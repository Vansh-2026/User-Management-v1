import {
  ActionSheetComponent,
  ActionSheetContentTemplateDirective,
  ActionSheetFooterTemplateDirective,
  ActionSheetHeaderTemplateDirective,
  ActionSheetTemplateDirective,
  ActionSheetViewComponent,
  AdaptiveService,
  AppBarComponent,
  AutoCompleteComponent,
  CheckBoxComponent,
  CustomMessagesComponent,
  DatePipe,
  DialogActionsComponent,
  DialogContainerService,
  DialogContentBase,
  DialogRef,
  DialogService,
  DragTargetContainerDirective,
  DropDownListComponent,
  DropTargetContainerDirective,
  ErrorComponent,
  FormFieldComponent,
  HintComponent,
  InputSpacerComponent,
  IntlService,
  KENDO_CHECKBOX,
  KENDO_FORMFIELD,
  KENDO_NUMERICTEXTBOX,
  KENDO_PAGER,
  KENDO_TEXTAREA,
  KENDO_TEXTBOX,
  NumericTextBoxComponent,
  NumericTextBoxCustomMessagesComponent,
  PagerComponent,
  PagerContextService,
  PagerFocusableDirective,
  PagerInfoComponent,
  PagerInputComponent,
  PagerNavigationService,
  PagerNextButtonsComponent,
  PagerNumericButtonsComponent,
  PagerPageSizesComponent,
  PagerPrevButtonsComponent,
  PagerSpacerComponent,
  PagerTemplateDirective,
  RadioButtonComponent,
  TextAreaComponent,
  TextAreaPrefixComponent,
  TextAreaSuffixComponent,
  TextBoxComponent,
  TextBoxPrefixTemplateDirective,
  WindowContainerService,
  WindowService,
  drawDOM,
  exportPDF,
  localeData,
  parseDate
} from "./chunk-LEETBGHI.js";
import {
  FormControl,
  FormControlDirective,
  FormGroup,
  FormGroupDirective,
  FormsModule,
  NG_VALIDATORS,
  NG_VALUE_ACCESSOR,
  NgControl,
  NgControlStatus,
  NgControlStatusGroup,
  NgForm,
  NgModel,
  ReactiveFormsModule,
  ɵNgNoValidate
} from "./chunk-SUSY775G.js";
import {
  KENDO_TOOLBAR,
  RefreshService,
  ToolBarButtonComponent,
  ToolBarButtonGroupComponent,
  ToolBarComponent,
  ToolBarDropDownButtonComponent,
  ToolBarSeparatorComponent,
  ToolBarSpacerComponent,
  ToolBarSplitButtonComponent,
  ToolBarToolComponent,
  ToolbarCustomMessagesComponent
} from "./chunk-GFRZJ52E.js";
import {
  AUTO_STYLE,
  AnimationBuilder,
  ButtonComponent,
  ChipComponent,
  ChipListComponent,
  DropDownButtonComponent,
  FloatingActionButtonComponent,
  IconComponent,
  IconWrapperComponent,
  IconsService,
  KENDO_BUTTON,
  KENDO_BUTTONS,
  KENDO_ICONS,
  KENDO_POPUP,
  POPUP_CONTAINER,
  PopupComponent,
  PopupService,
  SVGIconComponent,
  SpeechToTextButtonComponent,
  animate,
  arrowLeftIcon,
  arrowRightIcon,
  arrowRotateCcwIcon,
  arrowRotateCwIcon,
  arrowRotateCwSmallIcon,
  arrowsSwapIcon,
  calendarIcon,
  cancelIcon,
  cancelOutlineIcon,
  caretAltDownIcon,
  caretAltLeftIcon,
  caretAltRightIcon,
  caretAltUpIcon,
  checkCircleIcon,
  checkIcon,
  chevronDownIcon,
  chevronLeftIcon,
  chevronRightIcon,
  chevronUpIcon,
  clockIcon,
  columnsIcon,
  commentIcon,
  copyIcon,
  displayInlineFlexIcon,
  downloadIcon,
  exclamationCircleIcon,
  fileAudioIcon,
  fileConfigIcon,
  fileDataIcon,
  fileDiscImageIcon,
  fileExcelIcon,
  fileIcon,
  fileImageIcon,
  filePdfIcon,
  filePresentationIcon,
  fileProgrammingIcon,
  fileTxtIcon,
  fileVideoIcon,
  fileZipIcon,
  filterClearIcon,
  filterIcon,
  groupIcon,
  insertMiddleIcon,
  lockIcon,
  maxWidthIcon,
  menuIcon,
  minusIcon,
  moreHorizontalIcon,
  moreVerticalIcon,
  paperPlaneIcon,
  paperclipIcon,
  pauseSmIcon,
  pencilIcon,
  pinIcon,
  playSmIcon,
  plusCircleIcon,
  plusIcon,
  redoIcon,
  reorderIcon,
  saveIcon,
  searchIcon,
  setColumnPositionIcon,
  slidersIcon,
  sortAscSmallIcon,
  sortDescSmallIcon,
  sparklesIcon,
  state,
  stickIcon,
  stopSmIcon,
  style,
  tableWizardIcon,
  thumbDownIcon,
  thumbDownOutlineIcon,
  thumbUpIcon,
  thumbUpOutlineIcon,
  transition,
  trashIcon,
  trigger,
  undoIcon,
  unlockIcon,
  unstickIcon,
  uploadIcon,
  xCircleIcon,
  xIcon
} from "./chunk-QCW5GPZK.js";
import {
  DomSanitizer
} from "./chunk-5QJRNREK.js";
import {
  HttpClient,
  HttpEventType,
  HttpHeaders,
  HttpRequest,
  HttpResponse
} from "./chunk-6LJWVYYC.js";
import {
  ColumnBase,
  ColumnComponent,
  ColumnGroupComponent,
  FooterTemplateDirective,
  GroupFooterTemplateDirective,
  GroupHeaderColumnTemplateDirective,
  GroupHeaderTemplateDirective,
  saveAs,
  toDataURL,
  workbookOptions
} from "./chunk-P4VYZLGV.js";
import "./chunk-KVWCD4OJ.js";
import {
  ComponentMessages,
  L10N_PREFIX,
  LocalizationService,
  RTL
} from "./chunk-N5VTVND3.js";
import {
  Draggable,
  DraggableDirective,
  EventsOutsideAngularDirective,
  KENDO_TOGGLEBUTTONTABSTOP,
  KendoInput,
  Keys,
  MultiTabStop,
  PrefixTemplateDirective,
  PreventableEvent,
  ResizeBatchService,
  ResizeSensorComponent,
  ScrollbarWidthService,
  TemplateContextDirective,
  ToggleButtonTabStopDirective,
  WatermarkOverlayComponent,
  anyChanged,
  areObjectsEqual,
  closest,
  closestInScope,
  firefoxMaxHeight,
  focusableSelector,
  getLicenseMessage,
  getter,
  getter2,
  guid,
  hasClasses,
  hasObservers,
  isChanged,
  isControlRequired,
  isDocumentAvailable,
  isFirefox,
  isFocusable,
  isObject,
  isObjectPresent,
  isPresent,
  normalizeKeys,
  parseAttributes,
  parseCSSClassNames,
  processCssValue,
  removeHTMLAttributes,
  replaceMessagePlaceholder,
  setHTMLAttributes,
  shouldShowValidationUI,
  touchEnabled
} from "./chunk-GY4FWTVQ.js";
import {
  KeyValuePipe,
  NgClass,
  NgStyle,
  NgTemplateOutlet
} from "./chunk-GFDGTNHJ.js";
import "./chunk-2GFLEQ6X.js";
import {
  N
} from "./chunk-J6VOBU6M.js";
import {
  ChangeDetectionStrategy,
  ChangeDetectorRef,
  Component,
  ContentChild,
  ContentChildren,
  Directive,
  ElementRef,
  EventEmitter,
  Host,
  HostBinding,
  HostListener,
  Inject,
  Injectable,
  InjectionToken,
  Injector,
  Input,
  IterableDiffers,
  NgModule,
  NgZone,
  Optional,
  Output,
  Pipe,
  QueryList,
  Renderer2,
  SecurityContext,
  Self,
  SkipSelf,
  TemplateRef,
  ViewChild,
  ViewChildren,
  ViewContainerRef,
  ViewEncapsulation,
  forwardRef,
  inject,
  isDevMode,
  setClassMetadata,
  ɵɵInheritDefinitionFeature,
  ɵɵNgOnChangesFeature,
  ɵɵProvidersFeature,
  ɵɵadvance,
  ɵɵattribute,
  ɵɵclassMap,
  ɵɵclassProp,
  ɵɵcomponentInstance,
  ɵɵconditional,
  ɵɵconditionalCreate,
  ɵɵcontentQuery,
  ɵɵdefer,
  ɵɵdeferPrefetchOnIdle,
  ɵɵdeferWhen,
  ɵɵdefineComponent,
  ɵɵdefineDirective,
  ɵɵdefineInjectable,
  ɵɵdefineInjector,
  ɵɵdefineNgModule,
  ɵɵdefinePipe,
  ɵɵdirectiveInject,
  ɵɵdomElement,
  ɵɵdomElementContainerEnd,
  ɵɵdomElementContainerStart,
  ɵɵdomElementEnd,
  ɵɵdomElementStart,
  ɵɵdomListener,
  ɵɵdomProperty,
  ɵɵdomTemplate,
  ɵɵelement,
  ɵɵelementContainer,
  ɵɵelementContainerEnd,
  ɵɵelementContainerStart,
  ɵɵelementEnd,
  ɵɵelementStart,
  ɵɵgetCurrentView,
  ɵɵgetInheritedFactory,
  ɵɵi18nApply,
  ɵɵi18nAttributes,
  ɵɵi18nExp,
  ɵɵinject,
  ɵɵinterpolate,
  ɵɵinterpolate1,
  ɵɵinvalidFactory,
  ɵɵlistener,
  ɵɵloadQuery,
  ɵɵnamespaceHTML,
  ɵɵnamespaceSVG,
  ɵɵnextContext,
  ɵɵpipe,
  ɵɵpipeBind1,
  ɵɵpipeBind2,
  ɵɵpipeBind3,
  ɵɵprojection,
  ɵɵprojectionDef,
  ɵɵproperty,
  ɵɵpureFunction0,
  ɵɵpureFunction1,
  ɵɵpureFunction2,
  ɵɵpureFunction3,
  ɵɵpureFunction4,
  ɵɵpureFunction5,
  ɵɵpureFunction6,
  ɵɵpureFunction8,
  ɵɵpureFunctionV,
  ɵɵqueryRefresh,
  ɵɵreference,
  ɵɵrepeater,
  ɵɵrepeaterCreate,
  ɵɵrepeaterTrackByIdentity,
  ɵɵrepeaterTrackByIndex,
  ɵɵresetView,
  ɵɵrestoreView,
  ɵɵsanitizeUrl,
  ɵɵstyleMap,
  ɵɵstyleProp,
  ɵɵtemplate,
  ɵɵtemplateRefExtractor,
  ɵɵtext,
  ɵɵtextInterpolate,
  ɵɵtextInterpolate1,
  ɵɵtextInterpolate2,
  ɵɵtwoWayBindingSet,
  ɵɵtwoWayListener,
  ɵɵtwoWayProperty,
  ɵɵviewQuery
} from "./chunk-WASFMYUK.js";
import {
  BehaviorSubject,
  EMPTY,
  Observable,
  ReplaySubject,
  Subject,
  Subscription,
  __assign,
  __extends,
  __spreadArray,
  animationFrameScheduler,
  auditTime,
  bufferCount,
  combineLatest,
  debounceTime,
  delay,
  distinctUntilChanged,
  filter,
  flatMap,
  from,
  fromEvent,
  interval,
  map,
  merge,
  of,
  scan,
  skip,
  switchMap,
  switchMapTo,
  take,
  takeUntil,
  takeWhile,
  tap,
  throttleTime,
  zip
} from "./chunk-WNCK2WLC.js";
import {
  __spreadProps,
  __spreadValues
} from "./chunk-653SOEEV.js";

// node_modules/@progress/kendo-data-query/dist/es/utils.js
var isPresent2 = function(value2) {
  return value2 !== null && value2 !== void 0;
};
var isBlank = function(value2) {
  return value2 === null || value2 === void 0;
};
var isArray = function(value2) {
  return Array.isArray(value2);
};
var isFunction = function(value2) {
  return typeof value2 === "function";
};
var isString = function(value2) {
  return typeof value2 === "string";
};
var isNullOrEmptyString = function(value2) {
  return isBlank(value2) || value2.trim().length === 0;
};
var isNotNullOrEmptyString = function(value2) {
  return !isNullOrEmptyString(value2);
};
var isNumeric = function(value2) {
  return !isNaN(value2 - parseFloat(value2));
};
var isDate = function(value2) {
  return value2 && value2.getTime;
};

// node_modules/@progress/kendo-data-query/dist/es/filtering/filter-descriptor.interface.js
var isCompositeFilterDescriptor = function(source) {
  return isPresent2(source.filters);
};

// node_modules/@progress/kendo-data-query/dist/es/funcs.js
var ifElse = function(predicate, right2, left2) {
  return function(value2) {
    return predicate(value2) ? right2(value2) : left2(value2);
  };
};
var compose = function() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return function(data) {
    return args.reduceRight(function(acc, curr) {
      return curr(acc);
    }, data);
  };
};
var constant = function(x) {
  return function() {
    return x;
  };
};

// node_modules/@progress/kendo-data-query/dist/es/filter-serialization.common.js
var toUTC = function(date) {
  return new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
};
var isDateValue = function(x) {
  return isDate(x.value);
};

// node_modules/@progress/kendo-data-query/dist/es/filtering/filter.operators.js
var operatorMap = function(key) {
  return {
    "!=": "neq",
    "<": "lt",
    "<=": "lte",
    "==": "eq",
    ">": "gt",
    ">=": "gte",
    equal: "eq",
    equals: "eq",
    equalto: "eq",
    ge: "gte",
    greater: "gt",
    greaterthan: "gt",
    greaterthanequal: "gte",
    isempty: "isempty",
    isequalto: "eq",
    isgreaterthan: "gt",
    isgreaterthanorequalto: "gte",
    islessthan: "lt",
    islessthanorequalto: "lte",
    isnotempty: "isnotempty",
    isnotequalto: "neq",
    isnull: "isnull",
    le: "lte",
    less: "lt",
    lessthan: "lt",
    lessthanequal: "lte",
    ne: "neq",
    notequal: "neq",
    notequals: "neq",
    notequalto: "neq",
    notsubstringof: "doesnotcontain"
  }[key.toLowerCase()] || key;
};
var normalizeOperator = function(descriptor) {
  if (descriptor.filters) {
    descriptor.filters = descriptor.filters.map(function(filter3) {
      var result = Object.assign({}, filter3);
      if (!isCompositeFilterDescriptor(filter3) && isString(filter3.operator)) {
        result.operator = operatorMap(filter3.operator);
      }
      if (isCompositeFilterDescriptor(filter3)) {
        normalizeOperator(result);
      }
      return result;
    });
  }
};
var normalizeDescriptor = function(descriptor) {
  if (!isCompositeFilterDescriptor(descriptor)) {
    return {
      filters: isArray(descriptor) ? descriptor : [descriptor],
      logic: "and"
    };
  }
  return Object.assign({}, descriptor);
};
var normalizeFilters = function(descriptor) {
  if (isPresent2(descriptor)) {
    descriptor = normalizeDescriptor(descriptor);
    normalizeOperator(descriptor);
  }
  return descriptor;
};

// node_modules/@progress/kendo-data-query/dist/es/odata.operators.js
var emptyString = constant("");

// node_modules/@progress/kendo-data-query/dist/es/accessor.js
var getterCache = {};
var FIELD_REGEX = /\[(?:(\d+)|['"](.*?)['"])\]|((?:(?!\[.*?\]|\.).)+)/g;
getterCache["undefined"] = function(obj) {
  return obj;
};
var getter3 = function(field, safe) {
  var key = field + safe;
  if (getterCache[key]) {
    return getterCache[key];
  }
  var fields = [];
  field.replace(FIELD_REGEX, function(_, index, indexAccessor, field2) {
    fields.push(isPresent2(index) ? index : indexAccessor || field2);
    return void 0;
  });
  getterCache[key] = function(obj) {
    var result = obj;
    for (var idx4 = 0; idx4 < fields.length; idx4++) {
      result = result[fields[idx4]];
      if (!isPresent2(result) && safe) {
        return result;
      }
    }
    return result;
  };
  return getterCache[key];
};

// node_modules/@progress/kendo-data-query/dist/es/mvc/operators.js
var pairwise = function(key) {
  return function(value2) {
    return [key, value2];
  };
};
var empty = function() {
  return null;
};
var isNotEmptyArray = function(value2) {
  return isPresent2(value2) && isArray(value2) && value2.length > 0;
};
var has = function(accessor) {
  return function(value2) {
    return isPresent2(accessor(value2));
  };
};
var isNotEmpty = function(accessor) {
  return function(value2) {
    return isNotEmptyArray(accessor(value2));
  };
};
var runOrEmpty = function(predicate, fn) {
  return ifElse(predicate, fn, empty);
};
var calcPage = function(_a2) {
  var skip4 = _a2.skip, take4 = _a2.take;
  return Math.floor((skip4 || 0) / take4) + 1;
};
var formatDescriptors = function(accessor, formatter) {
  return function(state2) {
    return accessor(state2).map(formatter).join("~");
  };
};
var removeAfter = function(what) {
  return function(str) {
    return str.slice(0, str.indexOf(what));
  };
};
var replace = function(patterns) {
  return compose.apply(void 0, patterns.map(function(_a2) {
    var left2 = _a2[0], right2 = _a2[1];
    return function(s) {
      return s.replace(new RegExp(left2, "g"), right2);
    };
  }));
};
var sanitizeDateLiterals = replace([['"', ""], [":", "-"]]);
var removeAfterDot = removeAfter(".");
var directionFormatter = function(_a2) {
  var field = _a2.field, _b = _a2.dir, dir = _b === void 0 ? "asc" : _b;
  return "".concat(field, "-").concat(dir);
};
var aggregateFormatter = function(_a2) {
  var field = _a2.field, aggregate = _a2.aggregate;
  return "".concat(field, "-").concat(aggregate);
};
var take2 = getter3("take");
var aggregates = getter3("aggregates");
var skip2 = getter3("skip");
var group = getter3("group");
var sort = getter3("sort", true);
var formatSort = formatDescriptors(sort, directionFormatter);
var formatGroup = formatDescriptors(group, directionFormatter);
var formatAggregates = formatDescriptors(aggregates, aggregateFormatter);
var prefixDateValue = function(value2) {
  return "datetime'".concat(value2, "'");
};
var formatDateValue = compose(prefixDateValue, removeAfterDot, sanitizeDateLiterals, JSON.stringify, toUTC);
var formatDate = function(_a2) {
  var field = _a2.field, value2 = _a2.value, ignoreCase = _a2.ignoreCase, operator = _a2.operator;
  return {
    value: formatDateValue(value2),
    field,
    ignoreCase,
    operator
  };
};
var normalizeSort = function(state2) {
  return Object.assign({}, state2, {
    sort: (sort(state2) || []).filter(function(_a2) {
      var dir = _a2.dir;
      return isNotNullOrEmptyString(dir);
    })
  });
};
var transformSkip = compose(pairwise("page"), calcPage);
var transformTake = compose(pairwise("pageSize"), take2);
var transformGroup = compose(pairwise("group"), formatGroup);
var transformSort = compose(pairwise("sort"), formatSort);
var transformAggregates = compose(pairwise("aggregate"), formatAggregates);
var serializePage = runOrEmpty(has(skip2), transformSkip);
var serializePageSize = runOrEmpty(has(take2), transformTake);
var serializeGroup = runOrEmpty(isNotEmpty(group), transformGroup);
var serializeAggregates = runOrEmpty(has(aggregates), transformAggregates);
var serializeSort = compose(runOrEmpty(isNotEmpty(sort), transformSort), normalizeSort);
var filterFormatter = function(_a2) {
  var field = _a2.field, operator = _a2.operator, value2 = _a2.value;
  return "".concat(field, "~").concat(operator, "~").concat(value2);
};
var dateFormatter = ifElse(isDateValue, compose(filterFormatter, formatDate), filterFormatter);

// node_modules/@progress/kendo-data-query/dist/es/mvc/deserialization.js
var set = function(field, target, value2) {
  target[field] = value2;
  return target;
};
var toCamelCase = function(str) {
  return str.replace(/(^[A-Z])/g, function(_, g1) {
    return g1.toLowerCase();
  });
};
var prop = function(fieldName) {
  return function(obj) {
    var value2 = obj[fieldName];
    if (isPresent2(value2)) {
      return value2;
    }
    return obj[toCamelCase(fieldName)];
  };
};
var member = prop("Member");
var aggregateMethodName = prop("AggregateMethodName");
var value = prop("Value");
var convert = function(mapper) {
  return function(values) {
    return Object.keys(values).reduce(mapper.bind(null, values), {});
  };
};
var translateAggregate = convert(function(source, acc, field) {
  return set(field.toLowerCase(), acc, source[field]);
});
var translateAggregates = convert(function(source, acc, field) {
  return set(field, acc, translateAggregate(source[field]));
});
var valueOrDefault = function(value2, defaultValue) {
  return isPresent2(value2) ? value2 : defaultValue;
};
var normalizeGroup = function(group2) {
  return {
    aggregates: group2.Aggregates || group2.aggregates,
    field: group2.Member || group2.member || group2.field,
    hasSubgroups: group2.HasSubgroups || group2.hasSubgroups || false,
    items: group2.Items || group2.items,
    value: valueOrDefault(group2.Key, valueOrDefault(group2.key, group2.value))
  };
};
var translateGroup = compose(function(_a2) {
  var field = _a2.field, hasSubgroups = _a2.hasSubgroups, value2 = _a2.value, aggregates2 = _a2.aggregates, items = _a2.items;
  return {
    aggregates: translateAggregates(aggregates2),
    field,
    items: hasSubgroups ? items.map(translateGroup) : items,
    value: value2
  };
}, normalizeGroup);

// node_modules/@progress/kendo-data-query/dist/es/sorting/sort-array.operator.js
var compare = function(a, b) {
  if (isBlank(a)) {
    return a === b ? 0 : -1;
  }
  if (isBlank(b)) {
    return 1;
  }
  if (a.localeCompare) {
    return a.localeCompare(b);
  }
  return a > b ? 1 : a < b ? -1 : 0;
};
var compareDesc = function(a, b) {
  return compare(b, a);
};
var descriptorAsFunc = function(descriptor) {
  if (typeof descriptor.compare === "function") {
    return descriptor.compare;
  }
  var prop2 = getter3(descriptor.field, true);
  return function(a, b) {
    return (descriptor.dir === "asc" ? compare : compareDesc)(prop2(a), prop2(b));
  };
};
var initial = function(_a2, _b) {
  return 0;
};
var composeSortDescriptors = function(descriptors) {
  return descriptors.filter(function(x) {
    return isPresent2(x.dir) || isPresent2(x.compare);
  }).map(function(descriptor) {
    return descriptorAsFunc(descriptor);
  }).reduce(function(acc, curr) {
    return function(a, b) {
      return acc(a, b) || curr(a, b);
    };
  }, initial);
};

// node_modules/@progress/kendo-data-query/dist/es/transducers.js
var valueToString = function(value2) {
  value2 = isPresent2(value2) && value2.getTime ? value2.getTime() : value2;
  return value2 + "";
};
var groupCombinator = function(field) {
  var prop2 = getter3(field, true);
  var position2 = 0;
  return function(agg, value2) {
    agg[field] = agg[field] || {};
    var groupValue = prop2(value2);
    var key = valueToString(groupValue);
    var values = agg[field][key] || { __position: position2++, aggregates: {}, items: [], value: groupValue };
    values.items.push(value2);
    agg[field][key] = values;
    return agg;
  };
};
var expandAggregates = function(result) {
  if (result === void 0) {
    result = {};
  }
  Object.keys(result).forEach(function(field) {
    var aggregates2 = result[field];
    Object.keys(aggregates2).forEach(function(aggregate) {
      aggregates2[aggregate] = aggregates2[aggregate].result();
    });
  });
  return result;
};
var aggregatesFuncs = function(name) {
  return {
    average: function() {
      var value2 = 0;
      var count2 = 0;
      var hasValue = false;
      var firstNonNumeric = null;
      return {
        calc: function(curr) {
          if (isNumeric(curr)) {
            value2 += curr;
            count2++;
            hasValue = true;
          } else if (!hasValue && firstNonNumeric === null) {
            firstNonNumeric = curr;
          }
        },
        result: function() {
          return hasValue ? value2 / count2 : firstNonNumeric;
        }
      };
    },
    count: function() {
      var state2 = 0;
      return {
        calc: function() {
          return state2++;
        },
        result: function() {
          return state2;
        }
      };
    },
    max: function() {
      var state2 = Number.NEGATIVE_INFINITY;
      return {
        calc: function(value2) {
          state2 = isNumeric(state2) || isDate(state2) ? state2 : value2;
          if (state2 < value2 && (isNumeric(value2) || isDate(value2))) {
            state2 = value2;
          }
        },
        result: function() {
          return state2;
        }
      };
    },
    min: function() {
      var state2 = Number.POSITIVE_INFINITY;
      return {
        calc: function(value2) {
          state2 = isNumeric(state2) || isDate(state2) ? state2 : value2;
          if (state2 > value2 && (isNumeric(value2) || isDate(value2))) {
            state2 = value2;
          }
        },
        result: function() {
          return state2;
        }
      };
    },
    sum: function() {
      var state2 = 0;
      return {
        calc: function(value2) {
          value2 = isPresent2(value2) ? value2 : 0;
          state2 += value2;
        },
        result: function() {
          return state2;
        }
      };
    }
  }[name]();
};
var aggregatesCombinator = function(descriptors) {
  var functions = descriptors.map(function(descriptor) {
    var fieldAccessor = getter3(descriptor.field, true);
    var aggregateName = (descriptor.aggregate || "").toLowerCase();
    var aggregateAccessor = getter3(aggregateName, true);
    return function(state2, value2) {
      var fieldAggregates = state2[descriptor.field] || {};
      var aggregateFunction = aggregateAccessor(fieldAggregates) || aggregatesFuncs(aggregateName);
      aggregateFunction.calc(fieldAccessor(value2));
      fieldAggregates[descriptor.aggregate] = aggregateFunction;
      state2[descriptor.field] = fieldAggregates;
      return state2;
    };
  });
  return function(state2, value2) {
    return functions.reduce(function(agg, calc) {
      return calc(agg, value2);
    }, state2);
  };
};
var concat = function(arr, value2) {
  arr.push(value2);
  return arr;
};
var map2 = function(transform) {
  return (function(reduce) {
    return (function(acc, curr, index) {
      return reduce(acc, transform(curr, index));
    });
  });
};
var filter2 = function(predicate) {
  return (function(reduce) {
    return (function(acc, curr) {
      return predicate(curr) ? reduce(acc, curr) : acc;
    });
  });
};
var isTransformerResult = function(source) {
  return isPresent2(source.__value);
};
var reduced = function(x) {
  if (isTransformerResult(x)) {
    return x;
  }
  return {
    __value: x,
    reduced: true
  };
};
var take3 = function(count2) {
  return (function(reduce) {
    return (function(acc, curr) {
      return count2-- > 0 ? reduce(acc, curr) : reduced(acc);
    });
  });
};
var skip3 = function(count2) {
  return (function(reduce) {
    return (function(acc, curr) {
      return count2-- <= 0 ? reduce(acc, curr) : acc;
    });
  });
};
var exec = function(transform, initialValue, data) {
  var result = initialValue;
  for (var idx4 = 0, length_1 = data.length; idx4 < length_1; idx4++) {
    result = transform(result, data[idx4], idx4);
    if (isTransformerResult(result)) {
      result = result.__value;
      break;
    }
  }
  return result;
};

// node_modules/@progress/kendo-data-query/dist/es/grouping/aggregate.operators.js
var identity2 = map2(function(x) {
  return x;
});
var aggregateBy = function(data, descriptors, transformers) {
  if (descriptors === void 0) {
    descriptors = [];
  }
  if (transformers === void 0) {
    transformers = identity2;
  }
  var initialValue = {};
  if (!descriptors.length) {
    return initialValue;
  }
  var result = exec(transformers(aggregatesCombinator(descriptors)), initialValue, data);
  return expandAggregates(result);
};

// node_modules/@progress/kendo-data-query/dist/es/filtering/filter-no-eval.js
var logic = {
  "or": {
    concat: function(acc, fn) {
      return function(a) {
        return acc(a) || fn(a);
      };
    },
    identity: function() {
      return false;
    }
  },
  "and": {
    concat: function(acc, fn) {
      return function(a) {
        return acc(a) && fn(a);
      };
    },
    identity: function() {
      return true;
    }
  }
};
var operatorsMap = {
  contains: function(a, b) {
    return (a || "").indexOf(b) >= 0;
  },
  doesnotcontain: function(a, b) {
    return (a || "").indexOf(b) === -1;
  },
  doesnotendwith: function(a, b) {
    return (a || "").indexOf(b, (a || "").length - (b || "").length) < 0;
  },
  doesnotstartwith: function(a, b) {
    return (a || "").lastIndexOf(b, 0) === -1;
  },
  endswith: function(a, b) {
    return (a || "").indexOf(b, (a || "").length - (b || "").length) >= 0;
  },
  eq: function(a, b) {
    return a === b;
  },
  gt: function(a, b) {
    return a > b;
  },
  gte: function(a, b) {
    return a >= b;
  },
  isempty: function(a) {
    return a === "";
  },
  isnotempty: function(a) {
    return a !== "";
  },
  isnotnull: function(a) {
    return isPresent2(a);
  },
  isnull: function(a) {
    return isBlank(a);
  },
  lt: function(a, b) {
    return a < b;
  },
  lte: function(a, b) {
    return a <= b;
  },
  neq: function(a, b) {
    return a != b;
  },
  startswith: function(a, b) {
    return (a || "").lastIndexOf(b, 0) === 0;
  }
};
var dateRegExp = /^\/Date\((.*?)\)\/$/;
var convertValue = function(value2, ignoreCase) {
  if (value2 != null && isString(value2)) {
    var date = dateRegExp.exec(value2);
    if (date) {
      return (/* @__PURE__ */ new Date(+date[1])).getTime();
    } else if (ignoreCase) {
      return value2.toLowerCase();
    }
  } else if (value2 != null && isDate(value2)) {
    return value2.getTime();
  }
  return value2;
};
var typedGetter = function(prop2, value2, ignoreCase, operator) {
  if (!isPresent2(value2)) {
    return prop2;
  }
  var acc = prop2;
  if (isString(value2)) {
    var date = dateRegExp.exec(value2);
    if (date) {
      value2 = /* @__PURE__ */ new Date(+date[1]);
    } else {
      var isCustomOperator_1 = isFunction(operator);
      acc = function(a) {
        var x = prop2(a);
        if (x === null) {
          return x;
        }
        if (isCustomOperator_1 && isArray(x)) {
          return x;
        }
        var stringValue = typeof x === "string" ? x : x + "";
        return ignoreCase ? stringValue.toLowerCase() : stringValue;
      };
    }
  }
  if (isDate(value2)) {
    return function(a) {
      var x = acc(a);
      return isDate(x) ? x.getTime() : x;
    };
  }
  return acc;
};
var transformFilter = function(_a2) {
  var field = _a2.field, ignoreCase = _a2.ignoreCase, value2 = _a2.value, operator = _a2.operator;
  field = !isPresent2(field) ? function(a) {
    return a;
  } : field;
  ignoreCase = isPresent2(ignoreCase) ? ignoreCase : true;
  var itemProp = typedGetter(isFunction(field) ? field : getter3(field, true), value2, ignoreCase, operator);
  value2 = convertValue(value2, ignoreCase);
  var op = isFunction(operator) ? operator : operatorsMap[operator];
  return function(a) {
    return op(itemProp(a), value2, ignoreCase);
  };
};
var transformCompositeFilter = function(filter3) {
  var combiner = logic[filter3.logic];
  return filter3.filters.filter(isPresent2).map(function(x) {
    return isCompositeFilterDescriptor(x) ? transformCompositeFilter(x) : transformFilter(x);
  }).reduce(combiner.concat, combiner.identity);
};

// node_modules/@progress/kendo-data-query/dist/es/filtering/filter-expression.factory.js
var compileFilter = function(descriptor) {
  if (!descriptor || descriptor.filters.length === 0) {
    return function() {
      return true;
    };
  }
  return transformCompositeFilter(descriptor);
};
var filterBy = function(data, descriptor) {
  if (!isPresent2(descriptor) || isCompositeFilterDescriptor(descriptor) && descriptor.filters.length === 0) {
    return data;
  }
  return data.filter(compileFilter(normalizeFilters(descriptor)));
};

// node_modules/@progress/kendo-data-query/dist/es/grouping/group.operators.js
var normalizeGroups = function(descriptors) {
  descriptors = isArray(descriptors) ? descriptors : [descriptors];
  return descriptors.map(function(x) {
    return Object.assign({ dir: "asc" }, x);
  });
};
var identity3 = map2(function(x) {
  return x;
});
var groupBy = function(data, descriptors, transformers, originalData) {
  if (descriptors === void 0) {
    descriptors = [];
  }
  if (transformers === void 0) {
    transformers = identity3;
  }
  if (originalData === void 0) {
    originalData = data;
  }
  descriptors = normalizeGroups(descriptors);
  if (!descriptors.length) {
    return data;
  }
  var descriptor = descriptors[0];
  var initialValue = {};
  var view2 = exec(transformers(groupCombinator(descriptor.field)), initialValue, data);
  var result = [];
  Object.keys(view2).forEach(function(field) {
    Object.keys(view2[field]).forEach(function(value2) {
      var group2 = view2[field][value2];
      var aggregateResult = {};
      var filteredData = originalData;
      if (isPresent2(descriptor.aggregates)) {
        filteredData = filterBy(originalData, {
          field: descriptor.field,
          ignoreCase: false,
          operator: "eq",
          value: group2.value
        });
        aggregateResult = aggregateBy(filteredData, descriptor.aggregates);
      }
      result[group2.__position] = {
        aggregates: aggregateResult,
        field,
        items: descriptors.length > 1 ? groupBy(group2.items, descriptors.slice(1), identity3, filteredData) : group2.items,
        value: group2.value
      };
    });
  });
  if (isPresent2(descriptor.dir) || isPresent2(descriptor.compare)) {
    var comparer = composeSortDescriptors([{
      field: "value",
      dir: descriptor.dir,
      compare: descriptor.compare
    }]);
    result.sort(comparer);
  }
  return result;
};

// node_modules/@progress/kendo-data-query/dist/es/array.operators.js
var orderBy = function(data, descriptors) {
  if (descriptors.some(function(x) {
    return isPresent2(x.dir) || isPresent2(x.compare);
  })) {
    data = data.slice(0);
    var comparer = composeSortDescriptors(descriptors);
    data.sort(comparer);
  }
  return data;
};
var count = function(data, predicate) {
  var counter = 0;
  for (var idx4 = 0, length_1 = data.length; idx4 < length_1; idx4++) {
    if (predicate(data[idx4])) {
      counter++;
    }
  }
  return counter;
};
var limit = function(data, predicate) {
  if (predicate) {
    return data.filter(predicate);
  }
  return data;
};
var process = function(data, state2) {
  var skipCount = state2.skip, takeCount = state2.take, filterDescriptor = state2.filter, sort2 = state2.sort, group2 = state2.group;
  var sortDescriptors = __spreadArray(__spreadArray([], normalizeGroups(group2 || []), true), sort2 || [], true);
  if (sortDescriptors.length) {
    data = orderBy(data, sortDescriptors);
  }
  var hasFilters = isPresent2(filterDescriptor) && filter2.length;
  var hasGroups = isPresent2(group2) && group2.length;
  if (!hasFilters && !hasGroups) {
    return {
      data: takeCount ? data.slice(skipCount, skipCount + takeCount) : data,
      total: data.length
    };
  }
  var total;
  var transformers = [];
  var predicate;
  if (hasFilters) {
    predicate = compileFilter(normalizeFilters(filterDescriptor));
    total = count(data, predicate);
    transformers.push(filter2(predicate));
  } else {
    total = data.length;
  }
  if (isPresent2(skipCount) && isPresent2(takeCount)) {
    transformers.push(skip3(skipCount));
    transformers.push(take3(takeCount));
  }
  if (transformers.length) {
    var transform = compose.apply(void 0, transformers);
    var result = hasGroups ? groupBy(data, group2, transform, limit(data, predicate)) : exec(transform(concat), [], data);
    return { data: result, total };
  }
  return {
    data: hasGroups ? groupBy(data, group2) : data,
    total
  };
};

// node_modules/@progress/kendo-data-query/dist/es/filtering/operators.enum.js
var FilterOperator;
(function(FilterOperator2) {
  FilterOperator2["Contains"] = "contains";
  FilterOperator2["DoesNotContain"] = "doesnotcontain";
  FilterOperator2["DoesNotEndWith"] = "doesnotendwith";
  FilterOperator2["DoesNotStartWith"] = "doesnotstartwith";
  FilterOperator2["EndsWith"] = "endswith";
  FilterOperator2["EqualTo"] = "eq";
  FilterOperator2["GreaterThan"] = "gt";
  FilterOperator2["GreaterThanOrEqual"] = "gte";
  FilterOperator2["IsEmpty"] = "isempty";
  FilterOperator2["IsNotEmpty"] = "isnotempty";
  FilterOperator2["IsNotNull"] = "isnotnull";
  FilterOperator2["IsNull"] = "isnull";
  FilterOperator2["LessThan"] = "lt";
  FilterOperator2["LessThanOrEqual"] = "lte";
  FilterOperator2["NotEqualTo"] = "neq";
  FilterOperator2["StartsWith"] = "startswith";
})(FilterOperator || (FilterOperator = {}));

// node_modules/@progress/kendo-date-math/dist/es/clone-date.js
var cloneDate = function(date) {
  return date ? new Date(date.getTime()) : null;
};

// node_modules/@progress/kendo-date-math/dist/es/adjust-dst.js
var adjustDST = function(date, hour) {
  var newDate = cloneDate(date);
  if (hour === 0 && newDate.getHours() === 23) {
    newDate.setHours(newDate.getHours() + 2);
  }
  return newDate;
};

// node_modules/@progress/kendo-date-math/dist/es/add-days.js
var addDays = function(date, offset3) {
  var newDate = cloneDate(date);
  newDate.setDate(newDate.getDate() + offset3);
  return adjustDST(newDate, date.getHours());
};

// node_modules/@progress/kendo-date-math/dist/es/create-date.js
var createDate = function(year, month, day, hours, minutes, seconds, milliseconds) {
  if (hours === void 0) {
    hours = 0;
  }
  if (minutes === void 0) {
    minutes = 0;
  }
  if (seconds === void 0) {
    seconds = 0;
  }
  if (milliseconds === void 0) {
    milliseconds = 0;
  }
  var date = new Date(year, month, day, hours, minutes, seconds, milliseconds);
  if (year > -1 && year < 100) {
    date.setFullYear(date.getFullYear() - 1900);
  }
  return adjustDST(date, hours);
};

// node_modules/@progress/kendo-date-math/dist/es/last-day-of-month.js
var lastDayOfMonth = function(date) {
  var newDate = createDate(date.getFullYear(), date.getMonth() + 1, 1, date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
  return addDays(newDate, -1);
};

// node_modules/@progress/kendo-date-math/dist/es/add-months.js
var MONTHS_LENGTH = 12;
var normalize = function(date, expectedMonth) {
  return date.getMonth() !== expectedMonth ? lastDayOfMonth(addMonths(date, -1)) : date;
};
var addMonths = function(date, offset3) {
  var newDate = cloneDate(date);
  var diff = (newDate.getMonth() + offset3) % MONTHS_LENGTH;
  var expectedMonth = (MONTHS_LENGTH + diff) % MONTHS_LENGTH;
  newDate.setMonth(newDate.getMonth() + offset3);
  return normalize(adjustDST(newDate, date.getHours()), expectedMonth);
};

// node_modules/@progress/kendo-date-math/dist/es/set-year.js
var setYear = function(value2, year) {
  var month = value2.getMonth();
  var candidate = createDate(year, month, value2.getDate(), value2.getHours(), value2.getMinutes(), value2.getSeconds(), value2.getMilliseconds());
  return candidate.getMonth() === month ? candidate : lastDayOfMonth(addMonths(candidate, -1));
};

// node_modules/@progress/kendo-date-math/dist/es/add-years.js
var addYears = function(value2, offset3) {
  return adjustDST(setYear(value2, value2.getFullYear() + offset3), value2.getHours());
};

// node_modules/@progress/kendo-date-math/dist/es/add-centuries.js
var addCenturies = function(value2, offset3) {
  return addYears(value2, 100 * offset3);
};

// node_modules/@progress/kendo-date-math/dist/es/add-decades.js
var addDecades = function(value2, offset3) {
  return addYears(value2, 10 * offset3);
};

// node_modules/@progress/kendo-date-math/dist/es/add-weeks.js
var addWeeks = function(date, offset3) {
  return addDays(date, offset3 * 7);
};

// node_modules/@progress/kendo-date-math/dist/es/constants.js
var MS_PER_MINUTE = 6e4;
var MS_PER_HOUR = 36e5;
var MS_PER_DAY = 864e5;

// node_modules/@progress/kendo-date-math/dist/es/direction.enum.js
var Direction;
(function(Direction3) {
  Direction3[Direction3["Forward"] = 1] = "Forward";
  Direction3[Direction3["Backward"] = -1] = "Backward";
})(Direction || (Direction = {}));

// node_modules/@progress/kendo-date-math/dist/es/day-of-week.js
var dayOfWeek = function(date, weekDay, direction) {
  if (direction === void 0) {
    direction = Direction.Forward;
  }
  var newDate = cloneDate(date);
  var newDay = (weekDay - newDate.getDay() + 7 * direction) % 7;
  newDate.setDate(newDate.getDate() + newDay);
  return adjustDST(newDate, date.getHours());
};

// node_modules/@progress/kendo-date-math/dist/es/day.enum.js
var Day;
(function(Day2) {
  Day2[Day2["Sunday"] = 0] = "Sunday";
  Day2[Day2["Monday"] = 1] = "Monday";
  Day2[Day2["Tuesday"] = 2] = "Tuesday";
  Day2[Day2["Wednesday"] = 3] = "Wednesday";
  Day2[Day2["Thursday"] = 4] = "Thursday";
  Day2[Day2["Friday"] = 5] = "Friday";
  Day2[Day2["Saturday"] = 6] = "Saturday";
})(Day || (Day = {}));

// node_modules/@progress/kendo-date-math/dist/es/normalize-year.js
var normalizeYear = function(value2, year) {
  return setYear(value2, year(value2.getFullYear()));
};

// node_modules/@progress/kendo-date-math/dist/es/first-decade-of-century.js
var firstDecadeOfCentury = function(value2) {
  return normalizeYear(value2, function(y) {
    return y - y % 100;
  });
};

// node_modules/@progress/kendo-date-math/dist/es/duration-in-centuries.js
var durationInCenturies = function(start, end) {
  return (firstDecadeOfCentury(end).getFullYear() - firstDecadeOfCentury(start).getFullYear()) / 100;
};

// node_modules/@progress/kendo-date-math/dist/es/first-year-of-decade.js
var firstYearOfDecade = function(value2) {
  return normalizeYear(value2, function(y) {
    return y - y % 10;
  });
};

// node_modules/@progress/kendo-date-math/dist/es/duration-in-decades.js
var durationInDecades = function(start, end) {
  return (firstYearOfDecade(end).getFullYear() - firstYearOfDecade(start).getFullYear()) / 10;
};

// node_modules/@progress/kendo-date-math/dist/es/duration-in-months.js
var durationInMonths = function(start, end) {
  return (end.getFullYear() - start.getFullYear()) * 12 + (end.getMonth() - start.getMonth());
};

// node_modules/@progress/kendo-date-math/dist/es/duration-in-years.js
var durationInYears = function(start, end) {
  return end.getFullYear() - start.getFullYear();
};

// node_modules/@progress/kendo-date-math/dist/es/first-day-of-month.js
var firstDayOfMonth = function(date) {
  return createDate(date.getFullYear(), date.getMonth(), 1, date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
};

// node_modules/@progress/kendo-date-math/dist/es/set-month.js
var setMonth = function(value2, month) {
  var day = value2.getDate();
  var candidate = createDate(value2.getFullYear(), month, day, value2.getHours(), value2.getMinutes(), value2.getSeconds(), value2.getMilliseconds());
  return candidate.getDate() === day ? candidate : lastDayOfMonth(addMonths(candidate, -1));
};

// node_modules/@progress/kendo-date-math/dist/es/first-month-of-year.js
var firstMonthOfYear = function(value2) {
  return setMonth(value2, 0);
};

// node_modules/@progress/kendo-date-math/dist/es/get-date.js
var getDate = function(date) {
  return createDate(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0);
};

// node_modules/@progress/kendo-date-math/dist/es/is-equal.js
var isEqual = function(candidate, expected) {
  if (!candidate && !expected) {
    return true;
  }
  return candidate && expected && candidate.getTime() === expected.getTime();
};

// node_modules/@progress/kendo-date-math/dist/es/last-decade-of-century.js
var lastDecadeOfCentury = function(value2) {
  return normalizeYear(value2, function(y) {
    return y - y % 100 + 90;
  });
};

// node_modules/@progress/kendo-date-math/dist/es/last-month-of-year.js
var lastMonthOfYear = function(value2) {
  return setMonth(value2, 11);
};

// node_modules/@progress/kendo-date-math/dist/es/last-year-of-decade.js
var lastYearOfDecade = function(value2) {
  return normalizeYear(value2, function(y) {
    return y - y % 10 + 9;
  });
};

// node_modules/@progress/kendo-date-math/dist/es/prev-day-of-week.js
var prevDayOfWeek = function(date, weekDay) {
  return dayOfWeek(date, weekDay, Direction.Backward);
};

// node_modules/@progress/kendo-date-math/dist/es/tz/timezones.js
var timezones = {
  rules: {},
  titles: {},
  zones: {}
};

// node_modules/@progress/kendo-date-math/dist/es/tz/rule-to-date.js
var MONTHS = { Jan: 0, Feb: 1, Mar: 2, Apr: 3, May: 4, Jun: 5, Jul: 6, Aug: 7, Sep: 8, Oct: 9, Nov: 10, Dec: 11 };
var DAYS = { Sun: 0, Mon: 1, Tue: 2, Wed: 3, Thu: 4, Fri: 5, Sat: 6 };
var MS_PER_MINUTE2 = 6e4;
var ruleToDate = function(year, rule, zoneOffset) {
  var month = rule[3];
  var on = rule[4];
  var time = rule[5];
  var date;
  var ruleOffset = time[3] === "u" ? -zoneOffset * MS_PER_MINUTE2 : 0;
  if (!isNaN(on)) {
    date = new Date(Date.UTC(year, MONTHS[month], on, time[0], time[1], time[2]) + ruleOffset);
  } else if (on.indexOf("last") === 0) {
    date = new Date(Date.UTC(year, MONTHS[month] + 1, 1, time[0] - 24, time[1], time[2]) + ruleOffset);
    var targetDay = DAYS[on.substr(4, 3)];
    var ourDay = date.getUTCDay();
    date.setUTCDate(date.getUTCDate() + targetDay - ourDay - (targetDay > ourDay ? 7 : 0));
  } else if (on.indexOf(">=") >= 0) {
    date = new Date(Date.UTC(year, MONTHS[month], on.substr(5), time[0], time[1], time[2], 0) + ruleOffset);
    var targetDay = DAYS[on.substr(0, 3)];
    var ourDay = date.getUTCDay();
    date.setUTCDate(date.getUTCDate() + targetDay - ourDay + (targetDay < ourDay ? 7 : 0));
  }
  return date;
};

// node_modules/@progress/kendo-date-math/dist/es/tz/find-rule.js
var CURRENT_UTC_TIME = (/* @__PURE__ */ new Date()).getTime();
var findRule = function(zoneRule, utcTime, zoneOffset) {
  if (utcTime === void 0) {
    utcTime = CURRENT_UTC_TIME;
  }
  if (zoneOffset === void 0) {
    zoneOffset = 0;
  }
  var rules2 = timezones.rules[zoneRule];
  if (!rules2) {
    var time = zoneRule.split(":");
    var offset3 = 0;
    if (time.length > 1) {
      offset3 = time[0] * 60 + Number(time[1]);
    }
    return [-1e6, "max", "-", "Jan", 1, [0, 0, 0], offset3, "-"];
  }
  var year = new Date(utcTime).getUTCFullYear();
  rules2 = rules2.filter(function(currentRule) {
    var from2 = currentRule[0];
    var to = currentRule[1];
    return from2 <= year && (to >= year || from2 === year && to === "only" || to === "max");
  });
  rules2.push(utcTime);
  rules2.sort(function(a, b) {
    if (typeof a !== "number") {
      a = Number(ruleToDate(year, a, zoneOffset));
    }
    if (typeof b !== "number") {
      b = Number(ruleToDate(year, b, zoneOffset));
    }
    return a - b;
  });
  var rule = rules2[rules2.indexOf(utcTime) - 1] || rules2[rules2.length - 1];
  return isNaN(rule) ? rule : null;
};

// node_modules/@progress/kendo-date-math/dist/es/errors.js
var NO_TZ_INFO = "The required {0} timezone information is not provided!";
var formatRegExp = /\{(\d+)}?\}/g;
var flatten = function(arr) {
  return arr.reduce(function(a, b) {
    return a.concat(b);
  }, []);
};
var formatMessage = function(message) {
  var values = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    values[_i - 1] = arguments[_i];
  }
  var flattenValues = flatten(values);
  return message.replace(formatRegExp, function(_, index) {
    return flattenValues[parseInt(index, 10)];
  });
};

// node_modules/@progress/kendo-date-math/dist/es/tz/get-zone.js
var getZoneRules = function(timezone) {
  var zones = timezones.zones;
  if (!zones) {
    throw new Error(formatMessage(NO_TZ_INFO, timezone));
  }
  var zoneRules = zones[timezone];
  var result = typeof zoneRules === "string" ? zones[zoneRules] : zoneRules;
  if (!result) {
    throw new Error(formatMessage(NO_TZ_INFO, timezone));
  }
  return result;
};

// node_modules/@progress/kendo-date-math/dist/es/tz/find-zone.js
var findZone = function(timezone, utcTime) {
  if (utcTime === void 0) {
    utcTime = (/* @__PURE__ */ new Date()).getTime();
  }
  if (timezone === "Etc/UTC" || timezone === "Etc/GMT") {
    return [0, "-", "UTC", null];
  }
  var zoneRules = getZoneRules(timezone);
  var idx4 = zoneRules.length - 1;
  for (; idx4 >= 0; idx4--) {
    var until = zoneRules[idx4][3];
    if (until && utcTime > until) {
      break;
    }
  }
  var zone = zoneRules[idx4 + 1];
  if (!zone) {
    throw new Error(formatMessage(NO_TZ_INFO, timezone));
  }
  return zone;
};

// node_modules/@progress/kendo-date-math/dist/es/tz/zone-and-rule.js
var zoneAndRule = function(timezone, date) {
  var utcTime = date.getTime();
  var zone = findZone(timezone, utcTime);
  return {
    rule: findRule(zone[1], utcTime, zone[0]),
    zone
  };
};

// node_modules/@progress/kendo-date-math/dist/es/tz/pad-number.js
var padNumber = function(num, len) {
  if (len === void 0) {
    len = 2;
  }
  var sign = num < 0 ? "-" : "";
  return sign + new Array(len).concat([Math.abs(num)]).join("0").slice(-len);
};

// node_modules/@progress/kendo-date-math/dist/es/tz/abbr-timezone.js
var abbrTimezone = function(timezone, date) {
  if (date === void 0) {
    date = /* @__PURE__ */ new Date();
  }
  if (timezone === "Etc/UTC") {
    return "UTC";
  }
  if (timezone === "Etc/GMT") {
    return "GMT";
  }
  if (timezone === "") {
    return "";
  }
  var _a2 = zoneAndRule(timezone, date), zone = _a2.zone, rule = _a2.rule;
  var base = zone[2];
  if (base.indexOf("/") >= 0) {
    return base.split("/")[rule && +rule[6] ? 1 : 0];
  } else if (base.indexOf("%s") >= 0) {
    return base.replace("%s", !rule || rule[7] === "-" ? "" : rule[7]);
  } else if (base.indexOf("%z") >= 0) {
    var hours = -1 * Math.trunc(zone[0] / 60);
    var hoursPart = padNumber(hours, 2);
    var signPart = hours > 0 ? "+" : "";
    var minutes = Math.abs(Math.trunc(zone[0] % 60));
    var minutesPart = minutes === 0 ? "" : padNumber(minutes, 2);
    return base.replace("%z", "".concat(signPart).concat(hoursPart).concat(minutesPart));
  }
  return base;
};

// node_modules/@progress/kendo-date-math/dist/es/tz/offset.js
var offset = function(timezone, date) {
  if (date === void 0) {
    date = /* @__PURE__ */ new Date();
  }
  if (timezone === "Etc/UTC" || timezone === "Etc/GMT") {
    return 0;
  }
  if (timezone === "") {
    return date.getTimezoneOffset();
  }
  var _a2 = zoneAndRule(timezone, date), rule = _a2.rule, zone = _a2.zone;
  return parseFloat(rule ? zone[0] - rule[6] : zone[0]);
};

// node_modules/@progress/kendo-date-math/dist/es/tz/to-local-date.js
function toLocalDate(date) {
  return new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
}

// node_modules/@progress/kendo-date-math/dist/es/tz/zoned-date.js
var addMinutes = function(date, minutes) {
  return new Date(date.getTime() + minutes * MS_PER_MINUTE);
};
var addHours = function(date, hours) {
  return new Date(date.getTime() + hours * MS_PER_HOUR);
};
var dayAbbr = [
  "Sun",
  "Mon",
  "Tue",
  "Wed",
  "Thu",
  "Fri",
  "Sat"
];
var monthAbbr = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
var datePrefix = function(utcDate) {
  return dayAbbr[utcDate.getUTCDay()] + " " + monthAbbr[utcDate.getUTCMonth()];
};
function isZoneMissingHour(date, timezone) {
  var currentOffset = offset(timezone, date);
  var prevHour = addHours(date, -1);
  var prevOffset = offset(timezone, prevHour);
  return currentOffset < prevOffset;
}
function shiftZoneMissingHour(utcDate, timezone) {
  var dstOffset = isZoneMissingHour(utcDate, timezone) ? 1 : 0;
  return addHours(utcDate, dstOffset);
}
function convertTimezoneUTC(utcLocal, fromTimezone, toTimezone) {
  if (fromTimezone === toTimezone) {
    return utcLocal;
  }
  var fromOffset = offset(fromTimezone, utcLocal);
  var toOffset = offset(toTimezone, utcLocal);
  var baseDiff = fromOffset - toOffset;
  var midDate = addMinutes(utcLocal, baseDiff);
  var midOffset = offset(toTimezone, midDate);
  var dstDiff = toOffset - midOffset;
  return addMinutes(utcLocal, baseDiff + dstDiff);
}
function formatOffset(tzOffset) {
  var sign = tzOffset <= 0 ? "+" : "-";
  var value2 = Math.abs(tzOffset);
  var hours = padNumber(Math.floor(value2 / 60));
  var minutes = padNumber(value2 % 60);
  return "GMT".concat(sign).concat(hours).concat(minutes);
}
var ZonedDate = (
  /** @class */
  (function() {
    function ZonedDate2(utcDate, timezone) {
      this._utcDate = cloneDate(utcDate);
      this.timezone = timezone;
      var tzOffset = offset(timezone, utcDate);
      this.timezoneOffset = tzOffset;
      var localDate = shiftZoneMissingHour(utcDate, timezone);
      this._localDate = convertTimezoneUTC(localDate, timezone, "Etc/UTC");
    }
    Object.defineProperty(ZonedDate2.prototype, "cachedLocalDate", {
      /**
       * Returns a cached local date that denotes the exact time in the set timezone.
       *
       * @return Date - A local date that denotes the exact time in the set timezone.
       *
       * This property is an alternative to `toLocalDate()` that returns a cached value instead of cloning it.
       *
       * > Modifying the returned instance will corrupt the `ZonedDate` state.
       */
      get: function() {
        return this._localDate;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ZonedDate2.prototype, "cachedUTCDate", {
      /**
       * Returns a cached `Date` instance with UTC date parts that are set to the local time in the set timezone.
       *
       * @returns Date - A `Date` with UTC date parts that are set to the local time in the set timezone.
       *
       * This property is an alternative to `toUTCDate()` that returns a cached value instead of cloning it.
       *
       * > Modifying the returned instance will corrupt the `ZonedDate` state.
       */
      get: function() {
        return this._utcDate;
      },
      enumerable: false,
      configurable: true
    });
    ZonedDate2.fromLocalDate = function(date, timezone) {
      if (timezone === void 0) {
        timezone = "";
      }
      var utcDate = convertTimezoneUTC(date, "Etc/UTC", timezone);
      var shiftZone = isZoneMissingHour(utcDate, timezone);
      var zoneOffset = offset(timezone, utcDate);
      var fixedOffset = 0;
      if (shiftZone) {
        fixedOffset = zoneOffset > 0 ? -1 : 1;
      }
      var adjDate = addHours(utcDate, fixedOffset);
      return ZonedDate2.fromUTCDate(adjDate, timezone);
    };
    ZonedDate2.fromUTCDate = function(utcDate, timezone) {
      if (timezone === void 0) {
        timezone = "";
      }
      return new ZonedDate2(utcDate, timezone);
    };
    ZonedDate2.prototype.toLocalDate = function() {
      return cloneDate(this._localDate);
    };
    ZonedDate2.prototype.toUTCDate = function() {
      return cloneDate(this._utcDate);
    };
    ZonedDate2.prototype.toTimezone = function(toTimezone) {
      if (this.timezone === toTimezone) {
        return this.clone();
      }
      var tzOffset = offset(this.timezone, this._utcDate);
      var date = addMinutes(this._utcDate, tzOffset);
      return ZonedDate2.fromLocalDate(date, toTimezone);
    };
    ZonedDate2.prototype.clone = function() {
      return ZonedDate2.fromUTCDate(this._utcDate, this.timezone);
    };
    ZonedDate2.prototype.addDays = function(days) {
      var newDate = new Date(this._utcDate.getTime());
      newDate.setUTCDate(newDate.getUTCDate() + days);
      return ZonedDate2.fromUTCDate(newDate, this.timezone);
    };
    ZonedDate2.prototype.addTime = function(milliseconds) {
      var utcDate = new Date(this._utcDate.getTime());
      var utcMid = shiftZoneMissingHour(utcDate, this.timezone);
      utcMid.setTime(utcMid.getTime() + milliseconds);
      var utcResult = shiftZoneMissingHour(utcMid, this.timezone);
      return ZonedDate2.fromUTCDate(utcResult, this.timezone);
    };
    ZonedDate2.prototype.stripTime = function() {
      var date = this._utcDate;
      var ticks = Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), 0, 0, 0);
      return ZonedDate2.fromUTCDate(new Date(ticks), this.timezone);
    };
    ZonedDate2.prototype.getTime = function() {
      return this._localDate.getTime();
    };
    ZonedDate2.prototype.getTimezoneOffset = function() {
      return this.timezoneOffset;
    };
    ZonedDate2.prototype.getFullYear = function() {
      return this._utcDate.getUTCFullYear();
    };
    ZonedDate2.prototype.getMonth = function() {
      return this._utcDate.getUTCMonth();
    };
    ZonedDate2.prototype.getDate = function() {
      return this._utcDate.getUTCDate();
    };
    ZonedDate2.prototype.getDay = function() {
      return this._utcDate.getUTCDay();
    };
    ZonedDate2.prototype.getHours = function() {
      return this._utcDate.getUTCHours();
    };
    ZonedDate2.prototype.getMinutes = function() {
      return this._utcDate.getUTCMinutes();
    };
    ZonedDate2.prototype.getSeconds = function() {
      return this._utcDate.getUTCSeconds();
    };
    ZonedDate2.prototype.getMilliseconds = function() {
      return this._utcDate.getUTCMilliseconds();
    };
    ZonedDate2.prototype.getUTCDate = function() {
      return this._localDate.getUTCDate();
    };
    ZonedDate2.prototype.getUTCDay = function() {
      return this._localDate.getUTCDay();
    };
    ZonedDate2.prototype.getUTCFullYear = function() {
      return this._localDate.getUTCFullYear();
    };
    ZonedDate2.prototype.getUTCHours = function() {
      return this._localDate.getUTCHours();
    };
    ZonedDate2.prototype.getUTCMilliseconds = function() {
      return this._localDate.getUTCMilliseconds();
    };
    ZonedDate2.prototype.getUTCMinutes = function() {
      return this._localDate.getUTCMinutes();
    };
    ZonedDate2.prototype.getUTCMonth = function() {
      return this._localDate.getUTCMonth();
    };
    ZonedDate2.prototype.getUTCSeconds = function() {
      return this._localDate.getUTCSeconds();
    };
    ZonedDate2.prototype.setTime = function(time) {
      throw new Error("Method not implemented.");
    };
    ZonedDate2.prototype.setMilliseconds = function(ms) {
      throw new Error("Method not implemented.");
    };
    ZonedDate2.prototype.setUTCMilliseconds = function(ms) {
      throw new Error("Method not implemented.");
    };
    ZonedDate2.prototype.setSeconds = function(sec, ms) {
      throw new Error("Method not implemented.");
    };
    ZonedDate2.prototype.setUTCSeconds = function(sec, ms) {
      throw new Error("Method not implemented.");
    };
    ZonedDate2.prototype.setMinutes = function(min, sec, ms) {
      throw new Error("Method not implemented.");
    };
    ZonedDate2.prototype.setUTCMinutes = function(min, sec, ms) {
      throw new Error("Method not implemented.");
    };
    ZonedDate2.prototype.setHours = function(hours, min, sec, ms) {
      throw new Error("Method not implemented.");
    };
    ZonedDate2.prototype.setUTCHours = function(hours, min, sec, ms) {
      throw new Error("Method not implemented.");
    };
    ZonedDate2.prototype.setDate = function(date) {
      throw new Error("Method not implemented.");
    };
    ZonedDate2.prototype.setUTCDate = function(date) {
      throw new Error("Method not implemented.");
    };
    ZonedDate2.prototype.setMonth = function(month, date) {
      throw new Error("Method not implemented.");
    };
    ZonedDate2.prototype.setUTCMonth = function(month, date) {
      throw new Error("Method not implemented.");
    };
    ZonedDate2.prototype.setFullYear = function(year, month, date) {
      throw new Error("Method not implemented.");
    };
    ZonedDate2.prototype.setUTCFullYear = function(year, month, date) {
      throw new Error("Method not implemented.");
    };
    ZonedDate2.prototype.toISOString = function() {
      return this._localDate.toISOString();
    };
    ZonedDate2.prototype.toJSON = function() {
      return this._localDate.toJSON();
    };
    ZonedDate2.prototype.toString = function() {
      var dateString = datePrefix(this._utcDate);
      var timeString = this.toTimeString();
      return "".concat(dateString, " ").concat(this.getDate(), " ").concat(this.getFullYear(), " ").concat(timeString);
    };
    ZonedDate2.prototype.toDateString = function() {
      return toLocalDate(this._utcDate).toDateString();
    };
    ZonedDate2.prototype.toTimeString = function() {
      var hours = padNumber(this.getHours());
      var minutes = padNumber(this.getMinutes());
      var seconds = padNumber(this.getSeconds());
      var time = "".concat(hours, ":").concat(minutes, ":").concat(seconds);
      var tzOffset = formatOffset(this.timezoneOffset);
      var abbrev = abbrTimezone(this.timezone, this._utcDate);
      if (abbrev) {
        abbrev = " (".concat(abbrev, ")");
      }
      return "".concat(time, " ").concat(tzOffset).concat(abbrev);
    };
    ZonedDate2.prototype.toLocaleString = function(locales, options) {
      return this._localDate.toLocaleString(locales, options);
    };
    ZonedDate2.prototype.toLocaleDateString = function(locales, options) {
      return this._localDate.toLocaleDateString(locales, options);
    };
    ZonedDate2.prototype.toLocaleTimeString = function(locales, options) {
      return this._localDate.toLocaleTimeString(locales, options);
    };
    ZonedDate2.prototype.toUTCString = function() {
      return this.toTimezone("Etc/UTC").toString();
    };
    ZonedDate2.prototype[Symbol.toPrimitive] = function(hint) {
      if (hint === "string" || hint === "default") {
        return this.toString();
      }
      return this._localDate.getTime();
    };
    ZonedDate2.prototype.valueOf = function() {
      return this.getTime();
    };
    ZonedDate2.prototype.getVarDate = function() {
      throw new Error("Not implemented.");
    };
    ZonedDate2.prototype.format = function(_) {
      throw new Error("Not implemented.");
    };
    ZonedDate2.prototype.formatUTC = function(_) {
      throw new Error("Not implemented.");
    };
    return ZonedDate2;
  })()
);

// node_modules/@progress/kendo-date-math/dist/es/week-in-year.js
var moveDateToWeekStart = function(date, weekStartDay) {
  if (weekStartDay !== Day.Monday) {
    return addDays(prevDayOfWeek(date, weekStartDay), 4);
  }
  return addDays(date, 4 - (date.getDay() || 7));
};
var calcWeekInYear = function(date, weekStartDay) {
  var firstWeekInYear = createDate(date.getFullYear(), 0, 1, -6);
  var newDate = moveDateToWeekStart(date, weekStartDay);
  var diffInMS = newDate.getTime() - firstWeekInYear.getTime();
  var days = Math.floor(diffInMS / MS_PER_DAY);
  return 1 + Math.floor(days / 7);
};
var weekInYear = function(date, weekStartDay) {
  if (weekStartDay === void 0) {
    weekStartDay = Day.Monday;
  }
  date = getDate(date);
  var prevWeekDate = addDays(date, -7);
  var nextWeekDate = addDays(date, 7);
  var weekNumber = calcWeekInYear(date, weekStartDay);
  if (weekNumber === 0) {
    return calcWeekInYear(prevWeekDate, weekStartDay) + 1;
  }
  if (weekNumber === 53 && calcWeekInYear(nextWeekDate, weekStartDay) > 1) {
    return 1;
  }
  return weekNumber;
};

// node_modules/@progress/kendo-dateinputs-common/dist/es/common/mask.js
var Mask = (
  /** @class */
  /* @__PURE__ */ (function() {
    function Mask2() {
      this.symbols = "";
      this.partMap = [];
    }
    return Mask2;
  })()
);

// node_modules/@progress/kendo-dateinputs-common/dist/es/common/constants.js
var Constants = {
  formatSeparator: "_",
  twoDigitYearMax: 68,
  defaultDateFormat: "d",
  defaultLocaleId: "en"
};

// node_modules/@progress/kendo-dateinputs-common/dist/es/common/key.js
var Key = {
  DELETE: "Delete",
  BACKSPACE: "Backspace",
  TAB: "Tab",
  ENTER: "Enter",
  ESCAPE: "Escape",
  ARROW_LEFT: "ArrowLeft",
  ARROW_UP: "ArrowUp",
  ARROW_RIGHT: "ArrowRight",
  ARROW_DOWN: "ArrowDown",
  SPACE: " ",
  END: "End",
  HOME: "Home",
  PAGE_UP: "PageUp",
  PAGE_DOWN: "PageDown"
};

// node_modules/@progress/kendo-dateinputs-common/dist/es/dateinput/utils.js
var padZero = function(length2) {
  return new Array(Math.max(length2, 0)).fill("0").join("");
};
var unpadZero = function(value2) {
  return value2.replace(/^0*/, "");
};
var approximateStringMatching = function(_a2) {
  var oldText = _a2.oldText, newText = _a2.newText, formatPattern = _a2.formatPattern, selectionStart = _a2.selectionStart, isInCaretMode = _a2.isInCaretMode, keyEvent = _a2.keyEvent;
  var oldIndex = selectionStart + oldText.length - newText.length;
  var oldTextSeparator = oldText[oldIndex];
  var oldSegmentText = oldText.substring(0, oldIndex);
  var newSegmentText = newText.substring(0, selectionStart);
  var diff = [];
  if (oldSegmentText === newSegmentText && selectionStart > 0) {
    diff.push([formatPattern[selectionStart - 1], newSegmentText[selectionStart - 1]]);
    return diff;
  }
  if (oldSegmentText.indexOf(newSegmentText) === 0 && (isInCaretMode && (keyEvent.key === Key.DELETE || keyEvent.key === Key.BACKSPACE)) || oldSegmentText.indexOf(newSegmentText) === 0 && !isInCaretMode && (newSegmentText.length === 0 || formatPattern[newSegmentText.length - 1] !== formatPattern[newSegmentText.length])) {
    var deletedSymbol = "";
    if (!isInCaretMode && newSegmentText.length === 1) {
      diff.push([formatPattern[0], newSegmentText[0]]);
    }
    for (var i = newSegmentText.length; i < oldSegmentText.length; i++) {
      if (formatPattern[i] !== deletedSymbol && formatPattern[i] !== Constants.formatSeparator) {
        deletedSymbol = formatPattern[i];
        diff.push([deletedSymbol, ""]);
      }
    }
    return diff;
  }
  if (isInCaretMode && (newSegmentText.indexOf(oldSegmentText) === 0 || formatPattern[selectionStart - 1] === Constants.formatSeparator) || !isInCaretMode && (newSegmentText.indexOf(oldSegmentText) === 0 || formatPattern[selectionStart - 1] === Constants.formatSeparator)) {
    var symbol = formatPattern[0];
    for (var i = Math.max(0, oldSegmentText.length - 1); i < formatPattern.length; i++) {
      if (formatPattern[i] !== Constants.formatSeparator) {
        symbol = formatPattern[i];
        break;
      }
    }
    return [[symbol, newSegmentText[selectionStart - 1]]];
  }
  if (newSegmentText[newSegmentText.length - 1] === " " || newSegmentText[newSegmentText.length - 1] === oldTextSeparator && formatPattern[oldIndex] === "_") {
    return [[formatPattern[selectionStart - 1], Constants.formatSeparator]];
  }
  var result = [[formatPattern[selectionStart - 1], newSegmentText[selectionStart - 1]]];
  return result;
};
var dateSymbolMap = function(map3, part) {
  map3[part.pattern[0]] = part.type;
  return map3;
};

// node_modules/@progress/kendo-dateinputs-common/dist/es/common/utils.js
var dateSetter = function(method) {
  return function(date, value2) {
    var clone = cloneDate(date);
    clone[method](value2);
    return clone;
  };
};
var isPresent3 = function(value2) {
  return value2 !== void 0 && value2 !== null;
};
var isDocumentAvailable2 = function() {
  return !!document;
};
var isNumber = function(value2) {
  return isPresent3(value2) && typeof value2 === "number" && !Number.isNaN(value2);
};
var parseToInt = function(value2) {
  return parseInt(value2, 10);
};
var isParseableToInt = function(value2) {
  return isNumber(parseToInt(value2)) && /^[0-9]+$/.test(value2);
};
var clamp = function(value2, min, max) {
  return Math.min(max, Math.max(min, value2));
};
var extend = function() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return Object.assign.apply(Object, args);
};
var isFunction2 = function(fn) {
  return typeof fn === "function";
};
var cropTwoDigitYear = function(date) {
  if (!isPresent3(date) || isNaN(date.getTime())) {
    return 0;
  }
  return Number(date.getFullYear().toString().slice(-2));
};
var setYears = dateSetter("setFullYear");
var millisecondDigitsInFormat = function(format) {
  var result = format && format.match(/S+(\1)/);
  return result ? result[0].length : 0;
};
var millisecondStepFor = function(digits) {
  return Math.pow(10, 3 - digits);
};
var areDatePartsEqualTo = function(date, year, month, day, hour, minutes, seconds, milliseconds) {
  if (date && date.getFullYear() === year && date.getMonth() === month && date.getDate() === day && date.getHours() === hour && date.getMinutes() === minutes && date.getSeconds() === seconds && date.getMilliseconds() === milliseconds) {
    return true;
  }
  return false;
};
var isValidDate = function(value2) {
  return isPresent3(value2) && value2.getTime && isNumber(value2.getTime());
};
var isIOS = function() {
  return /iPad|iPhone|iPod/.test(navigator.userAgent) || navigator.maxTouchPoints && navigator.maxTouchPoints > 2 && /Macintosh/i.test(navigator.userAgent);
};

// node_modules/@progress/kendo-dateinputs-common/dist/es/common/dateobject.js
var MONTH_INDEX_FEBRUARY = 1;
var DEFAULT_LEAP_YEAR = 2e3;
var PREVIOUS_CENTURY_BASE = 1900;
var CURRENT_CENTURY_BASE = 2e3;
var SHORT_PATTERN_LENGTH_REGEXP = /d|M|H|h|m|s/;
var MONTH_PART_WITH_WORDS_THRESHOLD = 2;
var MONTH_SYMBOL = "M";
var JS_MONTH_OFFSET = 1;
var DateObject = (
  /** @class */
  (function() {
    function DateObject2(_a2) {
      var intlService = _a2.intlService, formatPlaceholder = _a2.formatPlaceholder, format = _a2.format, _b = _a2.cycleTime, cycleTime = _b === void 0 ? false : _b, _c = _a2.twoDigitYearMax, twoDigitYearMax = _c === void 0 ? Constants.twoDigitYearMax : _c, _d = _a2.value, value2 = _d === void 0 ? null : _d, _e = _a2.autoCorrectParts, autoCorrectParts = _e === void 0 ? true : _e, _f = _a2.toggleDayPeriod, toggleDayPeriod = _f === void 0 ? false : _f, _g = _a2.autoSwitchParts, autoSwitchParts = _g === void 0 ? true : _g;
      this.year = true;
      this.month = true;
      this.date = true;
      this.hours = true;
      this.minutes = true;
      this.seconds = true;
      this.milliseconds = true;
      this.dayperiod = true;
      this.leadingZero = null;
      this.typedMonthPart = "";
      this.knownParts = "adHhmMsEyS";
      this.symbols = {
        "E": "E",
        "H": "H",
        "M": "M",
        "a": "a",
        "d": "d",
        "h": "h",
        "m": "m",
        "s": "s",
        "y": "y",
        "S": "S"
      };
      this._value = this.getDefaultDate();
      this.cycleTime = false;
      this._partiallyInvalidDate = {
        startDate: null,
        invalidDateParts: {
          "E": { value: null, date: null, startDateOffset: 0 },
          "H": { value: null, date: null, startDateOffset: 0 },
          "M": { value: null, date: null, startDateOffset: 0 },
          "a": { value: null, date: null, startDateOffset: 0 },
          "d": { value: null, date: null, startDateOffset: 0 },
          "h": { value: null, date: null, startDateOffset: 0 },
          "m": { value: null, date: null, startDateOffset: 0 },
          "s": { value: null, date: null, startDateOffset: 0 },
          "y": { value: null, date: null, startDateOffset: 0 },
          "S": { value: null, date: null, startDateOffset: 0 }
        }
      };
      this.setOptions({
        intlService,
        formatPlaceholder,
        format,
        cycleTime,
        twoDigitYearMax,
        value: value2,
        autoCorrectParts,
        toggleDayPeriod,
        autoSwitchParts
      });
      if (!value2) {
        this._value = this.getDefaultDate();
        var sampleFormat = this.dateFormatString(this.value, this.format).symbols;
        for (var i = 0; i < sampleFormat.length; i++) {
          this.setExisting(sampleFormat[i], false);
        }
      } else {
        this._value = cloneDate(value2);
      }
    }
    Object.defineProperty(DateObject2.prototype, "value", {
      get: function() {
        return this._value;
      },
      set: function(value2) {
        if (value2 && !(value2 instanceof Date)) {
          return;
        }
        this._value = value2;
        this.resetInvalidDate();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DateObject2.prototype, "localeId", {
      get: function() {
        var localeId = Constants.defaultLocaleId;
        var cldrKeys = Object.keys(this.intl.cldr);
        for (var i = 0; i < cldrKeys.length; i++) {
          var key = cldrKeys[i];
          var value2 = this.intl.cldr[key];
          if (value2.name && value2.calendar && value2.numbers && value2.name !== Constants.defaultLocaleId) {
            localeId = value2.name;
            break;
          }
        }
        return localeId;
      },
      enumerable: false,
      configurable: true
    });
    DateObject2.prototype.setOptions = function(options) {
      this.intl = options.intlService;
      this.formatPlaceholder = options.formatPlaceholder || "wide";
      this.format = options.format;
      this.cycleTime = options.cycleTime;
      this.monthNames = this.allFormattedMonths(this.localeId);
      this.dayPeriods = this.allDayPeriods(this.localeId);
      this.twoDigitYearMax = options.twoDigitYearMax;
      this.autoCorrectParts = options.autoCorrectParts;
      this.toggleDayPeriod = options.toggleDayPeriod;
      this.autoSwitchParts = options.autoSwitchParts;
    };
    DateObject2.prototype.setValue = function(value2) {
      if (!value2) {
        this._value = this.getDefaultDate();
        this.modifyExisting(false);
      } else if (!isEqual(value2, this._value)) {
        this._value = cloneDate(value2);
        this.modifyExisting(true);
      } else if (isEqual(value2, this._value) && this.dayPeriods) {
        this.setExisting("a", true);
      }
      this.resetInvalidDate();
    };
    DateObject2.prototype.hasValue = function() {
      var _this = this;
      var pred = function(a, p) {
        return a || p.type !== "literal" && p.type !== "dayperiod" && _this.getExisting(p.pattern[0]);
      };
      return this.intl.splitDateFormat(this.format, this.localeId).reduce(pred, false);
    };
    DateObject2.prototype.getValue = function() {
      for (var i = 0; i < this.knownParts.length; i++) {
        if (!this.getExisting(this.knownParts[i])) {
          return null;
        }
      }
      return cloneDate(this.value);
    };
    DateObject2.prototype.createDefaultDate = function() {
      return createDate(DEFAULT_LEAP_YEAR, 0, 31);
    };
    DateObject2.prototype.getDefaultDate = function() {
      return getDate(this.createDefaultDate());
    };
    DateObject2.prototype.getFormattedDate = function(format) {
      return this.intl.formatDate(this.getValue(), format, this.localeId);
    };
    DateObject2.prototype.getTextAndFormat = function(customFormat) {
      if (customFormat === void 0) {
        customFormat = "";
      }
      var format = customFormat || this.format;
      var text = this.intl.formatDate(this.value, format, this.localeId);
      var mask = this.dateFormatString(this.value, format);
      if (!this.autoCorrectParts && this._partiallyInvalidDate.startDate) {
        var partiallyInvalidText = "";
        var formattedDate = this.intl.formatDate(this.value, format, this.localeId);
        var formattedDates = this.getFormattedInvalidDates(format);
        for (var i = 0; i < formattedDate.length; i++) {
          var symbol = mask.symbols[i];
          if (mask.partMap[i].type === "literal") {
            partiallyInvalidText += text[i];
          } else if (this.getInvalidDatePartValue(symbol)) {
            var partsForSegment = this.getPartsForSegment(mask, i);
            if (symbol === "M") {
              var datePartText = (parseToInt(this.getInvalidDatePartValue(symbol)) + JS_MONTH_OFFSET).toString();
              if (partsForSegment.length > MONTH_PART_WITH_WORDS_THRESHOLD) {
                partiallyInvalidText += formattedDates[symbol][i];
              } else {
                if (this.getInvalidDatePartValue(symbol)) {
                  var formattedDatePart = padZero(partsForSegment.length - datePartText.length) + datePartText;
                  partiallyInvalidText += formattedDatePart;
                  i += partsForSegment.length - 1;
                } else {
                  partiallyInvalidText += formattedDates[symbol][i];
                }
              }
            } else {
              if (this.getInvalidDatePartValue(symbol)) {
                var datePartText = this.getInvalidDatePartValue(symbol).toString();
                var formattedDatePart = padZero(partsForSegment.length - datePartText.length) + datePartText;
                partiallyInvalidText += formattedDatePart;
                i += partsForSegment.length - 1;
              } else {
                partiallyInvalidText += formattedDates[symbol][i];
              }
            }
          } else {
            partiallyInvalidText += text[i];
          }
        }
        text = partiallyInvalidText;
      }
      var result = this.merge(text, mask);
      return result;
    };
    DateObject2.prototype.getFormattedInvalidDates = function(customFormat) {
      var _this = this;
      if (customFormat === void 0) {
        customFormat = "";
      }
      var format = customFormat || this.format;
      var formattedDatesForSymbol = {
        "E": "",
        "H": "",
        "M": "",
        "a": "",
        "d": "",
        "h": "",
        "m": "",
        "s": "",
        "y": "",
        "S": ""
      };
      Object.keys(this._partiallyInvalidDate.invalidDateParts).forEach(function(key) {
        var date = _this.getInvalidDatePart(key).date;
        if (date) {
          var formattedInvalidDate = _this.intl.formatDate(date, format, _this.localeId);
          formattedDatesForSymbol[key] = formattedInvalidDate;
        }
      });
      return formattedDatesForSymbol;
    };
    DateObject2.prototype.modifyExisting = function(value2) {
      var sampleFormat = this.dateFormatString(this.value, this.format).symbols;
      for (var i = 0; i < sampleFormat.length; i++) {
        this.setExisting(sampleFormat[i], value2);
      }
    };
    DateObject2.prototype.getExisting = function(symbol) {
      switch (symbol) {
        case "y":
          return this.year;
        case "M":
        case "L":
          return this.month;
        case "d":
          return this.date;
        case "E":
          return this.date && this.month && this.year;
        case "h":
        case "H":
          return this.hours;
        case "t":
        case "a":
          return this.dayperiod;
        case "m":
          return this.minutes;
        case "s":
          return this.seconds;
        case "S":
          return this.milliseconds;
        default:
          return true;
      }
    };
    DateObject2.prototype.setExisting = function(symbol, value2) {
      switch (symbol) {
        case "y":
          this.year = value2;
          if (value2 === false) {
            this._value.setFullYear(DEFAULT_LEAP_YEAR);
          }
          break;
        case "M":
          this.month = value2;
          if (value2 === false) {
            if (this.autoCorrectParts) {
              this._value.setMonth(0);
            }
          }
          break;
        case "d":
          this.date = value2;
          break;
        case "h":
        case "H":
          this.hours = value2;
          break;
        case "t":
        case "a":
          this.dayperiod = value2;
          break;
        case "m":
          this.minutes = value2;
          break;
        case "s":
          this.seconds = value2;
          break;
        case "S":
          this.milliseconds = value2;
          break;
        default:
          break;
      }
      if (this.getValue()) {
        this.resetInvalidDate();
      }
    };
    DateObject2.prototype.modifyPart = function(symbol, offset3) {
      if (!isPresent3(symbol) || !isPresent3(offset3) || offset3 === 0) {
        return;
      }
      var newValue = cloneDate(this.value);
      var timeModified = false;
      var invalidDateFound;
      var isMonth = symbol === "M";
      var isDay = symbol === "d" || symbol === "E";
      var symbolExists = this.getExisting(symbol);
      if (!this.autoCorrectParts && (isDay || isMonth)) {
        var invalidDateParts = this._partiallyInvalidDate.invalidDateParts || {};
        var invalidDatePartValue = this.getInvalidDatePartValue(symbol);
        var year = invalidDateParts.y.value || newValue.getFullYear();
        var month = invalidDateParts.M.value || newValue.getMonth();
        var day = invalidDateParts.d.value || invalidDateParts.E.value || newValue.getDate();
        var hour = invalidDateParts.h.value || invalidDateParts.H.value || newValue.getHours();
        var minutes = invalidDateParts.m.value || newValue.getMinutes();
        var seconds = invalidDateParts.s.value || newValue.getSeconds();
        var milliseconds = invalidDateParts.S.value || newValue.getMilliseconds();
        switch (symbol) {
          case "y":
            year += offset3;
            break;
          case "M":
            month += offset3;
            break;
          case "d":
          case "E":
            day += offset3;
            break;
          // case 'h':
          // case 'H': hour += offset; break;
          // case 'm': minutes += offset; break;
          // case 's': seconds += offset; break;
          // case 'S': milliseconds += offset; break;
          default:
            break;
        }
        if (symbol === "M") {
          if (month < 0 || month > 11) {
            if (symbolExists) {
              this.setExisting(symbol, false);
              this.resetInvalidDateSymbol(symbol);
              return;
            }
          }
          if (!symbolExists) {
            if (month < 0) {
              month = clamp(11 + (month % 11 + 1), 0, 11);
            } else {
              var monthValue = isPresent3(invalidDatePartValue) ? month : (offset3 - JS_MONTH_OFFSET) % 12;
              month = clamp(monthValue, 0, 11);
            }
            month = clamp(month, 0, 11);
          }
          month = clamp(month, 0, 11);
        } else if (symbol === "d") {
          if (symbolExists) {
            if (day <= 0 || day > 31) {
              this.setExisting(symbol, false);
              this.resetInvalidDateSymbol(symbol);
              return;
            }
          } else if (!symbolExists) {
            if (isPresent3(invalidDatePartValue)) {
              if (day <= 0 || day > 31) {
                this.setExisting(symbol, false);
                this.resetInvalidDateSymbol(symbol);
                return;
              }
            }
            if (offset3 < 0) {
              var dayValue = isPresent3(invalidDatePartValue) ? day : 1 + (31 - Math.abs(offset3 % 31));
              day = clamp(dayValue, 1, 31);
            } else {
              var dayValue = isPresent3(invalidDatePartValue) ? day : offset3 % 31;
              day = clamp(dayValue, 1, 31);
            }
            day = clamp(day, 1, 31);
          }
        }
        var dateCandidate = createDate(year, month, day, hour, minutes, seconds, milliseconds);
        var newValueCandidate = isMonth || isDay ? this.modifyDateSymbolWithValue(newValue, symbol, isMonth ? month : day) : null;
        var dateCandidateExists = areDatePartsEqualTo(dateCandidate, year, month, day, hour, minutes, seconds, milliseconds);
        if (this.getValue() && areDatePartsEqualTo(dateCandidate, year, month, day, hour, minutes, seconds, milliseconds)) {
          newValue = cloneDate(dateCandidate);
          this.markDatePartsAsExisting();
        } else if (isMonth && newValueCandidate) {
          if (newValueCandidate.getMonth() === month) {
            if (this.getExisting("d")) {
              if (dateCandidateExists) {
                newValue = cloneDate(dateCandidate);
                this.resetInvalidDateSymbol(symbol);
              } else {
                invalidDateFound = true;
                this.setInvalidDatePart(symbol, {
                  value: month,
                  date: cloneDate(newValueCandidate),
                  startDateOffset: offset3,
                  startDate: cloneDate(this.value)
                });
                this.setExisting(symbol, false);
              }
            } else if (dateCandidateExists) {
              this.resetInvalidDateSymbol(symbol);
              newValue = cloneDate(dateCandidate);
              if (this.getExisting("M") && this.getExisting("y")) {
                this.setExisting("d", true);
                this.resetInvalidDateSymbol("d");
              }
            } else {
              this.resetInvalidDateSymbol(symbol);
              newValue = cloneDate(newValueCandidate);
            }
          } else {
            invalidDateFound = true;
            this.setInvalidDatePart(symbol, {
              value: month,
              date: cloneDate(newValueCandidate),
              startDateOffset: offset3,
              startDate: cloneDate(this.value)
            });
            this.setExisting(symbol, false);
          }
        } else if (isDay && newValueCandidate) {
          if (newValueCandidate.getDate() === day) {
            if (this.getExisting("M")) {
              if (dateCandidateExists) {
                newValue = cloneDate(dateCandidate);
                this.resetInvalidDateSymbol(symbol);
              } else {
                invalidDateFound = true;
                this.setInvalidDatePart(symbol, {
                  value: day,
                  date: cloneDate(newValueCandidate),
                  startDateOffset: offset3,
                  startDate: cloneDate(this.value)
                });
                this.setExisting(symbol, false);
              }
            } else if (dateCandidateExists) {
              newValue = cloneDate(dateCandidate);
              this.resetInvalidDateSymbol(symbol);
              if (this.getExisting("d") && this.getExisting("y")) {
                this.setExisting("M", true);
                this.resetInvalidDateSymbol("M");
              }
            } else {
              this.resetInvalidDateSymbol(symbol);
              newValue = cloneDate(newValueCandidate);
            }
          } else {
            invalidDateFound = true;
            this.setInvalidDatePart(symbol, {
              value: day,
              date: cloneDate(this.value),
              startDateOffset: offset3,
              startDate: cloneDate(this.value)
            });
            this.setExisting(symbol, false);
          }
        }
      } else {
        var hours = newValue.getHours();
        switch (symbol) {
          case "y":
            newValue.setFullYear(newValue.getFullYear() + offset3);
            break;
          case "M":
            newValue = addMonths(this.value, offset3);
            break;
          case "d":
          case "E":
            newValue.setDate(newValue.getDate() + offset3);
            break;
          case "h":
          case "H":
            newValue.setHours(newValue.getHours() + offset3);
            timeModified = true;
            break;
          case "m":
            newValue.setMinutes(newValue.getMinutes() + offset3);
            timeModified = true;
            break;
          case "s":
            newValue.setSeconds(newValue.getSeconds() + offset3);
            timeModified = true;
            break;
          case "S":
            newValue.setMilliseconds(newValue.getMilliseconds() + offset3);
            break;
          case "a":
            if (this.toggleDayPeriod) {
              newValue.setHours(hours >= 12 ? hours - 12 : hours + 12);
            } else {
              newValue.setHours(newValue.getHours() + 12 * offset3);
            }
            timeModified = true;
            break;
          default:
            break;
        }
      }
      if (this.shouldNormalizeCentury()) {
        newValue = this.normalizeCentury(newValue);
      }
      if (timeModified && !this.cycleTime && newValue.getDate() !== this._value.getDate()) {
      }
      if (!invalidDateFound) {
        this.setExisting(symbol, true);
        this._value = newValue;
        if (this.getValue()) {
          this.resetInvalidDate();
        }
      }
    };
    DateObject2.prototype.parsePart = function(_a2) {
      var symbol = _a2.symbol, currentChar = _a2.currentChar, resetSegmentValue = _a2.resetSegmentValue, cycleSegmentValue = _a2.cycleSegmentValue, rawInputValue = _a2.rawTextValue, isDeleting = _a2.isDeleting, originalFormat = _a2.originalFormat;
      var isInCaretMode = !cycleSegmentValue;
      var dateParts = this.dateFormatString(this.value, this.format);
      var datePartsLiterals = dateParts.partMap.filter(function(x) {
        return x.type === "literal";
      }).map(function(x, index) {
        return {
          datePartIndex: index,
          type: x.type,
          pattern: x.pattern,
          literal: ""
        };
      });
      var flatDateParts = dateParts.partMap.map(function(x) {
        return {
          type: x.type,
          pattern: x.pattern,
          text: ""
        };
      });
      for (var i = 0; i < datePartsLiterals.length; i++) {
        var datePart = datePartsLiterals[i];
        for (var j = 0; j < datePart.pattern.length; j++) {
          if (datePartsLiterals[i + j]) {
            datePartsLiterals[i + j].literal = datePart.pattern[j];
          }
        }
        i += datePart.pattern.length - 1;
      }
      for (var i = 0; i < flatDateParts.length; i++) {
        var datePart = flatDateParts[i];
        for (var j = 0; j < datePart.pattern.length; j++) {
          if (flatDateParts[i + j]) {
            flatDateParts[i + j].text = datePart.pattern[j];
          }
        }
        i += datePart.pattern.length - 1;
      }
      var shouldResetPart = isInCaretMode && symbol === "M" && dateParts.partMap.filter(function(x) {
        return x.type === "month";
      }).some(function(x) {
        return x.pattern.length > MONTH_PART_WITH_WORDS_THRESHOLD;
      });
      var parseResult = {
        value: null,
        switchToNext: false,
        resetPart: shouldResetPart,
        hasInvalidDatePart: false
      };
      if (!currentChar) {
        if (isInCaretMode) {
          for (var i = 0; i < datePartsLiterals.length; i++) {
            var literal = datePartsLiterals[i].literal;
            var rawValueStartsWithLiteral = rawInputValue.startsWith(literal);
            var rawValueEndsWithLiteral = rawInputValue.endsWith(literal);
            var rawValueHasConsecutiveLiterals = rawInputValue.indexOf(literal + literal) >= 0;
            if (rawValueStartsWithLiteral || rawValueEndsWithLiteral || rawValueHasConsecutiveLiterals) {
              this.resetLeadingZero();
              this.setExisting(symbol, false);
              this.resetInvalidDateSymbol(symbol);
              return extend(parseResult, { value: null, switchToNext: false });
            }
          }
        } else {
          this.resetLeadingZero();
          this.setExisting(symbol, false);
          this.resetInvalidDateSymbol(symbol);
          return extend(parseResult, { value: null, switchToNext: false });
        }
      }
      var baseDate = this.intl.formatDate(this.value, this.format, this.localeId);
      var baseFormat = dateParts.symbols;
      var replaced = false;
      var prefix2 = "";
      var current = "";
      var datePartText = "";
      var basePrefix = "";
      var baseSuffix = "";
      var suffix2 = "";
      var convertedBaseFormat = "";
      for (var i = 0; i < flatDateParts.length; i++) {
        convertedBaseFormat += flatDateParts[i].text;
      }
      var hasFixedFormat = this.format === baseFormat || this.format === convertedBaseFormat || this.format === originalFormat || this.format.length === originalFormat.length;
      var datePartStartIndex = (hasFixedFormat ? convertedBaseFormat : originalFormat).indexOf(symbol);
      var datePartEndIndex = (hasFixedFormat ? convertedBaseFormat : originalFormat).lastIndexOf(symbol);
      var segmentLength = datePartEndIndex - datePartStartIndex + 1;
      var formatToTextLengthDiff = originalFormat.length - rawInputValue.length;
      if (isInCaretMode || !isInCaretMode && !this.autoCorrectParts) {
        var segmentCharIndex = 0;
        for (var i = 0; i < baseDate.length; i++) {
          if (baseFormat[i] === symbol) {
            var existing = this.getExisting(symbol);
            if (symbol === "y") {
              if (!this.hasInvalidDatePart() && this.getExisting("y")) {
                current += baseDate[i];
              } else {
                var invalidDatePartValue = this.getInvalidDatePartValue(symbol);
                if (isPresent3(invalidDatePartValue)) {
                  current += (invalidDatePartValue || "").toString()[segmentCharIndex] || "";
                  segmentCharIndex++;
                } else {
                  current += existing ? baseDate[i] : "0";
                }
              }
            } else {
              current += existing ? baseDate[i] : "0";
            }
            if (formatToTextLengthDiff > 0) {
              if (datePartText.length + formatToTextLengthDiff < segmentLength) {
                datePartText += rawInputValue[i] || "";
              }
            } else {
              datePartText += rawInputValue[i] || "";
            }
            replaced = true;
          } else if (!replaced) {
            prefix2 += baseDate[i];
            basePrefix += baseDate[i];
          } else {
            suffix2 += baseDate[i];
            baseSuffix += baseDate[i];
          }
        }
        if (hasFixedFormat) {
          if (convertedBaseFormat.length < rawInputValue.length) {
            datePartText += currentChar;
          } else if (!isDeleting && originalFormat.length > rawInputValue.length) {
          }
          if (datePartText.length > segmentLength) {
            return extend(parseResult, { value: null, switchToNext: false });
          }
        }
        if (!hasFixedFormat || hasFixedFormat && !this.autoCorrectParts) {
          current = "";
          datePartText = "";
          prefix2 = "";
          suffix2 = "";
          replaced = false;
          var segmentCharIndex_1 = 0;
          for (var i = 0; i < originalFormat.length; i++) {
            if (originalFormat[i] === symbol) {
              var existing = this.getExisting(symbol);
              if (symbol === "y") {
                if (!this.hasInvalidDatePart() && this.getExisting("y")) {
                  current += baseDate[i];
                } else {
                  var invalidDatePartValue = this.getInvalidDatePartValue(symbol);
                  if (isPresent3(invalidDatePartValue)) {
                    current += (invalidDatePartValue || "").toString()[segmentCharIndex_1] || "";
                    segmentCharIndex_1++;
                  } else {
                    current += existing ? baseDate[i] : "0";
                  }
                }
              } else {
                current += existing ? baseDate[i] || "" : "0";
              }
              if (formatToTextLengthDiff > 0) {
                if (datePartText.length + formatToTextLengthDiff < segmentLength) {
                  datePartText += rawInputValue[i] || "";
                }
              } else {
                datePartText += rawInputValue[i] || "";
              }
              replaced = true;
            } else if (!replaced) {
              prefix2 += rawInputValue[i] || "";
            } else {
              suffix2 += rawInputValue[i - formatToTextLengthDiff] || "";
            }
          }
          if (originalFormat.length < rawInputValue.length) {
            datePartText += currentChar;
          }
        }
      }
      if (!isInCaretMode) {
        if (this.autoCorrectParts) {
          current = "";
          datePartText = "";
          prefix2 = "";
          suffix2 = "";
          replaced = false;
          for (var i = 0; i < baseDate.length; i++) {
            if (baseFormat[i] === symbol) {
              var existing = this.getExisting(symbol);
              current += existing ? baseDate[i] : "0";
              replaced = true;
            } else if (!replaced) {
              prefix2 += baseDate[i];
            } else {
              suffix2 += baseDate[i];
            }
          }
        } else {
          current = resetSegmentValue ? datePartText : current;
        }
      }
      var parsedDate = null;
      var _b = this.matchMonth(currentChar), monthByChar = _b.monthName, matchesCount = _b.matchesCount;
      var dayPeriod = this.matchDayPeriod(currentChar, symbol);
      var isZeroCurrentChar = currentChar === "0";
      var leadingZero = this.leadingZero || {};
      if (isZeroCurrentChar) {
        if (datePartText === "0") {
          datePartText = current;
        }
        var valueNumber = parseToInt(resetSegmentValue ? currentChar : (isInCaretMode ? datePartText : current) + currentChar);
        if (valueNumber === 0 && !this.isAbbrMonth(dateParts.partMap, symbol) && symbol !== "a") {
          this.incrementLeadingZero(symbol);
        }
      } else {
        this.resetLeadingZero();
      }
      var partPattern = this.partPattern(dateParts.partMap, symbol);
      var patternValue = partPattern ? partPattern.pattern : null;
      var patternLength = this.patternLength(patternValue) || (patternValue ? patternValue.length : 0);
      if (isInCaretMode) {
        if (isDeleting && !datePartText) {
          this.setExisting(symbol, false);
          return extend(parseResult, { value: null, switchToNext: false });
        }
      }
      var currentMaxLength = current.length - 3;
      var tryParse = true;
      var middle = isInCaretMode ? datePartText : current;
      for (var i = Math.max(0, currentMaxLength); i <= current.length; i++) {
        if (!tryParse) {
          break;
        }
        middle = resetSegmentValue ? currentChar : isInCaretMode ? datePartText : current.substring(i) + currentChar;
        if (this.autoSwitchParts && symbol === "h" && current.substring(i) === "12") {
          middle = middle.replace("12", "0");
        }
        if (isInCaretMode || !this.autoCorrectParts) {
          tryParse = false;
          middle = unpadZero(middle);
          middle = padZero(patternLength - middle.length) + middle;
        }
        var middleNumber = parseInt(middle, 10);
        var candidateDateString = prefix2 + middle + suffix2;
        parsedDate = this.intl.parseDate(candidateDateString, this.format, this.localeId);
        if (parsedDate && this.value && dateParts.partMap.every(function(x) {
          return x.type !== "year" && x.type !== "month" && x.type != "day";
        })) {
          parsedDate.setFullYear(this.value.getFullYear());
          parsedDate.setMonth(this.value.getMonth());
          parsedDate.setDate(this.value.getDate());
        }
        var autoCorrectedPrefixAndSuffix = false;
        if (isInCaretMode && !isValidDate(parsedDate)) {
          if (this.autoCorrectParts) {
            parsedDate = this.intl.parseDate(basePrefix + middle + baseSuffix, this.format, this.localeId);
            autoCorrectedPrefixAndSuffix = true;
          }
        }
        var isCurrentCharParsable = !isNaN(parseInt(currentChar, 10)) || isInCaretMode && isDeleting && currentChar === "";
        if (!parsedDate && !isNaN(middleNumber) && isCurrentCharParsable && this.autoCorrectParts) {
          if (symbol === MONTH_SYMBOL && !monthByChar) {
            var monthNumber = middleNumber - JS_MONTH_OFFSET;
            if (monthNumber > -1 && monthNumber < 12) {
              parsedDate = cloneDate(this.value);
              parsedDate.setMonth(monthNumber);
              if (parsedDate.getMonth() !== monthNumber) {
                parsedDate = lastDayOfMonth(addMonths(parsedDate, -1));
              }
            }
          }
          if (symbol === "y") {
            parsedDate = createDate(parseInt(middle, 10), this.month ? this.value.getMonth() : 0, this.date ? this.value.getDate() : 1, this.hours ? this.value.getHours() : 0, this.minutes ? this.value.getMinutes() : 0, this.seconds ? this.value.getSeconds() : 0, this.milliseconds ? this.value.getMilliseconds() : 0);
            if ((isInCaretMode && isValidDate(parsedDate) || !isInCaretMode && parsedDate) && this.date && parsedDate.getDate() !== this.value.getDate()) {
              parsedDate = lastDayOfMonth(addMonths(parsedDate, -1));
            }
          }
        }
        if (isInCaretMode && isValidDate(parsedDate) || !isInCaretMode && parsedDate) {
          var peekResult = this.isPeekDateOverflowingDatePart({
            useBasePrefixAndSuffix: autoCorrectedPrefixAndSuffix,
            middle,
            patternValue,
            basePrefix,
            baseSuffix,
            prefix: prefix2,
            suffix: suffix2,
            symbol,
            patternLength,
            leadingZero
          });
          var switchToNext = peekResult.switchToNext;
          if (this.shouldNormalizeCentury()) {
            parsedDate = this.normalizeCentury(parsedDate);
          }
          if (symbol === "H" && parsedDate.getHours() >= 12) {
            this.setExisting("a", true);
          }
          this._value = parsedDate;
          this.setExisting(symbol, true);
          this.resetInvalidDateSymbol(symbol);
          if (!this.autoCorrectParts) {
            if (symbol === "M") {
              if (this.getExisting("M") && this.getExisting("y")) {
                this.setExisting("d", true);
                this.resetInvalidDateSymbol("d");
              }
            } else if (symbol === "d") {
              if (this.getExisting("d") && this.getExisting("y")) {
                this.setExisting("M", true);
                this.resetInvalidDateSymbol("M");
              }
            } else if (symbol === "y") {
              this.markDatePartsAsExisting();
            }
            if (!this.hasInvalidDatePart()) {
              this.markDatePartsAsExisting();
              if (!peekResult.peekedDate && peekResult.switchToNext && !this.autoCorrectParts) {
                if (symbol === "M") {
                } else if (symbol === "d") {
                  if (peekResult.parsedPeekedValue === 30 && this.value.getMonth() === MONTH_INDEX_FEBRUARY) {
                    switchToNext = false;
                  }
                }
              }
            }
          }
          return extend(parseResult, { value: this.value, switchToNext });
        }
      }
      if (monthByChar) {
        parsedDate = this.intl.parseDate(prefix2 + monthByChar + suffix2, this.format, this.localeId);
        if (parsedDate) {
          this._value = parsedDate;
          this.setExisting(symbol, true);
          return extend(parseResult, { value: this.value, switchToNext: matchesCount === 1 });
        }
      }
      if (dayPeriod) {
        parsedDate = this.intl.parseDate(prefix2 + dayPeriod + suffix2, this.format) || this.intl.parseDate(basePrefix + dayPeriod + baseSuffix, this.format);
        if (parsedDate) {
          this._value = parsedDate;
          this.setExisting(symbol, true);
          return extend(parseResult, { value: this.value, switchToNext: true });
        }
      }
      if (isZeroCurrentChar && symbol !== "a") {
        this.setExisting(symbol, false);
      }
      if (!this.autoCorrectParts) {
        var datePartValue = void 0;
        var textToParse = isInCaretMode ? datePartText : middle;
        var parsedValue = parseToInt(textToParse);
        if (isNumber(parsedValue) && isParseableToInt(textToParse)) {
          if (symbol === "d" && (parsedValue <= 0 || parsedValue > 31) || symbol === "M" && (parsedValue <= 0 || parsedValue > 11)) {
            if (isInCaretMode) {
              return extend(parseResult, {
                value: null,
                switchToNext: false
              });
            } else {
              textToParse = currentChar;
              parsedValue = parseToInt(textToParse);
            }
          }
          if (!isNumber(parsedValue) || !isParseableToInt(textToParse)) {
            return extend(parseResult, { value: null, switchToNext: false });
          }
          datePartValue = symbol === "M" ? parsedValue - JS_MONTH_OFFSET : parsedValue;
          var isYear = symbol === "y";
          var isMonth = symbol === "M";
          var isDay = symbol === "d";
          var newValue = cloneDate(this._value);
          var invalidDateParts = this._partiallyInvalidDate.invalidDateParts || {};
          var year = isYear ? datePartValue : invalidDateParts.y.value || newValue.getFullYear();
          var month = isMonth ? datePartValue : invalidDateParts.M.value || newValue.getMonth();
          var day = isDay ? datePartValue : invalidDateParts.d.value || invalidDateParts.E.value || newValue.getDate();
          var hour = invalidDateParts.h.value || invalidDateParts.H.value || newValue.getHours();
          var minutes = invalidDateParts.m.value || newValue.getMinutes();
          var seconds = invalidDateParts.s.value || newValue.getSeconds();
          var milliseconds = invalidDateParts.S.value || newValue.getMilliseconds();
          var dateCandidate = createDate(year, month, day, hour, minutes, seconds, milliseconds);
          var dateCandidateExists = areDatePartsEqualTo(dateCandidate, year, month, day, hour, minutes, seconds, milliseconds);
          var newValueCandidate = isYear || isMonth || isDay ? this.modifyDateSymbolWithValue(newValue, symbol, isYear ? year : isMonth ? month : day) : null;
          var invalidDateFound = false;
          if (isMonth && newValueCandidate) {
            if (newValueCandidate.getMonth() === month) {
              if (this.getExisting("d")) {
                if (dateCandidateExists) {
                  newValue = cloneDate(dateCandidate);
                  this.resetInvalidDateSymbol(symbol);
                } else {
                  invalidDateFound = true;
                  this.setInvalidDatePart(symbol, {
                    value: month,
                    date: cloneDate(newValueCandidate),
                    startDate: cloneDate(this.value)
                  });
                  this.setExisting(symbol, false);
                }
              } else if (dateCandidateExists) {
                this.resetInvalidDateSymbol(symbol);
                newValue = cloneDate(dateCandidate);
                if (this.getExisting("M") && this.getExisting("y")) {
                  this.setExisting("d", true);
                  this.resetInvalidDateSymbol("d");
                }
              } else {
                this.resetInvalidDateSymbol(symbol);
                newValue = cloneDate(newValueCandidate);
              }
            } else {
              invalidDateFound = true;
              this.setInvalidDatePart(symbol, {
                value: month,
                date: cloneDate(newValueCandidate),
                startDate: cloneDate(this.value)
              });
              this.setExisting(symbol, false);
            }
          } else if (isDay && newValueCandidate) {
            if (newValueCandidate.getDate() === day) {
              if (this.getExisting("M")) {
                if (dateCandidateExists) {
                  newValue = cloneDate(dateCandidate);
                  this.resetInvalidDateSymbol(symbol);
                } else {
                  invalidDateFound = true;
                  this.setInvalidDatePart(symbol, {
                    value: day,
                    date: cloneDate(newValueCandidate),
                    startDate: cloneDate(this.value)
                  });
                  this.setExisting(symbol, false);
                }
              } else if (dateCandidateExists) {
                newValue = cloneDate(dateCandidate);
                this.resetInvalidDateSymbol(symbol);
                if (this.getExisting("d") && this.getExisting("y")) {
                  this.setExisting("M", true);
                  this.resetInvalidDateSymbol("M");
                }
              } else {
                this.resetInvalidDateSymbol(symbol);
                newValue = cloneDate(newValueCandidate);
              }
            } else {
              invalidDateFound = true;
              this.setInvalidDatePart(symbol, {
                value: day,
                date: cloneDate(this.value),
                startDate: cloneDate(this.value)
              });
              this.setExisting(symbol, false);
            }
          } else if (isYear && newValueCandidate) {
            if (newValueCandidate.getFullYear() === year) {
              if (this.getExisting("d") && this.getExisting("M")) {
                if (dateCandidateExists) {
                  newValue = cloneDate(dateCandidate);
                  this.resetInvalidDateSymbol(symbol);
                } else {
                  invalidDateFound = true;
                  this.setInvalidDatePart(symbol, {
                    value: year,
                    date: cloneDate(newValueCandidate),
                    startDate: cloneDate(this.value)
                  });
                  this.setExisting(symbol, false);
                }
              } else if (dateCandidateExists) {
                this.resetInvalidDateSymbol(symbol);
                newValue = cloneDate(dateCandidate);
                if (this.getExisting("M") && this.getExisting("d")) {
                  this.setExisting("y", true);
                  this.resetInvalidDateSymbol("y");
                }
              } else {
                this.resetInvalidDateSymbol(symbol);
                newValue = cloneDate(newValueCandidate);
              }
            } else {
              invalidDateFound = true;
              this.setInvalidDatePart(symbol, {
                value: year,
                date: cloneDate(newValueCandidate),
                startDate: cloneDate(this.value)
              });
              this.setExisting(symbol, false);
            }
          }
          if (!invalidDateFound) {
            this.setExisting(symbol, true);
            if (isInCaretMode && !isValidDate(parsedDate)) {
              var valueCandidate = this.intl.parseDate(basePrefix + middle + baseSuffix, this.format, this.localeId);
              if (isValidDate(valueCandidate)) {
                this._value = valueCandidate;
              }
            } else {
              this._value = newValue;
            }
            if (this.getValue()) {
              this.resetInvalidDate();
            }
          }
          var switchToNext = false;
          if (symbol === "M") {
            if (parsedValue >= 2 || textToParse.length >= 2) {
              switchToNext = true;
            } else {
              switchToNext = false;
            }
          } else {
            if (hasFixedFormat) {
              var peekDateSwitchToNext = this.isPeekDateOverflowingDatePart({
                useBasePrefixAndSuffix: !this.autoCorrectParts,
                middle,
                patternValue,
                basePrefix,
                baseSuffix,
                prefix: prefix2,
                suffix: suffix2,
                symbol,
                patternLength,
                leadingZero
              }).switchToNext;
              switchToNext = peekDateSwitchToNext;
            } else {
              switchToNext = textToParse.length > segmentLength;
            }
          }
          return extend(parseResult, {
            value: null,
            switchToNext,
            hasInvalidDatePart: invalidDateFound
          });
        }
      }
      return extend(parseResult, { value: null, switchToNext: false });
    };
    DateObject2.prototype.symbolMap = function(symbol) {
      return this.intl.splitDateFormat(this.format, this.localeId).reduce(dateSymbolMap, {})[symbol];
    };
    DateObject2.prototype.resetLeadingZero = function() {
      var hasLeadingZero = this.leadingZero !== null;
      this.setLeadingZero(null);
      return hasLeadingZero;
    };
    DateObject2.prototype.setLeadingZero = function(leadingZero) {
      this.leadingZero = leadingZero;
    };
    DateObject2.prototype.getLeadingZero = function() {
      return this.leadingZero || {};
    };
    DateObject2.prototype.normalizeCentury = function(date) {
      if (!isPresent3(date)) {
        return date;
      }
      var twoDigitYear = cropTwoDigitYear(date);
      var centuryBase = this.getNormalizedCenturyBase(twoDigitYear);
      var normalizedDate = setYears(date, centuryBase + twoDigitYear);
      return normalizedDate;
    };
    DateObject2.prototype.incrementLeadingZero = function(symbol) {
      var leadingZero = this.leadingZero || {};
      leadingZero[symbol] = (leadingZero[symbol] || 0) + 1;
      this.leadingZero = leadingZero;
    };
    DateObject2.prototype.isAbbrMonth = function(parts, symbol) {
      var pattern = this.partPattern(parts, symbol);
      return pattern.type === "month" && pattern.names;
    };
    DateObject2.prototype.partPattern = function(parts, symbol) {
      return parts.filter(function(part) {
        return part.pattern.indexOf(symbol) !== -1;
      })[0];
    };
    DateObject2.prototype.peek = function(value2, pattern) {
      if (!pattern) {
        return value2;
      }
      var peekValue = value2.replace(/^0*/, "") + "0";
      return padZero(pattern.length - peekValue.length) + peekValue;
    };
    DateObject2.prototype.matchMonth = function(typedChar) {
      var _this = this;
      this.typedMonthPart += typedChar.toLowerCase();
      if (this.monthNames.length === 0) {
        return { monthName: "", matchesCount: 0 };
      }
      while (this.typedMonthPart.length > 0) {
        var matchingMonths = [];
        for (var i = 0; i < this.monthNames.length; i++) {
          var monthName = this.monthNames[i].toLowerCase();
          if (monthName.startsWith(this.typedMonthPart)) {
            matchingMonths.push(this.monthNames[i]);
          }
        }
        if (matchingMonths.length > 0) {
          return { monthName: matchingMonths[0], matchesCount: matchingMonths.length };
        }
        var monthAsNum = parseInt(this.typedMonthPart, 10);
        if (monthAsNum >= 1 && monthAsNum <= 12 && monthAsNum.toString().startsWith(this.typedMonthPart)) {
          var months = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
          var matchesCount = months.reduce(function(count2, month) {
            return month.toString().startsWith(_this.typedMonthPart) ? count2 + 1 : count2;
          }, 0);
          return { monthName: this.monthNames[monthAsNum - 1], matchesCount };
        }
        this.typedMonthPart = this.typedMonthPart.substring(1, this.typedMonthPart.length);
      }
      return { monthName: "", matchesCount: 0 };
    };
    DateObject2.prototype.matchDayPeriod = function(typedChar, symbol) {
      var lowerChart = typedChar.toLowerCase();
      if (symbol === "a" && this.dayPeriods) {
        if (this.dayPeriods.am.toLowerCase().startsWith(lowerChart)) {
          return this.dayPeriods.am;
        } else if (this.dayPeriods.pm.toLowerCase().startsWith(lowerChart)) {
          return this.dayPeriods.pm;
        }
      }
      return "";
    };
    DateObject2.prototype.allFormattedMonths = function(locale) {
      if (locale === void 0) {
        locale = "en";
      }
      var dateFormatParts = this.intl.splitDateFormat(this.format, this.localeId);
      for (var i = 0; i < dateFormatParts.length; i++) {
        if (dateFormatParts[i].type === "month" && dateFormatParts[i].names) {
          return this.intl.dateFormatNames(locale, dateFormatParts[i].names);
        }
      }
      return [];
    };
    DateObject2.prototype.allDayPeriods = function(locale) {
      if (locale === void 0) {
        locale = "en";
      }
      var dateFormatParts = this.intl.splitDateFormat(this.format);
      for (var i = 0; i < dateFormatParts.length; i++) {
        if (dateFormatParts[i].type === "dayperiod" && dateFormatParts[i].names) {
          return this.intl.dateFormatNames(locale, dateFormatParts[i].names);
        }
      }
      return null;
    };
    DateObject2.prototype.patternLength = function(pattern) {
      if (!pattern) {
        return 0;
      }
      if (pattern[0] === "y") {
        return 4;
      }
      if (SHORT_PATTERN_LENGTH_REGEXP.test(pattern)) {
        return 2;
      }
      return 0;
    };
    DateObject2.prototype.dateFormatString = function(date, format) {
      var dateFormatParts = this.intl.splitDateFormat(format, this.localeId);
      var parts = [];
      var partMap = [];
      for (var i = 0; i < dateFormatParts.length; i++) {
        var partLength = this.intl.formatDate(date, { pattern: dateFormatParts[i].pattern }, this.localeId).length;
        while (partLength > 0) {
          parts.push(this.symbols[dateFormatParts[i].pattern[0]] || Constants.formatSeparator);
          partMap.push(dateFormatParts[i]);
          partLength--;
        }
      }
      var returnValue = new Mask();
      returnValue.symbols = parts.join("");
      returnValue.partMap = partMap;
      return returnValue;
    };
    DateObject2.prototype.merge = function(text, mask) {
      var resultText = "";
      var resultFormat = "";
      var format = mask.symbols;
      var processTextSymbolsEnded = false;
      var ignoreFormatSymbolsCount = 0;
      var formattedDates = this.getFormattedInvalidDates(format);
      for (var formatSymbolIndex = format.length - 1; formatSymbolIndex >= 0; formatSymbolIndex--) {
        var partsForSegment = this.getPartsForSegment(mask, formatSymbolIndex);
        if (this.knownParts.indexOf(format[formatSymbolIndex]) === -1 || this.getExisting(format[formatSymbolIndex])) {
          if (this.autoCorrectParts) {
            resultText = text[formatSymbolIndex] + resultText;
          } else {
            if (text.length !== format.length) {
              if (processTextSymbolsEnded) {
                resultText = text[formatSymbolIndex] + resultText;
              } else if (ignoreFormatSymbolsCount > 0) {
                resultText = text[formatSymbolIndex] + resultText;
                ignoreFormatSymbolsCount--;
                if (ignoreFormatSymbolsCount <= 0) {
                  processTextSymbolsEnded = true;
                }
              } else {
                resultText = (text[formatSymbolIndex + text.length - format.length] || "") + resultText;
              }
            } else {
              resultText = text[formatSymbolIndex] + resultText;
            }
          }
          resultFormat = format[formatSymbolIndex] + resultFormat;
        } else {
          var symbol = format[formatSymbolIndex];
          var formatSymbolIndexModifier = 0;
          if (this.autoCorrectParts || !this.autoCorrectParts && !this.getInvalidDatePartValue(symbol)) {
            while (formatSymbolIndex >= 0 && symbol === format[formatSymbolIndex]) {
              formatSymbolIndex--;
            }
            formatSymbolIndex++;
          }
          if (this.leadingZero && this.leadingZero[symbol]) {
            resultText = "0" + resultText;
          } else {
            if (!this.autoCorrectParts && this.getInvalidDatePartValue(symbol)) {
              var datePartText = this.getInvalidDatePartValue(symbol).toString();
              if (symbol === "M") {
                datePartText = (parseToInt(this.getInvalidDatePartValue(symbol)) + JS_MONTH_OFFSET).toString();
                if (partsForSegment.length > MONTH_PART_WITH_WORDS_THRESHOLD) {
                  resultText = formattedDates[symbol][formatSymbolIndex] + resultText;
                } else {
                  datePartText = (parseToInt(this.getInvalidDatePartValue(symbol)) + JS_MONTH_OFFSET).toString();
                  var formattedDatePart = padZero(partsForSegment.length - datePartText.length) + datePartText;
                  resultText = formattedDatePart + resultText;
                  formatSymbolIndexModifier = partsForSegment.length - 1;
                  ignoreFormatSymbolsCount = datePartText.length - partsForSegment.length;
                }
              } else {
                var formattedDatePart = padZero(partsForSegment.length - datePartText.length) + datePartText;
                resultText = formattedDatePart + resultText;
                formatSymbolIndexModifier = partsForSegment.length - 1;
                ignoreFormatSymbolsCount = datePartText.length - partsForSegment.length;
              }
            } else {
              resultText = this.dateFieldName(mask.partMap[formatSymbolIndex]) + resultText;
            }
          }
          while (resultFormat.length < resultText.length) {
            resultFormat = format[formatSymbolIndex] + resultFormat;
          }
          if (formatSymbolIndexModifier !== 0) {
            formatSymbolIndex = formatSymbolIndex - formatSymbolIndexModifier + (text.length - format.length);
          }
        }
      }
      return { text: resultText, format: resultFormat };
    };
    DateObject2.prototype.dateFieldName = function(part) {
      var formatPlaceholder = this.formatPlaceholder || "wide";
      if (formatPlaceholder[part.type]) {
        return formatPlaceholder[part.type];
      }
      if (formatPlaceholder === "formatPattern") {
        return part.pattern;
      }
      return this.intl.dateFieldName(Object.assign(part, { nameType: formatPlaceholder }));
    };
    DateObject2.prototype.getNormalizedCenturyBase = function(twoDigitYear) {
      return twoDigitYear > this.twoDigitYearMax ? PREVIOUS_CENTURY_BASE : CURRENT_CENTURY_BASE;
    };
    DateObject2.prototype.shouldNormalizeCentury = function() {
      return this.intl.splitDateFormat(this.format).some(function(part) {
        return part.pattern === "yy";
      });
    };
    DateObject2.prototype.resetInvalidDate = function() {
      var _this = this;
      this._partiallyInvalidDate.startDate = null;
      Object.keys(this._partiallyInvalidDate.invalidDateParts).forEach(function(key) {
        _this.resetInvalidDatePart(key);
      });
    };
    DateObject2.prototype.resetInvalidDateSymbol = function(symbol) {
      var _this = this;
      this.resetInvalidDatePart(symbol);
      var shouldResetInvalidDate = true;
      Object.keys(this._partiallyInvalidDate.invalidDateParts).forEach(function(key) {
        if (_this._partiallyInvalidDate.invalidDateParts[key] && isPresent3(_this._partiallyInvalidDate.invalidDateParts[key].value)) {
          shouldResetInvalidDate = false;
        }
      });
      if (shouldResetInvalidDate) {
        this.resetInvalidDate();
      }
    };
    DateObject2.prototype.resetInvalidDatePart = function(symbol) {
      if (this._partiallyInvalidDate.invalidDateParts[symbol]) {
        this._partiallyInvalidDate.invalidDateParts[symbol] = {
          value: null,
          date: null,
          startDateOffset: 0
        };
      }
    };
    DateObject2.prototype.getInvalidDatePart = function(symbol) {
      var invalidDatePart = this._partiallyInvalidDate.invalidDateParts[symbol];
      return invalidDatePart || {};
    };
    DateObject2.prototype.getInvalidDatePartValue = function(symbol) {
      var invalidDatePart = this._partiallyInvalidDate.invalidDateParts[symbol];
      return (invalidDatePart || {}).value;
    };
    DateObject2.prototype.setInvalidDatePart = function(symbol, _a2) {
      var _b = _a2.value, value2 = _b === void 0 ? null : _b, _c = _a2.date, date = _c === void 0 ? null : _c, _d = _a2.startDateOffset, startDateOffset = _d === void 0 ? 0 : _d, _e = _a2.startDate, startDate = _e === void 0 ? null : _e;
      if (this._partiallyInvalidDate.invalidDateParts[symbol]) {
        this._partiallyInvalidDate.invalidDateParts[symbol].value = value2;
        this._partiallyInvalidDate.invalidDateParts[symbol].date = date;
        this._partiallyInvalidDate.invalidDateParts[symbol].startDateOffset = startDateOffset;
        this._partiallyInvalidDate.startDate = startDate;
      }
    };
    DateObject2.prototype.hasInvalidDatePart = function() {
      var _this = this;
      var hasInvalidDatePart = false;
      Object.keys(this._partiallyInvalidDate.invalidDateParts).forEach(function(key) {
        if (_this._partiallyInvalidDate.invalidDateParts[key] && isPresent3(_this._partiallyInvalidDate.invalidDateParts[key].value)) {
          hasInvalidDatePart = true;
        }
      });
      return hasInvalidDatePart;
    };
    DateObject2.prototype.modifyDateSymbolWithOffset = function(date, symbol, offset3) {
      var newValue = cloneDate(date);
      var timeModified = false;
      switch (symbol) {
        case "y":
          newValue.setFullYear(newValue.getFullYear() + offset3);
          break;
        case "M":
          newValue = addMonths(this.value, offset3);
          break;
        case "d":
        case "E":
          newValue.setDate(newValue.getDate() + offset3);
          break;
        case "h":
        case "H":
          newValue.setHours(newValue.getHours() + offset3);
          timeModified = true;
          break;
        case "m":
          newValue.setMinutes(newValue.getMinutes() + offset3);
          timeModified = true;
          break;
        case "s":
          newValue.setSeconds(newValue.getSeconds() + offset3);
          timeModified = true;
          break;
        case "S":
          newValue.setMilliseconds(newValue.getMilliseconds() + offset3);
          break;
        case "a":
          newValue.setHours(newValue.getHours() + 12 * offset3);
          timeModified = true;
          break;
        default:
          break;
      }
      return {
        date: newValue,
        timeModified
      };
    };
    DateObject2.prototype.modifyDateSymbolWithValue = function(date, symbol, value2) {
      var newValue = cloneDate(date);
      switch (symbol) {
        case "y":
          newValue.setFullYear(value2);
          break;
        case "M":
          newValue = addMonths(date, value2 - date.getMonth());
          break;
        case "d":
        case "E":
          newValue.setDate(value2);
          break;
        case "h":
        case "H":
          newValue.setHours(value2);
          break;
        case "m":
          newValue.setMinutes(value2);
          break;
        case "s":
          newValue.setSeconds(value2);
          break;
        case "S":
          newValue.setMilliseconds(value2);
          break;
        case "a":
          newValue.setHours(value2);
          break;
        default:
          break;
      }
      return newValue;
    };
    DateObject2.prototype.markDatePartsAsExisting = function() {
      this.modifyExisting(true);
    };
    DateObject2.prototype.getPartsForSegment = function(mask, partIndex) {
      var segmentPart = mask.partMap[partIndex];
      var partsForSegment = [];
      for (var maskPartIndex = partIndex; maskPartIndex < mask.partMap.length; maskPartIndex++) {
        var part = mask.partMap[maskPartIndex];
        if (segmentPart.type === part.type && segmentPart.pattern === part.pattern) {
          partsForSegment.push(part);
        } else {
          break;
        }
      }
      for (var maskPartIndex = partIndex - 1; maskPartIndex >= 0; maskPartIndex--) {
        var part = mask.partMap[maskPartIndex];
        if (segmentPart.type === part.type && segmentPart.pattern === part.pattern) {
          partsForSegment.unshift(part);
        } else {
          break;
        }
      }
      return partsForSegment;
    };
    DateObject2.prototype.isPeekDateOverflowingDatePart = function(_a2) {
      var useBasePrefixAndSuffix = _a2.useBasePrefixAndSuffix, middle = _a2.middle, patternValue = _a2.patternValue, basePrefix = _a2.basePrefix, baseSuffix = _a2.baseSuffix, prefix2 = _a2.prefix, suffix2 = _a2.suffix, symbol = _a2.symbol, patternLength = _a2.patternLength, leadingZero = _a2.leadingZero;
      var peekedValue = this.peek(middle, patternValue);
      var peekedDateString = useBasePrefixAndSuffix ? "".concat(basePrefix).concat(peekedValue).concat(baseSuffix) : "".concat(prefix2).concat(peekedValue).concat(suffix2);
      var peekedDate = this.intl.parseDate(peekedDateString, this.format, this.localeId);
      var leadingZeroOffset = (this.leadingZero || {})[symbol] || 0;
      var patternSatisfied = leadingZeroOffset + unpadZero(middle).length >= patternLength;
      var parsedPeekedValue = parseToInt(peekedValue);
      var switchToNext = peekedDate === null || (leadingZero[symbol] ? patternValue.length <= middle.length : patternSatisfied);
      return {
        peekedDate,
        peekedDateString,
        peekedValue,
        parsedPeekedValue,
        switchToNext
      };
    };
    return DateObject2;
  })()
);

// node_modules/@progress/kendo-dateinputs-common/dist/es/common/keycode.js
var KeyCode = {
  BACKSPACE: 8,
  DELETE: 46,
  TAB: 9,
  ENTER: 13,
  ESCAPE: 27,
  ARROW_LEFT: 37,
  ARROW_UP: 38,
  ARROW_RIGHT: 39,
  ARROW_DOWN: 40,
  SPACE: 32,
  END: 35,
  HOME: 36,
  PAGE_UP: 33,
  PAGE_DOWN: 34
};

// node_modules/@progress/kendo-dateinputs-common/dist/es/common/observable.js
var defaultOptions = {
  events: {}
};
var Observable2 = (
  /** @class */
  (function() {
    function Observable3(options) {
      this.options = extend({}, defaultOptions, options);
    }
    Observable3.prototype.destroy = function() {
      this.options = {};
    };
    Observable3.prototype.trigger = function(eventName, args) {
      if (args === void 0) {
        args = {};
      }
      var eventData = {
        defaultPrevented: false,
        preventDefault: function() {
          eventData.defaultPrevented = true;
        }
      };
      if (isFunction2(this.options.events[eventName])) {
        this.options.events[eventName](extend(eventData, args, {
          sender: this
        }));
        return eventData.defaultPrevented;
      }
      return false;
    };
    return Observable3;
  })()
);

// node_modules/@progress/kendo-dateinputs-common/dist/es/dateinput/interaction-mode.js
var DateInputInteractionMode;
(function(DateInputInteractionMode2) {
  DateInputInteractionMode2["None"] = "none";
  DateInputInteractionMode2["Caret"] = "caret";
  DateInputInteractionMode2["Selection"] = "selection";
})(DateInputInteractionMode || (DateInputInteractionMode = {}));

// node_modules/@progress/kendo-dateinputs-common/dist/es/dateinput/dateinput.js
var _a;
var DEFAULT_SEGMENT_STEP = 1;
var DRAG_START = "dragStart";
var DROP = "drop";
var TOUCH_START = "touchstart";
var MOUSE_DOWN = "mousedown";
var MOUSE_UP = "mouseup";
var CLICK = "click";
var INPUT = "input";
var KEY_DOWN = "keydown";
var FOCUS = "focus";
var BLUR = "blur";
var PASTE = "paste";
var MOUSE_SCROLL = "DOMMouseScroll";
var MOUSE_WHEEL = "mousewheel";
var VALUE_CHANGE = "valueChange";
var INPUT_END = "inputEnd";
var BLUR_END = "blurEnd";
var FOCUS_END = "focusEnd";
var CHANGE = "change";
var defaultDateInputOptions = {
  format: "d",
  hasPlaceholder: false,
  placeholder: null,
  cycleTime: true,
  locale: null,
  steps: {
    millisecond: DEFAULT_SEGMENT_STEP,
    second: DEFAULT_SEGMENT_STEP,
    minute: DEFAULT_SEGMENT_STEP,
    hour: DEFAULT_SEGMENT_STEP,
    day: DEFAULT_SEGMENT_STEP,
    month: DEFAULT_SEGMENT_STEP,
    year: DEFAULT_SEGMENT_STEP
  },
  formatPlaceholder: null,
  events: (_a = {}, _a[VALUE_CHANGE] = null, _a[INPUT] = null, _a[INPUT_END] = null, _a[FOCUS] = null, _a[FOCUS_END] = null, _a[BLUR] = null, _a[BLUR_END] = null, _a[KEY_DOWN] = null, _a[MOUSE_WHEEL] = null, _a[CHANGE] = null, _a),
  selectNearestSegmentOnFocus: false,
  selectPreviousSegmentOnBackspace: false,
  enableMouseWheel: false,
  allowCaretMode: false,
  autoSwitchParts: true,
  autoSwitchKeys: [],
  twoDigitYearMax: Constants.twoDigitYearMax,
  autoCorrectParts: true,
  autoFill: false,
  toggleDayPeriod: false
};
var DateInput = (
  /** @class */
  (function(_super) {
    __extends(DateInput2, _super);
    function DateInput2(element, options) {
      var _this = _super.call(this, options) || this;
      _this.dateObject = null;
      _this.currentText = "";
      _this.currentFormat = "";
      _this.interactionMode = DateInputInteractionMode.None;
      _this.previousElementSelection = { start: 0, end: 0 };
      _this.init(element, options);
      return _this;
    }
    Object.defineProperty(DateInput2.prototype, "value", {
      get: function() {
        return this.dateObject && this.dateObject.getValue();
      },
      enumerable: false,
      configurable: true
    });
    DateInput2.prototype.init = function(element, options) {
      var dateValue = isValidDate(this.options.value) ? cloneDate(this.options.value) : new Date(options.formattedValue);
      if (!isValidDate(dateValue)) {
        dateValue = null;
      }
      this.element = element;
      this.options = extend({}, defaultDateInputOptions, options, { steps: __assign(__assign({}, defaultDateInputOptions.steps), options.steps) });
      this.intl = this.options.intlService;
      this.dateObject = this.createDateObject();
      this.dateObject.setValue(dateValue);
      this.setTextAndFormat();
      this.bindEvents();
      this.resetSegmentValue = true;
      this.interactionMode = DateInputInteractionMode.None;
      this.forceUpdate();
    };
    DateInput2.prototype.destroy = function() {
      this.unbindEvents();
      this.dateObject = null;
      _super.prototype.destroy.call(this);
    };
    DateInput2.prototype.bindEvents = function() {
      this.onElementDragStart = this.onElementDragStart.bind(this);
      this.element.addEventListener(DRAG_START, this.onElementDragStart);
      this.onElementDrop = this.onElementDrop.bind(this);
      this.element.addEventListener(DROP, this.onElementDrop);
      this.onElementClick = this.onElementClick.bind(this);
      this.element.addEventListener(CLICK, this.onElementClick);
      this.onElementMouseDown = this.onElementMouseDown.bind(this);
      this.element.addEventListener(MOUSE_DOWN, this.onElementMouseDown);
      this.element.addEventListener(TOUCH_START, this.onElementMouseDown);
      this.onElementMouseUp = this.onElementMouseUp.bind(this);
      this.element.addEventListener(MOUSE_UP, this.onElementMouseUp);
      this.onElementInput = this.onElementInput.bind(this);
      this.element.addEventListener(INPUT, this.onElementInput);
      this.onElementKeyDown = this.onElementKeyDown.bind(this);
      this.element.addEventListener(KEY_DOWN, this.onElementKeyDown);
      this.onElementFocus = this.onElementFocus.bind(this);
      this.element.addEventListener(FOCUS, this.onElementFocus);
      this.onElementBlur = this.onElementBlur.bind(this);
      this.element.addEventListener(BLUR, this.onElementBlur);
      this.onElementChange = this.onElementChange.bind(this);
      this.element.addEventListener(CHANGE, this.onElementChange);
      this.onElementPaste = this.onElementPaste.bind(this);
      this.element.addEventListener(PASTE, this.onElementPaste);
      this.onElementMouseWheel = this.onElementMouseWheel.bind(this);
      this.element.addEventListener(MOUSE_SCROLL, this.onElementMouseWheel);
      this.element.addEventListener(MOUSE_WHEEL, this.onElementMouseWheel);
    };
    DateInput2.prototype.unbindEvents = function() {
      this.element.removeEventListener(DRAG_START, this.onElementDragStart);
      this.element.removeEventListener(DROP, this.onElementDrop);
      this.element.removeEventListener(TOUCH_START, this.onElementMouseDown);
      this.element.removeEventListener(MOUSE_DOWN, this.onElementMouseDown);
      this.element.removeEventListener(MOUSE_UP, this.onElementMouseUp);
      this.element.removeEventListener(CLICK, this.onElementClick);
      this.element.removeEventListener(INPUT, this.onElementInput);
      this.element.removeEventListener(KEY_DOWN, this.onElementKeyDown);
      this.element.removeEventListener(FOCUS, this.onElementFocus);
      this.element.removeEventListener(BLUR, this.onElementBlur);
      this.element.removeEventListener(CHANGE, this.onElementChange);
      this.element.removeEventListener(PASTE, this.onElementPaste);
      this.element.removeEventListener(MOUSE_SCROLL, this.onElementMouseWheel);
      this.element.removeEventListener(MOUSE_WHEEL, this.onElementMouseWheel);
    };
    DateInput2.prototype.setOptions = function(options, refresh) {
      if (refresh === void 0) {
        refresh = false;
      }
      this.options = extend({}, this.options, options, { steps: __assign(__assign({}, defaultDateInputOptions.steps), options.steps) });
      this.setDateObjectOptions();
      if (refresh) {
        this.unbindEvents();
        this.init(this.element, this.options);
      }
    };
    DateInput2.prototype.setDateObjectOptions = function() {
      if (this.dateObject) {
        var newOptions = this.getDateObjectOptions();
        this.dateObject.setOptions(newOptions);
      }
    };
    DateInput2.prototype.resetLocale = function() {
      this.unbindEvents();
      this.init(this.element, this.options);
    };
    DateInput2.prototype.isInCaretMode = function() {
      return this.interactionMode === DateInputInteractionMode.Caret;
    };
    DateInput2.prototype.focus = function() {
      this.element.focus();
      if (this.options.selectNearestSegmentOnFocus) {
        this.selectNearestSegment(0);
      }
    };
    DateInput2.prototype.onElementDragStart = function(e) {
      e.preventDefault();
    };
    DateInput2.prototype.onElementDrop = function(e) {
      e.preventDefault();
    };
    DateInput2.prototype.onElementMouseDown = function() {
      this.mouseDownStarted = true;
      this.focusedPriorToMouseDown = this.isActive;
    };
    DateInput2.prototype.onElementMouseUp = function(e) {
      this.mouseDownStarted = false;
      e.preventDefault();
    };
    DateInput2.prototype.onElementClick = function(e) {
      this.mouseDownStarted = false;
      this.switchedPartOnPreviousKeyAction = false;
      var selection = this.selection;
      if (this.isInCaretMode()) {
        this.forceUpdate();
      }
      if (e.detail === 3) {
      } else {
        if (this.isActive && this.options.selectNearestSegmentOnFocus) {
          var selectionPresent = this.element.selectionStart !== this.element.selectionEnd;
          var placeholderToggled = isPresent3(this.options.placeholder) && !this.dateObject.hasValue() && !this.focusedPriorToMouseDown;
          var selectFirstSegment = !selectionPresent && placeholderToggled;
          var index = selectFirstSegment ? 0 : this.caret()[0];
          this.selectNearestSegment(index);
        } else {
          this.setSelection(this.selectionByIndex(selection.start));
        }
      }
    };
    DateInput2.prototype.onElementInput = function(e) {
      this.triggerInput({ event: e });
      var oldElementValue = this.elementValue;
      if (!this.element || !this.dateObject) {
        return;
      }
      var switchedPartOnPreviousKeyAction = this.switchedPartOnPreviousKeyAction;
      if (this.isPasteInProgress) {
        if (this.options.allowCaretMode) {
          this.resetSegmentValue = false;
        }
        this.updateOnPaste(e);
        this.isPasteInProgress = false;
        return;
      }
      var keyDownEvent = this.keyDownEvent || {};
      var isBackspaceKey = keyDownEvent.keyCode === KeyCode.BACKSPACE || keyDownEvent.key === Key.BACKSPACE;
      var isDeleteKey = keyDownEvent.keyCode === KeyCode.DELETE || keyDownEvent.key === Key.DELETE;
      var originalInteractionMode = this.interactionMode;
      if (this.options.allowCaretMode && originalInteractionMode !== DateInputInteractionMode.Caret && !isDeleteKey && !isBackspaceKey) {
        this.resetSegmentValue = true;
      }
      if (this.options.allowCaretMode) {
        this.interactionMode = DateInputInteractionMode.Caret;
      } else {
        this.interactionMode = DateInputInteractionMode.Selection;
      }
      var hasCaret = this.isInCaretMode();
      if (hasCaret && this.keyDownEvent.key === Key.SPACE) {
        this.restorePreviousInputEventState();
        return;
      }
      var oldExistingDateValue = this.dateObject && this.dateObject.getValue();
      var oldDateValue = this.dateObject ? this.dateObject.value : null;
      var _a2 = this.dateObject.getTextAndFormat(), currentText = _a2.text, currentFormat = _a2.format;
      this.currentFormat = currentFormat;
      var oldText = "";
      if (hasCaret) {
        if (isBackspaceKey || isDeleteKey) {
          oldText = this.previousElementValue;
        } else if (originalInteractionMode === DateInputInteractionMode.Caret) {
          oldText = this.previousElementValue;
        } else {
          oldText = currentText;
        }
      } else {
        oldText = currentText;
      }
      var newText = this.elementValue;
      var diff = approximateStringMatching({
        oldText,
        newText,
        formatPattern: this.currentFormat,
        selectionStart: this.selection.start,
        isInCaretMode: hasCaret,
        keyEvent: this.keyDownEvent
      });
      if (diff && diff.length && diff[0] && diff[0][1] !== Constants.formatSeparator) {
        this.switchedPartOnPreviousKeyAction = false;
      }
      if (hasCaret && (!diff || diff.length === 0)) {
        this.restorePreviousInputEventState();
        return;
      } else if (hasCaret && diff.length === 1) {
        if (!diff[0] || !diff[0][0]) {
          this.restorePreviousInputEventState();
          return;
        } else if (hasCaret && diff[0] && (diff[0][0] === Constants.formatSeparator || diff[0][1] === Constants.formatSeparator)) {
          this.restorePreviousInputEventState();
          return;
        }
      }
      var navigationOnly = diff.length === 1 && diff[0][1] === Constants.formatSeparator;
      var parsePartsResults = [];
      var switchPart = false;
      var error = null;
      if (!navigationOnly) {
        for (var i = 0; i < diff.length; i++) {
          var parsePartResult = this.dateObject.parsePart({
            symbol: diff[i][0],
            currentChar: diff[i][1],
            resetSegmentValue: this.resetSegmentValue,
            cycleSegmentValue: !this.isInCaretMode(),
            rawTextValue: this.element.value,
            isDeleting: isBackspaceKey || isDeleteKey,
            originalFormat: this.currentFormat
          });
          parsePartsResults.push(parsePartResult);
          if (!parsePartResult.value) {
            error = { type: "parse" };
          }
          switchPart = parsePartResult.switchToNext;
        }
      }
      if (!this.options.autoSwitchParts) {
        switchPart = false;
      }
      this.resetSegmentValue = false;
      var hasFixedFormat = this.options.format === this.currentFormat || // all not fixed formats are 1 symbol, e.g. "d"
      isPresent3(this.options.format) && this.options.format.length > 1;
      var lastParseResult = parsePartsResults[parsePartsResults.length - 1];
      var lastParseResultHasNoValue = lastParseResult && !isPresent3(lastParseResult.value);
      var parsingFailedOnDelete = hasCaret && (isBackspaceKey || isDeleteKey) && lastParseResultHasNoValue;
      var resetPart = lastParseResult ? lastParseResult.resetPart : false;
      var newExistingDateValue = this.dateObject.getValue();
      var hasExistingDateValueChanged = !isEqual(oldExistingDateValue, newExistingDateValue);
      var newDateValue = this.dateObject.value;
      var symbolForSelection;
      var currentSelection = this.selection;
      if (hasCaret) {
        var diffChar = diff && diff.length > 0 ? diff[0][0] : null;
        var hasLeadingZero = this.dateObject.getLeadingZero()[diffChar];
        if (diff.length && diff[0][0] !== Constants.formatSeparator) {
          if (switchPart) {
            this.forceUpdateWithSelection();
            this.switchDateSegment(1);
          } else if (resetPart) {
            symbolForSelection = this.currentFormat[currentSelection.start];
            if (symbolForSelection) {
              this.forceUpdate();
              this.setSelection(this.selectionBySymbol(symbolForSelection));
            } else {
              this.restorePreviousInputEventState();
            }
          } else if (parsingFailedOnDelete) {
            this.forceUpdate();
            if (diff.length && diff[0][0] !== Constants.formatSeparator) {
              this.setSelection(this.selectionBySymbol(diff[0][0]));
            }
          } else if (lastParseResultHasNoValue) {
            if (e.data === "0" && hasLeadingZero) {
            } else if (isPresent3(oldExistingDateValue) && !isPresent3(newExistingDateValue)) {
              this.restorePreviousInputEventState();
            } else if (!isPresent3(oldExistingDateValue) && isPresent3(newExistingDateValue)) {
              this.forceUpdateWithSelection();
            } else if (isPresent3(oldExistingDateValue) && isPresent3(newExistingDateValue)) {
              if (hasExistingDateValueChanged) {
                this.forceUpdateWithSelection();
              } else {
                this.restorePreviousInputEventState();
              }
            } else if (!isPresent3(oldExistingDateValue) && !isPresent3(newExistingDateValue)) {
              this.forceUpdateWithSelection();
            } else if (oldDateValue !== newDateValue) {
            } else {
              this.restorePreviousInputEventState();
            }
          } else if (!lastParseResultHasNoValue) {
            if (!hasFixedFormat) {
              this.forceUpdateWithSelection();
            }
          }
        } else {
          if (!this.options.autoSwitchParts && diff[0][1] === Constants.formatSeparator) {
          } else {
            this.setSelection(this.selectionBySymbol(diff[0][0]));
          }
        }
      } else if (!hasCaret) {
        this.forceUpdate();
        if (diff.length && diff[0][0] !== Constants.formatSeparator) {
          this.setSelection(this.selectionBySymbol(diff[0][0]));
        }
        if (this.options.autoSwitchParts) {
          if (navigationOnly) {
            this.resetSegmentValue = true;
            if (!switchedPartOnPreviousKeyAction) {
              this.switchDateSegment(1);
            }
            this.switchedPartOnPreviousKeyAction = true;
          } else if (switchPart) {
            this.switchDateSegment(1);
            this.switchedPartOnPreviousKeyAction = true;
          }
        } else {
          if (lastParseResult && lastParseResult.switchToNext) {
            this.resetSegmentValue = true;
          } else if (navigationOnly) {
            this.resetSegmentValue = true;
            if (!switchedPartOnPreviousKeyAction) {
              this.switchDateSegment(1);
            }
            this.switchedPartOnPreviousKeyAction = true;
          }
        }
        if (isBackspaceKey && this.options.selectPreviousSegmentOnBackspace) {
          this.switchDateSegment(-1);
        }
      }
      this.tryTriggerValueChange({
        oldValue: oldExistingDateValue,
        event: e
      });
      this.triggerInputEnd({ event: e, error, oldElementValue, newElementValue: this.elementValue });
      if (hasCaret) {
        this.setTextAndFormat();
      }
    };
    DateInput2.prototype.onElementFocus = function(e) {
      if (this.triggerFocus({ event: e })) {
        return;
      }
      this.isActive = true;
      this.interactionMode = DateInputInteractionMode.None;
      this.switchedPartOnPreviousKeyAction = false;
      this.refreshElementValue();
      if (!this.mouseDownStarted) {
        this.caret(0, this.elementValue.length);
      }
      this.mouseDownStarted = false;
      this.triggerFocusEnd({ event: e });
    };
    DateInput2.prototype.onElementBlur = function(e) {
      this.resetSegmentValue = true;
      this.isActive = false;
      if (this.triggerBlur({ event: e })) {
        return;
      }
      if (this.options.autoFill) {
        this.autoFill();
      }
      this.interactionMode = DateInputInteractionMode.None;
      this.switchedPartOnPreviousKeyAction = false;
      this.refreshElementValue();
      this.triggerBlurEnd({ event: e });
    };
    DateInput2.prototype.onElementChange = function(e) {
      this.triggerChange({ event: e });
    };
    DateInput2.prototype.onElementKeyDown = function(e) {
      if (this.triggerKeyDown({ event: e })) {
        return;
      }
      var _a2 = this.selection, start = _a2.start, end = _a2.end;
      var event = e;
      this.keyDownEvent = e;
      this.previousElementValue = this.element.value;
      this.previousElementSelection = { start, end };
      if (this.keyEventMatchesAutoSwitchKeys(e)) {
        var isTabKey = e.keyCode === KeyCode.TAB;
        if (isTabKey) {
          var _b = this.selection, selectionStart = _b.start, selectionEnd = _b.end;
          if (e.shiftKey && isTabKey) {
            this.switchDateSegment(-1);
          } else {
            this.switchDateSegment(1);
          }
          if (selectionStart !== this.selection.start || selectionEnd !== this.selection.end) {
            e.preventDefault();
            return;
          }
        } else {
          e.preventDefault();
          this.switchDateSegment(1);
          return;
        }
      }
      var symbol = this.currentFormat[this.selection.start];
      var step = this.getStepFromSymbol(symbol);
      var shouldPreventDefault = false;
      var oldElementValue = this.elementValue;
      if (e.altKey || e.ctrlKey || e.metaKey || e.keyCode === KeyCode.TAB) {
        return;
      }
      switch (e.keyCode) {
        case KeyCode.ARROW_LEFT:
          this.switchDateSegment(-1);
          shouldPreventDefault = true;
          this.switchedPartOnPreviousKeyAction = false;
          break;
        case KeyCode.ARROW_UP:
          this.modifyDateSegmentValue(step, symbol, event);
          if (oldElementValue !== this.elementValue) {
            this.triggerInputEnd({ event: e, error: null, newElementValue: this.elementValue, oldElementValue });
          }
          shouldPreventDefault = true;
          this.switchedPartOnPreviousKeyAction = false;
          break;
        case KeyCode.ARROW_RIGHT:
          this.switchDateSegment(1);
          shouldPreventDefault = true;
          this.switchedPartOnPreviousKeyAction = false;
          break;
        case KeyCode.ARROW_DOWN:
          this.modifyDateSegmentValue(-step, symbol, event);
          if (oldElementValue !== this.elementValue) {
            this.triggerInputEnd({ event: e, error: null, newElementValue: this.elementValue, oldElementValue });
          }
          shouldPreventDefault = true;
          this.switchedPartOnPreviousKeyAction = false;
          break;
        case KeyCode.ENTER:
          break;
        case KeyCode.HOME:
          this.selectNearestSegment(0);
          shouldPreventDefault = true;
          this.switchedPartOnPreviousKeyAction = false;
          this.resetSegmentValue = true;
          break;
        case KeyCode.END:
          this.selectNearestSegment(this.elementValue.length);
          shouldPreventDefault = true;
          this.switchedPartOnPreviousKeyAction = false;
          this.resetSegmentValue = true;
          break;
        default:
          return;
      }
      if (shouldPreventDefault) {
        e.preventDefault();
      }
    };
    DateInput2.prototype.onElementPaste = function() {
      this.isPasteInProgress = true;
    };
    DateInput2.prototype.onElementMouseWheel = function(e) {
      var oldElementValue = this.elementValue;
      if (!this.options.enableMouseWheel || this.triggerMouseWheel({ event: e })) {
        return;
      }
      if (!this.isActive) {
        return;
      }
      var event = e;
      if (event.shiftKey) {
        this.switchDateSegment((event.wheelDelta || -event.detail) > 0 ? -1 : 1);
      } else {
        this.modifyDateSegmentValue((event.wheelDelta || -event.detail) > 0 ? 1 : -1);
      }
      event.returnValue = false;
      if (event.preventDefault) {
        event.preventDefault();
      }
      if (oldElementValue !== this.elementValue) {
        this.triggerInputEnd({ event: e, error: null, newElementValue: this.elementValue, oldElementValue });
      }
    };
    DateInput2.prototype.updateOnPaste = function(e) {
      var value2 = this.intl.parseDate(this.elementValue, this.inputFormat) || this.value;
      if (isPresent3(value2) && this.dateObject.shouldNormalizeCentury()) {
        value2 = this.dateObject.normalizeCentury(value2);
      }
      var oldDateObjectValue = this.dateObject && this.dateObject.getValue();
      this.writeValue(value2);
      this.tryTriggerValueChange({
        oldValue: oldDateObjectValue,
        event: e
      });
    };
    Object.defineProperty(DateInput2.prototype, "elementValue", {
      get: function() {
        return (this.element || {}).value || "";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DateInput2.prototype, "inputFormat", {
      get: function() {
        if (!this.options.format) {
          return Constants.defaultDateFormat;
        }
        if (typeof this.options.format === "string") {
          return this.options.format;
        } else {
          return this.options.format.inputFormat;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DateInput2.prototype, "displayFormat", {
      get: function() {
        if (!this.options.format) {
          return Constants.defaultDateFormat;
        }
        if (typeof this.options.format === "string") {
          return this.options.format;
        } else {
          return this.options.format.displayFormat;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DateInput2.prototype, "selection", {
      get: function() {
        var returnValue = { start: 0, end: 0 };
        if (this.element !== null && this.element.selectionStart !== void 0) {
          returnValue = {
            start: this.element.selectionStart,
            end: this.element.selectionEnd
          };
        }
        return returnValue;
      },
      enumerable: false,
      configurable: true
    });
    DateInput2.prototype.setSelection = function(selection) {
      if (this.element && document.activeElement === this.element) {
        this.element.setSelectionRange(selection.start, selection.end);
        if (isDocumentAvailable2() && isIOS()) {
          this.element.scrollIntoView({ block: "nearest", inline: "nearest" });
        }
        if (selection.start !== selection.end) {
          this.interactionMode = DateInputInteractionMode.Selection;
        }
      }
    };
    DateInput2.prototype.selectionBySymbol = function(symbol) {
      var start = -1;
      var end = 0;
      for (var i = 0; i < this.currentFormat.length; i++) {
        if (this.currentFormat[i] === symbol) {
          end = i + 1;
          if (start === -1) {
            start = i;
          }
        }
      }
      if (start < 0) {
        start = 0;
      }
      if (!this.options.autoCorrectParts && this.currentFormat.length !== this.currentText.length) {
        if (this.currentFormat.length < this.currentText.length) {
          end += this.currentText.length - this.currentFormat.length;
        } else {
          end = Math.max(0, end - (this.currentFormat.length - this.currentText.length));
        }
      }
      return { start, end };
    };
    DateInput2.prototype.selectionByIndex = function(index) {
      var selection = { start: index, end: index };
      for (var i = index, j = index - 1; i < this.currentFormat.length || j >= 0; i++, j--) {
        if (i < this.currentFormat.length && this.currentFormat[i] !== Constants.formatSeparator) {
          selection = this.selectionBySymbol(this.currentFormat[i]);
          break;
        }
        if (j >= 0 && this.currentFormat[j] !== Constants.formatSeparator) {
          selection = this.selectionBySymbol(this.currentFormat[j]);
          break;
        }
      }
      return selection;
    };
    DateInput2.prototype.switchDateSegment = function(offset3) {
      var selection = this.selection;
      if (this.isInCaretMode()) {
        var start = selection.start;
        var currentSymbol = this.currentFormat[start - 1];
        var symbol = "";
        var symbolCandidate = "";
        if (offset3 < 0) {
          for (var i = start + offset3; i >= 0; i--) {
            symbolCandidate = this.currentFormat[i];
            if (symbolCandidate !== Constants.formatSeparator && symbolCandidate !== currentSymbol) {
              start = i;
              symbol = symbolCandidate;
              break;
            }
          }
        } else {
          for (var i = start + offset3; i < this.currentFormat.length; i++) {
            symbolCandidate = this.currentFormat[i];
            if (symbolCandidate !== Constants.formatSeparator && symbolCandidate !== currentSymbol) {
              start = i;
              symbol = symbolCandidate;
              break;
            }
          }
        }
        if (symbol) {
          this.forceUpdate();
          this.setSelection(this.selectionBySymbol(symbol));
          this.interactionMode = DateInputInteractionMode.Selection;
          return;
        }
      }
      this.interactionMode = DateInputInteractionMode.None;
      var _a2 = this.selection, selectionStart = _a2.start, selectionEnd = _a2.end;
      if (selectionStart < selectionEnd && this.currentFormat[selectionStart] !== this.currentFormat[selectionEnd - 1]) {
        this.setSelection(this.selectionByIndex(offset3 > 0 ? selectionStart : selectionEnd - 1));
        this.resetSegmentValue = true;
        this.interactionMode = DateInputInteractionMode.None;
        return;
      }
      var previousFormatSymbol = this.currentFormat[selectionStart];
      var a = selectionStart + offset3;
      while (a > 0 && a < this.currentFormat.length) {
        if (this.currentFormat[a] !== previousFormatSymbol && this.currentFormat[a] !== Constants.formatSeparator) {
          break;
        }
        a += offset3;
      }
      if (this.currentFormat[a] === Constants.formatSeparator) {
        return;
      }
      var b = a;
      while (b >= 0 && b < this.currentFormat.length) {
        if (this.currentFormat[b] !== this.currentFormat[a]) {
          break;
        }
        b += offset3;
      }
      if (a > b && (b + 1 !== selectionStart || a + 1 !== selectionEnd)) {
        this.setSelection({ start: b + 1, end: a + 1 });
        this.resetSegmentValue = true;
      } else if (a < b && (a !== selectionStart || b !== selectionEnd)) {
        this.setSelection({ start: a, end: b });
        this.resetSegmentValue = true;
      }
      this.interactionMode = DateInputInteractionMode.None;
    };
    DateInput2.prototype.modifyDateSegmentValue = function(offset3, symbol, event) {
      if (symbol === void 0) {
        symbol = "";
      }
      if (event === void 0) {
        event = {};
      }
      if (!this.dateObject || this.options.readonly) {
        return;
      }
      var oldValue = this.value;
      var step = DEFAULT_SEGMENT_STEP;
      var caret = this.caret();
      symbol = symbol || this.currentFormat[caret[0]];
      if (symbol === "S" && (!this.options.steps.millisecond || this.options.steps.millisecond === DEFAULT_SEGMENT_STEP)) {
        var msDigits = millisecondDigitsInFormat(this.inputFormat);
        step = millisecondStepFor(msDigits);
      }
      this.dateObject.modifyPart(symbol, step * offset3);
      this.tryTriggerValueChange({
        oldValue,
        event
      });
      this.forceUpdate();
      this.setSelection(this.selectionBySymbol(symbol));
    };
    DateInput2.prototype.tryTriggerValueChange = function(args) {
      if (args === void 0) {
        args = { oldValue: null, event: {} };
      }
      if (!isEqual(this.value, args.oldValue)) {
        return this.triggerValueChange(args);
      }
    };
    DateInput2.prototype.triggerValueChange = function(args) {
      if (args === void 0) {
        args = { oldValue: null, event: {} };
      }
      return this.trigger(VALUE_CHANGE, extend(args, {
        value: this.value
      }));
    };
    DateInput2.prototype.triggerInput = function(args) {
      if (args === void 0) {
        args = { event: {} };
      }
      return this.trigger(INPUT, extend(args, {
        value: this.value
      }));
    };
    DateInput2.prototype.triggerInputEnd = function(args) {
      if (args === void 0) {
        args = { event: {}, error: null, oldElementValue: "", newElementValue: "" };
      }
      return this.trigger(INPUT_END, extend(args, {
        value: this.value
      }));
    };
    DateInput2.prototype.triggerFocus = function(args) {
      if (args === void 0) {
        args = { event: {} };
      }
      return this.trigger(FOCUS, extend({}, args));
    };
    DateInput2.prototype.triggerFocusEnd = function(args) {
      if (args === void 0) {
        args = { event: {} };
      }
      return this.trigger(FOCUS_END, extend({}, args));
    };
    DateInput2.prototype.triggerBlur = function(args) {
      if (args === void 0) {
        args = { event: {} };
      }
      return this.trigger(BLUR, extend({}, args));
    };
    DateInput2.prototype.triggerBlurEnd = function(args) {
      if (args === void 0) {
        args = { event: {} };
      }
      return this.trigger(BLUR_END, extend({}, args));
    };
    DateInput2.prototype.triggerChange = function(args) {
      if (args === void 0) {
        args = { event: {} };
      }
      return this.trigger(CHANGE, extend(args, {
        value: this.value
      }));
    };
    DateInput2.prototype.triggerKeyDown = function(args) {
      if (args === void 0) {
        args = { event: {} };
      }
      return this.trigger(KEY_DOWN, extend({}, args));
    };
    DateInput2.prototype.triggerMouseWheel = function(args) {
      if (args === void 0) {
        args = { event: {} };
      }
      return this.trigger(MOUSE_WHEEL, extend({}, args));
    };
    DateInput2.prototype.forceUpdate = function() {
      this.setTextAndFormat();
      this.refreshElementValue();
    };
    DateInput2.prototype.forceUpdateWithSelection = function() {
      var _a2 = this.selection, start = _a2.start, end = _a2.end;
      var elementValueLength = this.elementValue.length;
      this.forceUpdate();
      var selectionOffset = this.elementValue.length - elementValueLength;
      this.setSelection({
        start: start + selectionOffset,
        end: end + selectionOffset
      });
    };
    DateInput2.prototype.setTextAndFormat = function() {
      var _a2 = this.dateObject.getTextAndFormat(), currentText = _a2.text, currentFormat = _a2.format;
      this.currentFormat = currentFormat;
      this.currentText = currentText;
    };
    DateInput2.prototype.setElementValue = function(value2) {
      this.element.value = value2;
    };
    DateInput2.prototype.getStepFromSymbol = function(symbol) {
      switch (symbol) {
        case "S":
          return Number(this.options.steps.millisecond);
        case "s":
          return Number(this.options.steps.second);
        case "m":
          return Number(this.options.steps.minute);
        // represents hour as value from 01 through 12
        case "h":
        // represents hour as value from 01 through 23
        case "H":
          return Number(this.options.steps.hour);
        case "M":
          return Number(this.options.steps.month);
        // there is no 'D' format specifier for day
        case "d":
        // used for formats such as "EEEE, MMMM d, yyyy",
        // where "EEEE" stands for full name of the day e.g. Monday
        case "E":
          return Number(this.options.steps.day);
        // there is no 'Y' format specifier for year
        case "y":
          return Number(this.options.steps.year);
        default:
          return DEFAULT_SEGMENT_STEP;
      }
    };
    DateInput2.prototype.restorePreviousInputEventState = function() {
      this.restorePreviousElementValue();
      this.restorePreviousElementSelection();
    };
    DateInput2.prototype.restorePreviousElementValue = function() {
      this.setElementValue(this.previousElementValue || "");
    };
    DateInput2.prototype.restorePreviousElementSelection = function() {
      var _a2 = this.previousElementSelection, start = _a2.start, end = _a2.end;
      this.setSelection({ start: start || 0, end: end || 0 });
    };
    DateInput2.prototype.writeValue = function(value2) {
      this.verifyValue(value2);
      this.dateObject = this.getDateObject(value2);
      this.refreshElementValue();
    };
    DateInput2.prototype.verifyValue = function(value2) {
      if (value2 && !isValidDate(value2)) {
        throw new Error("The 'value' should be a valid JavaScript Date instance.");
      }
    };
    DateInput2.prototype.refreshElementValue = function() {
      var element = this.element;
      var format = this.isActive ? this.inputFormat : this.displayFormat;
      var _a2 = this.dateObject.getTextAndFormat(format), currentText = _a2.text, currentFormat = _a2.format;
      this.currentFormat = currentFormat;
      this.currentText = currentText;
      var hasPlaceholder = this.options.hasPlaceholder || isPresent3(this.options.placeholder);
      var showPlaceholder = !this.isActive && hasPlaceholder && !this.dateObject.hasValue();
      if (hasPlaceholder && isPresent3(this.options.placeholder)) {
        element.placeholder = this.options.placeholder;
      }
      var newElementValue = showPlaceholder ? "" : currentText;
      this.previousElementValue = this.elementValue;
      this.setElementValue(newElementValue);
    };
    DateInput2.prototype.caret = function(start, end) {
      if (end === void 0) {
        end = start;
      }
      var isPosition = start !== void 0;
      var returnValue = [start, start];
      var element = this.element;
      if (isPosition && (this.options.disabled || this.options.readonly)) {
        return void 0;
      }
      try {
        if (element.selectionStart !== void 0) {
          if (isPosition) {
            if (isDocumentAvailable2() && document.activeElement !== element) {
              element.focus();
            }
            element.setSelectionRange(start, end);
          }
          returnValue = [element.selectionStart, element.selectionEnd];
        }
      } catch (e) {
        returnValue = [];
      }
      return returnValue;
    };
    DateInput2.prototype.selectNearestSegment = function(index) {
      for (var i = index, j = index - 1; i < this.currentFormat.length || j >= 0; i++, j--) {
        if (i < this.currentFormat.length && this.currentFormat[i] !== "_") {
          this.selectDateSegment(this.currentFormat[i]);
          return;
        }
        if (j >= 0 && this.currentFormat[j] !== "_") {
          this.selectDateSegment(this.currentFormat[j]);
          return;
        }
      }
    };
    DateInput2.prototype.selectDateSegment = function(symbol) {
      var begin = -1;
      var end = 0;
      for (var i = 0; i < this.currentFormat.length; i++) {
        if (this.currentFormat[i] === symbol) {
          end = i + 1;
          if (begin === -1) {
            begin = i;
          }
        }
      }
      if (begin < 0) {
        begin = 0;
      }
      this.caret(0, 0);
      this.caret(begin, end);
    };
    DateInput2.prototype.getDateObject = function(value2) {
      var leadingZero = (this.dateObject || {}).leadingZero;
      this.options.value = value2;
      var dateObject = this.createDateObject();
      dateObject.setLeadingZero(this.isActive ? leadingZero : null);
      return dateObject;
    };
    DateInput2.prototype.createDateObject = function() {
      var defaultOptions2 = this.getDateObjectOptions();
      var dateObject = new DateObject(extend({}, defaultOptions2));
      return dateObject;
    };
    DateInput2.prototype.getDateObjectOptions = function() {
      var newOptions = {
        intlService: this.options.intlService,
        formatPlaceholder: this.options.formatPlaceholder ? this.options.formatPlaceholder : "formatPattern",
        format: this.inputFormat,
        cycleTime: this.options.cycleTime,
        twoDigitYearMax: this.options.twoDigitYearMax,
        autoCorrectParts: this.options.autoCorrectParts,
        value: this.options.value,
        toggleDayPeriod: this.options.toggleDayPeriod,
        autoSwitchParts: this.options.autoSwitchParts
      };
      return newOptions;
    };
    DateInput2.prototype.keyEventMatchesAutoSwitchKeys = function(keyObject) {
      var autoSwitchKeys = (this.options.autoSwitchKeys || []).map(function(x) {
        return x.toString().toLowerCase().trim();
      });
      if (autoSwitchKeys.indexOf(keyObject.keyCode.toString()) >= 0 || autoSwitchKeys.indexOf(keyObject.keyCode) >= 0 || autoSwitchKeys.indexOf(keyObject.key.toLowerCase().trim()) >= 0) {
        return true;
      }
      return false;
    };
    DateInput2.prototype.autoFill = function() {
      var dateObject = this.dateObject;
      var currentDate = /* @__PURE__ */ new Date();
      var day, month, year, hours, minutes, seconds;
      if (dateObject.date || dateObject.month || dateObject.year || dateObject.hours || dateObject.minutes || dateObject.seconds) {
        year = dateObject.year ? dateObject.value.getFullYear() : currentDate.getFullYear(), month = dateObject.month ? dateObject.value.getMonth() : currentDate.getMonth(), day = dateObject.date ? dateObject.value.getDate() : currentDate.getDate(), hours = dateObject.hours ? dateObject.value.getHours() : currentDate.getHours(), minutes = dateObject.minutes ? dateObject.value.getMinutes() : currentDate.getMinutes(), seconds = dateObject.seconds ? dateObject.value.getSeconds() : currentDate.getSeconds();
        dateObject.setValue(new Date(year, month, day, hours, minutes, seconds));
        this.refreshElementValue();
        this.triggerValueChange();
      }
    };
    return DateInput2;
  })(Observable2)
);

// node_modules/@progress/kendo-angular-dateinputs/fesm2022/progress-kendo-angular-dateinputs.mjs
var _c0 = ["kendoCalendarView", ""];
var _c1 = (a0, a1) => ({
  $implicit: a0,
  cellContext: a1
});
function ViewComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr", 0)(1, "th", 2);
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵattribute("aria-hidden", ctx_r0.ariaHidden);
    ɵɵadvance();
    ɵɵproperty("colSpan", ctx_r0.colSpan);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.title);
  }
}
function ViewComponent_tr_1_Conditional_1_Conditional_0_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const row_r3 = ɵɵnextContext(3).$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵtextInterpolate1(" ", ctx_r0.getWeekNumber(ctx_r0.firstDate(row_r3)), " ");
  }
}
function ViewComponent_tr_1_Conditional_1_Conditional_0_Conditional_2_ng_template_0_Template(rf, ctx) {
}
function ViewComponent_tr_1_Conditional_1_Conditional_0_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ViewComponent_tr_1_Conditional_1_Conditional_0_Conditional_2_ng_template_0_Template, 0, 0, "ng-template", 7);
  }
  if (rf & 2) {
    const row_r3 = ɵɵnextContext(3).$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.weekNumberTemplateRef)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c1, ctx_r0.firstDate(row_r3), ctx_r0.getWeekNumberContext(row_r3)));
  }
}
function ViewComponent_tr_1_Conditional_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "td", 6);
    ɵɵlistener("click", function ViewComponent_tr_1_Conditional_1_Conditional_0_Template_td_click_0_listener() {
      ɵɵrestoreView(_r2);
      const row_r3 = ɵɵnextContext(2).$implicit;
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.handleWeekNumberClick(row_r3));
    });
    ɵɵconditionalCreate(1, ViewComponent_tr_1_Conditional_1_Conditional_0_Conditional_1_Template, 1, 1);
    ɵɵconditionalCreate(2, ViewComponent_tr_1_Conditional_1_Conditional_0_Conditional_2_Template, 1, 5, null, 7);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵconditional(!ctx_r0.weekNumberTemplateRef ? 1 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r0.weekNumberTemplateRef ? 2 : -1);
  }
}
function ViewComponent_tr_1_Conditional_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 5);
    ɵɵtext(1, " ");
    ɵɵelementEnd();
  }
}
function ViewComponent_tr_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, ViewComponent_tr_1_Conditional_1_Conditional_0_Template, 3, 2, "td", 4)(1, ViewComponent_tr_1_Conditional_1_Conditional_1_Template, 2, 0, "td", 5);
  }
  if (rf & 2) {
    const row_r3 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵconditional(ctx_r0.firstDate(row_r3) ? 0 : 1);
  }
}
function ViewComponent_tr_1_ng_container_2_Conditional_1_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const cell_r4 = ɵɵnextContext(2).$implicit;
    ɵɵtextInterpolate(cell_r4.formattedValue);
  }
}
function ViewComponent_tr_1_ng_container_2_Conditional_1_Conditional_3_ng_template_0_Template(rf, ctx) {
}
function ViewComponent_tr_1_ng_container_2_Conditional_1_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ViewComponent_tr_1_ng_container_2_Conditional_1_Conditional_3_ng_template_0_Template, 0, 0, "ng-template", 7);
  }
  if (rf & 2) {
    const cell_r4 = ɵɵnextContext(2).$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.templateRef)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c1, cell_r4.value, cell_r4));
  }
}
function ViewComponent_tr_1_ng_container_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 8)(1, "span", 9);
    ɵɵconditionalCreate(2, ViewComponent_tr_1_ng_container_2_Conditional_1_Conditional_2_Template, 1, 1);
    ɵɵconditionalCreate(3, ViewComponent_tr_1_ng_container_2_Conditional_1_Conditional_3_Template, 1, 5, null, 7);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    const cell_r4 = ctx_r4.$implicit;
    const cellIndex_r6 = ctx_r4.index;
    const rowIndex_r7 = ɵɵnextContext().index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ctx_r0.getStyles(cell_r4))("title", cell_r4.title);
    ɵɵattribute("id", cell_r4.id)("data-cell-index", ctx_r0.tableCellIndex(rowIndex_r7, cellIndex_r6))("aria-selected", cell_r4.isSelected || cell_r4.isRangeStart || cell_r4.isRangeMid || cell_r4.isRangeEnd)("aria-disabled", cell_r4.isDisabled)("aria-label", ctx_r0.getMonthLabel(cell_r4.value));
    ɵɵadvance(2);
    ɵɵconditional(!ctx_r0.templateRef ? 2 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r0.templateRef ? 3 : -1);
  }
}
function ViewComponent_tr_1_ng_container_2_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 5);
    ɵɵtext(1, " ");
    ɵɵelementEnd();
  }
}
function ViewComponent_tr_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵconditionalCreate(1, ViewComponent_tr_1_ng_container_2_Conditional_1_Template, 4, 9, "td", 8)(2, ViewComponent_tr_1_ng_container_2_Conditional_2_Template, 2, 0, "td", 5);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const cell_r4 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵconditional(ctx_r0.shouldRenderCellContent(cell_r4) ? 1 : 2);
  }
}
function ViewComponent_tr_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr", 0);
    ɵɵconditionalCreate(1, ViewComponent_tr_1_Conditional_1_Template, 2, 1);
    ɵɵtemplate(2, ViewComponent_tr_1_ng_container_2_Template, 3, 1, "ng-container", 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r3 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵconditional(ctx_r0.weekNumber ? 1 : -1);
    ɵɵadvance();
    ɵɵproperty("kForOf", row_r3);
  }
}
var _c2 = (a0) => ({
  date: a0,
  className: "k-pointer-events-none"
});
var _c3 = (a0) => ({
  date: a0
});
function HorizontalViewListComponent_ng_template_0_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "caption", 4);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const date_r3 = ɵɵnextContext().date;
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.getCaptionTitle(date_r3));
  }
}
function HorizontalViewListComponent_ng_template_0_Conditional_2_For_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 8);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const name_r4 = ctx.$implicit;
    const ɵ$index_14_r5 = ctx.$index;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵattribute("aria-label", ctx_r1.wideWeekNames[ɵ$index_14_r5]);
    ɵɵadvance();
    ɵɵtextInterpolate(name_r4);
  }
}
function HorizontalViewListComponent_ng_template_0_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "thead", 5)(1, "tr", 7);
    ɵɵrepeaterCreate(2, HorizontalViewListComponent_ng_template_0_Conditional_2_For_3_Template, 2, 2, "th", 8, ɵɵrepeaterTrackByIndex);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance(2);
    ɵɵrepeater(ctx_r1.weekNames);
  }
}
function HorizontalViewListComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "table", 3);
    ɵɵlistener("focus", function HorizontalViewListComponent_ng_template_0_Template_table_focus_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleClassicCalendarFocus());
    })("blur", function HorizontalViewListComponent_ng_template_0_Template_table_blur_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleClassicCalendarBlur($event));
    });
    ɵɵconditionalCreate(1, HorizontalViewListComponent_ng_template_0_Conditional_1_Template, 2, 1, "caption", 4);
    ɵɵconditionalCreate(2, HorizontalViewListComponent_ng_template_0_Conditional_2_Template, 4, 0, "thead", 5);
    ɵɵelementStart(3, "tbody", 6);
    ɵɵlistener("cellClick", function HorizontalViewListComponent_ng_template_0_Template_tbody_cellClick_3_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.cellClick.emit($event));
    })("weekNumberCellClick", function HorizontalViewListComponent_ng_template_0_Template_tbody_weekNumberCellClick_3_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.weekNumberCellClick.emit($event));
    })("cellEnter", function HorizontalViewListComponent_ng_template_0_Template_tbody_cellEnter_3_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.cellEnter.emit($event));
    })("cellLeave", function HorizontalViewListComponent_ng_template_0_Template_tbody_cellLeave_3_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.cellLeave.emit($event));
    })("focusedCellId", function HorizontalViewListComponent_ng_template_0_Template_tbody_focusedCellId_3_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.focusedCellChange.emit($event));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const date_r3 = ctx.date;
    const class_r6 = ctx.className;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngClass", class_r6);
    ɵɵattribute("role", ctx_r1.views >= 2 ? "none" : "grid")("aria-labelledby", ctx_r1.id)("aria-activedescendant", ctx_r1.getActiveDescendant)("tabindex", ctx_r1.getTabIndex);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.showViewHeader ? 1 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.isMonthView() ? 2 : -1);
    ɵɵadvance();
    ɵɵproperty("allowReverse", ctx_r1.allowReverse)("showOtherMonthDays", ctx_r1.showOtherMonthDays)("activeView", ctx_r1.activeView)("isActive", ctx_r1.isActive)("min", ctx_r1.min)("max", ctx_r1.max)("cellUID", ctx_r1.cellUID)("focusedDate", ctx_r1.focusedDate)("selectedDates", ctx_r1.selectedDates)("selectionRange", ctx_r1.selectionRange)("activeRangeEnd", ctx_r1.activeRangeEnd)("weekNumber", ctx_r1.weekNumber)("templateRef", ctx_r1.cellTemplateRef)("weekNumberTemplateRef", ctx_r1.weekNumberTemplateRef)("viewDate", date_r3);
  }
}
function HorizontalViewListComponent_Conditional_2_ng_template_0_Template(rf, ctx) {
}
function HorizontalViewListComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, HorizontalViewListComponent_Conditional_2_ng_template_0_Template, 0, 0, "ng-template", 1);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const tableTemplate_r7 = ɵɵreference(1);
    ɵɵproperty("ngTemplateOutlet", tableTemplate_r7)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c2, ctx_r1.nextAnimationDate));
  }
}
function HorizontalViewListComponent_3_ng_template_0_Template(rf, ctx) {
}
function HorizontalViewListComponent_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, HorizontalViewListComponent_3_ng_template_0_Template, 0, 0, "ng-template", 1);
  }
  if (rf & 2) {
    const date_r8 = ctx.$implicit;
    ɵɵnextContext();
    const tableTemplate_r7 = ɵɵreference(1);
    ɵɵproperty("ngTemplateOutlet", tableTemplate_r7)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c3, date_r8));
  }
}
function HorizontalViewListComponent_Conditional_4_ng_template_0_Template(rf, ctx) {
}
function HorizontalViewListComponent_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, HorizontalViewListComponent_Conditional_4_ng_template_0_Template, 0, 0, "ng-template", 1);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const tableTemplate_r7 = ɵɵreference(1);
    ɵɵproperty("ngTemplateOutlet", tableTemplate_r7)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c2, ctx_r1.prevAnimationDate));
  }
}
var _c4 = (a0, a1, a2) => ({
  title: a0,
  activeView: a1,
  date: a2
});
var _c5 = (a0) => ({
  click: a0
});
var _c6 = (a0, a1, a2) => ({
  $implicit: a0,
  activeView: a1,
  date: a2
});
function HeaderComponent_Conditional_0_ng_template_0_Template(rf, ctx) {
}
function HeaderComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, HeaderComponent_Conditional_0_ng_template_0_Template, 0, 0, "ng-template", 0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.headerTemplateRef)("ngTemplateOutletContext", ɵɵpureFunction3(2, _c4, ctx_r0.title, ctx_r0.activeViewValue, ctx_r0.currentDate));
  }
}
function HeaderComponent_Conditional_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵtextInterpolate1(" ", ctx_r0.title, " ");
  }
}
function HeaderComponent_Conditional_1_Conditional_2_ng_template_0_Template(rf, ctx) {
}
function HeaderComponent_Conditional_1_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, HeaderComponent_Conditional_1_Conditional_2_ng_template_0_Template, 0, 0, "ng-template", 0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.titleTemplateRef)("ngTemplateOutletContext", ɵɵpureFunction3(2, _c6, ctx_r0.title, ctx_r0.activeViewValue, ctx_r0.currentDate));
  }
}
function HeaderComponent_Conditional_1_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 7);
    ɵɵlistener("click", function HeaderComponent_Conditional_1_Conditional_5_Template_button_click_0_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.prevButtonClick.emit());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("size", ctx_r0.size)("svgIcon", ctx_r0.chevronLeftIcon)("disabled", ctx_r0.isPrevDisabled)("title", ctx_r0.prevButtonTitle);
    ɵɵattribute("aria-disabled", ctx_r0.isPrevDisabled);
  }
}
function HeaderComponent_Conditional_1_Conditional_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 8);
    ɵɵlistener("click", function HeaderComponent_Conditional_1_Conditional_8_Template_button_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.nextButtonClick.emit());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("size", ctx_r0.size)("svgIcon", ctx_r0.chevronRightIcon)("disabled", ctx_r0.isNextDisabled)("title", ctx_r0.nextButtonTitle);
    ɵɵattribute("aria-disabled", ctx_r0.isNextDisabled);
  }
}
function HeaderComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "button", 1);
    ɵɵconditionalCreate(1, HeaderComponent_Conditional_1_Conditional_1_Template, 1, 1);
    ɵɵconditionalCreate(2, HeaderComponent_Conditional_1_Conditional_2_Template, 1, 6, null, 0);
    ɵɵelementEnd();
    ɵɵelement(3, "span", 2);
    ɵɵelementStart(4, "span", 3);
    ɵɵconditionalCreate(5, HeaderComponent_Conditional_1_Conditional_5_Template, 1, 5, "button", 4);
    ɵɵelementStart(6, "button", 5);
    ɵɵtext(7);
    ɵɵelementEnd();
    ɵɵconditionalCreate(8, HeaderComponent_Conditional_1_Conditional_8_Template, 1, 5, "button", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("id", ctx_r0.id)("size", ctx_r0.size)("disabled", !ctx_r0.navigate)("kendoEventsOutsideAngular", ɵɵpureFunction1(15, _c5, ctx_r0.handleNavigation))("title", ctx_r0.parentViewButtonTitle)("scope", ctx_r0);
    ɵɵadvance();
    ɵɵconditional(!ctx_r0.titleTemplateRef ? 1 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r0.titleTemplateRef ? 2 : -1);
    ɵɵadvance(3);
    ɵɵconditional(ctx_r0.showNavigationButtons ? 5 : -1);
    ɵɵadvance();
    ɵɵproperty("size", ctx_r0.size)("disabled", !ctx_r0.todayAvailable)("kendoEventsOutsideAngular", ɵɵpureFunction1(17, _c5, ctx_r0.handleTodayClick))("scope", ctx_r0);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.todayMessage, " ");
    ɵɵadvance();
    ɵɵconditional(ctx_r0.showNavigationButtons ? 8 : -1);
  }
}
var _c7 = (a0, a1) => ({
  activeView: a0,
  date: a1
});
function FooterComponent_Conditional_0_ng_template_0_Template(rf, ctx) {
}
function FooterComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, FooterComponent_Conditional_0_ng_template_0_Template, 0, 0, "ng-template", 0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.footerTemplateRef)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c7, ctx_r0.activeViewValue, ctx_r0.currentDate));
  }
}
function FooterComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "button", 1);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.intl.formatDate(ctx_r0.getToday(), "D"), " ");
  }
}
function MultiViewCalendarComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-calendar-header", 4);
    ɵɵlistener("todayButtonClick", function MultiViewCalendarComponent_Conditional_1_Template_kendo_calendar_header_todayButtonClick_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleTodayButtonClick({
        selectedDates: [$event],
        focusedDate: $event
      }));
    })("prevButtonClick", function MultiViewCalendarComponent_Conditional_1_Template_kendo_calendar_header_prevButtonClick_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.navigateView(ctx_r1.prevView));
    })("nextButtonClick", function MultiViewCalendarComponent_Conditional_1_Template_kendo_calendar_header_nextButtonClick_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.navigateView(ctx_r1.nextView));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("activeView", ctx_r1.activeViewEnum)("currentDate", ctx_r1.activeDate)("size", ctx_r1.size)("min", ctx_r1.min)("max", ctx_r1.max)("id", ctx_r1.headerId)("rangeLength", ctx_r1.views)("titleTemplateRef", ctx_r1.headerTitleTemplateRef == null ? null : ctx_r1.headerTitleTemplateRef.templateRef)("headerTemplateRef", ctx_r1.headerTemplateRef == null ? null : ctx_r1.headerTemplateRef.templateRef)("isPrevDisabled", ctx_r1.isPrevDisabled)("isNextDisabled", ctx_r1.isNextDisabled)("showNavigationButtons", true)("orientation", ctx_r1.orientation);
  }
}
function MultiViewCalendarComponent_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-calendar-footer", 3);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("footerTemplateRef", ctx_r1.footerTemplateRef == null ? null : ctx_r1.footerTemplateRef.templateRef)("activeViewValue", ctx_r1.activeView)("currentDate", ctx_r1.activeDate);
  }
}
var _c8 = ["*"];
var _c9 = ["list"];
function NavigationComponent_li_4_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const date_r2 = ɵɵnextContext().$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵtextInterpolate1(" ", ctx_r2.service.navigationTitle(date_r2), " ");
  }
}
function NavigationComponent_li_4_Conditional_3_ng_template_0_Template(rf, ctx) {
}
function NavigationComponent_li_4_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, NavigationComponent_li_4_Conditional_3_ng_template_0_Template, 0, 0, "ng-template", 5);
  }
  if (rf & 2) {
    const date_r2 = ɵɵnextContext().$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r2.templateRef)("ngTemplateOutletContext", ɵɵpureFunction3(2, _c6, ctx_r2.service.navigationTitle(date_r2), ctx_r2.activeViewValue, date_r2));
  }
}
function NavigationComponent_li_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "li")(1, "span");
    ɵɵconditionalCreate(2, NavigationComponent_li_4_Conditional_2_Template, 1, 1);
    ɵɵconditionalCreate(3, NavigationComponent_li_4_Conditional_3_Template, 1, 6, null, 5);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const date_r2 = ctx.$implicit;
    const index_r4 = ctx.index;
    const ctx_r2 = ɵɵnextContext();
    ɵɵattribute("data-date-index", index_r4);
    ɵɵadvance();
    ɵɵclassProp("k-calendar-navigation-marker", ctx_r2.service.isRangeStart(date_r2));
    ɵɵadvance();
    ɵɵconditional(!ctx_r2.templateRef ? 2 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r2.templateRef ? 3 : -1);
  }
}
function ViewListComponent_Conditional_1_For_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 10);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const name_r2 = ctx.$implicit;
    const ɵ$index_10_r3 = ctx.$index;
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵattribute("aria-label", ctx_r3.wideWeekNames[ɵ$index_10_r3]);
    ɵɵadvance();
    ɵɵtextInterpolate(name_r2);
  }
}
function ViewListComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "table", 7)(1, "thead", 8)(2, "tr", 9);
    ɵɵrepeaterCreate(3, ViewListComponent_Conditional_1_For_4_Template, 2, 2, "th", 10, ɵɵrepeaterTrackByIndex);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵstyleProp("table-layout", "auto");
    ɵɵadvance(3);
    ɵɵrepeater(ctx_r3.weekNames);
  }
}
function ViewListComponent_For_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "col");
  }
}
function ViewListComponent_tbody_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "tbody", 11);
    ɵɵlistener("cellClick", function ViewListComponent_tbody_8_Template_tbody_cellClick_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.cellClick.emit($event));
    })("weekNumberCellClick", function ViewListComponent_tbody_8_Template_tbody_weekNumberCellClick_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.weekNumberCellClick.emit($event));
    })("focusedCellId", function ViewListComponent_tbody_8_Template_tbody_focusedCellId_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.focusedCellChange.emit($event));
    })("cellEnter", function ViewListComponent_tbody_8_Template_tbody_cellEnter_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.cellEnter.emit($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const date_r6 = ctx.$implicit;
    const ctx_r3 = ɵɵnextContext();
    ɵɵproperty("allowReverse", ctx_r3.allowReverse)("activeRangeEnd", ctx_r3.activeRangeEnd)("selectionRange", ctx_r3.selectionRange)("showOtherMonthDays", ctx_r3.showOtherMonthDays)("headerTitle", ctx_r3.headerTitle)("activeView", ctx_r3.activeView)("isActive", ctx_r3.isActive)("min", ctx_r3.min)("max", ctx_r3.max)("cellUID", ctx_r3.cellUID)("focusedDate", ctx_r3.focusedDate)("selectedDates", ctx_r3.selectedDates)("weekNumber", ctx_r3.weekNumber)("templateRef", ctx_r3.cellTemplateRef)("weekNumberTemplateRef", ctx_r3.weekNumberTemplateRef)("viewDate", date_r6);
  }
}
function ViewListComponent_Conditional_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-calendar-footer", 6);
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵproperty("footerTemplateRef", ctx_r3.footerTemplateRef)("activeViewValue", ctx_r3.activeViewValue)("currentDate", ctx_r3.activeDate);
  }
}
function CalendarComponent_Conditional_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-calendar-navigation", 6);
    ɵɵlistener("valueChange", function CalendarComponent_Conditional_1_Conditional_0_Template_kendo_calendar_navigation_valueChange_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.handleNavigation($event));
    })("pageChange", function CalendarComponent_Conditional_1_Conditional_0_Template_kendo_calendar_navigation_pageChange_0_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.onPageChange());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("activeView", ctx_r2.activeViewEnum)("focusedDate", ctx_r2.focusedDate)("min", ctx_r2.min)("max", ctx_r2.max)("templateRef", ctx_r2.navigationItemTemplateRef == null ? null : ctx_r2.navigationItemTemplateRef.templateRef);
  }
}
function CalendarComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵconditionalCreate(0, CalendarComponent_Conditional_1_Conditional_0_Template, 1, 5, "kendo-calendar-navigation", 3);
    ɵɵelementStart(1, "kendo-calendar-viewlist", 4);
    ɵɵlistener("todayButtonClick", function CalendarComponent_Conditional_1_Template_kendo_calendar_viewlist_todayButtonClick_1_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleDateChange({
        selectedDates: [$event],
        focusedDate: $event
      }));
    })("cellClick", function CalendarComponent_Conditional_1_Template_kendo_calendar_viewlist_cellClick_1_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleCellClick($event));
    })("weekNumberCellClick", function CalendarComponent_Conditional_1_Template_kendo_calendar_viewlist_weekNumberCellClick_1_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleWeekNumberClick($event));
    })("activeDateChange", function CalendarComponent_Conditional_1_Template_kendo_calendar_viewlist_activeDateChange_1_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleActiveDateChange($event));
    })("pageChange", function CalendarComponent_Conditional_1_Template_kendo_calendar_viewlist_pageChange_1_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onPageChange());
    })("focusCalendar", function CalendarComponent_Conditional_1_Template_kendo_calendar_viewlist_focusCalendar_1_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleFocus());
    })("blurCalendar", function CalendarComponent_Conditional_1_Template_kendo_calendar_viewlist_blurCalendar_1_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleBlur($event));
    })("cellEnter", function CalendarComponent_Conditional_1_Template_kendo_calendar_viewlist_cellEnter_1_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onCellEnter($event));
    });
    ɵɵelementEnd();
    ɵɵelementStart(2, "kendo-resize-sensor", 5);
    ɵɵlistener("resize", function CalendarComponent_Conditional_1_Template_kendo_resize_sensor_resize_2_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onResize());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    let tmp_11_0;
    const ctx_r2 = ɵɵnextContext();
    ɵɵconditional(ctx_r2.navigation ? 0 : -1);
    ɵɵadvance();
    ɵɵproperty("activeView", ctx_r2.activeViewEnum)("allowReverse", ctx_r2.allowReverse)("showOtherMonthDays", ctx_r2.showOtherMonthDays)("activeRangeEnd", ctx_r2.activeRangeEnd)("selectionRange", ctx_r2.selectionRange)("size", ctx_r2.size)("isActive", ctx_r2.isActive)("id", ctx_r2.headerId)("weekDaysFormat", ctx_r2.weekDaysFormat)("cellTemplateRef", (tmp_11_0 = ctx_r2.activeCellTemplate()) == null ? null : tmp_11_0.templateRef)("headerTitleTemplateRef", ctx_r2.headerTitleTemplateRef == null ? null : ctx_r2.headerTitleTemplateRef.templateRef)("headerTemplateRef", ctx_r2.headerTemplateRef == null ? null : ctx_r2.headerTemplateRef.templateRef)("showFooter", ctx_r2.footer)("footerTemplateRef", ctx_r2.footerTemplateRef == null ? null : ctx_r2.footerTemplateRef.templateRef)("weekNumberTemplateRef", ctx_r2.weekNumberTemplateRef == null ? null : ctx_r2.weekNumberTemplateRef.templateRef)("cellUID", ctx_r2.cellUID)("min", ctx_r2.min)("max", ctx_r2.max)("focusedDate", ctx_r2.focusedDate)("weekNumber", ctx_r2.weekNumber)("selectedDates", ctx_r2.selectedDates)("tabIndex", ctx_r2.tabIndex)("disabled", ctx_r2.disabled);
  }
}
function CalendarComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-multiviewcalendar", 7, 0);
    ɵɵlistener("onClosePopup", function CalendarComponent_Conditional_2_Template_kendo_multiviewcalendar_onClosePopup_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.closePopup.emit());
    })("activeViewChange", function CalendarComponent_Conditional_2_Template_kendo_multiviewcalendar_activeViewChange_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleActiveViewChange($event));
    })("navigate", function CalendarComponent_Conditional_2_Template_kendo_multiviewcalendar_navigate_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleNavigate($event));
    })("valueChange", function CalendarComponent_Conditional_2_Template_kendo_multiviewcalendar_valueChange_0_listener($event) {
      ɵɵrestoreView(_r4);
      const multiviewcalendar_r5 = ɵɵreference(1);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleMultiViewCalendarValueChange($event, multiviewcalendar_r5.focusedDate));
    })("focusCalendar", function CalendarComponent_Conditional_2_Template_kendo_multiviewcalendar_focusCalendar_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleFocus());
    })("blur", function CalendarComponent_Conditional_2_Template_kendo_multiviewcalendar_blur_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleBlur($event));
    })("blurEvent", function CalendarComponent_Conditional_2_Template_kendo_multiviewcalendar_blurEvent_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleBlur($event));
    })("keydown", function CalendarComponent_Conditional_2_Template_kendo_multiviewcalendar_keydown_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleMultiViewCalendarKeydown($event));
    });
    ɵɵelement(2, "kendo-multiviewcalendar-messages", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("views", 1)("min", ctx_r2.min)("max", ctx_r2.max)("size", ctx_r2.size)("id", ctx_r2.id)("activeRangeEnd", ctx_r2.activeRangeEnd)("selectionRange", ctx_r2.selectionRange)("allowReverse", ctx_r2.allowReverse)("disabled", ctx_r2.disabled)("isActive", ctx_r2.isActive)("showOtherMonthDays", ctx_r2.showOtherMonthDays)("tabIndex", ctx_r2.tabIndex)("activeView", ctx_r2.activeView)("bottomView", ctx_r2.bottomView)("topView", ctx_r2.topView)("weekDaysFormat", ctx_r2.weekDaysFormat)("weekNumber", ctx_r2.weekNumber)("animateNavigation", ctx_r2.animateNavigation)("cellTemplate", ctx_r2.activeCellTemplate())("monthCellTemplate", ctx_r2.monthCellTemplateRef)("yearCellTemplate", ctx_r2.yearCellTemplateRef)("decadeCellTemplate", ctx_r2.decadeCellTemplateRef)("centuryCellTemplate", ctx_r2.centuryCellTemplateRef)("headerTitleTemplate", ctx_r2.headerTitleTemplateRef)("headerTemplate", ctx_r2.headerTemplateRef)("footerTemplate", ctx_r2.footerTemplateRef)("footer", ctx_r2.footer)("weekNumberTemplate", ctx_r2.weekNumberTemplateRef)("focusedDate", ctx_r2.focusedDate)("selection", ctx_r2.selection)("value", ctx_r2.value)("disabledDates", ctx_r2.disabledDates);
    ɵɵadvance(2);
    ɵɵproperty("today", ctx_r2.localization.get("today"))("prevButtonTitle", ctx_r2.localization.get("prevButtonTitle"))("nextButtonTitle", ctx_r2.localization.get("nextButtonTitle"))("parentViewButtonTitle", ctx_r2.localization.get("parentViewButtonTitle"));
  }
}
var _c10 = ["dateInput"];
var _c11 = ["spinup"];
var _c12 = ["spindown"];
var _c13 = (a0, a1) => ({
  dragstart: a0,
  drop: a1
});
function DateInputComponent_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 7);
    ɵɵlistener("click", function DateInputComponent_Conditional_3_Template_span_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.resetInput());
    })("mousedown", function DateInputComponent_Conditional_3_Template_span_mousedown_0_listener($event) {
      ɵɵrestoreView(_r1);
      return ɵɵresetView($event.preventDefault());
    });
    ɵɵelement(1, "kendo-icon-wrapper", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵattribute("title", ctx_r1.localization.get("clearTitle"));
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r1.xIcon);
  }
}
function DateInputComponent_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 9);
    ɵɵlistener("mousedown", function DateInputComponent_Conditional_4_Template_span_mousedown_0_listener($event) {
      ɵɵrestoreView(_r3);
      return ɵɵresetView($event.preventDefault());
    });
    ɵɵelementStart(1, "button", 10, 1);
    ɵɵlistener("mousedown", function DateInputComponent_Conditional_4_Template_button_mousedown_1_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.arrowDirection = ctx_r1.arrow.Up);
    })("mouseleave", function DateInputComponent_Conditional_4_Template_button_mouseleave_1_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.arrowDirection = ctx_r1.arrow.None);
    })("click", function DateInputComponent_Conditional_4_Template_button_click_1_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleButtonClick(1));
    });
    ɵɵelement(3, "kendo-icon-wrapper", 11);
    ɵɵelementEnd();
    ɵɵelementStart(4, "button", 12, 2);
    ɵɵlistener("click", function DateInputComponent_Conditional_4_Template_button_click_4_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleButtonClick(-1));
    })("mousedown", function DateInputComponent_Conditional_4_Template_button_mousedown_4_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.arrowDirection = ctx_r1.arrow.Down);
    })("mouseleave", function DateInputComponent_Conditional_4_Template_button_mouseleave_4_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.arrowDirection = ctx_r1.arrow.None);
    });
    ɵɵelement(6, "kendo-icon-wrapper", 13);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵclassProp("k-active", ctx_r1.arrowDirection === ctx_r1.arrow.Up);
    ɵɵproperty("title", ctx_r1.localization.get("increment"));
    ɵɵattribute("aria-label", ctx_r1.localization.get("increment"));
    ɵɵadvance(2);
    ɵɵproperty("svgIcon", ctx_r1.caretAltUpIcon);
    ɵɵadvance();
    ɵɵclassProp("k-active", ctx_r1.arrowDirection === ctx_r1.arrow.Down);
    ɵɵproperty("title", ctx_r1.localization.get("decrement"));
    ɵɵattribute("aria-label", ctx_r1.localization.get("decrement"));
    ɵɵadvance(2);
    ɵɵproperty("svgIcon", ctx_r1.caretAltDownIcon);
  }
}
var _c14 = ["container"];
var _c15 = ["popupTemplate"];
var _c16 = ["toggleButton"];
var _c17 = ["actionSheet"];
var _c18 = (a0, a1) => ({
  click: a0,
  mousedown: a1
});
var _c19 = (a0, a1) => ({
  "k-adaptive-actionsheet": true,
  "k-actionsheet-fullscreen": a0,
  "k-actionsheet-bottom": a1
});
var _c20 = (a0) => ({
  height: a0
});
var _c21 = (a0) => ({
  keydown: a0
});
function DatePickerComponent_ng_template_9_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function DatePickerComponent_ng_template_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, DatePickerComponent_ng_template_9_ng_container_0_Template, 1, 0, "ng-container", 14);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const calendarTemplate_r2 = ɵɵreference(16);
    ɵɵproperty("ngTemplateOutlet", calendarTemplate_r2);
  }
}
function DatePickerComponent_Conditional_11_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-resize-sensor", 15);
    ɵɵlistener("resize", function DatePickerComponent_Conditional_11_Template_kendo_resize_sensor_resize_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.onResize());
    });
    ɵɵelementEnd();
  }
}
function DatePickerComponent_ng_template_14_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 19);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r3.adaptiveTitle);
  }
}
function DatePickerComponent_ng_template_14_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 20);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r3.adaptiveSubtitle);
  }
}
function DatePickerComponent_ng_template_14_ng_container_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function DatePickerComponent_ng_template_14_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 16)(1, "div", 17)(2, "div", 18);
    ɵɵconditionalCreate(3, DatePickerComponent_ng_template_14_Conditional_3_Template, 2, 1, "div", 19);
    ɵɵconditionalCreate(4, DatePickerComponent_ng_template_14_Conditional_4_Template, 2, 1, "div", 20);
    ɵɵelementEnd();
    ɵɵelementStart(5, "div", 21)(6, "button", 22);
    ɵɵlistener("click", function DatePickerComponent_ng_template_14_Template_button_click_6_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.show = false);
    });
    ɵɵelementEnd()()()();
    ɵɵelementStart(7, "div", 23);
    ɵɵtemplate(8, DatePickerComponent_ng_template_14_ng_container_8_Template, 1, 0, "ng-container", 14);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    const calendarTemplate_r2 = ɵɵreference(16);
    ɵɵadvance(3);
    ɵɵconditional(ctx_r3.adaptiveTitle ? 3 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r3.adaptiveSubtitle ? 4 : -1);
    ɵɵadvance(2);
    ɵɵproperty("svgIcon", ctx_r3.checkIcon)("tabIndex", -1);
    ɵɵattribute("title", ctx_r3.localization.get("adaptiveCloseButtonTitle"));
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", calendarTemplate_r2);
  }
}
function DatePickerComponent_ng_template_15_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-calendar", 24, 6);
    ɵɵlistener("closePopup", function DatePickerComponent_ng_template_15_Template_kendo_calendar_closePopup_0_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.show = false);
    })("valueChange", function DatePickerComponent_ng_template_15_Template_kendo_calendar_valueChange_0_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.handleChange(ctx_r3.mergeTime($event)));
    });
    ɵɵelement(2, "kendo-calendar-messages", 25);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵproperty("type", ctx_r3.calendarType)("size", ctx_r3.isAdaptive ? "large" : ctx_r3.size)("min", ctx_r3.min)("max", ctx_r3.max)("weekDaysFormat", ctx_r3.weekDaysFormat)("navigation", ctx_r3.navigation)("animateNavigation", ctx_r3.animateCalendarNavigation)("activeView", ctx_r3.activeView)("bottomView", ctx_r3.bottomView)("showOtherMonthDays", ctx_r3.showOtherMonthDays)("topView", ctx_r3.topView)("weekNumber", ctx_r3.weekNumber)("cellTemplate", ctx_r3.cellTemplate)("monthCellTemplate", ctx_r3.monthCellTemplate)("yearCellTemplate", ctx_r3.yearCellTemplate)("decadeCellTemplate", ctx_r3.decadeCellTemplate)("centuryCellTemplate", ctx_r3.centuryCellTemplate)("weekNumberTemplate", ctx_r3.weekNumberTemplate)("headerTitleTemplate", ctx_r3.headerTitleTemplate)("headerTemplate", ctx_r3.headerTemplate)("footerTemplate", ctx_r3.footerTemplate)("footer", ctx_r3.footer)("navigationItemTemplate", ctx_r3.navigationItemTemplate)("focusedDate", ctx_r3.focusedDate)("value", ctx_r3.value)("kendoEventsOutsideAngular", ɵɵpureFunction1(32, _c21, ctx_r3.handleKeydown))("scope", ctx_r3)("disabledDates", ctx_r3.disabledDates);
    ɵɵadvance(2);
    ɵɵproperty("today", ctx_r3.localization.get("today"))("prevButtonTitle", ctx_r3.localization.get("prevButtonTitle"))("nextButtonTitle", ctx_r3.localization.get("nextButtonTitle"))("parentViewButtonTitle", ctx_r3.localization.get("parentViewButtonTitle"));
  }
}
function TimeListComponent_For_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "li", 2)(1, "span");
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const item_r1 = ctx.$implicit;
    const ɵ$index_5_r2 = ctx.$index;
    const ctx_r2 = ɵɵnextContext();
    ɵɵattribute("data-timelist-item-index", ɵ$index_5_r2)("role", "option")("aria-selected", ɵ$index_5_r2 === ctx_r2.currentSelectedIndex);
    ɵɵadvance(2);
    ɵɵtextInterpolate(item_r1.text);
  }
}
var _c22 = ["accept"];
var _c23 = ["cancel"];
var _c24 = ["now"];
var _c25 = ["listWrapper"];
var _c26 = (a0, a1, a2, a3) => ({
  click: a0,
  focus: a1,
  blur: a2,
  keydown: a3
});
var _c27 = (a0, a1) => ({
  focus: a0,
  blur: a1
});
function TimeSelectorComponent_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "button", 7, 0);
    ɵɵtext(2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction4(6, _c26, ctx_r0.handleNow, ctx_r0.handleFocus, ctx_r0.handleBlur, ctx_r0.handleTabOut))("scope", ctx_r0)("disabled", ctx_r0.disabled);
    ɵɵattribute("title", ctx_r0.localization.get("nowLabel"))("aria-label", ctx_r0.localization.get("nowLabel"));
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.localization.get("now"));
  }
}
function TimeSelectorComponent_For_8_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 11, 1)(2, "span", 6);
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵelementStart(4, "kendo-timelist", 13);
    ɵɵtwoWayListener("valueChange", function TimeSelectorComponent_For_8_Conditional_0_Template_kendo_timelist_valueChange_4_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r0.current, $event) || (ctx_r0.current = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("tabOutLastPart", function TimeSelectorComponent_For_8_Conditional_0_Template_kendo_timelist_tabOutLastPart_4_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.tabOutLastPart.emit());
    })("tabOutFirstPart", function TimeSelectorComponent_For_8_Conditional_0_Template_kendo_timelist_tabOutFirstPart_4_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.tabOutFirstPart.emit());
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    const part_r4 = ctx_r2.$implicit;
    const ɵ$index_16_r5 = ctx_r2.$index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance(3);
    ɵɵtextInterpolate(ctx_r0.intl.dateFieldName(part_r4));
    ɵɵadvance();
    ɵɵproperty("isLast", ɵ$index_16_r5 === ctx_r0.dateFormatParts.length - 1)("isFirst", ɵ$index_16_r5 === 0)("min", ctx_r0.min)("max", ctx_r0.max)("part", part_r4)("step", ctx_r0.partStep(part_r4))("disabled", ctx_r0.disabled);
    ɵɵtwoWayProperty("value", ctx_r0.current);
    ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction2(12, _c27, ctx_r0.handleListFocus, ctx_r0.handleBlur))("scope", ctx_r0);
    ɵɵattribute("data-timelist-index", ɵ$index_16_r5);
  }
}
function TimeSelectorComponent_For_8_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 12);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const part_r4 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", part_r4.pattern, " ");
  }
}
function TimeSelectorComponent_For_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, TimeSelectorComponent_For_8_Conditional_0_Template, 5, 15, "div", 11);
    ɵɵconditionalCreate(1, TimeSelectorComponent_For_8_Conditional_1_Template, 2, 1, "div", 12);
  }
  if (rf & 2) {
    const part_r4 = ctx.$implicit;
    ɵɵconditional(part_r4.type !== "literal" ? 0 : -1);
    ɵɵadvance();
    ɵɵconditional(part_r4.type === "literal" ? 1 : -1);
  }
}
function TimeSelectorComponent_Conditional_9_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "button", 14, 2);
    ɵɵtext(2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction4(6, _c26, ctx_r0.handleAccept, ctx_r0.handleFocus, ctx_r0.handleBlur, ctx_r0.handleTabOut))("scope", ctx_r0)("disabled", ctx_r0.disabled);
    ɵɵattribute("title", ctx_r0.localization.get("acceptLabel"))("aria-label", ctx_r0.localization.get("acceptLabel"));
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.localization.get("accept"));
  }
}
function TimeSelectorComponent_Conditional_9_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "button", 15, 3);
    ɵɵtext(2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction4(6, _c26, ctx_r0.handleReject, ctx_r0.handleFocus, ctx_r0.handleBlur, ctx_r0.handleTabOut))("scope", ctx_r0)("disabled", ctx_r0.disabled);
    ɵɵattribute("title", ctx_r0.localization.get("cancelLabel"))("aria-label", ctx_r0.localization.get("cancelLabel"));
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.localization.get("cancel"));
  }
}
function TimeSelectorComponent_Conditional_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 10);
    ɵɵconditionalCreate(1, TimeSelectorComponent_Conditional_9_Conditional_1_Template, 3, 11, "button", 14);
    ɵɵconditionalCreate(2, TimeSelectorComponent_Conditional_9_Conditional_2_Template, 3, 11, "button", 15);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵconditional(ctx_r0.setButton ? 1 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r0.cancelButton ? 2 : -1);
  }
}
var _c28 = (a0, a1) => ({
  keydown: a0,
  mousedown: a1
});
function TimePickerComponent_ng_template_7_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function TimePickerComponent_ng_template_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TimePickerComponent_ng_template_7_ng_container_0_Template, 1, 0, "ng-container", 14);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const timeSelectorTemplate_r2 = ɵɵreference(16);
    ɵɵproperty("ngTemplateOutlet", timeSelectorTemplate_r2);
  }
}
function TimePickerComponent_Conditional_11_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-resize-sensor", 15);
    ɵɵlistener("resize", function TimePickerComponent_Conditional_11_Template_kendo_resize_sensor_resize_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.onResize());
    });
    ɵɵelementEnd();
  }
}
function TimePickerComponent_ng_template_14_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 19);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r3.adaptiveTitle);
  }
}
function TimePickerComponent_ng_template_14_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 20);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r3.adaptiveSubtitle);
  }
}
function TimePickerComponent_ng_template_14_ng_container_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function TimePickerComponent_ng_template_14_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 16)(1, "div", 17)(2, "div", 18);
    ɵɵconditionalCreate(3, TimePickerComponent_ng_template_14_Conditional_3_Template, 2, 1, "div", 19);
    ɵɵconditionalCreate(4, TimePickerComponent_ng_template_14_Conditional_4_Template, 2, 1, "div", 20);
    ɵɵelementEnd();
    ɵɵelementStart(5, "div", 21)(6, "button", 22);
    ɵɵlistener("click", function TimePickerComponent_ng_template_14_Template_button_click_6_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.show = false);
    });
    ɵɵelementEnd()()()();
    ɵɵelementStart(7, "div", 23);
    ɵɵtemplate(8, TimePickerComponent_ng_template_14_ng_container_8_Template, 1, 0, "ng-container", 14);
    ɵɵelementEnd();
    ɵɵelementStart(9, "div", 24)(10, "button", 25);
    ɵɵlistener("click", function TimePickerComponent_ng_template_14_Template_button_click_10_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.handleReject());
    });
    ɵɵtext(11);
    ɵɵelementEnd();
    ɵɵelementStart(12, "button", 26);
    ɵɵlistener("click", function TimePickerComponent_ng_template_14_Template_button_click_12_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.handleActionSheetAccept());
    });
    ɵɵtext(13);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    const timeSelectorTemplate_r2 = ɵɵreference(16);
    ɵɵadvance(3);
    ɵɵconditional(ctx_r3.adaptiveTitle ? 3 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r3.adaptiveSubtitle ? 4 : -1);
    ɵɵadvance(2);
    ɵɵproperty("svgIcon", ctx_r3.checkIcon)("tabIndex", -1);
    ɵɵattribute("title", ctx_r3.localization.get("adaptiveCloseButtonTitle"));
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", timeSelectorTemplate_r2);
    ɵɵadvance(2);
    ɵɵattribute("title", ctx_r3.localization.get("cancelLabel"))("aria-label", ctx_r3.localization.get("cancelLabel"));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r3.localization.get("cancel"), " ");
    ɵɵadvance();
    ɵɵattribute("title", ctx_r3.localization.get("acceptLabel"))("aria-label", ctx_r3.localization.get("acceptLabel"));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r3.localization.get("accept"), " ");
  }
}
function TimePickerComponent_ng_template_15_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-timeselector", 27, 6);
    ɵɵlistener("valueChange", function TimePickerComponent_ng_template_15_Template_kendo_timeselector_valueChange_0_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.handleChange($event));
    })("valueReject", function TimePickerComponent_ng_template_15_Template_kendo_timeselector_valueReject_0_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.handleReject());
    })("tabOutLastPart", function TimePickerComponent_ng_template_15_Template_kendo_timeselector_tabOutLastPart_0_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.onTabOutLastPart());
    })("tabOutFirstPart", function TimePickerComponent_ng_template_15_Template_kendo_timeselector_tabOutFirstPart_0_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.onTabOutFirstPart());
    })("tabOutNow", function TimePickerComponent_ng_template_15_Template_kendo_timeselector_tabOutNow_0_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.onTabOutNow());
    });
    ɵɵelement(2, "kendo-timeselector-messages", 28);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵclassProp("k-timeselector-lg", ctx_r3.isAdaptive);
    ɵɵproperty("cancelButton", ctx_r3.cancelButton && !ctx_r3.isAdaptive)("setButton", !ctx_r3.isAdaptive)("nowButton", ctx_r3.nowButton)("format", ctx_r3.format)("min", ctx_r3.min)("max", ctx_r3.max)("steps", ctx_r3.steps)("value", ctx_r3.value)("isAdaptiveEnabled", ctx_r3.isAdaptiveModeEnabled)("kendoEventsOutsideAngular", ɵɵpureFunction2(24, _c28, ctx_r3.handleKeydown, ctx_r3.handleMousedown))("scope", ctx_r3);
    ɵɵadvance(2);
    ɵɵproperty("acceptLabel", ctx_r3.localization.get("acceptLabel"))("accept", ctx_r3.localization.get("accept"))("cancelLabel", ctx_r3.localization.get("cancelLabel"))("cancel", ctx_r3.localization.get("cancel"))("nowLabel", ctx_r3.localization.get("nowLabel"))("now", ctx_r3.localization.get("now"))("hour", ctx_r3.localization.get("hour"))("minute", ctx_r3.localization.get("minute"))("second", ctx_r3.localization.get("second"))("millisecond", ctx_r3.localization.get("millisecond"))("dayperiod", ctx_r3.localization.get("dayperiod"));
  }
}
var _c29 = (a0, a1) => ({
  mousedown: a0,
  click: a1
});
var _c30 = (a0, a1) => ({
  "k-datetime-wrap-md": a0,
  "k-datetime-wrap-lg": a1
});
var _c31 = (a0, a1) => ({
  mousedown: a0,
  keydown: a1
});
var _c32 = (a0, a1) => ({
  focusin: a0,
  focusout: a1
});
var _c33 = (a0, a1) => ({
  click: a0,
  "keydown.shift.tab": a1
});
var _c34 = (a0, a1) => ({
  click: a0,
  "keydown.tab": a1
});
var _c35 = (a0) => ({
  transitionend: a0
});
var _c36 = (a0) => ({
  "k-timeselector-lg": a0
});
var _c37 = (a0, a1, a2) => ({
  click: a0,
  "keydown.tab": a1,
  "keydown.shift.tab": a2
});
function DateTimePickerComponent_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 11);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("svgIcon", ctx_r1.calendarIcon);
  }
}
function DateTimePickerComponent_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 12);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("svgIcon", ctx_r1.clockIcon);
  }
}
function DateTimePickerComponent_ng_template_9_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function DateTimePickerComponent_ng_template_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, DateTimePickerComponent_ng_template_9_ng_container_0_Template, 1, 0, "ng-container", 15);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const dateTimeTemplate_r3 = ɵɵreference(16);
    ɵɵproperty("ngTemplateOutlet", dateTimeTemplate_r3);
  }
}
function DateTimePickerComponent_Conditional_11_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-resize-sensor", 16);
    ɵɵlistener("resize", function DateTimePickerComponent_Conditional_11_Template_kendo_resize_sensor_resize_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onResize());
    });
    ɵɵelementEnd();
  }
}
function DateTimePickerComponent_ng_template_14_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 20);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.adaptiveTitle);
  }
}
function DateTimePickerComponent_ng_template_14_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 21);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.adaptiveSubtitle);
  }
}
function DateTimePickerComponent_ng_template_14_ng_container_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function DateTimePickerComponent_ng_template_14_Conditional_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 28);
    ɵɵlistener("click", function DateTimePickerComponent_ng_template_14_Conditional_10_Template_button_click_0_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.handleCancel());
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵattribute("title", ctx_r1.localization.get("cancelLabel"))("aria-label", ctx_r1.localization.get("cancelLabel"));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.localization.get("cancel"), " ");
  }
}
function DateTimePickerComponent_ng_template_14_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 17)(1, "div", 18)(2, "div", 19);
    ɵɵconditionalCreate(3, DateTimePickerComponent_ng_template_14_Conditional_3_Template, 2, 1, "div", 20);
    ɵɵconditionalCreate(4, DateTimePickerComponent_ng_template_14_Conditional_4_Template, 2, 1, "div", 21);
    ɵɵelementEnd();
    ɵɵelementStart(5, "div", 22)(6, "button", 23);
    ɵɵlistener("click", function DateTimePickerComponent_ng_template_14_Template_button_click_6_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.toggleActionSheet(false));
    });
    ɵɵelementEnd()()()();
    ɵɵelementStart(7, "div", 24);
    ɵɵtemplate(8, DateTimePickerComponent_ng_template_14_ng_container_8_Template, 1, 0, "ng-container", 15);
    ɵɵelementEnd();
    ɵɵelementStart(9, "div", 25);
    ɵɵconditionalCreate(10, DateTimePickerComponent_ng_template_14_Conditional_10_Template, 2, 3, "button", 26);
    ɵɵelementStart(11, "button", 27);
    ɵɵlistener("click", function DateTimePickerComponent_ng_template_14_Template_button_click_11_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleAccept());
    });
    ɵɵtext(12);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const dateTimeTemplate_r3 = ɵɵreference(16);
    ɵɵadvance(3);
    ɵɵconditional(ctx_r1.adaptiveTitle ? 3 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.adaptiveSubtitle ? 4 : -1);
    ɵɵadvance(2);
    ɵɵproperty("svgIcon", ctx_r1.checkIcon)("tabIndex", -1);
    ɵɵattribute("title", ctx_r1.localization.get("adaptiveCloseButtonTitle"));
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", dateTimeTemplate_r3);
    ɵɵadvance(2);
    ɵɵconditional(ctx_r1.cancelButton ? 10 : -1);
    ɵɵadvance();
    ɵɵproperty("disabled", !ctx_r1.calendarValue);
    ɵɵattribute("title", ctx_r1.localization.get("acceptLabel"))("aria-label", ctx_r1.localization.get("acceptLabel"));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.localization.get("accept"), " ");
  }
}
function DateTimePickerComponent_ng_template_15_Conditional_16_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "button", 43);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction3(5, _c37, ctx_r1.handleCancel, ctx_r1.handleTab, ctx_r1.handleTab))("scope", ctx_r1);
    ɵɵattribute("title", ctx_r1.localization.get("cancelLabel"))("aria-label", ctx_r1.localization.get("cancelLabel"));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.localization.get("cancel"), " ");
  }
}
function DateTimePickerComponent_ng_template_15_Conditional_16_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 41)(1, "button", 42);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵconditionalCreate(3, DateTimePickerComponent_ng_template_15_Conditional_16_Conditional_3_Template, 2, 9, "button", 43);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction2(9, _c32, ctx_r1.handleFocus, ctx_r1.handleBlur))("scope", ctx_r1);
    ɵɵadvance();
    ɵɵproperty("disabled", !ctx_r1.calendarValue)("kendoEventsOutsideAngular", ɵɵpureFunction3(12, _c37, ctx_r1.handleAccept, ctx_r1.handleTab, ctx_r1.handleTab))("scope", ctx_r1);
    ɵɵattribute("title", ctx_r1.localization.get("acceptLabel"))("aria-label", ctx_r1.localization.get("acceptLabel"));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.localization.get("accept"), " ");
    ɵɵadvance();
    ɵɵconditional(ctx_r1.cancelButton ? 3 : -1);
  }
}
function DateTimePickerComponent_ng_template_15_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 29)(1, "div", 30)(2, "div", 31)(3, "button", 32);
    ɵɵtext(4);
    ɵɵelementEnd();
    ɵɵelementStart(5, "button", 33);
    ɵɵtext(6);
    ɵɵelementEnd()()();
    ɵɵelementStart(7, "div", 34, 5)(9, "div", 35)(10, "kendo-calendar", 36, 6);
    ɵɵtwoWayListener("valueChange", function DateTimePickerComponent_ng_template_15_Template_kendo_calendar_valueChange_10_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext();
      ɵɵtwoWayBindingSet(ctx_r1.calendarValue, $event) || (ctx_r1.calendarValue = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("valueChange", function DateTimePickerComponent_ng_template_15_Template_kendo_calendar_valueChange_10_listener() {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleCalendarValueChange());
    });
    ɵɵelement(12, "kendo-calendar-messages", 37);
    ɵɵelementEnd()();
    ɵɵelementStart(13, "div", 38)(14, "kendo-timeselector", 39);
    ɵɵlistener("tabOutLastPart", function DateTimePickerComponent_ng_template_15_Template_kendo_timeselector_tabOutLastPart_14_listener() {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onTabOutLastPart());
    })("tabOutFirstPart", function DateTimePickerComponent_ng_template_15_Template_kendo_timeselector_tabOutFirstPart_14_listener() {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onTabOutFirstPart());
    })("tabOutNow", function DateTimePickerComponent_ng_template_15_Template_kendo_timeselector_tabOutNow_14_listener() {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onTabOutNow());
    });
    ɵɵelement(15, "kendo-timeselector-messages", 40);
    ɵɵelementEnd()()();
    ɵɵconditionalCreate(16, DateTimePickerComponent_ng_template_15_Conditional_16_Template, 4, 16, "div", 41);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const dateTimeSelector_r8 = ɵɵreference(8);
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMap(ɵɵinterpolate1("k-datetime-wrap k-", ctx_r1.activeTab, "-tab"));
    ɵɵproperty("ngClass", ɵɵpureFunction2(79, _c30, !ctx_r1.isAdaptive, ctx_r1.isAdaptive))("kendoEventsOutsideAngular", ɵɵpureFunction2(82, _c31, ctx_r1.preventMouseDown, ctx_r1.handleKeyDown))("scope", ctx_r1);
    ɵɵadvance();
    ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction2(85, _c32, ctx_r1.handleFocus, ctx_r1.handleBlur))("scope", ctx_r1);
    ɵɵadvance(2);
    ɵɵclassProp("k-selected", ctx_r1.activeTab === "date");
    ɵɵproperty("size", ctx_r1.isAdaptive ? "large" : ctx_r1.size)("kendoEventsOutsideAngular", ɵɵpureFunction2(88, _c33, ctx_r1.changeActiveTab.bind(ctx_r1, "date"), ctx_r1.handleTab))("scope", ctx_r1);
    ɵɵattribute("aria-pressed", ctx_r1.activeTab === "date" ? "true" : "false")("title", ctx_r1.localization.get("dateTabLabel"))("aria-label", ctx_r1.localization.get("dateTabLabel"));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.localization.get("dateTab"), " ");
    ɵɵadvance();
    ɵɵclassProp("k-selected", ctx_r1.activeTab === "time");
    ɵɵproperty("size", ctx_r1.isAdaptive ? "large" : ctx_r1.size)("kendoEventsOutsideAngular", ɵɵpureFunction2(91, _c34, ctx_r1.changeActiveTab.bind(ctx_r1, "time"), ctx_r1.handleTab))("scope", ctx_r1);
    ɵɵattribute("aria-pressed", ctx_r1.activeTab === "time" ? "true" : "false")("title", ctx_r1.localization.get("timeTabLabel"))("aria-label", ctx_r1.localization.get("timeTabLabel"));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.localization.get("timeTab"), " ");
    ɵɵadvance();
    ɵɵstyleProp("transition", ctx_r1.tabSwitchTransition);
    ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction1(94, _c35, ctx_r1.handleTabChangeTransitionEnd.bind(ctx_r1, dateTimeSelector_r8)));
    ɵɵadvance(3);
    ɵɵproperty("focusedDate", ctx_r1.focusedDate)("size", ctx_r1.isAdaptive ? "large" : ctx_r1.size);
    ɵɵtwoWayProperty("value", ctx_r1.calendarValue);
    ɵɵproperty("type", ctx_r1.calendarType)("min", ctx_r1.calendarMin)("max", ctx_r1.calendarMax)("weekDaysFormat", ctx_r1.weekDaysFormat)("weekNumber", ctx_r1.weekNumber)("navigation", false)("animateNavigation", ctx_r1.animateCalendarNavigation)("showOtherMonthDays", ctx_r1.showOtherMonthDays)("cellTemplate", ctx_r1.cellTemplate)("monthCellTemplate", ctx_r1.monthCellTemplate)("yearCellTemplate", ctx_r1.yearCellTemplate)("decadeCellTemplate", ctx_r1.decadeCellTemplate)("centuryCellTemplate", ctx_r1.centuryCellTemplate)("weekNumberTemplate", ctx_r1.weekNumberTemplate)("headerTitleTemplate", ctx_r1.headerTitleTemplate)("headerTemplate", ctx_r1.headerTemplate)("footerTemplate", ctx_r1.footerTemplate)("footer", ctx_r1.footer)("disabled", ctx_r1.disableCalendar)("disabledDates", ctx_r1.disabledDates);
    ɵɵadvance(2);
    ɵɵproperty("today", ctx_r1.localization.get("today"))("prevButtonTitle", ctx_r1.localization.get("prevButtonTitle"))("nextButtonTitle", ctx_r1.localization.get("nextButtonTitle"))("parentViewButtonTitle", ctx_r1.localization.get("parentViewButtonTitle"));
    ɵɵadvance(2);
    ɵɵproperty("ngClass", ɵɵpureFunction1(96, _c36, ctx_r1.isAdaptive))("value", ctx_r1.value)("format", ctx_r1.timeSelectorFormat)("min", ctx_r1.timeSelectorMin)("max", ctx_r1.timeSelectorMax)("setButton", false)("cancelButton", false)("steps", ctx_r1.steps)("disabled", ctx_r1.disableTimeSelector)("isAdaptiveEnabled", ctx_r1.isAdaptiveModeEnabled)("isDateTimePicker", true);
    ɵɵadvance();
    ɵɵproperty("acceptLabel", ctx_r1.localization.get("acceptLabel"))("accept", ctx_r1.localization.get("accept"))("cancelLabel", ctx_r1.localization.get("cancelLabel"))("cancel", ctx_r1.localization.get("cancel"))("nowLabel", ctx_r1.localization.get("nowLabel"))("now", ctx_r1.localization.get("now"))("hour", ctx_r1.localization.get("hour"))("minute", ctx_r1.localization.get("minute"))("second", ctx_r1.localization.get("second"))("millisecond", ctx_r1.localization.get("millisecond"))("dayperiod", ctx_r1.localization.get("dayperiod"));
    ɵɵadvance();
    ɵɵconditional(!ctx_r1.isAdaptive ? 16 : -1);
  }
}
var _c38 = ["defaultTemplate"];
function DateRangePopupComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-multiviewcalendar", 6);
    ɵɵlistener("onClosePopup", function DateRangePopupComponent_ng_template_3_Template_kendo_multiviewcalendar_onClosePopup_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.closePopup($event));
    })("onTabPress", function DateRangePopupComponent_ng_template_3_Template_kendo_multiviewcalendar_onTabPress_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleTab($event));
    })("onShiftTabPress", function DateRangePopupComponent_ng_template_3_Template_kendo_multiviewcalendar_onShiftTabPress_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleShiftTab($event));
    })("rangeSelectionChange", function DateRangePopupComponent_ng_template_3_Template_kendo_multiviewcalendar_rangeSelectionChange_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onRangeSelectionChange($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("activeView", ctx_r2.activeView)("bottomView", ctx_r2.bottomView)("animateNavigation", ctx_r2.animateNavigation)("disabled", ctx_r2.disabled)("views", ctx_r2.views)("weekNumber", ctx_r2.weekNumber)("topView", ctx_r2.topView)("disabledDates", ctx_r2.disabledDates)("min", ctx_r2.min)("max", ctx_r2.max)("showCalendarHeader", ctx_r2.showCalendarHeader)("focusedDate", ctx_r2.focusedDate)("allowReverse", ctx_r2.allowReverse)("showViewHeader", ctx_r2.showViewHeader)("showOtherMonthDays", ctx_r2.showOtherMonthDays)("size", ctx_r2.size)("value", ctx_r2.dateRangeService.selectionRange);
  }
}
function DateRangePopupComponent_ng_template_7_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-resize-sensor", 20);
    ɵɵlistener("resize", function DateRangePopupComponent_ng_template_7_Conditional_0_Template_kendo_resize_sensor_resize_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.onResize());
    });
    ɵɵelementEnd();
  }
}
function DateRangePopupComponent_ng_template_7_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 10);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r2.adaptiveTitle);
  }
}
function DateRangePopupComponent_ng_template_7_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 11);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r2.adaptiveSubtitle);
  }
}
function DateRangePopupComponent_ng_template_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵconditionalCreate(0, DateRangePopupComponent_ng_template_7_Conditional_0_Template, 1, 0, "kendo-resize-sensor");
    ɵɵelementStart(1, "div", 7)(2, "div", 8)(3, "div", 9);
    ɵɵconditionalCreate(4, DateRangePopupComponent_ng_template_7_Conditional_4_Template, 2, 1, "div", 10);
    ɵɵconditionalCreate(5, DateRangePopupComponent_ng_template_7_Conditional_5_Template, 2, 1, "div", 11);
    ɵɵelementEnd();
    ɵɵelementStart(6, "div", 12)(7, "button", 13);
    ɵɵlistener("click", function DateRangePopupComponent_ng_template_7_Template_button_click_7_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleAccept());
    });
    ɵɵelementEnd()()()();
    ɵɵelementStart(8, "div", 14)(9, "div", 15)(10, "kendo-multiviewcalendar", 16);
    ɵɵlistener("rangeSelectionChange", function DateRangePopupComponent_ng_template_7_Template_kendo_multiviewcalendar_rangeSelectionChange_10_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onRangeSelectionChange($event));
    });
    ɵɵelementEnd()()();
    ɵɵelementStart(11, "div", 17)(12, "button", 18);
    ɵɵlistener("click", function DateRangePopupComponent_ng_template_7_Template_button_click_12_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.show = false);
    });
    ɵɵtext(13);
    ɵɵelementEnd();
    ɵɵelementStart(14, "button", 19);
    ɵɵlistener("click", function DateRangePopupComponent_ng_template_7_Template_button_click_14_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleAccept());
    });
    ɵɵtext(15);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵconditional(ctx_r2.isAdaptiveModeEnabled ? 0 : -1);
    ɵɵadvance(4);
    ɵɵconditional(ctx_r2.adaptiveTitle ? 4 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r2.adaptiveSubtitle ? 5 : -1);
    ɵɵadvance(2);
    ɵɵproperty("svgIcon", ctx_r2.checkIcon)("tabIndex", -1);
    ɵɵattribute("title", ctx_r2.localization.get("adaptiveCloseButtonTitle"));
    ɵɵadvance(3);
    ɵɵproperty("animateNavigation", ctx_r2.animateNavigation)("disabled", ctx_r2.disabled)("views", ctx_r2.views)("weekNumber", ctx_r2.weekNumber)("disabledDates", ctx_r2.disabledDates)("activeView", ctx_r2.activeView)("bottomView", ctx_r2.bottomView)("topView", ctx_r2.topView)("min", ctx_r2.min)("max", ctx_r2.max)("showCalendarHeader", ctx_r2.showCalendarHeader)("focusedDate", ctx_r2.focusedDate)("allowReverse", ctx_r2.allowReverse)("showViewHeader", ctx_r2.showViewHeader)("showOtherMonthDays", ctx_r2.showOtherMonthDays)("focusedDate", ctx_r2.dateRangeService.focusedDate)("value", ctx_r2.dateRangeService.selectionRange);
    ɵɵadvance(2);
    ɵɵattribute("title", ctx_r2.localization.get("cancelLabel"))("aria-label", ctx_r2.localization.get("cancelLabel"));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r2.localization.get("cancel"), " ");
    ɵɵadvance();
    ɵɵattribute("title", ctx_r2.localization.get("acceptLabel"))("aria-label", ctx_r2.localization.get("acceptLabel"));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r2.localization.get("accept"), " ");
  }
}
function DateRangeComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-daterange-popup", 0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("size", ctx_r0.size);
  }
}
var packageMetadata = {
  name: "@progress/kendo-angular-dateinputs",
  productName: "Kendo UI for Angular",
  productCode: "KENDOUIANGULAR",
  productCodes: ["KENDOUIANGULAR"],
  publishDate: 0,
  version: "22.0.1",
  licensingDocsUrl: "https://www.telerik.com/kendo-angular-ui/my-license/"
};
var Action;
(function(Action2) {
  Action2[Action2["Left"] = 0] = "Left";
  Action2[Action2["Right"] = 1] = "Right";
  Action2[Action2["Up"] = 2] = "Up";
  Action2[Action2["Down"] = 3] = "Down";
  Action2[Action2["PrevView"] = 4] = "PrevView";
  Action2[Action2["NextView"] = 5] = "NextView";
  Action2[Action2["FirstInView"] = 6] = "FirstInView";
  Action2[Action2["LastInView"] = 7] = "LastInView";
  Action2[Action2["LowerView"] = 8] = "LowerView";
  Action2[Action2["UpperView"] = 9] = "UpperView";
})(Action || (Action = {}));
var EMPTY_SELECTIONRANGE = {
  start: null,
  end: null
};
var MIDNIGHT_DATE = new Date(1980, 0, 1);
var MIN_DATE = new Date(1900, 0, 1);
var MAX_DATE = new Date(2099, 11, 31);
var MIN_TIME = new Date(1980, 0, 1);
var MAX_TIME = new Date(1980, 0, 1, 23, 59, 59);
var requiresZoneOnBlur = (ngControl) => ngControl && (!ngControl.touched || ngControl.control && ngControl.control.updateOn === "blur");
var preventDefault = (args) => args.preventDefault();
var currentFocusTarget = (blurArgs) => blurArgs.relatedTarget || document.activeElement;
var isPresent4 = (value2) => value2 !== void 0 && value2 !== null;
var isNullOrDate = (value2) => value2 === null || value2 instanceof Date;
var isNumberArray = (value2) => Array.isArray(value2) && value2.length > 0 && value2.every((item) => typeof item === "number");
var isDateArray = (value2) => Array.isArray(value2) && value2.length > 0 && value2.every((item) => item instanceof Date);
var isArrowWithShiftPressed = (args) => {
  const code = normalizeKeys(args);
  return args.shiftKey && (code === Keys.ArrowRight || code === Keys.ArrowLeft || code === Keys.ArrowDown || code === Keys.ArrowUp);
};
var selectors = {
  infiniteCalendarTable: ".k-content .k-calendar-table",
  multiViewCalendarTable: ".k-calendar-table"
};
var attributeNames = {
  ariaActiveDescendant: "aria-activedescendant",
  ariaControls: "aria-controls",
  ariaExpanded: "aria-expanded",
  ariaHasPopup: "aria-haspopup",
  valueNow: "aria-valuenow",
  valuetext: "aria-valuetext",
  ariaInvalid: "aria-invalid"
};
var isSet = (value2) => value2 !== null && value2 !== void 0;
var setter = (method) => (date, value2) => {
  const clone = cloneDate(date);
  clone[method](value2);
  return clone;
};
var setTime = (origin, candidate) => {
  const date = cloneDate(origin);
  date.setHours(candidate.getHours(), candidate.getMinutes(), candidate.getSeconds(), candidate.getMilliseconds());
  return date;
};
var getTimeInMilliseconds = (candidate) => {
  const hoursInMilliseconds = candidate.getHours() * MS_PER_HOUR;
  const minutesInMilliseconds = candidate.getMinutes() * MS_PER_MINUTE;
  const secondsInMilliseconds = candidate.getSeconds() * 1e3;
  return hoursInMilliseconds + minutesInMilliseconds + secondsInMilliseconds + candidate.getMilliseconds();
};
var normalizeTimes = (candidate, min, max) => {
  return {
    candidateValue: setTime(MIDNIGHT_DATE, candidate),
    maxValue: addDays(setTime(MIDNIGHT_DATE, max), getTimeInMilliseconds(min) < getTimeInMilliseconds(max) ? 0 : 1),
    minValue: setTime(MIDNIGHT_DATE, min)
  };
};
var setYears2 = setter("setFullYear");
var setHours$1 = setter("setHours");
var setMinutes = setter("setMinutes");
var setSeconds = setter("setSeconds");
var setMilliseconds = setter("setMilliseconds");
var range = (start, end, step = 1) => {
  const result = [];
  for (let i = start; i < end; i = i + step) {
    result.push(i);
  }
  return result;
};
var isInRange = (candidate, min, max) => !candidate || !(min && min > candidate || max && max < candidate);
var isInTimeRange = (candidate, min, max) => {
  if (!candidate || !min || !max) {
    return true;
  }
  const {
    candidateValue,
    minValue,
    maxValue
  } = normalizeTimes(candidate, min, max);
  return minValue <= candidateValue && candidateValue <= maxValue;
};
var isValidRange = (min, max) => !isSet(min) || !isSet(max) || min <= max;
var dateInRange = (candidate, min, max) => {
  if (!candidate) {
    return candidate;
  }
  if (min && candidate < min) {
    return cloneDate(min);
  }
  if (max && candidate > max) {
    return cloneDate(max);
  }
  return candidate;
};
var timeInRange = (candidate, min, max) => {
  if (!candidate || !min || !max) {
    return candidate;
  }
  const {
    candidateValue,
    minValue,
    maxValue
  } = normalizeTimes(candidate, min, max);
  if (candidateValue < minValue) {
    return setTime(candidate, min);
  }
  if (candidateValue > maxValue) {
    return setTime(candidate, max);
  }
  return candidate;
};
var getNow = () => /* @__PURE__ */ new Date();
var getToday = () => getDate(/* @__PURE__ */ new Date());
var noop$2 = (_) => {
};
var isWindowAvailable = () => {
  return typeof window !== "undefined";
};
var stringifyClassObject = (classes) => {
  const pushToAcc = (acc, cls) => classes[cls] ? acc.concat(cls) : acc;
  return Object.keys(classes).reduce(pushToAcc, []).join(" ");
};
var shiftWeekNames = (names, offset3) => names.slice(offset3).concat(names.slice(0, offset3));
var domContainerFactory = (type) => (children2, classes = "", styles = {}) => {
  const container = document.createElement(type);
  container.className = classes;
  Object.keys(styles).forEach((key) => container.style[key] = styles[key]);
  if (typeof children2 === "string") {
    container.innerHTML = children2 || "";
  } else {
    (children2 || []).forEach((child) => child && container.appendChild(child));
  }
  return container;
};
var hasChange = (changes, field) => changes[field] !== void 0;
var hasExistingValue = (changes, field) => changes[field] && changes[field].currentValue !== void 0 && changes[field].currentValue !== null;
var last = (list2 = []) => list2 && list2[list2.length - 1];
var isInSelectionRange = (value2, selectionRange) => {
  const {
    start,
    end
  } = selectionRange || EMPTY_SELECTIONRANGE;
  if (!start || !end) {
    return false;
  }
  return start < value2 && value2 < end;
};
var either = (value1, value2) => value1 || value2;
var clampRange = (value2) => ({
  start: value2,
  end: value2
});
var isEqualRange = (initial2, updated) => {
  const {
    start: initialStart,
    end: initialEnd
  } = initial2 || EMPTY_SELECTIONRANGE;
  const {
    start: updatedStart,
    end: updatedEnd
  } = updated || EMPTY_SELECTIONRANGE;
  return isEqual(initialStart, updatedStart) && isEqual(initialEnd, updatedEnd);
};
var areDatesEqual = (first, second) => {
  first = first || [];
  second = second || [];
  return first.length === second.length && first.every((date, index) => isEqual(date, second[index]));
};
var sortDates = (dates) => {
  return dates.filter((date) => isPresent4(date)).sort((a, b) => a.getTime() - b.getTime());
};
var mergeDateAndTime = (date, time) => {
  if (!(date && time)) {
    return null;
  }
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
};
var lastMillisecondOfDate = (date) => {
  if (!date) {
    return null;
  }
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 23, 59, 59, 999);
};
var disabledDatesInRange = (start, end, isDateDisabled) => {
  if (!(start && end && isDateDisabled) || start > end) {
    return [];
  }
  const dates = [];
  let current = start;
  while (current <= end) {
    if (isDateDisabled(current)) {
      dates.push(current);
    }
    current = addDays(current, 1);
  }
  return dates;
};
var isTabExitingCalendar = (calendarType, focusedElement, shiftKey) => {
  if (!isPresent4(focusedElement)) {
    return false;
  }
  return calendarType === "infinite" || // infinte calendar is always exited on first tab keydown
  calendarType === "classic" && shiftKey && focusedElement.classList.contains("k-calendar-table") || // exited on main calendar element focused and back-tab
  !shiftKey && focusedElement.classList.contains("k-calendar-table");
};
var getSizeClass = (component, size) => {
  const SIZE_CLASSES = {
    "small": `k-${component}-sm`,
    "medium": `k-${component}-md`,
    "large": `k-${component}-lg`
  };
  return SIZE_CLASSES[size];
};
var getRoundedClass = (rounded) => {
  const ROUNDED_CLASSES = {
    "small": "k-rounded-sm",
    "medium": "k-rounded-md",
    "large": "k-rounded-lg",
    "full": "k-rounded-full"
  };
  return ROUNDED_CLASSES[rounded];
};
var getFillModeClass = (component, fillMode) => {
  const FILLMODE_CLASSES = {
    "solid": `k-${component}-solid`,
    "flat": `k-${component}-flat`,
    "outline": `k-${component}-outline`
  };
  return FILLMODE_CLASSES[fillMode];
};
var DEFAULT_ROUNDED = "medium";
var DEFAULT_SIZE = "medium";
var DEFAULT_FILL_MODE = "solid";
var EMPTY_DATA$3 = [[]];
var CELLS_LENGTH$3 = 4;
var ROWS_LENGTH$3 = 3;
var upStep$1 = (year) => {
  const decadeOfCentury = Number(year.toString().slice(-2, -1));
  if (decadeOfCentury < 2) {
    return -2;
  }
  if (decadeOfCentury < 4) {
    return -6;
  }
  return -4;
};
var downStep$1 = (year) => {
  const decadeOfCentury = Number(year.toString().slice(-2, -1));
  if (decadeOfCentury > 7) {
    return 2;
  }
  if (decadeOfCentury > 5) {
    return 6;
  }
  return 4;
};
var ACTIONS$3 = {
  [Action.Left]: (date) => addDecades(date, -1),
  [Action.Up]: (date) => addDecades(date, upStep$1(date.getFullYear())),
  [Action.Right]: (date) => addDecades(date, 1),
  [Action.Down]: (date) => addDecades(date, downStep$1(date.getFullYear())),
  [Action.PrevView]: (date) => addCenturies(date, -1),
  [Action.NextView]: (date) => addCenturies(date, 1),
  [Action.FirstInView]: (date) => firstDecadeOfCentury(date),
  [Action.LastInView]: (date) => lastDecadeOfCentury(date)
};
var CenturyViewService = class _CenturyViewService {
  addToDate(min, skip4) {
    return addCenturies(min, skip4);
  }
  datesList(start, count2) {
    return range(0, count2).map((i) => addCenturies(start, i));
  }
  data(options) {
    const {
      cellUID,
      focusedDate,
      isActiveView,
      max,
      min,
      selectedDates,
      selectionRange = EMPTY_SELECTIONRANGE,
      viewDate,
      allowReverse
    } = options;
    if (!viewDate) {
      return EMPTY_DATA$3;
    }
    const cells = range(0, CELLS_LENGTH$3);
    const firstDate = firstDecadeOfCentury(viewDate);
    const lastDate = lastDecadeOfCentury(viewDate);
    const lastYearOfCentury = lastYearOfDecade(lastDate).getFullYear() + 1;
    const today = getToday();
    return range(0, ROWS_LENGTH$3).map((rowOffset) => {
      const baseDate = addDecades(firstDate, rowOffset * CELLS_LENGTH$3);
      return cells.map((cellOffset) => {
        const cellDate = this.normalize(addDecades(baseDate, cellOffset), min, max);
        const nextCentury = cellDate.getFullYear() >= lastYearOfCentury;
        if (!this.isInRange(cellDate, min, max) || nextCentury) {
          return null;
        }
        let isRangeStart = false;
        let isRangeEnd = false;
        if (allowReverse) {
          if (this.isEqual(cellDate, selectionRange.start) && selectionRange.start <= selectionRange.end || this.isEqual(cellDate, selectionRange.end) && selectionRange.end <= selectionRange.start) {
            isRangeStart = true;
          }
          if (this.isEqual(cellDate, selectionRange.start) && selectionRange.start >= selectionRange.end || this.isEqual(cellDate, selectionRange.end) && selectionRange.end >= selectionRange.start) {
            isRangeEnd = true;
          }
        } else {
          isRangeStart = this.isEqual(cellDate, selectionRange.start);
          isRangeEnd = this.isEqual(cellDate, selectionRange.end);
        }
        const isInMiddle = !isRangeStart && !isRangeEnd;
        let isRangeMid;
        if (allowReverse) {
          isRangeMid = isInMiddle && (isInSelectionRange(cellDate, selectionRange) || isInSelectionRange(cellDate, {
            start: selectionRange.end,
            end: selectionRange.start
          }));
        } else {
          isRangeMid = isInMiddle && isInSelectionRange(cellDate, selectionRange);
        }
        return {
          formattedValue: this.value(cellDate),
          id: `${cellUID}${cellDate.getTime()}`,
          isFocused: this.isEqual(cellDate, focusedDate),
          isSelected: isActiveView && selectedDates.some((date) => this.isEqual(cellDate, date)),
          isWeekend: false,
          isRangeStart,
          isRangeMid,
          isRangeEnd,
          isRangeSplitEnd: isRangeMid && this.isEqual(cellDate, lastDate),
          isRangeSplitStart: isRangeMid && this.isEqual(cellDate, firstDate),
          isToday: this.isEqual(cellDate, today),
          title: this.cellTitle(cellDate),
          value: cellDate,
          allowReverse
        };
      });
    });
  }
  isEqual(candidate, expected) {
    if (!candidate || !expected) {
      return false;
    }
    return firstYearOfDecade(candidate).getFullYear() === firstYearOfDecade(expected).getFullYear();
  }
  isInArray(date, dates) {
    if (!dates.length) {
      return false;
    }
    const year = date.getFullYear();
    return dates[0].getFullYear() <= year && year <= dates[dates.length - 1].getFullYear() + 99;
  }
  isInRange(candidate, min, max) {
    const year = firstYearOfDecade(candidate).getFullYear();
    const aboveMin = !min || firstYearOfDecade(min).getFullYear() <= year;
    const belowMax = !max || year <= firstYearOfDecade(max).getFullYear();
    return aboveMin && belowMax;
  }
  beginningOfPeriod(date) {
    if (!date) {
      return date;
    }
    const firstYear = firstYearOfDecade(firstDecadeOfCentury(date));
    return createDate(firstYear.getFullYear(), 0, 1);
  }
  lastDayOfPeriod(date) {
    const decade = lastDecadeOfCentury(date);
    const year = lastYearOfDecade(decade);
    const month = lastMonthOfYear(year);
    return lastDayOfMonth(month);
  }
  isRangeStart(value2) {
    return value2.getFullYear() % 1e3 === 0;
  }
  move(value2, action) {
    const modifier = ACTIONS$3[action];
    if (!modifier) {
      return value2;
    }
    return modifier(value2);
  }
  cellTitle(value2) {
    return firstYearOfDecade(value2).getFullYear().toString();
  }
  navigationTitle(value2) {
    return value2 ? firstDecadeOfCentury(value2).getFullYear().toString() : "";
  }
  title(value2) {
    if (!value2) {
      return "";
    }
    return `${firstDecadeOfCentury(value2).getFullYear()} - ${lastDecadeOfCentury(value2).getFullYear()}`;
  }
  rowLength() {
    return CELLS_LENGTH$3;
  }
  skip(value2, min) {
    return durationInCenturies(min, value2);
  }
  total(min, max) {
    return durationInCenturies(min, max) + 1;
  }
  value(current) {
    return current ? firstYearOfDecade(current).getFullYear().toString() : "";
  }
  viewDate(date, max, viewsCount = 1) {
    const viewsInRange = this.total(date, max);
    if (viewsInRange < viewsCount) {
      const centuriesToSubtract = viewsCount - viewsInRange;
      return addCenturies(date, -1 * centuriesToSubtract);
    }
    return date;
  }
  dateRange = (start, end) => {
    if (!isPresent4(start) || !isPresent4(end)) {
      return [];
    }
    const result = [];
    let current = start;
    while (current <= end) {
      result.push(current);
      current = addDecades(current, 1);
    }
    return result;
  };
  normalize(cellDate, min, max) {
    if (cellDate < min && this.isEqual(cellDate, min)) {
      return cloneDate(min);
    }
    if (cellDate > max && this.isEqual(cellDate, max)) {
      return cloneDate(max);
    }
    return cellDate;
  }
  static ɵfac = function CenturyViewService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CenturyViewService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _CenturyViewService,
    factory: _CenturyViewService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CenturyViewService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var EMPTY_DATA$2 = [[]];
var CELLS_LENGTH$2 = 4;
var ROWS_LENGTH$2 = 3;
var upStep = (year) => {
  const yearOfDecade = Number(year.toString().slice(-1));
  if (yearOfDecade < 2) {
    return -2;
  }
  if (yearOfDecade < 4) {
    return -6;
  }
  return -4;
};
var downStep = (year) => {
  const yearOfDecade = Number(year.toString().slice(-1));
  if (yearOfDecade > 7) {
    return 2;
  }
  if (yearOfDecade > 5) {
    return 6;
  }
  return 4;
};
var ACTIONS$2 = {
  [Action.Left]: (date) => addYears(date, -1),
  [Action.Up]: (date) => addYears(date, upStep(date.getFullYear())),
  [Action.Right]: (date) => addYears(date, 1),
  [Action.Down]: (date) => addYears(date, downStep(date.getFullYear())),
  [Action.PrevView]: (date) => addDecades(date, -1),
  [Action.NextView]: (date) => addDecades(date, 1),
  [Action.FirstInView]: (date) => firstYearOfDecade(date),
  [Action.LastInView]: (date) => lastYearOfDecade(date)
};
var DecadeViewService = class _DecadeViewService {
  addToDate(min, skip4) {
    return addDecades(min, skip4);
  }
  datesList(start, count2) {
    return range(0, count2).map((i) => addDecades(start, i));
  }
  data(options) {
    const {
      cellUID,
      focusedDate,
      isActiveView,
      max,
      min,
      selectedDates,
      selectionRange = EMPTY_SELECTIONRANGE,
      viewDate,
      allowReverse
    } = options;
    if (!viewDate) {
      return EMPTY_DATA$2;
    }
    const cells = range(0, CELLS_LENGTH$2);
    const firstDate = firstYearOfDecade(viewDate);
    const lastDate = lastYearOfDecade(viewDate);
    const today = getToday();
    return range(0, ROWS_LENGTH$2).map((rowOffset) => {
      const baseDate = addYears(firstDate, rowOffset * CELLS_LENGTH$2);
      return cells.map((cellOffset) => {
        const cellDate = this.normalize(addYears(baseDate, cellOffset), min, max);
        const nextDecade = cellDate.getFullYear() > lastDate.getFullYear();
        if (!this.isInRange(cellDate, min, max) || nextDecade) {
          return null;
        }
        let isRangeStart = false;
        let isRangeEnd = false;
        if (allowReverse) {
          if (this.isEqual(cellDate, selectionRange.start) && selectionRange.start <= selectionRange.end || this.isEqual(cellDate, selectionRange.end) && selectionRange.end <= selectionRange.start) {
            isRangeStart = true;
          }
          if (this.isEqual(cellDate, selectionRange.start) && selectionRange.start >= selectionRange.end || this.isEqual(cellDate, selectionRange.end) && selectionRange.end >= selectionRange.start) {
            isRangeEnd = true;
          }
        } else {
          isRangeStart = this.isEqual(cellDate, selectionRange.start);
          isRangeEnd = this.isEqual(cellDate, selectionRange.end);
        }
        const isInMiddle = !isRangeStart && !isRangeEnd;
        let isRangeMid;
        if (allowReverse) {
          isRangeMid = isInMiddle && (isInSelectionRange(cellDate, selectionRange) || isInSelectionRange(cellDate, {
            start: selectionRange.end,
            end: selectionRange.start
          }));
        } else {
          isRangeMid = isInMiddle && isInSelectionRange(cellDate, selectionRange);
        }
        return {
          formattedValue: this.value(cellDate),
          id: `${cellUID}${cellDate.getTime()}`,
          isFocused: this.isEqual(cellDate, focusedDate),
          isSelected: isActiveView && selectedDates.some((date) => this.isEqual(cellDate, date)),
          isWeekend: false,
          isRangeStart,
          isRangeMid,
          isRangeEnd,
          isRangeSplitEnd: isRangeMid && this.isEqual(cellDate, lastDate),
          isRangeSplitStart: isRangeMid && this.isEqual(cellDate, firstDate),
          isToday: this.isEqual(cellDate, today),
          title: this.cellTitle(cellDate),
          value: cellDate,
          allowReverse
        };
      });
    });
  }
  isEqual(candidate, expected) {
    if (!candidate || !expected) {
      return false;
    }
    return candidate.getFullYear() === expected.getFullYear();
  }
  isInArray(date, dates) {
    if (!dates.length) {
      return false;
    }
    const year = date.getFullYear();
    return dates[0].getFullYear() <= year && year <= dates[dates.length - 1].getFullYear() + 9;
  }
  isInRange(candidate, min, max) {
    const year = candidate.getFullYear();
    const aboveMin = !min || min.getFullYear() <= year;
    const belowMax = !max || year <= max.getFullYear();
    return aboveMin && belowMax;
  }
  beginningOfPeriod(date) {
    if (!date) {
      return date;
    }
    const firstYear = firstYearOfDecade(date);
    return createDate(firstYear.getFullYear(), 0, 1);
  }
  lastDayOfPeriod(date) {
    const year = lastYearOfDecade(date);
    const month = lastMonthOfYear(year);
    return lastDayOfMonth(month);
  }
  isRangeStart(value2) {
    return value2.getFullYear() % 100 === 0;
  }
  move(value2, action) {
    const modifier = ACTIONS$2[action];
    if (!modifier) {
      return value2;
    }
    return modifier(value2);
  }
  cellTitle(value2) {
    return value2.getFullYear().toString();
  }
  navigationTitle(value2) {
    return value2 ? firstYearOfDecade(value2).getFullYear().toString() : "";
  }
  title(value2) {
    if (!value2) {
      return "";
    }
    return `${firstYearOfDecade(value2).getFullYear()} - ${lastYearOfDecade(value2).getFullYear()}`;
  }
  rowLength() {
    return CELLS_LENGTH$2;
  }
  skip(value2, min) {
    return durationInDecades(min, value2);
  }
  total(min, max) {
    return durationInDecades(min, max) + 1;
  }
  value(current) {
    return current ? current.getFullYear().toString() : "";
  }
  viewDate(date, max, viewsCount = 1) {
    const viewsInRange = this.total(date, max);
    if (viewsInRange < viewsCount) {
      const decadesToSubtract = viewsCount - viewsInRange;
      return addDecades(date, -1 * decadesToSubtract);
    }
    return date;
  }
  dateRange = (start, end) => {
    if (!isPresent4(start) || !isPresent4(end)) {
      return [];
    }
    const result = [];
    let current = start;
    while (current <= end) {
      result.push(current);
      current = addYears(current, 1);
    }
    return result;
  };
  normalize(cellDate, min, max) {
    if (cellDate < min && this.isEqual(cellDate, min)) {
      return cloneDate(min);
    }
    if (cellDate > max && this.isEqual(cellDate, max)) {
      return cloneDate(max);
    }
    return cellDate;
  }
  static ɵfac = function DecadeViewService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DecadeViewService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DecadeViewService,
    factory: _DecadeViewService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DecadeViewService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var EMPTY_DATA$1 = [[]];
var CELLS_LENGTH$1 = 7;
var ROWS_LENGTH$1 = 6;
var ACTIONS$1 = {
  [Action.Left]: (date) => addDays(date, -1),
  [Action.Up]: (date) => addWeeks(date, -1),
  [Action.Right]: (date) => addDays(date, 1),
  [Action.Down]: (date) => addWeeks(date, 1),
  [Action.PrevView]: (date) => addMonths(date, -1),
  [Action.NextView]: (date) => addMonths(date, 1),
  [Action.FirstInView]: (date) => firstDayOfMonth(date),
  [Action.LastInView]: (date) => lastDayOfMonth(date)
};
var MonthViewService = class _MonthViewService {
  _intlService;
  constructor(_intlService) {
    this._intlService = _intlService;
  }
  addToDate(min, skip4) {
    return addMonths(min, skip4);
  }
  datesList(start, count2) {
    return range(0, count2).map((i) => addMonths(start, i));
  }
  data(options) {
    const {
      cellUID,
      focusedDate,
      isActiveView,
      max,
      min,
      selectedDates,
      selectionRange = EMPTY_SELECTIONRANGE,
      viewDate,
      isDateDisabled = () => false,
      allowReverse
    } = options;
    if (!viewDate) {
      return EMPTY_DATA$1;
    }
    const firstMonthDate = firstDayOfMonth(viewDate);
    const firstMonthDay = getDate(firstMonthDate);
    const lastMonthDate = lastDayOfMonth(viewDate);
    const lastMonthDay = getDate(lastMonthDate);
    const backward = -1;
    const date = dayOfWeek(firstMonthDate, this._intlService.firstDay(), backward);
    const cells = range(0, CELLS_LENGTH$1);
    const today = getToday();
    return range(0, ROWS_LENGTH$1).map((rowOffset) => {
      const baseDate = addDays(date, rowOffset * CELLS_LENGTH$1);
      return cells.map((cellOffset) => {
        const cellDate = this.normalize(addDays(baseDate, cellOffset), min, max);
        const cellDay = getDate(cellDate);
        const otherMonth = cellDay < firstMonthDay || cellDay > lastMonthDay;
        const outOfRange = cellDate < min || cellDate > max;
        if (outOfRange) {
          return null;
        }
        let isRangeStart = false;
        let isRangeEnd = false;
        if (allowReverse) {
          if (this.isEqual(cellDate, selectionRange.start) && selectionRange.start <= selectionRange.end || this.isEqual(cellDate, selectionRange.end) && selectionRange.end <= selectionRange.start) {
            isRangeStart = true;
          }
          if (this.isEqual(cellDate, selectionRange.start) && selectionRange.start >= selectionRange.end || this.isEqual(cellDate, selectionRange.end) && selectionRange.end >= selectionRange.start) {
            isRangeEnd = true;
          }
        } else {
          isRangeStart = this.isEqual(cellDate, selectionRange.start);
          isRangeEnd = this.isEqual(cellDate, selectionRange.end);
        }
        const isInMiddle = !isRangeStart && !isRangeEnd;
        let isRangeMid;
        if (allowReverse) {
          isRangeMid = isInMiddle && (isInSelectionRange(cellDate, selectionRange) || isInSelectionRange(cellDate, {
            start: selectionRange.end,
            end: selectionRange.start
          }));
        } else {
          isRangeMid = isInMiddle && isInSelectionRange(cellDate, selectionRange);
        }
        return {
          formattedValue: this.value(cellDate),
          id: `${cellUID}${otherMonth ? cellDate.getTime() + "1" : cellDate.getTime()}`,
          isFocused: this.isEqual(cellDate, focusedDate),
          isSelected: isActiveView && selectedDates.some((date2) => this.isEqual(cellDate, date2)),
          isWeekend: this.isWeekend(cellDate),
          isRangeStart,
          isRangeMid,
          isRangeEnd,
          isRangeSplitStart: isRangeMid && this.isEqual(cellDate, firstMonthDate),
          isRangeSplitEnd: isRangeMid && this.isEqual(cellDate, lastMonthDate),
          isToday: this.isEqual(cellDate, today),
          title: this.cellTitle(cellDate),
          value: cellDate,
          isDisabled: isDateDisabled(cellDate),
          isOtherMonth: otherMonth,
          allowReverse
        };
      });
    });
  }
  isEqual(candidate, expected) {
    if (!candidate || !expected) {
      return false;
    }
    return getDate(candidate).getTime() === getDate(expected).getTime();
  }
  isInArray(date, dates) {
    if (dates.length === 0) {
      return false;
    }
    const lowerBound = this.beginningOfPeriod(dates[0]);
    const upperBound = this.beginningOfPeriod(addMonths(dates[dates.length - 1], 1));
    return lowerBound <= date && date < upperBound;
  }
  isInRange(candidate, min, max) {
    const value2 = getDate(candidate);
    const aboveMin = !min || getDate(min) <= value2;
    const belowMax = !max || value2 <= getDate(max);
    return aboveMin && belowMax;
  }
  beginningOfPeriod(date) {
    if (!date) {
      return date;
    }
    return createDate(date.getFullYear(), date.getMonth(), 1);
  }
  lastDayOfPeriod(date) {
    return lastDayOfMonth(date);
  }
  isRangeStart(value2) {
    return !value2.getMonth();
  }
  move(value2, action) {
    const modifier = ACTIONS$1[action];
    if (!modifier) {
      return value2;
    }
    return modifier(value2);
  }
  cellTitle(value2) {
    return this._intlService.formatDate(value2, "D");
  }
  navigationTitle(value2) {
    if (!value2) {
      return "";
    }
    return this.isRangeStart(value2) ? value2.getFullYear().toString() : this.abbrMonthNames()[value2.getMonth()];
  }
  title(current) {
    return `${this.wideMonthNames()[current.getMonth()]} ${current.getFullYear()}`;
  }
  rowLength(options = {}) {
    return CELLS_LENGTH$1 + (options.prependCell ? 1 : 0);
  }
  skip(value2, min) {
    return durationInMonths(min, value2);
  }
  total(min, max) {
    return durationInMonths(min, max) + 1;
  }
  value(current) {
    return current ? current.getDate().toString() : "";
  }
  viewDate(date, max, viewsCount = 1) {
    const viewsInRange = this.total(date, max);
    if (viewsInRange < viewsCount) {
      const monthsToSubtract = viewsCount - viewsInRange;
      return addMonths(date, -1 * monthsToSubtract);
    }
    return date;
  }
  isWeekend(date) {
    const {
      start,
      end
    } = this._intlService.weekendRange();
    const day = date.getDay();
    if (end < start) {
      return day <= end || start <= day;
    }
    return start <= day && day <= end;
  }
  dateRange = (start, end) => {
    if (!isPresent4(start) || !isPresent4(end)) {
      return [];
    }
    const result = [];
    let current = start;
    while (current <= end) {
      result.push(current);
      current = addDays(current, 1);
    }
    return result;
  };
  abbrMonthNames() {
    return this._intlService.dateFormatNames({
      nameType: "abbreviated",
      type: "months"
    });
  }
  normalize(cellDate, min, max) {
    if (cellDate < min && this.isEqual(cellDate, min)) {
      return cloneDate(min);
    }
    if (cellDate > max && this.isEqual(cellDate, max)) {
      return cloneDate(max);
    }
    return cellDate;
  }
  wideMonthNames() {
    return this._intlService.dateFormatNames({
      nameType: "wide",
      type: "months"
    });
  }
  static ɵfac = function MonthViewService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MonthViewService)(ɵɵinject(IntlService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _MonthViewService,
    factory: _MonthViewService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MonthViewService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: IntlService
  }], null);
})();
var EMPTY_DATA = [[]];
var CELLS_LENGTH = 4;
var ROWS_LENGTH = 3;
var ACTIONS = {
  [Action.Left]: (date) => addMonths(date, -1),
  [Action.Up]: (date) => addMonths(date, -4),
  [Action.Right]: (date) => addMonths(date, 1),
  [Action.Down]: (date) => addMonths(date, 4),
  [Action.PrevView]: (date) => addYears(date, -1),
  [Action.NextView]: (date) => addYears(date, 1),
  [Action.FirstInView]: (date) => firstMonthOfYear(date),
  [Action.LastInView]: (date) => lastMonthOfYear(date)
};
var YearViewService = class _YearViewService {
  _intlService;
  constructor(_intlService) {
    this._intlService = _intlService;
  }
  addToDate(min, skip4) {
    return addYears(min, skip4);
  }
  datesList(start, count2) {
    return range(0, count2).map((i) => addYears(start, i));
  }
  data(options) {
    const {
      cellUID,
      focusedDate,
      isActiveView,
      max,
      min,
      selectedDates,
      selectionRange = EMPTY_SELECTIONRANGE,
      viewDate,
      allowReverse
    } = options;
    if (!viewDate) {
      return EMPTY_DATA;
    }
    const months = this.abbrMonthNames();
    const firstDate = firstMonthOfYear(viewDate);
    const lastDate = lastMonthOfYear(viewDate);
    const currentYear = firstDate.getFullYear();
    const cells = range(0, CELLS_LENGTH);
    const today = getToday();
    return range(0, ROWS_LENGTH).map((rowOffset) => {
      const baseDate = addMonths(firstDate, rowOffset * CELLS_LENGTH);
      return cells.map((cellOffset) => {
        const cellDate = this.normalize(addMonths(baseDate, cellOffset), min, max);
        const changedYear = currentYear < cellDate.getFullYear();
        if (!this.isInRange(cellDate, min, max) || changedYear) {
          return null;
        }
        let isRangeStart = false;
        let isRangeEnd = false;
        if (allowReverse) {
          if (this.isEqual(cellDate, selectionRange.start) && selectionRange.start <= selectionRange.end || this.isEqual(cellDate, selectionRange.end) && selectionRange.end <= selectionRange.start) {
            isRangeStart = true;
          }
          if (this.isEqual(cellDate, selectionRange.start) && selectionRange.start >= selectionRange.end || this.isEqual(cellDate, selectionRange.end) && selectionRange.end >= selectionRange.start) {
            isRangeEnd = true;
          }
        } else {
          isRangeStart = this.isEqual(cellDate, selectionRange.start);
          isRangeEnd = this.isEqual(cellDate, selectionRange.end);
        }
        const isInMiddle = !isRangeStart && !isRangeEnd;
        let isRangeMid;
        if (allowReverse) {
          isRangeMid = isInMiddle && (isInSelectionRange(cellDate, selectionRange) || isInSelectionRange(cellDate, {
            start: selectionRange.end,
            end: selectionRange.start
          }));
        } else {
          isRangeMid = isInMiddle && isInSelectionRange(cellDate, selectionRange);
        }
        return {
          formattedValue: months[cellDate.getMonth()],
          id: `${cellUID}${cellDate.getTime()}`,
          isFocused: this.isEqual(cellDate, focusedDate),
          isSelected: isActiveView && selectedDates.some((date) => this.isEqual(cellDate, date)),
          isWeekend: false,
          isRangeStart,
          isRangeMid,
          isRangeEnd,
          isRangeSplitEnd: isRangeMid && this.isEqual(cellDate, lastDate),
          isRangeSplitStart: isRangeMid && this.isEqual(cellDate, firstDate),
          isToday: this.isEqual(cellDate, today),
          title: this.cellTitle(cellDate),
          value: cellDate,
          allowReverse
        };
      });
    });
  }
  isEqual(candidate, expected) {
    if (!candidate || !expected) {
      return false;
    }
    return candidate.getFullYear() === expected.getFullYear() && candidate.getMonth() === expected.getMonth();
  }
  isInArray(date, dates) {
    if (!dates.length) {
      return false;
    }
    const year = date.getFullYear();
    return dates[0].getFullYear() <= year && year <= dates[dates.length - 1].getFullYear();
  }
  isInRange(candidate, min, max) {
    const candidateValue = createDate(candidate.getFullYear(), candidate.getMonth(), 1);
    const aboveMin = !min || createDate(min.getFullYear(), min.getMonth(), 1) <= candidateValue;
    const belowMax = !max || candidateValue <= createDate(max.getFullYear(), max.getMonth(), 1);
    return aboveMin && belowMax;
  }
  beginningOfPeriod(date) {
    if (!date) {
      return date;
    }
    return createDate(date.getFullYear(), 0, 1);
  }
  lastDayOfPeriod(date) {
    const month = lastMonthOfYear(date);
    return lastDayOfMonth(month);
  }
  isRangeStart(value2) {
    return value2.getFullYear() % 10 === 0;
  }
  move(value2, action) {
    const modifier = ACTIONS[action];
    if (!modifier) {
      return value2;
    }
    return modifier(value2);
  }
  cellTitle(value2) {
    return `${value2.getFullYear()} ${this.value(value2)}`;
  }
  navigationTitle(value2) {
    return this.title(value2);
  }
  title(current) {
    return current ? current.getFullYear().toString() : "";
  }
  rowLength() {
    return CELLS_LENGTH;
  }
  skip(value2, min) {
    return durationInYears(min, value2);
  }
  total(min, max) {
    return durationInYears(min, max) + 1;
  }
  value(current) {
    return current ? this.abbrMonthNames()[current.getMonth()] : "";
  }
  viewDate(date, max, viewsCount = 1) {
    const viewsInRange = this.total(date, max);
    if (viewsInRange < viewsCount) {
      const yearsToSubtract = viewsCount - viewsInRange;
      return addYears(date, -1 * yearsToSubtract);
    }
    return date;
  }
  dateRange = (start, end) => {
    if (!isPresent4(start) || !isPresent4(end)) {
      return [];
    }
    const result = [];
    let current = start;
    while (current <= end) {
      result.push(current);
      current = addMonths(current, 1);
    }
    return result;
  };
  abbrMonthNames() {
    return this._intlService.dateFormatNames({
      nameType: "abbreviated",
      type: "months"
    });
  }
  normalize(cellDate, min, max) {
    if (cellDate < min && this.isEqual(cellDate, min)) {
      return cloneDate(min);
    }
    if (cellDate > max && this.isEqual(cellDate, max)) {
      return cloneDate(max);
    }
    return cellDate;
  }
  static ɵfac = function YearViewService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _YearViewService)(ɵɵinject(IntlService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _YearViewService,
    factory: _YearViewService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(YearViewService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: IntlService
  }], null);
})();
var CalendarViewEnum;
(function(CalendarViewEnum2) {
  CalendarViewEnum2[CalendarViewEnum2["month"] = 0] = "month";
  CalendarViewEnum2[CalendarViewEnum2["year"] = 1] = "year";
  CalendarViewEnum2[CalendarViewEnum2["decade"] = 2] = "decade";
  CalendarViewEnum2[CalendarViewEnum2["century"] = 3] = "century";
})(CalendarViewEnum || (CalendarViewEnum = {}));
var services$1 = {
  [CalendarViewEnum.month]: MonthViewService,
  [CalendarViewEnum.year]: YearViewService,
  [CalendarViewEnum.decade]: DecadeViewService,
  [CalendarViewEnum.century]: CenturyViewService
};
var viewOffset = (view2, offset3) => {
  const candidate = CalendarViewEnum[CalendarViewEnum[view2 + offset3]];
  return candidate !== void 0 ? candidate : view2;
};
var nextCalendarId = 0;
var BusViewService = class _BusViewService {
  injector;
  viewChanged = new EventEmitter();
  bottom = CalendarViewEnum.month;
  top = CalendarViewEnum.century;
  calendarId;
  constructor(injector) {
    this.injector = injector;
    this.calendarId = nextCalendarId++;
  }
  configure(bottom, top) {
    this.bottom = bottom;
    this.top = top;
  }
  service(view2) {
    const serviceType = services$1[view2];
    return serviceType ? this.injector.get(serviceType) : null;
  }
  moveDown(view2) {
    this.move(view2, -1);
  }
  moveUp(view2) {
    this.move(view2, 1);
  }
  moveToBottom(activeView) {
    if (activeView === this.bottom) {
      return;
    }
    this.viewChanged.emit({
      view: this.bottom
    });
  }
  canMoveDown(view2) {
    return this.bottom < view2;
  }
  canMoveUp(view2) {
    return view2 < this.top;
  }
  clamp(view2) {
    if (view2 < this.bottom) {
      return this.bottom;
    }
    if (view2 > this.top) {
      return this.top;
    }
    return view2;
  }
  move(view2, offset3) {
    const candidate = this.clamp(viewOffset(view2, offset3));
    if (candidate === view2) {
      return;
    }
    this.viewChanged.emit({
      view: candidate
    });
  }
  static ɵfac = function BusViewService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BusViewService)(ɵɵinject(Injector));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _BusViewService,
    factory: _BusViewService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BusViewService, [{
    type: Injectable
  }], () => [{
    type: Injector
  }], null);
})();
var KForOfContext = class {
  $implicit;
  kForOf;
  index;
  count;
  constructor($implicit, kForOf, index, count2) {
    this.$implicit = $implicit;
    this.kForOf = kForOf;
    this.index = index;
    this.count = count2;
  }
  get first() {
    return this.index === 0;
  }
  get last() {
    return this.index === this.count - 1;
  }
  get even() {
    return this.index % 2 === 0;
  }
  get odd() {
    return !this.even;
  }
};
var KForOf = class _KForOf {
  _viewContainer;
  _template;
  _differs;
  kForOf;
  kForTrackBy;
  _differ = null;
  constructor(_viewContainer, _template, _differs) {
    this._viewContainer = _viewContainer;
    this._template = _template;
    this._differs = _differs;
  }
  set kForTemplate(value2) {
    if (value2) {
      this._template = value2;
    }
  }
  ngOnChanges(changes) {
    if ("kForOf" in changes) {
      const value2 = changes["kForOf"].currentValue;
      if (this._differ || !value2) {
        return;
      }
      try {
        this._differ = this._differs.find(value2).create(this.kForTrackBy);
      } catch (_e) {
        throw new Error(`Cannot find a differ supporting object '${value2}' of type '${getTypeNameForDebugging(value2)}'.`);
      }
    }
  }
  ngDoCheck() {
    if (this._differ) {
      const changes = this._differ.diff(this.kForOf);
      if (changes) {
        this._applyChanges(changes);
      }
    }
  }
  _applyChanges(changes) {
    if (!isDocumentAvailable()) {
      return;
    }
    const viewContainerLength = this._viewContainer.length;
    const dataLength = this.kForOf.length;
    const tuples = {};
    changes.forEachOperation((record, _, currentIndex) => {
      if (currentIndex !== null) {
        tuples[currentIndex] = record.item;
      }
    });
    for (let i = viewContainerLength; i < dataLength; i++) {
      this._viewContainer.createEmbeddedView(this._template, new KForOfContext(null, this.kForOf, -1, -1), i);
    }
    for (let i = this._viewContainer.length; i > dataLength; i--) {
      this._viewContainer.remove(i - 1);
    }
    for (let i = 0; i < this._viewContainer.length; i++) {
      const view2 = this._viewContainer.get(i);
      view2.context.index = i;
      view2.context.count = length;
      view2.context.$implicit = tuples[i] || null;
    }
  }
  static ɵfac = function KForOf_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _KForOf)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(IterableDiffers));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _KForOf,
    selectors: [["", "kFor", "", "kForOf", ""]],
    inputs: {
      kForOf: "kForOf",
      kForTrackBy: "kForTrackBy",
      kForTemplate: "kForTemplate"
    },
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(KForOf, [{
    type: Directive,
    args: [{
      selector: "[kFor][kForOf]",
      standalone: true
    }]
  }], () => [{
    type: ViewContainerRef
  }, {
    type: TemplateRef
  }, {
    type: IterableDiffers
  }], {
    kForOf: [{
      type: Input
    }],
    kForTrackBy: [{
      type: Input
    }],
    kForTemplate: [{
      type: Input
    }]
  });
})();
function getTypeNameForDebugging(type) {
  return type.name || typeof type;
}
var noop$1 = () => false;
var DISABLED_DATES_DOC_LINK = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/calendar/disabled-dates/";
var DisabledDatesService = class _DisabledDatesService {
  /**
   * Emits every time the `isDateDisabled` method changes.
   */
  changes = new Subject();
  /**
   * Based on the user-defined `disabledDates` input evaluates if the date is disabled.
   * If not set, returns `false`.
   */
  isDateDisabled = noop$1;
  /**
   * Configures the `isDateDisabled` function.
   *
   * * If a function is provided, uses it as-is and passes each date to it for evaluation.
   * The time part is set to `midnight`.
   * * If a `Date[]` is provided, creates a function that checks the targeted date against
   * the listed dates and, if the targeted date is listed, marks it as disabled.
   * * If a `Day[]` is provided, creates a function that evaluates the provided days of the
   * week as disabled.
   */
  initialize(disabledDates) {
    if (typeof disabledDates === "function") {
      this.isDateDisabled = (date) => disabledDates(getDate(date));
    } else if (isNumberArray(disabledDates)) {
      const disabledWeekDays = new Set(disabledDates);
      this.isDateDisabled = (date) => disabledWeekDays.has(date.getDay());
    } else if (isDateArray(disabledDates)) {
      const normalizedDisabledDates = new Set(disabledDates.map((date) => getDate(date).getTime()));
      this.isDateDisabled = (date) => normalizedDisabledDates.has(getDate(date).getTime());
    } else {
      this.isDateDisabled = noop$1;
      this.notifyInvalidInput(disabledDates);
    }
    this.notifyServiceChange();
  }
  notifyInvalidInput(disabledDates) {
    if (isPresent4(disabledDates) && isDevMode()) {
      throw new Error(`The 'disabledDates' value should be a function, a Day array or a Date array. Check ${DISABLED_DATES_DOC_LINK} for more information.`);
    }
  }
  notifyServiceChange() {
    this.changes.next();
  }
  static ɵfac = function DisabledDatesService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DisabledDatesService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DisabledDatesService,
    factory: _DisabledDatesService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DisabledDatesService, [{
    type: Injectable
  }], null, null);
})();
var closestInScope2 = (node, predicate, scope) => {
  while (node && node !== scope && !predicate(node)) {
    node = node.parentNode;
  }
  if (node !== scope) {
    return node;
  }
};
var closest2 = (node, predicate) => {
  while (node && !predicate(node)) {
    node = node.parentNode;
  }
  return node;
};
var ViewComponent = class _ViewComponent {
  bus;
  intl;
  cdr;
  element;
  zone;
  renderer;
  disabledDatesService;
  allowReverse;
  showOtherMonthDays;
  direction = "vertical";
  isActive = true;
  activeView;
  cellUID;
  focusedDate;
  viewDate;
  activeRangeEnd;
  selectionRange;
  min;
  max;
  selectedDates = [];
  get weekNumber() {
    return this.showWeekNumbers && this.activeView === CalendarViewEnum.month;
  }
  set weekNumber(showWeekNumbers) {
    this.showWeekNumbers = showWeekNumbers;
  }
  viewIndex;
  templateRef;
  weekNumberTemplateRef;
  headerTitle;
  cellClick = new EventEmitter();
  weekNumberCellClick = new EventEmitter();
  cellEnter = new EventEmitter();
  cellLeave = new EventEmitter();
  focusedCellId = new EventEmitter();
  get ariaHidden() {
    return this.headerTitle === this.title ? null : true;
  }
  colSpan = 0;
  data;
  service;
  title;
  subscriptions = new Subscription();
  showWeekNumbers;
  domEvents = [];
  currentCellIndex;
  constructor(bus, intl, cdr, element, zone, renderer, disabledDatesService) {
    this.bus = bus;
    this.intl = intl;
    this.cdr = cdr;
    this.element = element;
    this.zone = zone;
    this.renderer = renderer;
    this.disabledDatesService = disabledDatesService;
    this.subscriptions.add(this.intl.changes.subscribe(this.intlChange.bind(this)));
    this.subscriptions.add(this.disabledDatesService.changes.subscribe(this.disabledDatesChange.bind(this)));
  }
  ngOnInit() {
    if (this.element) {
      this.zone.runOutsideAngular(() => {
        this.bindEvents();
      });
    }
  }
  ngOnChanges(changes) {
    this.service = this.bus.service(this.activeView);
    if (!this.service) {
      return;
    }
    this.colSpan = this.service.rowLength({
      prependCell: this.weekNumber
    });
    this.title = this.service.title(this.viewDate);
    this.updateData();
    if (changes.activeView) {
      this.currentCellIndex = null;
    }
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
    this.domEvents.forEach((unsubscribeCallback) => unsubscribeCallback());
  }
  isHorizontal() {
    return this.direction === "horizontal";
  }
  isMonthView() {
    return this.activeView === CalendarViewEnum.month;
  }
  shouldRenderCellContent(cellCtx) {
    return isPresent4(cellCtx) && (!cellCtx.isOtherMonth || cellCtx.isOtherMonth && this.showOtherMonthDays);
  }
  firstDate(rowCtx) {
    const ctx = this.firstWeekDateContext(rowCtx);
    return ctx ? ctx.value : null;
  }
  getWeekNumber(date) {
    if (!this.weekNumber) {
      return null;
    }
    return weekInYear(date, this.intl.firstDay());
  }
  getWeekNumberContext(rowCtx) {
    const ctx = this.firstWeekDateContext(rowCtx);
    if (!this.weekNumber || !ctx) {
      return null;
    }
    const weekNumber = weekInYear(ctx.value, this.intl.firstDay()).toString();
    return {
      formattedValue: weekNumber,
      id: null,
      isFocused: false,
      isSelected: false,
      isWeekend: false,
      title: weekNumber,
      value: cloneDate(ctx.value)
    };
  }
  getStyles(context) {
    if (!context.isOtherMonth && this.isActive && context.isFocused) {
      this.focusedCellId.emit(context.id);
    }
    const {
      isRangeEnd,
      isRangeStart
    } = context;
    const isEndActive = this.activeRangeEnd === "end" && isRangeEnd;
    const isStartActive = this.activeRangeEnd === "start" && isRangeStart;
    return stringifyClassObject({
      "k-range-end": !context.isOtherMonth && isRangeEnd,
      "k-range-mid": !context.isOtherMonth && context.isRangeMid,
      "k-range-split-end": !context.isOtherMonth && context.isRangeSplitEnd,
      "k-range-split-start": !context.isOtherMonth && context.isRangeSplitStart,
      "k-range-start": !context.isOtherMonth && isRangeStart,
      "k-active": isStartActive || isEndActive,
      "k-focus": !context.isOtherMonth && this.isActive && context.isFocused,
      "k-selected": !context.isOtherMonth && (context.isSelected || isRangeStart || isRangeEnd),
      "k-today": !context.isOtherMonth && context.isToday,
      "k-weekend": context.isWeekend,
      "k-disabled": context.isDisabled,
      "k-other-month": context.isOtherMonth
    });
  }
  tableCellIndex(rowIndex, cellIndex) {
    return `${rowIndex}:${cellIndex}`;
  }
  handleWeekNumberClick(week) {
    const availableDates = week.filter((day) => day).map((item) => item.value).filter((date) => !this.disabledDatesService.isDateDisabled(date));
    this.weekNumberCellClick.emit(availableDates);
  }
  getMonthLabel(date) {
    return this.activeView === 1 ? this.intl.formatDate(date, "MMMM") : null;
  }
  firstWeekDateContext(rowCtx) {
    if (!this.weekNumber) {
      return null;
    }
    let idx4 = 0;
    let ctx = this.shouldRenderCellContent(rowCtx[idx4]) ? rowCtx[idx4] : null;
    while (!ctx && idx4 < rowCtx.length) {
      const cellCtx = rowCtx[++idx4];
      ctx = this.shouldRenderCellContent(cellCtx) ? cellCtx : null;
    }
    return ctx;
  }
  updateData() {
    const time = last(this.selectedDates) || getToday();
    const viewDate = setTime(this.viewDate, time);
    this.data = this.service.data({
      cellUID: this.cellUID,
      focusedDate: this.focusedDate,
      isActiveView: !this.bus.canMoveDown(this.activeView),
      max: this.max,
      min: this.min,
      selectedDates: this.selectedDates,
      selectionRange: this.selectionRange,
      viewDate,
      isDateDisabled: this.disabledDatesService.isDateDisabled,
      direction: this.direction,
      allowReverse: this.allowReverse
    });
  }
  intlChange() {
    this.updateData();
    this.cdr.markForCheck();
  }
  disabledDatesChange() {
    this.updateData();
    this.cdr.markForCheck();
  }
  bindEvents() {
    const element = this.element.nativeElement;
    this.domEvents.push(this.renderer.listen(element, "mouseover", this.cellMouseoverHandler.bind(this)), this.renderer.listen(element, "mouseleave", this.mouseLeaveHandler.bind(this)), this.renderer.listen(element, "click", this.clickHandler.bind(this)));
  }
  clickHandler(args) {
    const cell2 = this.closestCell(args);
    if (!cell2) {
      return;
    }
    const index = cell2.getAttribute("data-cell-index");
    const cellContext = this.cellByIndex(index);
    if (!cellContext.isDisabled) {
      const {
        ctrlKey,
        metaKey,
        shiftKey
      } = args;
      this.cellClick.emit({
        date: cellContext.value,
        modifiers: {
          ctrlKey,
          metaKey,
          shiftKey
        }
      });
    }
  }
  mouseLeaveHandler() {
    if (this.currentCellIndex) {
      this.emitCellLeave();
    }
  }
  cellMouseoverHandler(args) {
    const cell2 = this.closestCell(args);
    if (cell2) {
      const index = cell2.getAttribute("data-cell-index");
      if (this.currentCellIndex && this.currentCellIndex !== index) {
        this.emitCellLeave();
      }
      const value2 = this.cellByIndex(index).value;
      this.cellEnter.emit(value2);
      this.currentCellIndex = index;
    } else if (this.currentCellIndex) {
      this.emitCellLeave();
    }
  }
  closestCell(eventArgs) {
    return closestInScope2(eventArgs.target, (node) => node.hasAttribute("data-cell-index"), this.element.nativeElement);
  }
  emitCellLeave() {
    const item = this.cellByIndex(this.currentCellIndex);
    if (item) {
      this.cellLeave.emit(item.value);
    }
    this.currentCellIndex = null;
  }
  cellByIndex(index) {
    const [rowIndex, cellIndex] = index.split(":");
    return this.data[rowIndex][cellIndex];
  }
  static ɵfac = function ViewComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ViewComponent)(ɵɵdirectiveInject(BusViewService), ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(DisabledDatesService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ViewComponent,
    selectors: [["", "kendoCalendarView", ""]],
    inputs: {
      allowReverse: "allowReverse",
      showOtherMonthDays: "showOtherMonthDays",
      direction: "direction",
      isActive: "isActive",
      activeView: "activeView",
      cellUID: "cellUID",
      focusedDate: "focusedDate",
      viewDate: "viewDate",
      activeRangeEnd: "activeRangeEnd",
      selectionRange: "selectionRange",
      min: "min",
      max: "max",
      selectedDates: "selectedDates",
      weekNumber: "weekNumber",
      viewIndex: "viewIndex",
      templateRef: "templateRef",
      weekNumberTemplateRef: "weekNumberTemplateRef",
      headerTitle: "headerTitle"
    },
    outputs: {
      cellClick: "cellClick",
      weekNumberCellClick: "weekNumberCellClick",
      cellEnter: "cellEnter",
      cellLeave: "cellLeave",
      focusedCellId: "focusedCellId"
    },
    features: [ɵɵNgOnChangesFeature],
    attrs: _c0,
    decls: 2,
    vars: 2,
    consts: [["role", "row", 1, "k-calendar-tr"], ["class", "k-calendar-tr", "role", "row", 4, "kFor", "kForOf"], ["scope", "col", 1, "k-calendar-caption", 3, "colSpan"], [4, "kFor", "kForOf"], ["role", "gridcell", 1, "k-alt", "k-calendar-td"], ["role", "gridcell", 1, "k-empty", "k-calendar-td"], ["role", "gridcell", 1, "k-alt", "k-calendar-td", 3, "click"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["role", "gridcell", 1, "k-calendar-td", 3, "ngClass", "title"], [1, "k-link"]],
    template: function ViewComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵconditionalCreate(0, ViewComponent_Conditional_0_Template, 3, 3, "tr", 0);
        ɵɵtemplate(1, ViewComponent_tr_1_Template, 3, 2, "tr", 1);
      }
      if (rf & 2) {
        ɵɵconditional(!ctx.isHorizontal() ? 0 : -1);
        ɵɵadvance();
        ɵɵproperty("kForOf", ctx.data);
      }
    },
    dependencies: [KForOf, NgTemplateOutlet, NgClass],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ViewComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line
      selector: "[kendoCalendarView]",
      template: `
@if (!isHorizontal()) {
  <tr class="k-calendar-tr" role="row" [attr.aria-hidden]="ariaHidden"><th class="k-calendar-caption" scope="col" [colSpan]="colSpan">{{title}}</th></tr>
}
<tr *kFor="let row of data; let rowIndex = index" class="k-calendar-tr" role="row">
  @if (weekNumber) {
    @if (firstDate(row)) {
      <td
        class="k-alt k-calendar-td"
        role="gridcell"
        (click)="handleWeekNumberClick(row)"
        >
        @if (!weekNumberTemplateRef) {
          {{getWeekNumber(firstDate(row))}}
        }
        @if (weekNumberTemplateRef) {
          <ng-template
            [ngTemplateOutlet]="weekNumberTemplateRef"
                    [ngTemplateOutletContext]="{
                        $implicit: firstDate(row),
                        cellContext: getWeekNumberContext(row)
                    }"
          ></ng-template>
        }
      </td>
    } @else {
      <td class="k-empty k-calendar-td" role="gridcell">&nbsp;</td>
    }
  }
  <ng-container *kFor="let cell of row; let cellIndex = index">
    @if (shouldRenderCellContent(cell)) {
      <td class="k-calendar-td"
        role="gridcell"
        [attr.id]="cell.id"
        [attr.data-cell-index]="tableCellIndex(rowIndex, cellIndex)"
        [attr.aria-selected]="cell.isSelected || cell.isRangeStart || cell.isRangeMid || cell.isRangeEnd"
        [attr.aria-disabled]="cell.isDisabled"
        [attr.aria-label]="getMonthLabel(cell.value)"
        [ngClass]="getStyles(cell)"
        [title]="cell.title"
        >
        <span class="k-link">
          @if (!templateRef) {{{cell.formattedValue}}}
          @if (templateRef) {
            <ng-template
              [ngTemplateOutlet]="templateRef"
              [ngTemplateOutletContext]="{ $implicit: cell.value, cellContext: cell }"
            ></ng-template>
          }
        </span>
      </td>
    } @else {
      <td class="k-empty k-calendar-td" role="gridcell">&nbsp;</td>
    }
  </ng-container>
</tr>
`,
      standalone: true,
      imports: [KForOf, NgTemplateOutlet, NgClass]
    }]
  }], () => [{
    type: BusViewService
  }, {
    type: IntlService
  }, {
    type: ChangeDetectorRef
  }, {
    type: ElementRef
  }, {
    type: NgZone
  }, {
    type: Renderer2
  }, {
    type: DisabledDatesService
  }], {
    allowReverse: [{
      type: Input
    }],
    showOtherMonthDays: [{
      type: Input
    }],
    direction: [{
      type: Input
    }],
    isActive: [{
      type: Input
    }],
    activeView: [{
      type: Input
    }],
    cellUID: [{
      type: Input
    }],
    focusedDate: [{
      type: Input
    }],
    viewDate: [{
      type: Input
    }],
    activeRangeEnd: [{
      type: Input
    }],
    selectionRange: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    selectedDates: [{
      type: Input
    }],
    weekNumber: [{
      type: Input
    }],
    viewIndex: [{
      type: Input
    }],
    templateRef: [{
      type: Input
    }],
    weekNumberTemplateRef: [{
      type: Input
    }],
    headerTitle: [{
      type: Input
    }],
    cellClick: [{
      type: Output
    }],
    weekNumberCellClick: [{
      type: Output
    }],
    cellEnter: [{
      type: Output
    }],
    cellLeave: [{
      type: Output
    }],
    focusedCellId: [{
      type: Output
    }]
  });
})();
var DEFAULT_VIEWS_LENGTH = 2;
var HorizontalViewListComponent = class _HorizontalViewListComponent {
  bus;
  intl;
  cdr;
  element;
  renderer;
  handleMultiViewCalendarFocus() {
    this.focusCalendar.emit();
  }
  handleMultiViewCalendarBlur(event) {
    this.blurCalendar.emit(event);
  }
  /**
   * Needed for the MultiViewCalendar used in the Scheduler Year view
   */
  showOtherMonthDays = true;
  cellTemplateRef;
  weekNumberTemplateRef;
  allowReverse;
  activeRangeEnd;
  activeView = CalendarViewEnum.month;
  cellUID;
  focusedDate;
  isActive = true;
  min = new Date(MIN_DATE);
  max = new Date(MAX_DATE);
  selectionRange;
  selectedDates = [];
  views = DEFAULT_VIEWS_LENGTH;
  showViewHeader = false;
  animateNavigation = false;
  orientation = "horizontal";
  activeDescendant;
  tabIndex = 0;
  disabled = false;
  id;
  weekDaysFormat = "short";
  get weekNumber() {
    return this.showWeekNumbers && this.isMonthView();
  }
  set weekNumber(showWeekNumbers) {
    this.showWeekNumbers = showWeekNumbers;
  }
  cellClick = new EventEmitter();
  weekNumberCellClick = new EventEmitter();
  cellEnter = new EventEmitter();
  cellLeave = new EventEmitter();
  activeDateChange = new EventEmitter();
  focusCalendar = new EventEmitter();
  blurCalendar = new EventEmitter();
  focusedCellChange = new EventEmitter();
  getComponentClass = true;
  get horizontalHostClass() {
    return this.orientation === "horizontal";
  }
  get verticalHostClass() {
    return this.orientation === "vertical";
  }
  get getComponentMonthClass() {
    return this.activeView === CalendarViewEnum.month;
  }
  get getComponentYearClass() {
    return this.activeView === CalendarViewEnum.year;
  }
  get getComponentDecadeClass() {
    return this.activeView === CalendarViewEnum.decade;
  }
  get getComponentCenturyClass() {
    return this.activeView === CalendarViewEnum.century;
  }
  get role() {
    return this.views >= 2 ? "grid" : null;
  }
  get tabindex() {
    return this.views >= 2 ? "0" : null;
  }
  get getActiveDescendant() {
    return this.views === 1 ? this.activeDescendant : null;
  }
  get getTabIndex() {
    return this.disabled || this.views >= 2 ? null : this.tabIndex;
  }
  service;
  weekNames = [];
  wideWeekNames = [];
  activeDate;
  dates = [];
  skip;
  total;
  nextAnimationDate;
  prevAnimationDate;
  showWeekNumbers;
  intlSubscription;
  animation;
  constructor(bus, intl, cdr, element, renderer) {
    this.bus = bus;
    this.intl = intl;
    this.cdr = cdr;
    this.element = element;
    this.renderer = renderer;
    this.intlSubscription = this.intl.changes.subscribe(this.intlChange.bind(this));
  }
  ngOnChanges(changes) {
    this.initService();
    if (this.weekNames.length === 0 || changes.weekNumber) {
      this.weekNames = this.getWeekNames(this.weekDaysFormat);
      this.wideWeekNames = this.getWeekNames("wide");
    }
    if (changes.weekDaysFormat && this.weekNames.length !== 0 && !changes.weekNumber) {
      this.weekNames = this.getWeekNames(this.weekDaysFormat);
    }
    if (!this.service) {
      return;
    }
    this.views = this.views || DEFAULT_VIEWS_LENGTH;
    const focusedDate = this.focusedDate;
    const viewDate = this.clampDate(this.service.viewDate(focusedDate, this.max, this.views));
    this.skip = this.service.skip(viewDate, this.min);
    this.total = this.service.total(this.min, this.max);
    const activeViewChanged = hasChange(changes, "activeView");
    const viewsHasChanged = this.views > 0 && hasChange(changes, "views");
    if (activeViewChanged || !this.isInDates(focusedDate) || viewsHasChanged || !this.activeDate) {
      this.dates = this.service.datesList(viewDate, this.getTake(this.skip));
      this.activeDate = cloneDate(this.dates[0]);
      this.activeDateChange.emit(this.activeDate);
    }
    this.setAriaActivedescendant();
    if (this.views >= 2) {
      this.renderer.setAttribute(this.element.nativeElement, "tabindex", this.tabIndex.toString());
    }
  }
  ngOnDestroy() {
    this.intlSubscription.unsubscribe();
  }
  initService() {
    this.service = this.bus.service(this.activeView);
  }
  isMonthView() {
    return this.activeView === CalendarViewEnum.month;
  }
  getCaptionTitle(date) {
    return this.service.title(date);
  }
  handleClassicCalendarFocus() {
    this.focusCalendar.emit();
  }
  handleClassicCalendarBlur(event) {
    this.blurCalendar.emit(event);
  }
  animateView(action) {
    const container = this.element.nativeElement;
    const table2 = container.querySelector("table");
    const initialContainerWidth = parseFloat(getComputedStyle(container).width);
    const tableWidth = parseFloat(getComputedStyle(table2).width);
    this.renderer.setStyle(container, "width", `${initialContainerWidth}px`);
    this.renderer.setStyle(container, "overflow", "visible");
    if (action === Action.NextView) {
      this.nextAnimationDate = cloneDate(this.dates[0]);
    } else {
      this.prevAnimationDate = cloneDate(this.dates[this.dates.length - 1]);
    }
    this.cdr.detectChanges();
    container.querySelectorAll("table").forEach((table3) => {
      this.renderer.setStyle(table3, "width", `${tableWidth}px`);
    });
    const tabRect = table2.getBoundingClientRect();
    const containerGap = parseFloat(getComputedStyle(container).columnGap);
    const start = action === Action.NextView ? "translateX(0)" : `translateX(-${tabRect.width + containerGap}px)`;
    const end = action === Action.NextView ? `translateX(-${tabRect.width + containerGap}px)` : "translateX(0)";
    if (!this.animation) {
      this.animation = container.animate([{
        transform: start
      }, {
        transform: end
      }], {
        duration: 500,
        easing: "ease-out"
      });
      this.animation.oncancel = this.animation.onfinish = () => {
        this.renderer.removeStyle(container, "width");
        this.renderer.removeStyle(container, "overflow");
        container.querySelectorAll("table").forEach((table3) => {
          this.renderer.removeStyle(table3, "width");
        });
        this.animation = null;
        this.nextAnimationDate = null;
        this.prevAnimationDate = null;
        this.cdr.detectChanges();
      };
    } else {
      this.animation.cancel();
    }
  }
  navigate(action) {
    if (this.animateNavigation && isDocumentAvailable() && isPresent4(this.element.nativeElement.animate)) {
      this.animateView(action);
    }
    const candidate = this.move(action);
    const list2 = this.service.datesList(candidate, this.getTake(this.skip));
    if (this.isListInRange(list2)) {
      this.dates = list2;
    }
    this.activeDate = cloneDate(this.dates[0]);
    this.focusedDate = cloneDate(candidate);
    this.cdr.markForCheck();
    this.activeDateChange.emit(this.activeDate);
    return cloneDate(candidate);
  }
  canNavigate(action) {
    if (!this.service) {
      return false;
    }
    return this.isListInRange(this.service.datesList(this.move(action), this.getTake(this.skip)));
  }
  getWeekNames(type) {
    const weekNames = shiftWeekNames(this.intl.dateFormatNames({
      nameType: type,
      type: "days"
    }), this.intl.firstDay());
    return this.weekNumber ? [""].concat(weekNames) : weekNames;
  }
  intlChange() {
    this.weekNames = this.getWeekNames(this.weekDaysFormat);
    this.wideWeekNames = this.getWeekNames("wide");
    this.cdr.markForCheck();
  }
  clampDate(value2) {
    return dateInRange(value2, this.min, this.max);
  }
  move(action) {
    return this.service.move(this.dates[0] || this.focusedDate, action);
  }
  isListInRange(list2) {
    const lowerBound = this.service.beginningOfPeriod(this.min);
    const upperBound = this.service.beginningOfPeriod(this.service.addToDate(this.max, 1));
    return lowerBound <= list2[0] && list2[list2.length - 1] < upperBound;
  }
  isInDates(value2) {
    return this.service.isInArray(value2, this.dates);
  }
  getTake(skip4) {
    return Math.min(this.total - skip4, this.views);
  }
  setAriaActivedescendant() {
    if (this.views >= 2) {
      this.renderer.setAttribute(this.element.nativeElement, attributeNames.ariaActiveDescendant, this.activeDescendant);
    }
  }
  static ɵfac = function HorizontalViewListComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HorizontalViewListComponent)(ɵɵdirectiveInject(BusViewService), ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _HorizontalViewListComponent,
    selectors: [["kendo-calendar-horizontal"]],
    hostVars: 20,
    hostBindings: function HorizontalViewListComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("focus", function HorizontalViewListComponent_focus_HostBindingHandler() {
          return ctx.handleMultiViewCalendarFocus();
        })("blur", function HorizontalViewListComponent_blur_HostBindingHandler($event) {
          return ctx.handleMultiViewCalendarBlur($event);
        });
      }
      if (rf & 2) {
        ɵɵattribute("role", ctx.role)("tabindex", ctx.tabindex);
        ɵɵclassProp("k-calendar-view", ctx.getComponentClass)("k-align-items-start", ctx.getComponentClass)("k-justify-content-center", ctx.getComponentClass)("k-hstack", ctx.horizontalHostClass)("k-vstack", ctx.verticalHostClass)("k-calendar-monthview", ctx.getComponentMonthClass)("k-calendar-yearview", ctx.getComponentYearClass)("k-calendar-decadeview", ctx.getComponentDecadeClass)("k-calendar-centuryview", ctx.getComponentCenturyClass);
      }
    },
    inputs: {
      showOtherMonthDays: "showOtherMonthDays",
      cellTemplateRef: "cellTemplateRef",
      weekNumberTemplateRef: "weekNumberTemplateRef",
      allowReverse: "allowReverse",
      activeRangeEnd: "activeRangeEnd",
      activeView: "activeView",
      cellUID: "cellUID",
      focusedDate: "focusedDate",
      isActive: "isActive",
      min: "min",
      max: "max",
      selectionRange: "selectionRange",
      selectedDates: "selectedDates",
      views: "views",
      showViewHeader: "showViewHeader",
      animateNavigation: "animateNavigation",
      orientation: "orientation",
      activeDescendant: "activeDescendant",
      tabIndex: "tabIndex",
      disabled: "disabled",
      id: "id",
      weekDaysFormat: "weekDaysFormat",
      weekNumber: "weekNumber"
    },
    outputs: {
      cellClick: "cellClick",
      weekNumberCellClick: "weekNumberCellClick",
      cellEnter: "cellEnter",
      cellLeave: "cellLeave",
      activeDateChange: "activeDateChange",
      focusCalendar: "focusCalendar",
      blurCalendar: "blurCalendar",
      focusedCellChange: "focusedCellChange"
    },
    features: [ɵɵNgOnChangesFeature],
    decls: 5,
    vars: 3,
    consts: [["tableTemplate", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [4, "kFor", "kForOf"], [1, "k-calendar-table", 3, "focus", "blur", "ngClass"], [1, "k-calendar-caption"], ["role", "rowgroup", 1, "k-calendar-thead"], ["kendoCalendarView", "", "role", "rowgroup", "direction", "horizontal", 1, "k-calendar-tbody", 3, "cellClick", "weekNumberCellClick", "cellEnter", "cellLeave", "focusedCellId", "allowReverse", "showOtherMonthDays", "activeView", "isActive", "min", "max", "cellUID", "focusedDate", "selectedDates", "selectionRange", "activeRangeEnd", "weekNumber", "templateRef", "weekNumberTemplateRef", "viewDate"], ["role", "row", 1, "k-calendar-tr"], ["scope", "col", "role", "columnheader", 1, "k-calendar-th"]],
    template: function HorizontalViewListComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, HorizontalViewListComponent_ng_template_0_Template, 4, 22, "ng-template", null, 0, ɵɵtemplateRefExtractor);
        ɵɵconditionalCreate(2, HorizontalViewListComponent_Conditional_2_Template, 1, 4, null, 1);
        ɵɵtemplate(3, HorizontalViewListComponent_3_Template, 1, 4, null, 2);
        ɵɵconditionalCreate(4, HorizontalViewListComponent_Conditional_4_Template, 1, 4, null, 1);
      }
      if (rf & 2) {
        ɵɵadvance(2);
        ɵɵconditional(ctx.nextAnimationDate ? 2 : -1);
        ɵɵadvance();
        ɵɵproperty("kForOf", ctx.dates);
        ɵɵadvance();
        ɵɵconditional(ctx.prevAnimationDate ? 4 : -1);
      }
    },
    dependencies: [NgClass, ViewComponent, NgTemplateOutlet, KForOf],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HorizontalViewListComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-calendar-horizontal",
      template: `
        <ng-template #tableTemplate let-date="date" let-class="className">
          <table
            [attr.role]="views >= 2 ? 'none' : 'grid'"
            class="k-calendar-table"
            [ngClass]="class"
            [attr.aria-labelledby]="id"
            [attr.aria-activedescendant]="getActiveDescendant"
            [attr.tabindex]="getTabIndex"
            (focus)="handleClassicCalendarFocus()"
            (blur)="handleClassicCalendarBlur($event)"
            >
            @if (showViewHeader) {
              <caption class="k-calendar-caption">{{ getCaptionTitle(date) }}</caption>
            }
            @if (isMonthView()) {
              <thead class="k-calendar-thead" role="rowgroup">
                <tr class="k-calendar-tr" role="row">
                  @for (name of weekNames; track $index; let i = $index) {
                    <th
                      class="k-calendar-th"
                      scope="col"
                      [attr.aria-label]="wideWeekNames[i]"
                      role="columnheader"
                    >{{name}}</th>
                  }
                </tr>
              </thead>
            }
            <tbody
              class="k-calendar-tbody"
              kendoCalendarView
              [allowReverse]="allowReverse"
              [showOtherMonthDays]="showOtherMonthDays"
              role="rowgroup"
              direction="horizontal"
              [activeView]="activeView"
              [isActive]="isActive"
              [min]="min"
              [max]="max"
              [cellUID]="cellUID"
              [focusedDate]="focusedDate"
              [selectedDates]="selectedDates"
              [selectionRange]="selectionRange"
              [activeRangeEnd]="activeRangeEnd"
              [weekNumber]="weekNumber"
              [templateRef]="cellTemplateRef"
              [weekNumberTemplateRef]="weekNumberTemplateRef"
              [viewDate]="date"
              (cellClick)="cellClick.emit($event)"
              (weekNumberCellClick)="weekNumberCellClick.emit($event)"
              (cellEnter)="cellEnter.emit($event)"
              (cellLeave)="cellLeave.emit($event)"
              (focusedCellId)="focusedCellChange.emit($event)"
              >
            </tbody>
          </table>
        </ng-template>

        <!-- When Next is clicked a placeholder table is rendered before the Main Table -->
        @if (nextAnimationDate) {
          <ng-template
            [ngTemplateOutlet]="tableTemplate"
            [ngTemplateOutletContext]="{
                date: nextAnimationDate,
                className: 'k-pointer-events-none'
            }"
            >
          </ng-template>
        }

        <ng-template
          *kFor="let date of dates"
          [ngTemplateOutlet]="tableTemplate"
            [ngTemplateOutletContext]="{
                date: date
            }"
          >
        </ng-template>

        <!-- When Prev is clicked a placeholder table is rendered after the Main Table -->
        @if (prevAnimationDate) {
          <ng-template
            [ngTemplateOutlet]="tableTemplate"
            [ngTemplateOutletContext]="{
                date: prevAnimationDate,
                className: 'k-pointer-events-none'
            }"
            >
          </ng-template>
        }
        `,
      standalone: true,
      imports: [NgClass, ViewComponent, NgTemplateOutlet, KForOf]
    }]
  }], () => [{
    type: BusViewService
  }, {
    type: IntlService
  }, {
    type: ChangeDetectorRef
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }], {
    handleMultiViewCalendarFocus: [{
      type: HostListener,
      args: ["focus"]
    }],
    handleMultiViewCalendarBlur: [{
      type: HostListener,
      args: ["blur", ["$event"]]
    }],
    showOtherMonthDays: [{
      type: Input
    }],
    cellTemplateRef: [{
      type: Input
    }],
    weekNumberTemplateRef: [{
      type: Input
    }],
    allowReverse: [{
      type: Input
    }],
    activeRangeEnd: [{
      type: Input
    }],
    activeView: [{
      type: Input
    }],
    cellUID: [{
      type: Input
    }],
    focusedDate: [{
      type: Input
    }],
    isActive: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    selectionRange: [{
      type: Input
    }],
    selectedDates: [{
      type: Input
    }],
    views: [{
      type: Input
    }],
    showViewHeader: [{
      type: Input
    }],
    animateNavigation: [{
      type: Input
    }],
    orientation: [{
      type: Input
    }],
    activeDescendant: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    weekDaysFormat: [{
      type: Input
    }],
    weekNumber: [{
      type: Input
    }],
    cellClick: [{
      type: Output
    }],
    weekNumberCellClick: [{
      type: Output
    }],
    cellEnter: [{
      type: Output
    }],
    cellLeave: [{
      type: Output
    }],
    activeDateChange: [{
      type: Output
    }],
    focusCalendar: [{
      type: Output
    }],
    blurCalendar: [{
      type: Output
    }],
    focusedCellChange: [{
      type: Output
    }],
    getComponentClass: [{
      type: HostBinding,
      args: ["class.k-calendar-view"]
    }, {
      type: HostBinding,
      args: ["class.k-align-items-start"]
    }, {
      type: HostBinding,
      args: ["class.k-justify-content-center"]
    }],
    horizontalHostClass: [{
      type: HostBinding,
      args: ["class.k-hstack"]
    }],
    verticalHostClass: [{
      type: HostBinding,
      args: ["class.k-vstack"]
    }],
    getComponentMonthClass: [{
      type: HostBinding,
      args: ["class.k-calendar-monthview"]
    }],
    getComponentYearClass: [{
      type: HostBinding,
      args: ["class.k-calendar-yearview"]
    }],
    getComponentDecadeClass: [{
      type: HostBinding,
      args: ["class.k-calendar-decadeview"]
    }],
    getComponentCenturyClass: [{
      type: HostBinding,
      args: ["class.k-calendar-centuryview"]
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    tabindex: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }]
  });
})();
var HeaderComponent = class _HeaderComponent {
  bus;
  cdr;
  localization;
  intl;
  disabledDatesService;
  /**
   * @hidden
   */
  chevronRightIcon = chevronRightIcon;
  /**
   * @hidden
   */
  chevronLeftIcon = chevronLeftIcon;
  navigate = true;
  todayAvailable = true;
  activeViewValue;
  todayMessage;
  title;
  prevButtonTitle;
  nextButtonTitle;
  parentViewButtonTitle;
  activeView;
  currentDate;
  min = new Date(MIN_DATE);
  max = new Date(MAX_DATE);
  rangeLength = 1;
  titleTemplateRef;
  headerTemplateRef;
  isPrevDisabled = true;
  isNextDisabled = true;
  showNavigationButtons = false;
  orientation = "horizontal";
  id;
  size;
  todayButtonClick = new EventEmitter();
  prevButtonClick = new EventEmitter();
  nextButtonClick = new EventEmitter();
  getComponentClass = true;
  get verticalHostClass() {
    return this.orientation === "vertical";
  }
  subscriptions = new Subscription();
  constructor(bus, cdr, localization, intl, disabledDatesService) {
    this.bus = bus;
    this.cdr = cdr;
    this.localization = localization;
    this.intl = intl;
    this.disabledDatesService = disabledDatesService;
  }
  ngOnInit() {
    this.subscriptions.add(this.intl.changes.subscribe(this.intlChange.bind(this)));
    this.subscriptions.add(this.localization.changes.subscribe(this.l10nChange.bind(this)));
    this.subscriptions.add(this.disabledDatesService.changes.subscribe(this.setTodayAvailability.bind(this)));
  }
  ngOnChanges() {
    const service = this.bus.service(this.activeView);
    if (!service) {
      return;
    }
    this.activeViewValue = CalendarViewEnum[this.activeView];
    this.todayMessage = this.localization.get("today");
    this.parentViewButtonTitle = this.localization.get("parentViewButtonTitle");
    this.setTodayAvailability();
    this.navigate = this.bus.canMoveUp(this.activeView);
    this.title = this.getTitle();
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  handleTodayClick() {
    if (!this.todayAvailable) {
      return;
    }
    this.bus.moveToBottom(this.activeView);
    this.todayButtonClick.emit(dateInRange(getToday(), this.min, this.max));
  }
  handleNavigation() {
    if (!this.navigate) {
      return;
    }
    this.bus.moveUp(this.activeView);
  }
  isDisabled() {
    return this.navigate ? null : "";
  }
  intlChange() {
    if (this.currentDate && this.bus.service(this.activeView)) {
      this.title = this.getTitle();
      this.cdr.markForCheck();
    }
  }
  l10nChange() {
    this.prevButtonTitle = this.localization.get("prevButtonTitle");
    this.nextButtonTitle = this.localization.get("nextButtonTitle");
    this.parentViewButtonTitle = this.localization.get("parentViewButtonTitle");
    this.todayMessage = this.localization.get("today");
    this.cdr.markForCheck();
  }
  getTitle() {
    if (!this.currentDate) {
      return "";
    }
    const service = this.bus.service(this.activeView);
    const take4 = this.rangeLength - 1;
    const title = service.title(this.currentDate);
    const nextDate = service.addToDate(this.currentDate, take4);
    if (take4 < 1 || !service.isInRange(nextDate, this.min, this.max)) {
      return title;
    }
    return `${title} - ${service.title(nextDate)}`;
  }
  setTodayAvailability() {
    const today = getToday();
    const isTodayInRange = isInRange(today, getDate(this.min), getDate(this.max));
    const isDisabled = this.disabledDatesService.isDateDisabled(today);
    this.todayAvailable = isTodayInRange && !isDisabled;
    this.cdr.markForCheck();
  }
  static ɵfac = function HeaderComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HeaderComponent)(ɵɵdirectiveInject(BusViewService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(DisabledDatesService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _HeaderComponent,
    selectors: [["kendo-calendar-header"]],
    hostVars: 4,
    hostBindings: function HeaderComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-calendar-header", ctx.getComponentClass)("k-vstack", ctx.verticalHostClass);
      }
    },
    inputs: {
      activeView: "activeView",
      currentDate: "currentDate",
      min: "min",
      max: "max",
      rangeLength: "rangeLength",
      titleTemplateRef: "titleTemplateRef",
      headerTemplateRef: "headerTemplateRef",
      isPrevDisabled: "isPrevDisabled",
      isNextDisabled: "isNextDisabled",
      showNavigationButtons: "showNavigationButtons",
      orientation: "orientation",
      id: "id",
      size: "size"
    },
    outputs: {
      todayButtonClick: "todayButtonClick",
      prevButtonClick: "prevButtonClick",
      nextButtonClick: "nextButtonClick"
    },
    features: [ɵɵNgOnChangesFeature],
    decls: 2,
    vars: 1,
    consts: [[3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["kendoButton", "", "role", "button", "type", "button", "fillMode", "flat", "themeColor", "primary", "tabindex", "-1", 1, "k-calendar-title", 3, "id", "size", "disabled", "kendoEventsOutsideAngular", "title", "scope"], [1, "k-spacer"], [1, "k-calendar-nav"], ["kendoButton", "", "fillMode", "flat", "icon", "chevron-left", "tabindex", "-1", "type", "button", 1, "k-calendar-nav-prev", 3, "size", "svgIcon", "disabled", "title"], ["kendoButton", "", "fillMode", "flat", "role", "link", "type", "button", 1, "k-calendar-nav-today", 3, "size", "disabled", "kendoEventsOutsideAngular", "scope"], ["kendoButton", "", "fillMode", "flat", "icon", "chevron-right", "tabindex", "-1", "type", "button", 1, "k-calendar-nav-next", 3, "size", "svgIcon", "disabled", "title"], ["kendoButton", "", "fillMode", "flat", "icon", "chevron-left", "tabindex", "-1", "type", "button", 1, "k-calendar-nav-prev", 3, "click", "size", "svgIcon", "disabled", "title"], ["kendoButton", "", "fillMode", "flat", "icon", "chevron-right", "tabindex", "-1", "type", "button", 1, "k-calendar-nav-next", 3, "click", "size", "svgIcon", "disabled", "title"]],
    template: function HeaderComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵconditionalCreate(0, HeaderComponent_Conditional_0_Template, 1, 6, null, 0)(1, HeaderComponent_Conditional_1_Template, 9, 19);
      }
      if (rf & 2) {
        ɵɵconditional(ctx.headerTemplateRef ? 0 : 1);
      }
    },
    dependencies: [NgTemplateOutlet, ButtonComponent, EventsOutsideAngularDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HeaderComponent, [{
    type: Component,
    args: [{
      selector: "kendo-calendar-header",
      template: `
    @if (headerTemplateRef) {
      <ng-template
        [ngTemplateOutlet]="headerTemplateRef"
        [ngTemplateOutletContext]="{ title: title, activeView: activeViewValue, date: currentDate }">
      </ng-template>
    } @else {
      <button
        kendoButton
        class="k-calendar-title"
        role="button"
        [id]="id"
        type="button"
        fillMode="flat"
        [size]="size"
        themeColor="primary"
        tabindex="-1"
        [disabled]="!navigate"
            [kendoEventsOutsideAngular]="{
                click: handleNavigation
            }"
        [title]="parentViewButtonTitle"
        [scope]="this">
        @if (!titleTemplateRef) {
          {{title}}
        }
        @if (titleTemplateRef) {
          <ng-template
            [ngTemplateOutlet]="titleTemplateRef"
            [ngTemplateOutletContext]="{ $implicit: title, activeView: activeViewValue, date: currentDate }"
          ></ng-template>
        }
      </button>
      <span class="k-spacer"></span>
      <span class="k-calendar-nav">
        @if (showNavigationButtons) {
          <button
            kendoButton
            fillMode="flat"
            [size]="size"
            [svgIcon]="chevronLeftIcon"
            icon="chevron-left"
            tabindex="-1"
            type="button"
            class="k-calendar-nav-prev"
            [attr.aria-disabled]="isPrevDisabled"
            [disabled]="isPrevDisabled"
            [title]="prevButtonTitle"
            (click)="prevButtonClick.emit()"
            >
          </button>
        }
        <button
          kendoButton
          class="k-calendar-nav-today"
          fillMode="flat"
          role="link"
          [size]="size"
          [disabled]="!todayAvailable"
                [kendoEventsOutsideAngular]="{
                    click: handleTodayClick
                }"
          [scope]="this"
          type="button"
          >
          {{ todayMessage }}
        </button>
        @if (showNavigationButtons) {
          <button
            kendoButton
            fillMode="flat"
            [size]="size"
            [svgIcon]="chevronRightIcon"
            icon="chevron-right"
            class="k-calendar-nav-next"
            tabindex="-1"
            type="button"
            [attr.aria-disabled]="isNextDisabled"
            [disabled]="isNextDisabled"
            [title]="nextButtonTitle"
            (click)="nextButtonClick.emit()"
            >
          </button>
        }
      </span>
    }
    `,
      standalone: true,
      imports: [NgTemplateOutlet, ButtonComponent, EventsOutsideAngularDirective]
    }]
  }], () => [{
    type: BusViewService
  }, {
    type: ChangeDetectorRef
  }, {
    type: LocalizationService
  }, {
    type: IntlService
  }, {
    type: DisabledDatesService
  }], {
    activeView: [{
      type: Input
    }],
    currentDate: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    rangeLength: [{
      type: Input
    }],
    titleTemplateRef: [{
      type: Input
    }],
    headerTemplateRef: [{
      type: Input
    }],
    isPrevDisabled: [{
      type: Input
    }],
    isNextDisabled: [{
      type: Input
    }],
    showNavigationButtons: [{
      type: Input
    }],
    orientation: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    todayButtonClick: [{
      type: Output
    }],
    prevButtonClick: [{
      type: Output
    }],
    nextButtonClick: [{
      type: Output
    }],
    getComponentClass: [{
      type: HostBinding,
      args: ["class.k-calendar-header"]
    }],
    verticalHostClass: [{
      type: HostBinding,
      args: ["class.k-vstack"]
    }]
  });
})();
var SelectionService = class _SelectionService {
  bus;
  constructor(bus) {
    this.bus = bus;
  }
  lastClicked;
  performSelection(args) {
    let {
      date,
      modifiers,
      selectionMode,
      activeViewEnum,
      rangePivot
    } = args;
    let selectedDates = args.selectedDates.slice();
    if (selectionMode === "multiple") {
      if (modifiers.ctrlKey || modifiers.metaKey) {
        if (this.isDateSelected(selectedDates, date)) {
          selectedDates = selectedDates.filter((item) => !isEqual(item, date));
        } else {
          selectedDates.push(date);
        }
        rangePivot = date;
      } else if (modifiers.shiftKey) {
        const [start, end] = sortDates([rangePivot || date, date]);
        selectedDates = this.bus.service(activeViewEnum).dateRange(start, end);
        rangePivot = date > selectedDates[0] ? selectedDates[0] : last(selectedDates);
        if (modifiers.anyArrow) {
          const [start2, end2] = sortDates([this.lastClicked || date, date]);
          selectedDates = this.bus.service(0).dateRange(start2, end2);
        }
      } else {
        selectedDates = [date];
        rangePivot = date;
      }
    } else {
      selectedDates = [date];
      rangePivot = date;
    }
    return {
      selectedDates,
      rangePivot
    };
  }
  isDateSelected(selectedDates, date) {
    return selectedDates.some((item) => isEqual(item, date));
  }
  static ɵfac = function SelectionService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SelectionService)(ɵɵinject(BusViewService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _SelectionService,
    factory: _SelectionService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectionService, [{
    type: Injectable
  }], () => [{
    type: BusViewService
  }], null);
})();
var CellTemplateDirective = class _CellTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function CellTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CellTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CellTemplateDirective,
    selectors: [["", "kendoCalendarCellTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CellTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoCalendarCellTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var MonthCellTemplateDirective = class _MonthCellTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function MonthCellTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MonthCellTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _MonthCellTemplateDirective,
    selectors: [["", "kendoCalendarMonthCellTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MonthCellTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoCalendarMonthCellTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var YearCellTemplateDirective = class _YearCellTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function YearCellTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _YearCellTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _YearCellTemplateDirective,
    selectors: [["", "kendoCalendarYearCellTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(YearCellTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoCalendarYearCellTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var DecadeCellTemplateDirective = class _DecadeCellTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function DecadeCellTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DecadeCellTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DecadeCellTemplateDirective,
    selectors: [["", "kendoCalendarDecadeCellTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DecadeCellTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoCalendarDecadeCellTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var CenturyCellTemplateDirective = class _CenturyCellTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function CenturyCellTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CenturyCellTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CenturyCellTemplateDirective,
    selectors: [["", "kendoCalendarCenturyCellTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CenturyCellTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoCalendarCenturyCellTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var WeekNumberCellTemplateDirective = class _WeekNumberCellTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function WeekNumberCellTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _WeekNumberCellTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _WeekNumberCellTemplateDirective,
    selectors: [["", "kendoCalendarWeekNumberCellTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(WeekNumberCellTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoCalendarWeekNumberCellTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var HeaderTitleTemplateDirective = class _HeaderTitleTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function HeaderTitleTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HeaderTitleTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _HeaderTitleTemplateDirective,
    selectors: [["", "kendoCalendarHeaderTitleTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HeaderTitleTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoCalendarHeaderTitleTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
function handleRangeSelection(date, selectionRange, activeRangeEnd, allowReverse = false) {
  if (activeRangeEnd === "start" && selectionRange.start?.getTime() === date?.getTime() && (allowReverse && !selectionRange.end || !allowReverse) || activeRangeEnd === "end" && selectionRange.end?.getTime() === date?.getTime()) {
    return {
      activeRangeEnd,
      selectionRange
    };
  }
  if (allowReverse) {
    if (activeRangeEnd === "start" && selectionRange.start?.getTime() !== date?.getTime()) {
      selectionRange.start = date;
      activeRangeEnd = "end";
    } else if (activeRangeEnd === "end" && selectionRange.end?.getTime() !== date?.getTime()) {
      selectionRange.end = date;
      activeRangeEnd = "start";
    }
  }
  if (!allowReverse) {
    if (activeRangeEnd === "start" && date > selectionRange.end || activeRangeEnd === "end" && date < selectionRange.start) {
      selectionRange = {
        start: date,
        end: null
      };
      activeRangeEnd = "end";
    } else if (activeRangeEnd === "start" && date <= selectionRange.end) {
      selectionRange.start = date;
      activeRangeEnd = "end";
    } else if (activeRangeEnd === "end" && date >= selectionRange.start && date.getTime() !== selectionRange.end?.getTime()) {
      selectionRange.end = date;
      activeRangeEnd = "start";
    }
  }
  return {
    activeRangeEnd,
    selectionRange
  };
}
var minValidator = (minValue) => {
  return (control) => {
    const err = {
      minError: {
        minValue,
        value: control.value
      }
    };
    if (!minValue || !control.value) {
      return null;
    }
    return control.value < minValue ? err : null;
  };
};
var maxValidator = (maxValue) => {
  return (control) => {
    const err = {
      maxError: {
        maxValue,
        value: control.value
      }
    };
    if (!maxValue || !control.value) {
      return null;
    }
    return control.value > maxValue ? err : null;
  };
};
var noop = () => null;
var disabledDatesRangeValidator = (isDateDisabled) => {
  if (!isPresent4(isDateDisabled)) {
    return noop;
  }
  return (selectedRange) => {
    const isRangeComplete = isPresent4(selectedRange) && isPresent4(selectedRange.start) && isPresent4(selectedRange.end);
    if (!isRangeComplete || selectedRange.start > selectedRange.end) {
      return null;
    }
    const disabledDates = disabledDatesInRange(selectedRange.start, selectedRange.end, isDateDisabled);
    const error = {
      disabledDatesInRange: disabledDates
    };
    return disabledDates.length ? error : null;
  };
};
var KEY_TO_ACTION = {
  "PageUp": Action.PrevView,
  "PageDown": Action.NextView,
  "End": Action.LastInView,
  "Home": Action.FirstInView,
  "ArrowLeft": Action.Left,
  "ArrowUp": Action.Up,
  "ArrowRight": Action.Right,
  "ArrowDown": Action.Down,
  "meta+ArrowUp": Action.UpperView,
  "meta+ArrowDown": Action.LowerView
};
var NavigationService = class _NavigationService {
  bus;
  constructor(bus) {
    this.bus = bus;
  }
  action(event) {
    const code = normalizeKeys(event);
    const action = `${event.ctrlKey || event.metaKey ? "meta+" : ""}${code}`;
    return KEY_TO_ACTION[action];
  }
  move(value2, action, activeView) {
    const service = this.bus.service(activeView);
    if (!service) {
      return value2;
    }
    if (action === Action.UpperView && this.bus.canMoveUp(activeView)) {
      this.bus.moveUp(activeView);
      return value2;
    }
    if (action === Action.LowerView && this.bus.canMoveDown(activeView)) {
      this.bus.moveDown(activeView);
      return value2;
    }
    return service.move(value2, action);
  }
  static ɵfac = function NavigationService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NavigationService)(ɵɵinject(BusViewService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _NavigationService,
    factory: _NavigationService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigationService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: BusViewService
  }], null);
})();
var HeaderTemplateDirective = class _HeaderTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function HeaderTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HeaderTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _HeaderTemplateDirective,
    selectors: [["", "kendoCalendarHeaderTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HeaderTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoCalendarHeaderTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var FooterTemplateDirective2 = class _FooterTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function FooterTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FooterTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FooterTemplateDirective,
    selectors: [["", "kendoCalendarFooterTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FooterTemplateDirective2, [{
    type: Directive,
    args: [{
      selector: "[kendoCalendarFooterTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var FooterComponent = class _FooterComponent {
  intl;
  showFooter = true;
  footerTemplateRef;
  activeViewValue;
  currentDate;
  getToday = getToday;
  constructor(intl) {
    this.intl = intl;
  }
  static ɵfac = function FooterComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FooterComponent)(ɵɵdirectiveInject(IntlService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _FooterComponent,
    selectors: [["kendo-calendar-footer"]],
    hostVars: 2,
    hostBindings: function FooterComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-calendar-footer", ctx.showFooter);
      }
    },
    inputs: {
      footerTemplateRef: "footerTemplateRef",
      activeViewValue: "activeViewValue",
      currentDate: "currentDate"
    },
    decls: 2,
    vars: 1,
    consts: [[3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["kendoButton", "", "fillMode", "flat", "themeColor", "primary", "type", "button", "tabindex", "-1", 1, "k-calendar-nav-today"]],
    template: function FooterComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵconditionalCreate(0, FooterComponent_Conditional_0_Template, 1, 5, null, 0)(1, FooterComponent_Conditional_1_Template, 2, 1, "button", 1);
      }
      if (rf & 2) {
        ɵɵconditional(ctx.footerTemplateRef ? 0 : 1);
      }
    },
    dependencies: [NgTemplateOutlet, ButtonComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FooterComponent, [{
    type: Component,
    args: [{
      selector: "kendo-calendar-footer",
      template: `
    @if (footerTemplateRef) {
      <ng-template
        [ngTemplateOutlet]="footerTemplateRef"
        [ngTemplateOutletContext]="{ activeView: activeViewValue, date: currentDate }">
      </ng-template>
    } @else {
      <button kendoButton
        fillMode="flat"
        themeColor="primary"
        class="k-calendar-nav-today"
        type="button"
        tabindex="-1">
        {{intl.formatDate(getToday(), 'D')}}
      </button>
    }
    `,
      standalone: true,
      imports: [NgTemplateOutlet, ButtonComponent]
    }]
  }], () => [{
    type: IntlService
  }], {
    showFooter: [{
      type: HostBinding,
      args: ["class.k-calendar-footer"]
    }],
    footerTemplateRef: [{
      type: Input
    }],
    activeViewValue: [{
      type: Input
    }],
    currentDate: [{
      type: Input
    }]
  });
})();
var Messages = class _Messages extends ComponentMessages {
  /**
   * The **Today** button text in the header of the MultiViewCalendar.
   */
  today;
  /**
   * The title of the **Prev** button in the header of the MultiViewCalendar.
   */
  prevButtonTitle;
  /**
   * The title of the **Next** button in the header of the MultiViewCalendar.
   */
  nextButtonTitle;
  /**
   * The title of the **Parent View** button in the header of the MultiViewCalendar.
   */
  parentViewButtonTitle;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵMessages_BaseFactory;
    return function Messages_Factory(__ngFactoryType__) {
      return (ɵMessages_BaseFactory || (ɵMessages_BaseFactory = ɵɵgetInheritedFactory(_Messages)))(__ngFactoryType__ || _Messages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _Messages,
    selectors: [["kendo-multiview-calendar-messages-base"]],
    inputs: {
      today: "today",
      prevButtonTitle: "prevButtonTitle",
      nextButtonTitle: "nextButtonTitle",
      parentViewButtonTitle: "parentViewButtonTitle"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Messages, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line
      selector: "kendo-multiview-calendar-messages-base"
    }]
  }], null, {
    today: [{
      type: Input
    }],
    prevButtonTitle: [{
      type: Input
    }],
    nextButtonTitle: [{
      type: Input
    }],
    parentViewButtonTitle: [{
      type: Input
    }]
  });
})();
var MultiViewCalendarLocalizedMessagesDirective = class _MultiViewCalendarLocalizedMessagesDirective extends Messages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function MultiViewCalendarLocalizedMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MultiViewCalendarLocalizedMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _MultiViewCalendarLocalizedMessagesDirective,
    selectors: [["", "kendoMultiViewCalendarLocalizedMessages", ""]],
    features: [ɵɵProvidersFeature([{
      provide: Messages,
      useExisting: forwardRef(() => _MultiViewCalendarLocalizedMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MultiViewCalendarLocalizedMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: Messages,
        useExisting: forwardRef(() => MultiViewCalendarLocalizedMessagesDirective)
      }],
      selector: "[kendoMultiViewCalendarLocalizedMessages]",
      standalone: true
    }]
  }], () => [{
    type: LocalizationService
  }], null);
})();
var BOTTOM_VIEW_DOC_LINK$1 = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-bottomview";
var TOP_VIEW_DOC_LINK$1 = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-topview";
var MIN_DOC_LINK$3 = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-min";
var MAX_DOC_LINK$3 = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-max";
var VALUE_DOC_LINK$5 = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/calendar/#toc-using-with-json";
var RANGE_CALENDAR_VALUE_ACCESSOR = {
  multi: true,
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => MultiViewCalendarComponent)
};
var RANGE_CALENDAR_RANGE_VALIDATORS = {
  multi: true,
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => MultiViewCalendarComponent)
};
var MultiViewCalendarComponent = class _MultiViewCalendarComponent {
  bus;
  element;
  navigator;
  renderer;
  cdr;
  zone;
  disabledDatesService;
  selectionService;
  /**
   * Shows days that fall outside the current month ([see example]({% slug viewoptions_multiviewcalendar %}#toc-displaying-other-month-days)).
   *
   * @default true
   */
  showOtherMonthDays = true;
  /**
   * @hidden
   *
   * Determines whether to display the calendar header.
   */
  showCalendarHeader = true;
  /**
   * @hidden
   *
   * TODO: Make visible when the Infinite Calendar is fixed to set properly the size option.
   * Sets the size of the component.
   *
   * The possible values are:
   * * `small`
   * * `medium` (Default)
   * * `large`
   * * `none`
   *
   */
  set size(size) {
    const newSize = size ? size : DEFAULT_SIZE;
    this.renderer.removeClass(this.element.nativeElement, getSizeClass("calendar", this.size));
    if (newSize !== "none") {
      this.renderer.addClass(this.element.nativeElement, getSizeClass("calendar", newSize));
    }
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  _size = DEFAULT_SIZE;
  /**
   * @hidden
   */
  id;
  /**
   * Specifies the focused date of the Calendar
   * ([see example]({% slug dates_multiviewcalendar %}#toc-focused-dates)).
   *
   * If the Calendar is outside the `min` or `max` range, the component normalizes the defined `focusedDate`.
   */
  set focusedDate(focusedDate) {
    this._focusedDate = focusedDate || getToday();
  }
  get focusedDate() {
    return this._focusedDate;
  }
  /**
   * Toggles the visibility of the footer.
   *
   * @default false
   */
  footer = false;
  /**
   * @hidden
   */
  get headerId() {
    return this.id + "header-";
  }
  /**
   * @hidden
   */
  get multiViewCalendarHeaderIdLabel() {
    return this.views >= 2 ? this.id + "header-" : null;
  }
  /**
  * @hidden
  */
  get calendarHeaderIdLabel() {
    return this.views === 1 ? this.id + "header-" : null;
  }
  /**
   * Specifies the minimum allowed date value
   *
   * @default 1970-01-01
   */
  set min(min) {
    this._min = min || new Date(MIN_DATE);
  }
  get min() {
    return this._min;
  }
  /**
   * Specifies the maximum allowed date value
   *
   * @default 2099-12-31
   */
  set max(max) {
    this._max = max || new Date(MAX_DATE);
  }
  get max() {
    return this._max;
  }
  /**
   * Determines whether the built-in `min` or `max` validators are enforced when validating a form.
   *
   * @default false
   */
  rangeValidation = false;
  /**
   * Determines whether the built-in validator for disabled
   * date ranges is enforced when validating a form
   * ([see example](slug:disabled_dates_multiviewcalendar)).
   *
   * @default false
   */
  disabledDatesRangeValidation = false;
  /**
   * Sets the Calendar selection mode
   * ([see example]({% slug selection_multiviewcalendar %})).
   * @default 'single'
   */
  set selection(_selection) {
    this.selectionSetter = true;
    this._selection = _selection;
  }
  get selection() {
    return this._selection;
  }
  _selection = "single";
  /**
   * Allows reverse selection when using `range` selection.
   * If `allowReverse` is set to `true`, the component skips the validation of whether the start date is after the end date.
   *
   * @default false
   */
  allowReverse = false;
  /**
   * Sets or gets the `value` property of the Calendar and defines the selected value of the component.
   *
   * > The `value` has to be a valid [JavaScript `Date`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date)
      instance when in `single` selection mode, an array of valid JavaScript Date instances when in `multiple` selection mode, or
      an object of type `SelectionRange` when in `range` selection mode.
   */
  set value(candidate) {
    this.valueSetter = true;
    this._value = candidate;
  }
  get value() {
    return this._value;
  }
  /**
   * Specifies whether the component is disabled
   * ([see example]({% slug disabled_multiviewcalendar %})).
   * To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_multiviewcalendar#toc-managing-the-multiviewcalendar-disabled-state-in-reactive-forms).
   *
   * @default false
   */
  disabled = false;
  /**
   * Specifies the `tabindex` property of the Calendar. Based on the
   * [HTML `tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) behavior,
   * it determines whether the component is focusable.
   *
   * @default 0
   */
  tabindex = 0;
  /**
   * @hidden
   */
  set tabIndex(tabIndex) {
    this.tabindex = tabIndex;
  }
  get tabIndex() {
    return this.tabindex;
  }
  /**
   * Specifies the format of the displayed week day names.
   *
   * @default 'short'
   */
  weekDaysFormat = "short";
  /**
   * @hidden
   */
  isActive = false;
  /**
   * Specifies the dates of the MultiViewCalendar that will be disabled
   * ([see example]({% slug disabled_dates_multiviewcalendar %})).
   */
  set disabledDates(value2) {
    this.disabledDatesService.initialize(value2);
  }
  /**
   * Specifies the active view that the Calendar initially renders.
   * By default, the active view is `month`.
   *
   * > You have to set `activeView` within the `topView`-`bottomView` range.
   *
   * @default month
   */
  activeView = CalendarViewEnum[CalendarViewEnum.month];
  /**
   * Specifies the bottommost view to which you can navigate.
   *
   * @default month
   */
  bottomView = CalendarViewEnum[CalendarViewEnum.month];
  /**
   * Specifies the topmost view to which you can navigate.
   *
   * @default century
   */
  topView = CalendarViewEnum[CalendarViewEnum.century];
  /**
   * Determines whether to display a header for every view (for example, the month name).
   *
   * @default false
   */
  showViewHeader = false;
  /**
   * Determines whether to enable animation when navigating to previous/next view.
   *
   * > This feature uses the [Web Animations API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API). In order to run the animation in browsers that do not support it, you need the `web-animations-js` polyfill.
   *
   * @default false
   */
  animateNavigation = false;
  /**
   * Specifies whether to display a week number column in the `month` view
   * ([see example]({% slug weeknumcolumn_multiviewcalendar %})).
   *
   * @default false
   */
  weekNumber = false;
  /**
   * Specifies which end of the defined selection range should be marked as active.
   *
   * > Value will be ignored if the selection range is undefined.
   * > If range selection is used then the default value is 'start'.
   */
  set activeRangeEnd(_activeRangeEnd) {
    this._activeRangeEnd = _activeRangeEnd;
  }
  get activeRangeEnd() {
    return this.selection === "range" && !this._activeRangeEnd ? "start" : this._activeRangeEnd;
  }
  /**
   * Specifies the `selectionRange` property and
   * defines the selection range of the component
   * ([see example](slug:selection_multiviewcalendar#toc-range-selection)).
   * > We recommend using the `value` property as it now supports `range` selection.
   */
  set selectionRange(range2) {
    this._selectionRange = range2;
    if (this.disabledDatesRangeValidation) {
      this.onValidatorChange();
    }
  }
  get selectionRange() {
    return this._selectionRange;
  }
  /**
   * Specifies the `views` property and
   * defines the number of rendered months.
   *
   * @default 2
   */
  views = 2;
  /**
   * Specifies the orientation of the MultiViewCalendar.
   *
   * The available values are:
   * * `horizontal` (default)
   * * `vertical`
   */
  orientation = "horizontal";
  /**
   * Fires when the active view is changed
   * ([see example](slug:events_multiviewcalendar)).
   */
  activeViewChange = new EventEmitter();
  /**
   * Fires when navigating in the currently active view
   * ([see example](slug:events_multiviewcalendar)).
   */
  navigate = new EventEmitter();
  /**
   * Fires when a view cell is entered
   * ([see example](slug:events_multiviewcalendar)).
   */
  cellEnter = new EventEmitter();
  /**
   * Fires when a view cell is leaved
   * ([see example](slug:events_multiviewcalendar)).
   */
  cellLeave = new EventEmitter();
  /**
   * Fires when the value is changed
   * ([see example](slug:events_multiviewcalendar)).
   */
  valueChange = new EventEmitter();
  /**
   * @hidden
   * Fires when the range selection changes.
   */
  rangeSelectionChange = new EventEmitter();
  /**
   * Fires each time the MultiViewCalendar gets blurred
   * ([see example](slug:events_multiviewcalendar)).
   */
  blurEvent = new EventEmitter();
  /**
   * Fires each time the MultiViewCalendar gets focused
   * ([see example](slug:events_multiviewcalendar)).
   */
  focusEvent = new EventEmitter();
  /**
   * @hidden
   */
  focusCalendar = new EventEmitter();
  /**
   * @hidden
   */
  onClosePopup = new EventEmitter();
  /**
   * @hidden
   */
  onTabPress = new EventEmitter();
  /**
   * @hidden
   */
  onShiftTabPress = new EventEmitter();
  /**
   * @hidden
   *
   * Queries the template for a cell template declaration.
   * Ignored if a `[cellTemplate]` value is explicitly provided.
   */
  cellTemplate;
  /**
   * @hidden
   *
   * Defines the template for each cell.
   * Takes precedence over nested templates in the KendoMultiViewCalendar tag.
   */
  set cellTemplateRef(template) {
    this._cellTemplateRef = template;
  }
  get cellTemplateRef() {
    return this._cellTemplateRef || this.cellTemplate;
  }
  /**
   * @hidden
   *
   * Queries the template for a month cell template declaration.
   * Ignored if a `[monthCellTemplate]` value is explicitly provided.
   */
  monthCellTemplate;
  /**
   * @hidden
   *
   * Defines the template for each month cell.
   * Takes precedence over nested templates in the KendoMultiViewCalendar tag.
   */
  set monthCellTemplateRef(template) {
    this._monthCellTemplateRef = template;
  }
  get monthCellTemplateRef() {
    return this._monthCellTemplateRef || this.monthCellTemplate;
  }
  /**
   * @hidden
   *
   * Queries the template for a year cell template declaration.
   * Ignored if a `[yearCellTemplate]` value is explicitly provided.
   */
  yearCellTemplate;
  /**
   * @hidden
   *
   * Defines the template for each year cell.
   * Takes precedence over nested templates in the KendoMultiViewCalendar tag.
   */
  set yearCellTemplateRef(template) {
    this._yearCellTemplateRef = template;
  }
  get yearCellTemplateRef() {
    return this._yearCellTemplateRef || this.yearCellTemplate;
  }
  /**
   * @hidden
   *
   * Queries the template for a decade cell template declaration.
   * Ignored if a `[decadeCellTemplate]` value is explicitly provided.
   */
  decadeCellTemplate;
  /**
   * @hidden
   *
   * Defines the template for each decade cell.
   * Takes precedence over nested templates in the KendoMultiViewCalendar tag.
   */
  set decadeCellTemplateRef(template) {
    this._decadeCellTemplateRef = template;
  }
  get decadeCellTemplateRef() {
    return this._decadeCellTemplateRef || this.decadeCellTemplate;
  }
  /**
   * @hidden
   *
   * Queries the template for a century cell template declaration.
   * Ignored if a `[centuryCellTemplate]` value is explicitly provided.
   */
  centuryCellTemplate;
  /**
   * @hidden
   *
   * Defines the template for each century cell.
   * Takes precedence over nested templates in the KendoMultiViewCalendar tag.
   */
  set centuryCellTemplateRef(template) {
    this._centuryCellTemplateRef = template;
  }
  get centuryCellTemplateRef() {
    return this._centuryCellTemplateRef || this.centuryCellTemplate;
  }
  /**
   * @hidden
   *
   * Queries the template for a week number cell template declaration.
   * Ignored if a `[weekNumberTemplate]` value is explicitly provided.
   */
  weekNumberTemplate;
  /**
   * @hidden
   *
   * Defines the template for the week cell.
   * Takes precedence over nested templates in the KendoMultiViewCalendar tag.
   */
  set weekNumberTemplateRef(template) {
    this._weekNumberTemplateRef = template;
  }
  get weekNumberTemplateRef() {
    return this._weekNumberTemplateRef || this.weekNumberTemplate;
  }
  /**
   * @hidden
   *
   * Queries the template for a header title template declaration.
   * Ignored if a `[headerTitleTemplate]` value is explicitly provided.
   */
  headerTitleTemplate;
  /**
   * @hidden
   *
   * Queries the template for a header template declaration.
   */
  headerTemplate;
  /**
   * @hidden
   *
   * Queries the template for a header template declaration.
   */
  footerTemplate;
  /**
   * @hidden
   *
   * Defines the template for the Calendar footer.
   * Takes precedence over nested templates in the KendoMultiViewCalendar tag.
   */
  set footerTemplateRef(template) {
    this._footerTemplateRef = template;
  }
  get footerTemplateRef() {
    return this._footerTemplateRef || this.footerTemplate;
  }
  /**
   * @hidden
   *
   * Defines the template for the header title.
   * Takes precedence over nested templates in the KendoMultiViewCalendar tag.
   */
  set headerTitleTemplateRef(template) {
    this._headerTitleTemplateRef = template;
  }
  get headerTitleTemplateRef() {
    return this._headerTitleTemplateRef || this.headerTitleTemplate;
  }
  /**
   * @hidden
   *
   * Defines the template for the Calendar header.
   * Takes precedence over nested templates in the KendoMultiViewCalendar tag.
   */
  set headerTemplateRef(template) {
    this._headerTemplateRef = template;
  }
  get headerTemplateRef() {
    return this._headerTemplateRef || this.headerTemplate;
  }
  headerElement;
  viewList;
  cellUID = guid();
  isHovered = false;
  activeDate;
  isPrevDisabled = true;
  isNextDisabled = true;
  prevView = Action.PrevView;
  nextView = Action.NextView;
  selectedDates = [];
  rangePivot;
  shouldHoverWhenNoStart = false;
  canHover = false;
  changes = {};
  valueSetter = false;
  selectionSetter = false;
  _min = new Date(MIN_DATE);
  _max = new Date(MAX_DATE);
  _focusedDate = getToday();
  _value;
  _selectionRange = {
    start: null,
    end: null
  };
  _activeRangeEnd;
  resolvedPromise = Promise.resolve();
  onControlChange = noop$2;
  onControlTouched = noop$2;
  onValidatorChange = noop$2;
  minValidateFn = noop$2;
  maxValidateFn = noop$2;
  disabledDatesRangeValidateFn = noop$2;
  subscriptions = new Subscription();
  _cellTemplateRef;
  _monthCellTemplateRef;
  _yearCellTemplateRef;
  _decadeCellTemplateRef;
  _centuryCellTemplateRef;
  _weekNumberTemplateRef;
  _headerTitleTemplateRef;
  _headerTemplateRef;
  _footerTemplateRef;
  get activeViewEnum() {
    const activeView = CalendarViewEnum[this.activeView];
    return activeView < this.bottomViewEnum ? this.bottomViewEnum : activeView;
  }
  get bottomViewEnum() {
    return CalendarViewEnum[this.bottomView];
  }
  get topViewEnum() {
    return CalendarViewEnum[this.topView];
  }
  get widgetId() {
    return this.views >= 2 ? this.id : null;
  }
  get ariaDisabled() {
    return this.disabled;
  }
  /**
   * @hidden
   */
  get ariaActivedescendant() {
    return this.cellUID + this.focusedDate.getTime();
  }
  /**
   * @hidden
   */
  handleFocusout(event) {
    const relatedTarget = event.relatedTarget;
    if (!this.element.nativeElement.contains(relatedTarget)) {
      const isClassicCalendar = this.views === 1;
      isClassicCalendar ? this.blurEvent.emit(event) : this.blurEvent.emit();
      this.onControlTouched();
    }
    this.isActive = false;
    this.isHovered = false;
  }
  /**
   * @hidden
   */
  handleFocus() {
    this.isActive = true;
    const isClassicCalendar = this.views === 1;
    isClassicCalendar ? this.focusCalendar.emit() : this.focusEvent.emit();
    this.focusEvent.emit();
  }
  /**
   * @hidden
   */
  handleMouseEnter() {
    this.isHovered = true;
  }
  /**
   * @hidden
   */
  handleMouseLeave() {
    this.isHovered = false;
    this.setRangeSelectionToValue();
  }
  /**
   * @hidden
   */
  handleMousedown(event) {
    event.preventDefault();
  }
  /**
   * @hidden
   */
  handleClick() {
    if (this.isActive) {
      return;
    }
    this.focus();
  }
  /**
   * @hidden
   */
  keydown(event) {
    const code = normalizeKeys(event);
    const arrowUpOrDownKeyPressed = [Keys.ArrowUp, Keys.ArrowDown].indexOf(code) !== -1;
    const ctrlKey = event.ctrlKey || event.metaKey;
    const onArrowRightAndControl = code === Keys.ArrowRight && ctrlKey;
    const onArrowLeftAndControl = code === Keys.ArrowLeft && ctrlKey;
    const onTKeyPress = code === Keys.KeyT;
    const onEnterKeyPress = code === Keys.Enter;
    const onArrowUpPress = code === Keys.ArrowUp;
    const altKey = event.altKey;
    const escKey = code === Keys.Escape;
    const tabKeyPress = code === Keys.Tab;
    const shiftKeyPress = event.shiftKey;
    if (onArrowRightAndControl) {
      event.preventDefault();
      this.navigateView(this.nextView);
      return;
    } else if (onArrowLeftAndControl) {
      event.preventDefault();
      this.navigateView(this.prevView);
      return;
    } else if (ctrlKey && arrowUpOrDownKeyPressed) {
      event.preventDefault();
    } else if (onTKeyPress) {
      this.focusedDate = getToday();
      this.bus.moveToBottom(this.activeViewEnum);
      this.updateButtonState();
      return;
    } else if (onEnterKeyPress) {
      if (this.selection !== "range") {
        this.selectionService.lastClicked = this.focusedDate;
        this.performSelection(this.focusedDate, event);
      } else {
        this.performRangeSelection(this.focusedDate);
      }
    }
    if (this.views >= 2) {
      if (escKey || altKey && onArrowUpPress) {
        this.onClosePopup.emit(event);
      } else if (tabKeyPress && shiftKeyPress) {
        this.onShiftTabPress.emit(event);
      } else if (tabKeyPress && !shiftKeyPress) {
        this.onTabPress.emit(event);
      }
    }
    const candidate = dateInRange(this.navigator.move(this.focusedDate, this.navigator.action(event), this.activeViewEnum), this.min, this.max);
    if (isEqual(this.focusedDate, candidate)) {
      return;
    }
    this.focusedDate = candidate;
    event.preventDefault();
    const isSameView = this.bus.service(this.activeViewEnum).isInArray(this.focusedDate, this.viewList.dates);
    if (!isSameView) {
      this.emitNavigate(this.focusedDate);
      this.updateButtonState();
    }
    if (isArrowWithShiftPressed(event) && this.selection !== "range") {
      event["anyArrow"] = true;
      this.performSelection(this.focusedDate, event);
    }
  }
  constructor(bus, element, navigator2, renderer, cdr, zone, disabledDatesService, selectionService) {
    this.bus = bus;
    this.element = element;
    this.navigator = navigator2;
    this.renderer = renderer;
    this.cdr = cdr;
    this.zone = zone;
    this.disabledDatesService = disabledDatesService;
    this.selectionService = selectionService;
    this.id = `kendo-multiviewcalendarid-${this.bus.calendarId}-`;
  }
  ngOnInit() {
    this.setClasses(this.element.nativeElement);
    this.subscriptions.add(this.bus.viewChanged.subscribe(({
      view: view2
    }) => {
      this.activeView = CalendarViewEnum[view2];
      this.activeViewChange.emit(this.activeView);
      this.cdr.detectChanges();
      this.updateButtonState();
    }));
  }
  ngOnChanges(changes) {
    this.changes = changes;
    this.verifyChanges();
    this.bus.configure(this.bottomViewEnum, this.topViewEnum);
  }
  ngDoCheck() {
    if (this.valueSetter || this.selectionSetter) {
      if (this.selection === "range" && (this.value?.start || this.value?.end) && this.focusedDate.getTime() !== this.value.start?.getTime() && this.focusedDate.getTime() !== this.value.end?.getTime()) {
        this.focusedDate = this.value.start || this.value.end || getToday();
      }
      this.setValue(this.value);
      this.valueSetter = false;
      this.selectionSetter = false;
    }
    if (hasExistingValue(this.changes, "focusedDate")) {
      const focusedDate = this.changes.focusedDate.currentValue;
      this.focusedDate = dateInRange(focusedDate, this.min, this.max);
    }
    if (this.changes.min || this.changes.max || this.changes.rangeValidation || this.changes.disabledDates || this.changes.disabledDatesRangeValidation) {
      this.minValidateFn = this.rangeValidation ? minValidator(this.min) : noop$2;
      this.maxValidateFn = this.rangeValidation ? maxValidator(this.max) : noop$2;
      this.disabledDatesRangeValidateFn = this.disabledDatesRangeValidation ? disabledDatesRangeValidator(this.disabledDatesService.isDateDisabled) : noop$2;
      this.onValidatorChange();
    }
    if (this.changes.min || this.changes.max || this.changes.focusedDate || this.changes.activeView || this.changes.value) {
      this.updateButtonState();
    }
    this.changes = {};
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  ngAfterViewInit() {
    this.updateButtonState();
  }
  /**
   * Focuses the host element of the Calendar.
   *
   * @example
   * ```ts
   * _@Component({
   * selector: 'my-app',
   * template: `
   *  <button (click)="multiviewcalendar.focus()">Focus calendar</button>
   *  <kendo-multiviewcalendar #multiviewcalendar></kendo-multiviewcalendar>
   * `
   * })
   * export class AppComponent { }
   * ```
   */
  focus() {
    if (!this.element) {
      return;
    }
    this.element.nativeElement.querySelector(".k-calendar-view").focus({
      preventScroll: true
    });
  }
  /**
   * Blurs the Calendar component.
   */
  blur() {
    if (!this.element) {
      return;
    }
    const activeElement = this.views >= 2 ? this.element.nativeElement.querySelector(".k-calendar-view") : this.element.nativeElement.querySelector(".k-calendar-table");
    activeElement.blur();
  }
  /**
   * @hidden
   */
  handleDateChange(args) {
    const canNavigateDown = this.bus.canMoveDown(this.activeViewEnum);
    const availableDates = args.selectedDates.filter((date) => !this.disabledDatesService.isDateDisabled(date));
    this.focusedDate = args.focusedDate || this.focusedDate;
    const sameDates = !canNavigateDown && areDatesEqual(availableDates, this.selectedDates);
    if (sameDates && !canNavigateDown && this.selection === "single") {
      this.onClosePopup.emit();
    }
    if (this.disabled || sameDates) {
      return;
    }
    if (canNavigateDown) {
      this.bus.moveDown(this.activeViewEnum);
      return;
    }
    if (this.disabledDatesService.isDateDisabled(this.focusedDate)) {
      return;
    }
    if (this.selection === "range") {
      return;
    }
    this.selectedDates = availableDates.map((date) => cloneDate(date));
    this.value = this.parseSelectionToValue(availableDates);
    this.onControlChange(this.parseSelectionToValue(availableDates));
    this.valueChange.emit(this.parseSelectionToValue(availableDates));
  }
  /**
   * @hidden
   */
  onCellEnter(cellEnter, date) {
    this.emitCellEvent(cellEnter, date);
    if (this.selection === "range" && (this.canHover || this.shouldHoverWhenNoStart)) {
      this.zone.run(() => {
        if (this.canHover && !this.shouldHoverWhenNoStart) {
          if (this.allowReverse) {
            if (this.activeRangeEnd === "end" && this.selectionRange.start) {
              this.selectionRange = {
                start: this.selectionRange.start,
                end: date
              };
            }
            if (this.activeRangeEnd === "start" && this.selectionRange.end) {
              this.selectionRange = {
                start: date,
                end: this.selectionRange.end
              };
            }
          } else {
            if (this.activeRangeEnd === "end" && this.selectionRange.start && date >= this.selectionRange.start) {
              this.selectionRange = {
                start: this.selectionRange.start,
                end: date
              };
            }
            if (this.selectionRange.start && date < this.selectionRange.start) {
              this.selectionRange = {
                start: this.selectionRange.start,
                end: null
              };
            }
          }
        } else if (this.shouldHoverWhenNoStart && date <= this.selectionRange.end) {
          this.selectionRange = {
            start: date,
            end: this.selectionRange.end
          };
        } else {
          this.selectionRange = {
            start: null,
            end: this.selectionRange.end
          };
        }
      });
    }
  }
  /**
   * @hidden
   */
  handleTodayButtonClick(args) {
    const todayDate = args.focusedDate;
    const isSameView = this.bus.service(this.activeViewEnum).isInArray(todayDate, this.viewList.dates);
    const isBottomView = !this.bus.canMoveDown(this.activeViewEnum);
    if (!isSameView && isBottomView) {
      this.emitNavigate(todayDate);
      this.updateButtonState();
    }
    if (this.selection === "range" && isBottomView) {
      this.performRangeSelection(todayDate);
    } else {
      this.handleDateChange(args);
    }
  }
  /**
   * @hidden
   */
  setActiveDate(date) {
    this.activeDate = cloneDate(date);
    this.cdr.detectChanges();
  }
  /**
   * @hidden
   */
  writeValue(candidate) {
    this.verifyValue(candidate);
    this.value = candidate;
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.onControlChange = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.onControlTouched = fn;
  }
  /**
   * @hidden
   */
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  validate(control) {
    return this.minValidateFn(control) || this.maxValidateFn(control) || this.disabledDatesRangeValidateFn(this.selectionRange);
  }
  /**
   * @hidden
   */
  registerOnValidatorChange(fn) {
    this.onValidatorChange = fn;
  }
  /**
   * @hidden
   */
  activeCellTemplate() {
    switch (this.activeViewEnum) {
      case CalendarViewEnum.month:
        return this.monthCellTemplateRef || this.cellTemplateRef;
      case CalendarViewEnum.year:
        return this.yearCellTemplateRef;
      case CalendarViewEnum.decade:
        return this.decadeCellTemplateRef;
      case CalendarViewEnum.century:
        return this.centuryCellTemplateRef;
      default:
        return null;
    }
  }
  /**
   * @hidden
   */
  navigateView(action) {
    this.focusedDate = this.viewList.navigate(action);
    this.updateButtonState();
    this.emitNavigate(this.focusedDate);
  }
  /**
   * @hidden
   */
  emitNavigate(focusedDate) {
    const activeView = CalendarViewEnum[this.activeViewEnum];
    this.navigate.emit({
      activeView,
      focusedDate
    });
  }
  /**
   * @hidden
   */
  emitCellEvent(emitter, args) {
    if (hasObservers(emitter)) {
      this.zone.run(() => {
        emitter.emit(args);
      });
    }
  }
  /**
   * @hidden
   */
  handleCellClick({
    date,
    modifiers
  }) {
    if (this.selection === "range" && this.activeViewEnum === CalendarViewEnum[this.bottomView]) {
      this.performRangeSelection(date);
    } else {
      this.selectionService.lastClicked = date;
      this.performSelection(date, modifiers);
    }
    const isSameView = this.bus.service(this.activeViewEnum).isInArray(this.focusedDate, this.viewList.dates);
    if (!isSameView) {
      this.emitNavigate(this.focusedDate);
      this.updateButtonState();
    }
  }
  /**
   * @hidden
   */
  handleWeekNumberClick(dates) {
    if (this.selection === "single") {
      return;
    }
    this.zone.run(() => {
      if (this.selection === "multiple") {
        this.handleDateChange({
          selectedDates: dates,
          focusedDate: last(dates)
        });
      }
      if (this.selection === "range") {
        this.activeRangeEnd = "start";
        const shouldEmitValueChange = this.selectionRange.start?.getTime() !== dates[0].getTime() || this.selectionRange.end?.getTime() !== last(dates).getTime();
        this.selectionRange.start = dates[0];
        this.selectionRange.end = last(dates);
        this.value = this.selectionRange;
        if (shouldEmitValueChange) {
          this.valueChange.emit(this.value);
        }
      }
    });
  }
  setClasses(element) {
    this.renderer.addClass(element, "k-calendar");
    this.renderer.addClass(element, getSizeClass("calendar", this.size));
    if (this.views >= 2) {
      this.renderer.addClass(element, "k-calendar-range");
    }
  }
  verifyChanges() {
    if (!isDevMode()) {
      return;
    }
    if (this.min > this.max) {
      throw new Error(`The max value should be bigger than the min. See ${MIN_DOC_LINK$3} and ${MAX_DOC_LINK$3}.`);
    }
    if (this.bottomViewEnum > this.topViewEnum) {
      throw new Error(`The topView should be greater than bottomView. See ${BOTTOM_VIEW_DOC_LINK$1} and ${TOP_VIEW_DOC_LINK$1}.`);
    }
  }
  verifyValue(candidate) {
    if (!isDevMode()) {
      return;
    }
    if (this.selection === "single" && candidate && !isNullOrDate(candidate)) {
      throw new Error(`When using 'single' selection the 'value' should be a valid JavaScript Date instance. Check ${VALUE_DOC_LINK$5} for possible resolution.`);
    } else if (this.selection === "multiple" && candidate) {
      if (Array.isArray(candidate)) {
        const onlyDates = candidate.every((value2) => value2 instanceof Date);
        if (!onlyDates) {
          throw new Error(`When using 'multiple' selection the 'value' should be an array of valid JavaScript Date instances. Check ${VALUE_DOC_LINK$5} for possible resolution.`);
        }
      }
      if (Object.keys(candidate).find((k) => k === "start") && Object.keys(candidate).find((k) => k === "end")) {
        throw new Error(`When using 'multiple' selection the 'value' should be an array of valid JavaScript Date instances. Check ${VALUE_DOC_LINK$5} for possible resolution.`);
      }
    } else if (this.selection === "range" && candidate && !(isNullOrDate(candidate["start"]) && isNullOrDate(candidate["end"]))) {
      throw new Error(`The 'value' should be an object with start and end dates. Check ${VALUE_DOC_LINK$5} for possible resolution.`);
    }
  }
  updateButtonState() {
    this.resolvedPromise.then(() => {
      this.cdr.detectChanges();
      this.isPrevDisabled = !this.viewList.canNavigate(this.prevView);
      this.isNextDisabled = !this.viewList.canNavigate(this.nextView);
      this.cdr.markForCheck();
    });
  }
  parseSelectionToValue(selection) {
    selection = selection || [];
    return this.selection === "single" ? cloneDate(last(selection)) : selection.map((date) => cloneDate(date));
  }
  setValue(candidate) {
    this.verifyValue(candidate);
    if (candidate === null) {
      this._value = null;
      this.selectedDates = [];
    } else if (Array.isArray(candidate)) {
      this.selectionRange = {
        start: null,
        end: null
      };
      this._value = candidate.filter((date) => isPresent4(date)).map((element) => cloneDate(element));
    } else if (isObject(candidate) && Object.keys(candidate).find((k) => k === "start") && Object.keys(candidate).find((k) => k === "end")) {
      this.selectedDates = [];
      this.selectionRange = {
        start: null,
        end: null
      };
      this._value = {
        start: null,
        end: null
      };
      this._value.start = candidate.start instanceof Date ? cloneDate(candidate.start) : null;
      this._value.end = candidate.end instanceof Date ? cloneDate(candidate.end) : null;
      this.selectionRange = Object.assign({}, this._value);
      if (this._value?.start && !this._value?.end) {
        this.activeRangeEnd = "end";
        this.canHover = true;
      }
      if (this._value?.end && !this._value?.start) {
        this.activeRangeEnd = "start";
        this.canHover = true;
      }
      if (this._value?.end && this._value?.start) {
        this.canHover = false;
      }
    } else {
      this.selectionRange = {
        start: null,
        end: null
      };
      this._value = cloneDate(candidate);
    }
    if (this.selection !== "range") {
      const selection = [].concat(candidate).filter((date) => isPresent4(date)).map((date) => cloneDate(date));
      if (!areDatesEqual(selection, this.selectedDates)) {
        const lastSelected = last(selection);
        this.rangePivot = cloneDate(lastSelected);
        this.focusedDate = cloneDate(lastSelected) || this.focusedDate;
        this.selectedDates = selection;
      }
    }
  }
  setRangeSelectionToValue() {
    if (this.selection === "range" && this.value) {
      this.selectionRange = this.value;
      this.cdr.markForCheck();
    }
  }
  performRangeSelection(date) {
    this.focusedDate = date;
    const clonedRangeSelection = Object.assign({}, this.selectionRange);
    const emitValueChange = this.activeRangeEnd === "start" && this.value?.start?.getTime() !== date?.getTime() || this.activeRangeEnd === "end" && this.value?.end?.getTime() !== date?.getTime();
    this.zone.run(() => {
      const rangeSelection = handleRangeSelection(date, clonedRangeSelection, this.activeRangeEnd, this.allowReverse);
      this.activeRangeEnd = rangeSelection.activeRangeEnd;
      if (this.canHover && rangeSelection.activeRangeEnd === "end" && rangeSelection.selectionRange.end?.getTime() === date.getTime()) {
        this.activeRangeEnd = "start";
        rangeSelection.activeRangeEnd = "start";
      }
      this.canHover = this.activeRangeEnd === "end" && rangeSelection.selectionRange.start && !rangeSelection.selectionRange.end;
      if (emitValueChange && (this.value?.start?.getTime() !== rangeSelection.selectionRange?.start?.getTime() || this.value?.end?.getTime() !== rangeSelection.selectionRange?.end?.getTime())) {
        this.value = rangeSelection.selectionRange;
        this.valueChange.emit(this.value);
        this.rangeSelectionChange.emit(rangeSelection);
      }
      this.cdr.markForCheck();
    });
  }
  performSelection(date, selectionModifiers) {
    const selection = this.selectionService.performSelection({
      date,
      modifiers: selectionModifiers,
      selectionMode: this.selection,
      activeViewEnum: this.activeViewEnum,
      rangePivot: this.rangePivot,
      selectedDates: this.selectedDates
    });
    this.rangePivot = selection.rangePivot;
    this.handleDateChange({
      selectedDates: selection.selectedDates,
      focusedDate: date
    });
  }
  static ɵfac = function MultiViewCalendarComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MultiViewCalendarComponent)(ɵɵdirectiveInject(BusViewService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NavigationService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(DisabledDatesService), ɵɵdirectiveInject(SelectionService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _MultiViewCalendarComponent,
    selectors: [["kendo-multiviewcalendar"]],
    contentQueries: function MultiViewCalendarComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, CellTemplateDirective, 5)(dirIndex, MonthCellTemplateDirective, 5)(dirIndex, YearCellTemplateDirective, 5)(dirIndex, DecadeCellTemplateDirective, 5)(dirIndex, CenturyCellTemplateDirective, 5)(dirIndex, WeekNumberCellTemplateDirective, 5)(dirIndex, HeaderTitleTemplateDirective, 5)(dirIndex, HeaderTemplateDirective, 5)(dirIndex, FooterTemplateDirective2, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.cellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.monthCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.yearCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.decadeCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.centuryCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.weekNumberTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTitleTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
      }
    },
    viewQuery: function MultiViewCalendarComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(HeaderComponent, 5, ElementRef)(HorizontalViewListComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerElement = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.viewList = _t.first);
      }
    },
    hostVars: 4,
    hostBindings: function MultiViewCalendarComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("mouseenter", function MultiViewCalendarComponent_mouseenter_HostBindingHandler() {
          return ctx.handleMouseEnter();
        })("mouseleave", function MultiViewCalendarComponent_mouseleave_HostBindingHandler() {
          return ctx.handleMouseLeave();
        })("mousedown", function MultiViewCalendarComponent_mousedown_HostBindingHandler($event) {
          return ctx.handleMousedown($event);
        })("click", function MultiViewCalendarComponent_click_HostBindingHandler() {
          return ctx.handleClick();
        })("keydown", function MultiViewCalendarComponent_keydown_HostBindingHandler($event) {
          return ctx.keydown($event);
        });
      }
      if (rf & 2) {
        ɵɵattribute("id", ctx.widgetId)("aria-disabled", ctx.ariaDisabled);
        ɵɵclassProp("k-disabled", ctx.ariaDisabled);
      }
    },
    inputs: {
      showOtherMonthDays: "showOtherMonthDays",
      showCalendarHeader: "showCalendarHeader",
      size: "size",
      id: "id",
      focusedDate: "focusedDate",
      footer: "footer",
      min: "min",
      max: "max",
      rangeValidation: "rangeValidation",
      disabledDatesRangeValidation: "disabledDatesRangeValidation",
      selection: "selection",
      allowReverse: "allowReverse",
      value: "value",
      disabled: "disabled",
      tabindex: "tabindex",
      tabIndex: "tabIndex",
      weekDaysFormat: "weekDaysFormat",
      isActive: "isActive",
      disabledDates: "disabledDates",
      activeView: "activeView",
      bottomView: "bottomView",
      topView: "topView",
      showViewHeader: "showViewHeader",
      animateNavigation: "animateNavigation",
      weekNumber: "weekNumber",
      activeRangeEnd: "activeRangeEnd",
      selectionRange: "selectionRange",
      views: "views",
      orientation: "orientation",
      cellTemplateRef: [0, "cellTemplate", "cellTemplateRef"],
      monthCellTemplateRef: [0, "monthCellTemplate", "monthCellTemplateRef"],
      yearCellTemplateRef: [0, "yearCellTemplate", "yearCellTemplateRef"],
      decadeCellTemplateRef: [0, "decadeCellTemplate", "decadeCellTemplateRef"],
      centuryCellTemplateRef: [0, "centuryCellTemplate", "centuryCellTemplateRef"],
      weekNumberTemplateRef: [0, "weekNumberTemplate", "weekNumberTemplateRef"],
      footerTemplateRef: [0, "footerTemplate", "footerTemplateRef"],
      headerTitleTemplateRef: [0, "headerTitleTemplate", "headerTitleTemplateRef"],
      headerTemplateRef: [0, "headerTemplate", "headerTemplateRef"]
    },
    outputs: {
      activeViewChange: "activeViewChange",
      navigate: "navigate",
      cellEnter: "cellEnter",
      cellLeave: "cellLeave",
      valueChange: "valueChange",
      rangeSelectionChange: "rangeSelectionChange",
      blurEvent: "blur",
      focusEvent: "focus",
      focusCalendar: "focusCalendar",
      onClosePopup: "onClosePopup",
      onTabPress: "onTabPress",
      onShiftTabPress: "onShiftTabPress"
    },
    exportAs: ["kendo-multiviewcalendar"],
    features: [ɵɵProvidersFeature([BusViewService, RANGE_CALENDAR_VALUE_ACCESSOR, RANGE_CALENDAR_RANGE_VALIDATORS, LocalizationService, DisabledDatesService, {
      provide: L10N_PREFIX,
      useValue: "kendo.multiviewcalendar"
    }, NavigationService, SelectionService]), ɵɵNgOnChangesFeature],
    decls: 4,
    vars: 26,
    consts: () => {
      let i18n_0;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_0 = goog.getMsg("Today");
        i18n_0 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_0;
      } else {
        i18n_0 = $localize`:kendo.multiviewcalendar.today|The label for the today button in the calendar header:Today`;
      }
      let i18n_1;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_1 = goog.getMsg("Navigate to previous view");
        i18n_1 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_1;
      } else {
        i18n_1 = $localize`:kendo.multiviewcalendar.prevButtonTitle|The label for the previous button in the Multiview calendar:Navigate to previous view`;
      }
      let i18n_2;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_2 = goog.getMsg("Navigate to next view");
        i18n_2 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_2;
      } else {
        i18n_2 = $localize`:kendo.multiviewcalendar.nextButtonTitle|The label for the next button in the Multiview calendar:Navigate to next view`;
      }
      let i18n_3;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_3 = goog.getMsg("Navigate to parent view");
        i18n_3 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_3;
      } else {
        i18n_3 = $localize`:kendo.multiviewcalendar.parentViewButtonTitle|The title of the parent view button in the Multiview calendar header:Navigate to parent view`;
      }
      return [["kendoMultiViewCalendarLocalizedMessages", "", "today", i18n_0, "prevButtonTitle", i18n_1, "nextButtonTitle", i18n_2, "parentViewButtonTitle", i18n_3], [3, "activeView", "currentDate", "size", "min", "max", "id", "rangeLength", "titleTemplateRef", "headerTemplateRef", "isPrevDisabled", "isNextDisabled", "showNavigationButtons", "orientation"], [3, "cellClick", "weekNumberCellClick", "cellEnter", "cellLeave", "activeDateChange", "focusCalendar", "blurCalendar", "showOtherMonthDays", "allowReverse", "id", "activeView", "activeDescendant", "isActive", "cellTemplateRef", "weekNumberTemplateRef", "cellUID", "weekDaysFormat", "views", "min", "max", "focusedDate", "animateNavigation", "showViewHeader", "weekNumber", "activeRangeEnd", "selectionRange", "selectedDates", "orientation", "tabIndex", "disabled"], [3, "footerTemplateRef", "activeViewValue", "currentDate"], [3, "todayButtonClick", "prevButtonClick", "nextButtonClick", "activeView", "currentDate", "size", "min", "max", "id", "rangeLength", "titleTemplateRef", "headerTemplateRef", "isPrevDisabled", "isNextDisabled", "showNavigationButtons", "orientation"]];
    },
    template: function MultiViewCalendarComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainer(0, 0);
        ɵɵconditionalCreate(1, MultiViewCalendarComponent_Conditional_1_Template, 1, 13, "kendo-calendar-header", 1);
        ɵɵelementStart(2, "kendo-calendar-horizontal", 2);
        ɵɵlistener("cellClick", function MultiViewCalendarComponent_Template_kendo_calendar_horizontal_cellClick_2_listener($event) {
          return ctx.handleCellClick($event);
        })("weekNumberCellClick", function MultiViewCalendarComponent_Template_kendo_calendar_horizontal_weekNumberCellClick_2_listener($event) {
          return ctx.handleWeekNumberClick($event);
        })("cellEnter", function MultiViewCalendarComponent_Template_kendo_calendar_horizontal_cellEnter_2_listener($event) {
          return ctx.onCellEnter(ctx.cellEnter, $event);
        })("cellLeave", function MultiViewCalendarComponent_Template_kendo_calendar_horizontal_cellLeave_2_listener($event) {
          return ctx.emitCellEvent(ctx.cellLeave, $event);
        })("activeDateChange", function MultiViewCalendarComponent_Template_kendo_calendar_horizontal_activeDateChange_2_listener($event) {
          return ctx.setActiveDate($event);
        })("focusCalendar", function MultiViewCalendarComponent_Template_kendo_calendar_horizontal_focusCalendar_2_listener() {
          return ctx.handleFocus();
        })("blurCalendar", function MultiViewCalendarComponent_Template_kendo_calendar_horizontal_blurCalendar_2_listener($event) {
          return ctx.handleFocusout($event);
        });
        ɵɵelementEnd();
        ɵɵconditionalCreate(3, MultiViewCalendarComponent_Conditional_3_Template, 1, 3, "kendo-calendar-footer", 3);
      }
      if (rf & 2) {
        let tmp_7_0;
        ɵɵadvance();
        ɵɵconditional(ctx.showCalendarHeader ? 1 : -1);
        ɵɵadvance();
        ɵɵproperty("showOtherMonthDays", ctx.showOtherMonthDays)("allowReverse", ctx.allowReverse)("id", ctx.calendarHeaderIdLabel)("activeView", ctx.activeViewEnum)("activeDescendant", ctx.ariaActivedescendant)("isActive", ctx.isActive || ctx.isHovered)("cellTemplateRef", (tmp_7_0 = ctx.activeCellTemplate()) == null ? null : tmp_7_0.templateRef)("weekNumberTemplateRef", ctx.weekNumberTemplateRef == null ? null : ctx.weekNumberTemplateRef.templateRef)("cellUID", ctx.cellUID)("weekDaysFormat", ctx.weekDaysFormat)("views", ctx.views)("min", ctx.min)("max", ctx.max)("focusedDate", ctx.focusedDate)("animateNavigation", ctx.animateNavigation)("showViewHeader", ctx.showViewHeader)("weekNumber", ctx.weekNumber)("activeRangeEnd", ctx.activeRangeEnd)("selectionRange", ctx.selectionRange)("selectedDates", ctx.selectedDates)("orientation", ctx.orientation)("tabIndex", ctx.tabIndex)("disabled", ctx.disabled);
        ɵɵattribute("aria-labelledby", ctx.multiViewCalendarHeaderIdLabel);
        ɵɵadvance();
        ɵɵconditional(ctx.footer ? 3 : -1);
      }
    },
    dependencies: [MultiViewCalendarLocalizedMessagesDirective, HeaderComponent, HorizontalViewListComponent, FooterComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MultiViewCalendarComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      exportAs: "kendo-multiviewcalendar",
      providers: [BusViewService, RANGE_CALENDAR_VALUE_ACCESSOR, RANGE_CALENDAR_RANGE_VALIDATORS, LocalizationService, DisabledDatesService, {
        provide: L10N_PREFIX,
        useValue: "kendo.multiviewcalendar"
      }, NavigationService, SelectionService],
      selector: "kendo-multiviewcalendar",
      template: `
    <ng-container kendoMultiViewCalendarLocalizedMessages
      i18n-today="kendo.multiviewcalendar.today|The label for the today button in the calendar header"
      today="Today"
    
      i18n-prevButtonTitle="kendo.multiviewcalendar.prevButtonTitle|The label for the previous button in the Multiview calendar"
      prevButtonTitle="Navigate to previous view"
    
      i18n-nextButtonTitle="kendo.multiviewcalendar.nextButtonTitle|The label for the next button in the Multiview calendar"
      nextButtonTitle="Navigate to next view"
    
      i18n-parentViewButtonTitle="kendo.multiviewcalendar.parentViewButtonTitle|The title of the parent view button in the Multiview calendar header"
      parentViewButtonTitle="Navigate to parent view"
      >
    </ng-container>
    @if (showCalendarHeader) {
      <kendo-calendar-header
        [activeView]="activeViewEnum"
        [currentDate]="activeDate"
        [size]="size"
        [min]="min"
        [max]="max"
        [id]="headerId"
        [rangeLength]="views"
        [titleTemplateRef]="headerTitleTemplateRef?.templateRef"
        [headerTemplateRef]="headerTemplateRef?.templateRef"
        [isPrevDisabled]="isPrevDisabled"
        [isNextDisabled]="isNextDisabled"
        [showNavigationButtons]="true"
        [orientation]="orientation"
        (todayButtonClick)="handleTodayButtonClick({ selectedDates: [$event], focusedDate: $event })"
        (prevButtonClick)="navigateView(prevView)"
        (nextButtonClick)="navigateView(nextView)"
        >
      </kendo-calendar-header>
    }
    <kendo-calendar-horizontal
      [showOtherMonthDays]="showOtherMonthDays"
      [allowReverse]="allowReverse"
      [id]="calendarHeaderIdLabel"
      [attr.aria-labelledby]="multiViewCalendarHeaderIdLabel"
      [activeView]="activeViewEnum"
      [activeDescendant]="ariaActivedescendant"
      [isActive]="isActive || isHovered"
      [cellTemplateRef]="activeCellTemplate()?.templateRef"
      [weekNumberTemplateRef]="weekNumberTemplateRef?.templateRef"
      [cellUID]="cellUID"
      [weekDaysFormat]="weekDaysFormat"
      [views]="views"
      [min]="min"
      [max]="max"
      [focusedDate]="focusedDate"
      [animateNavigation]="animateNavigation"
      [showViewHeader]="showViewHeader"
      [weekNumber]="weekNumber"
      [activeRangeEnd]="activeRangeEnd"
      [selectionRange]="selectionRange"
      [selectedDates]="selectedDates"
      [orientation]="orientation"
      [tabIndex]="tabIndex"
      [disabled]="disabled"
      (cellClick)="handleCellClick($event)"
      (weekNumberCellClick)="handleWeekNumberClick($event)"
      (cellEnter)="onCellEnter(cellEnter, $event)"
      (cellLeave)="emitCellEvent(cellLeave, $event)"
      (activeDateChange)="setActiveDate($event)"
      (focusCalendar)="handleFocus()"
      (blurCalendar)="handleFocusout($event)"
      >
    </kendo-calendar-horizontal>
    @if (footer) {
      <kendo-calendar-footer
        [footerTemplateRef]="footerTemplateRef?.templateRef"
        [activeViewValue]="activeView"
        [currentDate]="activeDate">
      </kendo-calendar-footer>
    }
    `,
      standalone: true,
      imports: [MultiViewCalendarLocalizedMessagesDirective, HeaderComponent, HorizontalViewListComponent, FooterComponent]
    }]
  }], () => [{
    type: BusViewService
  }, {
    type: ElementRef
  }, {
    type: NavigationService
  }, {
    type: Renderer2
  }, {
    type: ChangeDetectorRef
  }, {
    type: NgZone
  }, {
    type: DisabledDatesService
  }, {
    type: SelectionService
  }], {
    showOtherMonthDays: [{
      type: Input
    }],
    showCalendarHeader: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    focusedDate: [{
      type: Input
    }],
    footer: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    rangeValidation: [{
      type: Input
    }],
    disabledDatesRangeValidation: [{
      type: Input
    }],
    selection: [{
      type: Input
    }],
    allowReverse: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    weekDaysFormat: [{
      type: Input
    }],
    isActive: [{
      type: Input
    }],
    disabledDates: [{
      type: Input
    }],
    activeView: [{
      type: Input
    }],
    bottomView: [{
      type: Input
    }],
    topView: [{
      type: Input
    }],
    showViewHeader: [{
      type: Input
    }],
    animateNavigation: [{
      type: Input
    }],
    weekNumber: [{
      type: Input
    }],
    activeRangeEnd: [{
      type: Input
    }],
    selectionRange: [{
      type: Input
    }],
    views: [{
      type: Input
    }],
    orientation: [{
      type: Input
    }],
    activeViewChange: [{
      type: Output
    }],
    navigate: [{
      type: Output
    }],
    cellEnter: [{
      type: Output
    }],
    cellLeave: [{
      type: Output
    }],
    valueChange: [{
      type: Output
    }],
    rangeSelectionChange: [{
      type: Output
    }],
    blurEvent: [{
      type: Output,
      args: ["blur"]
    }],
    focusEvent: [{
      type: Output,
      args: ["focus"]
    }],
    focusCalendar: [{
      type: Output
    }],
    onClosePopup: [{
      type: Output
    }],
    onTabPress: [{
      type: Output
    }],
    onShiftTabPress: [{
      type: Output
    }],
    cellTemplate: [{
      type: ContentChild,
      args: [CellTemplateDirective, {
        static: false
      }]
    }],
    cellTemplateRef: [{
      type: Input,
      args: ["cellTemplate"]
    }],
    monthCellTemplate: [{
      type: ContentChild,
      args: [MonthCellTemplateDirective, {
        static: false
      }]
    }],
    monthCellTemplateRef: [{
      type: Input,
      args: ["monthCellTemplate"]
    }],
    yearCellTemplate: [{
      type: ContentChild,
      args: [YearCellTemplateDirective, {
        static: false
      }]
    }],
    yearCellTemplateRef: [{
      type: Input,
      args: ["yearCellTemplate"]
    }],
    decadeCellTemplate: [{
      type: ContentChild,
      args: [DecadeCellTemplateDirective, {
        static: false
      }]
    }],
    decadeCellTemplateRef: [{
      type: Input,
      args: ["decadeCellTemplate"]
    }],
    centuryCellTemplate: [{
      type: ContentChild,
      args: [CenturyCellTemplateDirective, {
        static: false
      }]
    }],
    centuryCellTemplateRef: [{
      type: Input,
      args: ["centuryCellTemplate"]
    }],
    weekNumberTemplate: [{
      type: ContentChild,
      args: [WeekNumberCellTemplateDirective, {
        static: false
      }]
    }],
    weekNumberTemplateRef: [{
      type: Input,
      args: ["weekNumberTemplate"]
    }],
    headerTitleTemplate: [{
      type: ContentChild,
      args: [HeaderTitleTemplateDirective, {
        static: false
      }]
    }],
    headerTemplate: [{
      type: ContentChild,
      args: [HeaderTemplateDirective]
    }],
    footerTemplate: [{
      type: ContentChild,
      args: [FooterTemplateDirective2]
    }],
    footerTemplateRef: [{
      type: Input,
      args: ["footerTemplate"]
    }],
    headerTitleTemplateRef: [{
      type: Input,
      args: ["headerTitleTemplate"]
    }],
    headerTemplateRef: [{
      type: Input,
      args: ["headerTemplate"]
    }],
    headerElement: [{
      type: ViewChild,
      args: [HeaderComponent, {
        static: false,
        read: ElementRef
      }]
    }],
    viewList: [{
      type: ViewChild,
      args: [HorizontalViewListComponent, {
        static: false
      }]
    }],
    widgetId: [{
      type: HostBinding,
      args: ["attr.id"]
    }],
    ariaDisabled: [{
      type: HostBinding,
      args: ["attr.aria-disabled"]
    }, {
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    handleMouseEnter: [{
      type: HostListener,
      args: ["mouseenter"]
    }],
    handleMouseLeave: [{
      type: HostListener,
      args: ["mouseleave"]
    }],
    handleMousedown: [{
      type: HostListener,
      args: ["mousedown", ["$event"]]
    }],
    handleClick: [{
      type: HostListener,
      args: ["click"]
    }],
    keydown: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }]
  });
})();
var div$1 = domContainerFactory("div");
var ul$1 = domContainerFactory("ul");
var li$1 = domContainerFactory("li");
var td = domContainerFactory("td");
var th = domContainerFactory("th");
var tr = domContainerFactory("tr");
var tbody = domContainerFactory("tbody");
var thead = domContainerFactory("thead");
var table = domContainerFactory("table");
var monthHeader = () => div$1(`
            <span class="k-button k-button-md k-rounded-md k-button-flat k-button-flat-base k-calendar-title">March 2017</span>
            <span class="k-spacer"></span>
            <span class="k-calendar-nav">
                <button class="k-calendar-nav-today k-button k-button-md k-button-flat k-button-flat-base k-rounded-md">TODAY</button>
            </span>
        `, "k-calendar-header");
var monthWeekHeader = () => table([thead([tr([th("MO", "k-calendar-th")], "k-calendar-tr")], "k-calendar-thead")], "k-calendar-weekdays k-calendar-table");
var repeat = (count2, mapper) => new Array(count2).fill("1").map(mapper);
var content = (rows, cells = 1) => table([tbody([tr([th("1", "k-calendar-th")], "k-calendar-tr")].concat(repeat(rows, () => tr(repeat(cells, (c) => td(`<span class="k-link">${c}</span>`, "k-calendar-td")), "k-calendar-tr"))), "k-calendar-tbody")], "k-calendar-table");
var scrollable$1 = (children2) => div$1(children2, "k-flex k-content k-scrollable");
var view = (contentElement, className, renderWeekHeader) => div$1([monthHeader(), renderWeekHeader ? monthWeekHeader() : null, scrollable$1([contentElement, contentElement])], className, {
  left: "-10000px",
  position: "absolute"
});
var navigationList = /* @__PURE__ */ (() => {
  let navElement;
  return () => {
    if (!isDocumentAvailable()) {
      return null;
    }
    if (!navElement) {
      navElement = div$1([scrollable$1([ul$1([li$1("<span>FEB</span>")])])], "k-calendar-navigation", {
        left: "0px",
        position: "absolute"
      });
    }
    return navElement;
  };
})();
var viewFactory = ({
  cells,
  rows
}, className, renderWeekHeader) => {
  let viewElement;
  return () => {
    if (!isDocumentAvailable()) {
      return null;
    }
    if (!viewElement) {
      viewElement = view(content(rows, cells), className, renderWeekHeader);
    }
    return viewElement;
  };
};
var getScrollable = (element) => element.querySelector(".k-scrollable");
var horizontal = (element) => {
  const scrollableElement = getScrollable(element);
  scrollableElement.classList.add("k-scrollable-horizontal");
  return element;
};
var monthView = viewFactory({
  cells: 7,
  rows: 6
}, "k-vstack k-calendar-view k-calendar-monthview", true);
var yearView = viewFactory({
  cells: 4,
  rows: 3
}, "k-vstack k-calendar-view k-calendar-yearview", false);
var decadeView = viewFactory({
  cells: 4,
  rows: 3
}, "k-vstack k-calendar-view k-calendar-decadeview", false);
var horzMonthView = () => horizontal(monthView());
var horzYearView = () => horizontal(yearView());
var horzDecadeView = () => horizontal(decadeView());
var height = (element) => {
  if (!isDocumentAvailable()) {
    return element.offsetHeight || 0;
  }
  return parseFloat(window.getComputedStyle(element).height) || element.offsetHeight;
};
var width = (element) => {
  if (!isDocumentAvailable()) {
    return element.offsetWidth || 0;
  }
  const styles = window.getComputedStyle(element);
  const computed = parseFloat(styles.width) + parseFloat(styles.paddingLeft) + parseFloat(styles.paddingRight);
  return computed || element.offsetWidth;
};
var getBody = (element) => element.querySelector("tbody");
var CalendarDOMService = class _CalendarDOMService {
  //heights
  calendarHeight;
  headerHeight;
  monthViewHeight;
  yearViewHeight;
  decadeViewHeight;
  centuryViewHeight;
  navigationItemHeight;
  scrollableContentHeight;
  scrollableYearContentHeight;
  //widths
  calendarWidth;
  monthViewWidth;
  yearViewWidth;
  decadeViewWidth;
  centuryViewWidth;
  scrollableContentWidth;
  hostContainer;
  ensureHeights() {
    if (this.calendarHeight !== void 0) {
      return;
    }
    this.calculateHeights();
  }
  calculateHeights(container) {
    if (!isDocumentAvailable()) {
      return;
    }
    this.hostContainer = container;
    this.batch(monthView(), (contentElement) => {
      const viewElement = getBody(contentElement);
      this.calendarHeight = height(contentElement);
      this.monthViewHeight = height(viewElement);
      this.headerHeight = height(viewElement.children[0]);
      this.scrollableContentHeight = height(getScrollable(contentElement));
    });
    this.batch(horzMonthView(), (contentElement) => {
      const viewElement = getBody(contentElement);
      this.calendarWidth = width(contentElement);
      this.monthViewWidth = width(viewElement);
      this.scrollableContentWidth = width(getScrollable(contentElement));
    });
    this.batch(yearView(), (contentElement) => {
      this.yearViewHeight = height(getBody(contentElement));
      this.scrollableYearContentHeight = height(getScrollable(contentElement));
    });
    this.batch(horzYearView(), (contentElement) => {
      this.yearViewWidth = width(getBody(contentElement));
    });
    this.batch(decadeView(), (contentElement) => {
      this.decadeViewHeight = height(getBody(contentElement));
      this.centuryViewHeight = this.decadeViewHeight;
    });
    this.batch(horzDecadeView(), (contentElement) => {
      this.decadeViewWidth = width(getBody(contentElement));
      this.centuryViewWidth = this.decadeViewWidth;
    });
    this.batch(navigationList(), (contentElement) => {
      this.navigationItemHeight = height(contentElement.querySelector("li"));
    });
  }
  viewHeight(viewType) {
    return this.viewDimension(viewType, "height");
  }
  viewWidth(viewType) {
    return this.viewDimension(viewType, "width");
  }
  viewDimension(viewType, dimension) {
    const viewProp = dimension === "height" ? "ViewHeight" : "ViewWidth";
    switch (viewType) {
      case CalendarViewEnum.month:
        return this[`month${viewProp}`];
      case CalendarViewEnum.year:
        return this[`year${viewProp}`];
      case CalendarViewEnum.decade:
        return this[`decade${viewProp}`];
      case CalendarViewEnum.century:
        return this[`century${viewProp}`];
      default:
        return 1;
    }
  }
  batch(contentElement, action) {
    if (!isPresent4(this.hostContainer)) {
      return;
    }
    const hostClone = this.hostContainer.cloneNode();
    document.body.appendChild(hostClone);
    try {
      const appendedContent = hostClone.appendChild(contentElement);
      action(appendedContent);
    } finally {
      document.body.removeChild(hostClone);
    }
  }
  static ɵfac = function CalendarDOMService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CalendarDOMService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _CalendarDOMService,
    factory: _CalendarDOMService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarDOMService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var update = (arr, idx4, value2) => [...arr.slice(0, idx4 + 1), ...arr.slice(idx4 + 1).map((x) => x + value2)];
var RowHeightService = class {
  total;
  rowHeight;
  detailRowHeight;
  offsets = [];
  heights = [];
  constructor(total = 0, rowHeight, detailRowHeight) {
    this.total = total;
    this.rowHeight = rowHeight;
    this.detailRowHeight = detailRowHeight;
    let agg = 0;
    for (let idx4 = 0; idx4 < total; idx4++) {
      this.offsets.push(agg);
      agg += rowHeight;
      this.heights.push(rowHeight);
    }
  }
  height(rowIndex) {
    return this.heights[rowIndex];
  }
  expandDetail(rowIndex) {
    if (this.height(rowIndex) === this.rowHeight) {
      this.updateRowHeight(rowIndex, this.detailRowHeight);
    }
  }
  collapseDetail(rowIndex) {
    if (this.height(rowIndex) > this.rowHeight) {
      this.updateRowHeight(rowIndex, this.detailRowHeight * -1);
    }
  }
  index(position2) {
    if (position2 < 0) {
      return void 0;
    }
    const result = this.offsets.reduce((prev, current, idx4) => {
      if (prev !== void 0) {
        return prev;
      } else if (current === position2) {
        return idx4;
      } else if (current > position2) {
        return idx4 - 1;
      }
      return void 0;
    }, void 0);
    return result === void 0 ? this.total - 1 : result;
  }
  offset(rowIndex) {
    return this.offsets[rowIndex];
  }
  totalHeight() {
    return this.heights.reduce((prev, curr) => prev + curr, 0);
  }
  updateRowHeight(rowIndex, value2) {
    this.heights[rowIndex] += value2;
    this.offsets = update(this.offsets, rowIndex, value2);
  }
};
var normalize2 = (x) => Math.max(x, 0);
var ScrollAction = class {
  offset;
  constructor(offset3) {
    this.offset = offset3;
  }
};
var PageAction = class {
  skip;
  constructor(skip4) {
    this.skip = skip4;
  }
};
var ScrollerService = class {
  scrollObservable;
  direction;
  firstLoaded = 0;
  lastLoaded;
  lastScroll;
  take;
  total;
  rowHeightService;
  scrollSubscription;
  subscription;
  bottomOffset = 0;
  topOffset = 0;
  constructor(scrollObservable) {
    this.scrollObservable = scrollObservable;
  }
  create(rowHeightService, skip4, take4, total, topOffset = 0, bottomOffset = 0, direction = "vertical") {
    this.rowHeightService = rowHeightService;
    this.firstLoaded = skip4;
    this.lastLoaded = skip4 + take4;
    this.take = take4;
    this.total = total;
    this.lastScroll = 0;
    this.topOffset = topOffset;
    this.bottomOffset = bottomOffset;
    this.direction = direction;
    const subject = new ReplaySubject(2);
    const offsetBufferRows = this.rowsForHeight(topOffset);
    const skipWithOffset = normalize2(skip4 - offsetBufferRows);
    subject.next(new ScrollAction(this.rowOffset(skipWithOffset)));
    if (offsetBufferRows) {
      subject.next(new PageAction(skipWithOffset));
    }
    this.subscription = new Observable((observer) => {
      this.unsubscribe();
      this.scrollSubscription = this.scrollObservable.subscribe((x) => this.onScroll(x, observer));
    }).subscribe((x) => subject.next(x));
    return subject;
  }
  destroy() {
    this.unsubscribe();
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
  }
  onScroll({
    scrollLeft,
    scrollTop,
    offsetHeight,
    offsetWidth: offsetWidth2
  }, observer) {
    const scrollPosition = this.direction === "vertical" ? scrollTop : scrollLeft;
    const offsetSize = this.direction === "vertical" ? offsetHeight : offsetWidth2;
    if (this.lastScroll === scrollPosition) {
      return;
    }
    const up = this.lastScroll >= scrollPosition;
    this.lastScroll = scrollPosition;
    const firstItemIndex = this.rowHeightService.index(normalize2(scrollPosition - this.topOffset));
    const lastItemIndex = this.rowHeightService.index(normalize2(scrollPosition + offsetSize - this.bottomOffset));
    if (!up && lastItemIndex >= this.lastLoaded && this.lastLoaded < this.total) {
      this.firstLoaded = firstItemIndex;
      observer.next(new ScrollAction(this.rowOffset(firstItemIndex)));
      this.lastLoaded = Math.min(this.firstLoaded + this.take, this.total);
      observer.next(new PageAction(this.firstLoaded));
    }
    if (up && firstItemIndex <= this.firstLoaded) {
      const nonVisibleBuffer = Math.floor(this.take * 0.3);
      this.firstLoaded = normalize2(firstItemIndex - nonVisibleBuffer);
      observer.next(new ScrollAction(this.rowOffset(this.firstLoaded)));
      this.lastLoaded = Math.min(this.firstLoaded + this.take, this.total);
      observer.next(new PageAction(this.firstLoaded));
    }
  }
  rowOffset(index) {
    return this.rowHeightService.offset(index) + this.topOffset;
  }
  rowsForHeight(height2) {
    return Math.ceil(height2 / this.rowHeightService.height(0));
  }
  unsubscribe() {
    if (this.scrollSubscription) {
      this.scrollSubscription.unsubscribe();
      this.scrollSubscription = null;
    }
  }
};
var SCROLLER_FACTORY_TOKEN = new InjectionToken("dateinputs-scroll-service-factory");
function DEFAULT_SCROLLER_FACTORY(observable) {
  return new ScrollerService(observable);
}
var ScrollDirection;
(function(ScrollDirection2) {
  ScrollDirection2[ScrollDirection2["Backward"] = 0] = "Backward";
  ScrollDirection2[ScrollDirection2["Forward"] = 1] = "Forward";
})(ScrollDirection || (ScrollDirection = {}));
var FRAME_DURATION = 17;
var scrollModifiers = {
  [ScrollDirection.Forward]: (step) => (value2) => value2 + step,
  [ScrollDirection.Backward]: (step) => (value2) => value2 - step
};
var scrollNormalizers = {
  [ScrollDirection.Forward]: (end) => (value2) => Math.min(value2, end),
  [ScrollDirection.Backward]: (end) => (value2) => Math.max(value2, end)
};
var scrollValidators = {
  [ScrollDirection.Forward]: (end) => (start) => start < end,
  [ScrollDirection.Backward]: (end) => (start) => start > end
};
var differenceToScroll = (scrollTop, staticOffset, maxScrollDifference) => {
  return Math.min(Math.abs(staticOffset - scrollTop), maxScrollDifference);
};
var VirtualizationComponent = class _VirtualizationComponent {
  container;
  renderer;
  zone;
  scrollBarWidthService;
  direction = "vertical";
  itemHeight = 1;
  itemWidth = 1;
  topOffset = 0;
  bottomOffset = 0;
  maxScrollDifference = 100;
  scrollOffsetSize = 0;
  scrollDuration = 150;
  skip;
  take;
  total;
  activeIndexChange = new EventEmitter();
  pageChange = new EventEmitter();
  scrollChange = new EventEmitter();
  wrapperClasses = true;
  get horizontalClass() {
    return this.direction === "horizontal";
  }
  totalSize;
  get totalVertexLength() {
    const value2 = `${this.totalSize}px`;
    return this.direction === "vertical" ? {
      height: value2
    } : {
      width: value2
    };
  }
  get containerOffsetSize() {
    return this.getContainerProperty(this.direction === "vertical" ? "offsetHeight" : "offsetWidth");
  }
  get containerScrollSize() {
    return this.getContainerProperty(this.direction === "vertical" ? "scrollHeight" : "scrollWidth");
  }
  get containerScrollPosition() {
    return this.getContainerProperty(this.direction === "vertical" ? "scrollTop" : "scrollLeft");
  }
  lastActiveIndex;
  resolvedPromise = Promise.resolve(null);
  scroller;
  rowHeightService;
  dispatcher = new Subject();
  scrollSubscription;
  containerScrollSubscription;
  animationSubscription;
  constructor(scrollerFactory, container, renderer, zone, scrollBarWidthService) {
    this.container = container;
    this.renderer = renderer;
    this.zone = zone;
    this.scrollBarWidthService = scrollBarWidthService;
    this.scroller = scrollerFactory(this.dispatcher);
  }
  ngOnChanges(changes) {
    if (changes.direction || changes.take || changes.total) {
      this.initServices();
      this.totalSize = this.rowHeightService.totalHeight() + this.bottomOffset;
    }
  }
  ngOnInit() {
    if (!this.rowHeightService) {
      this.rowHeightService = this.createRowHeightService();
    }
  }
  ngAfterViewInit() {
    this.zone.runOutsideAngular(() => {
      this.containerScrollSubscription = this.scroll$().pipe(map((event) => event.target)).subscribe((t) => {
        this.dispatcher.next(t);
        this.emitActiveIndex();
      });
    });
  }
  ngOnDestroy() {
    if (this.containerScrollSubscription) {
      this.containerScrollSubscription.unsubscribe();
    }
    if (this.scrollSubscription) {
      this.scrollSubscription.unsubscribe();
    }
    if (this.animationSubscription) {
      this.animationSubscription.unsubscribe();
    }
  }
  getContainerProperty(propertyName) {
    return this.container.nativeElement[propertyName];
  }
  activeIndex() {
    return this.itemIndex(Math.ceil(this.containerScrollPosition));
  }
  itemIndex(offset3) {
    return this.rowHeightService.index(offset3);
  }
  itemOffset(index) {
    return this.rowHeightService.offset(index);
  }
  isIndexVisible(index) {
    if (!this.rowHeightService) {
      return false;
    }
    const containerTop = this.containerScrollPosition;
    const containerBottom = containerTop + this.containerOffsetSize;
    const top = this.rowHeightService.offset(index);
    const bottom = top + this.rowHeightService.height(index);
    return top >= containerTop && bottom <= containerBottom;
  }
  isListScrolled(index) {
    return this.containerScrollPosition !== this.rowHeightService.offset(index);
  }
  scrollTo(value2) {
    const scrollProperty = this.direction === "vertical" ? "scrollTop" : "scrollLeft";
    this.renderer.setProperty(this.container.nativeElement, scrollProperty, value2);
  }
  scrollToIndex(index) {
    this.zone.runOutsideAngular(() => {
      this.resolvedPromise.then(() => {
        this.scrollTo(this.rowHeightService.offset(index));
      });
    });
  }
  scrollToBottom() {
    this.scrollTo(this.totalSize);
  }
  animateToIndex(index) {
    if (this.animationSubscription) {
      this.animationSubscription.unsubscribe();
    }
    const indexOffset = this.rowHeightService.offset(index);
    const direction = this.getContainerScrollDirection(indexOffset);
    const {
      start,
      end
    } = this.scrollRange(indexOffset, direction);
    if (start === end) {
      return;
    }
    const step = this.scrollStep(start, end);
    const modifyScroll = scrollModifiers[direction](step);
    const normalizeScroll = scrollNormalizers[direction](end);
    const isScrollValid = scrollValidators[direction](modifyScroll(end));
    this.zone.runOutsideAngular(() => {
      this.animationSubscription = combineLatest(of(start), interval(0, animationFrameScheduler)).pipe(map((stream) => stream[0]), scan(modifyScroll), takeWhile(isScrollValid), map(normalizeScroll)).subscribe((x) => this.scrollTo(x));
    });
  }
  scrollRange(indexOffset, direction) {
    const containerScroll = this.containerScrollPosition;
    if (parseInt(indexOffset, 10) === parseInt(containerScroll, 10)) {
      return {
        start: indexOffset,
        end: indexOffset
      };
    }
    const maxScroll = this.containerMaxScroll();
    const sign = direction === ScrollDirection.Backward ? 1 : -1;
    const difference = differenceToScroll(containerScroll, indexOffset, this.maxScrollDifference);
    const end = Math.min(indexOffset, maxScroll);
    const start = Math.min(Math.max(end + sign * difference, 0), maxScroll);
    return {
      start,
      end
    };
  }
  scrollStep(start, end) {
    return Math.abs(end - start) / (this.scrollDuration / FRAME_DURATION);
  }
  scroll$() {
    return isDocumentAvailable() ? fromEvent(this.container.nativeElement, "scroll") : EMPTY;
  }
  initServices() {
    this.rowHeightService = this.createRowHeightService();
    if (this.scrollSubscription) {
      this.scrollSubscription.unsubscribe();
    }
    this.scrollSubscription = this.scroller.create(this.rowHeightService, this.skip, this.take, this.total, this.topOffset, this.scrollOffsetSize, this.direction).subscribe((x) => {
      if (x instanceof PageAction) {
        this.pageChange.emit(x);
      } else {
        this.scrollChange.emit(x);
      }
    });
  }
  createRowHeightService() {
    const dimension = this.direction === "vertical" ? this.itemHeight : this.itemWidth;
    return new RowHeightService(this.total, dimension, 0);
  }
  emitActiveIndex() {
    const index = this.rowHeightService.index(this.containerScrollPosition - this.topOffset);
    if (this.lastActiveIndex !== index) {
      this.lastActiveIndex = index;
      this.activeIndexChange.emit(index);
    }
  }
  containerMaxScroll() {
    return this.containerScrollSize - this.containerOffsetSize;
  }
  getContainerScrollDirection(indexOffset) {
    return indexOffset < this.containerScrollPosition ? ScrollDirection.Backward : ScrollDirection.Forward;
  }
  static ɵfac = function VirtualizationComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _VirtualizationComponent)(ɵɵdirectiveInject(SCROLLER_FACTORY_TOKEN), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ScrollbarWidthService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _VirtualizationComponent,
    selectors: [["kendo-virtualization"]],
    hostVars: 8,
    hostBindings: function VirtualizationComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-flex", ctx.wrapperClasses)("k-content", ctx.wrapperClasses)("k-scrollable", ctx.wrapperClasses)("k-scrollable-horizontal", ctx.horizontalClass);
      }
    },
    inputs: {
      direction: "direction",
      itemHeight: "itemHeight",
      itemWidth: "itemWidth",
      topOffset: "topOffset",
      bottomOffset: "bottomOffset",
      maxScrollDifference: "maxScrollDifference",
      scrollOffsetSize: "scrollOffsetSize",
      scrollDuration: "scrollDuration",
      skip: "skip",
      take: "take",
      total: "total"
    },
    outputs: {
      activeIndexChange: "activeIndexChange",
      pageChange: "pageChange",
      scrollChange: "scrollChange"
    },
    features: [ɵɵProvidersFeature([{
      provide: SCROLLER_FACTORY_TOKEN,
      useValue: DEFAULT_SCROLLER_FACTORY
    }]), ɵɵNgOnChangesFeature],
    ngContentSelectors: _c8,
    decls: 2,
    vars: 3,
    consts: [[1, "k-scrollable-placeholder", 3, "ngStyle"]],
    template: function VirtualizationComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
        ɵɵelement(1, "div", 0);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵclassProp("k-scrollable-horizontal-placeholder", ctx.direction === "horizontal");
        ɵɵproperty("ngStyle", ctx.totalVertexLength);
      }
    },
    dependencies: [NgStyle],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(VirtualizationComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: SCROLLER_FACTORY_TOKEN,
        useValue: DEFAULT_SCROLLER_FACTORY
      }],
      selector: "kendo-virtualization",
      template: `
    <ng-content></ng-content>
    <div
        class="k-scrollable-placeholder"
        [class.k-scrollable-horizontal-placeholder]="direction === 'horizontal'"
        [ngStyle]="totalVertexLength"
    ></div>
  `,
      standalone: true,
      imports: [NgStyle]
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [SCROLLER_FACTORY_TOKEN]
    }]
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: NgZone
  }, {
    type: ScrollbarWidthService
  }], {
    direction: [{
      type: Input
    }],
    itemHeight: [{
      type: Input
    }],
    itemWidth: [{
      type: Input
    }],
    topOffset: [{
      type: Input
    }],
    bottomOffset: [{
      type: Input
    }],
    maxScrollDifference: [{
      type: Input
    }],
    scrollOffsetSize: [{
      type: Input
    }],
    scrollDuration: [{
      type: Input
    }],
    skip: [{
      type: Input
    }],
    take: [{
      type: Input
    }],
    total: [{
      type: Input
    }],
    activeIndexChange: [{
      type: Output
    }],
    pageChange: [{
      type: Output
    }],
    scrollChange: [{
      type: Output
    }],
    wrapperClasses: [{
      type: HostBinding,
      args: ["class.k-flex"]
    }, {
      type: HostBinding,
      args: ["class.k-content"]
    }, {
      type: HostBinding,
      args: ["class.k-scrollable"]
    }],
    horizontalClass: [{
      type: HostBinding,
      args: ["class.k-scrollable-horizontal"]
    }]
  });
})();
var ITEMS_COUNT = 30;
var NavigationComponent = class _NavigationComponent {
  bus;
  dom;
  intl;
  cdr;
  renderer;
  activeView;
  min = new Date(MIN_DATE);
  max = new Date(MAX_DATE);
  focusedDate = /* @__PURE__ */ new Date();
  templateRef;
  valueChange = new EventEmitter();
  pageChange = new EventEmitter();
  virtualization;
  list;
  get getComponentClass() {
    return true;
  }
  activeViewValue;
  service;
  dates = [];
  style;
  take = ITEMS_COUNT;
  skip;
  total;
  itemHeight;
  topOffset;
  bottomOffset;
  maxViewHeight;
  indexToScroll = -1;
  intlSubscription;
  constructor(bus, dom, intl, cdr, renderer) {
    this.bus = bus;
    this.dom = dom;
    this.intl = intl;
    this.cdr = cdr;
    this.renderer = renderer;
  }
  ngOnInit() {
    this.dom.ensureHeights();
    const calendarHeight = this.dom.calendarHeight;
    this.itemHeight = this.dom.navigationItemHeight;
    this.maxViewHeight = this.dom.monthViewHeight;
    this.topOffset = (calendarHeight - this.itemHeight) / 2;
    this.bottomOffset = calendarHeight - this.itemHeight;
    this.intlSubscription = this.intl.changes.subscribe(this.intlChange.bind(this));
  }
  ngOnChanges(changes) {
    this.service = this.bus.service(this.activeView);
    if (!this.service) {
      return;
    }
    this.activeViewValue = CalendarViewEnum[this.activeView];
    const viewDate = dateInRange(this.focusedDate, this.min, this.max);
    const total = this.service.total(this.min, this.max);
    const totalChanged = this.total && this.total !== total;
    this.skip = this.service.skip(viewDate, this.min);
    this.total = total;
    if (totalChanged || !this.service.isInArray(viewDate, this.dates)) {
      this.dates = this.service.datesList(viewDate, this.getTake(this.skip));
    }
    if (!!changes.focusedDate || totalChanged) {
      this.indexToScroll = this.service.skip(this.focusedDate, this.min);
    }
  }
  ngOnDestroy() {
    if (this.intlSubscription) {
      this.intlSubscription.unsubscribe();
    }
  }
  ngAfterViewInit() {
    if (this.indexToScroll === -1) {
      return;
    }
    this.virtualization.scrollToIndex(this.indexToScroll);
    this.indexToScroll = -1;
  }
  ngAfterViewChecked() {
    if (this.indexToScroll === -1) {
      return;
    }
    this.virtualization.scrollToIndex(this.indexToScroll);
    this.indexToScroll = -1;
  }
  onPageChange({
    skip: skip4
  }) {
    this.dates = this.service.datesList(this.service.addToDate(this.min, skip4), this.getTake(skip4));
    this.pageChange.emit();
  }
  scrollChange({
    offset: offset3
  }) {
    const el = this.list.nativeElement;
    const translate = `translateY(${offset3}px)`;
    this.renderer.setStyle(el, "transform", translate);
    this.renderer.setStyle(el, "-ms-transform", translate);
  }
  handleDateChange(args) {
    const item = closestInScope2(args.target, (node) => node.hasAttribute("data-date-index"), this.list.nativeElement);
    if (item) {
      const index = parseInt(item.getAttribute("data-date-index"), 10);
      const candidate = this.dates[index];
      this.valueChange.emit(cloneDate(candidate));
    }
  }
  getTake(skip4) {
    return Math.min(this.total - skip4, this.take);
  }
  intlChange() {
    if (this.activeView === CalendarViewEnum.month) {
      this.cdr.markForCheck();
    }
  }
  static ɵfac = function NavigationComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NavigationComponent)(ɵɵdirectiveInject(BusViewService), ɵɵdirectiveInject(CalendarDOMService), ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _NavigationComponent,
    selectors: [["kendo-calendar-navigation"]],
    viewQuery: function NavigationComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(VirtualizationComponent, 5)(_c9, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.virtualization = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.list = _t.first);
      }
    },
    hostVars: 2,
    hostBindings: function NavigationComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-calendar-navigation", ctx.getComponentClass);
      }
    },
    inputs: {
      activeView: "activeView",
      min: "min",
      max: "max",
      focusedDate: "focusedDate",
      templateRef: "templateRef"
    },
    outputs: {
      valueChange: "valueChange",
      pageChange: "pageChange"
    },
    features: [ɵɵNgOnChangesFeature],
    decls: 5,
    vars: 12,
    consts: [["list", ""], [1, "k-calendar-navigation-highlight"], [3, "pageChange", "scrollChange", "skip", "take", "total", "itemHeight", "topOffset", "bottomOffset", "maxScrollDifference"], [1, "k-reset", 3, "kendoEventsOutsideAngular", "scope"], [4, "kFor", "kForOf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
    template: function NavigationComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelement(0, "span", 1);
        ɵɵelementStart(1, "kendo-virtualization", 2);
        ɵɵlistener("pageChange", function NavigationComponent_Template_kendo_virtualization_pageChange_1_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onPageChange($event));
        })("scrollChange", function NavigationComponent_Template_kendo_virtualization_scrollChange_1_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.scrollChange($event));
        });
        ɵɵelementStart(2, "ul", 3, 0);
        ɵɵtemplate(4, NavigationComponent_li_4_Template, 4, 5, "li", 4);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("skip", ctx.skip)("take", ctx.take)("total", ctx.total)("itemHeight", ctx.itemHeight)("topOffset", ctx.topOffset)("bottomOffset", ctx.bottomOffset)("maxScrollDifference", ctx.maxViewHeight);
        ɵɵadvance();
        ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction1(10, _c5, ctx.handleDateChange))("scope", ctx);
        ɵɵadvance(2);
        ɵɵproperty("kForOf", ctx.dates);
      }
    },
    dependencies: [VirtualizationComponent, EventsOutsideAngularDirective, KForOf, NgTemplateOutlet],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigationComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-calendar-navigation",
      template: `
    <span class="k-calendar-navigation-highlight"></span>
    <kendo-virtualization
      [skip]="skip"
      [take]="take"
      [total]="total"
      [itemHeight]="itemHeight"
      [topOffset]="topOffset"
      [bottomOffset]="bottomOffset"
      [maxScrollDifference]="maxViewHeight"
      (pageChange)="onPageChange($event)"
      (scrollChange)="scrollChange($event)"
      >
      <ul #list class="k-reset" [kendoEventsOutsideAngular]="{ click: handleDateChange }" [scope]="this">
        <li *kFor="let date of dates; let index=index" [attr.data-date-index]="index">
          <span [class.k-calendar-navigation-marker]="service.isRangeStart(date)">
            @if (!templateRef) {
              {{service.navigationTitle(date)}}
            }
            @if (templateRef) {
              <ng-template
                [ngTemplateOutlet]="templateRef"
                [ngTemplateOutletContext]="{ $implicit: service.navigationTitle(date), activeView: activeViewValue, date: date }"
              ></ng-template>
            }
          </span>
        </li>
      </ul>
    </kendo-virtualization>
    `,
      standalone: true,
      imports: [VirtualizationComponent, EventsOutsideAngularDirective, KForOf, NgTemplateOutlet]
    }]
  }], () => [{
    type: BusViewService
  }, {
    type: CalendarDOMService
  }, {
    type: IntlService
  }, {
    type: ChangeDetectorRef
  }, {
    type: Renderer2
  }], {
    activeView: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    focusedDate: [{
      type: Input
    }],
    templateRef: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    pageChange: [{
      type: Output
    }],
    virtualization: [{
      type: ViewChild,
      args: [VirtualizationComponent, {
        static: false
      }]
    }],
    list: [{
      type: ViewChild,
      args: ["list", {
        static: true
      }]
    }],
    getComponentClass: [{
      type: HostBinding,
      args: ["class.k-calendar-navigation"]
    }]
  });
})();
var VIEWS_COUNT = 5;
var isEqualMonthYear = (date1, date2) => date1 && date2 && date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth();
var ViewListComponent = class _ViewListComponent {
  bus;
  cdr;
  intl;
  dom;
  renderer;
  allowReverse;
  cellTemplateRef;
  weekNumberTemplateRef;
  headerTitleTemplateRef;
  headerTemplateRef;
  footerTemplateRef;
  showOtherMonthDays;
  activeView;
  cellUID;
  focusedDate;
  isActive = true;
  min = new Date(MIN_DATE);
  max = new Date(MAX_DATE);
  selectedDates = [];
  tabIndex = 0;
  disabled = false;
  id;
  showFooter = false;
  weekDaysFormat = "short";
  activeRangeEnd;
  selectionRange;
  size;
  get weekNumber() {
    return this.showWeekNumbers && this.isMonthView();
  }
  set weekNumber(showWeekNumbers) {
    this.showWeekNumbers = showWeekNumbers;
  }
  cellEnter = new EventEmitter();
  cellClick = new EventEmitter();
  weekNumberCellClick = new EventEmitter();
  activeDateChange = new EventEmitter();
  todayButtonClick = new EventEmitter();
  pageChange = new EventEmitter();
  focusCalendar = new EventEmitter();
  blurCalendar = new EventEmitter();
  focusedCellChange = new EventEmitter();
  virtualization;
  headerComponent;
  get headerTitle() {
    return this.headerComponent?.title;
  }
  list;
  getComponentClass = true;
  get getComponentMonthClass() {
    return this.activeView === CalendarViewEnum.month;
  }
  get getComponentYearClass() {
    return this.activeView === CalendarViewEnum.year;
  }
  get getComponentDecadeClass() {
    return this.activeView === CalendarViewEnum.decade;
  }
  get getComponentCenturyClass() {
    return this.activeView === CalendarViewEnum.century;
  }
  get activeViewValue() {
    return CalendarViewEnum[this.activeView];
  }
  service;
  activeDate;
  dates = [];
  cols = [];
  weekNames = [];
  wideWeekNames = [];
  take = VIEWS_COUNT;
  skip;
  total;
  bottomOffset;
  viewHeight;
  viewOffset;
  animateToIndex = true;
  indexToScroll = -1;
  showWeekNumbers;
  minViewsToRender = 1;
  intlSubscription;
  constructor(bus, cdr, intl, dom, renderer) {
    this.bus = bus;
    this.cdr = cdr;
    this.intl = intl;
    this.dom = dom;
    this.renderer = renderer;
  }
  ngOnInit() {
    this.weekNames = this.getWeekNames(this.weekDaysFormat);
    this.wideWeekNames = this.getWeekNames("wide");
    this.bottomOffset = this.getBottomOffset();
    this.viewOffset = -1 * this.dom.headerHeight;
    this.viewHeight = this.dom.viewHeight(this.activeView);
    this.intlSubscription = this.intl.changes.subscribe(this.intlChange.bind(this));
  }
  ngOnChanges(changes) {
    this.service = this.bus.service(this.activeView);
    if (!this.service) {
      return;
    }
    this.cols = new Array(this.service.rowLength({
      prependCell: this.weekNumber
    })).fill("");
    this.weekNames = hasChange(changes, "weekNumber") && this.weekNumber ? this.getWeekNames(this.weekDaysFormat) : this.weekNames;
    if (hasChange(changes, "weekDaysFormat") && !hasChange(changes, "weekNumber")) {
      this.weekNames = this.getWeekNames(this.weekDaysFormat);
    }
    this.wideWeekNames = hasChange(changes, "weekNumber") && this.weekNumber ? this.getWeekNames("wide") : this.weekNames;
    const activeViewChanged = hasChange(changes, "activeView");
    const focusedDate = this.focusedDate;
    const viewDate = dateInRange(this.service.viewDate(focusedDate, this.max, this.minViewsToRender), this.min, this.max);
    const total = this.service.total(this.min, this.max);
    const totalChanged = this.total && this.total !== total;
    const generateDates = totalChanged || !this.service.isInArray(focusedDate, this.dates);
    this.skip = this.service.skip(viewDate, this.min);
    this.total = total;
    this.animateToIndex = !activeViewChanged;
    this.bottomOffset = this.getBottomOffset();
    this.viewHeight = this.dom.viewHeight(this.activeView);
    if (generateDates) {
      this.dates = this.service.datesList(viewDate, this.getTake(this.skip));
    }
    if (!isEqualMonthYear(this.activeDate, focusedDate)) {
      this.activeDate = cloneDate(focusedDate);
    }
    const updateIndex = hasChange(changes, "focusedDate") || activeViewChanged;
    if (generateDates || updateIndex || this.virtualization.isIndexVisible(this.skip)) {
      this.indexToScroll = this.service.skip(focusedDate, this.min);
    }
  }
  ngOnDestroy() {
    if (this.intlSubscription) {
      this.intlSubscription.unsubscribe();
    }
  }
  ngAfterViewInit() {
    if (this.indexToScroll === -1) {
      return;
    }
    this.virtualization.scrollToIndex(this.indexToScroll);
    this.indexToScroll = -1;
  }
  ngAfterViewChecked() {
    if (this.indexToScroll === -1) {
      return;
    }
    this.virtualization[this.animateToIndex ? "animateToIndex" : "scrollToIndex"](this.indexToScroll);
    this.animateToIndex = true;
    this.indexToScroll = -1;
  }
  onPageChange({
    skip: skip4
  }) {
    this.dates = this.service.datesList(this.service.addToDate(this.min, skip4), this.getTake(skip4));
    this.pageChange.emit();
  }
  scrollChange({
    offset: offset3
  }) {
    const el = this.list.nativeElement;
    const translate = `translateY(${offset3}px)`;
    this.renderer.setStyle(el, "transform", translate);
    this.renderer.setStyle(el, "-ms-transform", translate);
  }
  setActiveDate(index) {
    const candidate = this.service.addToDate(this.min, index);
    this.activeDate = candidate;
    this.activeDateChange.emit(candidate);
    this.cdr.detectChanges();
  }
  isMonthView() {
    return this.activeView === CalendarViewEnum.month;
  }
  isScrolled() {
    return this.virtualization.isListScrolled(this.service.skip(this.focusedDate, this.min));
  }
  getTabIndex() {
    return this.disabled ? null : this.tabIndex;
  }
  getBottomOffset() {
    return this.getScrollableHeight() - this.dom.viewHeight(this.activeView);
  }
  getScrollableHeight() {
    return this.activeView === CalendarViewEnum.month ? this.dom.scrollableContentHeight : this.dom.scrollableYearContentHeight;
  }
  getTake(skip4) {
    return Math.min(this.total - skip4, this.take);
  }
  getWeekNames(nameType) {
    const weekNames = shiftWeekNames(this.intl.dateFormatNames({
      nameType,
      type: "days"
    }), this.intl.firstDay());
    return this.weekNumber ? [""].concat(weekNames) : weekNames;
  }
  intlChange() {
    this.weekNames = this.getWeekNames(this.weekDaysFormat);
    this.wideWeekNames = this.getWeekNames("wide");
    if (this.isMonthView()) {
      this.cdr.markForCheck();
    }
  }
  static ɵfac = function ViewListComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ViewListComponent)(ɵɵdirectiveInject(BusViewService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(CalendarDOMService), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ViewListComponent,
    selectors: [["kendo-calendar-viewlist"]],
    viewQuery: function ViewListComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(VirtualizationComponent, 5)(HeaderComponent, 5)(_c9, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.virtualization = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerComponent = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.list = _t.first);
      }
    },
    hostVars: 12,
    hostBindings: function ViewListComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-vstack", ctx.getComponentClass)("k-calendar-view", ctx.getComponentClass)("k-calendar-monthview", ctx.getComponentMonthClass)("k-calendar-yearview", ctx.getComponentYearClass)("k-calendar-decadeview", ctx.getComponentDecadeClass)("k-calendar-centuryview", ctx.getComponentCenturyClass);
      }
    },
    inputs: {
      allowReverse: "allowReverse",
      cellTemplateRef: "cellTemplateRef",
      weekNumberTemplateRef: "weekNumberTemplateRef",
      headerTitleTemplateRef: "headerTitleTemplateRef",
      headerTemplateRef: "headerTemplateRef",
      footerTemplateRef: "footerTemplateRef",
      showOtherMonthDays: "showOtherMonthDays",
      activeView: "activeView",
      cellUID: "cellUID",
      focusedDate: "focusedDate",
      isActive: "isActive",
      min: "min",
      max: "max",
      selectedDates: "selectedDates",
      tabIndex: "tabIndex",
      disabled: "disabled",
      id: "id",
      showFooter: "showFooter",
      weekDaysFormat: "weekDaysFormat",
      activeRangeEnd: "activeRangeEnd",
      selectionRange: "selectionRange",
      size: "size",
      weekNumber: "weekNumber"
    },
    outputs: {
      cellEnter: "cellEnter",
      cellClick: "cellClick",
      weekNumberCellClick: "weekNumberCellClick",
      activeDateChange: "activeDateChange",
      todayButtonClick: "todayButtonClick",
      pageChange: "pageChange",
      focusCalendar: "focusCalendar",
      blurCalendar: "blurCalendar",
      focusedCellChange: "focusedCellChange"
    },
    features: [ɵɵNgOnChangesFeature],
    decls: 10,
    vars: 22,
    consts: [["list", ""], [3, "todayButtonClick", "currentDate", "size", "min", "max", "id", "activeView", "titleTemplateRef", "headerTemplateRef"], [1, "k-calendar-weekdays", "k-calendar-table", 3, "table-layout"], [3, "pageChange", "scrollChange", "activeIndexChange", "tabindex", "skip", "take", "total", "itemHeight", "topOffset", "bottomOffset", "scrollOffsetSize", "maxScrollDifference"], ["role", "grid", 1, "k-calendar-table", 3, "focus", "blur"], ["class", "k-calendar-tbody", "kendoCalendarView", "", "role", "rowgroup", 3, "allowReverse", "activeRangeEnd", "selectionRange", "showOtherMonthDays", "headerTitle", "activeView", "isActive", "min", "max", "cellUID", "focusedDate", "selectedDates", "weekNumber", "templateRef", "weekNumberTemplateRef", "viewDate", "cellClick", "weekNumberCellClick", "focusedCellId", "cellEnter", 4, "kFor", "kForOf"], [3, "footerTemplateRef", "activeViewValue", "currentDate"], [1, "k-calendar-weekdays", "k-calendar-table"], [1, "k-calendar-thead"], [1, "k-calendar-tr"], ["scope", "col", "role", "columnheader", 1, "k-calendar-th"], ["kendoCalendarView", "", "role", "rowgroup", 1, "k-calendar-tbody", 3, "cellClick", "weekNumberCellClick", "focusedCellId", "cellEnter", "allowReverse", "activeRangeEnd", "selectionRange", "showOtherMonthDays", "headerTitle", "activeView", "isActive", "min", "max", "cellUID", "focusedDate", "selectedDates", "weekNumber", "templateRef", "weekNumberTemplateRef", "viewDate"]],
    template: function ViewListComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "kendo-calendar-header", 1);
        ɵɵlistener("todayButtonClick", function ViewListComponent_Template_kendo_calendar_header_todayButtonClick_0_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.todayButtonClick.emit($event));
        });
        ɵɵelementEnd();
        ɵɵconditionalCreate(1, ViewListComponent_Conditional_1_Template, 5, 2, "table", 2);
        ɵɵelementStart(2, "kendo-virtualization", 3);
        ɵɵlistener("pageChange", function ViewListComponent_Template_kendo_virtualization_pageChange_2_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onPageChange($event));
        })("scrollChange", function ViewListComponent_Template_kendo_virtualization_scrollChange_2_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.scrollChange($event));
        })("activeIndexChange", function ViewListComponent_Template_kendo_virtualization_activeIndexChange_2_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.setActiveDate($event));
        });
        ɵɵelementStart(3, "table", 4, 0);
        ɵɵlistener("focus", function ViewListComponent_Template_table_focus_3_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.focusCalendar.emit());
        })("blur", function ViewListComponent_Template_table_blur_3_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.blurCalendar.emit($event));
        });
        ɵɵelementStart(5, "colgroup");
        ɵɵrepeaterCreate(6, ViewListComponent_For_7_Template, 1, 0, "col", null, ɵɵrepeaterTrackByIndex);
        ɵɵelementEnd();
        ɵɵtemplate(8, ViewListComponent_tbody_8_Template, 1, 16, "tbody", 5);
        ɵɵelementEnd()();
        ɵɵconditionalCreate(9, ViewListComponent_Conditional_9_Template, 1, 3, "kendo-calendar-footer", 6);
      }
      if (rf & 2) {
        ɵɵproperty("currentDate", ctx.activeDate)("size", ctx.size)("min", ctx.min)("max", ctx.max)("id", ctx.id)("activeView", ctx.activeView)("titleTemplateRef", ctx.headerTitleTemplateRef)("headerTemplateRef", ctx.headerTemplateRef);
        ɵɵadvance();
        ɵɵconditional(ctx.isMonthView() ? 1 : -1);
        ɵɵadvance();
        ɵɵproperty("tabindex", -1)("skip", ctx.skip)("take", ctx.take)("total", ctx.total)("itemHeight", ctx.viewHeight)("topOffset", ctx.viewOffset)("bottomOffset", ctx.bottomOffset)("scrollOffsetSize", ctx.viewOffset)("maxScrollDifference", ctx.viewHeight);
        ɵɵadvance();
        ɵɵattribute("tabindex", ctx.getTabIndex())("aria-labelledby", ctx.id);
        ɵɵadvance(3);
        ɵɵrepeater(ctx.cols);
        ɵɵadvance(2);
        ɵɵproperty("kForOf", ctx.dates);
        ɵɵadvance();
        ɵɵconditional(ctx.showFooter ? 9 : -1);
      }
    },
    dependencies: [HeaderComponent, VirtualizationComponent, KForOf, ViewComponent, FooterComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ViewListComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-calendar-viewlist",
      template: `
    <kendo-calendar-header
      [currentDate]="activeDate"
      [size]="size"
      [min]="min"
      [max]="max"
      [id]="id"
      [activeView]="activeView"
      [titleTemplateRef]="headerTitleTemplateRef"
      [headerTemplateRef]="headerTemplateRef"
      (todayButtonClick)="todayButtonClick.emit($event)"
      >
    </kendo-calendar-header>
    @if (isMonthView()) {
      <table class="k-calendar-weekdays k-calendar-table" [style.table-layout]="'auto'">
        <thead class="k-calendar-thead">
          <tr class="k-calendar-tr">
            @for (name of weekNames; track $index; let i = $index) {
              <th class="k-calendar-th" scope="col" [attr.aria-label]="wideWeekNames[i]" role="columnheader">{{name}}</th>
            }
          </tr>
        </thead>
      </table>
    }
    <kendo-virtualization
      [tabindex]="-1"
      [skip]="skip"
      [take]="take"
      [total]="total"
      [itemHeight]="viewHeight"
      [topOffset]="viewOffset"
      [bottomOffset]="bottomOffset"
      [scrollOffsetSize]="viewOffset"
      [maxScrollDifference]="viewHeight"
      (pageChange)="onPageChange($event)"
      (scrollChange)="scrollChange($event)"
      (activeIndexChange)="setActiveDate($event)"
      >
      <table
        #list
        role="grid"
        class="k-calendar-table"
        [attr.tabindex]="getTabIndex()"
        [attr.aria-labelledby]="id"
        (focus)="focusCalendar.emit()"
        (blur)="blurCalendar.emit($event)"
        >
        <colgroup>@for (_ of cols; track $index) {
        <col />
      }</colgroup>

      <tbody class="k-calendar-tbody"
        *kFor="let date of dates"
        kendoCalendarView
        [allowReverse]="allowReverse"
        [activeRangeEnd]="activeRangeEnd"
        [selectionRange]="selectionRange"
        [showOtherMonthDays]="showOtherMonthDays"
        [headerTitle]="headerTitle"
        role="rowgroup"
        [activeView]="activeView"
        [isActive]="isActive"
        [min]="min" [max]="max"
        [cellUID]="cellUID"
        [focusedDate]="focusedDate"
        [selectedDates]="selectedDates"
        [weekNumber]="weekNumber"
        [templateRef]="cellTemplateRef"
        [weekNumberTemplateRef]="weekNumberTemplateRef"
        [viewDate]="date"
        (cellClick)="cellClick.emit($event)"
        (weekNumberCellClick)="weekNumberCellClick.emit($event)"
        (focusedCellId)="focusedCellChange.emit($event)"
        (cellEnter)="cellEnter.emit($event)"
      ></tbody>
    </table>
    </kendo-virtualization>
    @if (showFooter) {
      <kendo-calendar-footer
        [footerTemplateRef]="footerTemplateRef"
        [activeViewValue]="activeViewValue"
        [currentDate]="activeDate">
      </kendo-calendar-footer>
    }
    `,
      standalone: true,
      imports: [HeaderComponent, VirtualizationComponent, KForOf, ViewComponent, FooterComponent]
    }]
  }], () => [{
    type: BusViewService
  }, {
    type: ChangeDetectorRef
  }, {
    type: IntlService
  }, {
    type: CalendarDOMService
  }, {
    type: Renderer2
  }], {
    allowReverse: [{
      type: Input
    }],
    cellTemplateRef: [{
      type: Input
    }],
    weekNumberTemplateRef: [{
      type: Input
    }],
    headerTitleTemplateRef: [{
      type: Input
    }],
    headerTemplateRef: [{
      type: Input
    }],
    footerTemplateRef: [{
      type: Input
    }],
    showOtherMonthDays: [{
      type: Input
    }],
    activeView: [{
      type: Input
    }],
    cellUID: [{
      type: Input
    }],
    focusedDate: [{
      type: Input
    }],
    isActive: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    selectedDates: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    showFooter: [{
      type: Input
    }],
    weekDaysFormat: [{
      type: Input
    }],
    activeRangeEnd: [{
      type: Input
    }],
    selectionRange: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    weekNumber: [{
      type: Input
    }],
    cellEnter: [{
      type: Output
    }],
    cellClick: [{
      type: Output
    }],
    weekNumberCellClick: [{
      type: Output
    }],
    activeDateChange: [{
      type: Output
    }],
    todayButtonClick: [{
      type: Output
    }],
    pageChange: [{
      type: Output
    }],
    focusCalendar: [{
      type: Output
    }],
    blurCalendar: [{
      type: Output
    }],
    focusedCellChange: [{
      type: Output
    }],
    virtualization: [{
      type: ViewChild,
      args: [VirtualizationComponent, {
        static: false
      }]
    }],
    headerComponent: [{
      type: ViewChild,
      args: [HeaderComponent, {
        static: false
      }]
    }],
    list: [{
      type: ViewChild,
      args: ["list", {
        static: true
      }]
    }],
    getComponentClass: [{
      type: HostBinding,
      args: ["class.k-vstack"]
    }, {
      type: HostBinding,
      args: ["class.k-calendar-view"]
    }],
    getComponentMonthClass: [{
      type: HostBinding,
      args: ["class.k-calendar-monthview"]
    }],
    getComponentYearClass: [{
      type: HostBinding,
      args: ["class.k-calendar-yearview"]
    }],
    getComponentDecadeClass: [{
      type: HostBinding,
      args: ["class.k-calendar-decadeview"]
    }],
    getComponentCenturyClass: [{
      type: HostBinding,
      args: ["class.k-calendar-centuryview"]
    }]
  });
})();
var divideByMagnitude = (magnitude) => (x) => Math.floor(x / magnitude);
var powerByMagnitude = (magnitude) => (x) => x * magnitude;
var ScrollSyncService = class _ScrollSyncService {
  dom;
  zone;
  divideByMagnitude;
  powerByMagnitude;
  navSubscription;
  viewSubscription;
  navigator;
  view;
  constructor(dom, zone) {
    this.dom = dom;
    this.zone = zone;
  }
  configure(activeView) {
    const magnitude = Math.max(this.dom.viewHeight(activeView) / this.dom.navigationItemHeight, 1);
    this.divideByMagnitude = divideByMagnitude(magnitude);
    this.powerByMagnitude = powerByMagnitude(magnitude);
  }
  sync(navigator2, view2) {
    this.unsubscribe();
    if (!navigator2 || !view2) {
      return;
    }
    this.navigator = navigator2;
    this.view = view2;
    this.zone.runOutsideAngular(() => {
      let navScrolled, monthScrolled;
      this.navSubscription = navigator2.scroll$().subscribe((e) => {
        if (monthScrolled) {
          monthScrolled = false;
          return;
        }
        navScrolled = true;
        this.scrollSiblingOf(e.target);
      });
      this.viewSubscription = view2.scroll$().subscribe((e) => {
        if (navScrolled) {
          navScrolled = false;
          return;
        }
        monthScrolled = true;
        this.scrollSiblingOf(e.target);
      });
    });
  }
  scrollSiblingOf(scrolledElement) {
    const component = this.siblingComponent(scrolledElement);
    const scrollTop = this.calculateScroll(component, scrolledElement.scrollTop);
    component.scrollTo(scrollTop);
  }
  siblingComponent(scrollableElement) {
    return this.navigator.container.nativeElement === scrollableElement ? this.view : this.navigator;
  }
  calculateScroll(component, scrollTop) {
    const modifier = component === this.navigator ? this.divideByMagnitude : this.powerByMagnitude;
    return modifier(scrollTop);
  }
  destroy() {
    this.unsubscribe();
  }
  unsubscribe() {
    if (this.navSubscription) {
      this.navSubscription.unsubscribe();
    }
    if (this.viewSubscription) {
      this.viewSubscription.unsubscribe();
    }
  }
  static ɵfac = function ScrollSyncService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ScrollSyncService)(ɵɵinject(CalendarDOMService), ɵɵinject(NgZone));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ScrollSyncService,
    factory: _ScrollSyncService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollSyncService, [{
    type: Injectable
  }], () => [{
    type: CalendarDOMService
  }, {
    type: NgZone
  }], null);
})();
var NavigationItemTemplateDirective = class _NavigationItemTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function NavigationItemTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NavigationItemTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _NavigationItemTemplateDirective,
    selectors: [["", "kendoCalendarNavigationItemTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigationItemTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoCalendarNavigationItemTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var PickerService = class {
  onFocus = new EventEmitter();
  onBlur = new EventEmitter();
  sameDateSelected = new EventEmitter();
  dateCompletenessChange = new EventEmitter();
  calendar;
  input;
  timeSelector;
};
var MultiViewCalendarCustomMessagesComponent = class _MultiViewCalendarCustomMessagesComponent extends Messages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function MultiViewCalendarCustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MultiViewCalendarCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _MultiViewCalendarCustomMessagesComponent,
    selectors: [["kendo-multiviewcalendar-messages"]],
    features: [ɵɵProvidersFeature([{
      provide: Messages,
      useExisting: forwardRef(() => _MultiViewCalendarCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function MultiViewCalendarCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MultiViewCalendarCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: Messages,
        useExisting: forwardRef(() => MultiViewCalendarCustomMessagesComponent)
      }],
      selector: "kendo-multiviewcalendar-messages",
      template: ``,
      standalone: true
    }]
  }], () => [{
    type: LocalizationService
  }], null);
})();
var CalendarMessages = class _CalendarMessages extends ComponentMessages {
  /**
   * The **Today** button text in the header of the Calendar.
   */
  today;
  /**
   * The title of the **Prev** button in the header of the Classic Calendar.
   */
  prevButtonTitle;
  /**
   * The title of the **Next** button in the header of the Classic Calendar.
   */
  nextButtonTitle;
  /**
   * The title of the **Parent View** button in the header of the Calendar.
   */
  parentViewButtonTitle;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵCalendarMessages_BaseFactory;
    return function CalendarMessages_Factory(__ngFactoryType__) {
      return (ɵCalendarMessages_BaseFactory || (ɵCalendarMessages_BaseFactory = ɵɵgetInheritedFactory(_CalendarMessages)))(__ngFactoryType__ || _CalendarMessages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _CalendarMessages,
    selectors: [["kendo-calendar-messages-base"]],
    inputs: {
      today: "today",
      prevButtonTitle: "prevButtonTitle",
      nextButtonTitle: "nextButtonTitle",
      parentViewButtonTitle: "parentViewButtonTitle"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarMessages, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line
      selector: "kendo-calendar-messages-base"
    }]
  }], null, {
    today: [{
      type: Input
    }],
    prevButtonTitle: [{
      type: Input
    }],
    nextButtonTitle: [{
      type: Input
    }],
    parentViewButtonTitle: [{
      type: Input
    }]
  });
})();
var CalendarLocalizedMessagesDirective = class _CalendarLocalizedMessagesDirective extends CalendarMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function CalendarLocalizedMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CalendarLocalizedMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CalendarLocalizedMessagesDirective,
    selectors: [["", "kendoCalendarLocalizedMessages", ""]],
    features: [ɵɵProvidersFeature([{
      provide: CalendarMessages,
      useExisting: forwardRef(() => _CalendarLocalizedMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarLocalizedMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: CalendarMessages,
        useExisting: forwardRef(() => CalendarLocalizedMessagesDirective)
      }],
      selector: "[kendoCalendarLocalizedMessages]",
      standalone: true
    }]
  }], () => [{
    type: LocalizationService
  }], null);
})();
var BOTTOM_VIEW_DOC_LINK = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-bottomview";
var TOP_VIEW_DOC_LINK = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-topview";
var MIN_DOC_LINK$2 = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-min";
var MAX_DOC_LINK$2 = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-max";
var VALUE_DOC_LINK$4 = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/calendar/#toc-using-with-json";
var virtualizationProp = (x) => x ? x.virtualization : null;
var CALENDAR_VALUE_ACCESSOR = {
  multi: true,
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => CalendarComponent)
};
var CALENDAR_RANGE_VALIDATORS = {
  multi: true,
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => CalendarComponent)
};
var KENDO_INPUT_PROVIDER = {
  provide: KendoInput,
  useExisting: forwardRef(() => CalendarComponent)
};
var CalendarComponent = class _CalendarComponent {
  bus;
  dom;
  element;
  navigator;
  renderer;
  cdr;
  ngZone;
  injector;
  scrollSyncService;
  disabledDatesService;
  localization;
  selectionService;
  pickerService;
  /**
   * Shows days that fall outside the current month and the default values per Calendar type are false for infinite and true for classic ([see example]({% slug viewoptions_calendar %}#toc-displaying-other-month-days)).
   */
  set showOtherMonthDays(_showOtherMonthDays) {
    this._showOtherMonthDays = _showOtherMonthDays;
  }
  get showOtherMonthDays() {
    if (this._showOtherMonthDays === void 0) {
      return this.type === "classic";
    }
    return this._showOtherMonthDays;
  }
  _showOtherMonthDays;
  /**
   * @hidden
   */
  id;
  /**
   * @hidden
   */
  get popupId() {
    return `kendo-popup-${this.bus.calendarId}`;
  }
  /**
   * Specifies the focused date of the Calendar
   * ([see example]({% slug dates_calendar %}#toc-focused-dates)).
   *
   * If the Calendar is outside the `min` or `max` range, the component normalizes the defined `focusedDate`.
   */
  set focusedDate(focusedDate) {
    if (this.activeViewDate && !isEqual(this._focusedDate, focusedDate)) {
      const service = this.bus.service(this.activeViewEnum);
      const lastDayInPeriod = service.lastDayOfPeriod(this.activeViewDate);
      const isFocusedDateInRange = service.isInRange(focusedDate, this.activeViewDate, lastDayInPeriod);
      if (!isFocusedDateInRange) {
        this.emitNavigate(focusedDate);
      }
    }
    this._focusedDate = focusedDate || getToday();
    this.setAriaActivedescendant();
  }
  get focusedDate() {
    if (this._focusedDate > this.max) {
      return this.max;
    }
    if (this._focusedDate < this.min) {
      return this.min;
    }
    return this._focusedDate;
  }
  /**
   * @hidden
   */
  get headerId() {
    return this.id + "-header";
  }
  /**
   * Specifies the minimum allowed date value
   * ([see example]({% slug dateranges_calendar %})).
   *
   * @default 1900-1-1
   */
  set min(min) {
    this._min = min || new Date(MIN_DATE);
  }
  get min() {
    return this._min;
  }
  /**
   * Specifies the maximum allowed date value
   * ([see example]({% slug dateranges_calendar %})).
   *
   * @default 2099-12-31
   */
  set max(max) {
    this._max = max || new Date(MAX_DATE);
  }
  get max() {
    return this._max;
  }
  /**
   * Determines whether the built-in `min` or `max` validators are enforced when validating a form.
   *
   * @default false
   */
  rangeValidation = false;
  /**
   * Specifies the format of the displayed week day names.
   *
   * @default 'short'
   */
  weekDaysFormat = "short";
  /**
   * Toggles the visibility of the footer.
   *
   * @default false
   */
  footer = false;
  /**
   * Sets the Calendar selection mode
   * ([see example]({% slug selection_calendar %})).
   * @default 'single'
   */
  set selection(_selection) {
    this._selection = _selection;
    this.selectionSetter = true;
  }
  get selection() {
    return this._selection;
  }
  _selection = "single";
  /**
   * Allows reverse selection when using `range` selection.
   * If `allowReverse` is set to `true`, the component skips the validation of whether the start date is after the end date.
   *
   * @default false
   */
  allowReverse = false;
  /**
   * Sets or gets the `value` property of the Calendar and defines the selected value of the component.
   *
   * The `value` has to be a valid [JavaScript `Date`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date) instance when in `single` selection mode, an array of valid JavaScript Date instances when in `multiple` selection mode, or an object of type `SelectionRange` when in `range` selection mode.
   */
  set value(candidate) {
    this.valueSetter = true;
    this._value = candidate;
  }
  get value() {
    return this._value;
  }
  /**
   * Sets or gets the `disabled` property of the Calendar and
   * determines whether the component is active
   * ([see example]({% slug disabled_calendar %})).
   * To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_calendar#toc-managing-the-calendar-disabled-state-in-reactive-forms).
   */
  disabled = false;
  /**
   * Specifies the `tabindex` property of the Calendar. Based on the
   * [HTML `tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) behavior,
   * it determines whether the component is focusable.
   *
   * @default 0
   */
  tabindex = 0;
  /**
   * @hidden
   */
  set tabIndex(tabIndex) {
    this.tabindex = tabIndex;
  }
  get tabIndex() {
    return this.tabindex;
  }
  /**
   * Specifies the dates of the Calendar that will be disabled
   * ([see example]({% slug disabled_dates_calendar %})).
   */
  set disabledDates(value2) {
    this.disabledDatesService.initialize(value2);
    this._disabledDates = value2;
  }
  get disabledDates() {
    return this._disabledDates;
  }
  /**
   * Determines whether the navigation side-bar will be displayed
   * ([see example]({% slug sidebar_calendar %})).
   * Applies to the [`infinite`]({% slug api_dateinputs_calendarcomponent %}#toc-type) Calendar only.
   *
   * @default true
   */
  navigation = true;
  /**
   * Defines the active view that the Calendar initially renders
   * ([see example]({% slug viewoptions_calendar %})).
   * You have to set `activeView` within the `topView`-`bottomView` range.
   *
   * @default 'month'
   */
  activeView = CalendarViewEnum[CalendarViewEnum.month];
  /**
   * Defines the bottommost view to which the user can navigate
   * ([see example](slug:viewdepth_calendar)).
   *
   * @default 'month'
   */
  bottomView = CalendarViewEnum[CalendarViewEnum.month];
  /**
   * Defines the topmost view to which the user can navigate
   * ([see example](slug:viewdepth_calendar)).
   *
   * @default 'century'
   */
  topView = CalendarViewEnum[CalendarViewEnum.century];
  /**
   * Specifies the Calendar type.
   *
   * @default 'infinite'
   */
  set type(type) {
    this.renderer.removeClass(this.element.nativeElement, `k-calendar-${this.type}`);
    if (type === "infinite") {
      this.renderer.addClass(this.element.nativeElement, `k-calendar-${type}`);
    }
    this._type = type;
  }
  get type() {
    return this._type;
  }
  /**
   * Determines whether to enable animation when navigating to previous/next view.
   * Applies to the [`classic`]({% slug api_dateinputs_calendarcomponent %}#toc-type) Calendar only.
   *
   * This feature uses the [Web Animations API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API). In order to run the animation in browsers that do not support it, you need the `web-animations-js` polyfill.
   *
   * @default false
   */
  animateNavigation = false;
  /**
   * Determines whether to display a week number column in the `month` view
   * ([see example]({% slug weeknumcolumn_calendar %})).
   *
   * @default false
   */
  weekNumber = false;
  /**
   * @hidden
   */
  closePopup = new EventEmitter();
  /**
   * Fires when the active view is changed
   * ([see example](slug:events_calendar)).
   */
  activeViewChange = new EventEmitter();
  /**
   * Fires when navigating in the currently active view
   * ([see example](slug:events_calendar)).
   */
  navigate = new EventEmitter();
  /**
   * Fires when the active view date is changed
   * ([see example](slug:events_calendar)).
   * Applies to the [`infinite`]({% slug api_dateinputs_calendarcomponent %}#toc-type) Calendar only.
   */
  activeViewDateChange = new EventEmitter();
  /**
   * Fires each time the Calendar gets blurred
   * ([see example](slug:events_calendar)).
   */
  onBlur = new EventEmitter();
  /**
   * Fires each time the Calendar gets focused
   * ([see example](slug:events_calendar)).
   */
  onFocus = new EventEmitter();
  /**
   * Fires when the value is changed
   * ([see example](slug:events_calendar)).
   */
  valueChange = new EventEmitter();
  /**
   * @hidden
   *
   * Queries the template for a cell template declaration.
   * Ignored if a `[cellTemplate]` value is explicitly provided.
   */
  cellTemplate;
  /**
   * @hidden
   *
   * Defines the template for each cell.
   * Takes precedence over nested templates in the KendoCalendar tag.
   */
  set cellTemplateRef(template) {
    this._cellTemplateRef = template;
  }
  get cellTemplateRef() {
    return this._cellTemplateRef || this.cellTemplate;
  }
  /**
   * @hidden
   *
   * Queries the template for a month cell template declaration.
   * Ignored if a `[monthCellTemplate]` value is explicitly provided.
   */
  monthCellTemplate;
  /**
   * @hidden
   *
   * Defines the template for each month cell.
   * Takes precedence over nested templates in the KendoCalendar tag.
   */
  set monthCellTemplateRef(template) {
    this._monthCellTemplateRef = template;
  }
  get monthCellTemplateRef() {
    return this._monthCellTemplateRef || this.monthCellTemplate;
  }
  /**
   * @hidden
   *
   * Queries the template for a year cell template declaration.
   * Ignored if a `[yearCellTemplate]` value is explicitly provided.
   */
  yearCellTemplate;
  /**
   * @hidden
   *
   * Defines the template for each year cell.
   * Takes precedence over nested templates in the KendoCalendar tag.
   */
  set yearCellTemplateRef(template) {
    this._yearCellTemplateRef = template;
  }
  get yearCellTemplateRef() {
    return this._yearCellTemplateRef || this.yearCellTemplate;
  }
  /**
   * @hidden
   *
   * Queries the template for a decade cell template declaration.
   * Ignored if a `[decadeCellTemplate]` value is explicitly provided.
   */
  decadeCellTemplate;
  /**
   * @hidden
   *
   * Defines the template for each decade cell.
   * Takes precedence over nested templates in the KendoCalendar tag.
   */
  set decadeCellTemplateRef(template) {
    this._decadeCellTemplateRef = template;
  }
  get decadeCellTemplateRef() {
    return this._decadeCellTemplateRef || this.decadeCellTemplate;
  }
  /**
   * @hidden
   *
   * Queries the template for a century cell template declaration.
   * Ignored if a `[centuryCellTemplate]` value is explicitly provided.
   */
  centuryCellTemplate;
  /**
   * @hidden
   *
   * Defines the template for each century cell.
   * Takes precedence over nested templates in the KendoCalendar tag.
   */
  set centuryCellTemplateRef(template) {
    this._centuryCellTemplateRef = template;
  }
  get centuryCellTemplateRef() {
    return this._centuryCellTemplateRef || this.centuryCellTemplate;
  }
  /**
   * @hidden
   *
   * Queries the template for a week number cell template declaration.
   * Ignored if a `[weekNumberTemplate]` value is explicitly provided.
   */
  weekNumberTemplate;
  /**
   * @hidden
   *
   * Defines the template for the week cell.
   * Takes precedence over nested templates in the KendoCalendar tag.
   */
  set weekNumberTemplateRef(template) {
    this._weekNumberTemplateRef = template;
  }
  get weekNumberTemplateRef() {
    return this._weekNumberTemplateRef || this.weekNumberTemplate;
  }
  /**
   * @hidden
   *
   * Queries the template for a header title template declaration.
   * Ignored if a `[headerTitleTemplate]` value is explicitly provided.
   */
  headerTitleTemplate;
  /**
   * @hidden
   *
   * Queries the template for a header template declaration.
   * Ignored if a `[headerTemplate]` value is explicitly provided.
   */
  headerTemplate;
  /**
   * @hidden
   *
   * Queries the template for a footer template declaration.
   * Ignored if a `[footerTemplate]` value is explicitly provided.
   */
  footerTemplate;
  /**
   * @hidden
   *
   * Defines the template for the header title.
   * Takes precedence over nested templates in the KendoCalendar tag.
   */
  set headerTitleTemplateRef(template) {
    this._headerTitleTemplateRef = template;
  }
  get headerTitleTemplateRef() {
    return this._headerTitleTemplateRef || this.headerTitleTemplate;
  }
  /**
   * @hidden
   *
   * Defines the template for the header.
   * Takes precedence over nested templates in the KendoCalendar tag.
   */
  set headerTemplateRef(template) {
    this._headerTemplateRef = template;
  }
  get headerTemplateRef() {
    return this._headerTemplateRef || this.headerTemplate;
  }
  /**
   * @hidden
   *
   * Defines the template for the footer.
   */
  set footerTemplateRef(template) {
    this._footerTemplateRef = template;
  }
  get footerTemplateRef() {
    return this._footerTemplateRef || this.footerTemplate;
  }
  /**
   * @hidden
   *
   * Queries the template for a navigation item template declaration.
   * Ignored if a `[navigationItemTemplate]` value is explicitly provided.
   */
  navigationItemTemplate;
  /**
   * @hidden
   *
   * Defines the template for the navigation item.
   * Takes precedence over nested templates in the KendoCalendar tag.
   */
  set navigationItemTemplateRef(template) {
    this._navigationItemTemplateRef = template;
  }
  get navigationItemTemplateRef() {
    return this._navigationItemTemplateRef || this.navigationItemTemplate;
  }
  /**
   * @hidden
   *
   * TODO: Make visible when true sizing of all calendar elements is implemented
   * Sets the size of the component.
   *
   * The possible values are:
   * * `small`
   * * `medium` (Default)
   * * `large`
   * * `none`
   *
   */
  set size(size) {
    this._size = size;
  }
  get size() {
    return this._size;
  }
  _size = DEFAULT_SIZE;
  /**
   * Specifies which end of the defined selection range should be marked as active.
   * Value will be ignored if the selection range is undefined. If range selection is used then the default value is 'start'.
   *
   * @default 'start'
   */
  set activeRangeEnd(_activeRangeEnd) {
    this._activeRangeEnd = _activeRangeEnd;
  }
  get activeRangeEnd() {
    return this._activeRangeEnd;
  }
  _activeRangeEnd = "start";
  navigationView;
  monthView;
  multiViewCalendar;
  isActive = false;
  cellUID = guid();
  selectionRange = {
    start: null,
    end: null
  };
  selectedDates = [];
  rangePivot;
  _disabledDates;
  _min = new Date(MIN_DATE);
  _max = new Date(MAX_DATE);
  _focusedDate = getToday();
  _value;
  onControlChange = noop$2;
  onControlTouched = noop$2;
  onValidatorChange = noop$2;
  minValidateFn = noop$2;
  maxValidateFn = noop$2;
  changes = {};
  valueSetter = false;
  selectionSetter = false;
  syncNavigation = true;
  viewChangeSubscription;
  _type = "infinite";
  _cellTemplateRef;
  _monthCellTemplateRef;
  _yearCellTemplateRef;
  _decadeCellTemplateRef;
  _centuryCellTemplateRef;
  _weekNumberTemplateRef;
  _headerTitleTemplateRef;
  _headerTemplateRef;
  _footerTemplateRef;
  _navigationItemTemplateRef;
  get activeViewEnum() {
    const activeView = CalendarViewEnum[this.activeView];
    return activeView < this.bottomViewEnum ? this.bottomViewEnum : activeView;
  }
  get bottomViewEnum() {
    return CalendarViewEnum[this.bottomView];
  }
  get topViewEnum() {
    return CalendarViewEnum[this.topView];
  }
  get widgetId() {
    return this.id;
  }
  get ariaDisabled() {
    return this.type === "classic" ? void 0 : this.disabled;
  }
  domEvents = [];
  control;
  pageChangeSubscription;
  resolvedPromise = Promise.resolve(null);
  destroyed = false;
  localizationChangeSubscription;
  activeViewDate;
  currentlyFocusedElement;
  canHover = false;
  constructor(bus, dom, element, navigator2, renderer, cdr, ngZone, injector, scrollSyncService, disabledDatesService, localization, selectionService, pickerService) {
    this.bus = bus;
    this.dom = dom;
    this.element = element;
    this.navigator = navigator2;
    this.renderer = renderer;
    this.cdr = cdr;
    this.ngZone = ngZone;
    this.injector = injector;
    this.scrollSyncService = scrollSyncService;
    this.disabledDatesService = disabledDatesService;
    this.localization = localization;
    this.selectionService = selectionService;
    this.pickerService = pickerService;
    N(packageMetadata);
    this.id = `kendo-calendarid-${this.bus.calendarId}`;
    if (this.pickerService) {
      this.pickerService.calendar = this;
    }
  }
  ngOnInit() {
    this.setClasses(this.element.nativeElement);
    if (this.type === "infinite") {
      this.dom.calculateHeights(this.element.nativeElement);
      this.scrollSyncService.configure(this.activeViewEnum);
    }
    this.localizationChangeSubscription = this.localization.changes.subscribe(() => this.cdr.markForCheck());
    this.viewChangeSubscription = this.bus.viewChanged.subscribe(({
      view: view2
    }) => this.handleActiveViewChange(CalendarViewEnum[view2]));
    this.control = this.injector.get(NgControl, null);
    if (this.element) {
      this.ngZone.runOutsideAngular(() => {
        this.bindEvents();
      });
    }
  }
  ngOnChanges(changes) {
    this.changes = changes;
    this.verifyChanges();
    this.bus.configure(this.bottomViewEnum, this.topViewEnum);
    this.scrollSyncService.configure(this.activeViewEnum);
  }
  ngDoCheck() {
    if (this.valueSetter || this.selectionSetter) {
      if (this.selection === "range" && (this.value?.start || this.value?.end) && this.focusedDate.getTime() !== this.value.start?.getTime() && this.focusedDate.getTime() !== this.value.end?.getTime()) {
        this.focusedDate = this.value.start || this.value.end || getToday();
      }
      this.setValue(this.value);
      this.valueSetter = false;
      this.selectionSetter = false;
    }
    if (hasExistingValue(this.changes, "focusedDate")) {
      const focusedDate = this.changes.focusedDate.currentValue;
      this.focusedDate = dateInRange(focusedDate, this.min, this.max);
    }
    if (this.changes.navigation) {
      this.syncNavigation = true;
    }
    if (this.changes.min || this.changes.max || this.changes.rangeValidation) {
      this.minValidateFn = this.rangeValidation ? minValidator(this.min) : noop$2;
      this.maxValidateFn = this.rangeValidation ? maxValidator(this.max) : noop$2;
      this.onValidatorChange();
    }
    this.changes = {};
  }
  ngAfterViewInit() {
    this.setAriaActivedescendant();
    if (this.size !== "none") {
      const element = this.type === "infinite" ? this.element : this.multiViewCalendar.element;
      this.renderer.removeClass(element.nativeElement, getSizeClass("calendar", this.size));
      this.renderer.addClass(element.nativeElement, getSizeClass("calendar", this.size));
    }
  }
  ngAfterViewChecked() {
    if (!this.syncNavigation) {
      return;
    }
    this.syncNavigation = false;
    this.scrollSyncService.sync(virtualizationProp(this.navigationView), virtualizationProp(this.monthView));
  }
  ngOnDestroy() {
    this.scrollSyncService.destroy();
    this.domEvents.forEach((unbindCallback) => unbindCallback());
    if (this.pickerService) {
      this.pickerService.calendar = null;
    }
    if (this.viewChangeSubscription) {
      this.viewChangeSubscription.unsubscribe();
    }
    if (this.pageChangeSubscription) {
      this.pageChangeSubscription.unsubscribe();
    }
    if (this.localizationChangeSubscription) {
      this.localizationChangeSubscription.unsubscribe();
    }
    this.destroyed = true;
  }
  /**
   * @hidden
   */
  onCellEnter(date) {
    if (this.selection === "range" && this.canHover) {
      this.ngZone.run(() => {
        if (this.allowReverse) {
          if (this.activeRangeEnd === "end" && this.selectionRange.start) {
            this.selectionRange = {
              start: this.selectionRange.start,
              end: date
            };
          }
          if (this.activeRangeEnd === "start" && this.selectionRange.end) {
            this.selectionRange = {
              start: date,
              end: this.selectionRange.end
            };
          }
        } else {
          if (this.activeRangeEnd === "end" && this.selectionRange.start && date >= this.selectionRange.start) {
            this.selectionRange = {
              start: this.selectionRange.start,
              end: date
            };
          }
          if (this.selectionRange.start && date < this.selectionRange.start) {
            this.selectionRange = {
              start: this.selectionRange.start,
              end: null
            };
          }
        }
      });
    }
  }
  /**
   * @hidden
   */
  onResize() {
    this.focusedDate = new Date(this.focusedDate);
    this.cdr.detectChanges();
  }
  /**
   * Focuses the Calendar by making the table.k-calendar-table element active.
   */
  focus() {
    this.currentlyFocusedElement = this.type === "infinite" ? this.element?.nativeElement.querySelector(selectors.infiniteCalendarTable) : this.element?.nativeElement.querySelector(selectors.multiViewCalendarTable);
    this.currentlyFocusedElement?.focus();
  }
  /**
   * Blurs the Calendar component.
   */
  blur() {
    const blurTarget = this.type === "infinite" ? this.currentlyFocusedElement : this.multiViewCalendar;
    if (isPresent4(blurTarget)) {
      blurTarget.blur();
    }
  }
  /**
   * @hidden
   */
  containsElement(element) {
    return Boolean(closest2(element, (node) => node === this.element.nativeElement));
  }
  /**
   * @hidden
   */
  handleNavigation(candidate) {
    if (this.disabled) {
      return;
    }
    const focusTarget = candidate ? new Date(cloneDate(candidate).setDate(1)) : this.focusedDate;
    this.focusedDate = dateInRange(focusTarget, this.min, this.max);
    this.detectChanges();
  }
  /**
   * @hidden
   */
  onPageChange() {
    if (!NgZone.isInAngularZone()) {
      if (this.pageChangeSubscription) {
        this.pageChangeSubscription.unsubscribe();
      }
      this.pageChangeSubscription = from(this.resolvedPromise).subscribe(() => {
        this.detectChanges();
      });
    }
  }
  /**
   * @hidden
   */
  handleMultiViewCalendarValueChange(value2, focusedDate) {
    if (this.selection === "range") {
      this.valueChange.emit(value2);
    } else {
      const selectedDates = Array.isArray(value2) ? value2 : [value2];
      this.handleDateChange({
        selectedDates,
        focusedDate
      });
    }
  }
  /**
   * @hidden
   */
  handleDateChange(args) {
    const selectedDates = Array.isArray(args.selectedDates) ? args.selectedDates : [args.selectedDates];
    const canNavigateDown = this.bus.canMoveDown(this.activeViewEnum);
    const availableDates = selectedDates.filter((date) => !this.disabledDatesService.isDateDisabled(date));
    this.focusedDate = args.focusedDate || this.focusedDate;
    if (this.disabled) {
      return;
    }
    if (!canNavigateDown && areDatesEqual(availableDates, this.selectedDates)) {
      this.emitSameDate();
      return;
    }
    if (canNavigateDown) {
      this.bus.moveDown(this.activeViewEnum);
      return;
    }
    if (this.disabledDatesService.isDateDisabled(this.focusedDate)) {
      return;
    }
    if (this.selection === "range") {
      return;
    }
    this.ngZone.run(() => {
      this.selectedDates = availableDates.map((date) => cloneDate(date));
      this.value = this.parseSelectionToValue(availableDates);
      this.onControlChange(this.parseSelectionToValue(availableDates));
      this.valueChange.emit(this.parseSelectionToValue(availableDates));
      this.cdr.markForCheck();
    });
  }
  /**
   * @hidden
   */
  writeValue(candidate) {
    this.verifyValue(candidate);
    this.value = candidate;
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.onControlChange = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.onControlTouched = fn;
  }
  /**
   * @hidden
   */
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  validate(control) {
    return this.minValidateFn(control) || this.maxValidateFn(control);
  }
  /**
   * @hidden
   */
  registerOnValidatorChange(fn) {
    this.onValidatorChange = fn;
  }
  /**
   * @hidden
   */
  activeCellTemplate() {
    switch (this.activeViewEnum) {
      case CalendarViewEnum.month:
        return this.monthCellTemplateRef || this.cellTemplateRef;
      case CalendarViewEnum.year:
        return this.yearCellTemplateRef;
      case CalendarViewEnum.decade:
        return this.decadeCellTemplateRef;
      case CalendarViewEnum.century:
        return this.centuryCellTemplateRef;
      default:
        return null;
    }
  }
  /**
   * @hidden
   */
  handleNavigate(event) {
    this.focusedDate = event.focusedDate;
    this.activeView = event.activeView;
    this.emitNavigate(this.focusedDate);
  }
  /**
   * @hidden
   */
  emitNavigate(focusedDate) {
    const activeView = CalendarViewEnum[this.activeViewEnum];
    this.navigate.emit({
      activeView,
      focusedDate
    });
  }
  /**
   * @hidden
   */
  emitEvent(emitter, args) {
    if (hasObservers(emitter)) {
      this.ngZone.run(() => {
        emitter.emit(args);
      });
    }
  }
  /**
   * @hidden
   */
  handleActiveDateChange(date) {
    this.activeViewDate = date;
    this.emitEvent(this.activeViewDateChange, date);
  }
  /**
   * @hidden
   */
  handleActiveViewChange(view2) {
    this.activeView = view2;
    this.emitEvent(this.activeViewChange, view2);
    if (this.type === "infinite") {
      this.scrollSyncService.configure(this.activeViewEnum);
    }
    this.detectChanges();
  }
  /**
   * @hidden
   */
  handleCellClick({
    date,
    modifiers
  }) {
    this.focus();
    if (this.selection === "range" && this.activeViewEnum === CalendarViewEnum[this.bottomView]) {
      this.performRangeSelection(date);
    } else {
      this.selectionService.lastClicked = date;
      this.performSelection(date, modifiers);
    }
  }
  /**
   * @hidden
   */
  handleWeekNumberClick(dates) {
    if (this.selection === "single") {
      return;
    }
    this.ngZone.run(() => {
      if (this.selection === "multiple") {
        this.handleDateChange({
          selectedDates: dates,
          focusedDate: last(dates)
        });
      }
      if (this.selection === "range") {
        this.canHover = false;
        this.activeRangeEnd = "start";
        const shouldEmitValueChange = this.selectionRange.start?.getTime() !== dates[0].getTime() || this.selectionRange.end?.getTime() !== last(dates).getTime();
        this.value = {
          start: dates[0],
          end: last(dates)
        };
        if (shouldEmitValueChange) {
          this.valueChange.emit(this.value);
        }
      }
    });
  }
  /**
   * @hidden
   */
  handleBlur(args) {
    if (this.element.nativeElement.contains(args.relatedTarget)) {
      return;
    }
    this.isActive = false;
    if (!this.pickerService && requiresZoneOnBlur(this.control)) {
      this.ngZone.run(() => {
        this.onControlTouched();
        this.emitBlur(args);
        this.cdr.markForCheck();
      });
    } else {
      this.emitBlur(args);
      this.detectChanges();
    }
  }
  /**
   * @hidden
   */
  handleFocus() {
    this.isActive = true;
    if (!NgZone.isInAngularZone()) {
      this.detectChanges();
    }
    this.emitFocus();
  }
  /**
   * @hidden
   */
  handleMultiViewCalendarKeydown(args) {
    if (isPresent4(this.pickerService) && (args.code === Keys.Enter || args.code === Keys.NumpadEnter)) {
      args.preventDefault();
    }
  }
  setClasses(element) {
    this.renderer.removeClass(element, `k-calendar-${this.type}`);
    if (this.type === "infinite") {
      this.renderer.addClass(element, "k-calendar");
      this.renderer.addClass(element, `k-calendar-${this.type}`);
    }
  }
  verifyChanges() {
    if (!isDevMode()) {
      return;
    }
    if (this.min > this.max) {
      throw new Error(`The max value should be bigger than the min. See ${MIN_DOC_LINK$2} and ${MAX_DOC_LINK$2}.`);
    }
    if (this.bottomViewEnum > this.topViewEnum) {
      throw new Error(`The topView should be greater than bottomView. See ${BOTTOM_VIEW_DOC_LINK} and ${TOP_VIEW_DOC_LINK}.`);
    }
  }
  verifyValue(candidate) {
    if (!isDevMode()) {
      return;
    }
    if (this.selection === "single" && candidate && !isNullOrDate(candidate)) {
      throw new Error(`When using 'single' selection the 'value' should be a valid JavaScript Date instance. Check ${VALUE_DOC_LINK$4} for possible resolution.`);
    } else if (this.selection === "multiple" && candidate) {
      if (Array.isArray(candidate)) {
        const onlyDates = candidate.every((value2) => value2 instanceof Date);
        if (!onlyDates) {
          throw new Error(`When using 'multiple' selection the 'value' should be an array of valid JavaScript Date instances. Check ${VALUE_DOC_LINK$4} for possible resolution.`);
        }
      }
      if (Object.keys(candidate).find((k) => k === "start") && Object.keys(candidate).find((k) => k === "end")) {
        throw new Error(`When using 'multiple' selection the 'value' should be an array of valid JavaScript Date instances. Check ${VALUE_DOC_LINK$4} for possible resolution.`);
      }
    } else if (this.selection === "range" && candidate && !(isNullOrDate(candidate["start"]) && isNullOrDate(candidate["end"]))) {
      throw new Error(`The 'value' should be an object with start and end dates. Check ${VALUE_DOC_LINK$4} for possible resolution.`);
    }
  }
  bindEvents() {
    const element = this.element.nativeElement;
    this.domEvents.push(this.renderer.listen(element, "focus", this.handleFocus.bind(this)), this.renderer.listen(element, "mousedown", preventDefault), this.renderer.listen(element, "click", this.handleComponentClick.bind(this)), this.renderer.listen(element, "keydown", this.handleKeydown.bind(this)), this.renderer.listen(element, "mouseleave", this.setRangeSelectionToValue.bind(this)));
  }
  setRangeSelectionToValue() {
    if (this.selection === "range" && this.type === "infinite" && this.value) {
      this.ngZone.run(() => {
        this.selectionRange = this.value;
        this.cdr.markForCheck();
      });
    }
  }
  emitBlur(args) {
    if (this.pickerService) {
      this.pickerService.onBlur.emit(args);
    }
    this.onBlur.emit();
  }
  emitFocus() {
    if (this.pickerService) {
      this.pickerService.onFocus.emit();
    }
    this.onFocus.emit();
  }
  handleComponentClick() {
    if (!this.isActive) {
      if (this.type === "infinite" && this.monthView.isScrolled()) {
        this.focusedDate = cloneDate(this.focusedDate);
        this.detectChanges();
      }
      this.focus();
    }
  }
  handleKeydown(args) {
    if (this.type === "infinite") {
      const ctrlKey = args.ctrlKey || args.metaKey;
      const code = normalizeKeys(args);
      const arrowKeyPressed = [Keys.ArrowUp, Keys.ArrowRight, Keys.ArrowDown, Keys.ArrowLeft].indexOf(code) !== -1;
      const reserveKeyCommandsForPicker = isPresent4(this.pickerService) && arrowKeyPressed && args.altKey;
      if (reserveKeyCommandsForPicker) {
        return;
      }
      if (ctrlKey && arrowKeyPressed) {
        args.preventDefault();
      }
      const preventSubmitInDatePicker = isPresent4(this.pickerService) && code === Keys.Enter;
      if (preventSubmitInDatePicker) {
        args.preventDefault();
      }
      const candidate = dateInRange(this.navigator.move(this.focusedDate, this.navigator.action(args), this.activeViewEnum), this.min, this.max);
      if (!isEqual(this.focusedDate, candidate)) {
        this.focusedDate = candidate;
        this.detectChanges();
        args.preventDefault();
      }
      if (code === Keys.Enter) {
        this.selectionService.lastClicked = this.focusedDate;
        if (this.selection !== "range") {
          this.performSelection(this.focusedDate, args);
        } else {
          this.performRangeSelection(this.focusedDate);
        }
      }
      if (code === Keys.KeyT) {
        this.focusToday();
      }
      if (isArrowWithShiftPressed(args) && this.selection !== "range") {
        args.anyArrow = true;
        this.performSelection(this.focusedDate, args);
      }
    }
  }
  focusToday() {
    this.focusedDate = getToday();
    this.bus.moveToBottom(this.activeViewEnum);
    this.cdr.detectChanges();
  }
  detectChanges() {
    if (!this.destroyed) {
      this.cdr.detectChanges();
    }
  }
  emitSameDate() {
    if (this.pickerService) {
      this.pickerService.sameDateSelected.emit();
    }
  }
  setAriaActivedescendant() {
    const infiniteCalendarTable = this.element.nativeElement?.querySelector(selectors.infiniteCalendarTable);
    const activedescendantHandledByInnerMultiViewCalendar = !isPresent4(infiniteCalendarTable) || this.type === "classic" && !infiniteCalendarTable.hasAttribute(attributeNames.ariaActiveDescendant);
    if (activedescendantHandledByInnerMultiViewCalendar) {
      return;
    }
    if (this.type === "classic") {
      this.renderer.removeAttribute(infiniteCalendarTable, attributeNames.ariaActiveDescendant);
      return;
    }
    const focusedCellId = this.cellUID + this.focusedDate.getTime();
    this.renderer.setAttribute(infiniteCalendarTable, attributeNames.ariaActiveDescendant, focusedCellId);
  }
  parseSelectionToValue(selection) {
    selection = selection || [];
    return this.selection === "single" ? cloneDate(last(selection)) : selection.map((date) => cloneDate(date));
  }
  setValue(candidate) {
    this.verifyValue(candidate);
    if (candidate === null) {
      this._value = null;
      this.selectedDates = [];
      this.selectionRange = {
        start: null,
        end: null
      };
    } else if (Array.isArray(candidate)) {
      this.selectionRange = {
        start: null,
        end: null
      };
      this._value = candidate.filter((date) => isPresent4(date)).map((element) => cloneDate(element));
    } else if (isObject(candidate) && Object.keys(candidate).find((k) => k === "start") && Object.keys(candidate).find((k) => k === "end")) {
      this.selectedDates = [];
      this.selectionRange = {
        start: null,
        end: null
      };
      this._value = {
        start: null,
        end: null
      };
      this._value.start = candidate.start instanceof Date ? cloneDate(candidate.start) : null;
      this._value.end = candidate.end instanceof Date ? cloneDate(candidate.end) : null;
      this.selectionRange = Object.assign({}, this._value);
      if (this._value?.start && !this._value?.end) {
        this.activeRangeEnd = "end";
        this.canHover = true;
      }
      if (this._value?.end && !this._value?.start) {
        this.activeRangeEnd = "start";
        this.canHover = true;
      }
      if (this._value?.end && this._value?.start) {
        this.canHover = false;
      }
    } else {
      this.selectionRange = {
        start: null,
        end: null
      };
      this._value = cloneDate(candidate);
    }
    if (this.selection !== "range") {
      const selection = [].concat(candidate).filter((date) => isPresent4(date)).map((date) => cloneDate(date));
      if (!areDatesEqual(selection, this.selectedDates)) {
        const lastSelected = last(selection);
        this.rangePivot = cloneDate(lastSelected);
        this.focusedDate = cloneDate(lastSelected) || this.focusedDate;
        this.selectedDates = selection;
      }
    }
  }
  performRangeSelection(date) {
    this.focusedDate = date;
    const clonedRangeSelection = Object.assign({}, this.selectionRange);
    const emitValueChange = this.activeRangeEnd === "start" && this.value?.start?.getTime() !== date?.getTime() || this.activeRangeEnd === "end" && this.value?.end?.getTime() !== date?.getTime();
    this.ngZone.run(() => {
      const rangeSelection = handleRangeSelection(date, clonedRangeSelection, this.activeRangeEnd, this.allowReverse);
      this.activeRangeEnd = rangeSelection.activeRangeEnd;
      if (this.canHover && rangeSelection.activeRangeEnd === "end" && rangeSelection.selectionRange.end?.getTime() === date.getTime()) {
        this.activeRangeEnd = "start";
        rangeSelection.activeRangeEnd = "start";
      }
      this.canHover = this.activeRangeEnd === "end" && rangeSelection.selectionRange.start && !rangeSelection.selectionRange.end;
      if (emitValueChange && (this.value?.start?.getTime() !== rangeSelection.selectionRange?.start?.getTime() || this.value?.end?.getTime() !== rangeSelection.selectionRange?.end?.getTime())) {
        this.value = rangeSelection.selectionRange;
        this.valueChange.emit(this.value);
      }
      this.cdr.markForCheck();
    });
  }
  performSelection(date, selectionModifiers) {
    const selection = this.selectionService.performSelection({
      date,
      modifiers: selectionModifiers,
      selectionMode: this.selection,
      activeViewEnum: this.activeViewEnum,
      rangePivot: this.rangePivot,
      selectedDates: this.selectedDates
    });
    this.rangePivot = selection.rangePivot;
    this.handleDateChange({
      selectedDates: selection.selectedDates,
      focusedDate: date
    });
  }
  static ɵfac = function CalendarComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CalendarComponent)(ɵɵdirectiveInject(BusViewService), ɵɵdirectiveInject(CalendarDOMService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NavigationService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(ScrollSyncService), ɵɵdirectiveInject(DisabledDatesService), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(SelectionService), ɵɵdirectiveInject(PickerService, 8));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _CalendarComponent,
    selectors: [["kendo-calendar"]],
    contentQueries: function CalendarComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, CellTemplateDirective, 5)(dirIndex, MonthCellTemplateDirective, 5)(dirIndex, YearCellTemplateDirective, 5)(dirIndex, DecadeCellTemplateDirective, 5)(dirIndex, CenturyCellTemplateDirective, 5)(dirIndex, WeekNumberCellTemplateDirective, 5)(dirIndex, HeaderTitleTemplateDirective, 5)(dirIndex, HeaderTemplateDirective, 5)(dirIndex, FooterTemplateDirective2, 5)(dirIndex, NavigationItemTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.cellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.monthCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.yearCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.decadeCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.centuryCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.weekNumberTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTitleTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.navigationItemTemplate = _t.first);
      }
    },
    viewQuery: function CalendarComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(NavigationComponent, 5)(ViewListComponent, 5)(MultiViewCalendarComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.navigationView = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.monthView = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.multiViewCalendar = _t.first);
      }
    },
    hostVars: 6,
    hostBindings: function CalendarComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("id", ctx.widgetId)("aria-disabled", ctx.ariaDisabled);
        ɵɵclassProp("k-week-number", ctx.weekNumber)("k-disabled", ctx.ariaDisabled);
      }
    },
    inputs: {
      showOtherMonthDays: "showOtherMonthDays",
      id: "id",
      focusedDate: "focusedDate",
      min: "min",
      max: "max",
      rangeValidation: "rangeValidation",
      weekDaysFormat: "weekDaysFormat",
      footer: "footer",
      selection: "selection",
      allowReverse: "allowReverse",
      value: "value",
      disabled: "disabled",
      tabindex: "tabindex",
      tabIndex: "tabIndex",
      disabledDates: "disabledDates",
      navigation: "navigation",
      activeView: "activeView",
      bottomView: "bottomView",
      topView: "topView",
      type: "type",
      animateNavigation: "animateNavigation",
      weekNumber: "weekNumber",
      cellTemplateRef: [0, "cellTemplate", "cellTemplateRef"],
      monthCellTemplateRef: [0, "monthCellTemplate", "monthCellTemplateRef"],
      yearCellTemplateRef: [0, "yearCellTemplate", "yearCellTemplateRef"],
      decadeCellTemplateRef: [0, "decadeCellTemplate", "decadeCellTemplateRef"],
      centuryCellTemplateRef: [0, "centuryCellTemplate", "centuryCellTemplateRef"],
      weekNumberTemplateRef: [0, "weekNumberTemplate", "weekNumberTemplateRef"],
      headerTitleTemplateRef: [0, "headerTitleTemplate", "headerTitleTemplateRef"],
      headerTemplateRef: [0, "headerTemplate", "headerTemplateRef"],
      footerTemplateRef: [0, "footerTemplate", "footerTemplateRef"],
      navigationItemTemplateRef: [0, "navigationItemTemplate", "navigationItemTemplateRef"],
      size: "size",
      activeRangeEnd: "activeRangeEnd"
    },
    outputs: {
      closePopup: "closePopup",
      activeViewChange: "activeViewChange",
      navigate: "navigate",
      activeViewDateChange: "activeViewDateChange",
      onBlur: "blur",
      onFocus: "focus",
      valueChange: "valueChange"
    },
    exportAs: ["kendo-calendar"],
    features: [ɵɵProvidersFeature([BusViewService, CALENDAR_VALUE_ACCESSOR, CALENDAR_RANGE_VALIDATORS, KENDO_INPUT_PROVIDER, LocalizationService, DisabledDatesService, {
      provide: L10N_PREFIX,
      useValue: "kendo.calendar"
    }, NavigationService, ScrollSyncService, SelectionService]), ɵɵNgOnChangesFeature],
    decls: 3,
    vars: 2,
    consts: () => {
      let i18n_4;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_4 = goog.getMsg("Today");
        i18n_4 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_4;
      } else {
        i18n_4 = $localize`:kendo.calendar.today|The label for the today button in the calendar header:Today`;
      }
      let i18n_5;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_5 = goog.getMsg("Navigate to previous view");
        i18n_5 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_5;
      } else {
        i18n_5 = $localize`:kendo.calendar.prevButtonTitle|The title of the previous button in the Classic calendar:Navigate to previous view`;
      }
      let i18n_6;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_6 = goog.getMsg("Navigate to next view");
        i18n_6 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_6;
      } else {
        i18n_6 = $localize`:kendo.calendar.nextButtonTitle|The title of the next button in the Classic calendar:Navigate to next view`;
      }
      let i18n_7;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_7 = goog.getMsg("Navigate to parent view");
        i18n_7 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_7;
      } else {
        i18n_7 = $localize`:kendo.calendar.parentViewButtonTitle|The title of the parent view button in the calendar header:Navigate to parent view`;
      }
      return [["multiviewcalendar", ""], ["kendoCalendarLocalizedMessages", "", "today", i18n_4, "prevButtonTitle", i18n_5, "nextButtonTitle", i18n_6, "parentViewButtonTitle", i18n_7], [3, "views", "min", "max", "size", "id", "activeRangeEnd", "selectionRange", "allowReverse", "disabled", "isActive", "showOtherMonthDays", "tabIndex", "activeView", "bottomView", "topView", "weekDaysFormat", "weekNumber", "animateNavigation", "cellTemplate", "monthCellTemplate", "yearCellTemplate", "decadeCellTemplate", "centuryCellTemplate", "headerTitleTemplate", "headerTemplate", "footerTemplate", "footer", "weekNumberTemplate", "focusedDate", "selection", "value", "disabledDates"], [3, "activeView", "focusedDate", "min", "max", "templateRef"], [3, "todayButtonClick", "cellClick", "weekNumberCellClick", "activeDateChange", "pageChange", "focusCalendar", "blurCalendar", "cellEnter", "activeView", "allowReverse", "showOtherMonthDays", "activeRangeEnd", "selectionRange", "size", "isActive", "id", "weekDaysFormat", "cellTemplateRef", "headerTitleTemplateRef", "headerTemplateRef", "showFooter", "footerTemplateRef", "weekNumberTemplateRef", "cellUID", "min", "max", "focusedDate", "weekNumber", "selectedDates", "tabIndex", "disabled"], [3, "resize"], [3, "valueChange", "pageChange", "activeView", "focusedDate", "min", "max", "templateRef"], [3, "onClosePopup", "activeViewChange", "navigate", "valueChange", "focusCalendar", "blur", "blurEvent", "keydown", "views", "min", "max", "size", "id", "activeRangeEnd", "selectionRange", "allowReverse", "disabled", "isActive", "showOtherMonthDays", "tabIndex", "activeView", "bottomView", "topView", "weekDaysFormat", "weekNumber", "animateNavigation", "cellTemplate", "monthCellTemplate", "yearCellTemplate", "decadeCellTemplate", "centuryCellTemplate", "headerTitleTemplate", "headerTemplate", "footerTemplate", "footer", "weekNumberTemplate", "focusedDate", "selection", "value", "disabledDates"], [3, "today", "prevButtonTitle", "nextButtonTitle", "parentViewButtonTitle"]];
    },
    template: function CalendarComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainer(0, 1);
        ɵɵconditionalCreate(1, CalendarComponent_Conditional_1_Template, 3, 24);
        ɵɵconditionalCreate(2, CalendarComponent_Conditional_2_Template, 3, 36, "kendo-multiviewcalendar", 2);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵconditional(ctx.type === "infinite" ? 1 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.type === "classic" ? 2 : -1);
      }
    },
    dependencies: [CalendarLocalizedMessagesDirective, NavigationComponent, ViewListComponent, ResizeSensorComponent, MultiViewCalendarComponent, MultiViewCalendarCustomMessagesComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      exportAs: "kendo-calendar",
      providers: [BusViewService, CALENDAR_VALUE_ACCESSOR, CALENDAR_RANGE_VALIDATORS, KENDO_INPUT_PROVIDER, LocalizationService, DisabledDatesService, {
        provide: L10N_PREFIX,
        useValue: "kendo.calendar"
      }, NavigationService, ScrollSyncService, SelectionService],
      selector: "kendo-calendar",
      template: `
    <ng-container kendoCalendarLocalizedMessages
      i18n-today="kendo.calendar.today|The label for the today button in the calendar header"
      today="Today"
    
      i18n-prevButtonTitle="kendo.calendar.prevButtonTitle|The title of the previous button in the Classic calendar"
      prevButtonTitle="Navigate to previous view"
    
      i18n-nextButtonTitle="kendo.calendar.nextButtonTitle|The title of the next button in the Classic calendar"
      nextButtonTitle="Navigate to next view"
    
      i18n-parentViewButtonTitle="kendo.calendar.parentViewButtonTitle|The title of the parent view button in the calendar header"
      parentViewButtonTitle="Navigate to parent view"
      >
    </ng-container>
    @if (type === 'infinite') {
      @if (navigation) {
        <kendo-calendar-navigation
          [activeView]="activeViewEnum"
          [focusedDate]="focusedDate"
          [min]="min"
          [max]="max"
          [templateRef]="navigationItemTemplateRef?.templateRef"
          (valueChange)="handleNavigation($event)"
          (pageChange)="onPageChange()"
          >
        </kendo-calendar-navigation>
      }
      <kendo-calendar-viewlist
        [activeView]="activeViewEnum"
        [allowReverse]="allowReverse"
        [showOtherMonthDays]="showOtherMonthDays"
        [activeRangeEnd]="activeRangeEnd"
        [selectionRange]="selectionRange"
        [size]="size"
        [isActive]="isActive"
        [id]="headerId"
        [weekDaysFormat]="weekDaysFormat"
        [cellTemplateRef]="activeCellTemplate()?.templateRef"
        [headerTitleTemplateRef]="headerTitleTemplateRef?.templateRef"
        [headerTemplateRef]="headerTemplateRef?.templateRef"
        [showFooter]="footer"
        [footerTemplateRef]="footerTemplateRef?.templateRef"
        [weekNumberTemplateRef]="weekNumberTemplateRef?.templateRef"
        [cellUID]="cellUID"
        [min]="min"
        [max]="max"
        [focusedDate]="focusedDate"
        [weekNumber]="weekNumber"
        [selectedDates]="selectedDates"
        [tabIndex]="tabIndex"
        [disabled]="disabled"
            (todayButtonClick)="handleDateChange({
                selectedDates: [$event],
                focusedDate: $event
            })"
        (cellClick)="handleCellClick($event)"
        (weekNumberCellClick)="handleWeekNumberClick($event)"
        (activeDateChange)="handleActiveDateChange($event)"
        (pageChange)="onPageChange()"
        (focusCalendar)="handleFocus()"
        (blurCalendar)="handleBlur($event)"
        (cellEnter)="onCellEnter($event)"
        >
      </kendo-calendar-viewlist>
      <kendo-resize-sensor (resize)="onResize()"></kendo-resize-sensor>
    }
    @if (type === 'classic') {
      <kendo-multiviewcalendar
        #multiviewcalendar
        [views]="1"
        [min]="min"
        [max]="max"
        [size]="size"
        [id]="id"
        [activeRangeEnd]="activeRangeEnd"
        [selectionRange]="selectionRange"
        [allowReverse]="allowReverse"
        [disabled]="disabled"
        [isActive]="isActive"
        [showOtherMonthDays]="showOtherMonthDays"
        [tabIndex]="tabIndex"
        [activeView]="activeView"
        [bottomView]="bottomView"
        [topView]="topView"
        [weekDaysFormat]="weekDaysFormat"
        [weekNumber]="weekNumber"
        [animateNavigation]="animateNavigation"
        [cellTemplate]="activeCellTemplate()"
        [monthCellTemplate]="monthCellTemplateRef"
        [yearCellTemplate]="yearCellTemplateRef"
        [decadeCellTemplate]="decadeCellTemplateRef"
        [centuryCellTemplate]="centuryCellTemplateRef"
        [headerTitleTemplate]="headerTitleTemplateRef"
        [headerTemplate]="headerTemplateRef"
        [footerTemplate]="footerTemplateRef"
        [footer]="footer"
        [weekNumberTemplate]="weekNumberTemplateRef"
        [focusedDate]="focusedDate"
        [selection]="selection"
        [value]="value"
        [disabledDates]="disabledDates"
        (onClosePopup)="closePopup.emit()"
        (activeViewChange)="handleActiveViewChange($event)"
        (navigate)="handleNavigate($event)"
        (valueChange)="handleMultiViewCalendarValueChange($event, multiviewcalendar.focusedDate)"
        (focusCalendar)="handleFocus()"
        (blur)="handleBlur($event)"
        (blurEvent)="handleBlur($event)"
        (keydown)="handleMultiViewCalendarKeydown($event)"
        >
        <kendo-multiviewcalendar-messages
          [today]="localization.get('today')"
          [prevButtonTitle]="localization.get('prevButtonTitle')"
          [nextButtonTitle]="localization.get('nextButtonTitle')"
          [parentViewButtonTitle]="localization.get('parentViewButtonTitle')"
          >
        </kendo-multiviewcalendar-messages>
      </kendo-multiviewcalendar>
    }
    `,
      standalone: true,
      imports: [CalendarLocalizedMessagesDirective, NavigationComponent, ViewListComponent, ResizeSensorComponent, MultiViewCalendarComponent, MultiViewCalendarCustomMessagesComponent]
    }]
  }], () => [{
    type: BusViewService
  }, {
    type: CalendarDOMService
  }, {
    type: ElementRef
  }, {
    type: NavigationService
  }, {
    type: Renderer2
  }, {
    type: ChangeDetectorRef
  }, {
    type: NgZone
  }, {
    type: Injector
  }, {
    type: ScrollSyncService
  }, {
    type: DisabledDatesService
  }, {
    type: LocalizationService
  }, {
    type: SelectionService
  }, {
    type: PickerService,
    decorators: [{
      type: Optional
    }]
  }], {
    showOtherMonthDays: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    focusedDate: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    rangeValidation: [{
      type: Input
    }],
    weekDaysFormat: [{
      type: Input
    }],
    footer: [{
      type: Input
    }],
    selection: [{
      type: Input
    }],
    allowReverse: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    disabledDates: [{
      type: Input
    }],
    navigation: [{
      type: Input
    }],
    activeView: [{
      type: Input
    }],
    bottomView: [{
      type: Input
    }],
    topView: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    animateNavigation: [{
      type: Input
    }],
    weekNumber: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-week-number"]
    }],
    closePopup: [{
      type: Output
    }],
    activeViewChange: [{
      type: Output
    }],
    navigate: [{
      type: Output
    }],
    activeViewDateChange: [{
      type: Output
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    valueChange: [{
      type: Output
    }],
    cellTemplate: [{
      type: ContentChild,
      args: [CellTemplateDirective, {
        static: false
      }]
    }],
    cellTemplateRef: [{
      type: Input,
      args: ["cellTemplate"]
    }],
    monthCellTemplate: [{
      type: ContentChild,
      args: [MonthCellTemplateDirective, {
        static: false
      }]
    }],
    monthCellTemplateRef: [{
      type: Input,
      args: ["monthCellTemplate"]
    }],
    yearCellTemplate: [{
      type: ContentChild,
      args: [YearCellTemplateDirective, {
        static: false
      }]
    }],
    yearCellTemplateRef: [{
      type: Input,
      args: ["yearCellTemplate"]
    }],
    decadeCellTemplate: [{
      type: ContentChild,
      args: [DecadeCellTemplateDirective, {
        static: false
      }]
    }],
    decadeCellTemplateRef: [{
      type: Input,
      args: ["decadeCellTemplate"]
    }],
    centuryCellTemplate: [{
      type: ContentChild,
      args: [CenturyCellTemplateDirective, {
        static: false
      }]
    }],
    centuryCellTemplateRef: [{
      type: Input,
      args: ["centuryCellTemplate"]
    }],
    weekNumberTemplate: [{
      type: ContentChild,
      args: [WeekNumberCellTemplateDirective, {
        static: false
      }]
    }],
    weekNumberTemplateRef: [{
      type: Input,
      args: ["weekNumberTemplate"]
    }],
    headerTitleTemplate: [{
      type: ContentChild,
      args: [HeaderTitleTemplateDirective, {
        static: false
      }]
    }],
    headerTemplate: [{
      type: ContentChild,
      args: [HeaderTemplateDirective]
    }],
    footerTemplate: [{
      type: ContentChild,
      args: [FooterTemplateDirective2]
    }],
    headerTitleTemplateRef: [{
      type: Input,
      args: ["headerTitleTemplate"]
    }],
    headerTemplateRef: [{
      type: Input,
      args: ["headerTemplate"]
    }],
    footerTemplateRef: [{
      type: Input,
      args: ["footerTemplate"]
    }],
    navigationItemTemplate: [{
      type: ContentChild,
      args: [NavigationItemTemplateDirective, {
        static: false
      }]
    }],
    navigationItemTemplateRef: [{
      type: Input,
      args: ["navigationItemTemplate"]
    }],
    size: [{
      type: Input
    }],
    activeRangeEnd: [{
      type: Input
    }],
    navigationView: [{
      type: ViewChild,
      args: [NavigationComponent, {
        static: false
      }]
    }],
    monthView: [{
      type: ViewChild,
      args: [ViewListComponent, {
        static: false
      }]
    }],
    multiViewCalendar: [{
      type: ViewChild,
      args: [MultiViewCalendarComponent, {
        static: false
      }]
    }],
    widgetId: [{
      type: HostBinding,
      args: ["attr.id"]
    }],
    ariaDisabled: [{
      type: HostBinding,
      args: ["attr.aria-disabled"]
    }, {
      type: HostBinding,
      args: ["class.k-disabled"]
    }]
  });
})();
var incompleteDateValidator = () => {
  return (control, incomplete) => {
    if (!isPresent4(control.value) && incomplete) {
      return {
        incompleteDate: true
      };
    } else {
      return null;
    }
  };
};
var Arrow;
(function(Arrow2) {
  Arrow2[Arrow2["Up"] = 0] = "Up";
  Arrow2[Arrow2["Down"] = 1] = "Down";
  Arrow2[Arrow2["None"] = 2] = "None";
})(Arrow || (Arrow = {}));
var DateInputMessages = class _DateInputMessages extends ComponentMessages {
  /**
   * The title of the **Decrement** button of the DateInput.
   */
  decrement;
  /**
   * The title of the **Increment** button of the DateInput.
   */
  increment;
  /**
   * The title of the **Clear** button of the DateInput.
   */
  clearTitle;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵDateInputMessages_BaseFactory;
    return function DateInputMessages_Factory(__ngFactoryType__) {
      return (ɵDateInputMessages_BaseFactory || (ɵDateInputMessages_BaseFactory = ɵɵgetInheritedFactory(_DateInputMessages)))(__ngFactoryType__ || _DateInputMessages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _DateInputMessages,
    selectors: [["kendo-dateinput-messages-base"]],
    inputs: {
      decrement: "decrement",
      increment: "increment",
      clearTitle: "clearTitle"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateInputMessages, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line
      selector: "kendo-dateinput-messages-base"
    }]
  }], null, {
    decrement: [{
      type: Input
    }],
    increment: [{
      type: Input
    }],
    clearTitle: [{
      type: Input
    }]
  });
})();
var DateInputLocalizedMessagesDirective = class _DateInputLocalizedMessagesDirective extends DateInputMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function DateInputLocalizedMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DateInputLocalizedMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DateInputLocalizedMessagesDirective,
    selectors: [["", "kendoDateInputLocalizedMessages", ""]],
    features: [ɵɵProvidersFeature([{
      provide: DateInputMessages,
      useExisting: forwardRef(() => _DateInputLocalizedMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateInputLocalizedMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: DateInputMessages,
        useExisting: forwardRef(() => DateInputLocalizedMessagesDirective)
      }],
      selector: "[kendoDateInputLocalizedMessages]",
      standalone: true
    }]
  }], () => [{
    type: LocalizationService
  }], null);
})();
var nextId = 0;
var MIN_DOC_LINK$1 = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/api/DateInputComponent/#toc-min";
var MAX_DOC_LINK$1 = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/api/DateInputComponent/#toc-max";
var VALUE_DOC_LINK$3 = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/dateinput/#toc-using-with-json";
var TWO_DIGIT_YEAR_MAX$2 = 68;
var DEFAULT_FORMAT$1 = "d";
var DEFAULT_FORMAT_PLACEHOLDER = "wide";
var DATE_PART_REGEXP = /year|month|<day>/;
var TIME_PART_REGEXP = /hour|minute|second|millisecond/;
var DateInputIntl = class {
  service;
  format;
  toString;
  formatDate;
  parseDate;
  parseNumber;
  formatNumber;
  splitDateFormat;
  numberSymbols;
  firstDay;
  weekendRange;
  dateFieldName;
  dateFormatNames;
  cldr = {};
  localeId;
  constructor(service) {
    this.service = service;
    this.localeId = service["localeId"];
    this.format = service.format;
    this.toString = service.toString;
    this.formatDate = service.formatDate;
    this.parseDate = service.parseDate;
    this.parseNumber = service.parseNumber;
    this.formatNumber = service.formatNumber;
    this.splitDateFormat = service.splitDateFormat;
    this.numberSymbols = service.numberSymbols;
    this.firstDay = service.firstDay;
    this.weekendRange = service.weekendRange;
    this.dateFieldName = service.dateFieldName;
    this.dateFormatNames = (localeId, options) => this.service.dateFormatNames(options, localeId || this.localeId);
    const _localeData = localeData(this.localeId);
    this.cldr[_localeData.name] = _localeData;
  }
};
var DateInputComponent = class _DateInputComponent {
  cdr;
  intl;
  renderer;
  wrapper;
  ngZone;
  injector;
  localization;
  pickerService;
  /**
   * @hidden
   */
  caretAltUpIcon = caretAltUpIcon;
  /**
   * @hidden
   */
  xIcon = xIcon;
  /**
   * @hidden
   */
  caretAltDownIcon = caretAltDownIcon;
  /**
   * @hidden
   */
  set focusableId(_focusableId) {
    if (_focusableId) {
      this._focusableId = _focusableId;
    }
  }
  get focusableId() {
    return this._focusableId;
  }
  /**
   * @hidden
   */
  set pickerType(_pickerType) {
    if (_pickerType) {
      this.focusableId = `${_pickerType}-${nextId}`;
    }
  }
  /**
   * Specifies whether to render a clear button after the input text or DateInput value has been changed.
   * Clicking this button resets the value of the component to `null` and triggers the `valueChange` event.
   * @default false
   */
  clearButton = false;
  /**
   * Specifies whether the component is disabled
   * ([see example]({% slug disabled_dateinput %})).
   * To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_dateinput#toc-managing-the-dateinput-disabled-state-in-reactive-forms).
   *
   * @default false
   */
  disabled = false;
  /**
   * Specifies the read-only state of the DateInput
   * ([see example]({% slug readonly_dateinput %})).
   *
   * @default false
   */
  readonly = false;
  /**
   * Specifies the title of the input element of the DateInput.
   *
   * @default ""
   */
  title = "";
  /**
   * Specifies the `tabIndex` property of the DateInput.
   *
   * @default 0
   */
  tabindex = 0;
  /**
   * @hidden
   */
  role = "textbox";
  /**
   * @hidden
   */
  ariaReadOnly = false;
  /**
   * @hidden
   */
  set tabIndex(tabIndex) {
    this.tabindex = tabIndex;
  }
  get tabIndex() {
    return this.tabindex;
  }
  /**
   * @hidden
   */
  isRequired = false;
  /**
   * Specifies the date format that is used to display the input value
   * ([see example]({% slug formats_dateinput %})).
   *
   * You can provide a string if a single format is going to be used regardless whether the input is focused or blurred.
   * Alternatively, you can provide a FormatSettings object to display different formats when the component is focused or blurred by specifying inputFormat and displayFormat values.
   */
  format = DEFAULT_FORMAT$1;
  /**
   * Defines the descriptions of the format sections in the input field.
   * For more information, refer to the article on
   * [placeholders]({% slug placeholders_dateinput %}).
   */
  set formatPlaceholder(format) {
    this._formatPlaceholder = format || DEFAULT_FORMAT_PLACEHOLDER;
  }
  get formatPlaceholder() {
    return this._formatPlaceholder;
  }
  /**
   * Specifies the hint the DateInput displays when its value is `null`.
   * For more information, refer to the article on
   * [placeholders]({% slug placeholders_dateinput %}).
   */
  placeholder;
  /**
   * Configures the incremental steps of the DateInput.
   * For more information, refer to the article on
   * [incremental steps]({% slug incrementalsteps_dateinput %}).
   */
  steps = {};
  /**
   * Specifies the biggest date that is valid
   * ([see example]({% slug dateranges_dateinput %})).
   *
   * @default 2099-12-31
   */
  max = cloneDate(MAX_DATE);
  /**
   * Specifies the smallest date that is valid
   * ([see example]({% slug dateranges_dateinput %})).
   *
   * @default 1900-1-1
   */
  min = cloneDate(MIN_DATE);
  /**
   * Specifies whether to enforce the built-in min and max validators when validating a form.
   * Set to `true` to enable validation for the `min` and `max` values.
   *
   * @default true
   */
  rangeValidation = true;
  /**
   * Specifies if the component automatically corrects invalid date segments.
   * When set to `true`, the component fixes invalid segments as you type.
   *
   * @default true
   */
  autoCorrectParts = true;
  /**
   * Specifies if the component automatically moves to the next segment after you complete the current one.
   * When set to `true`, focus moves to the next segment as soon as you finish typing the current segment.
   *
   * @default true
   */
  autoSwitchParts = true;
  /**
   * Specifies custom keys that move focus to the next date format segment.
   * Provide an array of strings to define which keys trigger the focus change.
   */
  autoSwitchKeys = [];
  /**
   * Specifies if the component displays a blinking caret inside the DateInput when possible.
   * Set to `true` to show a blinking caret for better visual feedback.
   *
   * @default false
   */
  allowCaretMode = false;
  /**
   * Specifies whether to autofill the rest of the date to the current date when the component loses focus.
   *
   * @default false
   */
  autoFill = false;
  /**
   * Specifies whether the built-in validation for incomplete dates is to be enforced when a form is being validated.
   *
   * @default false
   */
  incompleteDateValidation = false;
  /**
   * The maximum year to assume to be from the current century when typing two-digit year value
   * ([see example]({% slug formats_dateinput %}#toc-two-digit-year-format)).
   *
   * The default value is 68, indicating that typing any value less than 69
   * will be assumed to be 20xx, while 69 and larger will be assumed to be 19xx.
   * @default 68
   */
  twoDigitYearMax = TWO_DIGIT_YEAR_MAX$2;
  /**
   * Indicates whether the mouse scroll can be used to increase/decrease the time segments values.
   *
   * @default true
   */
  enableMouseWheel = true;
  /**
   * Specifies the value of the DateInput component.
   *
   * The `value` has to be a valid [JavaScript `Date`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date) instance or `null`.
   */
  set value(value2) {
    this.verifyValue(value2);
    this.showClearButton = value2 || !value2 && this.isDateIncomplete ? true : false;
    this._value = cloneDate(value2);
    this.valueUpdate.emit(cloneDate(value2));
  }
  get value() {
    return this._value;
  }
  /**
   * Specifies whether the **Up** and **Down** spin buttons will be rendered.
   * For more information, refer to the article on
   * [spinner buttons]({% slug spinbuttons_dateinput %}).
   *
   * @default false
   */
  spinners = false;
  /**
   * @hidden
   */
  isPopupOpen;
  /**
   * @hidden
   */
  hasPopup;
  /**
   * Specifies the size of the component.
   *
   * @default medium
   *
   */
  set size(size) {
    this.renderer.removeClass(this.wrapper.nativeElement, getSizeClass("input", this.size));
    const newSize = size || DEFAULT_SIZE;
    if (newSize !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getSizeClass("input", newSize));
    }
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * Specifies the border radius of the component.
   * @default 'medium'
   */
  set rounded(rounded) {
    this.renderer.removeClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
    const newRounded = rounded || DEFAULT_ROUNDED;
    if (newRounded !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(newRounded));
    }
    this._rounded = newRounded;
  }
  get rounded() {
    return this._rounded;
  }
  /**
   * Specifies the fillMode of the component.
   * @default 'solid'
   */
  set fillMode(fillMode) {
    this.renderer.removeClass(this.wrapper.nativeElement, getFillModeClass("input", this.fillMode));
    const newFillMode = fillMode || DEFAULT_FILL_MODE;
    if (newFillMode !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass("input", newFillMode));
      if (this.spinners && this.spinup && this.spindown) {
        this.setSpinnerFill(this.spinup.nativeElement, newFillMode, this.fillMode);
        this.setSpinnerFill(this.spindown.nativeElement, newFillMode, this.fillMode);
      }
    }
    this._fillMode = newFillMode;
  }
  get fillMode() {
    return this._fillMode;
  }
  /**
   * Specifies the HTML attributes of the inner focusable input element. Attributes which are essential for certain component functionalities cannot be changed.
   */
  set inputAttributes(attributes) {
    if (isObjectPresent(this.parsedAttributes)) {
      removeHTMLAttributes(this.parsedAttributes, this.renderer, this.dateInput.nativeElement);
    }
    this._inputAttributes = attributes;
    this.parsedAttributes = this.inputAttributes ? parseAttributes(this.inputAttributes, this.defaultAttributes) : this.inputAttributes;
    this.setInputAttributes();
  }
  get inputAttributes() {
    return this._inputAttributes;
  }
  /**
   * Fires each time the user selects a new value
   * ([see example](slug:events_dateinput)).
   */
  valueChange = new EventEmitter();
  /**
   * @hidden
   * Fires each time the user selects a new value
   * ([see example](slug:events_dateinput)).
   */
  valueUpdate = new EventEmitter();
  /**
   * Fires each time the user focuses the input element
   * ([see example](slug:events_dateinput)).
   */
  onFocus = new EventEmitter();
  /**
   * Fires each time the input element gets blurred
   * ([see example](slug:events_dateinput)).
   */
  onBlur = new EventEmitter();
  /**
   * @hidden
   */
  dateInput;
  get wrapperClass() {
    return true;
  }
  get disabledClass() {
    return this.disabled;
  }
  get inputElement() {
    return this.dateInput ? this.dateInput.nativeElement : null;
  }
  get inputValue() {
    return (this.inputElement || {}).value || "";
  }
  get isActive() {
    return this._active;
  }
  set isActive(value2) {
    this._active = value2;
    if (!this.wrapper) {
      return;
    }
    if (!isPresent4(this.pickerService)) {
      const element = this.wrapper.nativeElement;
      if (value2) {
        this.renderer.addClass(element, "k-focus");
      } else {
        this.renderer.removeClass(element, "k-focus");
      }
    }
  }
  /**
   * @hidden
   */
  get formControl() {
    const ngControl = this.injector.get(NgControl, null);
    return ngControl?.control || null;
  }
  get options() {
    return {
      format: this.format,
      steps: this.steps,
      readonly: this.readonly,
      formatPlaceholder: this.formatPlaceholder,
      placeholder: this.placeholder,
      autoCorrectParts: this.autoCorrectParts,
      autoSwitchParts: this.autoSwitchParts,
      selectPreviousSegmentOnBackspace: true,
      // matches current behavior -> Backspace moves to previous segment
      autoSwitchKeys: this.autoSwitchKeys,
      twoDigitYearMax: this.twoDigitYearMax,
      enableMouseWheel: this.enableMouseWheel,
      selectNearestSegmentOnFocus: true,
      allowCaretMode: this.allowCaretMode,
      autoFill: this.autoFill,
      value: this.value,
      intlService: new DateInputIntl(this.intl)
    };
  }
  arrow = Arrow;
  arrowDirection = Arrow.None;
  formatSections = {
    date: false,
    time: false
  };
  hasMousedown = false;
  focusedPriorToMousedown = false;
  showClearButton = false;
  /**
   * @hidden
   */
  isDateIncomplete = false;
  currentFormat = "";
  spinup;
  spindown;
  minValidator = noop$2;
  maxValidator = noop$2;
  incompleteValidator = noop$2;
  _value = null;
  _active = false;
  _focusableId = `dateinput-${nextId++}`;
  _formatPlaceholder = DEFAULT_FORMAT_PLACEHOLDER;
  kendoDate = null;
  kendoDateObject = null;
  domEvents = [];
  ngControl;
  onControlChange = noop$2;
  onControlTouched = noop$2;
  onValidatorChange = noop$2;
  _size = DEFAULT_SIZE;
  _rounded = DEFAULT_ROUNDED;
  _fillMode = DEFAULT_FILL_MODE;
  control;
  subs = new Subscription();
  _inputAttributes;
  parsedAttributes = {};
  get defaultAttributes() {
    return {
      "aria-readonly": this.ariaReadOnly,
      id: this.focusableId,
      title: this.title,
      tabindex: this.tabindex,
      disabled: this.disabled ? "" : null,
      readonly: this.readonly ? "" : null,
      placeholder: this.placeholder,
      "aria-expanded": this.isPopupOpen,
      "aria-haspopup": this.hasPopup,
      required: this.isControlRequired ? "" : null
    };
  }
  get mutableAttributes() {
    return {
      autocomplete: "off",
      autocorrect: "off",
      autocapitalize: "off",
      spellcheck: "false",
      role: this.role
    };
  }
  constructor(cdr, intl, renderer, wrapper, ngZone, injector, localization, pickerService) {
    this.cdr = cdr;
    this.intl = intl;
    this.renderer = renderer;
    this.wrapper = wrapper;
    this.ngZone = ngZone;
    this.injector = injector;
    this.localization = localization;
    this.pickerService = pickerService;
    N(packageMetadata);
    if (this.pickerService) {
      this.pickerService.input = this;
    } else {
      this.ariaReadOnly = null;
    }
  }
  /**
   * @hidden
   * Used by the TextBoxContainer to determine if the component is empty
   */
  isEmpty() {
    const currentValue = this.dateInput.nativeElement.value;
    return !currentValue || !String(currentValue).trim();
  }
  /**
   * @hidden
   */
  handleDragAndDrop(args) {
    args.preventDefault();
  }
  /**
   * @hidden
   */
  containsElement(element) {
    return Boolean(closest2(element, (node) => node === this.wrapper.nativeElement));
  }
  /**
   * @hidden
   */
  ngOnInit() {
    if (this.kendoDate) {
      this.kendoDate.destroy();
    }
    this.kendoDate = this.initKendoDate();
    this.kendoDateObject = this.kendoDate.dateObject;
    this.updateFormatSections();
    this.subs.add(this.intl.changes.subscribe(this.intlChange.bind(this)));
    this.ngControl = this.injector.get(NgControl, null);
    if (this.wrapper) {
      this.renderer.removeAttribute(this.wrapper.nativeElement, "tabindex");
    }
    this.minValidator = this.rangeValidation ? minValidator(this.min) : noop$2;
    this.maxValidator = this.rangeValidation ? maxValidator(this.max) : noop$2;
  }
  /**
   * @hidden
   */
  ngOnChanges(changes) {
    this.verifyRange();
    if (anyChanged(["min", "max", "rangeValidation", "incompleteDateValidation"], changes, false)) {
      this.minValidator = this.rangeValidation ? minValidator(this.min) : noop$2;
      this.maxValidator = this.rangeValidation ? maxValidator(this.max) : noop$2;
      this.incompleteValidator = this.incompleteDateValidation ? incompleteDateValidator() : noop$2;
      this.onValidatorChange();
    }
    if (changes["clearButton"]) {
      this.showClearButton = this.clearButton && (isPresent4(this.value) || this.isDateIncomplete);
    }
    const isEqualToKendoDate = this.kendoDate && isEqual(this.value, this.kendoDate.value);
    if (!isEqualToKendoDate) {
      if (!this.kendoDate) {
        return;
      }
      this.kendoDate.writeValue(this.value);
    }
    if (changes["format"] || changes["placeholder"]) {
      if (!this.kendoDate) {
        return;
      }
      this.kendoDate?.setOptions(this.options, true);
      this.updateFormatSections();
    }
    if (anyChanged(["enableMouseWheel", "autoFill", "autoSwitchParts", "autoSwitchKeys", "twoDigitYearMax", "allowCaretMode", "autoCorrectParts", "readonly", "steps", "formatPlaceholder"], changes)) {
      if (!this.kendoDate) {
        return;
      }
      this.kendoDate?.setOptions(this.options, true);
    }
  }
  updateFormatSections() {
    this.formatSections = this.intl.splitDateFormat(this.kendoDate.inputFormat).reduce(({
      date,
      time
    }, p) => {
      return {
        date: date || DATE_PART_REGEXP.test(p.type),
        time: time || TIME_PART_REGEXP.test(p.type)
      };
    }, {
      date: false,
      time: false
    });
  }
  updateIncompleteValidationStatus() {
    const previousValue = this.isDateIncomplete;
    this.isDateIncomplete = this.kendoDateObject.hasValue() && this.value === null;
    if (previousValue === this.isDateIncomplete || !this.incompleteDateValidation) {
      return;
    }
    if (isPresent4(this.ngControl) && !isPresent4(this.pickerService)) {
      this.cdr.markForCheck();
      this.ngZone.run(() => this.onValidatorChange());
    } else if (isPresent4(this.pickerService)) {
      this.pickerService.dateCompletenessChange.emit();
    }
  }
  ngAfterViewInit() {
    this.setComponentClasses();
    const formControl = this.injector.get(NgControl, null)?.control;
    this.control = formControl;
    this.subs.add(this.formControl?.statusChanges.subscribe(() => this.setAriaInvalid()));
    this.setAriaInvalid();
    this.subs.add(this.renderer.listen(this.dateInput?.nativeElement, "keydown", this.handleKeyDown));
  }
  ngOnDestroy() {
    this.subs.unsubscribe();
    if (this.pickerService) {
      this.pickerService.input = null;
    }
    this.domEvents.forEach((unbindCallback) => unbindCallback());
  }
  /**
   * @hidden
   */
  setAriaInvalid() {
    if (!this.control) {
      return;
    }
    if (this.control.invalid) {
      this.renderer.setAttribute(this.inputElement, attributeNames.ariaInvalid, "true");
    } else {
      this.renderer.setAttribute(this.inputElement, attributeNames.ariaInvalid, "false");
    }
  }
  /**
   * @hidden
   */
  get isControlRequired() {
    return isControlRequired(this.formControl) || this.isRequired;
  }
  /**
   * @hidden
   */
  validate(control) {
    return this.minValidator(control) || this.maxValidator(control) || this.incompleteValidator(control, this.isDateIncomplete);
  }
  /**
   * @hidden
   */
  registerOnValidatorChange(fn) {
    this.onValidatorChange = fn;
  }
  /**
   * @hidden
   */
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
    this.cdr.markForCheck();
  }
  //ngModel binding
  /**
   * @hidden
   */
  writeValue(value2) {
    this.verifyValue(value2);
    this.value = cloneDate(value2);
    this.kendoDate?.setOptions(this.options, true);
    this.kendoDateObject?.setValue(this.value);
    this.kendoDate?.refreshElementValue();
  }
  resetInput() {
    this.isDateIncomplete = false;
    this.writeValue(null);
    this.notify();
    this.showClearButton = false;
  }
  /**
   * @hidden
   */
  triggerChange() {
    const value2 = this.kendoDate.value;
    const oneValuePresent = isPresent4(value2) !== isPresent4(this.value);
    if (+value2 !== +this.value || oneValuePresent) {
      this.value = cloneDate(value2);
      this.notify();
    }
  }
  /**
   * @hidden
   */
  notify() {
    this.ngZone.run(() => {
      this.showClearButton = this.value ? true : false;
      this.onControlChange(cloneDate(this.value));
      this.valueChange.emit(cloneDate(this.value));
    });
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.onControlChange = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.onControlTouched = fn;
  }
  /**
   * Focuses the DateInput component.
   *
   */
  focus() {
    this.kendoDate?.focus();
  }
  /**
   * Blurs the DateInput component.
   */
  blur() {
    const input = this.inputElement;
    if (input) {
      input.blur();
    }
  }
  /**
   * @hidden
   */
  handleButtonClick(offset3) {
    this.showClearButton = true;
    this.arrowDirection = Arrow.None;
    if (!this.isActive) {
      this.kendoDate.focus();
    }
    this.kendoDate.modifyDateSegmentValue(offset3);
  }
  initKendoDate() {
    const kendoDate = new DateInput(this.dateInput.nativeElement, __spreadProps(__spreadValues({}, this.options), {
      events: {
        valueChange: this.onWidgetValueChange.bind(this),
        inputEnd: this.onWidgetInputEnd.bind(this),
        focusEnd: this.onWidgetFocus.bind(this),
        blurEnd: this.onWidgetBlur.bind(this),
        keydown: this.onWidgetKeyDown.bind(this)
      }
    }));
    return kendoDate;
  }
  onWidgetValueChange() {
    this.triggerChange();
  }
  onWidgetKeyDown() {
    this.kendoDateObject = this.kendoDate.dateObject;
  }
  onWidgetInputEnd() {
    this.updateIncompleteValidationStatus();
    if (this.clearButton) {
      this.showClearButton = this.value || this.isDateIncomplete ? true : false;
      this.cdr.markForCheck();
    }
  }
  onWidgetFocus(args) {
    this.isActive = true;
    if (hasObservers(this.onFocus)) {
      this.ngZone.run(() => {
        this.emitFocus(args.event);
      });
    } else {
      this.emitFocus(args.event);
    }
  }
  onWidgetBlur(args) {
    this.isActive = false;
    if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.ngControl)) {
      this.ngZone.run(() => {
        this.onControlTouched();
        this.emitBlur(args.event);
        this.cdr.markForCheck();
      });
    } else {
      this.emitBlur(args.event);
    }
  }
  handleKeyDown(event) {
    if (!isPresent4(event.keyCode)) {
      event.stopImmediatePropagation();
    }
  }
  verifyRange() {
    if (!isDevMode()) {
      return;
    }
    if (!isValidRange(this.min, this.max)) {
      throw new Error(`The max value should be bigger than the min. See ${MIN_DOC_LINK$1} and ${MAX_DOC_LINK$1}.`);
    }
  }
  verifyValue(value2) {
    if (!isDevMode()) {
      return;
    }
    if (value2 && !(value2 instanceof Date)) {
      throw new Error(`The 'value' should be a valid JavaScript Date instance or null. Check ${VALUE_DOC_LINK$3} for possible resolution.`);
    }
  }
  intlChange() {
    this.kendoDate.setOptions(this.options, true);
    this.updateFormatSections();
  }
  emitFocus(args) {
    this.onFocus.emit();
    if (this.pickerService) {
      this.pickerService.onFocus.emit(args);
    }
  }
  emitBlur(args) {
    this.onBlur.emit();
    if (this.pickerService) {
      this.pickerService.onBlur.emit(args);
    }
  }
  setSpinnerFill(spinner, fill, oldFill) {
    if (oldFill !== "none") {
      this.renderer.removeClass(spinner, `k-button-${oldFill}`);
      this.renderer.removeClass(spinner, `k-button-${oldFill}-base`);
    }
    this.renderer.addClass(spinner, `k-button-${fill}`);
    this.renderer.addClass(spinner, `k-button-${fill}-base`);
  }
  setComponentClasses() {
    if (this.size !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getSizeClass("input", this.size));
    }
    if (this.rounded !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
    }
    if (this.fillMode !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass("input", this.fillMode));
    }
    if (this.spinners && this.fillMode !== "none") {
      this.setSpinnerFill(this.spinup.nativeElement, this.fillMode);
      this.setSpinnerFill(this.spindown.nativeElement, this.fillMode);
    }
  }
  setInputAttributes() {
    const attributesToRender = __spreadValues(__spreadValues({}, this.mutableAttributes), this.parsedAttributes);
    setHTMLAttributes(attributesToRender, this.renderer, this.dateInput.nativeElement, this.ngZone);
  }
  static ɵfac = function DateInputComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DateInputComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(PickerService, 8));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DateInputComponent,
    selectors: [["kendo-dateinput"]],
    viewQuery: function DateInputComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c10, 7)(_c11, 5)(_c12, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dateInput = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.spinup = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.spindown = _t.first);
      }
    },
    hostVars: 8,
    hostBindings: function DateInputComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-readonly", ctx.readonly)("k-input", ctx.wrapperClass)("k-dateinput", ctx.wrapperClass)("k-disabled", ctx.disabledClass);
      }
    },
    inputs: {
      focusableId: "focusableId",
      pickerType: "pickerType",
      clearButton: "clearButton",
      disabled: "disabled",
      readonly: "readonly",
      title: "title",
      tabindex: "tabindex",
      role: "role",
      ariaReadOnly: "ariaReadOnly",
      tabIndex: "tabIndex",
      isRequired: "isRequired",
      format: "format",
      formatPlaceholder: "formatPlaceholder",
      placeholder: "placeholder",
      steps: "steps",
      max: "max",
      min: "min",
      rangeValidation: "rangeValidation",
      autoCorrectParts: "autoCorrectParts",
      autoSwitchParts: "autoSwitchParts",
      autoSwitchKeys: "autoSwitchKeys",
      allowCaretMode: "allowCaretMode",
      autoFill: "autoFill",
      incompleteDateValidation: "incompleteDateValidation",
      twoDigitYearMax: "twoDigitYearMax",
      enableMouseWheel: "enableMouseWheel",
      value: "value",
      spinners: "spinners",
      isPopupOpen: "isPopupOpen",
      hasPopup: "hasPopup",
      size: "size",
      rounded: "rounded",
      fillMode: "fillMode",
      inputAttributes: "inputAttributes"
    },
    outputs: {
      valueChange: "valueChange",
      valueUpdate: "valueUpdate",
      onFocus: "focus",
      onBlur: "blur"
    },
    exportAs: ["kendo-dateinput"],
    features: [ɵɵProvidersFeature([{
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _DateInputComponent),
      multi: true
    }, {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => _DateInputComponent),
      multi: true
    }, {
      provide: L10N_PREFIX,
      useValue: "kendo.dateinput"
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _DateInputComponent)
    }, LocalizationService]), ɵɵNgOnChangesFeature],
    decls: 5,
    vars: 18,
    consts: () => {
      let i18n_8;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_8 = goog.getMsg("Increase value");
        i18n_8 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_8;
      } else {
        i18n_8 = $localize`:kendo.dateinput.increment|The label for the **Increment** button in the DateInput:Increase value`;
      }
      let i18n_9;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_9 = goog.getMsg("Decrease value");
        i18n_9 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_9;
      } else {
        i18n_9 = $localize`:kendo.dateinput.decrement|The label for the **Decrement** button in the DateInput:Decrease value`;
      }
      let i18n_10;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_10 = goog.getMsg("clear");
        i18n_10 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_10;
      } else {
        i18n_10 = $localize`:kendo.dateinput.clearTitle|The title of the clear button:clear`;
      }
      return [["dateInput", ""], ["spinup", ""], ["spindown", ""], ["kendoDateInputLocalizedMessages", "", "increment", i18n_8, "decrement", i18n_9, "clearTitle", i18n_10], ["autocomplete", "off", "autocorrect", "off", "autocapitalize", "off", "spellcheck", "false", 1, "k-input-inner", 3, "id", "title", "tabindex", "disabled", "readonly", "kendoEventsOutsideAngular", "scope"], ["role", "button", "tabindex", "-1", 1, "k-clear-value"], [1, "k-input-spinner", "k-spin-button"], ["role", "button", "tabindex", "-1", 1, "k-clear-value", 3, "click", "mousedown"], ["name", "x", 3, "svgIcon"], [1, "k-input-spinner", "k-spin-button", 3, "mousedown"], ["tabindex", "-1", 1, "k-spinner-increase", "k-button", "k-icon-button", 3, "mousedown", "mouseleave", "click", "title"], ["name", "caret-alt-up", "innerCssClass", "k-button-icon", 3, "svgIcon"], ["tabindex", "-1", 1, "k-spinner-decrease", "k-button", "k-icon-button", 3, "click", "mousedown", "mouseleave", "title"], ["name", "caret-alt-down", "innerCssClass", "k-button-icon", 3, "svgIcon"]];
    },
    template: function DateInputComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainer(0, 3);
        ɵɵelement(1, "input", 4, 0);
        ɵɵconditionalCreate(3, DateInputComponent_Conditional_3_Template, 2, 2, "span", 5);
        ɵɵconditionalCreate(4, DateInputComponent_Conditional_4_Template, 7, 10, "span", 6);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("id", ctx.focusableId)("title", ctx.title)("tabindex", ctx.tabindex)("disabled", ctx.disabled)("readonly", ctx.readonly)("kendoEventsOutsideAngular", ɵɵpureFunction2(15, _c13, ctx.handleDragAndDrop, ctx.handleDragAndDrop))("scope", ctx);
        ɵɵattribute("required", ctx.isControlRequired ? "" : null)("role", ctx.role)("aria-readonly", ctx.ariaReadOnly)("placeholder", ctx.placeholder)("aria-expanded", ctx.isPopupOpen)("aria-haspopup", ctx.hasPopup);
        ɵɵadvance(2);
        ɵɵconditional(ctx.clearButton && ctx.showClearButton ? 3 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.spinners ? 4 : -1);
      }
    },
    dependencies: [DateInputLocalizedMessagesDirective, EventsOutsideAngularDirective, IconWrapperComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateInputComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      exportAs: "kendo-dateinput",
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => DateInputComponent),
        multi: true
      }, {
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => DateInputComponent),
        multi: true
      }, {
        provide: L10N_PREFIX,
        useValue: "kendo.dateinput"
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => DateInputComponent)
      }, LocalizationService],
      selector: "kendo-dateinput",
      template: `
    <ng-container kendoDateInputLocalizedMessages
      i18n-increment="kendo.dateinput.increment|The label for the **Increment** button in the DateInput"
      increment="Increase value"
    
      i18n-decrement="kendo.dateinput.decrement|The label for the **Decrement** button in the DateInput"
      decrement="Decrease value"
    
      i18n-clearTitle="kendo.dateinput.clearTitle|The title of the clear button"
      clearTitle="clear"
      >
    </ng-container>
    <input #dateInput
      class="k-input-inner"
      [attr.required]="isControlRequired ? '' : null"
      autocomplete="off"
      autocorrect="off"
      autocapitalize="off"
      spellcheck="false"
      [attr.role]="role"
      [attr.aria-readonly]="ariaReadOnly"
      [id]="focusableId"
      [title]="title"
      [tabindex]="tabindex"
      [disabled]="disabled"
      [readonly]="readonly"
      [attr.placeholder]="placeholder"
      [attr.aria-expanded]="isPopupOpen"
      [attr.aria-haspopup]="hasPopup"
        [kendoEventsOutsideAngular]="{
            dragstart: handleDragAndDrop,
            drop: handleDragAndDrop
        }"
      [scope]="this"
      />
    @if (clearButton && showClearButton) {
      <span
        class="k-clear-value"
        [attr.title]="localization.get('clearTitle')"
        role="button"
        tabindex="-1"
        (click)="resetInput()"
        (mousedown)="$event.preventDefault()"
        >
        <kendo-icon-wrapper
          name="x"
          [svgIcon]="xIcon"
          >
        </kendo-icon-wrapper>
      </span>
    }
    @if (spinners) {
      <span class="k-input-spinner k-spin-button" (mousedown)="$event.preventDefault()">
        <button
          #spinup
          tabindex="-1"
          class="k-spinner-increase k-button k-icon-button"
          [class.k-active]="arrowDirection === arrow.Up"
          (mousedown)="arrowDirection = arrow.Up"
          (mouseleave)="arrowDirection = arrow.None"
          (click)="handleButtonClick(1)"
          [title]="localization.get('increment')"
          [attr.aria-label]="localization.get('increment')"
          >
          <kendo-icon-wrapper
            name="caret-alt-up"
            [svgIcon]="caretAltUpIcon"
            innerCssClass="k-button-icon"
            >
          </kendo-icon-wrapper>
        </button>
        <button
          #spindown
          tabindex="-1"
          class="k-spinner-decrease k-button k-icon-button"
          (click)="handleButtonClick(-1)"
          [class.k-active]="arrowDirection === arrow.Down"
          (mousedown)="arrowDirection = arrow.Down"
          (mouseleave)="arrowDirection = arrow.None"
          [title]="localization.get('decrement')"
          [attr.aria-label]="localization.get('decrement')"
          >
          <kendo-icon-wrapper
            name="caret-alt-down"
            [svgIcon]="caretAltDownIcon"
            innerCssClass="k-button-icon"
            >
          </kendo-icon-wrapper>
        </button>
      </span>
    }
    `,
      standalone: true,
      imports: [DateInputLocalizedMessagesDirective, EventsOutsideAngularDirective, IconWrapperComponent]
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: IntlService
  }, {
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: NgZone
  }, {
    type: Injector
  }, {
    type: LocalizationService
  }, {
    type: PickerService,
    decorators: [{
      type: Optional
    }]
  }], {
    focusableId: [{
      type: Input
    }],
    pickerType: [{
      type: Input
    }],
    clearButton: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-readonly"]
    }],
    title: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    role: [{
      type: Input
    }],
    ariaReadOnly: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    isRequired: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    formatPlaceholder: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    steps: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    rangeValidation: [{
      type: Input
    }],
    autoCorrectParts: [{
      type: Input
    }],
    autoSwitchParts: [{
      type: Input
    }],
    autoSwitchKeys: [{
      type: Input
    }],
    allowCaretMode: [{
      type: Input
    }],
    autoFill: [{
      type: Input
    }],
    incompleteDateValidation: [{
      type: Input
    }],
    twoDigitYearMax: [{
      type: Input
    }],
    enableMouseWheel: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    spinners: [{
      type: Input
    }],
    isPopupOpen: [{
      type: Input
    }],
    hasPopup: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }],
    fillMode: [{
      type: Input
    }],
    inputAttributes: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    valueUpdate: [{
      type: Output
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    dateInput: [{
      type: ViewChild,
      args: ["dateInput", {
        static: true
      }]
    }],
    wrapperClass: [{
      type: HostBinding,
      args: ["class.k-input"]
    }, {
      type: HostBinding,
      args: ["class.k-dateinput"]
    }],
    disabledClass: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    spinup: [{
      type: ViewChild,
      args: ["spinup", {
        static: false
      }]
    }],
    spindown: [{
      type: ViewChild,
      args: ["spindown", {
        static: false
      }]
    }]
  });
})();
var PreventableEvent2 = class {
  prevented = false;
  /** @hidden */
  constructor() {
  }
  /**
   * Prevents the default action for a specified event.
   * In this way, the source component suppresses the built-in behavior that follows the event.
   */
  preventDefault() {
    this.prevented = true;
  }
  /**
   * If the event is prevented by any of its subscribers, returns `true`.
   *
   * @returns `true` if the default action was prevented. Otherwise, returns `false`.
   */
  isDefaultPrevented() {
    return this.prevented;
  }
};
var disabledDatesValidator = (isDateDisabled) => {
  return (control) => {
    if (!isDateDisabled || !control.value) {
      return null;
    }
    const error = {
      disabledDate: true
    };
    return isDateDisabled(control.value) ? error : null;
  };
};
var CalendarCustomMessagesComponent = class _CalendarCustomMessagesComponent extends CalendarMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function CalendarCustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CalendarCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _CalendarCustomMessagesComponent,
    selectors: [["kendo-calendar-messages"]],
    features: [ɵɵProvidersFeature([{
      provide: CalendarMessages,
      useExisting: forwardRef(() => _CalendarCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function CalendarCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: CalendarMessages,
        useExisting: forwardRef(() => CalendarCustomMessagesComponent)
      }],
      selector: "kendo-calendar-messages",
      template: ``,
      standalone: true
    }]
  }], () => [{
    type: LocalizationService
  }], null);
})();
var DateInputCustomMessagesComponent = class _DateInputCustomMessagesComponent extends DateInputMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function DateInputCustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DateInputCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DateInputCustomMessagesComponent,
    selectors: [["kendo-dateinput-messages"]],
    features: [ɵɵProvidersFeature([{
      provide: DateInputMessages,
      useExisting: forwardRef(() => _DateInputCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DateInputCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateInputCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: DateInputMessages,
        useExisting: forwardRef(() => DateInputCustomMessagesComponent)
      }],
      selector: "kendo-dateinput-messages",
      template: ``,
      standalone: true
    }]
  }], () => [{
    type: LocalizationService
  }], null);
})();
var DatePickerMessages = class _DatePickerMessages extends ComponentMessages {
  /**
   * The **Today** button text in the header of the Calendar.
   */
  today;
  /**
   * The title of the **Toggle** button of the DatePicker.
   */
  toggle;
  /**
   * The title of the **Prev** button in the header of the Classic Calendar.
   */
  prevButtonTitle;
  /**
   * The title of the **Next** button in the header of the Classic Calendar.
   */
  nextButtonTitle;
  /**
   * The title of the **Parent View** button in the header of the Calendar.
   */
  parentViewButtonTitle;
  /**
   * The title of the **Clear** button of the DatePicker.
   */
  clearTitle;
  /**
   * The title of the Close button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode.
   */
  adaptiveCloseButtonTitle;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵDatePickerMessages_BaseFactory;
    return function DatePickerMessages_Factory(__ngFactoryType__) {
      return (ɵDatePickerMessages_BaseFactory || (ɵDatePickerMessages_BaseFactory = ɵɵgetInheritedFactory(_DatePickerMessages)))(__ngFactoryType__ || _DatePickerMessages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _DatePickerMessages,
    selectors: [["kendo-datepicker-messages-base"]],
    inputs: {
      today: "today",
      toggle: "toggle",
      prevButtonTitle: "prevButtonTitle",
      nextButtonTitle: "nextButtonTitle",
      parentViewButtonTitle: "parentViewButtonTitle",
      clearTitle: "clearTitle",
      adaptiveCloseButtonTitle: "adaptiveCloseButtonTitle"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatePickerMessages, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line
      selector: "kendo-datepicker-messages-base"
    }]
  }], null, {
    today: [{
      type: Input
    }],
    toggle: [{
      type: Input
    }],
    prevButtonTitle: [{
      type: Input
    }],
    nextButtonTitle: [{
      type: Input
    }],
    parentViewButtonTitle: [{
      type: Input
    }],
    clearTitle: [{
      type: Input
    }],
    adaptiveCloseButtonTitle: [{
      type: Input
    }]
  });
})();
var DatePickerLocalizedMessagesDirective = class _DatePickerLocalizedMessagesDirective extends DatePickerMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function DatePickerLocalizedMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DatePickerLocalizedMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DatePickerLocalizedMessagesDirective,
    selectors: [["", "kendoDatePickerLocalizedMessages", ""]],
    features: [ɵɵProvidersFeature([{
      provide: DatePickerMessages,
      useExisting: forwardRef(() => _DatePickerLocalizedMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatePickerLocalizedMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: DatePickerMessages,
        useExisting: forwardRef(() => DatePickerLocalizedMessagesDirective)
      }],
      selector: "[kendoDatePickerLocalizedMessages]",
      standalone: true
    }]
  }], () => [{
    type: LocalizationService
  }], null);
})();
var MIN_DOC_LINK = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/api/DatePickerComponent/#toc-min";
var MAX_DOC_LINK = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/api/DatePickerComponent/#toc-max";
var VALUE_DOC_LINK$2 = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/datepicker/#toc-using-with-json";
var DEFAULT_FORMAT = "d";
var TWO_DIGIT_YEAR_MAX$1 = 68;
var DatePickerComponent = class _DatePickerComponent extends MultiTabStop {
  zone;
  localization;
  cdr;
  popupService;
  wrapper;
  renderer;
  injector;
  pickerService;
  disabledDatesService;
  adaptiveService;
  /**
   * @hidden
   */
  calendarIcon = calendarIcon;
  container;
  popupTemplate;
  toggleButton;
  actionSheet;
  /**
   * @hidden
   */
  focusableId;
  /**
   * @hidden
   */
  cellTemplate;
  /**
   * @hidden
   */
  set cellTemplateRef(template) {
    this.cellTemplate = template;
  }
  /**
   * Renders a clear button when set to `true` after the input text or DatePicker value changes.
   * Click this button to reset the component value to `null` and trigger the `valueChange` event.
   * @default false
   */
  clearButton = false;
  /**
   * Specifies the HTML attributes of the inner focusable input element.
   * You cannot change attributes that are essential for certain component functionalities.
   */
  inputAttributes;
  /**
   * @hidden
   */
  monthCellTemplate;
  /**
   * @hidden
   */
  set monthCellTemplateRef(template) {
    this.monthCellTemplate = template;
  }
  /**
   * @hidden
   */
  yearCellTemplate;
  /**
   * @hidden
   */
  set yearCellTemplateRef(template) {
    this.yearCellTemplate = template;
  }
  /**
   * @hidden
   */
  decadeCellTemplate;
  /**
   * @hidden
   */
  set decadeCellTemplateRef(template) {
    this.decadeCellTemplate = template;
  }
  /**
   * @hidden
   */
  centuryCellTemplate;
  /**
   * @hidden
   */
  set centuryCellTemplateRef(template) {
    this.centuryCellTemplate = template;
  }
  /**
   * @hidden
   */
  weekNumberTemplate;
  /**
   * @hidden
   */
  set weekNumberTemplateRef(template) {
    this.weekNumberTemplate = template;
  }
  /**
   * @hidden
   */
  headerTitleTemplate;
  /**
   * @hidden
   */
  set headerTitleTemplateRef(template) {
    this.headerTitleTemplate = template;
  }
  /**
   * @hidden
   */
  headerTemplate;
  /**
   * @hidden
   */
  set headerTemplateRef(template) {
    this.headerTemplate = template;
  }
  /**
   * @hidden
   */
  footerTemplate;
  /**
   * @hidden
   */
  set footerTemplateRef(template) {
    this.footerTemplate = template;
  }
  /**
   * Controls the visibility of the Calendar footer.
   * @default false
   */
  footer = false;
  /**
   * @hidden
   */
  navigationItemTemplate;
  /**
   * @hidden
   */
  set navigationItemTemplateRef(template) {
    this.navigationItemTemplate = template;
  }
  /**
   * Specifies the format of the displayed Calendar week days' names.
   * @default 'short'
   */
  weekDaysFormat = "short";
  /**
   * Shows the days that fall outside the current month in the Calendar ([see example]({% slug viewoptions_calendar %}#toc-displaying-other-month-days)).
   * The default value is `false` for infinite Calendar type and `true` for classic Calendar type.
   */
  showOtherMonthDays;
  /**
   * Specifies the active view that the Calendar initially renders ([see example]({% slug viewoptions_calendar %}#toc-active-view)).
   *
   * You have to set `activeView` within the `topView`-`bottomView` range.
   * @default 'month'
   */
  activeView = CalendarViewEnum[CalendarViewEnum.month];
  /**
   * Specifies the bottommost Calendar view to which you can navigate ([see example](slug:datepicker_calendar_options#toc-view-selection-depth)).
   * @default 'month'
   */
  bottomView = CalendarViewEnum[CalendarViewEnum.month];
  /**
   * Specifies the topmost Calendar view to which you can navigate ([see example](slug:datepicker_calendar_options#toc-view-selection-depth)).
   * @default 'century'
   */
  topView = CalendarViewEnum[CalendarViewEnum.century];
  /**
   * Specifies the Calendar type.
   * @default 'infinite'
   */
  calendarType = "infinite";
  /**
   * Determines whether to enable animation when navigating to previous/next Calendar view.
   * Applies to the [`classic`]({% slug api_dateinputs_datepickercomponent %}#toc-calendartype) Calendar only.
   *
   * This feature uses the [Web Animations API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API). In order to run the animation in browsers that do not support it, you need the `web-animations-js` polyfill.
   *
   * @default false
   */
  animateCalendarNavigation = false;
  /**
   * Specifies or gets the `disabled` property of the DatePicker and determines whether the component is active ([see example]({% slug disabled_datepicker %})).
   * To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_datepicker#toc-managing-the-datepicker-disabled-state-in-reactive-forms).
   */
  disabled = false;
  /**
   * Specifies the read-only state of the DatePicker ([see example]({% slug readonly_datepicker %}#toc-read-only-datepicker)).
   *
   * @default false
   */
  readonly = false;
  /**
   * Sets the read-only state of the DatePicker input field
   * ([see example]({% slug readonly_datepicker %}#toc-read-only-input)).
   *
   * If you set the [`readonly`]({% slug api_dateinputs_datepickercomponent %}#toc-readonly) property value to `true`,
   * the input will be rendered in a read-only state regardless of the `readOnlyInput` value.
   */
  readOnlyInput = false;
  /**
   * Configures the popup options of the DatePicker.
   *
   * The available options are animate which controls the popup animation and by default, the open and close animations are enabled.
   * The appendTo option controls the popup container and by default, the popup will be appended to the root component.
   * The popupClass option specifies a list of CSS classes that are used to style the popup.
   */
  set popupSettings(settings) {
    this._popupSettings = __spreadValues({
      animate: true
    }, settings);
  }
  get popupSettings() {
    return this._popupSettings;
  }
  /**
   * Sets or gets the `navigation` property of the Calendar
   * and determines whether the navigation side-bar is displayed.
   * ([see example]({% slug sidebar_datepicker %})).
   */
  set navigation(state2) {
    this._navigation = state2;
  }
  get navigation() {
    if (this.isAdaptive) {
      return;
    }
    return this._navigation;
  }
  _navigation = true;
  /**
   * Specifies the smallest valid date
   * ([see example]({% slug dateranges_datepicker %})).
   * @default 1900-1-1
   */
  min = cloneDate(MIN_DATE);
  /**
   * Specifies the biggest valid date
   * ([see example]({% slug dateranges_datepicker %})).
   * @default 2099-12-31
   */
  max = cloneDate(MAX_DATE);
  /**
   * Determines whether the built-in validation for incomplete dates is to be enforced when a form is being validated.
   * @default false
   */
  incompleteDateValidation = false;
  /**
   * Determines whether to autocorrect invalid segments automatically.
   *
   * @default true
   */
  autoCorrectParts = true;
  /**
   * Determines whether to automatically move to the next segment after the user completes the current one.
   *
   * @default true
   */
  autoSwitchParts = true;
  /**
   * A string array representing custom keys, which will move the focus to the next date format segment.
   */
  autoSwitchKeys = [];
  /**
   * Indicates whether the mouse scroll can be used to increase/decrease the time segments values.
   *
   * @default true
   */
  enableMouseWheel = true;
  /**
   * Determines if the users should see a blinking caret inside the Date Input when possible.
   *
   * @default false
   */
  allowCaretMode = false;
  /**
   * When enabled, the DatePicker will autofill the rest of the date to the current date when the component loses focus.
   *
   * @default false
   */
  autoFill = false;
  /**
   * Specifies the focused date of the Calendar component
   * ([see example](slug:datepicker_calendar_options#toc-focused-dates)).
   * @default null
   */
  focusedDate = null;
  /**
   * Specifies the value of the DatePicker component.
   *
   * The `value` has to be a valid [JavaScript `Date`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date) instance or `null`.
   */
  set value(value2) {
    this.verifyValue(value2);
    this._value = cloneDate(value2);
  }
  get value() {
    return this._value;
  }
  /**
   * Specifies the date format that is used to display the input value
   * ([see example]({% slug formats_datepicker %})).
   *
   * Format value options include string to provide a single format that is used regardless whether the input is focused or blurred.
   * FormatSettings can be used to display different formats when the component is focused or blurred by providing a settings object with specified inputFormat and displayFormat values.
   */
  format = DEFAULT_FORMAT;
  /**
   * The maximum year to assume to be from the current century when typing two-digit year value
   * ([see example]({% slug formats_datepicker %}#toc-two-digit-year-format)).
   *
   * The default value is 68, indicating that typing any value less than 69
   * will be assumed to be 20xx, while 69 and larger will be assumed to be 19xx.
   * @default 68
   */
  twoDigitYearMax = TWO_DIGIT_YEAR_MAX$1;
  /**
   * Defines the descriptions of the format sections in the input field.
   * ([more information and examples]({% slug placeholders_datepicker %})).
   *
   */
  formatPlaceholder;
  /**
   * Specifies the hint the DatePicker displays when its value is `null`.
   * ([more information and exaples]({% slug placeholders_datepicker %})).
   */
  placeholder;
  /**
   * Sets the `tabindex` of the DatePicker.
   * This property is used to set the order in which the DatePicker will receive focus when navigating through the page using the Tab key.
   * @default 0
   */
  tabindex = 0;
  /**
   * @hidden
   */
  set tabIndex(tabIndex) {
    this.tabindex = tabIndex;
  }
  get tabIndex() {
    return this.tabindex;
  }
  /**
   * Sets the dates of the DatePicker that will be disabled
   * ([see example]({% slug disabled_dates_datepicker %})).
   */
  set disabledDates(value2) {
    this._disabledDates = value2;
    this.disabledDatesService.initialize(value2);
  }
  get disabledDates() {
    return this._disabledDates;
  }
  /**
   * Sets the title of the input element of the DatePicker and the title text rendered
   * in the header of the popup(action sheet). Applicable only when [`AdaptiveMode` is set to `auto`](slug:api_dateinputs_adaptivemode).
   * @default ""
   */
  adaptiveTitle = "";
  /**
   * Sets the subtitle text rendered in the header of the popup(action sheet).
   * Applicable only when [`AdaptiveMode` is set to `auto`](slug:api_dateinputs_adaptivemode).
   * @default ""
   */
  adaptiveSubtitle = "";
  /**
   * Determines whether the built-in min or max validators are enforced when validating a form.
   *
   * @default true
   */
  rangeValidation = true;
  /**
   * Determines whether the built-in validator for disabled
   * date ranges is enforced when validating a form
   * ([see example]( slug:disabled_dates_datepicker#toc-using-a-function)).
   * @default true
   */
  disabledDatesValidation = true;
  /**
   * Determines whether to display a week number column in the `month` view of the Calendar
   * ([see example](slug:datepicker_calendar_options#toc-week-number-column)).
   * @default false
   */
  weekNumber = false;
  /**
   * Sets the size of the component.
   * @default 'medium'
   */
  set size(size) {
    this.renderer.removeClass(this.wrapper.nativeElement, getSizeClass("input", this.size));
    this.renderer.removeClass(this.toggleButton.nativeElement, getSizeClass("button", this.size));
    const newSize = size || DEFAULT_SIZE;
    if (newSize !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getSizeClass("input", newSize));
      this.renderer.addClass(this.toggleButton.nativeElement, getSizeClass("button", newSize));
    }
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * Specifies the border radius of the component.
   * @default 'medium'
   */
  set rounded(rounded) {
    this.renderer.removeClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
    const newRounded = rounded || DEFAULT_ROUNDED;
    if (newRounded !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(newRounded));
    }
    this._rounded = newRounded;
  }
  get rounded() {
    return this._rounded;
  }
  /**
   * Specifies the fillMode of the component.
   * @default 'solid'
   */
  set fillMode(fillMode) {
    this.renderer.removeClass(this.wrapper.nativeElement, getFillModeClass("input", this.fillMode));
    this.renderer.removeClass(this.toggleButton.nativeElement, getFillModeClass("button", this.fillMode));
    this.renderer.removeClass(this.toggleButton.nativeElement, `k-button-${this.fillMode}-base`);
    const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE;
    if (newFillMode !== "none") {
      this.renderer.addClass(this.toggleButton.nativeElement, getFillModeClass("button", newFillMode));
      this.renderer.addClass(this.toggleButton.nativeElement, `k-button-${newFillMode}-base`);
      this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass("input", newFillMode));
    }
    this._fillMode = newFillMode;
  }
  get fillMode() {
    return this._fillMode;
  }
  /**
   * Specifies whether to enable adaptive rendering. When enabled, the DatePicker automatically switches between a calendar popup on larger screens and an ActionSheet on mobile devices.
   *
   * @default 'none'
   */
  adaptiveMode = "none";
  /**
   * Fires each time the user selects a new value
   * ([see example](slug:events_datepicker)).
   */
  valueChange = new EventEmitter();
  /**
   * Fires each time the user focuses the input element
   * ([see example](slug:events_datepicker)).
   */
  onFocus = new EventEmitter();
  /**
   * Fires each time the input element gets blurred
   * ([see example](slug:events_datepicker)).
   */
  onBlur = new EventEmitter();
  /**
   * Fires each time the popup is about to open
   * ([see example](slug:events_datepicker)).
   * This event is preventable. If you cancel the event, the popup will remain closed.
   */
  open = new EventEmitter();
  /**
   * Fires each time the popup is about to close
   * ([see example](slug:events_datepicker)).
   * This event is preventable. If you cancel the event, the popup will remain open.
   */
  close = new EventEmitter();
  /**
   * @hidden
   */
  escape = new EventEmitter();
  /**
   * @hidden
   */
  wrapperClasses = true;
  /**
   * @hidden
   */
  get disabledClass() {
    return this.disabled;
  }
  get popupUID() {
    return this.calendar?.popupId;
  }
  popupRef;
  get isActive() {
    return this._active;
  }
  set isActive(value2) {
    this._active = value2;
    if (!this.wrapper) {
      return;
    }
    const element = this.wrapper.nativeElement;
    if (value2) {
      this.renderer.addClass(element, "k-focus");
    } else {
      this.renderer.removeClass(element, "k-focus");
    }
  }
  get show() {
    return this._show;
  }
  set show(show) {
    if (show && (this.disabled || this.readonly)) {
      return;
    }
    const skipZone = !show && (!this._show || !hasObservers(this.close) && !hasObservers(this.open));
    if (!skipZone) {
      this.zone.run(() => {
        const event = new PreventableEvent2();
        if (!this._show && show) {
          this.open.emit(event);
        } else if (this._show && !show) {
          this.close.emit(event);
        }
        if (event.isDefaultPrevented()) {
          return;
        }
        this.toggleCalendar(show);
      });
    } else {
      this.toggleCalendar(show);
    }
  }
  /**
   * @hidden
   */
  checkIcon = checkIcon;
  /**
   * @hidden
   */
  windowSize;
  /**
   * @hidden
   */
  get isControlRequired() {
    return isControlRequired(this.control);
  }
  _popupSettings = {
    animate: true
  };
  _show = false;
  _value = null;
  _active = false;
  _disabledDates;
  onControlChange = noop$2;
  onControlTouched = noop$2;
  onValidatorChange = noop$2;
  minValidateFn = noop$2;
  maxValidateFn = noop$2;
  disabledDatesValidateFn = noop$2;
  incompleteValidator = noop$2;
  resolvedPromise = Promise.resolve(null);
  subscription;
  pickerSubscriptions;
  localizationChangeSubscription;
  windowBlurSubscription;
  ariaActiveDescendantSubscription;
  control;
  domEvents = [];
  _size = DEFAULT_SIZE;
  _rounded = DEFAULT_ROUNDED;
  _fillMode = DEFAULT_FILL_MODE;
  constructor(zone, localization, cdr, popupService, wrapper, renderer, injector, pickerService, disabledDatesService, adaptiveService) {
    super();
    this.zone = zone;
    this.localization = localization;
    this.cdr = cdr;
    this.popupService = popupService;
    this.wrapper = wrapper;
    this.renderer = renderer;
    this.injector = injector;
    this.pickerService = pickerService;
    this.disabledDatesService = disabledDatesService;
    this.adaptiveService = adaptiveService;
    N(packageMetadata);
    this.pickerSubscriptions = this.pickerService.onFocus.subscribe(this.handleFocus.bind(this));
    this.pickerSubscriptions.add(this.pickerService.onBlur.subscribe(this.handleBlur.bind(this)));
    this.pickerSubscriptions.add(this.pickerService.sameDateSelected.subscribe(this.handleSameSelection.bind(this)));
    this.pickerSubscriptions.add(this.pickerService.dateCompletenessChange.subscribe(this.handleDateCompletenessChange.bind(this)));
  }
  /**
   * @hidden
   * Used by the TextBoxContainer to determine if the component is empty.
   */
  isEmpty() {
    return !this.value && this.dateInput.isEmpty();
  }
  /**
   * @hidden
   */
  ngOnInit() {
    this.localizationChangeSubscription = this.localization.changes.subscribe(() => this.cdr.markForCheck());
    this.control = this.injector.get(NgControl, null);
    if (this.wrapper) {
      this.renderer.removeAttribute(this.wrapper.nativeElement, "tabindex");
      this.zone.runOutsideAngular(() => {
        this.bindEvents();
      });
    }
    this.focusableId = this.dateInput?.focusableId;
    this.minValidateFn = this.rangeValidation ? minValidator(this.min) : noop$2;
    this.maxValidateFn = this.rangeValidation ? maxValidator(this.max) : noop$2;
  }
  ngAfterViewInit() {
    this.setComponentClasses();
    this.windowSize = this.adaptiveService.size;
  }
  /**
   * @hidden
   */
  ngOnChanges(changes) {
    this.verifySettings();
    if (changes.min || changes.max || changes.rangeValidation || changes.disabledDatesValidation || changes.disabledDates || changes.incompleteDateValidation) {
      this.minValidateFn = this.rangeValidation ? minValidator(this.min) : noop$2;
      this.maxValidateFn = this.rangeValidation ? maxValidator(this.max) : noop$2;
      this.disabledDatesValidateFn = this.disabledDatesValidation ? disabledDatesValidator(this.disabledDatesService.isDateDisabled) : noop$2;
      this.incompleteValidator = this.incompleteDateValidation ? incompleteDateValidator() : noop$2;
      this.onValidatorChange();
    }
    if (!this.focusableId || changes.focusableId) {
      this.focusableId = this.dateInput?.focusableId;
    }
  }
  /**
   * @hidden
   */
  ngOnDestroy() {
    if (this.isAdaptive && this.isOpen) {
      this.toggleActionSheet(false);
    }
    this.isActive = false;
    this.show = false;
    if (this.localizationChangeSubscription) {
      this.localizationChangeSubscription.unsubscribe();
    }
    if (this.windowBlurSubscription) {
      this.windowBlurSubscription.unsubscribe();
    }
    this.domEvents.forEach((unbindCallback) => unbindCallback());
    this.pickerSubscriptions.unsubscribe();
  }
  /**
   * Indicates whether the component is currently open. That is when the popup or actionSheet is open.
   */
  get isOpen() {
    return this.show;
  }
  /**
   * @hidden
   */
  writeValue(value2) {
    this.verifyValue(value2);
    this.value = cloneDate(value2);
    this.cdr.markForCheck();
    if (!value2 && this.dateInput) {
      this.dateInput.placeholder = this.placeholder;
      this.dateInput.writeValue(value2);
    }
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.onControlChange = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.onControlTouched = fn;
  }
  /**
   * @hidden
   */
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  validate(control) {
    return this.minValidateFn(control) || this.maxValidateFn(control) || this.disabledDatesValidateFn(control) || this.incompleteValidator(control, this.dateInput && this.dateInput.isDateIncomplete);
  }
  /**
   * @hidden
   */
  registerOnValidatorChange(fn) {
    this.onValidatorChange = fn;
  }
  /**
   * @hidden
   */
  handleActionSheetCollapse() {
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  handleActionSheetClick(e) {
    e.preventDefault();
  }
  /**
   * Focuses the DatePicker component.
   */
  focus() {
    this.dateInput.focus();
  }
  /**
   * Blurs the DatePicker component.
   */
  blur() {
    (this.calendar || this.dateInput)["blur"]();
  }
  /**
   * Toggles the visibility of the popup or actionSheet.
   * If you use the `toggle` method to show or hide the popup or actionSheet,
   * the `open` and `close` events do not fire.
   *
   * @param show The state of the popup.
   */
  toggle(show) {
    if (this.disabled || this.readonly) {
      return;
    }
    this.resolvedPromise.then(() => {
      this.toggleCalendar(show === void 0 ? !this.show : show);
    });
  }
  /**
   * @hidden
   */
  handleIconClick(event) {
    if (this.disabled || this.readonly) {
      return;
    }
    event.preventDefault();
    this.focusInput();
    this.handleFocus();
    this.show = !this.show;
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  handleDateInputClick() {
    this.windowSize = this.adaptiveService.size;
    if (this.isAdaptive) {
      this.show = true;
    } else if (this.isOpen) {
      this.show = false;
    }
  }
  /**
   * @hidden
   */
  handleMousedown(args) {
    args.preventDefault();
  }
  /**
   * @hidden
   */
  handleChange(value2, isInputValueChange) {
    this.value = value2;
    if (this.show) {
      if (!isInputValueChange) {
        this.focusInput();
      }
      this.show = false;
    }
    this.onControlChange(cloneDate(value2));
    this.valueChange.emit(cloneDate(value2));
  }
  /**
   * @hidden
   */
  handleInputChange(value2) {
    this.handleChange(this.dateInput.formatSections["time"] ? value2 : this.mergeTime(value2), true);
  }
  /**
   * @hidden
   */
  get popupClasses() {
    const popupClasses = ["k-datepicker-popup", "k-calendar-container"];
    if (!this.popupSettings.popupClass) {
      return popupClasses;
    }
    const customClasses = parseCSSClassNames(this.popupSettings.popupClass);
    if (customClasses?.length) {
      popupClasses.push(...customClasses);
    }
    return popupClasses;
  }
  /**
   * @hidden
   */
  get appendTo() {
    const {
      appendTo
    } = this.popupSettings;
    if (!appendTo || appendTo === "root") {
      return void 0;
    }
    return appendTo === "component" ? this.container : appendTo;
  }
  get dateInput() {
    return this.pickerService.input;
  }
  get calendar() {
    return this.pickerService.calendar;
  }
  /**
   * @hidden
   */
  get isAdaptiveModeEnabled() {
    return this.adaptiveMode === "auto";
  }
  /**
   * @hidden
   */
  get isAdaptive() {
    return this.isAdaptiveModeEnabled && this.windowSize !== "large";
  }
  /**
   * @hidden
   */
  onResize() {
    const currentWindowSize = this.adaptiveService.size;
    if (!this.isOpen || this.windowSize === currentWindowSize) {
      return;
    }
    if (this.actionSheet.expanded) {
      this.toggleActionSheet(false);
    } else {
      this.togglePopup(false);
    }
    this.windowSize = currentWindowSize;
  }
  /**
   * @hidden
   */
  mergeTime(value2) {
    return this.value && value2 ? setTime(value2, this.value) : value2;
  }
  /**
   * @hidden
   */
  handleKeydown(e) {
    const {
      altKey,
      shiftKey,
      target
    } = e;
    const code = normalizeKeys(e);
    if (code === Keys.Escape) {
      this.dateInput.focus();
      this.show = false;
      hasObservers(this.escape) && this.escape.emit();
    }
    if (altKey) {
      if (code === Keys.ArrowDown && !this.show) {
        this.show = true;
      }
      if (code === Keys.ArrowUp) {
        this.dateInput.focus();
        this.show = false;
      }
    }
    if (code === Keys.Tab && this.show && this.calendar.isActive && isTabExitingCalendar(this.calendarType, target, shiftKey)) {
      this.dateInput.focus();
      this.show = false;
    }
  }
  toggleCalendar(show) {
    const previousWindowSize = this.windowSize;
    this.windowSize = this.adaptiveService.size;
    if (previousWindowSize !== this.windowSize && !show) {
      if (previousWindowSize !== "large") {
        this.toggleActionSheet(show);
      } else {
        this.togglePopup(show);
      }
    } else {
      if (this.isAdaptive) {
        this.toggleActionSheet(show);
      } else {
        this.togglePopup(show);
      }
    }
    this.toggleFocus();
  }
  togglePopup(show) {
    if (show === this._show) {
      return;
    }
    this._show = show;
    if (show) {
      const direction = this.localization.rtl ? "right" : "left";
      const appendToComponent = typeof this.popupSettings.appendTo === "string" && this.popupSettings.appendTo === "component";
      this.popupRef = this.popupService.open({
        anchor: this.wrapper,
        anchorAlign: {
          vertical: "bottom",
          horizontal: direction
        },
        animate: this.popupSettings.animate,
        appendTo: this.appendTo,
        content: this.popupTemplate,
        popupAlign: {
          vertical: "top",
          horizontal: direction
        },
        popupClass: this.popupClasses,
        positionMode: appendToComponent ? "fixed" : "absolute"
      });
      this.setAriaActiveDescendant();
      this.popupRef.popupElement.setAttribute("id", this.popupUID);
      this.renderer.setAttribute(this.dateInput?.inputElement, attributeNames.ariaControls, this.popupUID);
      this.subscription = this.popupRef.popupAnchorViewportLeave.subscribe(() => this.show = false);
    } else {
      this.popupRef.close();
      this.popupRef = null;
      this.subscription.unsubscribe();
      this.ariaActiveDescendantSubscription.unsubscribe();
      if (this.dateInput) {
        this.renderer.removeAttribute(this.dateInput.inputElement, attributeNames.ariaControls);
        this.renderer.removeAttribute(this.dateInput.inputElement, attributeNames.ariaActiveDescendant);
      }
      this.cdr.detectChanges();
    }
  }
  toggleActionSheet(show) {
    if (show === this._show) {
      return;
    }
    if (show && !this.isOpen) {
      this.actionSheet.toggle();
      this.setAriaActiveDescendant();
      this.actionSheet.element.nativeElement.setAttribute("id", this.popupUID);
      this.renderer.setAttribute(this.dateInput?.inputElement, attributeNames.ariaControls, this.popupUID);
    } else if (!show && this.isOpen) {
      this.actionSheet.toggle();
      this.ariaActiveDescendantSubscription.unsubscribe();
      if (this.dateInput) {
        this.renderer.removeAttribute(this.dateInput.inputElement, attributeNames.ariaActiveDescendant);
        this.renderer.removeAttribute(this.dateInput.inputElement, attributeNames.ariaControls);
        this.dateInput.focus();
      }
    }
    this._show = show;
  }
  setAriaActiveDescendant() {
    const focusedCellChangeEvent = this.calendar.type === "infinite" ? this.calendar.monthView.focusedCellChange : this.calendar.multiViewCalendar.viewList.focusedCellChange;
    this.ariaActiveDescendantSubscription = focusedCellChangeEvent.subscribe((id3) => this.renderer.setAttribute(this.dateInput?.inputElement, attributeNames.ariaActiveDescendant, id3));
  }
  focusInput() {
    if (touchEnabled) {
      return;
    }
    this.dateInput.focus();
  }
  toggleFocus() {
    if (!this.isActive) {
      return;
    }
    if (this.show) {
      if (!this.calendar) {
        this.cdr.detectChanges();
      }
      if (this.calendar) {
        this.calendar.focus();
      }
    } else if (!touchEnabled) {
      this.dateInput.focus();
    } else if (!this.dateInput.isActive) {
      this.handleBlur();
    }
  }
  verifySettings() {
    if (!isDevMode()) {
      return;
    }
    if (!isValidRange(this.min, this.max)) {
      throw new Error(`The max value should be bigger than the min. See ${MIN_DOC_LINK} and ${MAX_DOC_LINK}.`);
    }
  }
  verifyValue(value2) {
    if (!isDevMode()) {
      return;
    }
    if (value2 && !(value2 instanceof Date)) {
      throw new Error(`The 'value' should be a valid JavaScript Date instance or null. Check ${VALUE_DOC_LINK$2} for possible resolution.`);
    }
  }
  bindEvents() {
    const element = this.wrapper.nativeElement;
    this.domEvents.push(this.renderer.listen(element, "keydown", this.handleKeydown.bind(this)));
    if (isWindowAvailable()) {
      this.windowBlurSubscription = fromEvent(window, "blur").subscribe(this.handleWindowBlur.bind(this));
    }
  }
  handleFocus() {
    if (this.isActive) {
      return;
    }
    this.isActive = true;
    if (hasObservers(this.onFocus)) {
      this.zone.run(() => {
        this.onFocus.emit();
      });
    }
  }
  handleWindowBlur() {
    if (!this.isOpen || this.actionSheet.expanded) {
      return;
    }
    this.show = false;
  }
  handleBlur(args) {
    const currentTarget = args && currentFocusTarget(args);
    const target = args && args.target;
    const isInsideActionSheet = this.actionSheet && (this.actionSheet.element.nativeElement.contains(target) || this.actionSheet.element.nativeElement.contains(currentTarget));
    if (currentTarget && (this.dateInput.containsElement(currentTarget) || this.calendar && this.calendar.containsElement(currentTarget) || isInsideActionSheet)) {
      return;
    }
    if (hasObservers(this.onBlur) || this.show && hasObservers(this.close) || requiresZoneOnBlur(this.control)) {
      this.zone.run(() => {
        this.blurComponent();
        this.cdr.markForCheck();
      });
    } else {
      this.blurComponent();
    }
  }
  blurComponent() {
    this.isActive = false;
    this.show = false;
    this.cdr.detectChanges();
    this.onControlTouched();
    this.onBlur.emit();
  }
  handleSameSelection() {
    if (this.show) {
      this.focusInput();
      this.show = false;
    }
  }
  handleDateCompletenessChange() {
    this.cdr.markForCheck();
    this.zone.run(() => this.onValidatorChange());
  }
  setComponentClasses() {
    if (this.size) {
      this.renderer.addClass(this.wrapper.nativeElement, getSizeClass("input", this.size));
      this.renderer.addClass(this.toggleButton.nativeElement, getSizeClass("button", this.size));
    }
    if (this.rounded) {
      this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
    }
    if (this.fillMode) {
      this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass("input", this.fillMode));
      this.renderer.addClass(this.toggleButton.nativeElement, getFillModeClass("button", this.fillMode));
      this.renderer.addClass(this.toggleButton.nativeElement, `k-button-${this.fillMode}-base`);
    }
  }
  static ɵfac = function DatePickerComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DatePickerComponent)(ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(PickerService), ɵɵdirectiveInject(DisabledDatesService), ɵɵdirectiveInject(AdaptiveService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DatePickerComponent,
    selectors: [["kendo-datepicker"]],
    contentQueries: function DatePickerComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, CellTemplateDirective, 5)(dirIndex, MonthCellTemplateDirective, 5)(dirIndex, YearCellTemplateDirective, 5)(dirIndex, DecadeCellTemplateDirective, 5)(dirIndex, CenturyCellTemplateDirective, 5)(dirIndex, WeekNumberCellTemplateDirective, 5)(dirIndex, HeaderTitleTemplateDirective, 5)(dirIndex, HeaderTemplateDirective, 5)(dirIndex, FooterTemplateDirective2, 5)(dirIndex, NavigationItemTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.cellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.monthCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.yearCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.decadeCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.centuryCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.weekNumberTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTitleTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.navigationItemTemplate = _t.first);
      }
    },
    viewQuery: function DatePickerComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c14, 7, ViewContainerRef)(_c15, 7)(_c16, 7)(_c17, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.container = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.toggleButton = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.actionSheet = _t.first);
      }
    },
    hostVars: 8,
    hostBindings: function DatePickerComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-readonly", ctx.readonly)("k-datepicker", ctx.wrapperClasses)("k-input", ctx.wrapperClasses)("k-disabled", ctx.disabledClass);
      }
    },
    inputs: {
      focusableId: "focusableId",
      cellTemplateRef: [0, "cellTemplate", "cellTemplateRef"],
      clearButton: "clearButton",
      inputAttributes: "inputAttributes",
      monthCellTemplateRef: [0, "monthCellTemplate", "monthCellTemplateRef"],
      yearCellTemplateRef: [0, "yearCellTemplate", "yearCellTemplateRef"],
      decadeCellTemplateRef: [0, "decadeCellTemplate", "decadeCellTemplateRef"],
      centuryCellTemplateRef: [0, "centuryCellTemplate", "centuryCellTemplateRef"],
      weekNumberTemplateRef: [0, "weekNumberTemplate", "weekNumberTemplateRef"],
      headerTitleTemplateRef: [0, "headerTitleTemplate", "headerTitleTemplateRef"],
      headerTemplateRef: [0, "headerTemplate", "headerTemplateRef"],
      footerTemplateRef: [0, "footerTemplate", "footerTemplateRef"],
      footer: "footer",
      navigationItemTemplateRef: [0, "navigationItemTemplate", "navigationItemTemplateRef"],
      weekDaysFormat: "weekDaysFormat",
      showOtherMonthDays: "showOtherMonthDays",
      activeView: "activeView",
      bottomView: "bottomView",
      topView: "topView",
      calendarType: "calendarType",
      animateCalendarNavigation: "animateCalendarNavigation",
      disabled: "disabled",
      readonly: "readonly",
      readOnlyInput: "readOnlyInput",
      popupSettings: "popupSettings",
      navigation: "navigation",
      min: "min",
      max: "max",
      incompleteDateValidation: "incompleteDateValidation",
      autoCorrectParts: "autoCorrectParts",
      autoSwitchParts: "autoSwitchParts",
      autoSwitchKeys: "autoSwitchKeys",
      enableMouseWheel: "enableMouseWheel",
      allowCaretMode: "allowCaretMode",
      autoFill: "autoFill",
      focusedDate: "focusedDate",
      value: "value",
      format: "format",
      twoDigitYearMax: "twoDigitYearMax",
      formatPlaceholder: "formatPlaceholder",
      placeholder: "placeholder",
      tabindex: "tabindex",
      tabIndex: "tabIndex",
      disabledDates: "disabledDates",
      adaptiveTitle: "adaptiveTitle",
      adaptiveSubtitle: "adaptiveSubtitle",
      rangeValidation: "rangeValidation",
      disabledDatesValidation: "disabledDatesValidation",
      weekNumber: "weekNumber",
      size: "size",
      rounded: "rounded",
      fillMode: "fillMode",
      adaptiveMode: "adaptiveMode"
    },
    outputs: {
      valueChange: "valueChange",
      onFocus: "focus",
      onBlur: "blur",
      open: "open",
      close: "close",
      escape: "escape"
    },
    exportAs: ["kendo-datepicker"],
    features: [ɵɵProvidersFeature([{
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _DatePickerComponent),
      multi: true
    }, {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => _DatePickerComponent),
      multi: true
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _DatePickerComponent)
    }, {
      provide: MultiTabStop,
      useExisting: forwardRef(() => _DatePickerComponent)
    }, LocalizationService, PickerService, DisabledDatesService, {
      provide: L10N_PREFIX,
      useValue: "kendo.datepicker"
    }]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
    decls: 17,
    vars: 49,
    consts: () => {
      let i18n_11;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_11 = goog.getMsg("Today");
        i18n_11 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_11;
      } else {
        i18n_11 = $localize`:kendo.datepicker.today|The label for the today button in the calendar header:Today`;
      }
      let i18n_12;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_12 = goog.getMsg("Toggle calendar");
        i18n_12 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_12;
      } else {
        i18n_12 = $localize`:kendo.datepicker.toggle|The title of the toggle button in the datepicker component:Toggle calendar`;
      }
      let i18n_13;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_13 = goog.getMsg("Navigate to previous view");
        i18n_13 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_13;
      } else {
        i18n_13 = $localize`:kendo.datepicker.prevButtonTitle|The title of the previous button in the Classic calendar:Navigate to previous view`;
      }
      let i18n_14;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_14 = goog.getMsg("Navigate to next view");
        i18n_14 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_14;
      } else {
        i18n_14 = $localize`:kendo.datepicker.nextButtonTitle|The title of the next button in the Classic calendar:Navigate to next view`;
      }
      let i18n_15;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_15 = goog.getMsg("Navigate to parent view");
        i18n_15 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_15;
      } else {
        i18n_15 = $localize`:kendo.datepicker.parentViewButtonTitle|The title of the parent view button in the calendar header:Navigate to parent view`;
      }
      let i18n_16;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_16 = goog.getMsg("clear");
        i18n_16 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_16;
      } else {
        i18n_16 = $localize`:kendo.datepicker.clearTitle|The title of the clear button:clear`;
      }
      let i18n_17;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_17 = goog.getMsg("Close");
        i18n_17 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_17;
      } else {
        i18n_17 = $localize`:kendo.datepicker.adaptiveCloseButtonTitle|The title of the Close button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode:Close`;
      }
      return [["input", ""], ["toggleButton", ""], ["container", ""], ["popupTemplate", ""], ["actionSheet", ""], ["calendarTemplate", ""], ["calendar", ""], ["kendoDatePickerLocalizedMessages", "", "today", i18n_11, "toggle", i18n_12, "prevButtonTitle", i18n_13, "nextButtonTitle", i18n_14, "parentViewButtonTitle", i18n_15, "clearTitle", i18n_16, "adaptiveCloseButtonTitle", i18n_17], ["pickerType", "datepicker", "hasPopup", "grid", "fillMode", "none", "rounded", "none", "size", "none", 3, "valueChange", "click", "role", "isPopupOpen", "clearButton", "disabled", "readonly", "ariaReadOnly", "tabindex", "isRequired", "title", "focusableId", "format", "twoDigitYearMax", "formatPlaceholder", "placeholder", "min", "max", "incompleteDateValidation", "autoCorrectParts", "autoSwitchParts", "autoSwitchKeys", "enableMouseWheel", "allowCaretMode", "autoFill", "inputAttributes", "value"], [3, "clearTitle"], ["type", "button", 1, "k-input-button", "k-button", "k-icon-button", 3, "tabindex", "kendoEventsOutsideAngular", "scope"], ["name", "calendar", "innerCssClass", "k-button-icon", 3, "svgIcon"], [3, "overlayClick", "collapse", "kendoEventsOutsideAngular", "scope", "titleId", "cssClass", "cssStyle"], ["kendoActionSheetTemplate", ""], [4, "ngTemplateOutlet"], [3, "resize"], [1, "k-actionsheet-titlebar"], [1, "k-actionsheet-titlebar-group"], [1, "k-actionsheet-title"], [1, "k-text-center"], [1, "k-actionsheet-subtitle", "k-text-center"], [1, "k-actionsheet-actions"], ["kendoButton", "", "type", "button", "icon", "check", "themeColor", "primary", "fillMode", "flat", "size", "large", "innerCssClass", "k-button-icon", 3, "click", "svgIcon", "tabIndex"], [1, "k-actionsheet-content"], [3, "closePopup", "valueChange", "type", "size", "min", "max", "weekDaysFormat", "navigation", "animateNavigation", "activeView", "bottomView", "showOtherMonthDays", "topView", "weekNumber", "cellTemplate", "monthCellTemplate", "yearCellTemplate", "decadeCellTemplate", "centuryCellTemplate", "weekNumberTemplate", "headerTitleTemplate", "headerTemplate", "footerTemplate", "footer", "navigationItemTemplate", "focusedDate", "value", "kendoEventsOutsideAngular", "scope", "disabledDates"], [3, "today", "prevButtonTitle", "nextButtonTitle", "parentViewButtonTitle"]];
    },
    template: function DatePickerComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainer(0, 7);
        ɵɵelementStart(1, "kendo-dateinput", 8, 0);
        ɵɵlistener("valueChange", function DatePickerComponent_Template_kendo_dateinput_valueChange_1_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleInputChange($event));
        })("click", function DatePickerComponent_Template_kendo_dateinput_click_1_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleDateInputClick());
        });
        ɵɵelement(3, "kendo-dateinput-messages", 9);
        ɵɵelementEnd();
        ɵɵelementStart(4, "button", 10, 1);
        ɵɵelement(6, "kendo-icon-wrapper", 11);
        ɵɵelementEnd();
        ɵɵelementContainer(7, null, 2);
        ɵɵtemplate(9, DatePickerComponent_ng_template_9_Template, 1, 1, "ng-template", null, 3, ɵɵtemplateRefExtractor);
        ɵɵconditionalCreate(11, DatePickerComponent_Conditional_11_Template, 1, 0, "kendo-resize-sensor");
        ɵɵelementStart(12, "kendo-actionsheet", 12, 4);
        ɵɵlistener("overlayClick", function DatePickerComponent_Template_kendo_actionsheet_overlayClick_12_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.show = false);
        })("collapse", function DatePickerComponent_Template_kendo_actionsheet_collapse_12_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleActionSheetCollapse());
        });
        ɵɵtemplate(14, DatePickerComponent_ng_template_14_Template, 9, 6, "ng-template", 13);
        ɵɵelementEnd();
        ɵɵtemplate(15, DatePickerComponent_ng_template_15_Template, 3, 34, "ng-template", null, 5, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("role", "combobox")("isPopupOpen", ctx.show)("clearButton", ctx.clearButton)("disabled", ctx.disabled)("readonly", ctx.readonly || ctx.readOnlyInput)("ariaReadOnly", ctx.readonly)("tabindex", ctx.tabindex)("isRequired", ctx.isControlRequired)("title", ctx.adaptiveTitle)("focusableId", ctx.focusableId)("format", ctx.format)("twoDigitYearMax", ctx.twoDigitYearMax)("formatPlaceholder", ctx.formatPlaceholder)("placeholder", ctx.placeholder)("min", ctx.min)("max", ctx.max)("incompleteDateValidation", ctx.incompleteDateValidation)("autoCorrectParts", ctx.autoCorrectParts)("autoSwitchParts", ctx.autoSwitchParts)("autoSwitchKeys", ctx.autoSwitchKeys)("enableMouseWheel", ctx.enableMouseWheel)("allowCaretMode", ctx.allowCaretMode)("autoFill", ctx.autoFill)("inputAttributes", ctx.inputAttributes)("value", ctx.value);
        ɵɵadvance(2);
        ɵɵproperty("clearTitle", ctx.localization.get("clearTitle"));
        ɵɵadvance();
        ɵɵproperty("tabindex", -1)("kendoEventsOutsideAngular", ɵɵpureFunction2(39, _c18, ctx.handleIconClick, ctx.handleMousedown))("scope", ctx);
        ɵɵattribute("title", ctx.localization.get("toggle"))("aria-label", ctx.localization.get("toggle"))("disabled", ctx.disabled ? "" : null);
        ɵɵadvance(2);
        ɵɵproperty("svgIcon", ctx.calendarIcon);
        ɵɵadvance(5);
        ɵɵconditional(ctx.isAdaptiveModeEnabled ? 11 : -1);
        ɵɵadvance();
        ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction1(42, _c5, ctx.handleActionSheetClick))("scope", ctx)("titleId", ctx.calendar == null ? null : ctx.calendar.headerId)("cssClass", ɵɵpureFunction2(44, _c19, ctx.windowSize === "small", ctx.windowSize === "medium"))("cssStyle", ɵɵpureFunction1(47, _c20, ctx.windowSize === "small" ? "100vh" : "60vh"));
      }
    },
    dependencies: [DatePickerLocalizedMessagesDirective, DateInputComponent, DateInputCustomMessagesComponent, EventsOutsideAngularDirective, IconWrapperComponent, NgTemplateOutlet, ResizeSensorComponent, ActionSheetComponent, ActionSheetTemplateDirective, ButtonComponent, CalendarComponent, CalendarCustomMessagesComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatePickerComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      exportAs: "kendo-datepicker",
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => DatePickerComponent),
        multi: true
      }, {
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => DatePickerComponent),
        multi: true
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => DatePickerComponent)
      }, {
        provide: MultiTabStop,
        useExisting: forwardRef(() => DatePickerComponent)
      }, LocalizationService, PickerService, DisabledDatesService, {
        provide: L10N_PREFIX,
        useValue: "kendo.datepicker"
      }],
      selector: "kendo-datepicker",
      template: `
        <ng-container kendoDatePickerLocalizedMessages
          i18n-today="kendo.datepicker.today|The label for the today button in the calendar header"
          today="Today"
        
          i18n-toggle="kendo.datepicker.toggle|The title of the toggle button in the datepicker component"
          toggle="Toggle calendar"
        
          i18n-prevButtonTitle="kendo.datepicker.prevButtonTitle|The title of the previous button in the Classic calendar"
          prevButtonTitle="Navigate to previous view"
        
          i18n-nextButtonTitle="kendo.datepicker.nextButtonTitle|The title of the next button in the Classic calendar"
          nextButtonTitle="Navigate to next view"
        
          i18n-parentViewButtonTitle="kendo.datepicker.parentViewButtonTitle|The title of the parent view button in the calendar header"
          parentViewButtonTitle="Navigate to parent view"
        
          i18n-clearTitle="kendo.datepicker.clearTitle|The title of the clear button"
          clearTitle="clear"
        
          i18n-adaptiveCloseButtonTitle="kendo.datepicker.adaptiveCloseButtonTitle|The title of the Close button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode"
          adaptiveCloseButtonTitle="Close"
          >
        </ng-container>
        <kendo-dateinput
          #input
          [role]="'combobox'"
          pickerType="datepicker"
          hasPopup="grid"
          [isPopupOpen]="show"
          [clearButton]="clearButton"
          [disabled]="disabled"
          [readonly]="readonly || readOnlyInput"
          [ariaReadOnly]="readonly"
          [tabindex]="tabindex"
          [isRequired]="isControlRequired"
          [title]="adaptiveTitle"
          [focusableId]="focusableId"
          [format]="format"
          [twoDigitYearMax]="twoDigitYearMax"
          [formatPlaceholder]="formatPlaceholder"
          [placeholder]="placeholder"
          [min]="min"
          [max]="max"
          [incompleteDateValidation]="incompleteDateValidation"
          [autoCorrectParts]="autoCorrectParts"
          [autoSwitchParts]="autoSwitchParts"
          [autoSwitchKeys]="autoSwitchKeys"
          [enableMouseWheel]="enableMouseWheel"
          [allowCaretMode]="allowCaretMode"
          [autoFill]="autoFill"
          fillMode="none"
          rounded="none"
          size="none"
          [inputAttributes]="inputAttributes"
          [value]="value"
          (valueChange)="handleInputChange($event)"
          (click)="handleDateInputClick()"
          >
          <kendo-dateinput-messages
            [clearTitle]="localization.get('clearTitle')"
            >
          </kendo-dateinput-messages>
        </kendo-dateinput>
        <button
          #toggleButton
          type="button"
          class="k-input-button k-button k-icon-button"
          [tabindex]="-1"
          [attr.title]="localization.get('toggle')"
          [attr.aria-label]="localization.get('toggle')"
          [attr.disabled]="disabled ? '' : null"
            [kendoEventsOutsideAngular]="{
                click: handleIconClick,
                mousedown: handleMousedown
            }"
          [scope]="this"
          >
          <kendo-icon-wrapper
            name="calendar"
            [svgIcon]="calendarIcon"
            innerCssClass="k-button-icon"
            >
          </kendo-icon-wrapper>
        </button>
        
        <ng-container #container></ng-container>
        
        <ng-template #popupTemplate>
          <ng-container *ngTemplateOutlet="calendarTemplate"></ng-container>
        </ng-template>
        
        @if (isAdaptiveModeEnabled) {
          <kendo-resize-sensor (resize)="onResize()"></kendo-resize-sensor>
        }
        <kendo-actionsheet
          #actionSheet
          (overlayClick)="show=false"
            [kendoEventsOutsideAngular]="{
                click: handleActionSheetClick
            }"
          [scope]="this"
          (collapse)="handleActionSheetCollapse()"
          [titleId]="calendar?.headerId"
            [cssClass]="{
                'k-adaptive-actionsheet': true,
                'k-actionsheet-fullscreen': windowSize === 'small',
                'k-actionsheet-bottom': windowSize === 'medium'
            }"
            [cssStyle]="{
                height: windowSize === 'small' ? '100vh' : '60vh'
            }"
          >
          <ng-template kendoActionSheetTemplate>
            <div class="k-actionsheet-titlebar">
              <div class="k-actionsheet-titlebar-group">
                <div class="k-actionsheet-title">
                  @if (adaptiveTitle) {
                    <div class="k-text-center">{{ adaptiveTitle }}</div>
                  }
                  @if (adaptiveSubtitle) {
                    <div class="k-actionsheet-subtitle k-text-center">{{ adaptiveSubtitle }}</div>
                  }
                </div>
                <div class="k-actionsheet-actions">
                  <button
                    kendoButton
                    type="button"
                    icon="check"
                    themeColor="primary"
                    [attr.title]="localization.get('adaptiveCloseButtonTitle')"
                    [svgIcon]="checkIcon"
                    fillMode="flat"
                    [tabIndex]="-1"
                    size="large"
                    innerCssClass="k-button-icon"
                    (click)="show = false">
                  </button>
                </div>
              </div>
            </div>
            <div class="k-actionsheet-content">
              <ng-container *ngTemplateOutlet="calendarTemplate"></ng-container>
            </div>
          </ng-template>
        </kendo-actionsheet>
        
        <ng-template #calendarTemplate>
          <kendo-calendar
            #calendar
            [type]="calendarType"
            [size]="isAdaptive ? 'large' : size"
            [min]="min"
            [max]="max"
            [weekDaysFormat]="weekDaysFormat"
            [navigation]="navigation"
            [animateNavigation]="animateCalendarNavigation"
            [activeView]="activeView"
            [bottomView]="bottomView"
            [showOtherMonthDays]="showOtherMonthDays"
            [topView]="topView"
            [weekNumber]="weekNumber"
            [cellTemplate]="cellTemplate"
            [monthCellTemplate]="monthCellTemplate"
            [yearCellTemplate]="yearCellTemplate"
            [decadeCellTemplate]="decadeCellTemplate"
            [centuryCellTemplate]="centuryCellTemplate"
            [weekNumberTemplate]="weekNumberTemplate"
            [headerTitleTemplate]="headerTitleTemplate"
            [headerTemplate]="headerTemplate"
            [footerTemplate]="footerTemplate"
            [footer]="footer"
            [navigationItemTemplate]="navigationItemTemplate"
            [focusedDate]="focusedDate"
            [value]="value"
            (closePopup)="show = false;"
            (valueChange)="handleChange(mergeTime($event))"
                [kendoEventsOutsideAngular]="{
                    keydown: handleKeydown
                }"
            [scope]="this"
            [disabledDates]="disabledDates"
            >
            <kendo-calendar-messages
              [today]="localization.get('today')"
              [prevButtonTitle]="localization.get('prevButtonTitle')"
              [nextButtonTitle]="localization.get('nextButtonTitle')"
              [parentViewButtonTitle]="localization.get('parentViewButtonTitle')"
              >
            </kendo-calendar-messages>
          </kendo-calendar>
        </ng-template>
        `,
      standalone: true,
      imports: [DatePickerLocalizedMessagesDirective, DateInputComponent, DateInputCustomMessagesComponent, EventsOutsideAngularDirective, IconWrapperComponent, NgTemplateOutlet, ResizeSensorComponent, ActionSheetComponent, ActionSheetTemplateDirective, ButtonComponent, CalendarComponent, CalendarCustomMessagesComponent]
    }]
  }], () => [{
    type: NgZone
  }, {
    type: LocalizationService
  }, {
    type: ChangeDetectorRef
  }, {
    type: PopupService
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: Injector
  }, {
    type: PickerService
  }, {
    type: DisabledDatesService
  }, {
    type: AdaptiveService
  }], {
    container: [{
      type: ViewChild,
      args: ["container", {
        read: ViewContainerRef,
        static: true
      }]
    }],
    popupTemplate: [{
      type: ViewChild,
      args: ["popupTemplate", {
        static: true
      }]
    }],
    toggleButton: [{
      type: ViewChild,
      args: ["toggleButton", {
        static: true
      }]
    }],
    actionSheet: [{
      type: ViewChild,
      args: ["actionSheet"]
    }],
    focusableId: [{
      type: Input
    }],
    cellTemplate: [{
      type: ContentChild,
      args: [CellTemplateDirective, {
        static: false
      }]
    }],
    cellTemplateRef: [{
      type: Input,
      args: ["cellTemplate"]
    }],
    clearButton: [{
      type: Input
    }],
    inputAttributes: [{
      type: Input
    }],
    monthCellTemplate: [{
      type: ContentChild,
      args: [MonthCellTemplateDirective, {
        static: false
      }]
    }],
    monthCellTemplateRef: [{
      type: Input,
      args: ["monthCellTemplate"]
    }],
    yearCellTemplate: [{
      type: ContentChild,
      args: [YearCellTemplateDirective, {
        static: false
      }]
    }],
    yearCellTemplateRef: [{
      type: Input,
      args: ["yearCellTemplate"]
    }],
    decadeCellTemplate: [{
      type: ContentChild,
      args: [DecadeCellTemplateDirective, {
        static: false
      }]
    }],
    decadeCellTemplateRef: [{
      type: Input,
      args: ["decadeCellTemplate"]
    }],
    centuryCellTemplate: [{
      type: ContentChild,
      args: [CenturyCellTemplateDirective, {
        static: false
      }]
    }],
    centuryCellTemplateRef: [{
      type: Input,
      args: ["centuryCellTemplate"]
    }],
    weekNumberTemplate: [{
      type: ContentChild,
      args: [WeekNumberCellTemplateDirective, {
        static: false
      }]
    }],
    weekNumberTemplateRef: [{
      type: Input,
      args: ["weekNumberTemplate"]
    }],
    headerTitleTemplate: [{
      type: ContentChild,
      args: [HeaderTitleTemplateDirective, {
        static: false
      }]
    }],
    headerTitleTemplateRef: [{
      type: Input,
      args: ["headerTitleTemplate"]
    }],
    headerTemplate: [{
      type: ContentChild,
      args: [HeaderTemplateDirective]
    }],
    headerTemplateRef: [{
      type: Input,
      args: ["headerTemplate"]
    }],
    footerTemplate: [{
      type: ContentChild,
      args: [FooterTemplateDirective2]
    }],
    footerTemplateRef: [{
      type: Input,
      args: ["footerTemplate"]
    }],
    footer: [{
      type: Input
    }],
    navigationItemTemplate: [{
      type: ContentChild,
      args: [NavigationItemTemplateDirective, {
        static: false
      }]
    }],
    navigationItemTemplateRef: [{
      type: Input,
      args: ["navigationItemTemplate"]
    }],
    weekDaysFormat: [{
      type: Input
    }],
    showOtherMonthDays: [{
      type: Input
    }],
    activeView: [{
      type: Input
    }],
    bottomView: [{
      type: Input
    }],
    topView: [{
      type: Input
    }],
    calendarType: [{
      type: Input
    }],
    animateCalendarNavigation: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-readonly"]
    }],
    readOnlyInput: [{
      type: Input
    }],
    popupSettings: [{
      type: Input
    }],
    navigation: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    incompleteDateValidation: [{
      type: Input
    }],
    autoCorrectParts: [{
      type: Input
    }],
    autoSwitchParts: [{
      type: Input
    }],
    autoSwitchKeys: [{
      type: Input
    }],
    enableMouseWheel: [{
      type: Input
    }],
    allowCaretMode: [{
      type: Input
    }],
    autoFill: [{
      type: Input
    }],
    focusedDate: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    twoDigitYearMax: [{
      type: Input
    }],
    formatPlaceholder: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    disabledDates: [{
      type: Input
    }],
    adaptiveTitle: [{
      type: Input
    }],
    adaptiveSubtitle: [{
      type: Input
    }],
    rangeValidation: [{
      type: Input
    }],
    disabledDatesValidation: [{
      type: Input
    }],
    weekNumber: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }],
    fillMode: [{
      type: Input
    }],
    adaptiveMode: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    open: [{
      type: Output
    }],
    close: [{
      type: Output
    }],
    escape: [{
      type: Output
    }],
    wrapperClasses: [{
      type: HostBinding,
      args: ["class.k-datepicker"]
    }, {
      type: HostBinding,
      args: ["class.k-input"]
    }],
    disabledClass: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }]
  });
})();
var TIME_PART = {
  dayperiod: "dayperiod",
  hour: "hour",
  millisecond: "millisecond",
  minute: "minute",
  second: "second"
};
var div = domContainerFactory("div");
var ul = domContainerFactory("ul");
var li = domContainerFactory("li");
var span = domContainerFactory("span");
var listTitle = () => span("hour", "k-title k-timeselector-title");
var listItem = () => li("<span>02</span>", "k-item");
var list = () => ul([listItem()], "k-reset");
var scrollable = () => div([list()], "k-time-container k-flex k-content k-scrollable");
var actionSheetContent = (isDateTimePicker) => [isDateTimePicker ? div([div("button", "k-button k-button-lg")], "k-datetime-buttongroup") : null, div([div([span("04:08:48:49 AM", "k-title k-timeselector-title"), div("now", "k-button k-button-md")], "k-time-header"), div([span("", "k-time-highlight"), div([listTitle(), div([scrollable()], "k-time-list")], "k-time-list-wrapper")], "k-time-list-container")], "k-timeselector k-timeselector-lg")];
var timeListWrapper = (isAdaptiveEnabled = false, windowSize, isDateTimePicker) => {
  if (!isDocumentAvailable()) {
    return null;
  }
  if (!isAdaptiveEnabled) {
    return div([listTitle(), div([scrollable()], "k-time-list")], "k-time-list-wrapper", {
      left: "-10000px",
      position: "absolute"
    });
  }
  return div([div([div([div([div([], "k-actionsheet-title"), div([div([div([div("", "k-i-check k-button-icon k-icon k-font-icon")], "k-icon-wrapper-host")], "k-button k-icon-button k-button-lg")], "k-actionsheet-actions")], "k-actionsheet-titlebar-group")], "k-actionsheet-titlebar"), div([isDateTimePicker ? div([...actionSheetContent(isDateTimePicker)], "k-datetime-wrap k-time-tab") : actionSheetContent(isDateTimePicker)[1]], "k-actionsheet-content"), div([div("button", "k-button k-button-lg")], "k-actions k-actions-stretched k-actions-horizontal k-actionsheet-footer")], "k-actionsheet-view")], `k-actionsheet k-adaptive-actionsheet ${windowSize === "small" ? "k-actionsheet-fullscreen" : ""}`, {
    height: windowSize === "small" ? "100%" : "60vh",
    left: "-10000px",
    position: "absolute",
    top: 0
  });
};
var TimePickerDOMService = class _TimePickerDOMService {
  adaptiveService;
  constructor(adaptiveService) {
    this.adaptiveService = adaptiveService;
  }
  itemHeight;
  timeListHeight;
  isAdaptiveEnabled;
  isDateTimePicker;
  get windowSize() {
    return this.adaptiveService.size;
  }
  ensureHeights() {
    if (this.timeListHeight !== void 0) {
      return;
    }
    this.calculateHeights();
  }
  sumCSSProperties(style2, ...properties) {
    return properties.reduce((sum, property) => sum + parseFloat(style2.getPropertyValue(property)), 0) || 0;
  }
  calculateHeights(container) {
    if (!isDocumentAvailable()) {
      return;
    }
    let wrapper;
    let hostContainer;
    if (!this.isAdaptiveEnabled || this.windowSize === "large") {
      const listContainer = container && container.querySelector(".k-time-list-container");
      hostContainer = listContainer || document.body;
      wrapper = hostContainer.appendChild(timeListWrapper());
    } else {
      hostContainer = document.body;
      wrapper = hostContainer.appendChild(timeListWrapper(true, this.windowSize, this.isDateTimePicker));
    }
    const itemStyle = getComputedStyle(wrapper.querySelector("li"));
    const listStyle = getComputedStyle(wrapper.querySelector(".k-scrollable"));
    if (this.isAdaptiveEnabled && this.windowSize !== "large") {
      this.itemHeight = parseFloat(itemStyle.getPropertyValue("height"));
    } else {
      if (itemStyle["box-sizing"] === "border-box") {
        this.itemHeight = parseFloat(itemStyle.getPropertyValue("height"));
      } else {
        this.itemHeight = this.sumCSSProperties(itemStyle, "height", "padding-top", "padding-bottom");
      }
    }
    this.timeListHeight = parseFloat(listStyle.getPropertyValue("height"));
    hostContainer.removeChild(wrapper);
  }
  isActive(element) {
    if (!isDocumentAvailable() || !element) {
      return false;
    }
    return (element.nativeElement || element) === document.activeElement;
  }
  static ɵfac = function TimePickerDOMService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TimePickerDOMService)(ɵɵinject(AdaptiveService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _TimePickerDOMService,
    factory: _TimePickerDOMService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimePickerDOMService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: AdaptiveService
  }], null);
})();
var HOURS_IN_DAY = 24;
var clampToRange$3 = (rangeValue) => (value2) => value2 % rangeValue;
var clamp$3 = clampToRange$3(HOURS_IN_DAY);
var stepper$3 = (start, step) => (idx4) => clamp$3(start + idx4 * step);
var distanceFromMin$3 = (value2, min) => clamp$3(HOURS_IN_DAY + value2 - min);
var limit$3 = (borderValue) => (barrier, value2) => {
  const useBarrier = !value2 || getDate(barrier).getTime() === getDate(value2).getTime();
  return useBarrier ? barrier : setHours$1(barrier, borderValue);
};
var limitDown$3 = limit$3(0);
var limitUp$3 = limit$3(HOURS_IN_DAY - 1);
var HoursService = class _HoursService {
  intl;
  boundRange = false;
  insertUndividedMax = false;
  min;
  max;
  step;
  toListItem;
  constructor(intl) {
    this.intl = intl;
  }
  apply(value2, candidate) {
    return setHours$1(value2, candidate.getHours());
  }
  configure(settings) {
    const {
      boundRange = this.boundRange,
      insertUndividedMax = this.insertUndividedMax,
      min = this.min,
      max = this.max,
      part,
      step = this.step
    } = settings;
    this.boundRange = boundRange;
    this.insertUndividedMax = insertUndividedMax;
    this.toListItem = (hour) => {
      const date = setHours$1(MIDNIGHT_DATE, hour);
      return {
        text: this.intl.formatDate(date, part.pattern),
        value: date
      };
    };
    this.min = min;
    this.max = max;
    this.step = step;
  }
  data(selectedValue) {
    const [min] = this.range(selectedValue);
    const getHour = stepper$3(min, this.step);
    const convertToItem = (idx4) => this.toListItem(getHour(idx4));
    const data = range(0, this.countFromMin(selectedValue)).map(convertToItem);
    this.addLast(data);
    this.addMissing(data, selectedValue);
    return data;
  }
  isRangeChanged(min, max) {
    return !isEqual(this.min, min) || !isEqual(this.max, max);
  }
  limitRange(min, max, value2) {
    return this.boundRange ? [limitDown$3(min, value2), limitUp$3(max, value2)] : [min, max];
  }
  total(value2) {
    const last4 = this.insertUndividedMax && this.isLastMissing(value2) ? 1 : 0;
    const missing = this.isMissing(value2) ? 1 : 0;
    return this.countFromMin(value2) + missing + last4;
  }
  selectedIndex(value2) {
    return Math.ceil(this.divideByStep(value2));
  }
  valueInList(value2) {
    if (!value2) {
      return true;
    }
    const matchMax = this.insertUndividedMax && this.lastHour(value2) === value2.getHours();
    return matchMax || !this.isMissing(value2);
  }
  addLast(data, value2) {
    if (this.insertUndividedMax && this.isLastMissing(value2)) {
      data.push(this.toListItem(this.lastHour(value2)));
    }
    return data;
  }
  addMissing(data, value2) {
    if (this.valueInList(value2)) {
      return data;
    }
    const missingItem = this.toListItem(value2.getHours());
    data.splice(this.selectedIndex(value2), 0, missingItem);
    return data;
  }
  countFromMin(value2) {
    const [min, max] = this.range(value2);
    return Math.floor(distanceFromMin$3(max, min) / this.step) + 1;
  }
  isMissing(value2) {
    if (!value2) {
      return false;
    }
    return this.selectedIndex(value2) !== this.divideByStep(value2);
  }
  isLastMissing(value2) {
    return this.isMissing(setHours$1(this.max, this.lastHour(value2)));
  }
  divideByStep(value2) {
    return distanceFromMin$3(value2.getHours(), this.min.getHours()) / this.step;
  }
  lastHour(value2) {
    return this.range(value2)[1];
  }
  range(value2) {
    const [min, max] = this.limitRange(this.min, this.max, value2);
    return [min.getHours(), max.getHours()];
  }
  static ɵfac = function HoursService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HoursService)(ɵɵinject(IntlService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _HoursService,
    factory: _HoursService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HoursService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: IntlService
  }], null);
})();
var MINUTES_IN_HOUR = 60;
var clampToRange$2 = (rangeValue) => (value2) => value2 % rangeValue;
var clamp$2 = clampToRange$2(MINUTES_IN_HOUR);
var stepper$2 = (start, step) => (idx4) => clamp$2(start + idx4 * step);
var distanceFromMin$2 = (value2, min) => clamp$2(MINUTES_IN_HOUR + value2 - min);
var limit$2 = (borderValue) => (barrier, value2) => {
  const useBarrier = !value2 || barrier.getHours() === value2.getHours();
  return useBarrier ? barrier : setMinutes(barrier, borderValue);
};
var limitDown$2 = limit$2(0);
var limitUp$2 = limit$2(MINUTES_IN_HOUR - 1);
var MinutesService = class _MinutesService {
  intl;
  toListItem;
  min;
  max;
  step;
  insertUndividedMax = false;
  constructor(intl) {
    this.intl = intl;
  }
  apply(value2, candidate) {
    return setMinutes(value2, candidate.getMinutes());
  }
  configure(settings) {
    const {
      insertUndividedMax = this.insertUndividedMax,
      min = this.min,
      max = this.max,
      part,
      step = this.step
    } = settings;
    this.insertUndividedMax = insertUndividedMax;
    this.toListItem = (minute) => {
      const date = setMinutes(MIDNIGHT_DATE, minute);
      return {
        text: this.intl.formatDate(date, part.pattern),
        value: date
      };
    };
    this.min = min;
    this.max = max;
    this.step = step;
  }
  data(selectedValue) {
    const [min] = this.range(selectedValue);
    const getMinute = stepper$2(min, this.step);
    const convertToItem = (idx4) => this.toListItem(getMinute(idx4));
    const data = range(0, this.countFromMin(selectedValue)).map(convertToItem);
    this.addLast(data);
    this.addMissing(data, selectedValue);
    return data;
  }
  isRangeChanged(min, max) {
    return !isEqual(this.min, min) || !isEqual(this.max, max);
  }
  limitRange(min, max, value2) {
    return [limitDown$2(min, value2), limitUp$2(max, value2)];
  }
  total(value2) {
    const last4 = this.insertUndividedMax && this.isLastMissing(value2) ? 1 : 0;
    const missing = this.isMissing(value2) ? 1 : 0;
    return this.countFromMin(value2) + missing + last4;
  }
  selectedIndex(value2) {
    return Math.ceil(this.divideByStep(value2));
  }
  valueInList(value2) {
    if (!value2) {
      return true;
    }
    const matchMax = this.insertUndividedMax && this.lastMinute(value2) === value2.getMinutes();
    return matchMax || !this.isMissing(value2);
  }
  addLast(data, value2) {
    if (this.insertUndividedMax && this.isLastMissing(value2)) {
      data.push(this.toListItem(this.lastMinute(value2)));
    }
    return data;
  }
  addMissing(data, value2) {
    if (this.valueInList(value2)) {
      return data;
    }
    const missingItem = this.toListItem(value2.getMinutes());
    data.splice(this.selectedIndex(value2), 0, missingItem);
    return data;
  }
  countFromMin(value2) {
    const [min, max] = this.range(value2);
    return Math.floor(distanceFromMin$2(max, min) / this.step) + 1;
  }
  isMissing(value2) {
    if (!value2) {
      return false;
    }
    return this.selectedIndex(value2) !== this.divideByStep(value2);
  }
  isLastMissing(value2) {
    return this.isMissing(setMinutes(this.max, this.lastMinute(value2)));
  }
  divideByStep(value2) {
    return distanceFromMin$2(value2.getMinutes(), this.min.getMinutes()) / this.step;
  }
  lastMinute(value2) {
    return this.range(value2)[1];
  }
  range(value2) {
    const [min, max] = this.limitRange(this.min, this.max, value2);
    return [min.getMinutes(), max.getMinutes()];
  }
  static ɵfac = function MinutesService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MinutesService)(ɵɵinject(IntlService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _MinutesService,
    factory: _MinutesService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MinutesService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: IntlService
  }], null);
})();
var SECONDS_IN_HOUR = 60;
var clampToRange$1 = (rangeValue) => (value2) => value2 % rangeValue;
var clamp$1 = clampToRange$1(SECONDS_IN_HOUR);
var stepper$1 = (start, step) => (idx4) => clamp$1(start + idx4 * step);
var distanceFromMin$1 = (value2, min) => clamp$1(SECONDS_IN_HOUR + value2 - min);
var limit$1 = (borderValue) => (barrier, value2) => {
  const useBarrier = !value2 || barrier.getHours() === value2.getHours() && barrier.getMinutes() === value2.getMinutes();
  return useBarrier ? barrier : setSeconds(barrier, borderValue);
};
var limitDown$1 = limit$1(0);
var limitUp$1 = limit$1(SECONDS_IN_HOUR - 1);
var SecondsService = class _SecondsService {
  intl;
  toListItem;
  min;
  max;
  step;
  insertUndividedMax = false;
  constructor(intl) {
    this.intl = intl;
  }
  apply(value2, candidate) {
    return setSeconds(value2, candidate.getSeconds());
  }
  configure(settings) {
    const {
      insertUndividedMax = this.insertUndividedMax,
      min = this.min,
      max = this.max,
      part,
      step = this.step
    } = settings;
    this.insertUndividedMax = insertUndividedMax;
    this.toListItem = (second) => {
      const date = setSeconds(MIDNIGHT_DATE, second);
      return {
        text: this.intl.formatDate(date, part.pattern),
        value: date
      };
    };
    this.min = min;
    this.max = max;
    this.step = step;
  }
  data(selectedValue) {
    const [min] = this.range(selectedValue);
    const getSecond = stepper$1(min, this.step);
    const convertToItem = (idx4) => this.toListItem(getSecond(idx4));
    const data = range(0, this.countFromMin(selectedValue)).map(convertToItem);
    this.addLast(data);
    this.addMissing(data, selectedValue);
    return data;
  }
  isRangeChanged(min, max) {
    return !isEqual(this.min, min) || !isEqual(this.max, max);
  }
  limitRange(min, max, value2) {
    return [limitDown$1(min, value2), limitUp$1(max, value2)];
  }
  total(value2) {
    const last4 = this.insertUndividedMax && this.isLastMissing(value2) ? 1 : 0;
    const missing = this.isMissing(value2) ? 1 : 0;
    return this.countFromMin(value2) + missing + last4;
  }
  selectedIndex(value2) {
    return Math.ceil(this.divideByStep(value2));
  }
  valueInList(value2) {
    if (!value2) {
      return true;
    }
    const matchMax = this.insertUndividedMax && this.lastSecond(value2) === value2.getSeconds();
    return matchMax || !this.isMissing(value2);
  }
  divideByStep(value2) {
    return distanceFromMin$1(value2.getSeconds(), this.min.getSeconds()) / this.step;
  }
  addLast(data, value2) {
    if (this.insertUndividedMax && this.isLastMissing(value2)) {
      data.push(this.toListItem(this.lastSecond(value2)));
    }
    return data;
  }
  addMissing(data, value2) {
    if (this.valueInList(value2)) {
      return data;
    }
    const missingItem = this.toListItem(value2.getSeconds());
    data.splice(this.selectedIndex(value2), 0, missingItem);
    return data;
  }
  countFromMin(value2) {
    const [min, max] = this.range(value2);
    return Math.floor(distanceFromMin$1(max, min) / this.step) + 1;
  }
  isMissing(value2) {
    if (!value2) {
      return false;
    }
    return this.selectedIndex(value2) !== this.divideByStep(value2);
  }
  isLastMissing(value2) {
    return this.isMissing(setSeconds(this.max, this.lastSecond(value2)));
  }
  lastSecond(value2) {
    return this.range(value2)[1];
  }
  range(value2) {
    const [min, max] = this.limitRange(this.min, this.max, value2);
    return [min.getSeconds(), max.getSeconds()];
  }
  static ɵfac = function SecondsService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SecondsService)(ɵɵinject(IntlService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _SecondsService,
    factory: _SecondsService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SecondsService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: IntlService
  }], null);
})();
var MILLISECONDS_IN_SECOND = 1e3;
var clampToRange = (rangeValue) => (value2) => value2 % rangeValue;
var clamp2 = clampToRange(MILLISECONDS_IN_SECOND);
var stepper = (start, step) => (idx4) => clamp2(start + idx4 * step);
var distanceFromMin = (value2, min) => clamp2(MILLISECONDS_IN_SECOND + value2 - min);
var limit2 = (borderValue) => (barrier, value2) => {
  const useBarrier = !value2 || barrier.getHours() === value2.getHours() && barrier.getMinutes() === value2.getMinutes() && barrier.getSeconds() === value2.getSeconds();
  return useBarrier ? barrier : setMilliseconds(barrier, borderValue);
};
var limitDown = limit2(0);
var limitUp = limit2(MILLISECONDS_IN_SECOND - 1);
var MillisecondsService = class _MillisecondsService {
  intl;
  toListItem;
  min;
  max;
  step;
  insertUndividedMax = false;
  constructor(intl) {
    this.intl = intl;
  }
  apply(value2, candidate) {
    return setMilliseconds(value2, candidate.getMilliseconds());
  }
  configure(settings) {
    const {
      insertUndividedMax = this.insertUndividedMax,
      min = this.min,
      max = this.max,
      step = this.step
    } = settings;
    this.insertUndividedMax = insertUndividedMax;
    this.toListItem = (millisecond) => {
      const date = setMilliseconds(MIDNIGHT_DATE, millisecond);
      return {
        text: this.intl.formatDate(date, "SSS"),
        // Always "SSS" for the popup UI
        value: date
      };
    };
    this.min = min;
    this.max = max;
    this.step = step;
  }
  data(selectedValue) {
    const [min] = this.range(selectedValue);
    const getMillisecond = stepper(min, this.step);
    const convertToItem = (idx4) => this.toListItem(getMillisecond(idx4));
    const data = range(0, this.countFromMin(selectedValue)).map(convertToItem);
    this.addLast(data);
    this.addMissing(data, selectedValue);
    return data;
  }
  isRangeChanged(min, max) {
    return !isEqual(this.min, min) || !isEqual(this.max, max);
  }
  limitRange(min, max, value2) {
    return [limitDown(min, value2), limitUp(max, value2)];
  }
  total(value2) {
    const last4 = this.insertUndividedMax && this.isLastMissing(value2) ? 1 : 0;
    const missing = this.isMissing(value2) ? 1 : 0;
    return this.countFromMin(value2) + missing + last4;
  }
  selectedIndex(value2) {
    return Math.ceil(this.divideByStep(value2));
  }
  valueInList(value2) {
    if (!value2) {
      return true;
    }
    const matchMax = this.insertUndividedMax && this.lastMillisecond(value2) === value2.getMilliseconds();
    return matchMax || !this.isMissing(value2);
  }
  divideByStep(value2) {
    return distanceFromMin(value2.getMilliseconds(), this.min.getMilliseconds()) / this.step;
  }
  addLast(data, value2) {
    if (this.insertUndividedMax && this.isLastMissing(value2)) {
      data.push(this.toListItem(this.lastMillisecond(value2)));
    }
    return data;
  }
  addMissing(data, value2) {
    if (this.valueInList(value2)) {
      return data;
    }
    const missingItem = this.toListItem(value2.getMilliseconds());
    data.splice(this.selectedIndex(value2), 0, missingItem);
    return data;
  }
  countFromMin(value2) {
    const [min, max] = this.range(value2);
    return Math.floor(distanceFromMin(max, min) / this.step) + 1;
  }
  isMissing(value2) {
    if (!value2) {
      return false;
    }
    return this.selectedIndex(value2) !== this.divideByStep(value2);
  }
  isLastMissing(value2) {
    return this.isMissing(setMilliseconds(this.max, this.lastMillisecond(value2)));
  }
  lastMillisecond(value2) {
    return this.range(value2)[1];
  }
  range(value2) {
    const [min, max] = this.limitRange(this.min, this.max, value2);
    return [min.getMilliseconds(), max.getMilliseconds()];
  }
  static ɵfac = function MillisecondsService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MillisecondsService)(ɵɵinject(IntlService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _MillisecondsService,
    factory: _MillisecondsService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MillisecondsService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: IntlService
  }], null);
})();
var setHours = (date, hours) => {
  const clone = cloneDate(date);
  clone.setHours(hours);
  return clone;
};
var isAM = (value2) => value2 !== null && value2 < 12;
var isPM = (value2) => value2 !== null && (!value2 || value2 > 11);
var inRange = (value2, min, max) => !min && !max || value2 >= min && value2 <= max;
var inReverseRange = (value2, min, max) => !min && !max || value2 >= min || value2 <= max;
var DayPeriodService = class _DayPeriodService {
  intl;
  min;
  max;
  part;
  constructor(intl) {
    this.intl = intl;
  }
  /**
   * @hidden
   */
  apply(value2, candidate) {
    const hour = value2.getHours();
    const hourAM = isAM(hour);
    const candidateAM = isAM(candidate.getHours());
    if (hourAM && candidateAM || !hourAM && !candidateAM) {
      return value2;
    }
    const [min, max = 24] = this.normalizedRange();
    const result = hour + (candidateAM ? -12 : 12);
    return setHours(value2, Math.min(Math.max(min, result), max || 24));
  }
  /**
   * @hidden
   */
  configure(settings) {
    const {
      min = this.min,
      max = this.max,
      part = this.part
    } = settings;
    this.min = min;
    this.max = max;
    this.part = part;
  }
  /**
   * @hidden
   */
  data(_) {
    const names = this.part.names;
    if (!names) {
      return [];
    }
    const data = [];
    const [min, max] = this.normalizedRange();
    const dayPeriod = this.intl.dateFormatNames(names);
    if (isAM(min)) {
      data.push({
        text: dayPeriod.am,
        value: setHours(this.min, min)
      });
    }
    if (isPM(max)) {
      data.push({
        text: dayPeriod.pm,
        value: setHours(this.min, Math.max(12, max))
      });
    }
    return this.min.getHours() !== min ? data.reverse() : data;
  }
  /**
   * @hidden
   */
  isRangeChanged(_, __) {
    return false;
  }
  /**
   * @hidden
   */
  limitRange(min, max, _) {
    return [min, max];
  }
  /**
   * @hidden
   */
  total() {
    const [min, max] = this.normalizedRange();
    if (!min && !max) {
      return 2;
    }
    if (min > 11 || max < 12) {
      return 1;
    }
    return 2;
  }
  /**
   * @hidden
   */
  selectedIndex(value2) {
    if (!this.valueInList(value2)) {
      return -1;
    }
    const index = Math.floor(value2.getHours() / 12);
    return this.min.getHours() === this.normalizedRange()[0] ? index : index === 0 ? 1 : 0;
  }
  /**
   * @hidden
   */
  valueInList(value2) {
    const reverse = this.min.getHours() !== this.normalizedRange()[0];
    const isInRange2 = reverse ? inReverseRange : inRange;
    return isInRange2(value2.getHours(), this.min.getHours(), this.max.getHours());
  }
  normalizedRange() {
    const minHour = this.min.getHours();
    const maxHour = this.max.getHours();
    return [Math.min(minHour, maxHour), Math.max(minHour, maxHour)];
  }
  static ɵfac = function DayPeriodService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DayPeriodService)(ɵɵinject(IntlService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DayPeriodService,
    factory: _DayPeriodService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DayPeriodService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: IntlService
  }], null);
})();
var SNAP_THRESHOLD = 0.05;
var SCROLL_THRESHOLD = 2;
var nil = () => null;
var getters = {
  [Keys.End]: (data, _) => data[data.length - 1],
  [Keys.Home]: (data, _) => data[0],
  [Keys.ArrowUp]: (data, index) => data[index - 1],
  [Keys.ArrowDown]: (data, index) => data[index + 1]
};
var services = {
  [TIME_PART.dayperiod]: DayPeriodService,
  [TIME_PART.hour]: HoursService,
  [TIME_PART.minute]: MinutesService,
  [TIME_PART.second]: SecondsService,
  [TIME_PART.millisecond]: MillisecondsService
};
var TimeListComponent = class _TimeListComponent {
  element;
  injector;
  dom;
  renderer;
  zone;
  localization;
  min = cloneDate(MIDNIGHT_DATE);
  max = cloneDate(MAX_TIME);
  part;
  step = 1;
  disabled = false;
  value;
  isLast = false;
  isFirst = false;
  valueChange = new EventEmitter();
  tabOutLastPart = new EventEmitter();
  tabOutFirstPart = new EventEmitter();
  virtualization;
  get tabIndex() {
    return this.disabled ? void 0 : 0;
  }
  componentClass = true;
  get isDayPeriod() {
    return this.part?.type === "dayperiod";
  }
  get currentSelectedIndex() {
    return this.selectedIndex(this.value);
  }
  get roleAttribute() {
    return "listbox";
  }
  get ariaLabel() {
    return this.localization.get(this.part?.type);
  }
  animateToIndex = true;
  isActive = false;
  skip = 0;
  total = 60;
  service;
  itemHeight;
  listHeight;
  topOffset;
  bottomOffset;
  bottomThreshold;
  topThreshold;
  style;
  data = [];
  indexToScroll = -1;
  scrollSubscription;
  domEvents = [];
  constructor(element, injector, dom, renderer, zone, localization) {
    this.element = element;
    this.injector = injector;
    this.dom = dom;
    this.renderer = renderer;
    this.zone = zone;
    this.localization = localization;
  }
  ngOnChanges(changes) {
    if (changes.part) {
      this.service = this.injector.get(services[this.part.type]);
      this.service.configure(this.serviceSettings());
    }
    const value2 = this.value;
    const valueChanges = changes.value || {};
    const [min, max] = this.service.limitRange(this.min, this.max, value2);
    if (this.service.isRangeChanged(min, max) || changes.min || changes.max || changes.step) {
      this.data = [];
      this.service.configure(this.serviceSettings({
        min,
        max
      }));
    }
    if (!this.data.length || this.hasMissingValue(valueChanges)) {
      this.animateToIndex = false;
      this.data = this.service.data(value2);
    }
    this.animateToIndex = this.animateToIndex && this.textHasChanged(valueChanges);
    this.total = this.service.total(value2);
    this.indexToScroll = this.selectedIndex(value2);
  }
  ngOnInit() {
    this.animateToIndex = true;
    this.dom.ensureHeights();
    this.itemHeight = this.dom.itemHeight;
    this.listHeight = this.dom.timeListHeight;
    this.topOffset = (this.listHeight - this.itemHeight) / 2;
    this.bottomOffset = this.listHeight - this.itemHeight;
    this.topThreshold = this.itemHeight * SNAP_THRESHOLD;
    this.bottomThreshold = this.itemHeight * (1 - SNAP_THRESHOLD);
    const translate = `translateY(${this.topOffset}px)`;
    this.style = {
      transform: translate,
      "-ms-transform": translate
    };
    if (this.element) {
      this.zone.runOutsideAngular(() => {
        this.bindEvents();
      });
    }
  }
  ngOnDestroy() {
    this.scrollSubscription.unsubscribe();
    this.domEvents.forEach((unbindCallback) => unbindCallback());
  }
  ngAfterViewInit() {
    this.scrollOnce((index) => this.virtualization.scrollToIndex(index));
  }
  ngAfterViewChecked() {
    this.scrollOnce((index) => {
      const action = this.animateToIndex ? "animateToIndex" : "scrollToIndex";
      this.virtualization[action](index);
      this.animateToIndex = true;
    });
  }
  getCurrentItem() {
    return this.indexToScroll >= 0 ? this.data[this.indexToScroll] : null;
  }
  handleChange(dataItem) {
    const candidate = this.service.apply(this.value, dataItem.value);
    if (this.value.getTime() === candidate.getTime()) {
      return;
    }
    this.indexToScroll = this.data.indexOf(dataItem);
    this.value = candidate;
    this.valueChange.emit(candidate);
  }
  handleItemClick(args) {
    const item = closestInScope2(args.target, (node) => node.hasAttribute("data-timelist-item-index"), this.element.nativeElement);
    if (item) {
      const index = item.getAttribute("data-timelist-item-index");
      this.handleChange(this.data[index]);
    }
  }
  /**
   * Focuses the host element of the TimeList.
   *
   * @example
   * ```ts
   * _@Component({
   * selector: 'my-app',
   * template: `
   *  <button (click)="timelist.focus()">Focus TimeList</button>
   *  <kendo-timelist #timelist></kendo-timelist>
   * `
   * })
   * export class AppComponent { }
   * ```
   */
  focus() {
    if (!this.element) {
      return;
    }
    this.element.nativeElement.focus();
  }
  /**
   * Blurs the TimeList component.
   */
  blur() {
    if (!this.element) {
      return;
    }
    this.element.nativeElement.blur();
  }
  itemOffset(scrollTop) {
    const valueIndex = this.selectedIndex(this.value);
    const activeIndex = this.virtualization.activeIndex();
    const offset3 = this.virtualization.itemOffset(activeIndex);
    const distance = Math.abs(Math.ceil(scrollTop) - offset3);
    if (valueIndex === activeIndex && distance < SCROLL_THRESHOLD) {
      return offset3;
    }
    const scrollUp = valueIndex > activeIndex;
    const moveToNext = scrollUp && distance >= this.bottomThreshold || !scrollUp && distance > this.topThreshold;
    return moveToNext ? this.virtualization.itemOffset(activeIndex + 1) : offset3;
  }
  hasMissingValue({
    previousValue,
    currentValue
  }) {
    const isPreviousMissing = previousValue && !this.service.valueInList(previousValue);
    const isCurrentMissing = currentValue && !this.service.valueInList(currentValue);
    return isPreviousMissing || isCurrentMissing;
  }
  scrollOnce(action) {
    if (this.indexToScroll !== -1) {
      action(this.indexToScroll);
      this.indexToScroll = -1;
    }
  }
  serviceSettings(settings) {
    const defaults = {
      boundRange: false,
      insertUndividedMax: false,
      max: this.max,
      min: this.min,
      part: this.part,
      step: this.step
    };
    const result = Object.assign({}, defaults, settings);
    result.boundRange = result.part.type !== "hour";
    return result;
  }
  selectedIndex(value2) {
    if (!value2) {
      return -1;
    }
    return this.service.selectedIndex(value2);
  }
  textHasChanged({
    previousValue,
    currentValue
  }) {
    if (!previousValue || !currentValue) {
      return false;
    }
    const oldData = this.data[this.selectedIndex(previousValue)];
    const newData = this.data[this.selectedIndex(currentValue)];
    return oldData && newData && oldData.text !== newData.text;
  }
  handleKeyDown(e) {
    const code = normalizeKeys(e);
    if (code === Keys.Tab && !e.shiftKey && this.isLast) {
      e.preventDefault();
      this.tabOutLastPart.emit();
    }
    if (code === Keys.Tab && e.shiftKey && this.isFirst) {
      e.preventDefault();
      this.tabOutFirstPart.emit();
    }
    const getter5 = getters[code] || nil;
    const dataItem = getter5(this.data, this.service.selectedIndex(this.value));
    if (dataItem) {
      this.handleChange(dataItem);
      e.preventDefault();
    }
  }
  bindEvents() {
    this.scrollSubscription = this.virtualization.scroll$().pipe(debounceTime(100), map((e) => e.target.scrollTop), map((top) => this.itemOffset(top)), map((itemOffset) => this.virtualization.itemIndex(itemOffset))).subscribe((index) => {
      this.virtualization.scrollToIndex(index);
      this.handleChange(this.data[index]);
    });
    const element = this.element.nativeElement;
    this.domEvents.push(this.renderer.listen(element, "mouseover", () => !this.isActive && this.focus()), this.renderer.listen(element, "click", () => this.focus()), this.renderer.listen(element, "blur", () => this.isActive = false), this.renderer.listen(element, "focus", () => this.isActive = true), this.renderer.listen(element, "keydown", this.handleKeyDown.bind(this)));
  }
  static ɵfac = function TimeListComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TimeListComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(TimePickerDOMService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TimeListComponent,
    selectors: [["kendo-timelist"]],
    viewQuery: function TimeListComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(VirtualizationComponent, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.virtualization = _t.first);
      }
    },
    hostVars: 3,
    hostBindings: function TimeListComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("tabindex", ctx.tabIndex);
        ɵɵclassProp("k-time-list", ctx.componentClass);
      }
    },
    inputs: {
      min: "min",
      max: "max",
      part: "part",
      step: "step",
      disabled: "disabled",
      value: "value",
      isLast: "isLast",
      isFirst: "isFirst"
    },
    outputs: {
      valueChange: "valueChange",
      tabOutLastPart: "tabOutLastPart",
      tabOutFirstPart: "tabOutFirstPart"
    },
    features: [ɵɵNgOnChangesFeature],
    decls: 4,
    vars: 15,
    consts: [["tabindex", "-1", 1, "k-time-container", 3, "skip", "take", "total", "itemHeight", "maxScrollDifference", "topOffset", "bottomOffset"], [1, "k-reset", 3, "ngStyle", "kendoEventsOutsideAngular", "scope"], [1, "k-item"]],
    template: function TimeListComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "kendo-virtualization", 0)(1, "ul", 1);
        ɵɵrepeaterCreate(2, TimeListComponent_For_3_Template, 3, 4, "li", 2, ɵɵrepeaterTrackByIndex);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵproperty("skip", ctx.skip)("take", ctx.total)("total", ctx.total)("itemHeight", ctx.itemHeight)("maxScrollDifference", ctx.listHeight)("topOffset", ctx.topOffset)("bottomOffset", ctx.bottomOffset);
        ɵɵattribute("role", ctx.roleAttribute)("aria-label", ctx.ariaLabel);
        ɵɵadvance();
        ɵɵproperty("ngStyle", ctx.style)("kendoEventsOutsideAngular", ɵɵpureFunction1(13, _c5, ctx.handleItemClick))("scope", ctx);
        ɵɵattribute("role", "presentation");
        ɵɵadvance();
        ɵɵrepeater(ctx.data);
      }
    },
    dependencies: [VirtualizationComponent, NgStyle, EventsOutsideAngularDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimeListComponent, [{
    type: Component,
    args: [{
      selector: "kendo-timelist",
      template: `
    <kendo-virtualization
      [attr.role]="roleAttribute"
      [attr.aria-label]="ariaLabel"
      [skip]="skip"
      [take]="total"
      [total]="total"
      [itemHeight]="itemHeight"
      [maxScrollDifference]="listHeight"
      [topOffset]="topOffset"
      [bottomOffset]="bottomOffset"
      class="k-time-container"
      tabindex="-1"
      >
      <ul [ngStyle]="style" class="k-reset"
            [kendoEventsOutsideAngular]="{
                click: handleItemClick
            }"
        [scope]="this"
        [attr.role]="'presentation'"
        >
        @for (item of data; track $index; let index = $index) {
          <li class="k-item"
            [attr.data-timelist-item-index]="index"
            [attr.role]="'option'"
            [attr.aria-selected]="index === currentSelectedIndex"
            >
            <span>{{item.text}}</span>
          </li>
        }
      </ul>
    </kendo-virtualization>
    `,
      standalone: true,
      imports: [VirtualizationComponent, NgStyle, EventsOutsideAngularDirective]
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Injector
  }, {
    type: TimePickerDOMService
  }, {
    type: Renderer2
  }, {
    type: NgZone
  }, {
    type: LocalizationService
  }], {
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    part: [{
      type: Input
    }],
    step: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    isLast: [{
      type: Input
    }],
    isFirst: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    tabOutLastPart: [{
      type: Output
    }],
    tabOutFirstPart: [{
      type: Output
    }],
    virtualization: [{
      type: ViewChild,
      args: [VirtualizationComponent, {
        static: true
      }]
    }],
    tabIndex: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    componentClass: [{
      type: HostBinding,
      args: ["class.k-time-list"]
    }]
  });
})();
var isEqualTillMinute = (value2, min) => value2.getHours() === min.getHours() && value2.getMinutes() === min.getMinutes();
var isEqualTillSecond = (value2, min) => isEqualTillMinute(value2, min) && value2.getSeconds() === min.getSeconds();
var isEqualTillMillisecond = (value2, min) => isEqualTillSecond(value2, min) && value2.getMilliseconds() === min.getMilliseconds();
var defaultGetters = [{
  type: TIME_PART.hour,
  getter: (value2) => value2.getHours(),
  minGetter: (_, min) => min.getHours()
}, {
  type: TIME_PART.minute,
  getter: (value2) => value2.getMinutes(),
  minGetter: (value2, min) => isEqualTillMinute(value2, min) ? min.getMinutes() : 0
}, {
  type: TIME_PART.second,
  getter: (value2) => value2.getSeconds(),
  minGetter: (value2, min) => isEqualTillSecond(value2, min) ? min.getSeconds() : 0
}, {
  type: TIME_PART.millisecond,
  getter: (value2) => value2.getMilliseconds(),
  minGetter: (value2, min) => isEqualTillMillisecond(value2, min) ? min.getMilliseconds() : 0
}];
var left = (getter5) => (origin, _) => getter5(origin);
var right = (getter5) => (_, candidate) => getter5(candidate);
var convertToObject = (parts) => parts.reduce((obj, p) => {
  obj[p.type] = p.type;
  return obj;
}, {});
var getterByPart = (parts) => (g) => parts[g.type] ? right(g.getter) : left(g.getter);
var gettersFactory = (getters2) => (parts) => getters2.map(getterByPart(convertToObject(parts)));
var snapValue = (getter5, minGetter, step) => (date, min) => {
  const value2 = getter5(date);
  const minValue = minGetter(date, min);
  const rest = value2 - minValue;
  if (rest < 0) {
    return minValue;
  }
  const mod = rest % step;
  return value2 - mod + (mod > step / 2 ? step : 0);
};
var snappersFactory = (getters2) => (steps) => getters2.map((g) => {
  const step = steps[g.type];
  return step ? snapValue(g.getter, g.minGetter, step) : g.getter;
});
var generateGetters = gettersFactory(defaultGetters);
var generateSnappers = snappersFactory(defaultGetters);
var valueMerger = (getters2) => (origin, candidate) => {
  origin.setHours(...getters2.map((g) => g(origin, candidate)));
  return origin;
};
var snapTime = (snappers) => (candidate, min) => {
  const date = cloneDate(candidate);
  date.setHours(...snappers.map((s) => s(date, min)));
  return date;
};
var TimePickerMessages = class _TimePickerMessages extends ComponentMessages {
  /**
   * Specifies the text of the **Accept** button in the popup footer of the TimeList.
   */
  accept;
  /**
   * Specifies the label of the **Accept** button in the popup footer of the TimeList.
   */
  acceptLabel;
  /**
   * Specifies the text of the **Cancel** button in the popup footer of the TimeList.
   */
  cancel;
  /**
   * Specifies the label of the **Cancel** button in the popup footer of the TimeList.
   */
  cancelLabel;
  /**
   * Specifies the text of the **Now** button in the popup header of the TimeList.
   */
  now;
  /**
   * Specifies the label of the **Now** button in the popup header of the TimeList.
   */
  nowLabel;
  /**
   * Specifies the title of the **Toggle** button of the TimePicker.
   */
  toggle;
  /**
   * Specifies the label of the **Hour** part in the TimePicker.
   */
  hour;
  /**
   * Specifies the label of the **Minute** part in the TimePicker.
   */
  minute;
  /**
   * Specifies the label of the **Second** part in the TimePicker.
   */
  second;
  /**
   * Specifies the label of the **Millisecond** part in the TimePicker.
   */
  millisecond;
  /**
   * Specifies the label of the **Dayperiod** part in the TimePicker.
   */
  dayperiod;
  /**
   * Specifies the title of the **Clear** button of the TimePicker.
   */
  clearTitle;
  /**
   * Specifies the title of the **Close** button of the ActionSheet that renders instead of the popup when using small screen devices in adaptive mode.
   */
  adaptiveCloseButtonTitle;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵTimePickerMessages_BaseFactory;
    return function TimePickerMessages_Factory(__ngFactoryType__) {
      return (ɵTimePickerMessages_BaseFactory || (ɵTimePickerMessages_BaseFactory = ɵɵgetInheritedFactory(_TimePickerMessages)))(__ngFactoryType__ || _TimePickerMessages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _TimePickerMessages,
    selectors: [["kendo-timepicker-messages-base"]],
    inputs: {
      accept: "accept",
      acceptLabel: "acceptLabel",
      cancel: "cancel",
      cancelLabel: "cancelLabel",
      now: "now",
      nowLabel: "nowLabel",
      toggle: "toggle",
      hour: "hour",
      minute: "minute",
      second: "second",
      millisecond: "millisecond",
      dayperiod: "dayperiod",
      clearTitle: "clearTitle",
      adaptiveCloseButtonTitle: "adaptiveCloseButtonTitle"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimePickerMessages, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line
      selector: "kendo-timepicker-messages-base"
    }]
  }], null, {
    accept: [{
      type: Input
    }],
    acceptLabel: [{
      type: Input
    }],
    cancel: [{
      type: Input
    }],
    cancelLabel: [{
      type: Input
    }],
    now: [{
      type: Input
    }],
    nowLabel: [{
      type: Input
    }],
    toggle: [{
      type: Input
    }],
    hour: [{
      type: Input
    }],
    minute: [{
      type: Input
    }],
    second: [{
      type: Input
    }],
    millisecond: [{
      type: Input
    }],
    dayperiod: [{
      type: Input
    }],
    clearTitle: [{
      type: Input
    }],
    adaptiveCloseButtonTitle: [{
      type: Input
    }]
  });
})();
var TimeSelectorLocalizedMessagesDirective = class _TimeSelectorLocalizedMessagesDirective extends TimePickerMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function TimeSelectorLocalizedMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TimeSelectorLocalizedMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _TimeSelectorLocalizedMessagesDirective,
    selectors: [["", "kendoTimeSelectorLocalizedMessages", ""]],
    features: [ɵɵProvidersFeature([{
      provide: TimePickerMessages,
      useExisting: forwardRef(() => _TimeSelectorLocalizedMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimeSelectorLocalizedMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: TimePickerMessages,
        useExisting: forwardRef(() => TimeSelectorLocalizedMessagesDirective)
      }],
      selector: "[kendoTimeSelectorLocalizedMessages]",
      standalone: true
    }]
  }], () => [{
    type: LocalizationService
  }], null);
})();
var listReducer = (state2, list2, idx4, all) => {
  if (state2.length || !list2.isActive) {
    return state2;
  }
  return [{
    next: all[idx4 + 1] || list2,
    prev: all[idx4 - 1] || list2
  }];
};
var Direction2;
(function(Direction3) {
  Direction3[Direction3["Left"] = 0] = "Left";
  Direction3[Direction3["Right"] = 1] = "Right";
})(Direction2 || (Direction2 = {}));
var TimeSelectorComponent = class _TimeSelectorComponent {
  localization;
  cdr;
  element;
  intl;
  dom;
  zone;
  renderer;
  pickerService;
  accept;
  cancel;
  now;
  timeLists;
  timeListWrappers;
  /**
   * @hidden
   */
  get disabledClass() {
    return this.disabled;
  }
  /**
   * Specifies the time format that displays the time list columns.
   *
   * @default 't'
   */
  format = "t";
  /**
   * Sets the smallest valid time value.
   */
  min = cloneDate(MIN_TIME);
  /**
   * Sets the largest valid time value.
   */
  max = cloneDate(MAX_TIME);
  /**
   * Controls the display of the **Cancel** button in the popup.
   *
   * @default true
   */
  cancelButton = true;
  /**
   * Controls the display of the **Set** button in the popup.
   *
   * @default true
   */
  setButton = true;
  /**
   * Controls the display of the **Now** button in the popup.
   *
   * When the current time is out of range or the incremental step is greater than `1`, the **Now** button is hidden.
   *
   * @default true
   */
  nowButton = true;
  /**
   * Sets the `disabled` property of the `TimeSelector` and controls whether the component is active.
   *
   * @default false
   */
  disabled = false;
  /**
   * Sets the adaptive mode for the component.
   * Use this property to enable proper height calculation in the DOM service.
   */
  isAdaptiveEnabled;
  /**
   * Specifies whether the component is used as part of a DateTimePicker.
   */
  isDateTimePicker;
  /**
   * Configures the incremental steps of the TimeSelector.
   *
   * When the incremental step is greater than `1`, the **Now** button is hidden.
   */
  set steps(steps) {
    this._steps = steps || {};
  }
  get steps() {
    return this._steps;
  }
  /**
   * Specifies the value of the TimeSelector component.
   */
  value = null;
  /**
   * Fires each time the user selects a new value.
   */
  valueChange = new EventEmitter();
  /**
   * Fires each time the user cancels the selected value.
   */
  valueReject = new EventEmitter();
  tabOutLastPart = new EventEmitter();
  tabOutFirstPart = new EventEmitter();
  tabOutNow = new EventEmitter();
  dateFormatParts;
  isActive = false;
  showNowButton = true;
  set current(value2) {
    this._current = timeInRange(this.snapTime(cloneDate(value2 || MIDNIGHT_DATE), this.min), this.min, this.max);
    if (!NgZone.isInAngularZone()) {
      this.cdr.detectChanges();
    }
  }
  get current() {
    return this._current;
  }
  get activeListIndex() {
    return this._activeListIndex;
  }
  set activeListIndex(value2) {
    this._activeListIndex = value2;
    if (!this.timeListWrappers || !this.timeListWrappers.length) {
      return;
    }
    this.timeListWrappers.forEach((listWrapper) => {
      this.renderer.removeClass(listWrapper.nativeElement, "k-focus");
    });
    if (value2 >= 0) {
      const listIndex = this.listIndex(value2);
      const focusedWrapper = this.timeListWrappers.toArray()[listIndex];
      if (focusedWrapper) {
        this.renderer.addClass(focusedWrapper.nativeElement, "k-focus");
      }
    }
  }
  mergeValue;
  snapTime;
  _activeListIndex = -1;
  _current;
  _steps = {};
  subscriptions;
  domEvents = [];
  constructor(localization, cdr, element, intl, dom, zone, renderer, pickerService) {
    this.localization = localization;
    this.cdr = cdr;
    this.element = element;
    this.intl = intl;
    this.dom = dom;
    this.zone = zone;
    this.renderer = renderer;
    this.pickerService = pickerService;
    if (this.pickerService) {
      this.pickerService.timeSelector = this;
    }
  }
  /**
   * @hidden
   */
  ngOnInit() {
    this.subscriptions = this.intl.changes.subscribe(this.intlChange.bind(this));
    if (this.localization) {
      this.subscriptions.add(this.localization.changes.subscribe(() => this.cdr.markForCheck()));
    }
    this.renderer.addClass(this.element.nativeElement, "k-timeselector");
    this.dom.isAdaptiveEnabled = this.isAdaptiveEnabled;
    this.dom.isDateTimePicker = this.isDateTimePicker;
    this.dom.calculateHeights(this.element.nativeElement);
    this.init();
    this.bindEvents();
  }
  /**
   * @hidden
   */
  ngOnChanges() {
    this.init();
  }
  ngOnDestroy() {
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
    }
    if (this.pickerService) {
      this.pickerService.timeSelector = null;
    }
    this.domEvents.forEach((unbindCallback) => unbindCallback());
  }
  /**
   * Focuses the TimeSelector component.
   */
  focus() {
    const list2 = this.timeLists.first;
    if (!list2) {
      return;
    }
    list2.focus();
  }
  /**
   * Blurs the TimeSelector component.
   */
  blur() {
    const list2 = this.timeLists.first;
    if (!list2) {
      return;
    }
    list2.blur();
  }
  /**
   * @hidden
   */
  handleAccept() {
    this.handleChange(this.mergeValue(cloneDate(this.value || getDate(getNow())), this.current));
  }
  /**
   * @hidden
   */
  handleNow() {
    this.current = getNow();
    this.handleChange(this.current);
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  handleReject() {
    this.current = this.value;
    this.valueReject.emit();
  }
  /**
   * @hidden
   */
  handleFocus(args) {
    if (this.isActive) {
      return;
    }
    this.isActive = true;
    this.emitFocus(args);
  }
  /**
   * @hidden
   */
  handleListFocus(args) {
    const index = parseInt(args.target.getAttribute("data-timelist-index"), 10);
    this.activeListIndex = index;
    this.handleFocus(args);
  }
  /**
   * @hidden
   */
  handleBlur(args) {
    const currentTarget = currentFocusTarget(args);
    if (currentTarget && this.containsElement(currentTarget)) {
      return;
    }
    this.activeListIndex = -1;
    this.isActive = false;
    this.emitBlur(args);
  }
  /**
   * @hidden
   */
  containsElement(element) {
    return Boolean(closest2(element, (node) => node === this.element.nativeElement));
  }
  /**
   * @hidden
   */
  handleTabOut(event) {
    const {
      code,
      shiftKey
    } = event;
    if (event.target === this.now?.nativeElement && code === Keys.Tab && shiftKey) {
      event.preventDefault();
      if (this.isDateTimePicker) {
        this.tabOutNow.emit();
      } else {
        this.cancel ? this.cancel.nativeElement.focus() : this.accept?.nativeElement.focus();
      }
      return;
    }
    if (code === Keys.Tab && !shiftKey && event.target !== this.now?.nativeElement) {
      event.preventDefault();
      if (document.activeElement === this.accept.nativeElement) {
        if (this.cancel) {
          this.cancel.nativeElement.focus();
        } else {
          this.now ? this.now.nativeElement.focus() : this.timeLists.first.focus();
        }
      } else {
        this.now ? this.now.nativeElement.focus() : this.timeLists.first.focus();
      }
    }
  }
  partStep(part) {
    return this.steps[part.type] || 1;
  }
  init(changes) {
    if (!changes || hasChange(changes, "format")) {
      this.dateFormatParts = this.intl.splitDateFormat(this.format);
      this.mergeValue = valueMerger(generateGetters(this.dateFormatParts));
    }
    if (!changes || hasChange(changes, "steps")) {
      this.snapTime = snapTime(generateSnappers(this.steps));
    }
    if (!changes || hasChange(changes, "value")) {
      this.current = this.value;
    }
    this.showNowButton = !this.hasSteps() && this.nowButton && isInTimeRange(getNow(), this.min, this.max);
  }
  focusList(dir) {
    if (!this.timeLists.length) {
      return;
    }
    this.timeLists.reduce(listReducer, []).map((state2) => dir === Direction2.Right ? state2.next : state2.prev).map((list2) => list2 && list2.focus());
  }
  handleChange(value2) {
    this.value = value2;
    this.valueChange.emit(cloneDate(value2));
  }
  hasActiveButton() {
    if (!this.accept) {
      return false;
    }
    return [this.accept, this.cancel, this.now].reduce((isActive2, el) => isActive2 || this.dom.isActive(el), false);
  }
  hasSteps() {
    const keys = Object.keys(this.steps);
    return keys.length !== keys.reduce((acc, k) => acc + this.steps[k], 0);
  }
  intlChange() {
    this.dateFormatParts = this.intl.splitDateFormat(this.format);
    this.mergeValue = valueMerger(generateGetters(this.dateFormatParts));
    this.cdr.markForCheck();
  }
  bindEvents() {
    if (this.element) {
      this.zone.runOutsideAngular(() => {
        this.domEvents.push(this.renderer.listen(this.element.nativeElement, "keydown", this.handleKeydown.bind(this)));
      });
    }
  }
  handleKeydown(args) {
    const {
      altKey
    } = args;
    const code = normalizeKeys(args);
    const arrowKeyPressed = [Keys.ArrowLeft, Keys.ArrowRight].indexOf(code) !== -1;
    if (isPresent4(this.pickerService) && arrowKeyPressed && altKey) {
      return;
    }
    if (code === Keys.Enter && !this.hasActiveButton()) {
      this.handleAccept();
    } else if (code === Keys.ArrowLeft || code === Keys.ArrowRight) {
      this.focusList(code === Keys.ArrowLeft ? Direction2.Left : Direction2.Right);
    }
  }
  emitBlur(args) {
    if (this.pickerService) {
      this.pickerService.onBlur.emit(args);
    }
  }
  emitFocus(args) {
    if (this.pickerService) {
      this.pickerService.onFocus.emit(args);
    }
  }
  listIndex(partIndex) {
    let listIdx = 0;
    let partIdx = 0;
    while (partIdx < partIndex) {
      if (this.dateFormatParts[partIdx].type !== "literal") {
        listIdx++;
      }
      partIdx++;
    }
    return listIdx;
  }
  static ɵfac = function TimeSelectorComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TimeSelectorComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(TimePickerDOMService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(PickerService, 8));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TimeSelectorComponent,
    selectors: [["kendo-timeselector"]],
    viewQuery: function TimeSelectorComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c22, 5)(_c23, 5)(_c24, 5)(TimeListComponent, 5)(_c25, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.accept = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.cancel = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.now = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.timeLists = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.timeListWrappers = _t);
      }
    },
    hostVars: 2,
    hostBindings: function TimeSelectorComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-disabled", ctx.disabledClass);
      }
    },
    inputs: {
      format: "format",
      min: "min",
      max: "max",
      cancelButton: "cancelButton",
      setButton: "setButton",
      nowButton: "nowButton",
      disabled: "disabled",
      isAdaptiveEnabled: "isAdaptiveEnabled",
      isDateTimePicker: "isDateTimePicker",
      steps: "steps",
      value: "value"
    },
    outputs: {
      valueChange: "valueChange",
      valueReject: "valueReject",
      tabOutLastPart: "tabOutLastPart",
      tabOutFirstPart: "tabOutFirstPart",
      tabOutNow: "tabOutNow"
    },
    exportAs: ["kendo-timeselector"],
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.timeselector"
    }]), ɵɵNgOnChangesFeature],
    decls: 10,
    vars: 3,
    consts: () => {
      let i18n_18;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_18 = goog.getMsg("Set");
        i18n_18 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_18;
      } else {
        i18n_18 = $localize`:kendo.timeselector.accept|The Accept button text in the timeselector component:Set`;
      }
      let i18n_19;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_19 = goog.getMsg("Set time");
        i18n_19 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_19;
      } else {
        i18n_19 = $localize`:kendo.timeselector.acceptLabel|The label for the Accept button in the timeselector component:Set time`;
      }
      let i18n_20;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_20 = goog.getMsg("Cancel");
        i18n_20 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_20;
      } else {
        i18n_20 = $localize`:kendo.timeselector.cancel|The Cancel button text in the timeselector component:Cancel`;
      }
      let i18n_21;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_21 = goog.getMsg("Cancel changes");
        i18n_21 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_21;
      } else {
        i18n_21 = $localize`:kendo.timeselector.cancelLabel|The label for the Cancel button in the timeselector component:Cancel changes`;
      }
      let i18n_22;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_22 = goog.getMsg("Now");
        i18n_22 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_22;
      } else {
        i18n_22 = $localize`:kendo.timeselector.now|The Now button text in the timeselector component:Now`;
      }
      let i18n_23;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_23 = goog.getMsg("Select now");
        i18n_23 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_23;
      } else {
        i18n_23 = $localize`:kendo.timeselector.nowLabel|The label for the Now button in the timeselector component:Select now`;
      }
      return [["now", ""], ["listWrapper", ""], ["accept", ""], ["cancel", ""], ["kendoTimeSelectorLocalizedMessages", "", "accept", i18n_18, "acceptLabel", i18n_19, "cancel", i18n_20, "cancelLabel", i18n_21, "now", i18n_22, "nowLabel", i18n_23], [1, "k-time-header"], [1, "k-title", "k-timeselector-title"], ["type", "button", 1, "k-button", "k-button-md", "k-rounded-md", "k-button-flat", "k-button-flat-primary", "k-time-now", 3, "kendoEventsOutsideAngular", "scope", "disabled"], [1, "k-time-list-container"], [1, "k-time-highlight"], [1, "k-time-footer", "k-actions", "k-actions-stretched", "k-actions-horizontal"], ["role", "presentation", "tabindex", "-1", 1, "k-time-list-wrapper"], [1, "k-time-separator"], [3, "valueChange", "tabOutLastPart", "tabOutFirstPart", "isLast", "isFirst", "min", "max", "part", "step", "disabled", "value", "kendoEventsOutsideAngular", "scope"], ["type", "button", 1, "k-button", "k-time-accept", "k-button-md", "k-rounded-md", "k-button-solid", "k-button-solid-primary", 3, "kendoEventsOutsideAngular", "scope", "disabled"], ["type", "button", 1, "k-button", "k-time-cancel", "k-button-md", "k-rounded-md", "k-button-solid", "k-button-solid-base", 3, "kendoEventsOutsideAngular", "scope", "disabled"]];
    },
    template: function TimeSelectorComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainer(0, 4);
        ɵɵelementStart(1, "div", 5)(2, "span", 6);
        ɵɵtext(3);
        ɵɵelementEnd();
        ɵɵconditionalCreate(4, TimeSelectorComponent_Conditional_4_Template, 3, 11, "button", 7);
        ɵɵelementEnd();
        ɵɵelementStart(5, "div", 8);
        ɵɵelement(6, "span", 9);
        ɵɵrepeaterCreate(7, TimeSelectorComponent_For_8_Template, 2, 2, null, null, ɵɵrepeaterTrackByIndex);
        ɵɵelementEnd();
        ɵɵconditionalCreate(9, TimeSelectorComponent_Conditional_9_Template, 3, 2, "div", 10);
      }
      if (rf & 2) {
        ɵɵadvance(3);
        ɵɵtextInterpolate1(" ", ctx.intl.formatDate(ctx.current, ctx.format), " ");
        ɵɵadvance();
        ɵɵconditional(ctx.showNowButton ? 4 : -1);
        ɵɵadvance(3);
        ɵɵrepeater(ctx.dateFormatParts);
        ɵɵadvance(2);
        ɵɵconditional(ctx.setButton || ctx.cancelButton ? 9 : -1);
      }
    },
    dependencies: [TimeSelectorLocalizedMessagesDirective, EventsOutsideAngularDirective, TimeListComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimeSelectorComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      exportAs: "kendo-timeselector",
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.timeselector"
      }],
      selector: "kendo-timeselector",
      template: `
        <ng-container kendoTimeSelectorLocalizedMessages
          i18n-accept="kendo.timeselector.accept|The Accept button text in the timeselector component"
          accept="Set"

          i18n-acceptLabel="kendo.timeselector.acceptLabel|The label for the Accept button in the timeselector component"
          acceptLabel="Set time"

          i18n-cancel="kendo.timeselector.cancel|The Cancel button text in the timeselector component"
          cancel="Cancel"

          i18n-cancelLabel="kendo.timeselector.cancelLabel|The label for the Cancel button in the timeselector component"
          cancelLabel="Cancel changes"

          i18n-now="kendo.timeselector.now|The Now button text in the timeselector component"
          now="Now"

          i18n-nowLabel="kendo.timeselector.nowLabel|The label for the Now button in the timeselector component"
          nowLabel="Select now"
          >
        </ng-container>
        <div class="k-time-header">
          <span class="k-title k-timeselector-title">
            {{ intl.formatDate(current, format) }}
          </span>
          @if (showNowButton) {
            <button
              #now
              type="button"
              class="k-button k-button-md k-rounded-md k-button-flat k-button-flat-primary k-time-now"
              [attr.title]="localization.get('nowLabel')"
              [attr.aria-label]="localization.get('nowLabel')"
                [kendoEventsOutsideAngular]="{
                    click: handleNow,
                    focus: handleFocus,
                    blur: handleBlur,
                    keydown: handleTabOut
                }"
              [scope]="this"
              [disabled]="disabled"
            >{{localization.get('now')}}</button>
          }
        </div>
        <div class="k-time-list-container">
          <span class="k-time-highlight"></span>
          @for (part of dateFormatParts; track $index; let idx = $index) {
            @if (part.type !== 'literal') {
              <div
                #listWrapper
                class="k-time-list-wrapper"
                role="presentation" tabindex="-1"
                >
                <span class="k-title k-timeselector-title">{{intl.dateFieldName(part)}}</span>
                <kendo-timelist
                  [isLast]="idx === dateFormatParts.length - 1"
                  [isFirst]="idx === 0"
                  [min]="min"
                  [max]="max"
                  [part]="part"
                  [step]="partStep(part)"
                  [disabled]="disabled"
                  [(value)]="current"
                  (tabOutLastPart)="tabOutLastPart.emit()"
                  (tabOutFirstPart)="tabOutFirstPart.emit()"
                        [kendoEventsOutsideAngular]="{
                            focus: handleListFocus,
                            blur: handleBlur
                        }"
                  [scope]="this"
                  [attr.data-timelist-index]="idx"
                ></kendo-timelist>
              </div>
            }
            @if (part.type === 'literal') {
              <div class="k-time-separator">
                {{part.pattern}}
              </div>
            }
          }
        </div>
        @if (setButton || cancelButton) {
          <div class="k-time-footer k-actions k-actions-stretched k-actions-horizontal">
            @if (setButton) {
              <button
                #accept
                type="button"
                class="k-button k-time-accept k-button-md k-rounded-md k-button-solid k-button-solid-primary"
                [attr.title]="localization.get('acceptLabel')"
                [attr.aria-label]="localization.get('acceptLabel')"
                [kendoEventsOutsideAngular]="{
                    click: handleAccept,
                    focus: handleFocus,
                    blur: handleBlur,
                    keydown: handleTabOut
                }"
                [scope]="this"
                [disabled]="disabled"
              >{{localization.get('accept')}}</button>
            }
            @if (cancelButton) {
              <button
                #cancel
                class="k-button k-time-cancel k-button-md k-rounded-md k-button-solid k-button-solid-base"
                type="button"
                [attr.title]="localization.get('cancelLabel')"
                [attr.aria-label]="localization.get('cancelLabel')"
                [kendoEventsOutsideAngular]="{
                    click: handleReject,
                    focus: handleFocus,
                    blur: handleBlur,
                    keydown: handleTabOut
                }"
                [scope]="this"
                [disabled]="disabled"
              >{{localization.get('cancel')}}</button>
            }
          </div>
        }
        `,
      standalone: true,
      imports: [TimeSelectorLocalizedMessagesDirective, EventsOutsideAngularDirective, TimeListComponent]
    }]
  }], () => [{
    type: LocalizationService
  }, {
    type: ChangeDetectorRef
  }, {
    type: ElementRef
  }, {
    type: IntlService
  }, {
    type: TimePickerDOMService
  }, {
    type: NgZone
  }, {
    type: Renderer2
  }, {
    type: PickerService,
    decorators: [{
      type: Optional
    }]
  }], {
    accept: [{
      type: ViewChild,
      args: ["accept", {
        static: false
      }]
    }],
    cancel: [{
      type: ViewChild,
      args: ["cancel", {
        static: false
      }]
    }],
    now: [{
      type: ViewChild,
      args: ["now", {
        static: false
      }]
    }],
    timeLists: [{
      type: ViewChildren,
      args: [TimeListComponent]
    }],
    timeListWrappers: [{
      type: ViewChildren,
      args: ["listWrapper"]
    }],
    disabledClass: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    format: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    cancelButton: [{
      type: Input
    }],
    setButton: [{
      type: Input
    }],
    nowButton: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    isAdaptiveEnabled: [{
      type: Input
    }],
    isDateTimePicker: [{
      type: Input
    }],
    steps: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    valueReject: [{
      type: Output
    }],
    tabOutLastPart: [{
      type: Output
    }],
    tabOutFirstPart: [{
      type: Output
    }],
    tabOutNow: [{
      type: Output
    }]
  });
})();
var timeRangeValidator = (min, max) => {
  return (control) => {
    if (!min || !max || !control.value) {
      return null;
    }
    const err = {
      timeRangeError: {
        maxValue: max,
        minValue: min,
        value: control.value
      }
    };
    return isInTimeRange(control.value, min, max) ? null : err;
  };
};
var TimeSelectorCustomMessagesComponent = class _TimeSelectorCustomMessagesComponent extends TimePickerMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function TimeSelectorCustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TimeSelectorCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TimeSelectorCustomMessagesComponent,
    selectors: [["kendo-timeselector-messages"]],
    features: [ɵɵProvidersFeature([{
      provide: TimePickerMessages,
      useExisting: forwardRef(() => _TimeSelectorCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function TimeSelectorCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimeSelectorCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: TimePickerMessages,
        useExisting: forwardRef(() => TimeSelectorCustomMessagesComponent)
      }],
      selector: "kendo-timeselector-messages",
      template: ``,
      standalone: true
    }]
  }], () => [{
    type: LocalizationService
  }], null);
})();
var TimePickerLocalizedMessagesDirective = class _TimePickerLocalizedMessagesDirective extends TimePickerMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function TimePickerLocalizedMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TimePickerLocalizedMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _TimePickerLocalizedMessagesDirective,
    selectors: [["", "kendoTimePickerLocalizedMessages", ""]],
    features: [ɵɵProvidersFeature([{
      provide: TimePickerMessages,
      useExisting: forwardRef(() => _TimePickerLocalizedMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimePickerLocalizedMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: TimePickerMessages,
        useExisting: forwardRef(() => TimePickerLocalizedMessagesDirective)
      }],
      selector: "[kendoTimePickerLocalizedMessages]",
      standalone: true
    }]
  }], () => [{
    type: LocalizationService
  }], null);
})();
var VALUE_DOC_LINK$1 = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/timepicker/#toc-integration-with-json";
var INTL_DATE_FORMAT = "https://github.com/telerik/kendo-intl/blob/master/docs/date-formatting/index.md";
var formatRegExp2 = new RegExp(`${TIME_PART.hour}|${TIME_PART.minute}|${TIME_PART.second}|${TIME_PART.millisecond}|${TIME_PART.dayperiod}|literal`);
var ACCEPT_BUTTON_SELECTOR$1 = ".k-button.k-time-accept";
var CANCEL_BUTTON_SELECTOR = ".k-button.k-time-cancel";
var TimePickerComponent = class _TimePickerComponent extends MultiTabStop {
  bus;
  zone;
  localization;
  cdr;
  popupService;
  wrapper;
  renderer;
  injector;
  pickerService;
  intl;
  adaptiveService;
  /**
   * @hidden
   */
  clockIcon = clockIcon;
  container;
  popupTemplate;
  toggleButton;
  actionSheet;
  /**
   * @hidden
   */
  focusableId;
  /**
   * Determines whether the TimePicker is disabled
   * ([see example]({% slug disabled_timepicker %})).
   * To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_timepicker#toc-managing-the-timepicker-disabled-state-in-reactive-forms).
   *
   * @default false
   */
  disabled = false;
  /**
   * Determines the read-only state of the TimePicker
   * ([see example]({% slug readonly_timepicker %}#toc-read-only-timepicker)).
   *
   * @default false
   */
  readonly = false;
  /**
   * Sets the read-only state of the TimePicker input field
   * ([see example]({% slug readonly_timepicker %}#toc-read-only-input)).
   *
   * If you set the [`readonly`]({% slug api_dateinputs_timepickercomponent %}#toc-readonly) property value to `true`,
   * the input will be rendered in a read-only state regardless of the `readOnlyInput` value.
   * @default false
   */
  readOnlyInput = false;
  /**
   * If set to `true`, renders a clear button after the input text or TimePicker value has been changed.
   * Clicking this button resets the value of the component to `null` and triggers the `valueChange` event.
   * @default false
   */
  clearButton = false;
  /**
   * Specifies the time format that is used to display the input value
   * ([see example]({% slug formats_timepicker %})).
   * @default 't'
   */
  format = "t";
  /**
   * Defines the descriptions of the format sections in the input field.
   * For more information, refer to the article on
   * [placeholders]({% slug placeholders_timepicker %}).
   */
  formatPlaceholder;
  /**
   * Specifies the hint the TimePicker displays when its value is `null`.
   * For more information, refer to the article on
   * [placeholders]({% slug placeholders_timepicker %}).
   * @default null
   */
  placeholder;
  /**
   * Specifies the smallest valid time value
   * ([see example]({% slug timeranges_timepicker %})).
   * @default `00:00:00`
   */
  set min(min) {
    this._min = cloneDate(min || MIN_TIME);
  }
  get min() {
    return this._min;
  }
  /**
   * Specifies the biggest valid time value
   * ([see example]({% slug timeranges_timepicker %})).
   * @default `23:59:59`
   */
  set max(max) {
    this._max = cloneDate(max || MAX_TIME);
  }
  get max() {
    return this._max;
  }
  /**
   * Determines whether the built-in validation for incomplete dates is to be enforced when a form is being validated.
   *
   * @default false
   */
  incompleteDateValidation = false;
  /**
   * Determines whether to automatically move to the next segment after the user completes the current one.
   *
   * @default true
   */
  autoSwitchParts = true;
  /**
   * A string array representing custom keys, which will move the focus to the next date format segment.
   */
  autoSwitchKeys = [];
  /**
   * Indicates whether the mouse scroll can be used to increase/decrease the time segments values.
   *
   * @default true
   */
  enableMouseWheel = true;
  /**
   * Determines if the users should see a blinking caret inside the Date Input when possible.
   *
   * @default false
   */
  allowCaretMode = false;
  /**
   * Determines whether to display the **Cancel** button in the popup.
   *
   * @default true
   */
  cancelButton = true;
  /**
   * Determines whether to display the **Now** button in the popup.
   *
   * If the current time is out of range or the incremental step is greater than `1`, the **Now** button will be hidden.
   *
   * @default true
   */
  nowButton = true;
  /**
   * Configures the incremental steps of the TimePicker.
   * For more information, refer to the article on
   * [incremental steps]({% slug incrementalsteps_timepicker %}).
   *
   * If the incremental step is greater than `1`, the **Now** button will be hidden.
   */
  set steps(steps) {
    this._steps = steps || {};
  }
  get steps() {
    return this._steps;
  }
  /**
   * Configures the popup of the TimePicker.
   *
   * The available options are animate which controls the popup animation and by default, the open and close animations are enabled.
   * The `appendTo` option controls the popup container and by default, the popup will be appended to the root component.
   * The `popupClass` option specifies a list of CSS classes that are used to style the popup.
   */
  set popupSettings(settings) {
    this._popupSettings = Object.assign({}, {
      animate: true
    }, settings);
  }
  get popupSettings() {
    return this._popupSettings;
  }
  /**
   * Sets the tabindex of the TimePicker component.
   * @default 0
   */
  tabindex = 0;
  /**
   * @hidden
   */
  set tabIndex(tabIndex) {
    this.tabindex = tabIndex;
  }
  get tabIndex() {
    return this.tabindex;
  }
  /**
   * Sets the title of the input element of the TimePicker and the title text rendered
   * in the header of the popup(action sheet). Applicable only when [`AdaptiveMode` is set to `auto`](slug:api_dateinputs_adaptivemode).
   */
  adaptiveTitle = "";
  /**
   * Sets the subtitle text rendered in the header of the popup(action sheet).
   * Applicable only when [`AdaptiveMode` is set to `auto`](slug:api_dateinputs_adaptivemode).
   * By default, subtitle is not rendered.
   */
  adaptiveSubtitle;
  /**
   * Determines whether the built-in min or max validators are enforced when a form is being validated.
   *
   * @default true
   */
  rangeValidation = true;
  /**
   * Determines whether the TimePicker is in adaptive mode.
   * @default 'none'
   */
  adaptiveMode = "none";
  /**
   * Determines whether the TimePicker is in adaptive mode.
   *
   * The `value` has to be a valid [JavaScript `Date`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date) instance or `null`.
   */
  set value(value2) {
    this.verifyValue(value2);
    this._value = cloneDate(value2);
  }
  get value() {
    return this._value;
  }
  /**
   * Sets the size of the component.
   * @default 'medium'
   */
  set size(size) {
    this.renderer.removeClass(this.wrapper.nativeElement, getSizeClass("input", this.size));
    this.renderer.removeClass(this.toggleButton.nativeElement, getSizeClass("button", this.size));
    const newSize = size ? size : DEFAULT_SIZE;
    if (newSize !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getSizeClass("input", newSize));
      this.renderer.addClass(this.toggleButton.nativeElement, getSizeClass("button", newSize));
    }
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * Sets the rounded styling of the component.
   * @default 'medium'
   *
   */
  set rounded(rounded) {
    this.renderer.removeClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
    const newRounded = rounded ? rounded : DEFAULT_ROUNDED;
    if (newRounded !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(newRounded));
    }
    this._rounded = newRounded;
  }
  get rounded() {
    return this._rounded;
  }
  /**
   * Sets the fillMode of the component.
   * @default 'solid'
   */
  set fillMode(fillMode) {
    this.renderer.removeClass(this.wrapper.nativeElement, getFillModeClass("input", this.fillMode));
    this.renderer.removeClass(this.toggleButton.nativeElement, getFillModeClass("button", this.fillMode));
    this.renderer.removeClass(this.toggleButton.nativeElement, `k-button-${this.fillMode}-base`);
    const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE;
    if (newFillMode !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass("input", newFillMode));
      this.renderer.addClass(this.toggleButton.nativeElement, getFillModeClass("button", newFillMode));
      this.renderer.addClass(this.toggleButton.nativeElement, `k-button-${newFillMode}-base`);
    }
    this._fillMode = newFillMode;
  }
  get fillMode() {
    return this._fillMode;
  }
  /**
   * Sets the HTML attributes of the inner focusable input element. Attributes which are essential for certain component functionalities cannot be changed.
   */
  inputAttributes;
  /**
   * Fires each time the user selects a new value
   * ([see example](slug:events_timepicker)).
   */
  valueChange = new EventEmitter();
  /**
   * Fires each time the user focuses the input element
   * ([see example](slug:events_timepicker)).
   */
  onFocus = new EventEmitter();
  /**
   * Fires each time the input element gets blurred
   * ([see example](slug:events_timepicker)).
   */
  onBlur = new EventEmitter();
  /**
   * Fires each time the popup is about to open
   * ([see example](slug:events_timepicker)).
   * This event is preventable. If you cancel the event, the popup will remain closed.
   */
  open = new EventEmitter();
  /**
   * Fires each time the popup is about to close
   * ([see example](slug:events_timepicker)).
   * This event is preventable. If you cancel the event, the popup will remain open.
   */
  close = new EventEmitter();
  /**
   * @hidden
   */
  escape = new EventEmitter();
  /**
   * @hidden
   */
  wrapperClasses = true;
  /**
   * @hidden
   */
  get disabledClass() {
    return this.disabled;
  }
  get popupUID() {
    return `k-timepicker-popup-${this.bus.calendarId}-`;
  }
  popupRef;
  /**
   * @hidden
   */
  checkIcon = checkIcon;
  get isActive() {
    return this._active;
  }
  set isActive(value2) {
    this._active = value2;
    if (!this.wrapper) {
      return;
    }
    const element = this.wrapper.nativeElement;
    if (value2) {
      this.renderer.addClass(element, "k-focus");
    } else {
      this.renderer.removeClass(element, "k-focus");
    }
  }
  get show() {
    return this._show;
  }
  set show(show) {
    if (show && (this.disabled || this.readonly)) {
      return;
    }
    const skipZone = !show && (!this._show || !hasObservers(this.close) && !hasObservers(this.open));
    if (!skipZone) {
      this.zone.run(() => {
        const event = new PreventableEvent2();
        if (!this._show && show) {
          this.open.emit(event);
        } else if (this._show && !show) {
          this.close.emit(event);
        }
        if (event.isDefaultPrevented()) {
          return;
        }
        this.toggleTimeSelector(show);
      });
    } else {
      this.toggleTimeSelector(show);
    }
  }
  get dateInput() {
    return this.pickerService.input;
  }
  get timeSelector() {
    return this.pickerService.timeSelector;
  }
  /**
   * @hidden
   */
  get isControlRequired() {
    return isControlRequired(this.control);
  }
  /**
   * @hidden
   */
  windowSize;
  get adaptiveAcceptButton() {
    return this.actionSheet.element.nativeElement.querySelector(ACCEPT_BUTTON_SELECTOR$1);
  }
  get adaptiveCancelButton() {
    return this.actionSheet.element.nativeElement.querySelector(CANCEL_BUTTON_SELECTOR);
  }
  get inputElement() {
    return this.wrapper.nativeElement.querySelector("input");
  }
  onControlChange = noop$2;
  onControlTouched = noop$2;
  onValidatorChange = noop$2;
  resolvedPromise = Promise.resolve(null);
  timeRangeValidateFn = noop$2;
  incompleteValidator = noop$2;
  _min = cloneDate(MIN_TIME);
  _max = cloneDate(MAX_TIME);
  _popupSettings = {
    animate: true
  };
  _show = false;
  _steps = {};
  _value = null;
  _active = false;
  localizationChangeSubscription;
  pickerSubscriptions;
  windowBlurSubscription;
  control;
  domEvents = [];
  _size = DEFAULT_SIZE;
  _rounded = DEFAULT_ROUNDED;
  _fillMode = DEFAULT_FILL_MODE;
  constructor(bus, zone, localization, cdr, popupService, wrapper, renderer, injector, pickerService, intl, adaptiveService) {
    super();
    this.bus = bus;
    this.zone = zone;
    this.localization = localization;
    this.cdr = cdr;
    this.popupService = popupService;
    this.wrapper = wrapper;
    this.renderer = renderer;
    this.injector = injector;
    this.pickerService = pickerService;
    this.intl = intl;
    this.adaptiveService = adaptiveService;
    N(packageMetadata);
    this.pickerSubscriptions = this.pickerService.onFocus.subscribe(this.handleFocus.bind(this));
    this.pickerSubscriptions.add(this.pickerService.onBlur.subscribe(this.handleBlur.bind(this)));
    this.pickerSubscriptions.add(this.pickerService.dateCompletenessChange.subscribe(this.handleDateCompletenessChange.bind(this)));
  }
  /**
   * @hidden
   * Used by the TextBoxContainer to determine if the component is empty
   */
  isEmpty() {
    return !this.value && this.dateInput.isEmpty();
  }
  /**
   * @hidden
   */
  ngOnInit() {
    this.localizationChangeSubscription = this.localization.changes.subscribe(() => this.cdr.markForCheck());
    this.control = this.injector.get(NgControl, null);
    if (this.wrapper) {
      this.renderer.removeAttribute(this.wrapper.nativeElement, "tabindex");
      this.zone.runOutsideAngular(() => {
        this.bindEvents();
      });
    }
    this.focusableId = this.dateInput?.focusableId;
  }
  /**
   * @hidden
   */
  ngAfterViewInit() {
    this.setComponentClasses();
    this.windowSize = this.adaptiveService.size;
  }
  /**
   * @hidden
   */
  ngOnChanges(changes) {
    if (changes.min || changes.max || changes.rangeValidation || changes.incompleteDateValidation) {
      this.timeRangeValidateFn = this.rangeValidation ? timeRangeValidator(this.min, this.max) : noop$2;
      this.incompleteValidator = this.incompleteDateValidation ? incompleteDateValidator() : noop$2;
      this.onValidatorChange();
    }
    if (changes.format) {
      this.verifyFormat();
    }
    if (!this.focusableId || changes.focusableId) {
      this.focusableId = this.dateInput?.focusableId;
    }
  }
  /**
   * @hidden
   */
  ngOnDestroy() {
    this.isActive = false;
    this.show = false;
    if (this.localizationChangeSubscription) {
      this.localizationChangeSubscription.unsubscribe();
    }
    if (this.windowBlurSubscription) {
      this.windowBlurSubscription.unsubscribe();
    }
    this.domEvents.forEach((unbindCallback) => unbindCallback());
    this.pickerSubscriptions.unsubscribe();
  }
  /**
   * @hidden
   */
  handleKeydown(event) {
    const {
      altKey
    } = event;
    const code = normalizeKeys(event);
    if (code === Keys.Escape) {
      this.focusInput();
      this.show = false;
      hasObservers(this.escape) && this.escape.emit();
      this.cdr.detectChanges();
      return;
    }
    if (altKey) {
      if (code === Keys.ArrowUp) {
        event.preventDefault();
        this.focusInput();
        this.show = false;
        this.cdr.detectChanges();
      }
      if (code === Keys.ArrowDown && !this.show) {
        event.preventDefault();
        this.show = true;
      }
    }
  }
  /**
   * @hidden
   */
  writeValue(value2) {
    this.verifyValue(value2);
    this.value = cloneDate(value2);
    this.cdr.markForCheck();
    if (!value2 && this.dateInput) {
      this.dateInput.placeholder = this.placeholder;
      this.dateInput.writeValue(value2);
    }
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.onControlChange = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.onControlTouched = fn;
  }
  /**
   * @hidden
   */
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  validate(control) {
    return this.timeRangeValidateFn(control) || this.incompleteValidator(control, this.dateInput && this.dateInput.isDateIncomplete);
  }
  /**
   * @hidden
   */
  registerOnValidatorChange(fn) {
    this.onValidatorChange = fn;
  }
  /**
   * Focuses the TimePicker component.
   *
   */
  focus() {
    this.dateInput.focus();
  }
  /**
   * Blurs the TimePicker component.
   *
   */
  blur() {
    (this.timeSelector || this.dateInput)["blur"]();
  }
  /**
   * Toggles the visibility of the popup or ActionSheet.
   * If you use the `toggle` method to show or hide the popup or ActionSheet, the `open` and `close` events do not fire.
   *
   * @param {boolean} show The state of the popup.
   */
  toggle(show) {
    if (this.disabled || this.readonly) {
      return;
    }
    this.resolvedPromise.then(() => {
      this.toggleTimeSelector(show === void 0 ? !this.show : show);
    });
  }
  /**
   * Returns whether the component is currently open.
   * That is when the popup or ActionSheet is open.
   */
  get isOpen() {
    return this.show;
  }
  /**
   * @hidden
   */
  get appendTo() {
    const {
      appendTo
    } = this.popupSettings;
    if (!appendTo || appendTo === "root") {
      return void 0;
    }
    return appendTo === "component" ? this.container : appendTo;
  }
  /**
   * @hidden
   */
  handleChange(value2) {
    if (isEqual(this.value, value2)) {
      if (this.show) {
        this.focusInput();
        this.show = false;
      }
      if (this.incompleteDateValidation) {
        this.onControlChange(cloneDate(value2));
      }
      return;
    }
    this.value = cloneDate(value2);
    this.zone.run(() => {
      if (this.show) {
        this.focusInput();
        this.show = false;
      }
      this.dateInput.showClearButton = true;
      this.onControlChange(cloneDate(value2));
      this.valueChange.emit(cloneDate(value2));
    });
  }
  /**
   * @hidden
   */
  handleActionSheetAccept() {
    this.timeSelector.handleAccept();
  }
  /**
   * @hidden
   */
  handleActionSheetCollapse() {
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  handleReject() {
    this.focusInput();
    this.show = false;
  }
  /**
   * @hidden
   */
  handleInputChange(value2) {
    const val = this.dateInput.formatSections["date"] ? value2 : this.mergeTime(value2);
    this.handleChange(val);
  }
  /**
   * @hidden
   */
  handleDateInputClick() {
    this.windowSize = this.adaptiveService.size;
    if (this.isAdaptive) {
      this.show = true;
    } else if (this.isOpen) {
      this.show = false;
    }
  }
  /**
   * @hidden
   */
  onTabOutNow() {
    if (!this.timeSelector.showNowButton) {
      this.cancelButton ? this.timeSelector.cancel.nativeElement.focus() : this.timeSelector.accept.nativeElement.focus();
    }
  }
  /**
   * @hidden
   */
  handleMousedown(args) {
    args.preventDefault();
  }
  /**
   * @hidden
   */
  handleIconClick(event) {
    if (this.disabled || this.readonly) {
      return;
    }
    event.preventDefault();
    this.focusInput();
    this.handleFocus();
    this.show = !this.show;
    this.cdr.detectChanges();
  }
  /**
   * @hidden
   */
  get popupClasses() {
    const popupClasses = ["k-timepicker-popup"];
    if (!this.popupSettings.popupClass) {
      return popupClasses;
    }
    const customClasses = parseCSSClassNames(this.popupSettings.popupClass);
    if (customClasses?.length) {
      popupClasses.push(...customClasses);
    }
    return popupClasses;
  }
  /**
   * @hidden
   */
  get isAdaptiveModeEnabled() {
    return this.adaptiveMode === "auto";
  }
  /**
   * @hidden
   */
  get isAdaptive() {
    return this.isAdaptiveModeEnabled && this.windowSize !== "large";
  }
  /**
   * @hidden
   */
  normalizeTime(date) {
    return setTime(MIDNIGHT_DATE, date);
  }
  /**
   * @hidden
   */
  mergeTime(value2) {
    return this.value && value2 ? setTime(this.value, value2) : value2;
  }
  /**
   * @hidden
   */
  onResize() {
    const currentWindowSize = this.adaptiveService.size;
    if (!this.isOpen || this.windowSize === currentWindowSize) {
      return;
    }
    if (this.actionSheet.expanded) {
      this.toggleActionSheet(false);
    } else {
      this.togglePopup(false);
    }
    this.windowSize = currentWindowSize;
  }
  /**
   * @hidden
   */
  onTabOutLastPart() {
    this.renderer.removeClass(this.timeSelector.timeListWrappers.last.nativeElement, "k-focus");
    if (this.isAdaptive) {
      this.cancelButton ? this.adaptiveCancelButton.focus() : this.adaptiveAcceptButton.focus();
    } else {
      this.timeSelector.accept.nativeElement.focus();
    }
  }
  /**
   * @hidden
   */
  onTabOutFirstPart() {
    this.renderer.removeClass(this.timeSelector.timeListWrappers.first.nativeElement, "k-focus");
    if (this.timeSelector.showNowButton) {
      this.timeSelector.now.nativeElement.focus();
    } else {
      this.cancelButton ? this.timeSelector.cancel.nativeElement.focus() : this.timeSelector.accept.nativeElement.focus();
    }
  }
  toggleTimeSelector(show) {
    const previousWindowSize = this.windowSize;
    this.windowSize = this.adaptiveService.size;
    if (previousWindowSize !== this.windowSize && !show) {
      if (previousWindowSize !== "large") {
        this.toggleActionSheet(show);
      } else {
        this.togglePopup(show);
      }
    } else {
      if (this.isAdaptive) {
        this.toggleActionSheet(show);
      } else {
        this.togglePopup(show);
      }
    }
    this.toggleFocus();
  }
  toggleActionSheet(show) {
    if (show === this._show) {
      return;
    }
    if (show && !this.isOpen) {
      this.actionSheet.toggle();
      this.renderer.setAttribute(this.actionSheet.element.nativeElement, "id", this.popupUID);
      this.renderer.setAttribute(this.dateInput?.inputElement, attributeNames.ariaControls, this.popupUID);
    } else if (!show && this.isOpen) {
      this.renderer.setStyle(this.timeSelector.element.nativeElement, "pointer-events", "none");
      if (this.dateInput) {
        this.renderer.removeAttribute(this.dateInput.inputElement, attributeNames.ariaControls);
      }
      this.actionSheet.toggle();
      this.dateInput.focus();
    }
    this._show = show;
  }
  togglePopup(show) {
    if (show === this.isOpen) {
      return;
    }
    this._show = show;
    this.cdr.markForCheck();
    if (show) {
      const direction = this.localization.rtl ? "right" : "left";
      const appendToComponent = typeof this.popupSettings.appendTo === "string" && this.popupSettings.appendTo === "component";
      this.popupRef = this.popupService.open({
        anchor: this.wrapper,
        anchorAlign: {
          vertical: "bottom",
          horizontal: direction
        },
        animate: this.popupSettings.animate,
        appendTo: this.appendTo,
        content: this.popupTemplate,
        popupAlign: {
          vertical: "top",
          horizontal: direction
        },
        popupClass: this.popupClasses,
        positionMode: appendToComponent ? "fixed" : "absolute"
      });
      this.popupRef.popupElement.setAttribute("id", this.popupUID);
      this.renderer.setAttribute(this.dateInput?.inputElement, attributeNames.ariaControls, this.popupUID);
      this.popupRef.popupAnchorViewportLeave.subscribe(() => this.show = false);
    } else {
      this.popupRef.close();
      this.popupRef = null;
      if (this.dateInput) {
        this.renderer.removeAttribute(this.dateInput?.inputElement, attributeNames.ariaControls);
      }
    }
  }
  focusInput() {
    if (touchEnabled) {
      return;
    }
    this.dateInput.focus();
  }
  toggleFocus() {
    if (!this.isActive) {
      return;
    }
    if (this.show) {
      if (!this.timeSelector) {
        this.cdr.detectChanges();
      }
      if (this.isActive) {
        this.timeSelector.focus();
      }
    } else if (!touchEnabled) {
      this.dateInput.focus();
    } else if (!this.dateInput.isActive) {
      this.handleBlur();
    }
  }
  verifyValue(value2) {
    if (!isDevMode()) {
      return;
    }
    if (value2 && !(value2 instanceof Date)) {
      throw new Error(`The 'value' should be a valid JavaScript Date instance or null. Check ${VALUE_DOC_LINK$1} for possible resolution.`);
    }
  }
  verifyFormat() {
    if (!isDevMode()) {
      return;
    }
    const formatContainsDateParts = this.intl.splitDateFormat(this.format).some((part) => !formatRegExp2.test(part.type));
    if (formatContainsDateParts) {
      throw new Error(`Provided format is not supported. Supported specifiers are T|t|H|h|m|s|S|a. See ${INTL_DATE_FORMAT}`);
    }
  }
  bindEvents() {
    const element = this.wrapper.nativeElement;
    this.domEvents.push(this.renderer.listen(element, "keydown", this.handleKeydown.bind(this)));
    if (isWindowAvailable()) {
      this.windowBlurSubscription = fromEvent(window, "blur").subscribe(this.handleWindowBlur.bind(this));
    }
  }
  handleWindowBlur() {
    if (!this.isOpen || this.actionSheet.expanded) {
      return;
    }
    this.show = false;
  }
  handleFocus() {
    if (this.isActive) {
      return;
    }
    this.isActive = true;
    if (hasObservers(this.onFocus)) {
      this.zone.run(() => {
        this.onFocus.emit();
      });
    }
  }
  handleBlur(args) {
    const currentTarget = args && currentFocusTarget(args);
    const target = args && args.target;
    const isInsideActionSheet = this.actionSheet && (this.actionSheet.element.nativeElement.contains(target) || this.actionSheet.element.nativeElement.contains(currentTarget));
    if (currentTarget && (this.dateInput.containsElement(currentTarget) || this.timeSelector && this.timeSelector.containsElement(currentTarget) || isInsideActionSheet)) {
      return;
    }
    if (hasObservers(this.onBlur) || this.show && hasObservers(this.close) || requiresZoneOnBlur(this.control)) {
      this.zone.run(() => {
        this.blurComponent();
        this.cdr.markForCheck();
      });
    } else {
      this.blurComponent();
    }
    this.cdr.detectChanges();
  }
  blurComponent() {
    this.isActive = false;
    this.show = false;
    this.onControlTouched();
    this.onBlur.emit();
  }
  handleDateCompletenessChange() {
    this.cdr.markForCheck();
    this.zone.run(() => this.onValidatorChange());
  }
  setComponentClasses() {
    if (this.size) {
      this.renderer.addClass(this.wrapper.nativeElement, getSizeClass("input", this.size));
      this.renderer.addClass(this.toggleButton.nativeElement, getSizeClass("button", this.size));
    }
    if (this.rounded) {
      this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
    }
    if (this.fillMode) {
      this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass("input", this.fillMode));
      this.renderer.addClass(this.toggleButton.nativeElement, getFillModeClass("button", this.fillMode));
      this.renderer.addClass(this.toggleButton.nativeElement, `k-button-${this.fillMode}-base`);
    }
  }
  static ɵfac = function TimePickerComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TimePickerComponent)(ɵɵdirectiveInject(BusViewService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(PickerService), ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(AdaptiveService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TimePickerComponent,
    selectors: [["kendo-timepicker"]],
    viewQuery: function TimePickerComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c14, 5, ViewContainerRef)(_c15, 5)(_c16, 7)(_c17, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.container = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.toggleButton = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.actionSheet = _t.first);
      }
    },
    hostVars: 8,
    hostBindings: function TimePickerComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-readonly", ctx.readonly)("k-timepicker", ctx.wrapperClasses)("k-input", ctx.wrapperClasses)("k-disabled", ctx.disabledClass);
      }
    },
    inputs: {
      focusableId: "focusableId",
      disabled: "disabled",
      readonly: "readonly",
      readOnlyInput: "readOnlyInput",
      clearButton: "clearButton",
      format: "format",
      formatPlaceholder: "formatPlaceholder",
      placeholder: "placeholder",
      min: "min",
      max: "max",
      incompleteDateValidation: "incompleteDateValidation",
      autoSwitchParts: "autoSwitchParts",
      autoSwitchKeys: "autoSwitchKeys",
      enableMouseWheel: "enableMouseWheel",
      allowCaretMode: "allowCaretMode",
      cancelButton: "cancelButton",
      nowButton: "nowButton",
      steps: "steps",
      popupSettings: "popupSettings",
      tabindex: "tabindex",
      tabIndex: "tabIndex",
      adaptiveTitle: "adaptiveTitle",
      adaptiveSubtitle: "adaptiveSubtitle",
      rangeValidation: "rangeValidation",
      adaptiveMode: "adaptiveMode",
      value: "value",
      size: "size",
      rounded: "rounded",
      fillMode: "fillMode",
      inputAttributes: "inputAttributes"
    },
    outputs: {
      valueChange: "valueChange",
      onFocus: "focus",
      onBlur: "blur",
      open: "open",
      close: "close",
      escape: "escape"
    },
    exportAs: ["kendo-timepicker"],
    features: [ɵɵProvidersFeature([{
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _TimePickerComponent),
      multi: true
    }, {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => _TimePickerComponent),
      multi: true
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _TimePickerComponent)
    }, {
      provide: MultiTabStop,
      useExisting: forwardRef(() => _TimePickerComponent)
    }, LocalizationService, BusViewService, {
      provide: L10N_PREFIX,
      useValue: "kendo.timepicker"
    }, PickerService]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
    decls: 17,
    vars: 42,
    consts: () => {
      let i18n_24;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_24 = goog.getMsg("Set");
        i18n_24 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_24;
      } else {
        i18n_24 = $localize`:kendo.timepicker.accept|The Accept button text in the timepicker component:Set`;
      }
      let i18n_25;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_25 = goog.getMsg("Set time");
        i18n_25 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_25;
      } else {
        i18n_25 = $localize`:kendo.timepicker.acceptLabel|The label for the Accept button in the timepicker component:Set time`;
      }
      let i18n_26;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_26 = goog.getMsg("Cancel");
        i18n_26 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_26;
      } else {
        i18n_26 = $localize`:kendo.timepicker.cancel|The Cancel button text in the timepicker component:Cancel`;
      }
      let i18n_27;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_27 = goog.getMsg("Cancel changes");
        i18n_27 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_27;
      } else {
        i18n_27 = $localize`:kendo.timepicker.cancelLabel|The label for the Cancel button in the timepicker component:Cancel changes`;
      }
      let i18n_28;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_28 = goog.getMsg("Now");
        i18n_28 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_28;
      } else {
        i18n_28 = $localize`:kendo.timepicker.now|The Now button text in the timepicker component:Now`;
      }
      let i18n_29;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_29 = goog.getMsg("Select now");
        i18n_29 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_29;
      } else {
        i18n_29 = $localize`:kendo.timepicker.nowLabel|The label for the Now button in the timepicker component:Select now`;
      }
      let i18n_30;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_30 = goog.getMsg("Toggle time list");
        i18n_30 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_30;
      } else {
        i18n_30 = $localize`:kendo.timepicker.toggle|The label for the toggle button in the timepicker component:Toggle time list`;
      }
      let i18n_31;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_31 = goog.getMsg("Hour");
        i18n_31 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_31;
      } else {
        i18n_31 = $localize`:kendo.timepicker.hour|The label for the hour part in the timepicker component:Hour`;
      }
      let i18n_32;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_32 = goog.getMsg("Minute");
        i18n_32 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_32;
      } else {
        i18n_32 = $localize`:kendo.timepicker.minute|The label for the minute part in the timepicker component:Minute`;
      }
      let i18n_33;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_33 = goog.getMsg("Second");
        i18n_33 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_33;
      } else {
        i18n_33 = $localize`:kendo.timepicker.second|The label for the second part in the timepicker component:Second`;
      }
      let i18n_34;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_34 = goog.getMsg("Millisecond");
        i18n_34 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_34;
      } else {
        i18n_34 = $localize`:kendo.timepicker.millisecond|The label for the millisecond part in the timepicker component:Millisecond`;
      }
      let i18n_35;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_35 = goog.getMsg("Dayperiod");
        i18n_35 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_35;
      } else {
        i18n_35 = $localize`:kendo.timepicker.dayperiod|The label for the dayperiod part in the timepicker component:Dayperiod`;
      }
      let i18n_36;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_36 = goog.getMsg("clear");
        i18n_36 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_36;
      } else {
        i18n_36 = $localize`:kendo.timepicker.clearTitle|The title of the clear button:clear`;
      }
      let i18n_37;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_37 = goog.getMsg("Close");
        i18n_37 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_37;
      } else {
        i18n_37 = $localize`:kendo.timepicker.adaptiveCloseButtonTitle|The title of the Close button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode:Close`;
      }
      return [["input", ""], ["toggleButton", ""], ["popupTemplate", ""], ["container", ""], ["actionSheet", ""], ["timeSelectorTemplate", ""], ["timeSelector", ""], ["kendoTimePickerLocalizedMessages", "", "accept", i18n_24, "acceptLabel", i18n_25, "cancel", i18n_26, "cancelLabel", i18n_27, "now", i18n_28, "nowLabel", i18n_29, "toggle", i18n_30, "hour", i18n_31, "minute", i18n_32, "second", i18n_33, "millisecond", i18n_34, "dayperiod", i18n_35, "clearTitle", i18n_36, "adaptiveCloseButtonTitle", i18n_37], ["pickerType", "timepicker", "hasPopup", "dialog", "fillMode", "none", "rounded", "none", "size", "none", 3, "valueChange", "click", "isPopupOpen", "disabled", "clearButton", "readonly", "role", "ariaReadOnly", "format", "formatPlaceholder", "placeholder", "focusableId", "min", "max", "incompleteDateValidation", "autoSwitchParts", "autoSwitchKeys", "enableMouseWheel", "allowCaretMode", "steps", "tabindex", "isRequired", "title", "inputAttributes", "value"], [3, "clearTitle"], ["type", "button", "tabindex", "-1", 1, "k-input-button", "k-button", "k-icon-button", 3, "kendoEventsOutsideAngular", "scope"], ["name", "clock", "innerCssClass", "k-button-icon", 3, "svgIcon"], [3, "overlayClick", "collapse", "titleId", "cssClass", "cssStyle"], ["kendoActionSheetTemplate", ""], [4, "ngTemplateOutlet"], [3, "resize"], [1, "k-actionsheet-titlebar"], [1, "k-actionsheet-titlebar-group"], [1, "k-actionsheet-title"], [1, "k-text-center"], [1, "k-actionsheet-subtitle", "k-text-center"], [1, "k-actionsheet-actions"], ["kendoButton", "", "type", "button", "icon", "check", "fillMode", "flat", "size", "large", 3, "click", "svgIcon", "tabIndex"], [1, "k-actionsheet-content"], [1, "k-actions", "k-actions-stretched", "k-actions-horizontal", "k-actionsheet-footer"], ["kendoButton", "", "type", "button", "size", "large", 1, "k-time-cancel", 3, "click"], ["kendoButton", "", "type", "button", "size", "large", "themeColor", "primary", 1, "k-time-accept", 3, "click"], [3, "valueChange", "valueReject", "tabOutLastPart", "tabOutFirstPart", "tabOutNow", "cancelButton", "setButton", "nowButton", "format", "min", "max", "steps", "value", "isAdaptiveEnabled", "kendoEventsOutsideAngular", "scope"], [3, "acceptLabel", "accept", "cancelLabel", "cancel", "nowLabel", "now", "hour", "minute", "second", "millisecond", "dayperiod"]];
    },
    template: function TimePickerComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainer(0, 7);
        ɵɵelementStart(1, "kendo-dateinput", 8, 0);
        ɵɵlistener("valueChange", function TimePickerComponent_Template_kendo_dateinput_valueChange_1_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleInputChange($event));
        })("click", function TimePickerComponent_Template_kendo_dateinput_click_1_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleDateInputClick());
        });
        ɵɵelement(3, "kendo-dateinput-messages", 9);
        ɵɵelementEnd();
        ɵɵelementStart(4, "button", 10, 1);
        ɵɵelement(6, "kendo-icon-wrapper", 11);
        ɵɵelementEnd();
        ɵɵtemplate(7, TimePickerComponent_ng_template_7_Template, 1, 1, "ng-template", null, 2, ɵɵtemplateRefExtractor);
        ɵɵelementContainer(9, null, 3);
        ɵɵconditionalCreate(11, TimePickerComponent_Conditional_11_Template, 1, 0, "kendo-resize-sensor");
        ɵɵelementStart(12, "kendo-actionsheet", 12, 4);
        ɵɵlistener("overlayClick", function TimePickerComponent_Template_kendo_actionsheet_overlayClick_12_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.show = false);
        })("collapse", function TimePickerComponent_Template_kendo_actionsheet_collapse_12_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleActionSheetCollapse());
        });
        ɵɵtemplate(14, TimePickerComponent_ng_template_14_Template, 14, 12, "ng-template", 13);
        ɵɵelementEnd();
        ɵɵtemplate(15, TimePickerComponent_ng_template_15_Template, 3, 27, "ng-template", null, 5, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("isPopupOpen", ctx.show)("disabled", ctx.disabled)("clearButton", ctx.clearButton)("readonly", ctx.readonly || ctx.readOnlyInput)("role", "combobox")("ariaReadOnly", ctx.readonly)("format", ctx.format)("formatPlaceholder", ctx.formatPlaceholder)("placeholder", ctx.placeholder)("focusableId", ctx.focusableId)("min", ctx.normalizeTime(ctx.min))("max", ctx.normalizeTime(ctx.max))("incompleteDateValidation", ctx.incompleteDateValidation)("autoSwitchParts", ctx.autoSwitchParts)("autoSwitchKeys", ctx.autoSwitchKeys)("enableMouseWheel", ctx.enableMouseWheel)("allowCaretMode", ctx.allowCaretMode)("steps", ctx.steps)("tabindex", !ctx.show ? ctx.tabindex : -1)("isRequired", ctx.isControlRequired)("title", ctx.adaptiveTitle)("inputAttributes", ctx.inputAttributes)("value", ctx.value);
        ɵɵadvance(2);
        ɵɵproperty("clearTitle", ctx.localization.get("clearTitle"));
        ɵɵadvance();
        ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction2(34, _c18, ctx.handleIconClick, ctx.handleMousedown))("scope", ctx);
        ɵɵattribute("title", ctx.localization.get("toggle"))("aria-label", ctx.localization.get("toggle"))("disabled", ctx.disabled ? "" : null);
        ɵɵadvance(2);
        ɵɵproperty("svgIcon", ctx.clockIcon);
        ɵɵadvance(5);
        ɵɵconditional(ctx.isAdaptiveModeEnabled ? 11 : -1);
        ɵɵadvance();
        ɵɵproperty("titleId", ctx.focusableId)("cssClass", ɵɵpureFunction2(37, _c19, ctx.windowSize === "small", ctx.windowSize === "medium"))("cssStyle", ɵɵpureFunction1(40, _c20, ctx.windowSize === "small" ? "100vh" : "60vh"));
      }
    },
    dependencies: [TimePickerLocalizedMessagesDirective, DateInputComponent, DateInputCustomMessagesComponent, EventsOutsideAngularDirective, IconWrapperComponent, NgTemplateOutlet, ResizeSensorComponent, ActionSheetComponent, ActionSheetTemplateDirective, ButtonComponent, TimeSelectorComponent, TimeSelectorCustomMessagesComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimePickerComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      exportAs: "kendo-timepicker",
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => TimePickerComponent),
        multi: true
      }, {
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => TimePickerComponent),
        multi: true
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => TimePickerComponent)
      }, {
        provide: MultiTabStop,
        useExisting: forwardRef(() => TimePickerComponent)
      }, LocalizationService, BusViewService, {
        provide: L10N_PREFIX,
        useValue: "kendo.timepicker"
      }, PickerService],
      selector: "kendo-timepicker",
      template: `
        <ng-container kendoTimePickerLocalizedMessages
          i18n-accept="kendo.timepicker.accept|The Accept button text in the timepicker component"
          accept="Set"
        
          i18n-acceptLabel="kendo.timepicker.acceptLabel|The label for the Accept button in the timepicker component"
          acceptLabel="Set time"
        
          i18n-cancel="kendo.timepicker.cancel|The Cancel button text in the timepicker component"
          cancel="Cancel"
        
          i18n-cancelLabel="kendo.timepicker.cancelLabel|The label for the Cancel button in the timepicker component"
          cancelLabel="Cancel changes"
        
          i18n-now="kendo.timepicker.now|The Now button text in the timepicker component"
          now="Now"
        
          i18n-nowLabel="kendo.timepicker.nowLabel|The label for the Now button in the timepicker component"
          nowLabel="Select now"
        
          i18n-toggle="kendo.timepicker.toggle|The label for the toggle button in the timepicker component"
          toggle="Toggle time list"
        
          i18n-hour="kendo.timepicker.hour|The label for the hour part in the timepicker component"
          hour="Hour"
        
          i18n-minute="kendo.timepicker.minute|The label for the minute part in the timepicker component"
          minute="Minute"
        
          i18n-second="kendo.timepicker.second|The label for the second part in the timepicker component"
          second="Second"
        
          i18n-millisecond="kendo.timepicker.millisecond|The label for the millisecond part in the timepicker component"
          millisecond="Millisecond"
        
          i18n-dayperiod="kendo.timepicker.dayperiod|The label for the dayperiod part in the timepicker component"
          dayperiod="Dayperiod"
        
          i18n-clearTitle="kendo.timepicker.clearTitle|The title of the clear button"
          clearTitle="clear"
        
          i18n-adaptiveCloseButtonTitle="kendo.timepicker.adaptiveCloseButtonTitle|The title of the Close button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode"
          adaptiveCloseButtonTitle="Close"
          >
        </ng-container>
        <kendo-dateinput
          #input
          pickerType="timepicker"
          hasPopup="dialog"
          [isPopupOpen]="show"
          [disabled]="disabled"
          [clearButton]="clearButton"
          [readonly]="readonly || readOnlyInput"
          [role]="'combobox'"
          [ariaReadOnly]="readonly"
          [format]="format"
          [formatPlaceholder]="formatPlaceholder"
          [placeholder]="placeholder"
          [focusableId]="focusableId"
          [min]="normalizeTime(min)"
          [max]="normalizeTime(max)"
          [incompleteDateValidation]="incompleteDateValidation"
          [autoSwitchParts]="autoSwitchParts"
          [autoSwitchKeys]="autoSwitchKeys"
          [enableMouseWheel]="enableMouseWheel"
          [allowCaretMode]="allowCaretMode"
          fillMode="none"
          rounded="none"
          size="none"
          [steps]="steps"
          [tabindex]="!show ? tabindex : -1"
          [isRequired]="isControlRequired"
          [title]="adaptiveTitle"
          [inputAttributes]="inputAttributes"
          [value]="value"
          (valueChange)="handleInputChange($event)"
          (click)="handleDateInputClick()"
          >
          <kendo-dateinput-messages
            [clearTitle]="localization.get('clearTitle')"
            >
          </kendo-dateinput-messages>
        </kendo-dateinput>
        <button
          #toggleButton
          type="button"
          tabindex="-1"
          class="k-input-button k-button k-icon-button"
          [attr.title]="localization.get('toggle')"
          [attr.aria-label]="localization.get('toggle')"
          [attr.disabled]="disabled ? '' : null"
            [kendoEventsOutsideAngular]="{
                click: handleIconClick,
                mousedown: handleMousedown
            }"
          [scope]="this"
          >
          <kendo-icon-wrapper
            name="clock"
            [svgIcon]="clockIcon"
            innerCssClass="k-button-icon"
            >
          </kendo-icon-wrapper>
        </button>
        <ng-template #popupTemplate>
          <ng-container *ngTemplateOutlet="timeSelectorTemplate"></ng-container>
        </ng-template>
        <ng-container #container></ng-container>
        
        @if (isAdaptiveModeEnabled) {
          <kendo-resize-sensor (resize)="onResize()"></kendo-resize-sensor>
        }
        <kendo-actionsheet
          #actionSheet
          (overlayClick)="show=false"
          (collapse)="handleActionSheetCollapse()"
          [titleId]="focusableId"
            [cssClass]="{
                'k-adaptive-actionsheet': true,
                'k-actionsheet-fullscreen': windowSize === 'small',
                'k-actionsheet-bottom': windowSize === 'medium'
            }"
            [cssStyle]="{
                height: windowSize === 'small' ? '100vh' : '60vh'
            }"
          >
          <ng-template kendoActionSheetTemplate>
            <div class="k-actionsheet-titlebar">
              <div class="k-actionsheet-titlebar-group">
                <div class="k-actionsheet-title">
                  @if (adaptiveTitle) {
                    <div class="k-text-center">{{ adaptiveTitle }}</div>
                  }
                  @if (adaptiveSubtitle) {
                    <div class="k-actionsheet-subtitle k-text-center">{{ adaptiveSubtitle }}</div>
                  }
                </div>
                <div class="k-actionsheet-actions">
                  <button
                    kendoButton
                    type="button"
                    icon="check"
                    [attr.title]="localization.get('adaptiveCloseButtonTitle')"
                    [svgIcon]="checkIcon"
                    fillMode="flat"
                    size="large"
                    [tabIndex]="-1"
                    (click)="show = false">
                  </button>
                </div>
              </div>
            </div>
            <div class="k-actionsheet-content">
              <ng-container *ngTemplateOutlet="timeSelectorTemplate"></ng-container>
            </div>
            <div class="k-actions k-actions-stretched k-actions-horizontal k-actionsheet-footer">
              <button kendoButton
                type="button"
                (click)="handleReject()"
                size="large"
                class="k-time-cancel"
                [attr.title]="localization.get('cancelLabel')"
                [attr.aria-label]="localization.get('cancelLabel')"
                >
                {{localization.get('cancel')}}
              </button>
        
              <button kendoButton
                type="button"
                (click)="handleActionSheetAccept()"
                size="large"
                class="k-time-accept"
                themeColor="primary"
                [attr.title]="localization.get('acceptLabel')"
                [attr.aria-label]="localization.get('acceptLabel')"
                >
                {{localization.get('accept')}}
              </button>
            </div>
          </ng-template>
        </kendo-actionsheet>
        
        <ng-template #timeSelectorTemplate>
          <kendo-timeselector
            #timeSelector
            [class.k-timeselector-lg]="isAdaptive"
            [cancelButton]="cancelButton && !this.isAdaptive"
            [setButton]="!isAdaptive"
            [nowButton]="nowButton"
            [format]="format"
            [min]="min"
            [max]="max"
            [steps]="steps"
            [value]="value"
            [isAdaptiveEnabled]="isAdaptiveModeEnabled"
                [kendoEventsOutsideAngular]="{
                    keydown: handleKeydown,
                    mousedown: handleMousedown
                }"
            [scope]="this"
            (valueChange)="handleChange($event)"
            (valueReject)="handleReject()"
            (tabOutLastPart)="onTabOutLastPart()"
            (tabOutFirstPart)="onTabOutFirstPart()"
            (tabOutNow)="onTabOutNow()"
            >
            <kendo-timeselector-messages
              [acceptLabel]="localization.get('acceptLabel')"
              [accept]="localization.get('accept')"
              [cancelLabel]="localization.get('cancelLabel')"
              [cancel]="localization.get('cancel')"
              [nowLabel]="localization.get('nowLabel')"
              [now]="localization.get('now')"
              [hour]="localization.get('hour')"
              [minute]="localization.get('minute')"
              [second]="localization.get('second')"
              [millisecond]="localization.get('millisecond')"
              [dayperiod]="localization.get('dayperiod')"
              >
            </kendo-timeselector-messages>
          </kendo-timeselector>
        </ng-template>
        `,
      standalone: true,
      imports: [TimePickerLocalizedMessagesDirective, DateInputComponent, DateInputCustomMessagesComponent, EventsOutsideAngularDirective, IconWrapperComponent, NgTemplateOutlet, ResizeSensorComponent, ActionSheetComponent, ActionSheetTemplateDirective, ButtonComponent, TimeSelectorComponent, TimeSelectorCustomMessagesComponent]
    }]
  }], () => [{
    type: BusViewService
  }, {
    type: NgZone
  }, {
    type: LocalizationService
  }, {
    type: ChangeDetectorRef
  }, {
    type: PopupService
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: Injector
  }, {
    type: PickerService
  }, {
    type: IntlService
  }, {
    type: AdaptiveService
  }], {
    container: [{
      type: ViewChild,
      args: ["container", {
        read: ViewContainerRef,
        static: false
      }]
    }],
    popupTemplate: [{
      type: ViewChild,
      args: ["popupTemplate", {
        static: false
      }]
    }],
    toggleButton: [{
      type: ViewChild,
      args: ["toggleButton", {
        static: true
      }]
    }],
    actionSheet: [{
      type: ViewChild,
      args: ["actionSheet"]
    }],
    focusableId: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-readonly"]
    }],
    readOnlyInput: [{
      type: Input
    }],
    clearButton: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    formatPlaceholder: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    incompleteDateValidation: [{
      type: Input
    }],
    autoSwitchParts: [{
      type: Input
    }],
    autoSwitchKeys: [{
      type: Input
    }],
    enableMouseWheel: [{
      type: Input
    }],
    allowCaretMode: [{
      type: Input
    }],
    cancelButton: [{
      type: Input
    }],
    nowButton: [{
      type: Input
    }],
    steps: [{
      type: Input
    }],
    popupSettings: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    adaptiveTitle: [{
      type: Input
    }],
    adaptiveSubtitle: [{
      type: Input
    }],
    rangeValidation: [{
      type: Input
    }],
    adaptiveMode: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }],
    fillMode: [{
      type: Input
    }],
    inputAttributes: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    open: [{
      type: Output
    }],
    close: [{
      type: Output
    }],
    escape: [{
      type: Output
    }],
    wrapperClasses: [{
      type: HostBinding,
      args: ["class.k-timepicker"]
    }, {
      type: HostBinding,
      args: ["class.k-input"]
    }],
    disabledClass: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }]
  });
})();
var DateTimePickerMessages = class _DateTimePickerMessages extends ComponentMessages {
  /**
   * The title of the **Toggle** button of the DateTimePicker.
   */
  toggle;
  /**
   * The text of the **Date** tab in the popup header of the DateTimePicker.
   */
  dateTab;
  /**
   * The label of the **Date** tab in the popup header of the DateTimePicker.
   */
  dateTabLabel;
  /**
   * The text of the **Time** tab in the popup header of the DateTimePicker.
   */
  timeTab;
  /**
   * The label of the **Time** tab in the popup header of the DateTimePicker.
   */
  timeTabLabel;
  /**
   * The text of the **Accept** button in the popup footer of the DateTimePicker.
   */
  accept;
  /**
   * The label of the **Accept** button in the popup footer of the DateTimePicker.
   */
  acceptLabel;
  /**
   * The text of the **Cancel** button in the popup footer of the DateTimePicker.
   */
  cancel;
  /**
   * The label of the **Cancel** button in the popup footer of the DateTimePicker.
   */
  cancelLabel;
  /**
   * The **Today** button text in the header of the Calendar.
   */
  today;
  /**
   * The text of the **Now** button in the popup header of the TimePicker.
   */
  now;
  /**
   * The label of the **Now** button in the popup header of the TimePicker.
   */
  nowLabel;
  /**
   * The title of the **Prev** button in the header of the Classic Calendar.
   */
  prevButtonTitle;
  /**
   * The title of the **Next** button in the header of the Classic Calendar.
   */
  nextButtonTitle;
  /**
   * The title of the **Parent View** button in the header of the Calendar.
   */
  parentViewButtonTitle;
  /**
   * The label of the **Hour** part in the TimePicker.
   */
  hour;
  /**
   * The label of the **Minute** part in the TimePicker.
   */
  minute;
  /**
   * The label of the **Second** part in the TimePicker.
   */
  second;
  /**
   * The label of the **Millisecond** part in the TimePicker.
   */
  millisecond;
  /**
   * The label of the **Dayperiod** part in the TimePicker.
   */
  dayperiod;
  /**
   * The title of the **Clear** button of the DateTimePicker.
   */
  clearTitle;
  /**
   * The title of the Close button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode.
   */
  adaptiveCloseButtonTitle;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵDateTimePickerMessages_BaseFactory;
    return function DateTimePickerMessages_Factory(__ngFactoryType__) {
      return (ɵDateTimePickerMessages_BaseFactory || (ɵDateTimePickerMessages_BaseFactory = ɵɵgetInheritedFactory(_DateTimePickerMessages)))(__ngFactoryType__ || _DateTimePickerMessages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _DateTimePickerMessages,
    selectors: [["kendo-datetimepicker-messages-base"]],
    inputs: {
      toggle: "toggle",
      dateTab: "dateTab",
      dateTabLabel: "dateTabLabel",
      timeTab: "timeTab",
      timeTabLabel: "timeTabLabel",
      accept: "accept",
      acceptLabel: "acceptLabel",
      cancel: "cancel",
      cancelLabel: "cancelLabel",
      today: "today",
      now: "now",
      nowLabel: "nowLabel",
      prevButtonTitle: "prevButtonTitle",
      nextButtonTitle: "nextButtonTitle",
      parentViewButtonTitle: "parentViewButtonTitle",
      hour: "hour",
      minute: "minute",
      second: "second",
      millisecond: "millisecond",
      dayperiod: "dayperiod",
      clearTitle: "clearTitle",
      adaptiveCloseButtonTitle: "adaptiveCloseButtonTitle"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateTimePickerMessages, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line
      selector: "kendo-datetimepicker-messages-base"
    }]
  }], null, {
    toggle: [{
      type: Input
    }],
    dateTab: [{
      type: Input
    }],
    dateTabLabel: [{
      type: Input
    }],
    timeTab: [{
      type: Input
    }],
    timeTabLabel: [{
      type: Input
    }],
    accept: [{
      type: Input
    }],
    acceptLabel: [{
      type: Input
    }],
    cancel: [{
      type: Input
    }],
    cancelLabel: [{
      type: Input
    }],
    today: [{
      type: Input
    }],
    now: [{
      type: Input
    }],
    nowLabel: [{
      type: Input
    }],
    prevButtonTitle: [{
      type: Input
    }],
    nextButtonTitle: [{
      type: Input
    }],
    parentViewButtonTitle: [{
      type: Input
    }],
    hour: [{
      type: Input
    }],
    minute: [{
      type: Input
    }],
    second: [{
      type: Input
    }],
    millisecond: [{
      type: Input
    }],
    dayperiod: [{
      type: Input
    }],
    clearTitle: [{
      type: Input
    }],
    adaptiveCloseButtonTitle: [{
      type: Input
    }]
  });
})();
var LocalizedMessagesDirective = class _LocalizedMessagesDirective extends DateTimePickerMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function LocalizedMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LocalizedMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LocalizedMessagesDirective,
    selectors: [["", "kendoDateTimePickerLocalizedMessages", ""]],
    features: [ɵɵProvidersFeature([{
      provide: DateTimePickerMessages,
      useExisting: forwardRef(() => _LocalizedMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalizedMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: DateTimePickerMessages,
        useExisting: forwardRef(() => LocalizedMessagesDirective)
      }],
      selector: "[kendoDateTimePickerLocalizedMessages]",
      standalone: true
    }]
  }], () => [{
    type: LocalizationService
  }], null);
})();
var timeFormatRegExp = new RegExp(`${TIME_PART.hour}|${TIME_PART.minute}|${TIME_PART.second}|${TIME_PART.dayperiod}|literal`);
var VALUE_DOC_LINK = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/datetimepicker/integration-with-json/";
var MIN_MAX_DOC_LINK = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/datetimepicker/date-time-limits/";
var DEFAULT_ACTIVE_TAB = "date";
var DEFAULT_DATEINPUT_FORMAT = "g";
var DEFAULT_TIMESELECTOR_FORMAT = "t";
var TWO_DIGIT_YEAR_MAX = 68;
var ACCEPT_BUTTON_SELECTOR = ".k-button.k-time-accept";
var CANCEL_BUTTON_SELECOTR = ".k-button.k-time-cancel";
var DATE_TAB_BUTTON_SELECTOR = ".k-button.k-group-start";
var TIME_TAB_BUTTON_SELECTOR = ".k-button.k-group-end";
var TODAY_BUTTON_SELECTOR = ".k-button.k-calendar-nav-today";
var DateTimePickerComponent = class _DateTimePickerComponent extends MultiTabStop {
  popupService;
  intl;
  cdr;
  pickerService;
  ngZone;
  wrapper;
  localization;
  disabledDatesService;
  renderer;
  injector;
  adaptiveService;
  /**
   * @hidden
   */
  calendarIcon = calendarIcon;
  /**
   * @hidden
   */
  clockIcon = clockIcon;
  /**
   * @hidden
   */
  hostClasses = true;
  /**
   * @hidden
   */
  get disabledClass() {
    return this.disabled;
  }
  /**
   * @hidden
   */
  toggleButton;
  /**
   * @hidden
   */
  get dateInput() {
    return this.pickerService.input;
  }
  /**
   * @hidden
   */
  get calendar() {
    return this.pickerService.calendar;
  }
  /**
   * @hidden
   */
  get timeSelector() {
    return this.pickerService.timeSelector;
  }
  /**
   * @hidden
   */
  focusableId;
  /**
   * Sets the format of the displayed Calendar week days' names.
   * @default 'short'
   */
  weekDaysFormat = "short";
  /**
   * Displays the days that fall out of the current month in the Calendar ([see example]({% slug datetimepicker_calendar_options %}#toc-displaying-other-month-days)).
   * You can set this to show or hide days from other months.
   *
   * For infinite Calendar the default value is `false`, while for classic Calendar it is `true`.
   */
  showOtherMonthDays;
  /**
   * Sets the value of the DateTimePicker component.
   * You can set a specific date and time for the picker to display and use.
   *
   * The `value` has to be a valid [JavaScript `Date`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date) instance or `null`.
   */
  set value(value2) {
    this.verifyValue(value2);
    this._value = cloneDate(value2);
    this.setCalendarValue(value2);
    this.cdr.markForCheck();
  }
  get value() {
    return this._value;
  }
  /**
   * Specifies the date format for displaying the input value
   * ([see example]({% slug formats_datetimepicker %})).
   *
   * When using a string format, the same format is applied regardless of whether the input is focused or blurred.
   * When using a FormatSettings object, you can specify different inputFormat and displayFormat values for focused and blurred states.
   *
   * If a FormatSettings object is provided, the displayFormat value will be used for the popup TimePicker.
   */
  set format(format) {
    this._format = format;
    const displayFormat = this.getDisplayFormat(format);
    this.timeSelectorFormat = this.getTimeSelectorFormat(displayFormat);
  }
  get format() {
    return this._format;
  }
  /**
   * The maximum year to assume to be from the current century when typing two-digit year value
   * ([see example]({% slug formats_datetimepicker %}#toc-two-digit-year-format)).
   *
   * The default value is 68, indicating that typing any value less than 69
   * will be assumed to be 20xx, while 69 and larger will be assumed to be 19xx.
   * @default 68
   */
  twoDigitYearMax = TWO_DIGIT_YEAR_MAX;
  /**
   * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the DateTimePicker.
   */
  set tabindex(value2) {
    const tabindex = Number(value2);
    const defaultValue = 0;
    this._tabindex = !isNaN(tabindex) ? tabindex : defaultValue;
  }
  get tabindex() {
    return this.disabled ? -1 : this._tabindex;
  }
  /**
   * Sets the dates of the DateTimePicker that will be disabled
   * ([see example]({% slug disabled_dates_datetimepicker %})).
   */
  set disabledDates(value2) {
    this._disabledDates = value2;
    this.disabledDatesService.initialize(value2);
  }
  get disabledDates() {
    return this._disabledDates;
  }
  /**
   * Configures the popup settings of the DateTimePicker
   * ([see example]({% slug datetimepicker_popup_options %}#toc-customizing-the-popup)).
   *
   * The available options are animate which controls the popup animation and by default, the open and close animations are enabled.
   * The `appendTo` option controls the popup container and by default, the popup will be appended to the root component.
   * The `popupClass` option specifies a list of CSS classes that are used to style the popup.
   */
  set popupSettings(settings) {
    this._popupSettings = Object.assign({}, {
      animate: true
    }, settings);
  }
  get popupSettings() {
    return this._popupSettings;
  }
  /**
   * Specifies the title of the input element of the DateTimePicker and the title text rendered
   * in the header of the popup (action sheet). Applicable only when [`AdaptiveMode` is set to `auto`](slug:api_dateinputs_adaptivemode).
   * @default ''
   */
  adaptiveTitle = "";
  /**
   * Specifies the subtitle text rendered in the header of the popup (action sheet).
   * Applicable only when [`AdaptiveMode` is set to `auto`](slug:api_dateinputs_adaptivemode).
   * @default ''
   */
  adaptiveSubtitle = "";
  /**
   * Specifies the `disabled` property of the DateTimePicker and determines whether the component is active
   * ([see example]({% slug disabled_datetimepicker %})).
   * To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_datetimepicker#toc-managing-the-datetimepicker-disabled-state-in-reactive-forms).
   * @default false
   */
  disabled = false;
  /**
   * Specifies the read-only state of the DateTimePicker
   * ([see example]({% slug readonly_datetimepicker %}#toc-read-only-datetimepicker)).
   * @default false
   *
   * @default false
   */
  readonly = false;
  /**
   * Determines whether the input field of the DateTimePicker is read-only
   * ([see example]({% slug readonly_datetimepicker %}#toc-read-only-input)).
   *
   * If you set the [`readonly`]({% slug api_dateinputs_datetimepickercomponent %}#toc-readonly) property value to `true`,
   * the input will be rendered in a read-only state regardless of the `readOnlyInput` value.
   *
   * @default false
   */
  readOnlyInput = false;
  /**
   * Determines whether to display the **Cancel** button in the popup
   * ([see example]({% slug datetimepicker_popup_options %}#toc-toggling-the-cancel-button)).
   * @default true
   */
  cancelButton = true;
  /**
   * Defines the descriptions of the format sections in the input field
   * ([see example]({% slug placeholders_datetimepicker %}#toc-format-sections-description)).
   */
  formatPlaceholder;
  /**
   * Specifies the hint which is displayed by the DateTimePicker when its value is `null`
   * ([see example]({% slug placeholders_datetimepicker %}#toc-text-hints)).
   */
  placeholder;
  /**
   * Configures the incremental steps of the DateInput and the popup component of the TimePicker
   * ([see example]({% slug incrementalsteps_datetimepicker %})).
   */
  steps = {};
  /**
   * Specifies the focused date of the popup Calendar
   * ([see example]({% slug datetimepicker_calendar_options %}#toc-focused-dates)).
   */
  focusedDate;
  /**
   * Specifies the Calendar type.
   *
   * @default 'infinite'
   */
  calendarType = "infinite";
  /**
   * Determines whether to enable animation when navigating to previous/next Calendar view.
   * Applies to the [`classic`]({% slug api_dateinputs_datetimepickercomponent %}#toc-calendartype) Calendar only.
   *
   * The feature uses the [Web Animations API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API). In order to run the animation in browsers that do not support it, you need the `web-animations-js` polyfill.
   *
   * @default false
   */
  animateCalendarNavigation = false;
  /**
   * Determines whether to display a week number column in the `month` view of the popup Calendar
   * ([see example]({% slug datetimepicker_calendar_options %}#toc-week-number-column)).
   * @default false
   */
  weekNumber = false;
  /**
   * Specifies the smallest valid date.
   * The Calendar will not display dates before this value.
   * If the `min` value of the Calendar is selected, the TimePicker will not display
   * time entries before the specified time portion of this value
   * ([see example]({% slug dateranges_datetimepicker %})).
   */
  set min(value2) {
    this._min = cloneDate(value2);
    this.calendarMin = getDate(value2 || MIN_DATE);
  }
  get min() {
    return this._min;
  }
  /**
   * Specifies the biggest valid date.
   * The Calendar will not display dates after this value.
   * If the `max` value of the Calendar is selected, the TimePicker will not display
   * time entries after the specified time portion of this value
   * ([see example]({% slug dateranges_datetimepicker %})).
   */
  set max(value2) {
    this._max = cloneDate(value2);
    this.calendarMax = lastMillisecondOfDate(value2 || MAX_DATE);
  }
  get max() {
    return this._max;
  }
  /**
   * Determines whether the built-in `min` or `max` validators are enforced when validating a form
   * ([see example](slug:dateranges_datetimepicker)).
   *
   * @default true
   */
  rangeValidation = true;
  /**
   * Determines whether the built-in validator for disabled date ranges is enforced when validating a form
   * ([see example](slug:disabled_dates_datetimepicker)).
   * @default true
   */
  disabledDatesValidation = true;
  /**
   * Determines whether the built-in validation for incomplete dates is enforced when validating a form.
   * @default false
   */
  incompleteDateValidation = false;
  /**
   * Determines whether to auto correct invalid segments automatically.
   *
   * @default true
   */
  autoCorrectParts = true;
  /**
   * Determines whether to automatically move to the next segment after the user completes the current one.
   *
   * @default true
   */
  autoSwitchParts = true;
  /**
   * Specifies custom keys that move the focus to the next date format segment.
   */
  autoSwitchKeys = [];
  /**
   * Determines whether you can use the mouse scroll to increase or decrease the time segment values.
   *
   * @default true
   */
  enableMouseWheel = true;
  /**
   * Determines whether you can see a blinking caret inside the DateInput when possible.
   *
   * @default false
   */
  allowCaretMode = false;
  /**
   * Renders a clear button when set to `true` after the input text or DateTimePicker value has been changed.
   * Clicking this button resets the value of the component to `null` and triggers the `valueChange` event.
   * @default false
   */
  clearButton = false;
  /**
   * Auto fills the rest of the date to the current date when the component loses focus.
   *
   * @default false
   */
  autoFill = false;
  /**
   * Enables or disables the adaptive mode. The adaptive rendering is disabled by default.
   * @default 'none'
   */
  adaptiveMode = "none";
  /**
   * Specifies the HTML attributes of the inner focusable input element. You cannot change attributes that are essential for certain component functionalities.
   */
  inputAttributes;
  /**
   * Fires each time the user selects a new value
   * ([see example](slug:events_datetimepicker)).
   */
  valueChange = new EventEmitter();
  /**
   * Fires each time the popup is about to open
   * ([see example](slug:events_datetimepicker)).
   * This event is preventable. If you cancel the event by setting `event.preventDefault()`, the popup will remain closed.
   */
  open = new EventEmitter();
  /**
   * Fires each time the popup is about to close
   * ([see example](slug:events_datetimepicker)).
   * This event is preventable. If you cancel the event by setting `event.preventDefault()`, the popup will remain open.
   */
  close = new EventEmitter();
  /**
   * Fires each time the user focuses the component
   * ([see example](slug:events_datetimepicker)).
   */
  onFocus = new EventEmitter();
  /**
   * Fires each time the user blurs the component
   * ([see example](slug:events_datetimepicker)).
   */
  onBlur = new EventEmitter();
  /**
   * @hidden
   */
  escape = new EventEmitter();
  /**
   * Indicates whether the component is currently open. This is when the popup or action sheet is open.
   */
  get isOpen() {
    return this.actionSheet?.expanded || isPresent4(this.popupRef);
  }
  /**
   * Indicates whether the component or its popup content is focused.
   */
  get isActive() {
    return this._isActive;
  }
  set isActive(value2) {
    if (value2) {
      this.renderer.addClass(this.wrapper.nativeElement, "k-focus");
    } else {
      this.renderer.removeClass(this.wrapper.nativeElement, "k-focus");
    }
    this._isActive = value2;
  }
  /**
   * Specifies the active tab when opening the popup
   * ([see example]({% slug datetimepicker_popup_options %}#toc-setting-the-default-tab)).
   */
  set defaultTab(tab) {
    this._defaultTab = tab || DEFAULT_ACTIVE_TAB;
    this.activeTab = this.defaultTab;
  }
  get defaultTab() {
    return this._defaultTab;
  }
  /**
   * Specifies the size of the component.
   *
   */
  set size(size) {
    this.renderer.removeClass(this.wrapper.nativeElement, getSizeClass("input", this.size));
    this.renderer.removeClass(this.toggleButton.nativeElement, getSizeClass("button", this.size));
    const newSize = size || DEFAULT_SIZE;
    if (newSize !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getSizeClass("input", newSize));
      this.renderer.addClass(this.toggleButton.nativeElement, getSizeClass("button", newSize));
    }
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * Specifies the border radius of the component.
   *
   */
  set rounded(rounded) {
    this.renderer.removeClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
    const newRounded = rounded || DEFAULT_ROUNDED;
    if (newRounded !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(newRounded));
    }
    this._rounded = newRounded;
  }
  get rounded() {
    return this._rounded;
  }
  /**
   * Specifies the fill mode of the component.
   *
   */
  set fillMode(fillMode) {
    this.renderer.removeClass(this.wrapper.nativeElement, getFillModeClass("input", this.fillMode));
    this.renderer.removeClass(this.toggleButton.nativeElement, getFillModeClass("button", this.fillMode));
    this.renderer.removeClass(this.toggleButton.nativeElement, `k-button-${this.fillMode}-base`);
    const newFillMode = fillMode || DEFAULT_FILL_MODE;
    if (newFillMode !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass("input", newFillMode));
      this.renderer.addClass(this.toggleButton.nativeElement, getFillModeClass("button", newFillMode));
      this.renderer.addClass(this.toggleButton.nativeElement, `k-button-${newFillMode}-base`);
    }
    this._fillMode = newFillMode;
  }
  get fillMode() {
    return this._fillMode;
  }
  /**
   * @hidden
   */
  get tabSwitchTransition() {
    return this.isOpen ? null : "none";
  }
  /**
   * @hidden
   *
   * Indicates whether the Calendar will be disabled.
   * The inactive tab component gets disabled and becomes inaccessible on tab click.
   */
  get disableCalendar() {
    return this.activeTab !== "date" && !this.calendar.isActive;
  }
  /**
   * @hidden
   *
   * Indicates whether the TimeSelector will be disabled.
   * The inactive tab component gets disabled and becomes inaccessible on tab click.
   */
  get disableTimeSelector() {
    return this.activeTab !== "time" && !this.timeSelector.isActive;
  }
  /**
   * @hidden
   */
  get isAdaptiveModeEnabled() {
    return this.adaptiveMode === "auto";
  }
  /**
   * @hidden
   */
  get isAdaptive() {
    return this.isAdaptiveModeEnabled && this.windowSize !== "large";
  }
  /**
   * @hidden
   */
  onResize() {
    const currentWindowSize = this.adaptiveService.size;
    if (!this.isOpen || this.windowSize === currentWindowSize) {
      return;
    }
    if (this.actionSheet.expanded) {
      this.toggleActionSheet(false);
    } else {
      this._togglePopup(false);
    }
    this.windowSize = currentWindowSize;
  }
  /**
   * @hidden
   *
   * Controls whether the Calendar or the TimeSelector will be displayed.
   */
  activeTab = DEFAULT_ACTIVE_TAB;
  /**
   * @hidden
   *
   * Specifies the stripped time-related format that is used in the TimeSelector.
   * Updates each time the `format` property value changes.
   */
  timeSelectorFormat = DEFAULT_TIMESELECTOR_FORMAT;
  /**
   * @hidden
   */
  timeSelectorMin = cloneDate(MIN_TIME);
  /**
   * @hidden
   */
  timeSelectorMax = cloneDate(MAX_TIME);
  /**
   * @hidden
   */
  calendarValue = null;
  /**
   * @hidden
   */
  calendarMin = cloneDate(MIN_DATE);
  /**
   * @hidden
   */
  calendarMax = lastMillisecondOfDate(MAX_DATE);
  /**
   * @hidden
   */
  checkIcon = checkIcon;
  /**
   * @hidden
   */
  windowSize;
  /**
   * @hidden
   */
  cellTemplate;
  /**
   * @hidden
   */
  monthCellTemplate;
  /**
   * @hidden
   */
  yearCellTemplate;
  /**
   * @hidden
   */
  decadeCellTemplate;
  /**
   * @hidden
   */
  centuryCellTemplate;
  /**
   * @hidden
   */
  weekNumberTemplate;
  /**
   * @hidden
   */
  headerTitleTemplate;
  /**
   * @hidden
   */
  headerTemplate;
  /**
   * @hidden
   */
  set headerTemplateRef(template) {
    this.headerTemplate = template;
  }
  /**
   * @hidden
   */
  footerTemplate;
  /**
   * @hidden
   */
  set footerTemplateRef(template) {
    this.footerTemplate = template;
  }
  /**
   * Toggles the visibility of the Calendar footer.
   * @default false
   */
  footer = false;
  get activeTabComponent() {
    if (!this.isOpen) {
      return;
    }
    if (!(isPresent4(this.calendar) || isPresent4(this.timeSelector))) {
      this.cdr.detectChanges();
    }
    return this.activeTab === "date" ? this.calendar : this.timeSelector;
  }
  get appendTo() {
    const {
      appendTo
    } = this.popupSettings;
    if (!isPresent4(appendTo) || appendTo === "root") {
      return void 0;
    }
    return appendTo === "component" ? this.container : appendTo;
  }
  container;
  popupTemplate;
  actionSheet;
  get popupUID() {
    return this.calendar?.popupId;
  }
  get acceptButton() {
    if (this.isAdaptive) {
      return this.actionSheet.element.nativeElement.querySelector(ACCEPT_BUTTON_SELECTOR);
    } else {
      return this.popupRef?.popup.instance.container.nativeElement.querySelector(ACCEPT_BUTTON_SELECTOR);
    }
  }
  get cancelButtonElement() {
    if (this.isAdaptive) {
      return this.actionSheet.element.nativeElement.querySelector(CANCEL_BUTTON_SELECOTR);
    } else {
      return this.popupRef?.popup.instance.container.nativeElement.querySelector(CANCEL_BUTTON_SELECOTR);
    }
  }
  get dateTabButton() {
    if (this.isAdaptive) {
      return this.actionSheet.element.nativeElement.querySelector(DATE_TAB_BUTTON_SELECTOR);
    } else {
      return this.popupRef?.popup.instance.container.nativeElement.querySelector(DATE_TAB_BUTTON_SELECTOR);
    }
  }
  get timeTabButton() {
    if (this.isAdaptive) {
      return this.actionSheet.element.nativeElement.querySelector(TIME_TAB_BUTTON_SELECTOR);
    } else {
      return this.popupRef?.popup.instance.container.nativeElement.querySelector(TIME_TAB_BUTTON_SELECTOR);
    }
  }
  get todayButton() {
    if (this.isAdaptive) {
      return this.actionSheet.element.nativeElement.querySelector(TODAY_BUTTON_SELECTOR);
    } else {
      return this.popupRef?.popup.instance.container.nativeElement.querySelector(TODAY_BUTTON_SELECTOR);
    }
  }
  get popupClasses() {
    const classes = ["k-datetime-container", "k-datetimepicker-popup"];
    if (!this.popupSettings.popupClass) {
      return classes;
    }
    const parsedPopupClasses = parseCSSClassNames(this.popupSettings.popupClass);
    if (parsedPopupClasses?.length) {
      classes.push(...parsedPopupClasses);
    }
    return classes;
  }
  /**
   * @hidden
   */
  get formControl() {
    const ngControl = this.injector.get(NgControl, null);
    return ngControl?.control || null;
  }
  /**
   * @hidden
   */
  get isControlRequired() {
    return isControlRequired(this.formControl);
  }
  popupRef;
  _popupSettings = {
    animate: true
  };
  _value = null;
  _format = DEFAULT_DATEINPUT_FORMAT;
  _tabindex = 0;
  _defaultTab = DEFAULT_ACTIVE_TAB;
  _min = mergeDateAndTime(MIN_DATE, MIN_TIME);
  _max = mergeDateAndTime(MAX_DATE, MAX_TIME);
  _disabledDates;
  _isActive = false;
  onControlTouched = noop$2;
  onControlChange = noop$2;
  onValidatorChange = noop$2;
  minValidateFn = noop$2;
  maxValidateFn = noop$2;
  disabledDatesValidateFn = noop$2;
  incompleteValidator = noop$2;
  subscriptions = new Subscription();
  ariaActiveDescendantSubscription;
  _size = DEFAULT_SIZE;
  _rounded = DEFAULT_ROUNDED;
  _fillMode = DEFAULT_FILL_MODE;
  constructor(popupService, intl, cdr, pickerService, ngZone, wrapper, localization, disabledDatesService, renderer, injector, adaptiveService) {
    super();
    this.popupService = popupService;
    this.intl = intl;
    this.cdr = cdr;
    this.pickerService = pickerService;
    this.ngZone = ngZone;
    this.wrapper = wrapper;
    this.localization = localization;
    this.disabledDatesService = disabledDatesService;
    this.renderer = renderer;
    this.injector = injector;
    this.adaptiveService = adaptiveService;
    N(packageMetadata);
  }
  ngOnInit() {
    this.subscriptions.add(this.pickerService.onFocus.pipe(tap(this.detectPopupChanges.bind(this))).subscribe(this.handleFocus.bind(this)));
    this.subscriptions.add(this.pickerService.onBlur.subscribe(this.handleBlur.bind(this)));
    this.subscriptions.add(this.pickerService.sameDateSelected.subscribe(this.handleCalendarValueChange.bind(this)));
    this.subscriptions.add(this.localization.changes.subscribe(() => this.cdr.markForCheck()));
    this.subscriptions.add(this.pickerService.dateCompletenessChange.subscribe(this.handleDateCompletenessChange.bind(this)));
    if (isWindowAvailable()) {
      this.subscriptions.add(this.ngZone.runOutsideAngular(() => fromEvent(window, "blur").subscribe(() => {
        if (!this.isAdaptive) {
          this.handleCancel();
        }
      })));
    }
    this.focusableId = this.dateInput?.focusableId;
    this.minValidateFn = this.rangeValidation ? minValidator(this.min) : noop$2;
    this.maxValidateFn = this.rangeValidation ? maxValidator(this.max) : noop$2;
  }
  ngAfterViewInit() {
    this.setComponentClasses();
    this.windowSize = this.adaptiveService.size;
  }
  ngOnChanges(changes) {
    if (isPresent4(changes["min"]) || isPresent4(changes["max"])) {
      this.verifyMinMaxRange();
    }
    if (changes["min"] || changes["max"] || changes["rangeValidation"] || changes["disabledDatesValidation"] || changes["disabledDates"] || changes["incompleteDateValidation"]) {
      this.minValidateFn = this.rangeValidation ? minValidator(this.min) : noop$2;
      this.maxValidateFn = this.rangeValidation ? maxValidator(this.max) : noop$2;
      this.disabledDatesValidateFn = this.disabledDatesValidation ? disabledDatesValidator(this.disabledDatesService.isDateDisabled) : noop$2;
      this.incompleteValidator = this.incompleteDateValidation ? incompleteDateValidator() : noop$2;
      this.onValidatorChange();
    }
    if (!this.focusableId || changes["focusableId"]) {
      this.focusableId = this.dateInput?.focusableId;
    }
  }
  ngOnDestroy() {
    if (this.isOpen && !this.isAdaptive) {
      this.closePopup();
    }
    this.subscriptions.unsubscribe();
  }
  /**
   * Focuses the DateTimePicker input if the popup is closed.
   * Moves the focus to the popup content if the popup is open.
   */
  focus() {
    if (this.disabled) {
      return;
    }
    if (this.isOpen) {
      this.activeTabComponent.focus();
    } else {
      this.dateInput.focus();
    }
  }
  /**
   * Blurs the DateTimePicker component.
   */
  blur() {
    if (this.isOpen && this.activeTabComponent.isActive) {
      this.activeTabComponent.blur();
    } else {
      this.dateInput.blur();
    }
  }
  /**
   * Toggles the visibility of the popup or action sheet.
   * If you use the `toggle` method to show or hide the popup or action sheet,
   * the `open` and `close` events do not fire.
   *
   * @param show - The state of the popup.
   */
  toggle(show) {
    if (this.disabled || this.readonly || show === this.isOpen) {
      return;
    }
    const previousWindowSize = this.windowSize;
    this.windowSize = this.adaptiveService.size;
    if (previousWindowSize !== this.windowSize && !show) {
      if (previousWindowSize !== "large") {
        this.toggleActionSheet(show);
      } else {
        this._togglePopup(show);
      }
    } else {
      if (this.isAdaptive) {
        this.toggleActionSheet(show);
      } else {
        this._togglePopup(show);
      }
    }
  }
  /**
   * @hidden
   */
  writeValue(value2) {
    this.verifyValue(value2);
    this.value = cloneDate(value2);
    this.cdr.markForCheck();
    if (!value2 && this.dateInput) {
      this.dateInput.placeholder = this.placeholder;
      this.dateInput.writeValue(value2);
    }
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.onControlChange = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.onControlTouched = fn;
  }
  /**
   * @hidden
   */
  setDisabledState(disabled) {
    this.disabled = disabled;
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  validate(control) {
    return this.minValidateFn(control) || this.maxValidateFn(control) || this.disabledDatesValidateFn(control) || this.incompleteValidator(control, this.dateInput && this.dateInput.isDateIncomplete);
  }
  /**
   * @hidden
   */
  registerOnValidatorChange(fn) {
    this.onValidatorChange = fn;
  }
  /**
   * @hidden
   *
   * Used by the TextBoxContainer to determine if the floating label will render in the input.
   */
  isEmpty() {
    return !isPresent4(this.value) && this.dateInput.isEmpty();
  }
  /**
   * @hidden
   */
  handleIconClick(event) {
    if (this.disabled || this.readonly) {
      return;
    }
    event.preventDefault();
    const runInZone = !this.isOpen || hasObservers(this.close);
    this.run(runInZone, () => {
      const shouldOpen = !this.isOpen;
      this.handleFocus();
      if (!shouldOpen) {
        this.dateInput.focus();
      }
      this.toggleDateTime(shouldOpen);
      this.switchFocus();
    });
  }
  /**
   * @hidden
   */
  handleFocus() {
    if (this.isActive) {
      return;
    }
    this.isActive = true;
    if (hasObservers(this.onFocus)) {
      this.ngZone.run(() => this.onFocus.emit());
    }
  }
  /**
   * @hidden
   */
  handleBlur(event) {
    if (!this.isActive || this.focusTargetInComponent(event)) {
      return;
    }
    this.isActive = false;
    const isNgControlUntouched = this.wrapper.nativeElement.classList.contains("ng-untouched");
    const runInZone = isNgControlUntouched || hasObservers(this.onBlur) || this.isOpen && hasObservers(this.close);
    this.run(runInZone, () => {
      this.onBlur.emit();
      this.onControlTouched();
      this.toggleDateTime(false);
      this.cdr.markForCheck();
    });
  }
  /**
   * @hidden
   */
  changeActiveTab(tab) {
    if (!this.isOpen || this.activeTab === tab) {
      return;
    }
    if (!isEqual(this.timeSelector.value, this.timeSelector.current)) {
      this.timeSelector.handleAccept();
    }
    this.activeTab = tab;
    this.cdr.detectChanges();
    this.detectPopupChanges();
  }
  /**
   * @hidden
   */
  handleTabChangeTransitionEnd(dateTimeSelector, event) {
    if (event.target !== dateTimeSelector) {
      return;
    }
    if (this.activeTab === "time") {
      this.renderer.removeAttribute(this.dateInput?.inputElement, attributeNames.ariaActiveDescendant);
    }
    this.activeTabComponent.focus();
  }
  /**
   * @hidden
   */
  onTabOutLastPart() {
    if (this.calendarValue) {
      this.acceptButton.focus();
    } else if (!this.calendarValue && this.cancelButton) {
      this.cancelButtonElement.focus();
    } else {
      this.dateTabButton.focus();
    }
  }
  /**
   * @hidden
   */
  onTabOutFirstPart() {
    if (this.activeTab === "time") {
      this.renderer.removeClass(this.timeSelector.timeListWrappers.first.nativeElement, "k-focus");
      this.timeSelector.showNowButton ? this.timeSelector.now.nativeElement.focus() : this.timeTabButton.focus();
    }
  }
  /**
   * @hidden
   */
  onTabOutNow() {
    this.timeTabButton.focus();
  }
  /**
   * @hidden
   */
  handleAccept() {
    if (!this.isOpen) {
      return;
    }
    const candidate = mergeDateAndTime(this.calendar.value, this.timeSelector.current);
    const valueChangePresent = !isEqual(this.value, candidate);
    const runInZone = valueChangePresent || hasObservers(this.close);
    this.run(runInZone, () => {
      this.handleValueChange(candidate);
      this.dateInput.focus();
      this.toggleDateTime(false);
    });
  }
  /**
   * @hidden
   */
  handleCancel() {
    if (!this.isOpen) {
      return;
    }
    const runInZone = hasObservers(this.close);
    this.dateInput.focus();
    this.run(runInZone, () => this.toggleDateTime(false));
    hasObservers(this.escape) && this.escape.emit();
  }
  /**
   * @hidden
   */
  handleInputValueChange(value2) {
    this.handleValueChange(value2);
    if (this.isOpen) {
      this.toggleDateTime(false);
    }
  }
  /**
   * @hidden
   */
  handleDateInputClick() {
    this.windowSize = this.adaptiveService.size;
    if (this.isAdaptive) {
      this.toggleDateTime(true);
    } else if (this.isOpen) {
      this.toggleDateTime(false);
    }
  }
  /**
   * @hidden
   */
  handleCalendarValueChange() {
    this.setTimeSelectorMinMax(this.calendar.value);
    this.changeActiveTab("time");
  }
  /**
   * @hidden
   */
  handleKeyDown(event) {
    if (this.disabled || this.readonly) {
      return;
    }
    const {
      altKey
    } = event;
    const code = normalizeKeys(event);
    switch (code) {
      case (altKey && Keys.ArrowUp):
      case Keys.Escape:
        this.handleCancel();
        break;
      case (!this.isOpen && altKey && Keys.ArrowDown):
        this.ngZone.run(() => this.toggleDateTime(true));
        break;
      case (altKey && Keys.ArrowRight):
        this.changeActiveTab("time");
        break;
      case (altKey && Keys.ArrowLeft):
        this.changeActiveTab("date");
        break;
      case (this.isOpen && this.timeSelector.isActive && isPresent4(this.calendarValue) && Keys.Enter):
        this.handleAccept();
        break;
      default:
        return;
    }
  }
  /**
   * @hidden
   */
  handleTab(event) {
    event.preventDefault();
    const {
      shiftKey
    } = event;
    switch (event.target) {
      case this.acceptButton:
        if (!shiftKey) {
          this.cancelButton ? this.cancelButtonElement.focus() : this.dateTabButton.focus();
        } else {
          if (this.activeTab === "date") {
            this.calendar.monthView.list.nativeElement.focus();
          } else {
            this.timeSelector.timeLists.last.focus();
          }
        }
        break;
      case this.cancelButtonElement:
        if (this.calendarValue) {
          shiftKey ? this.acceptButton.focus() : this.dateTabButton.focus();
        } else {
          if (shiftKey) {
            if (this.activeTab === "date") {
              this.calendar.monthView.list.nativeElement.focus();
            } else {
              this.timeSelector.timeLists.last.focus();
            }
          } else {
            this.dateTabButton.focus();
          }
        }
        break;
      case this.dateTabButton:
        if (this.cancelButton) {
          this.cancelButtonElement.focus();
        }
        if (!this.cancelButton && this.calendarValue) {
          this.acceptButton.focus();
        }
        if (!this.cancelButton && !this.calendarValue) {
          if (this.activeTab === "date") {
            this.calendar.monthView.list.nativeElement.focus();
          } else {
            this.timeSelector.timeLists.last.focus();
          }
        }
        break;
      case this.timeTabButton:
        if (this.activeTab === "time") {
          this.timeSelector.showNowButton ? this.timeSelector.now.nativeElement.focus() : this.timeSelector.timeLists.first.focus();
        } else {
          this.todayButton.focus();
        }
        break;
      default:
        break;
    }
  }
  /**
   * @hidden
   */
  handleActionSheetCollapse() {
    this.cdr.markForCheck();
    this.resetActiveTab();
  }
  /**
   * @hidden
   *
   * Prevents the diversion of the focus from the currently active element in the component.
   */
  preventMouseDown(event) {
    event.preventDefault();
  }
  /**
   * @hidden
   */
  toggleActionSheet(show) {
    if (isPresent4(show) && show && !this.isOpen) {
      this.actionSheet.toggle();
      this.renderer.setAttribute(this.actionSheet.element.nativeElement, "id", this.popupUID);
      this.renderer.setAttribute(this.dateInput?.inputElement, attributeNames.ariaControls, this.popupUID);
      this.setAriaActiveDescendant();
    } else if (isPresent4(show) && !show && this.isOpen) {
      this.handleBlur();
      this.actionSheet.toggle();
      this.ariaActiveDescendantSubscription.unsubscribe();
      if (this.dateInput) {
        this.renderer.removeAttribute(this.dateInput.inputElement, attributeNames.ariaActiveDescendant);
        this.renderer.removeAttribute(this.dateInput.inputElement, attributeNames.ariaControls);
        this.dateInput.focus();
      }
    }
  }
  _togglePopup(show) {
    const shouldOpen = isPresent4(show) ? show : !this.isOpen;
    if (shouldOpen) {
      this.openPopup();
      return;
    }
    this.closePopup();
    this.resetActiveTab();
  }
  /**
   * Changes the tab and the calendar or clock icon to the designated default.
   */
  resetActiveTab() {
    if (this.activeTab !== this.defaultTab) {
      this.activeTab = this.defaultTab;
      this.cdr.detectChanges();
    }
  }
  verifyValue(value2) {
    if (!isDevMode()) {
      return;
    }
    if (isPresent4(value2) && !(value2 instanceof Date)) {
      throw new Error(`The 'value' should be a valid JavaScript Date instance or null. Check ${VALUE_DOC_LINK} for possible resolution.`);
    }
  }
  verifyMinMaxRange() {
    if (!isDevMode()) {
      return;
    }
    if (!isValidRange(this.min, this.max)) {
      throw new Error(`The max value should be bigger than the min. See ${MIN_MAX_DOC_LINK}.`);
    }
  }
  /**
   * Extracts the time slots and literals that are not preceded by date parts
   * and combines the resulting parts into a string.
   * If the provided `format` value does not contain any time parts,
   * returns the designated format of the default popup component of the `TimePicker`.
   */
  getTimeSelectorFormat(format) {
    const timeSelectorFormat = this.intl.splitDateFormat(format).filter(this.timeFormatPartFilter).reduce((format2, part) => format2 += part.pattern, "");
    return timeSelectorFormat || DEFAULT_TIMESELECTOR_FORMAT;
  }
  /**
   * Extracts the `displayFormat` from the provided `string | FormatSettings` value.
   * Falls back to the default input value if a falsy value parameter is passed.
   */
  getDisplayFormat(format) {
    if (!format) {
      return DEFAULT_DATEINPUT_FORMAT;
    }
    if (typeof format === "string") {
      return format;
    } else {
      return format.displayFormat;
    }
  }
  /**
   * The filter expression that filters out all format parts
   * except for `hour`, `minute`, `second`, `dayperiod`, and specific literals.
   * Literals remain only if they are not preceded by date parts.
   */
  timeFormatPartFilter(part, index, parts) {
    const previousPart = index >= 1 && parts[index - 1];
    if (previousPart && part.type === "literal") {
      return timeFormatRegExp.test(previousPart.type);
    }
    return timeFormatRegExp.test(part.type);
  }
  /**
   * @hidden
   */
  toggleDateTime(open) {
    if (open === this.isOpen) {
      return;
    }
    const event = new PreventableEvent2();
    if (open) {
      this.open.emit(event);
    } else {
      this.close.emit(event);
    }
    if (event.isDefaultPrevented()) {
      return;
    }
    this.toggle(open);
    this.switchFocus();
  }
  switchFocus() {
    if (!this.isActive) {
      return;
    }
    if (this.isOpen) {
      this.activeTabComponent.focus();
    } else if (!touchEnabled) {
      this.dateInput.focus();
    } else if (!this.dateInput.isActive) {
      this.handleBlur();
    }
  }
  openPopup() {
    this.setCalendarValue(this.value);
    this.setTimeSelectorMinMax(this.value);
    const direction = this.localization.rtl ? "right" : "left";
    const appendToComponent = typeof this.popupSettings.appendTo === "string" && this.popupSettings.appendTo === "component";
    this.popupRef = this.popupService.open({
      anchor: this.wrapper,
      content: this.popupTemplate,
      positionMode: appendToComponent ? "fixed" : "absolute",
      animate: this.popupSettings.animate,
      appendTo: this.appendTo,
      popupClass: this.popupClasses,
      anchorAlign: {
        vertical: "bottom",
        horizontal: direction
      },
      popupAlign: {
        vertical: "top",
        horizontal: direction
      }
    });
    this.popupRef.popupElement.setAttribute("id", this.popupUID);
    this.renderer.setAttribute(this.dateInput?.inputElement, attributeNames.ariaControls, this.popupUID);
    this.setAriaActiveDescendant();
    this.popupRef.popupAnchorViewportLeave.subscribe(() => this.handleCancel());
    if (this.calendar.type === "infinite") {
      this.subscriptions.add(fromEvent(this.calendar.monthView.list.nativeElement, "keydown").subscribe((event) => {
        const {
          code,
          shiftKey
        } = event;
        if (code === Keys.Tab && !shiftKey) {
          event.preventDefault();
          if (!this.calendarValue && !this.cancelButton) {
            this.dateTabButton.focus();
          } else if (this.calendarValue) {
            this.acceptButton.focus();
          } else if (this.cancelButton) {
            this.cancelButtonElement.focus();
          }
        }
      }));
    }
  }
  setAriaActiveDescendant() {
    const focusedCellChangeEvent = this.calendar.type === "infinite" ? this.calendar.monthView.focusedCellChange : this.calendar.multiViewCalendar.viewList.focusedCellChange;
    this.ariaActiveDescendantSubscription = focusedCellChangeEvent.subscribe((id3) => this.renderer.setAttribute(this.dateInput?.inputElement, attributeNames.ariaActiveDescendant, id3));
  }
  closePopup() {
    if (!this.isOpen) {
      return;
    }
    this.ariaActiveDescendantSubscription.unsubscribe();
    if (this.dateInput) {
      this.renderer.removeAttribute(this.dateInput?.inputElement, attributeNames.ariaControls);
      this.renderer.removeAttribute(this.dateInput?.inputElement, attributeNames.ariaActiveDescendant);
    }
    this.popupRef.close();
    this.popupRef = null;
  }
  handleValueChange(value2) {
    if (isEqual(this.value, value2)) {
      if (this.incompleteDateValidation) {
        this.onControlChange(cloneDate(value2));
      }
      return;
    }
    this.value = cloneDate(value2);
    this.onControlChange(cloneDate(value2));
    this.valueChange.emit(cloneDate(value2));
  }
  /**
   * Indicates whether the focus target is part of this component.
   * Checks whether the focus target is inside the component or in the popup.
   */
  focusTargetInComponent(event) {
    if (!isPresent4(event)) {
      return false;
    }
    const relatedTarget = event.relatedTarget || document.activeElement;
    const focusInPopup = isPresent4(this.popupRef) && this.popupRef.popupElement.contains(relatedTarget);
    const focusInWrapper = this.wrapper.nativeElement.contains(relatedTarget);
    const isInsideActionSheet = this.actionSheet && (this.actionSheet.element.nativeElement.contains(event.target) || this.actionSheet.element.nativeElement.contains(relatedTarget));
    return focusInPopup || focusInWrapper || isInsideActionSheet;
  }
  setTimeSelectorMinMax(selectedDate) {
    const minDateSelected = isPresent4(selectedDate) && isPresent4(this.min) && isEqual(getDate(selectedDate), getDate(this.min));
    this.timeSelectorMin = cloneDate(minDateSelected ? this.min : MIN_TIME);
    const maxDateSelected = isPresent4(selectedDate) && isPresent4(this.max) && isEqual(getDate(selectedDate), getDate(this.max));
    this.timeSelectorMax = cloneDate(maxDateSelected ? this.max : MAX_TIME);
  }
  setCalendarValue(value2) {
    const isInCalendarRange = isPresent4(value2) && isInRange(value2, this.calendarMin, this.calendarMax);
    this.calendarValue = isInCalendarRange ? getDate(value2) : null;
  }
  /**
   * Runs a popup change detection if the popup is available.
   */
  detectPopupChanges() {
    if (!this.isOpen || this.isAdaptive) {
      return;
    }
    this.popupRef.popup.changeDetectorRef.detectChanges();
  }
  /**
   * Runs the provided function either in the Angular zone or in the current zone.
   * The execution zone depends on the predicate `runInZone` value that is passed.
   */
  run(runInZone, fn) {
    if (runInZone) {
      this.ngZone.run(() => fn());
    } else {
      fn();
    }
  }
  handleDateCompletenessChange() {
    this.cdr.markForCheck();
    this.ngZone.run(() => this.onValidatorChange());
  }
  setComponentClasses() {
    if (this.size) {
      this.renderer.addClass(this.wrapper.nativeElement, getSizeClass("input", this.size));
      this.renderer.addClass(this.toggleButton.nativeElement, getSizeClass("button", this.size));
    }
    if (this.rounded) {
      this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
    }
    if (this.fillMode) {
      this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass("input", this.fillMode));
      this.renderer.addClass(this.toggleButton.nativeElement, getFillModeClass("button", this.fillMode));
      this.renderer.addClass(this.toggleButton.nativeElement, `k-button-${this.fillMode}-base`);
    }
  }
  static ɵfac = function DateTimePickerComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DateTimePickerComponent)(ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PickerService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(DisabledDatesService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(AdaptiveService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DateTimePickerComponent,
    selectors: [["kendo-datetimepicker"]],
    contentQueries: function DateTimePickerComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, CellTemplateDirective, 5)(dirIndex, MonthCellTemplateDirective, 5)(dirIndex, YearCellTemplateDirective, 5)(dirIndex, DecadeCellTemplateDirective, 5)(dirIndex, CenturyCellTemplateDirective, 5)(dirIndex, WeekNumberCellTemplateDirective, 5)(dirIndex, HeaderTitleTemplateDirective, 5)(dirIndex, HeaderTemplateDirective, 5)(dirIndex, FooterTemplateDirective2, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.cellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.monthCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.yearCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.decadeCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.centuryCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.weekNumberTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTitleTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
      }
    },
    viewQuery: function DateTimePickerComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c16, 7)(_c14, 7, ViewContainerRef)(_c15, 7, TemplateRef)(_c17, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.toggleButton = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.container = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.actionSheet = _t.first);
      }
    },
    hostVars: 8,
    hostBindings: function DateTimePickerComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-datetimepicker", ctx.hostClasses)("k-input", ctx.hostClasses)("k-disabled", ctx.disabledClass)("k-readonly", ctx.readonly);
      }
    },
    inputs: {
      focusableId: "focusableId",
      weekDaysFormat: "weekDaysFormat",
      showOtherMonthDays: "showOtherMonthDays",
      value: "value",
      format: "format",
      twoDigitYearMax: "twoDigitYearMax",
      tabindex: "tabindex",
      disabledDates: "disabledDates",
      popupSettings: "popupSettings",
      adaptiveTitle: "adaptiveTitle",
      adaptiveSubtitle: "adaptiveSubtitle",
      disabled: "disabled",
      readonly: "readonly",
      readOnlyInput: "readOnlyInput",
      cancelButton: "cancelButton",
      formatPlaceholder: "formatPlaceholder",
      placeholder: "placeholder",
      steps: "steps",
      focusedDate: "focusedDate",
      calendarType: "calendarType",
      animateCalendarNavigation: "animateCalendarNavigation",
      weekNumber: "weekNumber",
      min: "min",
      max: "max",
      rangeValidation: "rangeValidation",
      disabledDatesValidation: "disabledDatesValidation",
      incompleteDateValidation: "incompleteDateValidation",
      autoCorrectParts: "autoCorrectParts",
      autoSwitchParts: "autoSwitchParts",
      autoSwitchKeys: "autoSwitchKeys",
      enableMouseWheel: "enableMouseWheel",
      allowCaretMode: "allowCaretMode",
      clearButton: "clearButton",
      autoFill: "autoFill",
      adaptiveMode: "adaptiveMode",
      inputAttributes: "inputAttributes",
      defaultTab: "defaultTab",
      size: "size",
      rounded: "rounded",
      fillMode: "fillMode",
      headerTemplateRef: [0, "headerTemplate", "headerTemplateRef"],
      footerTemplateRef: [0, "footerTemplate", "footerTemplateRef"],
      footer: "footer"
    },
    outputs: {
      valueChange: "valueChange",
      open: "open",
      close: "close",
      onFocus: "focus",
      onBlur: "blur",
      escape: "escape"
    },
    exportAs: ["kendo-datetimepicker"],
    features: [ɵɵProvidersFeature([PickerService, LocalizationService, DisabledDatesService, {
      provide: L10N_PREFIX,
      useValue: "kendo.datetimepicker"
    }, {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _DateTimePickerComponent),
      multi: true
    }, {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => _DateTimePickerComponent),
      multi: true
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _DateTimePickerComponent)
    }, {
      provide: MultiTabStop,
      useExisting: forwardRef(() => _DateTimePickerComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
    decls: 17,
    vars: 51,
    consts: () => {
      let i18n_38;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_38 = goog.getMsg("Date");
        i18n_38 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_38;
      } else {
        i18n_38 = $localize`:kendo.datetimepicker.dateTab|The Date tab text in the datetimepicker popup header:Date`;
      }
      let i18n_39;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_39 = goog.getMsg("Date tab");
        i18n_39 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_39;
      } else {
        i18n_39 = $localize`:kendo.datetimepicker.dateTabLabel|The label for the Date tab in the datetimepicker popup header:Date tab`;
      }
      let i18n_40;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_40 = goog.getMsg("Time");
        i18n_40 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_40;
      } else {
        i18n_40 = $localize`:kendo.datetimepicker.timeTab|The Time tab text in the datetimepicker popup header:Time`;
      }
      let i18n_41;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_41 = goog.getMsg("Time tab");
        i18n_41 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_41;
      } else {
        i18n_41 = $localize`:kendo.datetimepicker.timeTabLabel|The label for the Time tab in the datetimepicker popup header:Time tab`;
      }
      let i18n_42;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_42 = goog.getMsg("Toggle popup");
        i18n_42 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_42;
      } else {
        i18n_42 = $localize`:kendo.datetimepicker.toggle|The title of the toggle button in the datetimepicker component:Toggle popup`;
      }
      let i18n_43;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_43 = goog.getMsg("Set");
        i18n_43 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_43;
      } else {
        i18n_43 = $localize`:kendo.datetimepicker.accept|The Accept button text in the datetimepicker component:Set`;
      }
      let i18n_44;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_44 = goog.getMsg("Set");
        i18n_44 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_44;
      } else {
        i18n_44 = $localize`:kendo.datetimepicker.acceptLabel|The label for the Accept button in the datetimepicker component:Set`;
      }
      let i18n_45;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_45 = goog.getMsg("Cancel");
        i18n_45 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_45;
      } else {
        i18n_45 = $localize`:kendo.datetimepicker.cancel|The Cancel button text in the datetimepicker component:Cancel`;
      }
      let i18n_46;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_46 = goog.getMsg("Cancel");
        i18n_46 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_46;
      } else {
        i18n_46 = $localize`:kendo.datetimepicker.cancelLabel|The label for the Cancel button in the datetimepicker component:Cancel`;
      }
      let i18n_47;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_47 = goog.getMsg("NOW");
        i18n_47 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_47;
      } else {
        i18n_47 = $localize`:kendo.datetimepicker.now|The Now button text in the timepicker component:NOW`;
      }
      let i18n_48;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_48 = goog.getMsg("Select now");
        i18n_48 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_48;
      } else {
        i18n_48 = $localize`:kendo.datetimepicker.nowLabel|The label for the Now button in the timepicker component:Select now`;
      }
      let i18n_49;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_49 = goog.getMsg("Today");
        i18n_49 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_49;
      } else {
        i18n_49 = $localize`:kendo.datetimepicker.today|The label for the today button in the calendar header:Today`;
      }
      let i18n_50;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_50 = goog.getMsg("Navigate to previous view");
        i18n_50 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_50;
      } else {
        i18n_50 = $localize`:kendo.datetimepicker.prevButtonTitle|The title of the previous button in the Classic calendar:Navigate to previous view`;
      }
      let i18n_51;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_51 = goog.getMsg("Navigate to next view");
        i18n_51 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_51;
      } else {
        i18n_51 = $localize`:kendo.datetimepicker.nextButtonTitle|The title of the next button in the Classic calendar:Navigate to next view`;
      }
      let i18n_52;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_52 = goog.getMsg("Navigate to parent view");
        i18n_52 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_52;
      } else {
        i18n_52 = $localize`:kendo.datetimepicker.parentViewButtonTitle|The title of the parent view button in the calendar header:Navigate to parent view`;
      }
      let i18n_53;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_53 = goog.getMsg("Hour");
        i18n_53 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_53;
      } else {
        i18n_53 = $localize`:kendo.datetimepicker.hour|The label for the hour part in the timepicker component:Hour`;
      }
      let i18n_54;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_54 = goog.getMsg("Minute");
        i18n_54 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_54;
      } else {
        i18n_54 = $localize`:kendo.datetimepicker.minute|The label for the minute part in the timepicker component:Minute`;
      }
      let i18n_55;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_55 = goog.getMsg("Second");
        i18n_55 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_55;
      } else {
        i18n_55 = $localize`:kendo.datetimepicker.second|The label for the second part in the timepicker component:Second`;
      }
      let i18n_56;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_56 = goog.getMsg("Millisecond");
        i18n_56 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_56;
      } else {
        i18n_56 = $localize`:kendo.datetimepicker.millisecond|The label for the millisecond part in the timepicker component:Millisecond`;
      }
      let i18n_57;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_57 = goog.getMsg("Dayperiod");
        i18n_57 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_57;
      } else {
        i18n_57 = $localize`:kendo.datetimepicker.dayperiod|The label for the dayperiod part in the timepicker component:Dayperiod`;
      }
      let i18n_58;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_58 = goog.getMsg("clear");
        i18n_58 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_58;
      } else {
        i18n_58 = $localize`:kendo.datetimepicker.clearTitle|The title of the clear button:clear`;
      }
      let i18n_59;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_59 = goog.getMsg("Close");
        i18n_59 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_59;
      } else {
        i18n_59 = $localize`:kendo.datetimepicker.adaptiveCloseButtonTitle|The title of the Close button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode:Close`;
      }
      return [["toggleButton", ""], ["container", ""], ["popupTemplate", ""], ["actionSheet", ""], ["dateTimeTemplate", ""], ["dateTimeSelector", ""], ["calendar", ""], ["kendoDateTimePickerLocalizedMessages", "", "dateTab", i18n_38, "dateTabLabel", i18n_39, "timeTab", i18n_40, "timeTabLabel", i18n_41, "toggle", i18n_42, "accept", i18n_43, "acceptLabel", i18n_44, "cancel", i18n_45, "cancelLabel", i18n_46, "now", i18n_47, "nowLabel", i18n_48, "today", i18n_49, "prevButtonTitle", i18n_50, "nextButtonTitle", i18n_51, "parentViewButtonTitle", i18n_52, "hour", i18n_53, "minute", i18n_54, "second", i18n_55, "millisecond", i18n_56, "dayperiod", i18n_57, "clearTitle", i18n_58, "adaptiveCloseButtonTitle", i18n_59], ["pickerType", "datetimepicker", "hasPopup", "dialog", "fillMode", "none", "rounded", "none", "size", "none", 3, "valueChange", "click", "value", "format", "clearButton", "twoDigitYearMax", "min", "max", "incompleteDateValidation", "autoCorrectParts", "autoSwitchParts", "autoSwitchKeys", "enableMouseWheel", "allowCaretMode", "autoFill", "formatPlaceholder", "placeholder", "disabled", "focusableId", "readonly", "role", "ariaReadOnly", "steps", "tabindex", "isRequired", "title", "inputAttributes", "isPopupOpen", "kendoEventsOutsideAngular", "scope"], [3, "clearTitle"], ["type", "button", 1, "k-input-button", "k-button", "k-icon-button", 3, "tabindex", "kendoEventsOutsideAngular", "scope"], ["name", "calendar", "innerCssClass", "k-button-icon", 3, "svgIcon"], ["name", "clock", "innerCssClass", "k-button-icon", 3, "svgIcon"], [3, "overlayClick", "collapse", "titleId", "cssClass", "cssStyle"], ["kendoActionSheetTemplate", ""], [4, "ngTemplateOutlet"], [3, "resize"], [1, "k-actionsheet-titlebar"], [1, "k-actionsheet-titlebar-group"], [1, "k-actionsheet-title"], [1, "k-text-center"], [1, "k-actionsheet-subtitle", "k-text-center"], [1, "k-actionsheet-actions"], ["kendoButton", "", "type", "button", "icon", "check", "fillMode", "flat", "themeColor", "primary", "size", "large", "innerCssClass", "k-button-icon", 3, "click", "svgIcon", "tabIndex"], [1, "k-actionsheet-content"], [1, "k-actions", "k-actions-stretched", "k-actions-horizontal", "k-actionsheet-footer"], ["kendoButton", "", "type", "button", "size", "large", 1, "k-time-cancel"], ["kendoButton", "", "type", "button", "size", "large", "themeColor", "primary", 1, "k-time-accept", 3, "click", "disabled"], ["kendoButton", "", "type", "button", "size", "large", 1, "k-time-cancel", 3, "click"], [3, "ngClass", "kendoEventsOutsideAngular", "scope"], [1, "k-datetime-buttongroup", 3, "kendoEventsOutsideAngular", "scope"], ["role", "group", 1, "k-button-group", "k-button-group-solid", "k-button-group-stretched"], ["kendoButton", "", "type", "button", 1, "k-group-start", 3, "size", "kendoEventsOutsideAngular", "scope"], ["kendoButton", "", "type", "button", 1, "k-group-end", 3, "size", "kendoEventsOutsideAngular", "scope"], [1, "k-datetime-selector", 3, "kendoEventsOutsideAngular"], [1, "k-datetime-calendar-wrap"], [3, "valueChange", "focusedDate", "size", "value", "type", "min", "max", "weekDaysFormat", "weekNumber", "navigation", "animateNavigation", "showOtherMonthDays", "cellTemplate", "monthCellTemplate", "yearCellTemplate", "decadeCellTemplate", "centuryCellTemplate", "weekNumberTemplate", "headerTitleTemplate", "headerTemplate", "footerTemplate", "footer", "disabled", "disabledDates"], [3, "today", "prevButtonTitle", "nextButtonTitle", "parentViewButtonTitle"], [1, "k-datetime-time-wrap"], [3, "tabOutLastPart", "tabOutFirstPart", "tabOutNow", "ngClass", "value", "format", "min", "max", "setButton", "cancelButton", "steps", "disabled", "isAdaptiveEnabled", "isDateTimePicker"], [3, "acceptLabel", "accept", "cancelLabel", "cancel", "nowLabel", "now", "hour", "minute", "second", "millisecond", "dayperiod"], [1, "k-datetime-footer", "k-actions", "k-actions-stretched", "k-actions-horizontal", 3, "kendoEventsOutsideAngular", "scope"], ["kendoButton", "", "type", "button", "themeColor", "primary", 1, "k-time-accept", 3, "disabled", "kendoEventsOutsideAngular", "scope"], ["kendoButton", "", "type", "button", 1, "k-time-cancel", 3, "kendoEventsOutsideAngular", "scope"]];
    },
    template: function DateTimePickerComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainer(0, 7);
        ɵɵelementStart(1, "kendo-dateinput", 8);
        ɵɵlistener("valueChange", function DateTimePickerComponent_Template_kendo_dateinput_valueChange_1_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleInputValueChange($event));
        })("click", function DateTimePickerComponent_Template_kendo_dateinput_click_1_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleDateInputClick());
        });
        ɵɵelement(2, "kendo-dateinput-messages", 9);
        ɵɵelementEnd();
        ɵɵelementStart(3, "button", 10, 0);
        ɵɵconditionalCreate(5, DateTimePickerComponent_Conditional_5_Template, 1, 1, "kendo-icon-wrapper", 11);
        ɵɵconditionalCreate(6, DateTimePickerComponent_Conditional_6_Template, 1, 1, "kendo-icon-wrapper", 12);
        ɵɵelementEnd();
        ɵɵelementContainer(7, null, 1);
        ɵɵtemplate(9, DateTimePickerComponent_ng_template_9_Template, 1, 1, "ng-template", null, 2, ɵɵtemplateRefExtractor);
        ɵɵconditionalCreate(11, DateTimePickerComponent_Conditional_11_Template, 1, 0, "kendo-resize-sensor");
        ɵɵelementStart(12, "kendo-actionsheet", 13, 3);
        ɵɵlistener("overlayClick", function DateTimePickerComponent_Template_kendo_actionsheet_overlayClick_12_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.toggleActionSheet(false));
        })("collapse", function DateTimePickerComponent_Template_kendo_actionsheet_collapse_12_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleActionSheetCollapse());
        });
        ɵɵtemplate(14, DateTimePickerComponent_ng_template_14_Template, 13, 11, "ng-template", 14);
        ɵɵelementEnd();
        ɵɵtemplate(15, DateTimePickerComponent_ng_template_15_Template, 17, 98, "ng-template", null, 4, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("value", ctx.value)("format", ctx.format)("clearButton", ctx.clearButton)("twoDigitYearMax", ctx.twoDigitYearMax)("min", ctx.min)("max", ctx.max)("incompleteDateValidation", ctx.incompleteDateValidation)("autoCorrectParts", ctx.autoCorrectParts)("autoSwitchParts", ctx.autoSwitchParts)("autoSwitchKeys", ctx.autoSwitchKeys)("enableMouseWheel", ctx.enableMouseWheel)("allowCaretMode", ctx.allowCaretMode)("autoFill", ctx.autoFill)("formatPlaceholder", ctx.formatPlaceholder)("placeholder", ctx.placeholder)("disabled", ctx.disabled)("focusableId", ctx.focusableId)("readonly", ctx.readonly || ctx.readOnlyInput)("role", "combobox")("ariaReadOnly", ctx.readonly)("steps", ctx.steps)("tabindex", ctx.tabindex)("isRequired", ctx.isControlRequired)("title", ctx.adaptiveTitle)("inputAttributes", ctx.inputAttributes)("isPopupOpen", ctx.isOpen)("kendoEventsOutsideAngular", ɵɵpureFunction1(41, _c21, ctx.handleKeyDown))("scope", ctx);
        ɵɵadvance();
        ɵɵproperty("clearTitle", ctx.localization.get("clearTitle"));
        ɵɵadvance();
        ɵɵproperty("tabindex", -1)("kendoEventsOutsideAngular", ɵɵpureFunction2(43, _c29, ctx.preventMouseDown, ctx.handleIconClick))("scope", ctx);
        ɵɵattribute("title", ctx.localization.get("toggle"))("aria-label", ctx.localization.get("toggle"))("disabled", ctx.disabled ? "" : null);
        ɵɵadvance(2);
        ɵɵconditional(ctx.activeTab === "date" ? 5 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.activeTab === "time" ? 6 : -1);
        ɵɵadvance(5);
        ɵɵconditional(ctx.isAdaptiveModeEnabled ? 11 : -1);
        ɵɵadvance();
        ɵɵproperty("titleId", ctx.calendar == null ? null : ctx.calendar.headerId)("cssClass", ɵɵpureFunction2(46, _c19, ctx.windowSize === "small", ctx.windowSize === "medium"))("cssStyle", ɵɵpureFunction1(49, _c20, ctx.windowSize === "small" ? "100vh" : "60vh"));
      }
    },
    dependencies: [LocalizedMessagesDirective, DateInputComponent, EventsOutsideAngularDirective, DateInputCustomMessagesComponent, IconWrapperComponent, NgTemplateOutlet, ResizeSensorComponent, ActionSheetComponent, ActionSheetTemplateDirective, ButtonComponent, NgClass, CalendarComponent, CalendarCustomMessagesComponent, TimeSelectorComponent, TimeSelectorCustomMessagesComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateTimePickerComponent, [{
    type: Component,
    args: [{
      selector: "kendo-datetimepicker",
      exportAs: "kendo-datetimepicker",
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [PickerService, LocalizationService, DisabledDatesService, {
        provide: L10N_PREFIX,
        useValue: "kendo.datetimepicker"
      }, {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => DateTimePickerComponent),
        multi: true
      }, {
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => DateTimePickerComponent),
        multi: true
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => DateTimePickerComponent)
      }, {
        provide: MultiTabStop,
        useExisting: forwardRef(() => DateTimePickerComponent)
      }],
      template: `
        <ng-container
          kendoDateTimePickerLocalizedMessages
        
          i18n-dateTab="kendo.datetimepicker.dateTab|The Date tab text in the datetimepicker popup header"
          dateTab="Date"
        
          i18n-dateTabLabel="kendo.datetimepicker.dateTabLabel|The label for the Date tab in the datetimepicker popup header"
          dateTabLabel="Date tab"
        
          i18n-timeTab="kendo.datetimepicker.timeTab|The Time tab text in the datetimepicker popup header"
          timeTab="Time"
        
          i18n-timeTabLabel="kendo.datetimepicker.timeTabLabel|The label for the Time tab in the datetimepicker popup header"
          timeTabLabel="Time tab"
        
          i18n-toggle="kendo.datetimepicker.toggle|The title of the toggle button in the datetimepicker component"
          toggle="Toggle popup"
        
          i18n-accept="kendo.datetimepicker.accept|The Accept button text in the datetimepicker component"
          accept="Set"
        
          i18n-acceptLabel="kendo.datetimepicker.acceptLabel|The label for the Accept button in the datetimepicker component"
          acceptLabel="Set"
        
          i18n-cancel="kendo.datetimepicker.cancel|The Cancel button text in the datetimepicker component"
          cancel="Cancel"
        
          i18n-cancelLabel="kendo.datetimepicker.cancelLabel|The label for the Cancel button in the datetimepicker component"
          cancelLabel="Cancel"
        
          i18n-now="kendo.datetimepicker.now|The Now button text in the timepicker component"
          now="NOW"
        
          i18n-nowLabel="kendo.datetimepicker.nowLabel|The label for the Now button in the timepicker component"
          nowLabel="Select now"
        
          i18n-today="kendo.datetimepicker.today|The label for the today button in the calendar header"
          today="Today"
        
          i18n-prevButtonTitle="kendo.datetimepicker.prevButtonTitle|The title of the previous button in the Classic calendar"
          prevButtonTitle="Navigate to previous view"
        
          i18n-nextButtonTitle="kendo.datetimepicker.nextButtonTitle|The title of the next button in the Classic calendar"
          nextButtonTitle="Navigate to next view"
        
          i18n-parentViewButtonTitle="kendo.datetimepicker.parentViewButtonTitle|The title of the parent view button in the calendar header"
          parentViewButtonTitle="Navigate to parent view"
        
          i18n-hour="kendo.datetimepicker.hour|The label for the hour part in the timepicker component"
          hour="Hour"
        
          i18n-minute="kendo.datetimepicker.minute|The label for the minute part in the timepicker component"
          minute="Minute"
        
          i18n-second="kendo.datetimepicker.second|The label for the second part in the timepicker component"
          second="Second"
        
          i18n-millisecond="kendo.datetimepicker.millisecond|The label for the millisecond part in the timepicker component"
          millisecond="Millisecond"
        
          i18n-dayperiod="kendo.datetimepicker.dayperiod|The label for the dayperiod part in the timepicker component"
          dayperiod="Dayperiod"
        
          i18n-clearTitle="kendo.datetimepicker.clearTitle|The title of the clear button"
          clearTitle="clear"
        
          i18n-adaptiveCloseButtonTitle="kendo.datetimepicker.adaptiveCloseButtonTitle|The title of the Close button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode"
          adaptiveCloseButtonTitle="Close"
          >
        </ng-container>
        
        <kendo-dateinput
          [value]="value"
          [format]="format"
          [clearButton]="clearButton"
          [twoDigitYearMax]="twoDigitYearMax"
          [min]="min"
          [max]="max"
          [incompleteDateValidation]="incompleteDateValidation"
          [autoCorrectParts]="autoCorrectParts"
          [autoSwitchParts]="autoSwitchParts"
          [autoSwitchKeys]="autoSwitchKeys"
          [enableMouseWheel]="enableMouseWheel"
          [allowCaretMode]="allowCaretMode"
          [autoFill]="autoFill"
          [formatPlaceholder]="formatPlaceholder"
          [placeholder]="placeholder"
          [disabled]="disabled"
          [focusableId]="focusableId"
          [readonly]="readonly || readOnlyInput"
          [role]="'combobox'"
          [ariaReadOnly]="readonly"
          [steps]="steps"
          [tabindex]="tabindex"
          [isRequired]="isControlRequired"
          [title]="adaptiveTitle"
          pickerType="datetimepicker"
          hasPopup="dialog"
          [inputAttributes]="inputAttributes"
          [isPopupOpen]="isOpen"
          (valueChange)="handleInputValueChange($event)"
            [kendoEventsOutsideAngular]="{
                keydown: handleKeyDown
            }"
          [scope]="this"
          fillMode="none"
          rounded="none"
          size="none"
          (click)="handleDateInputClick()"
          >
          <kendo-dateinput-messages
            [clearTitle]="localization.get('clearTitle')"
            >
          </kendo-dateinput-messages>
        </kendo-dateinput>
        <button
          #toggleButton
          type="button"
          class="k-input-button k-button k-icon-button"
          [tabindex]="-1"
          [attr.title]="localization.get('toggle')"
          [attr.aria-label]="localization.get('toggle')"
          [attr.disabled]="disabled ? '' : null"
            [kendoEventsOutsideAngular]="{
                mousedown: preventMouseDown,
                click: handleIconClick
            }"
          [scope]="this"
          >
          @if (activeTab === 'date') {
            <kendo-icon-wrapper
              name="calendar"
              [svgIcon]="calendarIcon"
              innerCssClass="k-button-icon"
              >
            </kendo-icon-wrapper>
          }
          @if (activeTab === 'time') {
            <kendo-icon-wrapper
              name="clock"
              [svgIcon]="clockIcon"
              innerCssClass="k-button-icon"
              >
            </kendo-icon-wrapper>
          }
        </button>
        
        <ng-container #container></ng-container>
        
        <ng-template #popupTemplate>
          <ng-container *ngTemplateOutlet="dateTimeTemplate"></ng-container>
        </ng-template>
        
        @if (isAdaptiveModeEnabled) {
          <kendo-resize-sensor (resize)="onResize()"></kendo-resize-sensor>
        }
        
        <kendo-actionsheet
          #actionSheet
          (overlayClick)="toggleActionSheet(false)"
          (collapse)="handleActionSheetCollapse()"
          [titleId]="calendar?.headerId"
            [cssClass]="{
                'k-adaptive-actionsheet': true,
                'k-actionsheet-fullscreen': windowSize === 'small',
                'k-actionsheet-bottom': windowSize === 'medium'
            }"
            [cssStyle]="{
                height: windowSize === 'small' ? '100vh' : '60vh'
            }"
          >
          <ng-template kendoActionSheetTemplate>
            <div class="k-actionsheet-titlebar">
              <div class="k-actionsheet-titlebar-group">
                <div class="k-actionsheet-title">
                  @if (adaptiveTitle) {
                    <div class="k-text-center">{{ adaptiveTitle }}</div>
                  }
                  @if (adaptiveSubtitle) {
                    <div class="k-actionsheet-subtitle k-text-center">{{ adaptiveSubtitle }}</div>
                  }
                </div>
                <div class="k-actionsheet-actions">
                  <button
                    kendoButton
                    type="button"
                    icon="check"
                    [attr.title]="localization.get('adaptiveCloseButtonTitle')"
                    [svgIcon]="checkIcon"
                    fillMode="flat"
                    themeColor="primary"
                    [tabIndex]="-1"
                    size="large"
                    innerCssClass="k-button-icon"
                    (click)="toggleActionSheet(false)">
                  </button>
                </div>
              </div>
            </div>
            <div class="k-actionsheet-content">
              <ng-container *ngTemplateOutlet="dateTimeTemplate"></ng-container>
            </div>
            <div class="k-actions k-actions-stretched k-actions-horizontal k-actionsheet-footer">
              @if (cancelButton) {
                <button kendoButton
                  class="k-time-cancel"
                  type="button"
                  (click)="handleCancel()"
                  size="large"
                  [attr.title]="localization.get('cancelLabel')"
                  [attr.aria-label]="localization.get('cancelLabel')"
                  >
                  {{localization.get('cancel')}}
                </button>
              }
        
              <button kendoButton
                type="button"
                class="k-time-accept"
                (click)="handleAccept()"
                [disabled]="!calendarValue"
                size="large"
                themeColor="primary"
                [attr.title]="localization.get('acceptLabel')"
                [attr.aria-label]="localization.get('acceptLabel')"
                >
                {{localization.get('accept')}}
              </button>
            </div>
          </ng-template>
        </kendo-actionsheet>
        
        <ng-template #dateTimeTemplate>
          <div
            class="k-datetime-wrap k-{{activeTab}}-tab"
                [ngClass]="{
                    'k-datetime-wrap-md': !isAdaptive,
                    'k-datetime-wrap-lg': isAdaptive
                }"
                [kendoEventsOutsideAngular]="{
                    mousedown: preventMouseDown,
                    keydown: handleKeyDown
                }"
            [scope]="this"
            >
            <div class="k-datetime-buttongroup"
                    [kendoEventsOutsideAngular]="{
                        focusin: handleFocus,
                        focusout: handleBlur
                    }"
              [scope]="this"
              >
              <div class="k-button-group k-button-group-solid k-button-group-stretched" role="group">
                <button kendoButton
                  type="button"
                  class="k-group-start"
                  [size]="isAdaptive ? 'large' : size"
                  [class.k-selected]="activeTab === 'date'"
                  [attr.aria-pressed]="activeTab === 'date' ? 'true' : 'false'"
                  [attr.title]="localization.get('dateTabLabel')"
                  [attr.aria-label]="localization.get('dateTabLabel')"
                            [kendoEventsOutsideAngular]="{
                                click: changeActiveTab.bind(this, 'date'),
                                'keydown.shift.tab': handleTab
                            }"
                  [scope]="this"
                  >
                  {{localization.get('dateTab')}}
                </button>
                <button kendoButton
                  type="button"
                  class="k-group-end"
                  [size]="isAdaptive ? 'large' : size"
                  [class.k-selected]="activeTab === 'time'"
                  [attr.aria-pressed]="activeTab === 'time' ? 'true' : 'false'"
                  [attr.title]="localization.get('timeTabLabel')"
                  [attr.aria-label]="localization.get('timeTabLabel')"
                            [kendoEventsOutsideAngular]="{
                                click: changeActiveTab.bind(this, 'time'),
                                'keydown.tab': handleTab
                            }"
                  [scope]="this"
                  >
                  {{localization.get('timeTab')}}
                </button>
              </div>
            </div>
            <div
              #dateTimeSelector
              class="k-datetime-selector"
              [style.transition]="tabSwitchTransition"
                    [kendoEventsOutsideAngular]="{
                        transitionend: handleTabChangeTransitionEnd.bind(this, dateTimeSelector)
                    }"
              >
              <div class="k-datetime-calendar-wrap">
                <kendo-calendar
                  #calendar
                  [focusedDate]="focusedDate"
                  [size]="isAdaptive ? 'large' : size"
                  [(value)]="calendarValue"
                  [type]="calendarType"
                  [min]="calendarMin"
                  [max]="calendarMax"
                  [weekDaysFormat]="weekDaysFormat"
                  [weekNumber]="weekNumber"
                  [navigation]="false"
                  [animateNavigation]="animateCalendarNavigation"
                  [showOtherMonthDays]="showOtherMonthDays"
                  [cellTemplate]="cellTemplate"
                  [monthCellTemplate]="monthCellTemplate"
                  [yearCellTemplate]="yearCellTemplate"
                  [decadeCellTemplate]="decadeCellTemplate"
                  [centuryCellTemplate]="centuryCellTemplate"
                  [weekNumberTemplate]="weekNumberTemplate"
                  [headerTitleTemplate]="headerTitleTemplate"
                  [headerTemplate]="headerTemplate"
                  [footerTemplate]="footerTemplate"
                  [footer]="footer"
                  [disabled]="disableCalendar"
                  [disabledDates]="disabledDates"
                  (valueChange)="handleCalendarValueChange()"
                  >
                  <kendo-calendar-messages
                    [today]="localization.get('today')"
                    [prevButtonTitle]="localization.get('prevButtonTitle')"
                    [nextButtonTitle]="localization.get('nextButtonTitle')"
                    [parentViewButtonTitle]="localization.get('parentViewButtonTitle')"
                    >
                  </kendo-calendar-messages>
                </kendo-calendar>
              </div>
              <div class="k-datetime-time-wrap">
                <kendo-timeselector
                  [ngClass]="{'k-timeselector-lg': isAdaptive}"
                  [value]="value"
                  [format]="timeSelectorFormat"
                  [min]="timeSelectorMin"
                  [max]="timeSelectorMax"
                  [setButton]="false"
                  [cancelButton]="false"
                  [steps]="steps"
                  [disabled]="disableTimeSelector"
                  [isAdaptiveEnabled]="isAdaptiveModeEnabled"
                  [isDateTimePicker]="true"
                  (tabOutLastPart)="onTabOutLastPart()"
                  (tabOutFirstPart)="onTabOutFirstPart()"
                  (tabOutNow)="onTabOutNow()"
                  >
                  <kendo-timeselector-messages
                    [acceptLabel]="localization.get('acceptLabel')"
                    [accept]="localization.get('accept')"
                    [cancelLabel]="localization.get('cancelLabel')"
                    [cancel]="localization.get('cancel')"
                    [nowLabel]="localization.get('nowLabel')"
                    [now]="localization.get('now')"
                    [hour]="localization.get('hour')"
                    [minute]="localization.get('minute')"
                    [second]="localization.get('second')"
                    [millisecond]="localization.get('millisecond')"
                    [dayperiod]="localization.get('dayperiod')"
                    >
                  </kendo-timeselector-messages>
                </kendo-timeselector>
              </div>
            </div>
            @if (!isAdaptive) {
              <div
                class="k-datetime-footer k-actions k-actions-stretched k-actions-horizontal"
                    [kendoEventsOutsideAngular]="{
                        focusin: handleFocus,
                        focusout: handleBlur
                    }"
                [scope]="this"
                >
                <button kendoButton
                  type="button"
                  class="k-time-accept"
                  themeColor="primary"
                  [attr.title]="localization.get('acceptLabel')"
                  [attr.aria-label]="localization.get('acceptLabel')"
                  [disabled]="!calendarValue"
                        [kendoEventsOutsideAngular]="{
                            click: handleAccept,
                            'keydown.tab': handleTab,
                            'keydown.shift.tab': handleTab
                        }"
                  [scope]="this"
                  >
                  {{localization.get('accept')}}
                </button>
                @if (cancelButton) {
                  <button kendoButton
                    type="button"
                    class="k-time-cancel"
                    [attr.title]="localization.get('cancelLabel')"
                    [attr.aria-label]="localization.get('cancelLabel')"
                        [kendoEventsOutsideAngular]="{
                            click: handleCancel,
                            'keydown.tab': handleTab,
                            'keydown.shift.tab': handleTab
                        }"
                    [scope]="this"
                    >
                    {{localization.get('cancel')}}
                  </button>
                }
              </div>
            }
          </div>
        </ng-template>
        `,
      standalone: true,
      imports: [LocalizedMessagesDirective, DateInputComponent, EventsOutsideAngularDirective, DateInputCustomMessagesComponent, IconWrapperComponent, NgTemplateOutlet, ResizeSensorComponent, ActionSheetComponent, ActionSheetTemplateDirective, ButtonComponent, NgClass, CalendarComponent, CalendarCustomMessagesComponent, TimeSelectorComponent, TimeSelectorCustomMessagesComponent]
    }]
  }], () => [{
    type: PopupService
  }, {
    type: IntlService
  }, {
    type: ChangeDetectorRef
  }, {
    type: PickerService
  }, {
    type: NgZone
  }, {
    type: ElementRef
  }, {
    type: LocalizationService
  }, {
    type: DisabledDatesService
  }, {
    type: Renderer2
  }, {
    type: Injector
  }, {
    type: AdaptiveService
  }], {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-datetimepicker"]
    }, {
      type: HostBinding,
      args: ["class.k-input"]
    }],
    disabledClass: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    toggleButton: [{
      type: ViewChild,
      args: ["toggleButton", {
        static: true
      }]
    }],
    focusableId: [{
      type: Input
    }],
    weekDaysFormat: [{
      type: Input
    }],
    showOtherMonthDays: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    twoDigitYearMax: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    disabledDates: [{
      type: Input
    }],
    popupSettings: [{
      type: Input
    }],
    adaptiveTitle: [{
      type: Input
    }],
    adaptiveSubtitle: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-readonly"]
    }],
    readOnlyInput: [{
      type: Input
    }],
    cancelButton: [{
      type: Input
    }],
    formatPlaceholder: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    steps: [{
      type: Input
    }],
    focusedDate: [{
      type: Input
    }],
    calendarType: [{
      type: Input
    }],
    animateCalendarNavigation: [{
      type: Input
    }],
    weekNumber: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    rangeValidation: [{
      type: Input
    }],
    disabledDatesValidation: [{
      type: Input
    }],
    incompleteDateValidation: [{
      type: Input
    }],
    autoCorrectParts: [{
      type: Input
    }],
    autoSwitchParts: [{
      type: Input
    }],
    autoSwitchKeys: [{
      type: Input
    }],
    enableMouseWheel: [{
      type: Input
    }],
    allowCaretMode: [{
      type: Input
    }],
    clearButton: [{
      type: Input
    }],
    autoFill: [{
      type: Input
    }],
    adaptiveMode: [{
      type: Input
    }],
    inputAttributes: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    open: [{
      type: Output
    }],
    close: [{
      type: Output
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    escape: [{
      type: Output
    }],
    defaultTab: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }],
    fillMode: [{
      type: Input
    }],
    cellTemplate: [{
      type: ContentChild,
      args: [CellTemplateDirective, {
        static: false
      }]
    }],
    monthCellTemplate: [{
      type: ContentChild,
      args: [MonthCellTemplateDirective, {
        static: false
      }]
    }],
    yearCellTemplate: [{
      type: ContentChild,
      args: [YearCellTemplateDirective, {
        static: false
      }]
    }],
    decadeCellTemplate: [{
      type: ContentChild,
      args: [DecadeCellTemplateDirective, {
        static: false
      }]
    }],
    centuryCellTemplate: [{
      type: ContentChild,
      args: [CenturyCellTemplateDirective, {
        static: false
      }]
    }],
    weekNumberTemplate: [{
      type: ContentChild,
      args: [WeekNumberCellTemplateDirective, {
        static: false
      }]
    }],
    headerTitleTemplate: [{
      type: ContentChild,
      args: [HeaderTitleTemplateDirective, {
        static: false
      }]
    }],
    headerTemplate: [{
      type: ContentChild,
      args: [HeaderTemplateDirective]
    }],
    headerTemplateRef: [{
      type: Input,
      args: ["headerTemplate"]
    }],
    footerTemplate: [{
      type: ContentChild,
      args: [FooterTemplateDirective2]
    }],
    footerTemplateRef: [{
      type: Input,
      args: ["footerTemplate"]
    }],
    footer: [{
      type: Input
    }],
    container: [{
      type: ViewChild,
      args: ["container", {
        read: ViewContainerRef,
        static: true
      }]
    }],
    popupTemplate: [{
      type: ViewChild,
      args: ["popupTemplate", {
        read: TemplateRef,
        static: true
      }]
    }],
    actionSheet: [{
      type: ViewChild,
      args: ["actionSheet"]
    }]
  });
})();
var WeekNamesService = class _WeekNamesService {
  intl;
  constructor(intl) {
    this.intl = intl;
  }
  getWeekNames(includeWeekNumber = false, nameType) {
    const weekNames = shiftWeekNames(this.intl.dateFormatNames({
      nameType,
      type: "days"
    }), this.intl.firstDay());
    return includeWeekNumber ? [""].concat(weekNames) : weekNames;
  }
  static ɵfac = function WeekNamesService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _WeekNamesService)(ɵɵinject(IntlService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _WeekNamesService,
    factory: _WeekNamesService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(WeekNamesService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: IntlService
  }], null);
})();
var DateRangePopupTemplateDirective = class _DateRangePopupTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function DateRangePopupTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DateRangePopupTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DateRangePopupTemplateDirective,
    selectors: [["", "kendoDateRangePopupTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateRangePopupTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDateRangePopupTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var isActive = (cmp) => cmp && cmp.isActive || false;
var hasActiveContent = (popup) => popup && popup.hasActiveContent();
var DateRangeService = class _DateRangeService {
  renderer;
  /**
   * Notifies when the `activeRangeEnd` state changes.
   */
  activeRangeEnd$ = new BehaviorSubject(null);
  /**
   * Notifies when the `focusedDate` changes.
   */
  focusedDate$ = new BehaviorSubject(null);
  /**
   * Notifies when the end DateInput component changes.
   * For example, when you attach a new end `DateInput` or detach the old one.
   */
  endInput$ = new BehaviorSubject(null);
  /**
   * Notifies when the start DateInput component changes.
   * For example, when you attach a new start `DateInput` or detach the old one.
   */
  startInput$ = new BehaviorSubject(null);
  /**
   * Notifies when the `DateRangePopup` component changes.
   */
  dateRangePopup$ = new BehaviorSubject(null);
  /**
   * Notifies when the selection range state changes.
   */
  range$ = new BehaviorSubject(EMPTY_SELECTIONRANGE);
  /**
   * Gets the current `activeRangeEnd` value.
   */
  get activeRangeEnd() {
    return this.activeRangeEnd$.value;
  }
  /**
   * Gets the current `focusedDate` value.
   */
  get focusedDate() {
    return this.focusedDate$.value;
  }
  /**
   * Gets the minimum range value.
   * Takes the `min` value from the start DateInput component or the `min` value of the calendar.
   */
  get min() {
    return (this.startInput$.value || {}).min || null;
  }
  /**
   * Gets the maximum range value.
   * Takes the `max` value from the end DateInput component or the `max` value of the calendar.
   */
  get max() {
    return (this.endInput$.value || {}).max || null;
  }
  /**
   * Gets the current `selectionRange` value.
   */
  get selectionRange() {
    return this.range$.value;
  }
  /**
   * @hidden
   * Gets the start input element.
   */
  get inputStartElement() {
    return this.startInput$.value.inputElement;
  }
  /**
   * @hidden
   * Gets the end input element.
   */
  get inputEndElement() {
    return this.endInput$.value.inputElement;
  }
  /** @hidden */
  constructor(renderer) {
    this.renderer = renderer;
  }
  /**
   * Opens the registered DateRangePopup component.
   * Opens the popup and focuses the calendar.
   */
  activatePopup() {
    const dateRangePopup = this.dateRangePopup$.value;
    if (!dateRangePopup) {
      return;
    }
    if (this.startInput$.value) {
      this.renderer.setAttribute(this.inputStartElement, attributeNames.ariaControls, dateRangePopup.popupUID);
      this.renderer.setAttribute(this.inputStartElement, attributeNames.ariaExpanded, "true");
      this.renderer.setAttribute(this.inputEndElement, attributeNames.ariaControls, dateRangePopup.popupUID);
      this.renderer.setAttribute(this.inputEndElement, attributeNames.ariaExpanded, "true");
    }
    dateRangePopup.activate();
  }
  /**
   * Deactivates the registered `DateRangePopup` component.
   * The method closes the popup.
   */
  deactivatePopup() {
    const dateRangePopup = this.dateRangePopup$.value;
    if (this.startInput$.value) {
      this.renderer.removeAttribute(this.inputStartElement, attributeNames.ariaControls);
      this.renderer.setAttribute(this.inputStartElement, attributeNames.ariaExpanded, "false");
      this.renderer.removeAttribute(this.inputStartElement, attributeNames.ariaActiveDescendant);
      this.renderer.removeAttribute(this.inputEndElement, attributeNames.ariaControls);
      this.renderer.setAttribute(this.inputEndElement, attributeNames.ariaExpanded, "false");
      this.renderer.removeAttribute(this.inputEndElement, attributeNames.ariaActiveDescendant);
    }
    if (!(dateRangePopup && dateRangePopup.show)) {
      return;
    }
    dateRangePopup.show = false;
  }
  /**
   * @hidden
   */
  setActiveDescendent(id3) {
    this.renderer.setAttribute(this.inputStartElement, attributeNames.ariaActiveDescendant, id3);
    this.renderer.setAttribute(this.inputEndElement, attributeNames.ariaActiveDescendant, id3);
  }
  /**
   * @hidden
   *
   * Deactivates the registered `DateRangePopup` component and fires the `cancel` event.
   * The method closes the popup.
   */
  cancelPopup() {
    const dateRangePopup = this.dateRangePopup$.value;
    if (!(dateRangePopup && dateRangePopup.show)) {
      return;
    }
    dateRangePopup.cancelPopup();
  }
  /**
   * Completes all observables to prevent memory leaks.
   * Call this method when you destroy a component that uses the service.
   */
  destroy() {
    this.activeRangeEnd$.complete();
    this.dateRangePopup$.complete();
    this.focusedDate$.complete();
    this.endInput$.complete();
    this.startInput$.complete();
    this.range$.complete();
  }
  /**
   * Checks if any component inside the DateRangeComponent is active.
   * For example, detects an open popup or a focused DateInput component.
   *
   * @returns {boolean} Returns `true` if an active component is present.
   */
  hasActiveComponent() {
    const popup = this.dateRangePopup$.value;
    const isPopup = isActive(popup);
    const isStart = isActive(this.startInput$.value);
    const isEnd = isActive(this.endInput$.value);
    return isPopup || isStart || isEnd || hasActiveContent(popup) || false;
  }
  /**
   * Registers a new start DateInput component and notifies all `startInput$` listeners.
   */
  registerStartInput(startInput) {
    this.startInput$.next(startInput);
  }
  /**
   * Registers a new end `DateInput` component and notifies all `endInput$` listeners.
   */
  registerEndInput(endInput) {
    this.endInput$.next(endInput);
  }
  /**
   * Registers a new `DateRangePopup` component and notifies all `dateRangePopup$` listeners.
   */
  registerPopup(dateRangePopup) {
    this.dateRangePopup$.next(dateRangePopup);
  }
  /**
   * Updates the `activeRangeEnd` value and notifies all `activeRangeEnd$` listeners.
   */
  setActiveRangeEnd(activeRange) {
    if (!activeRange || this.activeRangeEnd === activeRange) {
      return;
    }
    this.activeRangeEnd$.next(activeRange);
  }
  /**
   * Updates the focused date and notifies all `focusedDate$` listeners.
   */
  setFocusedDate(value2) {
    if (isEqual(this.focusedDate$.value, value2)) {
      return;
    }
    this.focusedDate$.next(value2);
  }
  /**
   * Updates the selection range and notifies all `range$` listeners.
   */
  setRange(range2 = EMPTY_SELECTIONRANGE) {
    this.range$.next(range2);
  }
  static ɵfac = function DateRangeService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DateRangeService)(ɵɵinject(Renderer2, 8));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DateRangeService,
    factory: _DateRangeService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateRangeService, [{
    type: Injectable
  }], () => [{
    type: Renderer2,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var DateRangeSelectionDirective = class _DateRangeSelectionDirective {
  calendar;
  cdr;
  element;
  dateRangeService;
  /**
   * Specifies the auto-correction behavior. If the start date is greater than the end date,
   * the directive corrects the date range to a single date either on input change or on blur
   * ([see example](slug:autocorrect_daterange#toc-calendar-selection-directive)).
   *
   * By default, the auto-correction triggers on change.
   * To disable this behavior, set the `autoCorrectOn` property to `none`.
   *
   * @default 'change'
   */
  autoCorrectOn = "change";
  /**
   * Gets or sets the selection range of the calendar. When you set a new range,
   * the connected DateRangeService notifies all related parties.
   */
  get selectionRange() {
    return this.calendar ? this.calendar.selectionRange : null;
  }
  set selectionRange(range2) {
    if (!this.isEqualCalendarRange(range2)) {
      this.setSelectionRange(range2);
    }
    if (!isEqualRange(this.dateRangeService.selectionRange, range2)) {
      this.dateRangeService.setRange(range2);
    }
    this.updateFocusedDate(range2);
  }
  /**
   * Gets or sets the active end of the selection range. This option determines which range end will be updated on
   * user interaction. When a new active end is set, the connected DateRangeService notifies all related parties.
   */
  /**
   * Specifies which end of the selection range is marked as active. The active end gets modified when you interact with the component. When you set a new active end, the wired DateRangeService notifies all related components. For
   * example, the start and end DateInput components.
   *
   * > If the selection range is undefined, the value is ignored.
   */
  get activeRangeEnd() {
    return this.calendar.activeRangeEnd;
  }
  set activeRangeEnd(activeRange) {
    if (this.dateRangeService.activeRangeEnd === activeRange) {
      return;
    }
    this.calendar.activeRangeEnd = activeRange;
    this.dateRangeService.setActiveRangeEnd(activeRange);
  }
  /**
   * @hidden
   * When in adaptive mode range should not be set automatically on calendar value change but only on accept
   */
  shouldSetRange = true;
  /**
   * Fires when the active range end changes. For more information, refer to
   * the section on [events](slug:events_multiviewcalendar).
   */
  activeRangeEndChange = new EventEmitter();
  /**
   * Fires when the selection range changes. For more information, refer to
   * the section on [events](slug:events_multiviewcalendar).
   */
  selectionRangeChange = new EventEmitter();
  get calendarRange() {
    return this.selectionRange || EMPTY_SELECTIONRANGE;
  }
  calendarSubscriptions = new Subscription();
  range;
  constructor(calendar, cdr, element, renderer, dateRangeService) {
    this.calendar = calendar;
    this.cdr = cdr;
    this.element = element;
    this.dateRangeService = dateRangeService;
    this.dateRangeService = this.dateRangeService || new DateRangeService(renderer);
    renderer.setAttribute(element.nativeElement, "aria-multiselectable", "true");
  }
  ngOnInit() {
    const calendar = this.calendar;
    const dateRangeService = this.dateRangeService;
    calendar.min = either(dateRangeService.min, calendar.min);
    calendar.max = either(dateRangeService.max, calendar.max);
    this.addSubscriptions(calendar.cellEnter.subscribe((value2) => this.handleHover(value2)), calendar.valueChange.subscribe((value2) => this.handleChange(value2)), dateRangeService.focusedDate$.subscribe((focusedDate) => {
      if (!isEqual(calendar.focusedDate, focusedDate)) {
        calendar.focusedDate = focusedDate;
      }
    }), dateRangeService.activeRangeEnd$.subscribe((rangeEnd) => {
      if (calendar.activeRangeEnd === rangeEnd) {
        return;
      }
      calendar.activeRangeEnd = rangeEnd;
      this.activeRangeEndChange.emit(rangeEnd);
      this.cdr.markForCheck();
    }), dateRangeService.range$.subscribe((range2) => {
      if (!this.isEqualCalendarRange(range2)) {
        this.acceptAndEmit(range2);
      }
      this.updateFocusedDate(range2);
    }), fromEvent(this.element.nativeElement, "blur").subscribe(() => this.handleBlur()));
  }
  ngOnDestroy() {
    this.calendarSubscriptions.unsubscribe();
  }
  /**
   * @hidden
   */
  handleChange(value2) {
    const service = this.dateRangeService;
    const autoCorrect = this.autoCorrectOn === "change" && this.shouldAutoCorrect(value2);
    const activeEnd = this.calendar.activeRangeEnd !== "end" ? "end" : autoCorrect ? "end" : "start";
    this.range = autoCorrect ? clampRange(value2) : this.updateRange(value2);
    if (!isEqualRange(service.selectionRange, this.range)) {
      this.acceptAndEmit(this.range);
      service.setActiveRangeEnd(activeEnd);
      if (this.shouldSetRange) {
        this.setRange();
      }
    }
  }
  setRange(range2) {
    this.dateRangeService.setRange(this.range ? this.range : range2);
  }
  addSubscriptions(...subscriptions) {
    subscriptions.forEach((s) => this.calendarSubscriptions.add(s));
  }
  isEqualCalendarRange(range2) {
    return isEqualRange(this.calendar.selectionRange, range2);
  }
  handleBlur() {
    const {
      start,
      end
    } = this.calendarRange;
    const autoCorrect = this.autoCorrectOn === "blur" && start !== null && end !== null && end < start;
    if (autoCorrect) {
      this.dateRangeService.setRange(clampRange(start));
    }
  }
  handleHover(value2) {
    if (this.hasCompleteRange()) {
      return;
    }
    const {
      start,
      end
    } = this.calendarRange;
    const activeRangeEnd = this.calendar.activeRangeEnd;
    const updateRange = start && activeRangeEnd === "end" || end && activeRangeEnd === "start";
    if (updateRange) {
      this.setSelectionRange(this.updateRange(value2));
    }
  }
  hasCompleteRange() {
    const {
      start,
      end
    } = this.dateRangeService.selectionRange || EMPTY_SELECTIONRANGE;
    return Boolean(start) && Boolean(end);
  }
  shouldAutoCorrect(value2) {
    const {
      end,
      start
    } = this.calendarRange;
    if (this.calendar.activeRangeEnd !== "end") {
      return end !== null && value2 > end;
    } else {
      return start !== null && value2 < start;
    }
  }
  updateFocusedDate(range2) {
    if (!range2 || this.dateRangeService.focusedDate) {
      return;
    }
    this.dateRangeService.setFocusedDate(range2.start || range2.end);
  }
  updateRange(value2) {
    const {
      end,
      start
    } = this.calendarRange;
    return this.calendar.activeRangeEnd !== "end" ? {
      start: value2,
      end
    } : {
      start,
      end: value2
    };
  }
  setSelectionRange(range2) {
    this.calendar.selectionRange = range2;
    this.calendar.writeValue(null);
  }
  acceptAndEmit(range2) {
    this.setSelectionRange(range2);
    this.selectionRangeChange.emit(range2);
  }
  static ɵfac = function DateRangeSelectionDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DateRangeSelectionDirective)(ɵɵdirectiveInject(MultiViewCalendarComponent), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(DateRangeService, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DateRangeSelectionDirective,
    selectors: [["", "kendoDateRangeSelection", ""]],
    inputs: {
      autoCorrectOn: "autoCorrectOn",
      selectionRange: "selectionRange",
      activeRangeEnd: "activeRangeEnd",
      shouldSetRange: "shouldSetRange"
    },
    outputs: {
      activeRangeEndChange: "activeRangeEndChange",
      selectionRangeChange: "selectionRangeChange"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateRangeSelectionDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDateRangeSelection]",
      standalone: true
    }]
  }], () => [{
    type: MultiViewCalendarComponent
  }, {
    type: ChangeDetectorRef
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: DateRangeService,
    decorators: [{
      type: Optional
    }]
  }], {
    autoCorrectOn: [{
      type: Input
    }],
    selectionRange: [{
      type: Input
    }],
    activeRangeEnd: [{
      type: Input
    }],
    shouldSetRange: [{
      type: Input
    }],
    activeRangeEndChange: [{
      type: Output
    }],
    selectionRangeChange: [{
      type: Output
    }]
  });
})();
var DateRangePopupMessages = class _DateRangePopupMessages extends ComponentMessages {
  /**
   * The text of the **Accept** button in the popup footer of the DateRange Popup.
   */
  accept;
  /**
   * The label of the **Accept** button in the popup footer of the DateRange Popup.
   */
  acceptLabel;
  /**
   * The text of the **Cancel** button in the popup footer of the DateRange Popup.
   */
  cancel;
  /**
   * The label of the **Cancel** button in the popup footer of the DateRange Popup.
   */
  cancelLabel;
  /**
   * The title of the Close button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode.
   */
  adaptiveCloseButtonTitle;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵDateRangePopupMessages_BaseFactory;
    return function DateRangePopupMessages_Factory(__ngFactoryType__) {
      return (ɵDateRangePopupMessages_BaseFactory || (ɵDateRangePopupMessages_BaseFactory = ɵɵgetInheritedFactory(_DateRangePopupMessages)))(__ngFactoryType__ || _DateRangePopupMessages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _DateRangePopupMessages,
    selectors: [["kendo-daterangepopup-messages-base"]],
    inputs: {
      accept: "accept",
      acceptLabel: "acceptLabel",
      cancel: "cancel",
      cancelLabel: "cancelLabel",
      adaptiveCloseButtonTitle: "adaptiveCloseButtonTitle"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateRangePopupMessages, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line
      selector: "kendo-daterangepopup-messages-base"
    }]
  }], null, {
    accept: [{
      type: Input
    }],
    acceptLabel: [{
      type: Input
    }],
    cancel: [{
      type: Input
    }],
    cancelLabel: [{
      type: Input
    }],
    adaptiveCloseButtonTitle: [{
      type: Input
    }]
  });
})();
var DateRangePopupLocalizedMessagesDirective = class _DateRangePopupLocalizedMessagesDirective extends DateRangePopupMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function DateRangePopupLocalizedMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DateRangePopupLocalizedMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DateRangePopupLocalizedMessagesDirective,
    selectors: [["", "kendoDateRangePopupLocalizedMessages", ""]],
    features: [ɵɵProvidersFeature([{
      provide: DateRangePopupMessages,
      useExisting: forwardRef(() => _DateRangePopupLocalizedMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateRangePopupLocalizedMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: DateRangePopupMessages,
        useExisting: forwardRef(() => DateRangePopupLocalizedMessagesDirective)
      }],
      selector: "[kendoDateRangePopupLocalizedMessages]",
      standalone: true
    }]
  }], () => [{
    type: LocalizationService
  }], null);
})();
var DateRangePopupComponent = class _DateRangePopupComponent {
  popupService;
  dateRangeService;
  zone;
  renderer;
  localization;
  cdr;
  rtl;
  adaptiveService;
  container;
  actionSheet;
  defaultTemplate;
  contentTemplate;
  dateRangeSelectionDirective;
  viewCalendar;
  contentCalendar;
  /**
   * @hidden
   *
   * Determines whether to display the MultiViewCalendar header.
   */
  showCalendarHeader = true;
  /**
   * Specifies the focused date of the MultiViewCalendar component.
   * Defines which date receives focus when the component loads ([see example]({% slug dates_multiviewcalendar %}#toc-focused-dates)).
   *
   * If the MultiViewCalendar is out of the min or max range, it normalizes the defined `focusedDate`.
   */
  focusedDate;
  /**
   * Specifies the dates in the MultiViewCalendar that you want to disable ([see example]({% slug disabled_dates_multiviewcalendar %})).
   */
  disabledDates;
  /**
   * Specifies the initial view that the MultiViewCalendar displays when it loads ([see example]({% slug viewoptions_multiviewcalendar %})).
   * By default, the active view is `month`.
   *
   * You have to set `activeView` within the `topView`-`bottomView` range.
   *
   * @default 'month
   */
  activeView = CalendarViewEnum[CalendarViewEnum.month];
  /**
   * Specifies the lowest view level that users can navigate to ([see example](slug:viewdepth_multiviewcalendar)).
   *
   * @default 'month'
   */
  bottomView = CalendarViewEnum[CalendarViewEnum.month];
  /**
   * Specifies the highest view level that users can navigate to ([see example](slug:viewdepth_multiviewcalendar)).
   *
   * @default 'century'
   */
  topView = CalendarViewEnum[CalendarViewEnum.century];
  /**
   * Specifies the minimum date that users can select ([see example]({% slug dates_multiviewcalendar %}#toc-focused-dates)).
   *
   * @default '1900-01-01'
   */
  min;
  /**
   * Specifies the maximum date that users can select ([see example]({% slug dates_multiviewcalendar %}#toc-focused-dates)).
   *
   * @default '2099-12-31'
   */
  max;
  /**
   * Determines whether users can select dates in reverse order.
   * When you set `allowReverse` to `true`, the component does not validate if the start date comes after the end date.
   *
   * @default false
   */
  allowReverse = false;
  /**
   * Determines whether to animate transitions when users navigate between views.
   *
   * @default false
   */
  animateNavigation = false;
  /**
   * Determines whether the MultiViewCalendar is interactive ([see example]({% slug disabled_multiviewcalendar %})).
   * When you set `disabled` to `true`, users cannot interact with the component.
   *
   * @default false
   */
  disabled = false;
  /**
   * Specifies the number of calendar views to display side by side.
   *
   * @default 2
   */
  views = 2;
  /**
   * Determines whether to display week numbers in the `month` view ([see example]({% slug weeknumcolumn_multiviewcalendar %})).
   *
   * @default false
   */
  weekNumber = false;
  /**
   * Controls the popup animations.
   * When you set `animate` to `true`, the popup displays opening and closing animations.
   * For more information about controlling the popup animations,
   * refer to the article on [animations]({% slug animations_popup %}).
   *
   * @default true
   */
  animate = true;
  /**
   * Specifies the element that serves as an anchor for the popup.
   * The popup opens next to this element.
   * For more information, refer to the section on
   * [aligning to specific components]({% slug alignmentpositioning_popup %}#toc-aligning-to-components).
   */
  anchor;
  /**
   * Specifies the alignment point for the anchor element.
   * For more information, refer to the section on
   * [positioning]({% slug alignmentpositioning_popup %}#toc-positioning).
   */
  anchorAlign;
  /**
   * Determines whether to display a header for each view ([see example]({% slug viewheader_multiviewcalendar %})).
   * For example, displays the month name in the month view.
   *
   * @default false
   */
  showViewHeader = false;
  /**
   * Determines whether to display days from adjacent months in the current month view ([see example]({% slug viewoptions_multiviewcalendar %}#toc-displaying-other-month-days)).
   *
   * @default false
   */
  showOtherMonthDays = false;
  /**
   * Specifies where to render the popup container.
   * By default, the popup renders in the root component.
   *
   * @default 'root'
   */
  appendTo;
  /**
   * Configures how the popup behaves when it encounters viewport boundaries.
   * For more information, refer to the article on
   * [viewport boundary detection]({% slug viewportboundarydetection_popup %}).
   *
   * @default { horizontal: 'fit', vertical: 'flip' }
   */
  collision = {
    horizontal: "fit",
    vertical: "flip"
  };
  /**
   * Specifies the alignment point for the popup element.
   * For more information, refer to the section on
   * [positioning]({% slug alignmentpositioning_popup %}#toc-positioning).
   */
  popupAlign;
  /**
   * Specifies the margin around the popup in pixels.
   * Creates empty space between the popup and its anchor element.
   */
  margin;
  /**
   * Determines whether the component uses adaptive rendering for different screen sizes.
   * By default, adaptive rendering is disabled.
   *
   * @default 'none'
   */
  adaptiveMode = "none";
  /**
   * Specifies the title text for the input element and the header of the action sheet.
   * Applies only when [`AdaptiveMode` is set to `auto`](slug:api_dateinputs_adaptivemode).
   *
   * @default ""
   */
  adaptiveTitle = "";
  /**
   * Specifies the subtitle text displayed in the header of the action sheet.
   * Applies only when [`AdaptiveMode` is set to `auto`](slug:api_dateinputs_adaptivemode).
   *
   * @default ""
   */
  adaptiveSubtitle = "";
  /**
   * @hidden
   *
   * TODO: Make visible when the Infinite Calendar is fixed to set properly the size option.
   * Sets the size of the component.
   * @default 'medium'
   */
  size;
  /**
   * Fires when the popup is about to open ([see example](slug:popup_daterange#toc-events)).
   * You can prevent this event to keep the popup closed.
   */
  open = new EventEmitter();
  /**
   * Fires when the popup is about to close ([see example](slug:popup_daterange#toc-events)).
   * You can prevent this event to keep the popup open.
   */
  close = new EventEmitter();
  /**
   * Fires when the calendar element loses focus ([see example](slug:popup_daterange#toc-events)).
   */
  onBlur = new EventEmitter();
  /**
   * Fires when the calendar element receives focus ([see example](slug:popup_daterange#toc-events)).
   */
  onFocus = new EventEmitter();
  /**
   * Fires when the popup closes due to an `ESC` keypress or when it leaves the viewport ([see example](slug:popup_daterange#toc-events)).
   */
  cancel = new EventEmitter();
  /**
   * Gets the active calendar that displays in the popup.
   *
   * When the popup is closed, the property returns `null`.
   */
  get calendar() {
    return this._calendar;
  }
  set calendar(calendar) {
    this._calendar = calendar;
    this.subscribeFocusBlur(calendar);
  }
  /**
   * Gets the active state of the component.
   * Returns `true` when the opened calendar is active.
   */
  get isActive() {
    return this.calendar && this.calendar.isActive || this.actionSheet && this.actionSheet.expanded;
  }
  /**
   * @hidden
   */
  get isAdaptiveModeEnabled() {
    return this.adaptiveMode === "auto";
  }
  /**
   * @hidden
   */
  get isAdaptive() {
    return this.isAdaptiveModeEnabled && this.windowSize !== "large";
  }
  /**
   * @hidden
   */
  popupRef;
  /**
   * @hidden
   */
  popupUID = guid();
  /**
   * @hidden
   */
  checkIcon = checkIcon;
  /**
   * @hidden
   */
  windowSize;
  /**
   * Gets or sets the visibility state of the component.
   */
  set show(show) {
    if (this._show === show) {
      return;
    }
    const event = new PreventableEvent2();
    if (show) {
      this.open.emit(event);
    } else {
      this.close.emit(event);
    }
    if (event.isDefaultPrevented()) {
      return;
    }
    this.toggleDateRange(show);
  }
  get show() {
    return this._show;
  }
  /**
   * @hidden
   */
  handleAccept() {
    this.dateRangeService.setRange(this._rangeSelection);
    this.show = false;
  }
  activateSubscription;
  blurSubscription;
  focusSubscription;
  calendarSubscriptions = new Subscription();
  popupSubscriptions = new Subscription();
  windowBlurSubscription;
  localizationSubscriptions = new Subscription();
  resolvedPromise = Promise.resolve();
  _calendar;
  _show;
  _rangeSelection;
  constructor(popupService, dateRangeService, zone, renderer, localization, cdr, rtl, adaptiveService) {
    this.popupService = popupService;
    this.dateRangeService = dateRangeService;
    this.zone = zone;
    this.renderer = renderer;
    this.localization = localization;
    this.cdr = cdr;
    this.rtl = rtl;
    this.adaptiveService = adaptiveService;
  }
  ngOnInit() {
    this.dateRangeService.registerPopup(this);
    if (this.localization) {
      this.localizationSubscriptions.add(this.localization.changes.subscribe(() => this.cdr.markForCheck()));
    }
  }
  ngAfterViewInit() {
    this.calendarSubscriptions.add(this.contentCalendar.changes.subscribe((changes) => {
      this.calendar = changes.first;
      this.actionSheet.titleId = changes.first?.headerId;
      this.cdr.detectChanges();
    }));
    this.calendarSubscriptions.add(this.viewCalendar.changes.subscribe((changes) => {
      this.calendar = changes.first;
      this.actionSheet.titleId = changes.first?.headerId;
      this.cdr.detectChanges();
    }));
    this.calendarSubscriptions.add(this.dateRangeService.startInput$?.value?.valueChange.subscribe((res) => {
      if (this.calendar) {
        if (!res && this.dateRangeService.selectionRange.end) {
          this.calendar.shouldHoverWhenNoStart = true;
        } else {
          this.calendar.shouldHoverWhenNoStart = false;
        }
      }
    }));
    if (isWindowAvailable()) {
      this.zone.runOutsideAngular(() => this.windowBlurSubscription = fromEvent(window, "blur").subscribe(this.handleWindowBlur.bind(this)));
    }
  }
  ngOnDestroy() {
    this.destroyPopup();
    this.calendarSubscriptions.unsubscribe();
    if (this.activateSubscription) {
      this.activateSubscription.unsubscribe();
    }
    if (this.blurSubscription) {
      this.blurSubscription.unsubscribe();
      this.focusSubscription.unsubscribe();
    }
    if (this.windowBlurSubscription) {
      this.windowBlurSubscription.unsubscribe();
    }
  }
  /**
   * @hidden
   *
   */
  onRangeSelectionChange(rangeSelection) {
    this.dateRangeService.setActiveRangeEnd(rangeSelection.activeRangeEnd);
    if (!this.isAdaptive) {
      this.dateRangeService.setRange(rangeSelection.selectionRange);
    } else {
      this._rangeSelection = rangeSelection.selectionRange;
    }
  }
  /**
   * Opens the popup component and focuses the calendar.
   */
  activate() {
    if (this.show === true) {
      return;
    }
    if (this.activateSubscription) {
      this.activateSubscription.unsubscribe();
    }
    this.show = true;
    this.cdr.markForCheck();
    this.zone.runOutsideAngular(() => {
      this.activateSubscription = merge(this.contentCalendar.changes, this.viewCalendar.changes).pipe(filter((changes) => changes && changes.first), map((changes) => changes.first)).subscribe((calendar) => setTimeout(() => {
        calendar.focus();
        this.addCalendarSubscription(calendar);
      }));
    });
  }
  /**
   * Focuses the calendar if it is available.
   */
  focus() {
    if (this.calendar) {
      this.calendar.focus();
    }
  }
  /**
   * Checks if a focused element is inside the popup.
   *
   * @returns {boolean} Returns `true` if the focused element is inside the popup.
   */
  hasActiveContent() {
    if (!isDocumentAvailable() || !this.popupRef) {
      return false;
    }
    return this.popupRef.popupElement.contains(document.activeElement);
  }
  /**
   * Toggles the visibility of the popup or action sheet.
   * When you use the `toggle` method to show or hide the popup or action sheet,
   * the `open` and `close` events do not fire.
   *
   * @param {boolean} show The state of the popup.
   */
  toggle(show) {
    this.resolvedPromise.then(() => {
      this.toggleDateRange(show === void 0 ? !this.show : show);
    });
  }
  /**
   * @hidden
   *
   * Closes the popup and triggers the `cancel` event.
   */
  cancelPopup() {
    this.show = false;
    this.cancel.emit();
  }
  /**
   * @hidden
   */
  onResize() {
    const currentWindowSize = this.adaptiveService.size;
    if (!this.show || this.windowSize === currentWindowSize) {
      return;
    }
    if (this.actionSheet.expanded) {
      this.toggleActionSheet(false);
    } else {
      this.togglePopup(false);
    }
    this.windowSize = currentWindowSize;
  }
  /**
   * @hidden
   */
  closePopup(event) {
    event.preventDefault();
    event.stopPropagation();
    this.toggle(false);
    if (this.dateRangeService.activeRangeEnd === "start" || !this.dateRangeService.activeRangeEnd) {
      this.dateRangeService.startInput$.value.focus();
    } else {
      this.dateRangeService.endInput$.value.focus();
    }
  }
  /**
   * @hidden
   */
  handleTab(event) {
    event.preventDefault();
    event.stopPropagation();
    if (this.dateRangeService.activeRangeEnd === "start" || !this.dateRangeService.activeRangeEnd) {
      this.dateRangeService.setActiveRangeEnd("end");
    } else {
      this.dateRangeService.endInput$.value.focus();
    }
  }
  /**
   * @hidden
   */
  handleShiftTab(event) {
    event.preventDefault();
    event.stopPropagation();
    if (this.dateRangeService.activeRangeEnd === "end") {
      this.dateRangeService.setActiveRangeEnd("start");
    } else {
      this.dateRangeService.startInput$.value.focus();
    }
  }
  handleWindowBlur() {
    if (!this.show || this.actionSheet.expanded) {
      return;
    }
    if (hasObservers(this.close)) {
      this.zone.run(() => this.show = false);
    } else {
      this.show = false;
    }
  }
  handleMouseLeave() {
    this.dateRangeService.setRange(this.dateRangeService.selectionRange);
  }
  handleKeydown(event) {
    const {
      altKey
    } = event;
    const code = normalizeKeys(event);
    if (code === Keys.Escape || altKey && code === Keys.ArrowUp) {
      this.zone.run(() => this.cancelPopup());
    }
  }
  subscribeFocusBlur(calendar) {
    if (this.blurSubscription) {
      this.blurSubscription.unsubscribe();
      this.focusSubscription.unsubscribe();
    }
    if (!calendar) {
      return;
    }
    const calendarElement = calendar.element.nativeElement.querySelector(".k-calendar-view");
    this.blurSubscription = fromEvent(calendarElement, "blur").subscribe(() => this.onBlur.emit());
    this.focusSubscription = fromEvent(calendarElement, "focus").subscribe(() => this.onFocus.emit());
  }
  addPopupSubscriptions(...subscriptions) {
    if (!isPresent4(this.popupSubscriptions)) {
      this.popupSubscriptions = new Subscription();
    }
    subscriptions.forEach((s) => this.popupSubscriptions.add(s));
  }
  get _appendTo() {
    const appendTo = this.appendTo;
    if (!appendTo || appendTo === "root") {
      return void 0;
    }
    return appendTo === "component" ? this.container : appendTo;
  }
  togglePopup(show) {
    this._show = show;
    if (this.popupRef) {
      this.destroyPopup();
    }
    if (this._show) {
      const direction = this.rtl ? "right" : "left";
      this.popupRef = this.popupService.open({
        anchor: this.anchor,
        anchorAlign: this.anchorAlign || {
          vertical: "bottom",
          horizontal: direction
        },
        animate: this.animate,
        appendTo: this._appendTo,
        collision: this.collision,
        content: (this.contentTemplate || {}).templateRef || this.defaultTemplate,
        margin: this.margin,
        popupClass: "k-calendar-container k-daterangepicker-popup",
        popupAlign: this.popupAlign || {
          vertical: "top",
          horizontal: direction
        },
        positionMode: "absolute"
      });
      const {
        popupElement,
        popupAnchorViewportLeave
      } = this.popupRef;
      this.renderer.setAttribute(popupElement.querySelector(".k-popup"), "id", this.popupUID);
      this.addPopupSubscriptions(this.zone.runOutsideAngular(() => fromEvent(popupElement, "keydown").subscribe(this.handleKeydown.bind(this))), fromEvent(popupElement, "mouseleave").subscribe(this.handleMouseLeave.bind(this)), popupAnchorViewportLeave.subscribe(() => this.cancelPopup()));
    }
  }
  destroyPopup() {
    if (isPresent4(this.popupRef)) {
      this.popupRef.close();
      this.popupRef = null;
    }
    if (isPresent4(this.popupSubscriptions)) {
      this.popupSubscriptions.unsubscribe();
    }
  }
  toggleDateRange(show) {
    this.windowSize = this.adaptiveService.size;
    if (this.isAdaptive) {
      this.toggleActionSheet(show);
    } else {
      this.togglePopup(show);
    }
  }
  toggleActionSheet(show) {
    if (show === this._show) {
      return;
    }
    if (show && !this.actionSheet.expanded) {
      this.actionSheet.toggle();
      this.renderer.setAttribute(this.actionSheet.element.nativeElement, "id", this.popupUID);
    } else if (!show && this.actionSheet.expanded) {
      this.actionSheet.toggle();
    }
    this._show = show;
  }
  addCalendarSubscription = (calendar) => {
    this.calendarSubscriptions.add(calendar.viewList.focusedCellChange.subscribe((id3) => {
      this.dateRangeService.setActiveDescendent(id3);
    }));
  };
  static ɵfac = function DateRangePopupComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DateRangePopupComponent)(ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(DateRangeService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(RTL, 8), ɵɵdirectiveInject(AdaptiveService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DateRangePopupComponent,
    selectors: [["kendo-daterange-popup"]],
    contentQueries: function DateRangePopupComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, DateRangePopupTemplateDirective, 5)(dirIndex, MultiViewCalendarComponent, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.contentTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.contentCalendar = _t);
      }
    },
    viewQuery: function DateRangePopupComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c14, 5, ViewContainerRef)(_c17, 5)(_c38, 5)(DateRangeSelectionDirective, 5)(MultiViewCalendarComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.container = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.actionSheet = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.defaultTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dateRangeSelectionDirective = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.viewCalendar = _t);
      }
    },
    inputs: {
      showCalendarHeader: "showCalendarHeader",
      focusedDate: "focusedDate",
      disabledDates: "disabledDates",
      activeView: "activeView",
      bottomView: "bottomView",
      topView: "topView",
      min: "min",
      max: "max",
      allowReverse: "allowReverse",
      animateNavigation: "animateNavigation",
      disabled: "disabled",
      views: "views",
      weekNumber: "weekNumber",
      animate: "animate",
      anchor: "anchor",
      anchorAlign: "anchorAlign",
      showViewHeader: "showViewHeader",
      showOtherMonthDays: "showOtherMonthDays",
      appendTo: "appendTo",
      collision: "collision",
      popupAlign: "popupAlign",
      margin: "margin",
      adaptiveMode: "adaptiveMode",
      adaptiveTitle: "adaptiveTitle",
      adaptiveSubtitle: "adaptiveSubtitle",
      size: "size"
    },
    outputs: {
      open: "open",
      close: "close",
      onBlur: "blur",
      onFocus: "focus",
      cancel: "cancel"
    },
    exportAs: ["kendo-daterange-popup"],
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.daterangepopup"
    }])],
    decls: 8,
    vars: 7,
    consts: () => {
      let i18n_60;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_60 = goog.getMsg("Set");
        i18n_60 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_60;
      } else {
        i18n_60 = $localize`:kendo.daterangepopup.accept|The Accept button text in the timepicker component:Set`;
      }
      let i18n_61;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_61 = goog.getMsg("Set time");
        i18n_61 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_61;
      } else {
        i18n_61 = $localize`:kendo.daterangepopup.acceptLabel|The label for the Accept button in the timepicker component:Set time`;
      }
      let i18n_62;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_62 = goog.getMsg("Cancel");
        i18n_62 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_62;
      } else {
        i18n_62 = $localize`:kendo.daterangepopup.cancel|The Cancel button text in the timepicker component:Cancel`;
      }
      let i18n_63;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_63 = goog.getMsg("Cancel changes");
        i18n_63 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_63;
      } else {
        i18n_63 = $localize`:kendo.daterangepopup.cancelLabel|The label for the Cancel button in the timepicker component:Cancel changes`;
      }
      let i18n_64;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_64 = goog.getMsg("Close");
        i18n_64 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_64;
      } else {
        i18n_64 = $localize`:kendo.daterangepopup.adaptiveCloseButtonTitle|The title of the Close button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode:Close`;
      }
      return [["container", ""], ["defaultTemplate", ""], ["actionSheet", ""], ["kendoDateRangePopupLocalizedMessages", "", "accept", i18n_60, "acceptLabel", i18n_61, "cancel", i18n_62, "cancelLabel", i18n_63, "adaptiveCloseButtonTitle", i18n_64], [3, "overlayClick", "collapse", "cssClass", "cssStyle"], ["kendoActionSheetTemplate", ""], ["orientation", "horizontal", "selection", "range", 3, "onClosePopup", "onTabPress", "onShiftTabPress", "rangeSelectionChange", "activeView", "bottomView", "animateNavigation", "disabled", "views", "weekNumber", "topView", "disabledDates", "min", "max", "showCalendarHeader", "focusedDate", "allowReverse", "showViewHeader", "showOtherMonthDays", "size", "value"], [1, "k-actionsheet-titlebar"], [1, "k-actionsheet-titlebar-group"], [1, "k-actionsheet-title"], [1, "k-text-center"], [1, "k-actionsheet-subtitle", "k-text-center"], [1, "k-actionsheet-actions"], ["kendoButton", "", "type", "button", "icon", "check", "fillMode", "flat", "themeColor", "primary", "size", "large", "innerCssClass", "k-button-icon", 3, "click", "svgIcon", "tabIndex"], [1, "k-actionsheet-content"], [1, "k-scrollable-wrap"], ["size", "large", "orientation", "vertical", "selection", "range", 3, "rangeSelectionChange", "animateNavigation", "disabled", "views", "weekNumber", "disabledDates", "activeView", "bottomView", "topView", "min", "max", "showCalendarHeader", "focusedDate", "allowReverse", "showViewHeader", "showOtherMonthDays", "value"], [1, "k-actions", "k-actions-stretched", "k-actions-horizontal", "k-actionsheet-footer"], ["kendoButton", "", "type", "button", "size", "large", 1, "k-time-cancel", 3, "click"], ["kendoButton", "", "type", "button", "size", "large", "themeColor", "primary", 1, "k-time-accept", 3, "click"], [3, "resize"]];
    },
    template: function DateRangePopupComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainer(0, 3)(1, null, 0);
        ɵɵtemplate(3, DateRangePopupComponent_ng_template_3_Template, 1, 17, "ng-template", null, 1, ɵɵtemplateRefExtractor);
        ɵɵelementStart(5, "kendo-actionsheet", 4, 2);
        ɵɵlistener("overlayClick", function DateRangePopupComponent_Template_kendo_actionsheet_overlayClick_5_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.show = false);
        })("collapse", function DateRangePopupComponent_Template_kendo_actionsheet_collapse_5_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onBlur.emit());
        });
        ɵɵtemplate(7, DateRangePopupComponent_ng_template_7_Template, 16, 29, "ng-template", 5);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance(5);
        ɵɵproperty("cssClass", ɵɵpureFunction2(2, _c19, ctx.windowSize === "small", ctx.windowSize === "medium"))("cssStyle", ɵɵpureFunction1(5, _c20, ctx.windowSize === "small" ? "100vh" : "60vh"));
      }
    },
    dependencies: [DateRangePopupLocalizedMessagesDirective, MultiViewCalendarComponent, ActionSheetComponent, ActionSheetTemplateDirective, ResizeSensorComponent, ButtonComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateRangePopupComponent, [{
    type: Component,
    args: [{
      exportAs: "kendo-daterange-popup",
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.daterangepopup"
      }],
      selector: "kendo-daterange-popup",
      template: `
        <ng-container kendoDateRangePopupLocalizedMessages
          i18n-accept="kendo.daterangepopup.accept|The Accept button text in the timepicker component"
          accept="Set"
        
          i18n-acceptLabel="kendo.daterangepopup.acceptLabel|The label for the Accept button in the timepicker component"
          acceptLabel="Set time"
        
          i18n-cancel="kendo.daterangepopup.cancel|The Cancel button text in the timepicker component"
          cancel="Cancel"
        
          i18n-cancelLabel="kendo.daterangepopup.cancelLabel|The label for the Cancel button in the timepicker component"
          cancelLabel="Cancel changes"
        
          i18n-adaptiveCloseButtonTitle="kendo.daterangepopup.adaptiveCloseButtonTitle|The title of the Close button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode"
          adaptiveCloseButtonTitle="Close"
          >
        </ng-container>
        <ng-container #container></ng-container>
        <ng-template #defaultTemplate>
          <kendo-multiviewcalendar
            [activeView]="activeView"
            [bottomView]="bottomView"
            [animateNavigation]="animateNavigation"
            [disabled]="disabled"
            orientation="horizontal"
            [views]="views"
            [weekNumber]="weekNumber"
            [topView]="topView"
            [disabledDates]="disabledDates"
            [min]="min"
            [max]="max"
            [showCalendarHeader]="showCalendarHeader"
            [focusedDate]="focusedDate"
            [allowReverse]="allowReverse"
            [showViewHeader]="showViewHeader"
            [showOtherMonthDays]="showOtherMonthDays"
            selection="range"
            [size]="size"
            [value]="dateRangeService.selectionRange"
            (onClosePopup)="closePopup($event)"
            (onTabPress)="handleTab($event)"
            (onShiftTabPress)="handleShiftTab($event)"
            (rangeSelectionChange)="onRangeSelectionChange($event)"
          ></kendo-multiviewcalendar>
        </ng-template>
        
        <kendo-actionsheet
          #actionSheet
          (overlayClick)="show=false"
          (collapse)="onBlur.emit()"
            [cssClass]="{
                'k-adaptive-actionsheet': true,
                'k-actionsheet-fullscreen': windowSize === 'small',
                'k-actionsheet-bottom': windowSize === 'medium'
            }"
            [cssStyle]="{
                height: windowSize === 'small' ? '100vh' : '60vh'
            }"
          >
          <ng-template kendoActionSheetTemplate>
            <!-- Resize sensor needs to be inside the template because the date-range-popup
            element itself always has 0x0 size and does not trigger the sensor.
            Note: The popup in non-adaptive mode closes on window blur -->
            @if (isAdaptiveModeEnabled) {
              <kendo-resize-sensor (resize)="onResize()"></kendo-resize-sensor>
            }
            <div class="k-actionsheet-titlebar">
              <div class="k-actionsheet-titlebar-group">
                <div class="k-actionsheet-title">
                  @if (adaptiveTitle) {
                    <div class="k-text-center">{{ adaptiveTitle }}</div>
                  }
                  @if (adaptiveSubtitle) {
                    <div class="k-actionsheet-subtitle k-text-center">{{ adaptiveSubtitle }}</div>
                  }
                </div>
                <div class="k-actionsheet-actions">
                  <button
                    kendoButton
                    type="button"
                    icon="check"
                    [attr.title]="localization.get('adaptiveCloseButtonTitle')"
                    [svgIcon]="checkIcon"
                    fillMode="flat"
                    themeColor="primary"
                    [tabIndex]="-1"
                    size="large"
                    innerCssClass="k-button-icon"
                    (click)="handleAccept()">
                  </button>
                </div>
              </div>
            </div>
            <div class="k-actionsheet-content">
              <div class="k-scrollable-wrap">
                <kendo-multiviewcalendar
                  size="large"
                  [animateNavigation]="animateNavigation"
                  [disabled]="disabled"
                  orientation="vertical"
                  [views]="views"
                  [weekNumber]="weekNumber"
                  [disabledDates]="disabledDates"
                  [activeView]="activeView"
                  [bottomView]="bottomView"
                  [topView]="topView"
                  [min]="min"
                  [max]="max"
                  [showCalendarHeader]="showCalendarHeader"
                  [focusedDate]="focusedDate"
                  [allowReverse]="allowReverse"
                  [showViewHeader]="showViewHeader"
                  [showOtherMonthDays]="showOtherMonthDays"
                  [focusedDate]="dateRangeService.focusedDate"
                  [value]="dateRangeService.selectionRange"
                  selection="range"
                  (rangeSelectionChange)="onRangeSelectionChange($event)"
                  >
                </kendo-multiviewcalendar>
              </div>
            </div>
            <div class="k-actions k-actions-stretched k-actions-horizontal k-actionsheet-footer">
              <button kendoButton
                class="k-time-cancel"
                type="button"
                size="large"
                [attr.title]="localization.get('cancelLabel')"
                [attr.aria-label]="localization.get('cancelLabel')"
                (click)="show=false"
                >
                {{localization.get('cancel')}}
              </button>
        
              <button kendoButton
                class="k-time-accept"
                type="button"
                size="large"
                themeColor="primary"
                [attr.title]="localization.get('acceptLabel')"
                [attr.aria-label]="localization.get('acceptLabel')"
                (click)="handleAccept()"
                >
                {{localization.get('accept')}}
              </button>
            </div>
          </ng-template>
        </kendo-actionsheet>
        `,
      standalone: true,
      imports: [DateRangePopupLocalizedMessagesDirective, MultiViewCalendarComponent, ActionSheetComponent, ActionSheetTemplateDirective, ResizeSensorComponent, ButtonComponent]
    }]
  }], () => [{
    type: PopupService
  }, {
    type: DateRangeService
  }, {
    type: NgZone
  }, {
    type: Renderer2
  }, {
    type: LocalizationService
  }, {
    type: ChangeDetectorRef
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [RTL]
    }]
  }, {
    type: AdaptiveService
  }], {
    container: [{
      type: ViewChild,
      args: ["container", {
        read: ViewContainerRef,
        static: false
      }]
    }],
    actionSheet: [{
      type: ViewChild,
      args: ["actionSheet"]
    }],
    defaultTemplate: [{
      type: ViewChild,
      args: ["defaultTemplate", {
        static: false
      }]
    }],
    contentTemplate: [{
      type: ContentChild,
      args: [DateRangePopupTemplateDirective, {
        static: false
      }]
    }],
    dateRangeSelectionDirective: [{
      type: ViewChild,
      args: [DateRangeSelectionDirective, {
        static: false
      }]
    }],
    viewCalendar: [{
      type: ViewChildren,
      args: [MultiViewCalendarComponent]
    }],
    contentCalendar: [{
      type: ContentChildren,
      args: [MultiViewCalendarComponent]
    }],
    showCalendarHeader: [{
      type: Input
    }],
    focusedDate: [{
      type: Input
    }],
    disabledDates: [{
      type: Input
    }],
    activeView: [{
      type: Input
    }],
    bottomView: [{
      type: Input
    }],
    topView: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    allowReverse: [{
      type: Input
    }],
    animateNavigation: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    views: [{
      type: Input
    }],
    weekNumber: [{
      type: Input
    }],
    animate: [{
      type: Input
    }],
    anchor: [{
      type: Input
    }],
    anchorAlign: [{
      type: Input
    }],
    showViewHeader: [{
      type: Input
    }],
    showOtherMonthDays: [{
      type: Input
    }],
    appendTo: [{
      type: Input
    }],
    collision: [{
      type: Input
    }],
    popupAlign: [{
      type: Input
    }],
    margin: [{
      type: Input
    }],
    adaptiveMode: [{
      type: Input
    }],
    adaptiveTitle: [{
      type: Input
    }],
    adaptiveSubtitle: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    open: [{
      type: Output
    }],
    close: [{
      type: Output
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    cancel: [{
      type: Output
    }]
  });
})();
var DateRangeComponent = class _DateRangeComponent {
  dateRangeService;
  /**
   * @hidden
   *
   * TODO: Make visible when the Infinite Calendar is fixed to set properly the size option.
   * Sets the size of the component.
   *
   * @default 'medium'
   */
  size;
  /**
  * @hidden
  */
  keydown(event) {
    const code = normalizeKeys(event);
    const shouldOpenPopup = code === Keys.ArrowDown && event.altKey;
    if (shouldOpenPopup) {
      this.dateRangeService.activatePopup();
    }
    const shouldClosePopup = code === Keys.ArrowUp && event.altKey || code === Keys.Escape;
    if (shouldClosePopup) {
      this.dateRangeService.deactivatePopup();
    }
  }
  wrapperClass = true;
  /**
   * @hidden
   */
  showDefault = false;
  contentPopup;
  get hasContentPopup() {
    return this.contentPopup.length > 0;
  }
  subscription;
  constructor(dateRangeService) {
    this.dateRangeService = dateRangeService;
    N(packageMetadata);
  }
  ngAfterContentInit() {
    this.showDefault = !this.hasContentPopup;
    this.subscription = this.contentPopup.changes.subscribe(() => {
      this.showDefault = !this.hasContentPopup;
    });
  }
  ngOnDestroy() {
    this.subscription?.unsubscribe();
  }
  static ɵfac = function DateRangeComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DateRangeComponent)(ɵɵdirectiveInject(DateRangeService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DateRangeComponent,
    selectors: [["kendo-daterange"]],
    contentQueries: function DateRangeComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, DateRangePopupComponent, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.contentPopup = _t);
      }
    },
    hostVars: 2,
    hostBindings: function DateRangeComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("keydown", function DateRangeComponent_keydown_HostBindingHandler($event) {
          return ctx.keydown($event);
        });
      }
      if (rf & 2) {
        ɵɵclassProp("k-daterangepicker", ctx.wrapperClass);
      }
    },
    inputs: {
      size: "size"
    },
    features: [ɵɵProvidersFeature([DateRangeService])],
    ngContentSelectors: _c8,
    decls: 2,
    vars: 1,
    consts: [[3, "size"]],
    template: function DateRangeComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
        ɵɵconditionalCreate(1, DateRangeComponent_Conditional_1_Template, 1, 1, "kendo-daterange-popup", 0);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵconditional(ctx.showDefault ? 1 : -1);
      }
    },
    dependencies: [DateRangePopupComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateRangeComponent, [{
    type: Component,
    args: [{
      providers: [DateRangeService],
      selector: "kendo-daterange",
      template: `
        <ng-content></ng-content>
        @if (showDefault) {
          <kendo-daterange-popup [size]="size"></kendo-daterange-popup>
        }
        `,
      standalone: true,
      imports: [DateRangePopupComponent]
    }]
  }], () => [{
    type: DateRangeService
  }], {
    size: [{
      type: Input
    }],
    keydown: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }],
    wrapperClass: [{
      type: HostBinding,
      args: ["class.k-daterangepicker"]
    }],
    contentPopup: [{
      type: ContentChildren,
      args: [DateRangePopupComponent]
    }]
  });
})();
var DateRangeInput = class _DateRangeInput {
  activeRangeEnd;
  dateRangeService;
  input;
  element;
  renderer;
  zone;
  navigateCalendarOnFocus = false;
  get isActiveEnd() {
    return this.dateRangeService.activeRangeEnd === this.activeRangeEnd;
  }
  popupSubscriptions = new Subscription();
  subscriptions = new Subscription();
  get popupCalendarActivated() {
    const popup = this.dateRangeService.dateRangePopup$.value;
    return isPresent4(popup) && isPresent4(popup.calendar);
  }
  constructor(activeRangeEnd, dateRangeService, input, element, renderer, zone) {
    this.activeRangeEnd = activeRangeEnd;
    this.dateRangeService = dateRangeService;
    this.input = input;
    this.element = element;
    this.renderer = renderer;
    this.zone = zone;
  }
  init() {
    this.input.role = "combobox";
    this.input.hasPopup = "grid";
    if (this.input.value) {
      this.dateRangeService.setRange(this.getRange(this.input.value));
    }
    [this.input.onBlur.subscribe(() => this.deactivate()), this.input.valueUpdate.subscribe((value2) => this.updateRange(value2, "change")), this.dateRangeService.activeRangeEnd$.subscribe(() => {
      if (this.navigateCalendarOnFocus) {
        this.focusActiveDate();
      }
      this.toggleActiveClass(this.isActiveEnd);
    }), this.dateRangeService.dateRangePopup$.subscribe((popup) => this.initPopup(popup)), this.dateRangeService.range$.subscribe((range2) => this.updateInputValue(range2)), fromEvent(this.element.nativeElement, "click").subscribe(() => this.activate()), fromEvent(this.element.nativeElement, "keydown").subscribe((event) => this.togglePopup(event || {}))].forEach((s) => this.subscriptions.add(s));
  }
  destroy() {
    this.subscriptions.unsubscribe();
    this.unsubscribePopup();
  }
  initPopup(popup) {
    if (!popup) {
      this.unsubscribePopup();
      return;
    }
    if (!popup.anchor) {
      popup.anchor = this.element.nativeElement;
    }
    [popup.cancel.subscribe(() => this.isActiveEnd && this.input.focus()), popup.onFocus.subscribe(() => this.toggleActiveClass(this.isActiveEnd)), popup.onBlur.subscribe(() => this.deactivate()), popup.close?.subscribe(() => this.isActiveEnd && this.input.focus())].forEach((s) => this.popupSubscriptions.add(s));
  }
  unsubscribePopup() {
    this.popupSubscriptions.unsubscribe();
    this.popupSubscriptions = new Subscription();
  }
  activate() {
    this.dateRangeService.setActiveRangeEnd(this.activeRangeEnd);
    this.dateRangeService.activatePopup();
  }
  deactivate() {
    this.zone.runOutsideAngular(() => {
      setTimeout(() => {
        this.updateRange(this.input.value, "blur");
        if (this.dateRangeService.hasActiveComponent()) {
          return;
        }
        this.toggleActiveClass(false);
        this.zone.run(() => this.dateRangeService.deactivatePopup());
      });
    });
  }
  updateRange(value2, correctOn) {
    const range2 = this.getRange(value2, correctOn);
    if (range2) {
      this.focusActiveDate();
      this.dateRangeService.setRange(range2);
    }
  }
  togglePopup(e) {
    const code = normalizeKeys(e);
    const altKey = e.altKey;
    if (code === Keys.Escape) {
      this.dateRangeService.cancelPopup();
    } else if (altKey && code === Keys.ArrowDown) {
      this.dateRangeService.activatePopup();
    }
  }
  focusActiveDate() {
    if (this.input.value && this.isActiveEnd) {
      this.dateRangeService.setFocusedDate(cloneDate(this.input.value));
    }
  }
  toggleActiveClass(show) {
    const action = show ? "addClass" : "removeClass";
    const nativeElement = this.element.nativeElement;
    if (nativeElement && nativeElement.querySelector) {
      this.renderer[action](nativeElement, "k-focus");
    }
  }
  static ɵfac = function DateRangeInput_Factory(__ngFactoryType__) {
    ɵɵinvalidFactory();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DateRangeInput
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateRangeInput, [{
    type: Directive,
    args: [{}]
  }], () => [{
    type: void 0
  }, {
    type: DateRangeService
  }, {
    type: DateInputComponent
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: NgZone
  }], null);
})();
var DateRangeEndInputDirective = class _DateRangeEndInputDirective extends DateRangeInput {
  rangeService;
  dateInput;
  /**
   * Specifies the auto-correction behavior. If the start date is greater than the end date, the directive fixes the date range to a single date either on input change or on blur ([see example](slug:autocorrect_daterange#toc-input-directives)).
   *
   * By default, the component does not perform any auto-correction.
   *
   */
  autoCorrectOn;
  /**
   * Specifies the navigation behavior of the calendar when the active end is changed on input focus. When enabled,
   * the calendar navigates to the value of the focused input. Otherwise, the calendar displays the last picked date.
   *
   * @default false
   */
  navigateCalendarOnFocus = false;
  constructor(rangeService, dateInput, element, renderer, zone) {
    super("end", rangeService, dateInput, element, renderer, zone);
    this.rangeService = rangeService;
    this.dateInput = dateInput;
  }
  ngOnInit() {
    this.rangeService.registerEndInput(this.dateInput);
    super.init();
    this.dateInput.pickerType = "daterangeend";
  }
  ngAfterViewInit() {
    this.renderer.setAttribute(this.dateInput.inputElement, attributeNames.ariaExpanded, "false");
  }
  ngOnDestroy() {
    super.destroy();
  }
  getRange(value2, correctOn) {
    const {
      min,
      max
    } = this.dateInput;
    if (!isInRange(value2, min, max)) {
      return null;
    }
    const {
      start
    } = this.rangeService.selectionRange || EMPTY_SELECTIONRANGE;
    const shouldClamp = this.autoCorrectOn === correctOn && isPresent4(value2) && value2 < start;
    return shouldClamp ? clampRange(value2) : {
      start,
      end: cloneDate(value2)
    };
  }
  updateInputValue(range2) {
    const {
      end
    } = range2 || EMPTY_SELECTIONRANGE;
    const {
      min,
      max
    } = this.dateInput;
    if (isEqual(this.dateInput.value, end) || !isInRange(end, min, max)) {
      return;
    }
    this.dateInput.writeValue(cloneDate(end));
    this.dateInput.notify();
  }
  static ɵfac = function DateRangeEndInputDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DateRangeEndInputDirective)(ɵɵdirectiveInject(DateRangeService), ɵɵdirectiveInject(DateInputComponent), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DateRangeEndInputDirective,
    selectors: [["", "kendoDateRangeEndInput", ""]],
    inputs: {
      autoCorrectOn: "autoCorrectOn",
      navigateCalendarOnFocus: "navigateCalendarOnFocus"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateRangeEndInputDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDateRangeEndInput]",
      standalone: true
    }]
  }], () => [{
    type: DateRangeService
  }, {
    type: DateInputComponent
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: NgZone
  }], {
    autoCorrectOn: [{
      type: Input
    }],
    navigateCalendarOnFocus: [{
      type: Input
    }]
  });
})();
var DateRangeStartInputDirective = class _DateRangeStartInputDirective extends DateRangeInput {
  rangeService;
  dateInput;
  renderer;
  /**
   * Specifies when the component automatically corrects invalid date ranges.
   * When the start date is greater than the end date, the component fixes the range to a single date either on input change or on blur ([see example](slug:autocorrect_daterange#toc-input-directives)).
   *
   * By default, the component does not perform any auto-correction.
   *
   */
  autoCorrectOn;
  /**
   * Determines how the calendar navigates when you focus on the input.
   * When you set `navigateCalendarOnFocus` to `true`, the calendar moves to the value of the focused input.
   * When you set it to `false`, the calendar shows the last selected date.
   *
   * @default false
   */
  navigateCalendarOnFocus = false;
  constructor(rangeService, dateInput, element, renderer, zone) {
    super("start", rangeService, dateInput, element, renderer, zone);
    this.rangeService = rangeService;
    this.dateInput = dateInput;
    this.renderer = renderer;
  }
  ngOnInit() {
    this.rangeService.registerStartInput(this.dateInput);
    super.init();
    this.dateInput.pickerType = "daterangestart";
  }
  ngAfterViewInit() {
    this.renderer.setAttribute(this.dateInput.inputElement, attributeNames.ariaExpanded, "false");
  }
  ngOnDestroy() {
    super.destroy();
  }
  getRange(value2, correctOn) {
    const {
      min,
      max
    } = this.dateInput;
    if (!isInRange(value2, min, max)) {
      return null;
    }
    const {
      end
    } = this.rangeService.selectionRange || EMPTY_SELECTIONRANGE;
    const shouldClamp = this.autoCorrectOn === correctOn && end && value2 > end;
    return shouldClamp ? clampRange(value2) : {
      start: cloneDate(value2),
      end
    };
  }
  updateInputValue(range2) {
    const {
      start
    } = range2 || EMPTY_SELECTIONRANGE;
    const {
      min,
      max
    } = this.dateInput;
    if (isEqual(this.dateInput.value, start) || !isInRange(start, min, max)) {
      return;
    }
    this.dateInput.writeValue(cloneDate(start));
    this.dateInput.notify();
  }
  static ɵfac = function DateRangeStartInputDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DateRangeStartInputDirective)(ɵɵdirectiveInject(DateRangeService), ɵɵdirectiveInject(DateInputComponent), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DateRangeStartInputDirective,
    selectors: [["", "kendoDateRangeStartInput", ""]],
    inputs: {
      autoCorrectOn: "autoCorrectOn",
      navigateCalendarOnFocus: "navigateCalendarOnFocus"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateRangeStartInputDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDateRangeStartInput]",
      standalone: true
    }]
  }], () => [{
    type: DateRangeService
  }, {
    type: DateInputComponent
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: NgZone
  }], {
    autoCorrectOn: [{
      type: Input
    }],
    navigateCalendarOnFocus: [{
      type: Input
    }]
  });
})();
var DatePickerCustomMessagesComponent = class _DatePickerCustomMessagesComponent extends DatePickerMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function DatePickerCustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DatePickerCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DatePickerCustomMessagesComponent,
    selectors: [["kendo-datepicker-messages"]],
    features: [ɵɵProvidersFeature([{
      provide: DatePickerMessages,
      useExisting: forwardRef(() => _DatePickerCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DatePickerCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatePickerCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: DatePickerMessages,
        useExisting: forwardRef(() => DatePickerCustomMessagesComponent)
      }],
      selector: "kendo-datepicker-messages",
      template: ``,
      standalone: true
    }]
  }], () => [{
    type: LocalizationService
  }], null);
})();
var DateRangePopupCustomMessagesComponent = class _DateRangePopupCustomMessagesComponent extends DateRangePopupMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function DateRangePopupCustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DateRangePopupCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DateRangePopupCustomMessagesComponent,
    selectors: [["kendo-daterange-popup-messages"]],
    features: [ɵɵProvidersFeature([{
      provide: DateRangePopupMessages,
      useExisting: forwardRef(() => _DateRangePopupCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DateRangePopupCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateRangePopupCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: DateRangePopupMessages,
        useExisting: forwardRef(() => DateRangePopupCustomMessagesComponent)
      }],
      selector: "kendo-daterange-popup-messages",
      template: ``,
      standalone: true
    }]
  }], () => [{
    type: LocalizationService
  }], null);
})();
var DateTimePickerCustomMessagesComponent = class _DateTimePickerCustomMessagesComponent extends DateTimePickerMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function DateTimePickerCustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DateTimePickerCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DateTimePickerCustomMessagesComponent,
    selectors: [["kendo-datetimepicker-messages"]],
    features: [ɵɵProvidersFeature([{
      provide: DateTimePickerMessages,
      useExisting: forwardRef(() => _DateTimePickerCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DateTimePickerCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateTimePickerCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: DateTimePickerMessages,
        useExisting: forwardRef(() => DateTimePickerCustomMessagesComponent)
      }],
      selector: "kendo-datetimepicker-messages",
      template: ``,
      standalone: true
    }]
  }], () => [{
    type: LocalizationService
  }], null);
})();
var TimePickerCustomMessagesComponent = class _TimePickerCustomMessagesComponent extends TimePickerMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function TimePickerCustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TimePickerCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TimePickerCustomMessagesComponent,
    selectors: [["kendo-timepicker-messages"]],
    features: [ɵɵProvidersFeature([{
      provide: TimePickerMessages,
      useExisting: forwardRef(() => _TimePickerCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function TimePickerCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimePickerCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: TimePickerMessages,
        useExisting: forwardRef(() => TimePickerCustomMessagesComponent)
      }],
      selector: "kendo-timepicker-messages",
      template: ``,
      standalone: true
    }]
  }], () => [{
    type: LocalizationService
  }], null);
})();
var KENDO_CALENDAR = [CalendarCustomMessagesComponent, CalendarComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective2, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, NavigationItemTemplateDirective];
var KENDO_MULTIVIEWCALENDAR = [MultiViewCalendarCustomMessagesComponent, MultiViewCalendarComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective2, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective];
var KENDO_DATEINPUT = [DateInputCustomMessagesComponent, DateInputComponent];
var KENDO_DATEPICKER = [DatePickerCustomMessagesComponent, DatePickerComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective2, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, NavigationItemTemplateDirective, ToggleButtonTabStopDirective];
var KENDO_DATERANGE = [DateRangePopupCustomMessagesComponent, ...KENDO_DATEINPUT, DateRangeEndInputDirective, DateRangePopupTemplateDirective, DateRangeComponent, DateRangePopupComponent, DateRangeSelectionDirective, DateRangeStartInputDirective];
var KENDO_DATETIMEPICKER = [DateTimePickerCustomMessagesComponent, DateTimePickerComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective2, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, ToggleButtonTabStopDirective];
var KENDO_TIMEPICKER = [TimePickerCustomMessagesComponent, TimePickerComponent, ToggleButtonTabStopDirective];
var KENDO_DATEINPUTS = [...KENDO_CALENDAR, ...KENDO_MULTIVIEWCALENDAR, ...KENDO_DATEINPUT, ...KENDO_DATEPICKER, ...KENDO_DATERANGE, ...KENDO_DATETIMEPICKER, ...KENDO_TIMEPICKER];
var CalendarModule = class _CalendarModule {
  static ɵfac = function CalendarModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CalendarModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _CalendarModule,
    imports: [CalendarCustomMessagesComponent, CalendarComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective2, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, NavigationItemTemplateDirective],
    exports: [CalendarCustomMessagesComponent, CalendarComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective2, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, NavigationItemTemplateDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService, ResizeBatchService, CalendarDOMService, CenturyViewService, DecadeViewService, MonthViewService, YearViewService, PopupService, NavigationService],
    imports: [CalendarComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_CALENDAR],
      imports: [...KENDO_CALENDAR],
      providers: [IconsService, ResizeBatchService, CalendarDOMService, CenturyViewService, DecadeViewService, MonthViewService, YearViewService, PopupService, NavigationService]
    }]
  }], null, null);
})();
var CalendarsModule = class _CalendarsModule {
  static ɵfac = function CalendarsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CalendarsModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _CalendarsModule,
    imports: [CalendarCustomMessagesComponent, CalendarComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective2, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, NavigationItemTemplateDirective, MultiViewCalendarCustomMessagesComponent, MultiViewCalendarComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective2, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective],
    exports: [CalendarCustomMessagesComponent, CalendarComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective2, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, NavigationItemTemplateDirective, MultiViewCalendarCustomMessagesComponent, MultiViewCalendarComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective2, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService, ResizeBatchService, CalendarDOMService, CenturyViewService, DecadeViewService, MonthViewService, YearViewService, PopupService, NavigationService],
    imports: [CalendarComponent, MultiViewCalendarComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarsModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_CALENDAR, ...KENDO_MULTIVIEWCALENDAR],
      imports: [...KENDO_CALENDAR, ...KENDO_MULTIVIEWCALENDAR],
      providers: [IconsService, ResizeBatchService, CalendarDOMService, CenturyViewService, DecadeViewService, MonthViewService, YearViewService, PopupService, NavigationService]
    }]
  }], null, null);
})();
var DateInputModule = class _DateInputModule {
  static ɵfac = function DateInputModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DateInputModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _DateInputModule,
    imports: [DateInputCustomMessagesComponent, DateInputComponent],
    exports: [DateInputCustomMessagesComponent, DateInputComponent]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService],
    imports: [DateInputComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateInputModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_DATEINPUT],
      imports: [...KENDO_DATEINPUT],
      providers: [IconsService]
    }]
  }], null, null);
})();
var DatePickerModule = class _DatePickerModule {
  static ɵfac = function DatePickerModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DatePickerModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _DatePickerModule,
    imports: [DatePickerCustomMessagesComponent, DatePickerComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective2, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, NavigationItemTemplateDirective, ToggleButtonTabStopDirective, ToggleButtonTabStopDirective],
    exports: [DatePickerCustomMessagesComponent, DatePickerComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective2, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, NavigationItemTemplateDirective, ToggleButtonTabStopDirective, ToggleButtonTabStopDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [
      // DateInputModule providers
      IconsService,
      // CalendarModule providers
      ResizeBatchService,
      CalendarDOMService,
      CenturyViewService,
      DecadeViewService,
      MonthViewService,
      YearViewService,
      PopupService,
      NavigationService,
      AdaptiveService
    ],
    imports: [DatePickerComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatePickerModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_DATEPICKER, ...KENDO_TOGGLEBUTTONTABSTOP],
      imports: [...KENDO_DATEPICKER, ...KENDO_TOGGLEBUTTONTABSTOP],
      providers: [
        // DateInputModule providers
        IconsService,
        // CalendarModule providers
        ResizeBatchService,
        CalendarDOMService,
        CenturyViewService,
        DecadeViewService,
        MonthViewService,
        YearViewService,
        PopupService,
        NavigationService,
        AdaptiveService
      ]
    }]
  }], null, null);
})();
var DateInputsModule = class _DateInputsModule {
  static ɵfac = function DateInputsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DateInputsModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _DateInputsModule,
    imports: [CalendarCustomMessagesComponent, CalendarComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective2, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, NavigationItemTemplateDirective, MultiViewCalendarCustomMessagesComponent, MultiViewCalendarComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective2, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, DateInputCustomMessagesComponent, DateInputComponent, DatePickerCustomMessagesComponent, DatePickerComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective2, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, NavigationItemTemplateDirective, ToggleButtonTabStopDirective, DateRangePopupCustomMessagesComponent, DateInputCustomMessagesComponent, DateInputComponent, DateRangeEndInputDirective, DateRangePopupTemplateDirective, DateRangeComponent, DateRangePopupComponent, DateRangeSelectionDirective, DateRangeStartInputDirective, DateTimePickerCustomMessagesComponent, DateTimePickerComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective2, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, ToggleButtonTabStopDirective, TimePickerCustomMessagesComponent, TimePickerComponent, ToggleButtonTabStopDirective, ToggleButtonTabStopDirective],
    exports: [CalendarCustomMessagesComponent, CalendarComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective2, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, NavigationItemTemplateDirective, MultiViewCalendarCustomMessagesComponent, MultiViewCalendarComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective2, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, DateInputCustomMessagesComponent, DateInputComponent, DatePickerCustomMessagesComponent, DatePickerComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective2, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, NavigationItemTemplateDirective, ToggleButtonTabStopDirective, DateRangePopupCustomMessagesComponent, DateInputCustomMessagesComponent, DateInputComponent, DateRangeEndInputDirective, DateRangePopupTemplateDirective, DateRangeComponent, DateRangePopupComponent, DateRangeSelectionDirective, DateRangeStartInputDirective, DateTimePickerCustomMessagesComponent, DateTimePickerComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective2, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, ToggleButtonTabStopDirective, TimePickerCustomMessagesComponent, TimePickerComponent, ToggleButtonTabStopDirective, ToggleButtonTabStopDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [
      // CalendarModule providers
      IconsService,
      ResizeBatchService,
      CalendarDOMService,
      CenturyViewService,
      DecadeViewService,
      MonthViewService,
      YearViewService,
      PopupService,
      NavigationService,
      // TimePickerModule providers
      TimePickerDOMService,
      HoursService,
      MinutesService,
      SecondsService,
      MillisecondsService,
      DayPeriodService,
      AdaptiveService
    ],
    imports: [CalendarComponent, MultiViewCalendarComponent, DateInputComponent, DatePickerComponent, DateInputComponent, DateRangeComponent, DateRangePopupComponent, DateTimePickerComponent, TimePickerComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateInputsModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_DATEINPUTS, ...KENDO_TOGGLEBUTTONTABSTOP],
      imports: [...KENDO_DATEINPUTS, ...KENDO_TOGGLEBUTTONTABSTOP],
      providers: [
        // CalendarModule providers
        IconsService,
        ResizeBatchService,
        CalendarDOMService,
        CenturyViewService,
        DecadeViewService,
        MonthViewService,
        YearViewService,
        PopupService,
        NavigationService,
        // TimePickerModule providers
        TimePickerDOMService,
        HoursService,
        MinutesService,
        SecondsService,
        MillisecondsService,
        DayPeriodService,
        AdaptiveService
      ]
    }]
  }], null, null);
})();
var TimePickerModule = class _TimePickerModule {
  static ɵfac = function TimePickerModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TimePickerModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _TimePickerModule,
    imports: [TimePickerCustomMessagesComponent, TimePickerComponent, ToggleButtonTabStopDirective, ToggleButtonTabStopDirective],
    exports: [TimePickerCustomMessagesComponent, TimePickerComponent, ToggleButtonTabStopDirective, ToggleButtonTabStopDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService, PopupService, ResizeBatchService, TimePickerDOMService, HoursService, MinutesService, SecondsService, MillisecondsService, DayPeriodService, AdaptiveService],
    imports: [TimePickerComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimePickerModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_TIMEPICKER, ...KENDO_TOGGLEBUTTONTABSTOP],
      imports: [...KENDO_TIMEPICKER, ...KENDO_TOGGLEBUTTONTABSTOP],
      providers: [IconsService, PopupService, ResizeBatchService, TimePickerDOMService, HoursService, MinutesService, SecondsService, MillisecondsService, DayPeriodService, AdaptiveService]
    }]
  }], null, null);
})();
var DateTimePickerModule = class _DateTimePickerModule {
  static ɵfac = function DateTimePickerModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DateTimePickerModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _DateTimePickerModule,
    imports: [DateTimePickerCustomMessagesComponent, DateTimePickerComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective2, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, ToggleButtonTabStopDirective, ToggleButtonTabStopDirective],
    exports: [DateTimePickerCustomMessagesComponent, DateTimePickerComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective2, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, ToggleButtonTabStopDirective, ToggleButtonTabStopDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [
      // CalendarModule providers
      IconsService,
      ResizeBatchService,
      CalendarDOMService,
      CenturyViewService,
      DecadeViewService,
      MonthViewService,
      YearViewService,
      PopupService,
      NavigationService,
      // TimePickerModule providers
      TimePickerDOMService,
      HoursService,
      MinutesService,
      SecondsService,
      MillisecondsService,
      DayPeriodService,
      AdaptiveService
    ],
    imports: [DateTimePickerComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateTimePickerModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_DATETIMEPICKER, ...KENDO_TOGGLEBUTTONTABSTOP],
      imports: [...KENDO_DATETIMEPICKER, ...KENDO_TOGGLEBUTTONTABSTOP],
      providers: [
        // CalendarModule providers
        IconsService,
        ResizeBatchService,
        CalendarDOMService,
        CenturyViewService,
        DecadeViewService,
        MonthViewService,
        YearViewService,
        PopupService,
        NavigationService,
        // TimePickerModule providers
        TimePickerDOMService,
        HoursService,
        MinutesService,
        SecondsService,
        MillisecondsService,
        DayPeriodService,
        AdaptiveService
      ]
    }]
  }], null, null);
})();
var MultiViewCalendarModule = class _MultiViewCalendarModule {
  static ɵfac = function MultiViewCalendarModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MultiViewCalendarModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _MultiViewCalendarModule,
    imports: [MultiViewCalendarCustomMessagesComponent, MultiViewCalendarComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective2, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective],
    exports: [MultiViewCalendarCustomMessagesComponent, MultiViewCalendarComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective2, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [PopupService, NavigationService, CenturyViewService, DecadeViewService, MonthViewService, YearViewService],
    imports: [MultiViewCalendarComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MultiViewCalendarModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_MULTIVIEWCALENDAR],
      imports: [...KENDO_MULTIVIEWCALENDAR],
      providers: [PopupService, NavigationService, CenturyViewService, DecadeViewService, MonthViewService, YearViewService]
    }]
  }], null, null);
})();
var DateRangeModule = class _DateRangeModule {
  static ɵfac = function DateRangeModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DateRangeModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _DateRangeModule,
    imports: [DateRangePopupCustomMessagesComponent, DateInputCustomMessagesComponent, DateInputComponent, DateRangeEndInputDirective, DateRangePopupTemplateDirective, DateRangeComponent, DateRangePopupComponent, DateRangeSelectionDirective, DateRangeStartInputDirective],
    exports: [DateRangePopupCustomMessagesComponent, DateInputCustomMessagesComponent, DateInputComponent, DateRangeEndInputDirective, DateRangePopupTemplateDirective, DateRangeComponent, DateRangePopupComponent, DateRangeSelectionDirective, DateRangeStartInputDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [
      // MultiViewCalendarModule providers
      PopupService,
      NavigationService,
      CenturyViewService,
      DecadeViewService,
      MonthViewService,
      YearViewService,
      // DateInputModule providers
      IconsService,
      // AdaptiveModule providers
      ResizeBatchService,
      AdaptiveService
    ],
    imports: [DateInputComponent, DateRangeComponent, DateRangePopupComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateRangeModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_DATERANGE],
      imports: [...KENDO_DATERANGE],
      providers: [
        // MultiViewCalendarModule providers
        PopupService,
        NavigationService,
        CenturyViewService,
        DecadeViewService,
        MonthViewService,
        YearViewService,
        // DateInputModule providers
        IconsService,
        // AdaptiveModule providers
        ResizeBatchService,
        AdaptiveService
      ]
    }]
  }], null, null);
})();

// node_modules/@progress/kendo-angular-progressbar/fesm2022/progress-kendo-angular-progressbar.mjs
var _c02 = ["progressStatus"];
var _c110 = ["progressStatusWrap"];
function ProgressBarComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 4);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.formattedLabelValue);
  }
}
function ProgressBarComponent_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 4);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.formattedLabelValue);
  }
}
function ChunkProgressBarComponent_For_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "li", 3);
  }
  if (rf & 2) {
    const chunk_r1 = ctx.$implicit;
    const ɵ$index_5_r2 = ctx.$index;
    const ctx_r2 = ɵɵnextContext();
    ɵɵstyleProp("width", ctx_r2.orientationStyles.width)("height", ctx_r2.orientationStyles.height);
    ɵɵclassProp("k-first", ɵ$index_5_r2 === 0)("k-last", ɵ$index_5_r2 === ctx_r2.chunkCount - 1)("k-selected", chunk_r1);
    ɵɵproperty("ngClass", chunk_r1 ? ctx_r2.progressCssClass : ctx_r2.emptyCssClass)("ngStyle", chunk_r1 ? ctx_r2.progressCssStyle : ctx_r2.emptyCssStyle);
  }
}
var _c210 = ["progress"];
var _c39 = ["scale"];
var _c42 = ["label"];
var _c52 = ["surface"];
function CircularProgressBarComponent_Conditional_11_ng_template_2_Template(rf, ctx) {
}
function CircularProgressBarComponent_Conditional_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 9, 4);
    ɵɵtemplate(2, CircularProgressBarComponent_Conditional_11_ng_template_2_Template, 0, 0, "ng-template", 11);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.centerTemplate.templateRef)("ngTemplateOutletContext", ctx_r1.centerTemplateContext);
  }
}
var packageMetadata2 = {
  name: "@progress/kendo-angular-progressbar",
  productName: "Kendo UI for Angular",
  productCode: "KENDOUIANGULAR",
  productCodes: ["KENDOUIANGULAR"],
  publishDate: 0,
  version: "22.0.1",
  licensingDocsUrl: "https://www.telerik.com/kendo-angular-ui/my-license/"
};
var MIN_MAX_ERROR_MESSAGE = `The max value should be greater than the min.`;
var LABEL_DECIMALS = 3;
var MIN_RATIO = 1e-4;
var formatValue = (value2, min, max, label) => {
  const defaultFormattedValue = truncateNumber(value2);
  if (typeof label !== "boolean") {
    if (typeof label.format === "string") {
      switch (label.format) {
        case "value":
          return defaultFormattedValue;
        case "percent":
          return `${Math.floor(calculatePercentage(value2, min, max))}%`;
        default:
          return defaultFormattedValue;
      }
    } else if (typeof label.format === "function") {
      return label.format(value2);
    } else {
      return defaultFormattedValue;
    }
  }
  return defaultFormattedValue;
};
var validateRange = (min, max) => {
  if (isDevMode && min > max) {
    throw new Error(MIN_MAX_ERROR_MESSAGE);
  }
};
var adjustValueToRange = (min, max, value2) => Math.max(Math.min(value2, max), min);
var calculatePercentage = (value2, min, max) => {
  const decimalValue = Math.abs((value2 - min) / (max - min));
  return decimalValue * 100;
};
var truncateNumber = (value2) => {
  const numberParts = value2.toString().split(".");
  return numberParts.length === 1 ? `${numberParts[0]}` : `${numberParts[0]}.${numberParts[1].substr(0, LABEL_DECIMALS)}`;
};
var calculateRatio = (min, max, value2) => Math.max((value2 - min) / (max - min), MIN_RATIO);
var extractValueFromChanges = (changes, type, value2) => changes[type] && changes[type].currentValue !== void 0 ? changes[type].currentValue : value2;
var runAnimation = (changes, animation, previousValue, displayValue) => animation && typeof requestAnimationFrame !== "undefined" && changes["value"] && previousValue !== displayValue;
var stopCurrentAnimation = (changes) => {
  const isAnimationChanged = Boolean(changes["animation"]);
  const hasAnimation = isAnimationChanged && changes["animation"].currentValue;
  return isAnimationChanged && !hasAnimation;
};
var setProgressBarStyles = (props, renderer) => {
  props.forEach((prop2) => {
    renderer[prop2.method](prop2.el, prop2.attr, `${prop2.attrValue}`);
  });
};
var removeProgressBarStyles = (props, renderer) => {
  props.forEach((prop2) => {
    renderer[prop2.method](prop2.el, prop2.attr);
  });
};
var hasElementSize = (element) => {
  return !!(element.style.width && element.style.height);
};
var ProgressBarBase = class _ProgressBarBase {
  elem;
  renderer;
  localization;
  hostClasses = true;
  get isHorizontal() {
    return this.orientation === "horizontal";
  }
  get isVertical() {
    return this.orientation === "vertical";
  }
  get disabledClass() {
    return this.disabled;
  }
  get reverseClass() {
    return this.reverse;
  }
  get indeterminateClass() {
    return this.indeterminate;
  }
  get dirAttribute() {
    return this.direction;
  }
  roleAttribute = "progressbar";
  get ariaMinAttribute() {
    return String(this.min);
  }
  get ariaMaxAttribute() {
    return String(this.max);
  }
  get ariaValueAttribute() {
    return this.indeterminate ? void 0 : String(this.displayValue);
  }
  /**
   * The maximum value of the ProgressBar.
   * Defaults to `100`.
   */
  max = 100;
  /**
   * The minimum value of the ProgressBar.
   * Defaults to `0`.
   */
  min = 0;
  /**
   * The value of the ProgressBar.
   * Has to be between `min` and `max`.
   * By default, the value is equal to the `min` value.
   */
  /**
   * The value of the ProgressBar.
   * Has to be between `min` and `max`.
   * Defaults to `0`.
   */
  value = 0;
  /**
   * @hidden
   */
  get isCompleted() {
    return this.value === this.max;
  }
  /**
   * @hidden
   */
  get statusWidth() {
    return this.orientation === "horizontal" ? this._progressRatio * 100 : 100;
  }
  /**
   * @hidden
   */
  get statusHeight() {
    return this.orientation === "vertical" ? this._progressRatio * 100 : 100;
  }
  /**
   * @hidden
   */
  get statusWrapperWidth() {
    return this.orientation === "horizontal" ? 100 / this._progressRatio : 100;
  }
  /**
   * @hidden
   */
  get statusWrapperHeight() {
    return this.orientation === "vertical" ? 100 / this._progressRatio : 100;
  }
  get _progressRatio() {
    return calculateRatio(this.min, this.max, this.displayValue);
  }
  /**
   * Defines the orientation of the ProgressBar
   * ([see example]({% slug progressbar_orientation %})).
   * Defaults to `horizontal`.
   */
  orientation = "horizontal";
  /**
   * If set to `true`, the ProgressBar will be disabled
   * ([see example]({% slug progressbar_disabled %})).
   * It will still allow you to change its value.
   * Defaults to `false`.
   */
  disabled = false;
  /**
   * If set to `true`, the ProgressBar will be reversed
   * ([see example]({% slug progressbar_direction %})).
   * Defaults to `false`.
   */
  reverse = false;
  /**
   * Sets the `indeterminate` state of the ProgressBar.
   * Defaults to `false`.
   */
  indeterminate = false;
  direction;
  localizationChangeSubscription;
  displayValue = 0;
  previousValue = 0;
  /**
   * @hidden
   */
  constructor(elem, renderer, localization) {
    this.elem = elem;
    this.renderer = renderer;
    this.localization = localization;
    N(packageMetadata2);
    this.localizationChangeSubscription = localization.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
    });
  }
  ngAfterViewInit() {
    const elem = this.elem.nativeElement;
    const label = this.localization.get("progressBarLabel");
    this.renderer.setAttribute(elem, "aria-label", label);
  }
  ngOnChanges(changes) {
    const min = extractValueFromChanges(changes, "min", this.min);
    const max = extractValueFromChanges(changes, "max", this.max);
    const value2 = extractValueFromChanges(changes, "value", this.value);
    if (changes["min"] || changes["max"] || changes["value"]) {
      if (changes["min"] || changes["max"]) {
        validateRange(min, max);
      }
      if (changes["value"]) {
        if (value2 == null || Number.isNaN(value2)) {
          this.value = min;
        }
        const previousValue = this.displayValue;
        this.displayValue = adjustValueToRange(this.min, this.max, value2);
        this.previousValue = previousValue;
      }
      this.min = min;
      this.max = max;
      this.displayValue = adjustValueToRange(this.min, this.max, value2);
    }
  }
  ngOnDestroy() {
    if (this.localizationChangeSubscription) {
      this.localizationChangeSubscription.unsubscribe();
    }
  }
  static ɵfac = function ProgressBarBase_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ProgressBarBase)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ProgressBarBase,
    selectors: [["ng-component"]],
    hostVars: 17,
    hostBindings: function ProgressBarBase_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.dirAttribute)("role", ctx.roleAttribute)("aria-valuemin", ctx.ariaMinAttribute)("aria-valuemax", ctx.ariaMaxAttribute)("aria-valuenow", ctx.ariaValueAttribute);
        ɵɵclassProp("k-progressbar", ctx.hostClasses)("k-progressbar-horizontal", ctx.isHorizontal)("k-progressbar-vertical", ctx.isVertical)("k-disabled", ctx.disabledClass)("k-progressbar-reverse", ctx.reverseClass)("k-progressbar-indeterminate", ctx.indeterminateClass);
      }
    },
    inputs: {
      max: "max",
      min: "min",
      value: "value",
      orientation: "orientation",
      disabled: "disabled",
      reverse: "reverse",
      indeterminate: "indeterminate"
    },
    features: [ɵɵNgOnChangesFeature],
    decls: 0,
    vars: 0,
    template: function ProgressBarBase_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProgressBarBase, [{
    type: Component,
    args: [{
      template: ""
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: LocalizationService
  }], {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-progressbar"]
    }],
    isHorizontal: [{
      type: HostBinding,
      args: ["class.k-progressbar-horizontal"]
    }],
    isVertical: [{
      type: HostBinding,
      args: ["class.k-progressbar-vertical"]
    }],
    disabledClass: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    reverseClass: [{
      type: HostBinding,
      args: ["class.k-progressbar-reverse"]
    }],
    indeterminateClass: [{
      type: HostBinding,
      args: ["class.k-progressbar-indeterminate"]
    }],
    dirAttribute: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    roleAttribute: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    ariaMinAttribute: [{
      type: HostBinding,
      args: ["attr.aria-valuemin"]
    }],
    ariaMaxAttribute: [{
      type: HostBinding,
      args: ["attr.aria-valuemax"]
    }],
    ariaValueAttribute: [{
      type: HostBinding,
      args: ["attr.aria-valuenow"]
    }],
    max: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    orientation: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    reverse: [{
      type: Input
    }],
    indeterminate: [{
      type: Input
    }]
  });
})();
var ProgressBarMessages = class _ProgressBarMessages extends ComponentMessages {
  /**
   * The aria-label attribute for the ProgressBar component.
   */
  progressBarLabel;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵProgressBarMessages_BaseFactory;
    return function ProgressBarMessages_Factory(__ngFactoryType__) {
      return (ɵProgressBarMessages_BaseFactory || (ɵProgressBarMessages_BaseFactory = ɵɵgetInheritedFactory(_ProgressBarMessages)))(__ngFactoryType__ || _ProgressBarMessages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _ProgressBarMessages,
    inputs: {
      progressBarLabel: "progressBarLabel"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProgressBarMessages, [{
    type: Directive,
    args: [{}]
  }], null, {
    progressBarLabel: [{
      type: Input
    }]
  });
})();
var LocalizedProgressBarMessagesDirective = class _LocalizedProgressBarMessagesDirective extends ProgressBarMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function LocalizedProgressBarMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LocalizedProgressBarMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LocalizedProgressBarMessagesDirective,
    selectors: [["", "kendoProgressBarLocalizedMessages", ""]],
    features: [ɵɵProvidersFeature([{
      provide: ProgressBarMessages,
      useExisting: forwardRef(() => _LocalizedProgressBarMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalizedProgressBarMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: ProgressBarMessages,
        useExisting: forwardRef(() => LocalizedProgressBarMessagesDirective)
      }],
      selector: `[kendoProgressBarLocalizedMessages]`,
      standalone: true
    }]
  }], () => [{
    type: LocalizationService
  }], null);
})();
var ProgressBarComponent = class _ProgressBarComponent extends ProgressBarBase {
  localization;
  elem;
  renderer;
  zone;
  /**
   * Determines whether the status label displays.
   * @default true
   */
  label = true;
  /**
   * Sets the CSS styles that will be rendered on the inner element, which represents the full portion of the progress bar
   * ([see example]({% slug progressbar_appearance %})).
   * Supports the type of values that [`ngStyle`](link:site.data.urls.angular['ngstyleapi']) supports.
   */
  progressCssStyle;
  /**
   * The CSS classes that render on the inner element which represents the full portion of the progress bar
   * ([see example]({% slug progressbar_appearance %})).
   * Supports the type of values that [`ngClass`](link:site.data.urls.angular['ngclassapi']) supports.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  progressCssClass;
  /**
   * The CSS styles that render on the inner element which represents the empty portion of the progress bar
   * ([see example]({% slug progressbar_appearance %})).
   * Supports the type of values that [`ngStyle`](link:site.data.urls.angular['ngstyleapi']) supports.
   */
  emptyCssStyle;
  /**
   * The CSS classes that render on the inner element which represents the empty portion of the progress bar
   * ([see example]({% slug progressbar_appearance %})).
   * Supports the type of values that [`ngClass`](link:site.data.urls.angular['ngclassapi']) supports.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  emptyCssClass;
  /**
   * The animation configuration of the ProgressBar.
   * @default false
   */
  animation = false;
  /**
   * Fires when the animation which indicates the latest value change completes.
   */
  animationEnd = new EventEmitter();
  /**
   * @hidden
   */
  get showLabel() {
    if (typeof this.label === "boolean") {
      return this.label;
    } else {
      if (this.label && !this.label.hasOwnProperty("visible")) {
        this.label.visible = true;
      }
      return this.label.visible;
    }
  }
  /**
   * @hidden
   */
  get labelPosition() {
    if (typeof this.label === "boolean") {
      return "end";
    } else {
      if (this.label && !this.label.hasOwnProperty("position")) {
        this.label.position = "end";
      }
      return this.label.position;
    }
  }
  /**
   * @hidden
   */
  get isPositionStart() {
    return this.labelPosition === "start";
  }
  /**
   * @hidden
   */
  get isPositionCenter() {
    return this.labelPosition === "center";
  }
  /**
   * @hidden
   */
  get isPositionEnd() {
    return this.labelPosition === "end";
  }
  /**
   * @hidden
   */
  get formattedLabelValue() {
    return formatValue(this.displayValue, this.min, this.max, this.label);
  }
  progressStatusElement;
  progressStatusWrapperElement;
  animationFrame;
  cancelCurrentAnimation;
  isAnimationInProgress;
  /**
   * @hidden
   */
  constructor(localization, elem, renderer, zone) {
    super(elem, renderer, localization);
    this.localization = localization;
    this.elem = elem;
    this.renderer = renderer;
    this.zone = zone;
  }
  /**
   * @hidden
   */
  ngOnChanges(changes) {
    super.ngOnChanges(changes);
    if (this.isAnimationInProgress && stopCurrentAnimation(changes)) {
      this.cancelCurrentAnimation = true;
    }
    if (runAnimation(changes, this.animation, this.previousValue, this.displayValue) && !changes["value"].firstChange) {
      this.startAnimation(this.previousValue);
    }
  }
  /**
   * @hidden
   */
  ngOnDestroy() {
    if (this.animationFrame) {
      cancelAnimationFrame(this.animationFrame);
    }
  }
  /**
   * @hidden
   */
  startAnimation(previousValue) {
    this.isAnimationInProgress = true;
    const element = this.progressStatusElement.nativeElement;
    const wrapperElement = this.progressStatusWrapperElement.nativeElement;
    const animationOptions = this.getAnimationOptions(previousValue);
    this.zone.runOutsideAngular(() => {
      if (this.animationFrame) {
        cancelAnimationFrame(this.animationFrame);
      }
      const animate2 = () => {
        const elapsed = (/* @__PURE__ */ new Date()).getTime() - animationOptions.startTime;
        const position2 = Math.min(elapsed / animationOptions.duration, 1);
        const size = animationOptions.startSize + animationOptions.deltaSize * position2;
        const wrapperSize = 100 / size * 100;
        this.renderValueChange(element, wrapperElement, animationOptions.property, size, wrapperSize);
        if (position2 < 1) {
          if (this.cancelCurrentAnimation) {
            this.resetProgress(element, wrapperElement, animationOptions.property);
            return;
          }
          this.animationFrame = requestAnimationFrame(animate2);
        } else {
          this.stopAnimation(previousValue);
        }
      };
      animate2();
    });
  }
  /**
   * @hidden
   */
  get animationDuration() {
    if (typeof this.animation === "boolean") {
      return 400;
    } else {
      if (this.animation && !this.animation.hasOwnProperty("duration")) {
        this.animation.duration = 400;
      }
      return this.animation.duration;
    }
  }
  stopAnimation(value2) {
    if (hasObservers(this.animationEnd)) {
      this.zone.run(() => {
        this.animationEnd.emit({
          from: value2,
          to: this.displayValue
        });
      });
    }
    this.zone.run(() => {
      this.isAnimationInProgress = false;
    });
  }
  getAnimationOptions(value2) {
    const isHorizontal = this.orientation === "horizontal";
    const previousRatio = calculateRatio(this.min, this.max, value2);
    const previousStatusWidth = isHorizontal ? previousRatio * 100 : 100;
    const previousStatusHeight = !isHorizontal ? previousRatio * 100 : 100;
    const property = isHorizontal ? "width" : "height";
    const startTime = (/* @__PURE__ */ new Date()).getTime();
    const startSize = isHorizontal ? previousStatusWidth : previousStatusHeight;
    const deltaSize = isHorizontal ? this.statusWidth - previousStatusWidth : this.statusHeight - previousStatusHeight;
    const duration = this.animationDuration * Math.abs(deltaSize / 100);
    return {
      property,
      startTime,
      startSize,
      deltaSize,
      duration
    };
  }
  renderValueChange(element, wrapperElement, property, size, wrapperSize) {
    this.renderer.setStyle(element, property, size + "%");
    this.renderer.setStyle(wrapperElement, property, wrapperSize + "%");
  }
  resetProgress(element, wrapperElement, property) {
    const size = calculateRatio(this.min, this.max, this.value);
    const newSize = size * 100;
    const newWrapperSize = 100 / size;
    this.renderValueChange(element, wrapperElement, property, newSize, newWrapperSize);
    this.zone.run(() => {
      this.cancelCurrentAnimation = false;
      this.isAnimationInProgress = false;
    });
  }
  static ɵfac = function ProgressBarComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ProgressBarComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ProgressBarComponent,
    selectors: [["kendo-progressbar"]],
    viewQuery: function ProgressBarComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c02, 5)(_c110, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.progressStatusElement = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.progressStatusWrapperElement = _t.first);
      }
    },
    inputs: {
      label: "label",
      progressCssStyle: "progressCssStyle",
      progressCssClass: "progressCssClass",
      emptyCssStyle: "emptyCssStyle",
      emptyCssClass: "emptyCssClass",
      animation: "animation"
    },
    outputs: {
      animationEnd: "animationEnd"
    },
    exportAs: ["kendoProgressBar"],
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.progressbar"
    }]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
    decls: 8,
    vars: 28,
    consts: () => {
      let i18n_0;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PROGRESSBAR_FESM2022_PROGRESS_KENDO_ANGULAR_PROGRESSBAR_MJS_0 = goog.getMsg("Progressbar");
        i18n_0 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PROGRESSBAR_FESM2022_PROGRESS_KENDO_ANGULAR_PROGRESSBAR_MJS_0;
      } else {
        i18n_0 = $localize`:kendo.progressbar.progressBarLabel|The aria-label attribute for the ProgressBar component.:Progressbar`;
      }
      return [["progressStatus", ""], ["progressStatusWrap", ""], ["kendoProgressBarLocalizedMessages", "", "progressBarLabel", i18n_0], [1, "k-progress-status-wrap", 3, "ngStyle", "ngClass"], [1, "k-progress-status"], [1, "k-selected", "k-progressbar-value", 3, "ngStyle", "ngClass"], [1, "k-progress-status-wrap"]];
    },
    template: function ProgressBarComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainer(0, 2);
        ɵɵelementStart(1, "span", 3);
        ɵɵconditionalCreate(2, ProgressBarComponent_Conditional_2_Template, 2, 1, "span", 4);
        ɵɵelementEnd();
        ɵɵelementStart(3, "div", 5, 0)(5, "span", 6, 1);
        ɵɵconditionalCreate(7, ProgressBarComponent_Conditional_7_Template, 2, 1, "span", 4);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵclassProp("k-progress-start", ctx.isPositionStart)("k-progress-center", ctx.isPositionCenter)("k-progress-end", ctx.isPositionEnd);
        ɵɵproperty("ngStyle", ctx.emptyCssStyle)("ngClass", ctx.emptyCssClass);
        ɵɵadvance();
        ɵɵconditional(ctx.showLabel ? 2 : -1);
        ɵɵadvance();
        ɵɵstyleProp("width", ctx.statusWidth, "%")("height", ctx.statusHeight, "%");
        ɵɵclassProp("k-complete", ctx.isCompleted);
        ɵɵproperty("ngStyle", ctx.progressCssStyle)("ngClass", ctx.progressCssClass);
        ɵɵadvance(2);
        ɵɵstyleProp("width", ctx.statusWrapperWidth, "%")("height", ctx.statusWrapperHeight, "%");
        ɵɵclassProp("k-progress-start", ctx.isPositionStart)("k-progress-center", ctx.isPositionCenter)("k-progress-end", ctx.isPositionEnd);
        ɵɵadvance(2);
        ɵɵconditional(ctx.showLabel ? 7 : -1);
      }
    },
    dependencies: [LocalizedProgressBarMessagesDirective, NgStyle, NgClass],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProgressBarComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoProgressBar",
      selector: "kendo-progressbar",
      template: `
        <ng-container kendoProgressBarLocalizedMessages
          i18n-progressBarLabel="kendo.progressbar.progressBarLabel|The aria-label attribute for the ProgressBar component."
          progressBarLabel="Progressbar"
          >
        </ng-container>
        <span class="k-progress-status-wrap"
          [class.k-progress-start]="isPositionStart"
          [class.k-progress-center]="isPositionCenter"
          [class.k-progress-end]="isPositionEnd"
          [ngStyle]="emptyCssStyle"
          [ngClass]="emptyCssClass">
          @if (showLabel) {
            <span class="k-progress-status">{{formattedLabelValue}}</span>
          }
        </span>
        <div
          #progressStatus
          class="k-selected k-progressbar-value"
          [class.k-complete]="isCompleted"
          [ngStyle]="progressCssStyle"
          [ngClass]="progressCssClass"
          [style.width.%]="statusWidth"
          [style.height.%]="statusHeight"
          >
          <span
            #progressStatusWrap
            class="k-progress-status-wrap"
            [style.width.%]="statusWrapperWidth"
            [style.height.%]="statusWrapperHeight"
            [class.k-progress-start]="isPositionStart"
            [class.k-progress-center]="isPositionCenter"
            [class.k-progress-end]="isPositionEnd"
            >
            @if (showLabel) {
              <span class="k-progress-status">{{formattedLabelValue}}</span>
            }
          </span>
        </div>
        `,
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.progressbar"
      }],
      standalone: true,
      imports: [LocalizedProgressBarMessagesDirective, NgStyle, NgClass]
    }]
  }], () => [{
    type: LocalizationService
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: NgZone
  }], {
    label: [{
      type: Input
    }],
    progressCssStyle: [{
      type: Input
    }],
    progressCssClass: [{
      type: Input
    }],
    emptyCssStyle: [{
      type: Input
    }],
    emptyCssClass: [{
      type: Input
    }],
    animation: [{
      type: Input
    }],
    animationEnd: [{
      type: Output
    }],
    progressStatusElement: [{
      type: ViewChild,
      args: ["progressStatus", {
        static: false
      }]
    }],
    progressStatusWrapperElement: [{
      type: ViewChild,
      args: ["progressStatusWrap", {
        static: false
      }]
    }]
  });
})();
var ChunkProgressBarComponent = class _ChunkProgressBarComponent extends ProgressBarBase {
  localization;
  elem;
  renderer;
  chunkClass = true;
  /**
   * Sets the number of chunks into which the ChunkProgressBar will be split.
   *
   * @default 5
   */
  chunkCount = 5;
  /**
   * @hidden
   */
  get chunks() {
    const count2 = this.chunkCount;
    const chunks = Array(count2).fill(false);
    const completedChunks = Math.floor(this._progressRatio * count2);
    for (let i = 0; i < completedChunks; i++) {
      chunks[i] = true;
    }
    return chunks;
  }
  /**
   * Sets the CSS styles that will be rendered on the full chunk elements ([see example]({% slug chunkprogressbar_appearance %})).
   * Supports the type of values that [`ngStyle`](link:site.data.urls.angular['ngstyleapi']) supports.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  progressCssStyle;
  /**
   * Sets the CSS classes that will be rendered on the full chunk elements ([see example]({% slug chunkprogressbar_appearance %})).
   * Supports the type of values that [`ngClass`](link:site.data.urls.angular['ngclassapi']) supports.
   */
  progressCssClass;
  /**
   * Sets the CSS styles that will be rendered on the empty chunk elements ([see example]({% slug chunkprogressbar_appearance %})).
   * Supports the type of values that [`ngStyle`](link:site.data.urls.angular['ngstyleapi']) supports.
   */
  emptyCssStyle;
  /**
   * Sets the CSS classes that will be rendered on the empty chunk elements ([see example]({% slug chunkprogressbar_appearance %})).
   * Supports the type of values that [`ngClass`](link:site.data.urls.angular['ngclassapi']) supports.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  emptyCssClass;
  /**
   * @hidden
   */
  get chunkSizePercentage() {
    return 100 / this.chunkCount;
  }
  /**
   * @hidden
   */
  get orientationStyles() {
    if (this.orientation === "horizontal") {
      this._orientationStyles.width = `${this.chunkSizePercentage}%`;
      this._orientationStyles.height = null;
    } else {
      this._orientationStyles.height = `${this.chunkSizePercentage}%`;
      this._orientationStyles.width = null;
    }
    return this._orientationStyles;
  }
  _orientationStyles = {
    width: `${this.chunkSizePercentage}%`,
    height: null
  };
  /**
   * @hidden
   */
  constructor(localization, elem, renderer) {
    super(elem, renderer, localization);
    this.localization = localization;
    this.elem = elem;
    this.renderer = renderer;
  }
  static ɵfac = function ChunkProgressBarComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ChunkProgressBarComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ChunkProgressBarComponent,
    selectors: [["kendo-chunkprogressbar"]],
    hostVars: 2,
    hostBindings: function ChunkProgressBarComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-chunk-progressbar", ctx.chunkClass);
      }
    },
    inputs: {
      chunkCount: "chunkCount",
      progressCssStyle: "progressCssStyle",
      progressCssClass: "progressCssClass",
      emptyCssStyle: "emptyCssStyle",
      emptyCssClass: "emptyCssClass"
    },
    exportAs: ["kendoChunkProgressBar"],
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.chunkprogressbar"
    }]), ɵɵInheritDefinitionFeature],
    decls: 4,
    vars: 0,
    consts: () => {
      let i18n_1;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PROGRESSBAR_FESM2022_PROGRESS_KENDO_ANGULAR_PROGRESSBAR_MJS_1 = goog.getMsg("Chunk progressbar");
        i18n_1 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PROGRESSBAR_FESM2022_PROGRESS_KENDO_ANGULAR_PROGRESSBAR_MJS_1;
      } else {
        i18n_1 = $localize`:kendo.chunkprogressbar.progressBarLabel|The aria-label attribute for the ChunkProgressBar component.:Chunk progressbar`;
      }
      return [["kendoProgressBarLocalizedMessages", "", "progressBarLabel", i18n_1], [1, "k-reset", "k-progressbar-chunks"], [1, "k-progressbar-chunk", 3, "k-first", "k-last", "k-selected", "ngClass", "ngStyle", "width", "height"], [1, "k-progressbar-chunk", 3, "ngClass", "ngStyle"]];
    },
    template: function ChunkProgressBarComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainer(0, 0);
        ɵɵelementStart(1, "ul", 1);
        ɵɵrepeaterCreate(2, ChunkProgressBarComponent_For_3_Template, 1, 12, "li", 2, ɵɵrepeaterTrackByIndex);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance(2);
        ɵɵrepeater(ctx.chunks);
      }
    },
    dependencies: [LocalizedProgressBarMessagesDirective, NgClass, NgStyle],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChunkProgressBarComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoChunkProgressBar",
      selector: "kendo-chunkprogressbar",
      template: `
        <ng-container kendoProgressBarLocalizedMessages
          i18n-progressBarLabel="kendo.chunkprogressbar.progressBarLabel|The aria-label attribute for the ChunkProgressBar component."
          progressBarLabel="Chunk progressbar"
          >
        </ng-container>
        <ul class="k-reset k-progressbar-chunks">
          @for (chunk of chunks; track $index; let i = $index) {
            <li class="k-progressbar-chunk"
              [class.k-first]="i === 0"
              [class.k-last]="i === chunkCount - 1"
              [class.k-selected]="chunk"
              [ngClass]="chunk ? progressCssClass : emptyCssClass"
              [ngStyle]="chunk ? progressCssStyle : emptyCssStyle"
              [style.width]="orientationStyles.width"
              [style.height]="orientationStyles.height"
              >
            </li>
          }
        </ul>
        `,
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.chunkprogressbar"
      }],
      standalone: true,
      imports: [LocalizedProgressBarMessagesDirective, NgClass, NgStyle]
    }]
  }], () => [{
    type: LocalizationService
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }], {
    chunkClass: [{
      type: HostBinding,
      args: ["class.k-chunk-progressbar"]
    }],
    chunkCount: [{
      type: Input
    }],
    progressCssStyle: [{
      type: Input
    }],
    progressCssClass: [{
      type: Input
    }],
    emptyCssStyle: [{
      type: Input
    }],
    emptyCssClass: [{
      type: Input
    }]
  });
})();
var CircularProgressbarCenterTemplateDirective = class _CircularProgressbarCenterTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function CircularProgressbarCenterTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CircularProgressbarCenterTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CircularProgressbarCenterTemplateDirective,
    selectors: [["", "kendoCircularProgressbarCenterTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CircularProgressbarCenterTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoCircularProgressbarCenterTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var DEFAULT_SURFACE_SIZE = 200;
var CircularProgressBarComponent = class _CircularProgressBarComponent {
  renderer;
  cdr;
  localization;
  element;
  zone;
  hostClasses = true;
  get ariaMinAttribute() {
    return String(this.min);
  }
  get ariaMaxAttribute() {
    return String(this.max);
  }
  get ariaValueAttribute() {
    return this.indeterminate ? void 0 : String(this.value);
  }
  roleAttribute = "progressbar";
  /**
   * Sets the default value of the Circular ProgressBar between `min` and `max`.
   *
   * @default 0
   */
  set value(value2) {
    if (value2 > this.max) {
      this.handleErrors("value > max");
    }
    if (value2 < this.min) {
      this.handleErrors("value < min");
    }
    this.previousValue = this.value;
    this._value = value2;
  }
  get value() {
    return this._value;
  }
  /**
   * Sets the maximum value which the Circular ProgressBar can accept.
   *
   * @default 100
   */
  set max(max) {
    if (max < this.min) {
      this.handleErrors("max < min");
    }
    this._max = max;
  }
  get max() {
    return this._max;
  }
  /**
   * Sets the minimum value which the Circular ProgressBar can accept.
   *
   * @default 0
   */
  set min(min) {
    if (min > this.max) {
      this.handleErrors("max < min");
    }
    this._min = min;
  }
  get min() {
    return this._min;
  }
  /**
   * Specifies whether to play an animation when the value changes.
   *
   * @default false
   */
  animation = false;
  /**
   * Sets the opacity of the value arc.
   *
   * @default 1
   */
  opacity = 1;
  /**
   * Puts the Circular ProgressBar in indeterminate state.
   *
   * @default false
   */
  set indeterminate(indeterminate) {
    this._indeterminate = indeterminate;
  }
  get indeterminate() {
    return this._indeterminate;
  }
  /**
   * Configures the pointer color. You can set it to a single color string or customize it per progress stages.
   */
  progressColor;
  /**
   * Fires when the animation that indicates the latest value change completes.
   */
  animationEnd = new EventEmitter();
  progress;
  scale;
  labelElement;
  surface;
  centerTemplate;
  centerTemplateContext = {};
  _indeterminate = false;
  _max = 100;
  _min = 0;
  _value = 0;
  previousValue = 0;
  internalValue = 0;
  rtl;
  subscriptions = new Subscription();
  constructor(renderer, cdr, localization, element, zone) {
    this.renderer = renderer;
    this.cdr = cdr;
    this.localization = localization;
    this.element = element;
    this.zone = zone;
    N(packageMetadata2);
    this.subscriptions.add(this.localization.changes.subscribe(this.rtlChange.bind(this)));
  }
  ngAfterViewInit() {
    if (!isDocumentAvailable()) {
      return;
    }
    const elem = this.element.nativeElement;
    const ariaLabel = this.localization.get("progressBarLabel");
    this.renderer.setAttribute(elem, "aria-label", ariaLabel);
    this.initProgressArc();
  }
  ngOnChanges(changes) {
    const skipFirstChange = true;
    if (isChanged("value", changes, skipFirstChange) && this.progress) {
      if (this.animation) {
        this.progressbarAnimation();
      } else {
        const value2 = this.value - this.min;
        this.internalValue = changes["value"].currentValue;
        this.calculateProgress(value2);
      }
    }
    if (changes["opacity"] && this.progress) {
      setProgressBarStyles([{
        method: "setAttribute",
        el: this.progress.nativeElement,
        attr: "opacity",
        attrValue: this.opacity.toString()
      }], this.renderer);
    }
    if (changes["indeterminate"] && !changes["indeterminate"].firstChange) {
      this.indeterminateState();
    }
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  /**
   * @hidden
   */
  onResize() {
    this.setStyles();
    const value2 = this.animation ? this.internalValue : this.value;
    this.calculateProgress(value2);
    this.updateCenterTemplate(value2);
  }
  initProgressArc() {
    this.setStyles();
    if (this.indeterminate) {
      this.indeterminateState();
    } else {
      if (!this.animation) {
        const value2 = this.value - this.min;
        this.calculateProgress(value2);
      } else {
        this.progressbarAnimation();
      }
    }
  }
  calculateProgress(value2) {
    if (this.progressColor) {
      this.updateProgressColor(value2);
    }
    this.zone.onStable.pipe(take(1)).subscribe(() => {
      this.updateCenterTemplate(value2 + this.min);
    });
    const progressArc = this.progress.nativeElement;
    const radius = this.progress.nativeElement.r.baseVal.value;
    const circumference = Math.PI * (radius * 2);
    const dir = this.rtl ? circumference * -1 : circumference;
    const strokeDashOffest = circumference - dir * (value2 / (this.max - this.min));
    const progressCalculations = [{
      method: "setStyle",
      el: progressArc,
      attr: "strokeDasharray",
      attrValue: circumference.toString()
    }, {
      method: "setStyle",
      el: progressArc,
      attr: "strokeDashoffset",
      attrValue: strokeDashOffest.toString()
    }];
    setProgressBarStyles(progressCalculations, this.renderer);
  }
  progressbarAnimation() {
    const forwardProgress = {
      isOngoing: this.internalValue > this.value - this.min,
      isPositive: this.value >= this.previousValue
    };
    const backwardProgress = {
      isOngoing: this.internalValue < this.value - this.min,
      isNegative: this.value <= this.previousValue
    };
    if (forwardProgress.isOngoing && forwardProgress.isPositive || backwardProgress.isOngoing && backwardProgress.isNegative) {
      return;
    }
    this.calculateProgress(this.internalValue);
    const from2 = this.internalValue;
    if (hasObservers(this.animationEnd)) {
      this.animationEnd.emit({
        from: from2,
        to: this.internalValue
      });
    }
    if (forwardProgress.isPositive) {
      this.internalValue += 1;
    } else {
      this.internalValue -= 1;
    }
    requestAnimationFrame(this.progressbarAnimation.bind(this));
  }
  setStyles() {
    const progressArc = this.progress.nativeElement;
    const scale = this.scale.nativeElement;
    const surface = this.surface.nativeElement;
    const element = this.element.nativeElement;
    let elWidth = element.getBoundingClientRect().width;
    if (!hasElementSize(element)) {
      const surfaceSize = [{
        method: "setStyle",
        el: surface,
        attr: "width",
        attrValue: `${DEFAULT_SURFACE_SIZE}px`
      }, {
        method: "setStyle",
        el: surface,
        attr: "height",
        attrValue: `${DEFAULT_SURFACE_SIZE}px`
      }];
      elWidth = DEFAULT_SURFACE_SIZE;
      setProgressBarStyles(surfaceSize, this.renderer);
    }
    const attributesArray = [{
      method: "setAttribute",
      el: progressArc,
      attr: "r",
      attrValue: String(elWidth / 2 - 10)
    }, {
      method: "setAttribute",
      el: progressArc,
      attr: "cx",
      attrValue: String(elWidth / 2)
    }, {
      method: "setAttribute",
      el: progressArc,
      attr: "cy",
      attrValue: String(elWidth / 2)
    }, {
      method: "setAttribute",
      el: progressArc,
      attr: "opacity",
      attrValue: String(this.opacity)
    }, {
      method: "setAttribute",
      el: scale,
      attr: "r",
      attrValue: String(elWidth / 2 - 10)
    }, {
      method: "setAttribute",
      el: scale,
      attr: "cx",
      attrValue: String(elWidth / 2)
    }, {
      method: "setAttribute",
      el: scale,
      attr: "cy",
      attrValue: String(elWidth / 2)
    }];
    setProgressBarStyles(attributesArray, this.renderer);
  }
  indeterminateState() {
    const progressArc = this.progress.nativeElement;
    if (this.indeterminate) {
      this.calculateProgress(this.value - this.min);
      const rotate = this.rtl ? {
        from: 360,
        to: 0
      } : {
        from: 0,
        to: 360
      };
      let color;
      if (!this.progressColor) {
        color = getComputedStyle(progressArc).stroke;
      }
      const indeterminateStyles = [{
        method: "setStyle",
        el: progressArc,
        attr: "transform-origin",
        attrValue: "center"
      }, {
        method: "setStyle",
        el: progressArc,
        attr: "fill",
        attrValue: "none"
      }, {
        method: "setStyle",
        el: progressArc,
        attr: "stroke-linecap",
        attrValue: "round"
      }, {
        method: "setStyle",
        el: progressArc,
        attr: "stroke",
        attrValue: color ? color : this.currentColor
      }];
      setProgressBarStyles(indeterminateStyles, this.renderer);
      this.renderer.removeClass(progressArc, "k-circular-progressbar-arc");
      progressArc.innerHTML = `<animateTransform attributeName="transform" type="rotate" from="${rotate.from} 0 0" to="${rotate.to} 0 0" dur="1s" repeatCount="indefinite" />`;
    } else {
      this.renderer.addClass(progressArc, "k-circular-progressbar-arc");
      const removeIndeterminateStyles = [{
        method: "removeStyle",
        el: progressArc,
        attr: "transform-origin"
      }, {
        method: "removeStyle",
        el: progressArc,
        attr: "fill"
      }, {
        method: "removeStyle",
        el: progressArc,
        attr: "stroke-linecap"
      }];
      removeProgressBarStyles(removeIndeterminateStyles, this.renderer);
      progressArc.innerHTML = "";
      if (this.animation) {
        this.progressbarAnimation();
      }
    }
  }
  updateCenterTemplate(value2) {
    if (!this.centerTemplate) {
      return;
    }
    this.centerTemplateContext.value = value2;
    this.centerTemplateContext.color = this.currentColor;
    this.cdr.detectChanges();
    this.positionLabel();
  }
  positionLabel() {
    const labelEl = this.labelElement.nativeElement;
    const element = this.element.nativeElement;
    const surface = this.surface.nativeElement;
    let elWidth;
    let elHeight;
    if (!hasElementSize(element)) {
      const surfaceSize = surface.getBoundingClientRect();
      elWidth = surfaceSize.width;
      elHeight = surfaceSize.height;
    } else {
      const elementSize = element.getBoundingClientRect();
      elWidth = elementSize.width;
      elHeight = elementSize.height;
    }
    const left2 = elWidth / 2 - labelEl.offsetWidth / 2;
    const top = elHeight / 2 - labelEl.offsetHeight / 2;
    const labelCalculations = [{
      method: "setStyle",
      el: labelEl,
      attr: "left",
      attrValue: `${left2}px`
    }, {
      method: "setStyle",
      el: labelEl,
      attr: "top",
      attrValue: `${top}px`
    }];
    setProgressBarStyles(labelCalculations, this.renderer);
  }
  get currentColor() {
    const currentColor = this.progress.nativeElement.style.stroke;
    return currentColor;
  }
  updateProgressColor(value2) {
    const progressArc = this.progress.nativeElement;
    if (typeof this.progressColor === "string") {
      this.renderer.setStyle(progressArc, "stroke", this.progressColor);
    } else {
      for (let i = 0; i < this.progressColor.length; i++) {
        const from2 = this.progressColor[i].from;
        const to = this.progressColor[i].to;
        if (value2 >= from2 && value2 <= to || !from2 && value2 <= to) {
          this.renderer.setStyle(progressArc, "stroke", this.progressColor[i].color);
          break;
        }
        if (!to && value2 >= from2) {
          this.renderer.setStyle(progressArc, "stroke", this.progressColor[i].color);
        }
      }
    }
  }
  handleErrors(type) {
    if (isDevMode()) {
      switch (type) {
        case "value > max":
          throw new Error("The value of the CircularProgressbar cannot exceed the max value");
        case "value < min":
          throw new Error("The value of the CircularProgressbar cannot be lower than the min value");
        case "max < min":
          throw new Error("The min value cannot be higher than the max value");
        default:
      }
    }
  }
  setDirection() {
    this.rtl = this.localization.rtl;
    if (this.element) {
      this.renderer.setAttribute(this.element.nativeElement, "dir", this.rtl ? "rtl" : "ltr");
    }
    if (this.labelElement) {
      this.renderer.setAttribute(this.labelElement.nativeElement, "dir", this.rtl ? "rtl" : "ltr");
    }
  }
  rtlChange() {
    if (this.element && this.rtl !== this.localization.rtl) {
      this.setDirection();
    }
  }
  static ɵfac = function CircularProgressBarComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CircularProgressBarComponent)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _CircularProgressBarComponent,
    selectors: [["kendo-circularprogressbar"]],
    contentQueries: function CircularProgressBarComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, CircularProgressbarCenterTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.centerTemplate = _t.first);
      }
    },
    viewQuery: function CircularProgressBarComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c210, 5)(_c39, 5)(_c42, 5)(_c52, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.progress = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.scale = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.labelElement = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.surface = _t.first);
      }
    },
    hostVars: 6,
    hostBindings: function CircularProgressBarComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("aria-valuemin", ctx.ariaMinAttribute)("aria-valuemax", ctx.ariaMaxAttribute)("aria-valuenow", ctx.ariaValueAttribute)("role", ctx.roleAttribute);
        ɵɵclassProp("k-circular-progressbar", ctx.hostClasses);
      }
    },
    inputs: {
      value: "value",
      max: "max",
      min: "min",
      animation: "animation",
      opacity: "opacity",
      indeterminate: "indeterminate",
      progressColor: "progressColor"
    },
    outputs: {
      animationEnd: "animationEnd"
    },
    exportAs: ["kendoCircularProgressBar"],
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.circularprogressbar"
    }]), ɵɵNgOnChangesFeature],
    decls: 13,
    vars: 1,
    consts: () => {
      let i18n_2;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PROGRESSBAR_FESM2022_PROGRESS_KENDO_ANGULAR_PROGRESSBAR_MJS_2 = goog.getMsg("Circular progressbar");
        i18n_2 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PROGRESSBAR_FESM2022_PROGRESS_KENDO_ANGULAR_PROGRESSBAR_MJS_2;
      } else {
        i18n_2 = $localize`:kendo.circularprogressbar.progressBarLabel|The aria-label attribute for the Circular ProgressBar component.:Circular progressbar`;
      }
      return [["surface", ""], ["svg", ""], ["scale", ""], ["progress", ""], ["label", ""], ["kendoProgressBarLocalizedMessages", "", "progressBarLabel", i18n_2], [1, "k-circular-progressbar-surface"], ["stroke-width", "9.5", 1, "k-circular-progressbar-scale"], ["stroke-width", "9.5", 1, "k-circular-progressbar-arc"], [1, "k-circular-progressbar-label"], [3, "resize"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]];
    },
    template: function CircularProgressBarComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainer(0, 5);
        ɵɵelementStart(1, "div", 6, 0)(3, "div");
        ɵɵnamespaceSVG();
        ɵɵelementStart(4, "svg", null, 1)(6, "g");
        ɵɵelement(7, "circle", 7, 2)(9, "circle", 8, 3);
        ɵɵelementEnd()();
        ɵɵconditionalCreate(11, CircularProgressBarComponent_Conditional_11_Template, 3, 2, "div", 9);
        ɵɵelementEnd()();
        ɵɵnamespaceHTML();
        ɵɵelementStart(12, "kendo-resize-sensor", 10);
        ɵɵlistener("resize", function CircularProgressBarComponent_Template_kendo_resize_sensor_resize_12_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onResize());
        });
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance(11);
        ɵɵconditional(ctx.centerTemplate ? 11 : -1);
      }
    },
    dependencies: [LocalizedProgressBarMessagesDirective, NgTemplateOutlet, ResizeSensorComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CircularProgressBarComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoCircularProgressBar",
      selector: "kendo-circularprogressbar",
      template: `
        <ng-container kendoProgressBarLocalizedMessages
          i18n-progressBarLabel="kendo.circularprogressbar.progressBarLabel|The aria-label attribute for the Circular ProgressBar component."
          progressBarLabel="Circular progressbar"
          >
        </ng-container>
        <div #surface class="k-circular-progressbar-surface">
          <div>
            <svg #svg>
              <g>
                <circle class="k-circular-progressbar-scale" #scale stroke-width="9.5"></circle>
                <circle class="k-circular-progressbar-arc" #progress stroke-width="9.5"></circle>
              </g>
            </svg>
            @if (centerTemplate) {
              <div class="k-circular-progressbar-label" #label>
                <ng-template [ngTemplateOutlet]="centerTemplate.templateRef" [ngTemplateOutletContext]="centerTemplateContext"></ng-template>
              </div>
            }
          </div>
        </div>
        <kendo-resize-sensor (resize)="onResize()"></kendo-resize-sensor>
        `,
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.circularprogressbar"
      }],
      standalone: true,
      imports: [LocalizedProgressBarMessagesDirective, NgTemplateOutlet, ResizeSensorComponent]
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ChangeDetectorRef
  }, {
    type: LocalizationService
  }, {
    type: ElementRef
  }, {
    type: NgZone
  }], {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-circular-progressbar"]
    }],
    ariaMinAttribute: [{
      type: HostBinding,
      args: ["attr.aria-valuemin"]
    }],
    ariaMaxAttribute: [{
      type: HostBinding,
      args: ["attr.aria-valuemax"]
    }],
    ariaValueAttribute: [{
      type: HostBinding,
      args: ["attr.aria-valuenow"]
    }],
    roleAttribute: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    value: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    animation: [{
      type: Input
    }],
    opacity: [{
      type: Input
    }],
    indeterminate: [{
      type: Input
    }],
    progressColor: [{
      type: Input
    }],
    animationEnd: [{
      type: Output
    }],
    progress: [{
      type: ViewChild,
      args: ["progress"]
    }],
    scale: [{
      type: ViewChild,
      args: ["scale"]
    }],
    labelElement: [{
      type: ViewChild,
      args: ["label"]
    }],
    surface: [{
      type: ViewChild,
      args: ["surface"]
    }],
    centerTemplate: [{
      type: ContentChild,
      args: [CircularProgressbarCenterTemplateDirective]
    }]
  });
})();
var ProgressBarCustomMessagesComponent = class _ProgressBarCustomMessagesComponent extends ProgressBarMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function ProgressBarCustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ProgressBarCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ProgressBarCustomMessagesComponent,
    selectors: [["kendo-progressbar-messages"]],
    features: [ɵɵProvidersFeature([{
      provide: ProgressBarMessages,
      useExisting: forwardRef(() => _ProgressBarCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function ProgressBarCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProgressBarCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: ProgressBarMessages,
        useExisting: forwardRef(() => ProgressBarCustomMessagesComponent)
      }],
      selector: "kendo-progressbar-messages",
      template: ``,
      standalone: true
    }]
  }], () => [{
    type: LocalizationService
  }], null);
})();
var KENDO_CHUNKPROGRESSBAR = [ChunkProgressBarComponent, ProgressBarCustomMessagesComponent];
var KENDO_CIRCULARPROGRESSBAR = [CircularProgressbarCenterTemplateDirective, CircularProgressBarComponent, ProgressBarCustomMessagesComponent];
var KENDO_PROGRESSBAR = [ProgressBarComponent, ProgressBarCustomMessagesComponent];
var KENDO_PROGRESSBARS = [...KENDO_CHUNKPROGRESSBAR, ...KENDO_CIRCULARPROGRESSBAR, ...KENDO_PROGRESSBAR];
var ProgressBarModule = class _ProgressBarModule {
  static ɵfac = function ProgressBarModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ProgressBarModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _ProgressBarModule,
    imports: [ChunkProgressBarComponent, ProgressBarCustomMessagesComponent, CircularProgressbarCenterTemplateDirective, CircularProgressBarComponent, ProgressBarCustomMessagesComponent, ProgressBarComponent, ProgressBarCustomMessagesComponent],
    exports: [ChunkProgressBarComponent, ProgressBarCustomMessagesComponent, CircularProgressbarCenterTemplateDirective, CircularProgressBarComponent, ProgressBarCustomMessagesComponent, ProgressBarComponent, ProgressBarCustomMessagesComponent]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [ResizeBatchService],
    imports: [CircularProgressBarComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProgressBarModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_PROGRESSBARS],
      imports: [...KENDO_PROGRESSBARS],
      providers: [ResizeBatchService]
    }]
  }], null, null);
})();

// node_modules/@progress/kendo-angular-layout/fesm2022/progress-kendo-angular-layout.mjs
var _c03 = ["header"];
var _c111 = ["contentWrapper"];
var _c211 = [[["kendo-panelbar-item"]]];
var _c310 = ["kendo-panelbar-item"];
var PanelBarItemComponent_Conditional_7_Defer_1_DepsFn = () => [PanelBarItemComponent, NgTemplateOutlet];
var _c43 = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) => ({
  title: a0,
  id: a1,
  icon: a2,
  iconClass: a3,
  svgIcon: a4,
  imageUrl: a5,
  selected: a6,
  expanded: a7,
  disabled: a8,
  focused: a9,
  content: a10
});
var _c53 = (a0) => ({
  item: a0
});
var _c62 = (a0, a1, a2, a3, a4, a5) => ({
  title: a0,
  id: a1,
  icon: a2,
  imageUrl: a3,
  disabled: a4,
  content: a5
});
var _c72 = (a0) => ({
  $implicit: a0
});
function PanelBarItemComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 3);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r1.iconClasses)("customFontClass", ctx_r1.customIconClasses)("svgIcon", ctx_r1.svgIcon);
  }
}
function PanelBarItemComponent_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "img", 4);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("src", ctx_r1.imageUrl, ɵɵsanitizeUrl);
  }
}
function PanelBarItemComponent_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 5);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.title);
  }
}
function PanelBarItemComponent_Conditional_5_ng_template_0_Template(rf, ctx) {
}
function PanelBarItemComponent_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PanelBarItemComponent_Conditional_5_ng_template_0_Template, 0, 0, "ng-template", 6);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.titleTemplate)("ngTemplateOutletContext", ɵɵpureFunction1(14, _c53, ɵɵpureFunctionV(2, _c43, [ctx_r1.title, ctx_r1.id, ctx_r1.icon, ctx_r1.iconClass, ctx_r1.svgIcon, ctx_r1.imageUrl, ctx_r1.selected, ctx_r1.expanded, ctx_r1.disabled, ctx_r1.focused, ctx_r1.content])));
  }
}
function PanelBarItemComponent_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 7);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r1.expanded ? "chevron-up" : "chevron-down")("svgIcon", ctx_r1.expanderSVGIcon)("innerCssClass", ctx_r1.dirInnerCssClasses);
  }
}
function PanelBarItemComponent_Conditional_7_Defer_0_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 10);
    ɵɵprojection(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵstyleProp("overflow", ctx_r1.contentOverflow)("height", ctx_r1.contentHeight);
  }
}
function PanelBarItemComponent_Conditional_7_Defer_0_Conditional_3_ng_template_1_Template(rf, ctx) {
}
function PanelBarItemComponent_Conditional_7_Defer_0_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 11);
    ɵɵtemplate(1, PanelBarItemComponent_Conditional_7_Defer_0_Conditional_3_ng_template_1_Template, 0, 0, "ng-template", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵstyleProp("overflow", ctx_r1.contentOverflow)("height", ctx_r1.contentHeight);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.contentTemplate.first.templateRef)("ngTemplateOutletContext", ɵɵpureFunction1(13, _c72, ɵɵpureFunction6(6, _c62, ctx_r1.title, ctx_r1.id, ctx_r1.icon, ctx_r1.imageUrl, ctx_r1.disabled, ctx_r1.content)));
  }
}
function PanelBarItemComponent_Conditional_7_Defer_0_Conditional_4_For_2_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-panelbar-item", 12);
  }
  if (rf & 2) {
    const item_r3 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵproperty("title", item_r3.title)("id", item_r3.id)("icon", item_r3.icon)("iconClass", item_r3.iconClass)("svgIcon", item_r3.svgIcon)("imageUrl", item_r3.imageUrl)("selected", !!item_r3.selected)("expanded", !!item_r3.expanded)("disabled", !!item_r3.disabled)("template", ctx_r1.template)("items", item_r3.children)("content", item_r3.content);
  }
}
function PanelBarItemComponent_Conditional_7_Defer_0_Conditional_4_For_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, PanelBarItemComponent_Conditional_7_Defer_0_Conditional_4_For_2_Conditional_0_Template, 1, 12, "kendo-panelbar-item", 12);
  }
  if (rf & 2) {
    const item_r3 = ctx.$implicit;
    ɵɵconditional(!item_r3.hidden ? 0 : -1);
  }
}
function PanelBarItemComponent_Conditional_7_Defer_0_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 10);
    ɵɵrepeaterCreate(1, PanelBarItemComponent_Conditional_7_Defer_0_Conditional_4_For_2_Template, 1, 1, null, null, ɵɵrepeaterTrackByIdentity);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵstyleProp("overflow", ctx_r1.contentOverflow)("height", ctx_r1.contentHeight);
    ɵɵadvance();
    ɵɵrepeater(ctx_r1.items);
  }
}
function PanelBarItemComponent_Conditional_7_Defer_0_Conditional_5_ng_template_1_Template(rf, ctx) {
}
function PanelBarItemComponent_Conditional_7_Defer_0_Conditional_5_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵtextInterpolate1(" ", ctx_r1.content, " ");
  }
}
function PanelBarItemComponent_Conditional_7_Defer_0_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 11);
    ɵɵtemplate(1, PanelBarItemComponent_Conditional_7_Defer_0_Conditional_5_ng_template_1_Template, 0, 0, "ng-template", 6);
    ɵɵconditionalCreate(2, PanelBarItemComponent_Conditional_7_Defer_0_Conditional_5_Conditional_2_Template, 1, 1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵstyleProp("overflow", ctx_r1.contentOverflow)("height", ctx_r1.contentHeight);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.template)("ngTemplateOutletContext", ɵɵpureFunction1(14, _c72, ɵɵpureFunction6(7, _c62, ctx_r1.title, ctx_r1.id, ctx_r1.icon, ctx_r1.imageUrl, ctx_r1.disabled, ctx_r1.content)));
    ɵɵadvance();
    ɵɵconditional(!ctx_r1.template ? 2 : -1);
  }
}
function PanelBarItemComponent_Conditional_7_Defer_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", null, 1);
    ɵɵconditionalCreate(2, PanelBarItemComponent_Conditional_7_Defer_0_Conditional_2_Template, 2, 4, "div", 8);
    ɵɵconditionalCreate(3, PanelBarItemComponent_Conditional_7_Defer_0_Conditional_3_Template, 2, 15, "div", 9);
    ɵɵconditionalCreate(4, PanelBarItemComponent_Conditional_7_Defer_0_Conditional_4_Template, 3, 4, "div", 8);
    ɵɵconditionalCreate(5, PanelBarItemComponent_Conditional_7_Defer_0_Conditional_5_Template, 3, 16, "div", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("@toggle", ctx_r1.state);
    ɵɵattribute("role", "group")("aria-hidden", !ctx_r1.disabled && !ctx_r1.expanded);
    ɵɵadvance(2);
    ɵɵconditional(ctx_r1.hasChildItems && !(ctx_r1.items == null ? null : ctx_r1.items.length) ? 2 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.hasContent && !ctx_r1.content ? 3 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.hasItems ? 4 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.content ? 5 : -1);
  }
}
function PanelBarItemComponent_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵdomTemplate(0, PanelBarItemComponent_Conditional_7_Defer_0_Template, 6, 7);
    ɵɵdefer(1, 0, PanelBarItemComponent_Conditional_7_Defer_1_DepsFn);
    ɵɵdeferPrefetchOnIdle();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵdeferWhen(!ctx_r1.disabled && ctx_r1.expanded && ctx_r1.keepContent !== true || ctx_r1.keepContent === true);
  }
}
function PanelBarComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
function PanelBarComponent_Conditional_1_For_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-panelbar-item", 1);
  }
  if (rf & 2) {
    const item_r1 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("title", item_r1.title)("id", item_r1.id)("icon", item_r1.icon)("iconClass", item_r1.iconClass)("svgIcon", item_r1.svgIcon)("imageUrl", item_r1.imageUrl)("selected", !!item_r1.selected)("expanded", !!item_r1.expanded)("disabled", !!item_r1.disabled)("template", ctx_r1.templateRef)("items", item_r1.children)("content", item_r1.content);
  }
}
function PanelBarComponent_Conditional_1_For_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, PanelBarComponent_Conditional_1_For_1_Conditional_0_Template, 1, 12, "kendo-panelbar-item", 1);
  }
  if (rf & 2) {
    const item_r1 = ctx.$implicit;
    ɵɵconditional(!item_r1.hidden ? 0 : -1);
  }
}
function PanelBarComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵrepeaterCreate(0, PanelBarComponent_Conditional_1_For_1_Template, 1, 1, null, null, ɵɵrepeaterTrackByIdentity);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵrepeater(ctx_r1.items);
  }
}
function PanelBarComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 0);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("licenseMessage", ctx_r1.licenseMessage);
  }
}
var _c82 = ["*"];
function SplitterPaneComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
function SplitterPaneComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵdomElement(0, "div", 0);
  }
}
function SplitterBarComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 3);
    ɵɵlistener("click", function SplitterBarComponent_Conditional_0_Template_div_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.togglePrevious());
    });
    ɵɵelement(1, "kendo-icon-wrapper", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("name", ctx_r1.previousArrowClass())("svgIcon", ctx_r1.previousSVGArrowClass());
  }
}
function SplitterBarComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 5);
    ɵɵlistener("click", function SplitterBarComponent_Conditional_2_Template_div_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.toggleNext());
    });
    ɵɵelement(1, "kendo-icon-wrapper", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("name", ctx_r1.nextArrowClass())("svgIcon", ctx_r1.nextSVGArrowClass());
  }
}
var _c92 = [[["kendo-splitter-pane"]]];
var _c102 = ["kendo-splitter-pane"];
var _c112 = (a0, a1) => ({
  width: a0,
  height: a1
});
function SplitterComponent_For_2_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-splitter-bar", 0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    const pane_r2 = ctx_r0.$implicit;
    const ɵ$index_2_r3 = ctx_r0.$index;
    const ctx_r3 = ɵɵnextContext();
    ɵɵproperty("index", ɵ$index_2_r3)("orientation", ctx_r3.orientation)("ngClass", pane_r2.splitterBarClass || ctx_r3.splitterBarClass)("ngStyle", ɵɵpureFunction2(4, _c112, ctx_r3.orientation === "horizontal" ? ctx_r3.splitbarWidth + "px" : void 0, ctx_r3.orientation === "vertical" ? ctx_r3.splitbarWidth + "px" : void 0));
  }
}
function SplitterComponent_For_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, SplitterComponent_For_2_Conditional_0_Template, 1, 7, "kendo-splitter-bar", 0);
  }
  if (rf & 2) {
    const ɵ$index_2_r3 = ctx.$index;
    const ɵ$count_2_r5 = ctx.$count;
    ɵɵconditional(!(ɵ$index_2_r3 === ɵ$count_2_r5 - 1) ? 0 : -1);
  }
}
var _c122 = ["kendoTabStripScrollableButton", ""];
var _c132 = ["kendoTabStripTab", ""];
function TabComponent_Conditional_0_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 3)(1, "span", 4);
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.tab.title);
  }
}
function TabComponent_Conditional_0_Conditional_1_ng_template_1_Template(rf, ctx) {
}
function TabComponent_Conditional_0_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 3);
    ɵɵtemplate(1, TabComponent_Conditional_0_Conditional_1_ng_template_1_Template, 0, 0, "ng-template", 1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.tab.tabTitle.templateRef);
  }
}
function TabComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, TabComponent_Conditional_0_Conditional_0_Template, 3, 1, "span", 3);
    ɵɵconditionalCreate(1, TabComponent_Conditional_0_Conditional_1_Template, 2, 1, "span", 3);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵconditional(!ctx_r0.tab.tabTitle ? 0 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r0.tab.tabTitle ? 1 : -1);
  }
}
function TabComponent_Conditional_1_ng_template_0_Template(rf, ctx) {
}
function TabComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TabComponent_Conditional_1_ng_template_0_Template, 0, 0, "ng-template", 1, 0, ɵɵtemplateRefExtractor);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.tab.tabTemplate == null ? null : ctx_r0.tab.tabTemplate.templateRef);
  }
}
function TabComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 5);
    ɵɵlistener("click", function TabComponent_Conditional_2_Template_span_click_0_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.closeTab(ctx_r0.index));
    });
    ɵɵelement(1, "kendo-icon-wrapper", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("title", ctx_r0.closeButtonTitle);
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r0.closeSVGIconClass)("name", ctx_r0.closeIconClasses)("customFontClass", ctx_r0.customCloseIconClasses);
  }
}
var _c142 = ["tablist"];
var _c152 = ["prevScrollButton"];
var _c162 = ["nextScrollButton"];
var _c172 = ["tabHeaderContainer"];
var TabStripComponent_ng_template_5_For_1_Conditional_0_Defer_1_DepsFn = () => [NgTemplateOutlet, NgClass];
var _c182 = (a0, a1, a2, a3, a4, a5) => ({
  "k-tabstrip-items-start": a0,
  "k-tabstrip-items-center": a1,
  "k-tabstrip-items-end": a2,
  "k-tabstrip-items-stretched": a3,
  "k-tabstrip-items-justify": a4,
  "k-tabstrip-items-scroll": a5
});
var _c192 = (a0, a1, a2) => ({
  "k-button-sm": a0,
  "k-button-md": a1,
  "k-button-lg": a2
});
function TabStripComponent_Conditional_1_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function TabStripComponent_Conditional_1_Conditional_1_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function TabStripComponent_Conditional_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TabStripComponent_Conditional_1_Conditional_1_ng_container_0_Template, 1, 0, "ng-container", 8);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const content_r1 = ɵɵreference(6);
    ɵɵproperty("ngTemplateOutlet", content_r1);
  }
}
function TabStripComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TabStripComponent_Conditional_1_ng_container_0_Template, 1, 0, "ng-container", 8);
    ɵɵconditionalCreate(1, TabStripComponent_Conditional_1_Conditional_1_Template, 1, 1, "ng-container");
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const heading_r3 = ɵɵreference(4);
    ɵɵproperty("ngTemplateOutlet", heading_r3);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.showContentArea ? 1 : -1);
  }
}
function TabStripComponent_Conditional_2_Conditional_0_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function TabStripComponent_Conditional_2_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TabStripComponent_Conditional_2_Conditional_0_ng_container_0_Template, 1, 0, "ng-container", 8);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const content_r1 = ɵɵreference(6);
    ɵɵproperty("ngTemplateOutlet", content_r1);
  }
}
function TabStripComponent_Conditional_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function TabStripComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, TabStripComponent_Conditional_2_Conditional_0_Template, 1, 1, "ng-container");
    ɵɵtemplate(1, TabStripComponent_Conditional_2_ng_container_1_Template, 1, 0, "ng-container", 8);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const heading_r3 = ɵɵreference(4);
    ɵɵconditional(ctx_r1.showContentArea ? 0 : -1);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", heading_r3);
  }
}
function TabStripComponent_ng_template_3_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 13, 3);
    ɵɵlistener("tabScroll", function TabStripComponent_ng_template_3_Conditional_1_Template_span_tabScroll_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.tabScroll.emit($event));
    })("onClick", function TabStripComponent_ng_template_3_Conditional_1_Template_span_onClick_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onScrollButtonClick($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("scrollable", ctx_r1.scrollable)("tabPosition", ctx_r1.tabPosition)("prev", true)("title", ctx_r1.localization.get("previousTabButton"))("ngClass", ɵɵpureFunction3(5, _c192, ctx_r1.size === "small", ctx_r1.size === "medium" || !ctx_r1.size, ctx_r1.size === "large"));
  }
}
function TabStripComponent_ng_template_3_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 13, 4);
    ɵɵlistener("tabScroll", function TabStripComponent_ng_template_3_Conditional_2_Template_span_tabScroll_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.tabScroll.emit($event));
    })("onClick", function TabStripComponent_ng_template_3_Conditional_2_Template_span_onClick_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onScrollButtonClick($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("scrollable", ctx_r1.scrollable)("tabPosition", ctx_r1.tabPosition)("prev", false)("title", ctx_r1.localization.get("nextTabButton"))("ngClass", ɵɵpureFunction3(5, _c192, ctx_r1.size === "small", ctx_r1.size === "medium" || !ctx_r1.size, ctx_r1.size === "large"));
  }
}
function TabStripComponent_ng_template_3_For_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "li", 14, 5);
    ɵɵlistener("tabClose", function TabStripComponent_ng_template_3_For_6_Template_li_tabClose_0_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.tabClose.emit($event));
    })("click", function TabStripComponent_ng_template_3_For_6_Template_li_click_0_listener($event) {
      const ɵ$index_35_r7 = ɵɵrestoreView(_r6).$index;
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onTabClick($event, ɵ$index_35_r7));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const tab_r8 = ctx.$implicit;
    const ɵ$index_35_r7 = ctx.$index;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵclassProp("k-first", ɵ$index_35_r7 === 0)("k-last", ɵ$index_35_r7 === ctx_r1.tabs.length - 1);
    ɵɵproperty("ngClass", tab_r8.cssClass)("ngStyle", tab_r8.cssStyle)("tab", tab_r8)("index", ɵ$index_35_r7)("tabStripClosable", ctx_r1.closable)("tabStripCloseIcon", ctx_r1.closeIcon)("customTabstripCloseIcon", ctx_r1.closeIconClass)("closeSVGIcon", ctx_r1.closeSVGIcon)("id", ctx_r1.getTabId(ɵ$index_35_r7));
    ɵɵattribute("aria-controls", ctx_r1.showContentArea && tab_r8.selected ? ctx_r1.getTabPanelId(ɵ$index_35_r7) : void 0);
  }
}
function TabStripComponent_ng_template_3_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 13, 3);
    ɵɵlistener("tabScroll", function TabStripComponent_ng_template_3_Conditional_7_Template_span_tabScroll_0_listener($event) {
      ɵɵrestoreView(_r9);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.tabScroll.emit($event));
    })("onClick", function TabStripComponent_ng_template_3_Conditional_7_Template_span_onClick_0_listener($event) {
      ɵɵrestoreView(_r9);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onScrollButtonClick($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("scrollable", ctx_r1.scrollable)("tabPosition", ctx_r1.tabPosition)("prev", true)("title", ctx_r1.localization.get("previousTabButton"))("ngClass", ɵɵpureFunction3(5, _c192, ctx_r1.size === "small", ctx_r1.size === "medium" || !ctx_r1.size, ctx_r1.size === "large"));
  }
}
function TabStripComponent_ng_template_3_Conditional_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 13, 4);
    ɵɵlistener("tabScroll", function TabStripComponent_ng_template_3_Conditional_8_Template_span_tabScroll_0_listener($event) {
      ɵɵrestoreView(_r10);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.tabScroll.emit($event));
    })("onClick", function TabStripComponent_ng_template_3_Conditional_8_Template_span_onClick_0_listener($event) {
      ɵɵrestoreView(_r10);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onScrollButtonClick($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("scrollable", ctx_r1.scrollable)("tabPosition", ctx_r1.tabPosition)("prev", false)("title", ctx_r1.localization.get("nextTabButton"))("ngClass", ɵɵpureFunction3(5, _c192, ctx_r1.size === "small", ctx_r1.size === "medium" || !ctx_r1.size, ctx_r1.size === "large"));
  }
}
function TabStripComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 9);
    ɵɵconditionalCreate(1, TabStripComponent_ng_template_3_Conditional_1_Template, 2, 9, "span", 10);
    ɵɵconditionalCreate(2, TabStripComponent_ng_template_3_Conditional_2_Template, 2, 9, "span", 10);
    ɵɵelementStart(3, "ul", 11, 2);
    ɵɵrepeaterCreate(5, TabStripComponent_ng_template_3_For_6_Template, 2, 14, "li", 12, ɵɵrepeaterTrackByIdentity);
    ɵɵelementEnd();
    ɵɵconditionalCreate(7, TabStripComponent_ng_template_3_Conditional_7_Template, 2, 9, "span", 10);
    ɵɵconditionalCreate(8, TabStripComponent_ng_template_3_Conditional_8_Template, 2, 9, "span", 10);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("k-tabstrip-items-wrapper-scroll", ctx_r1.mouseScrollEnabled);
    ɵɵproperty("ngClass", ctx_r1.itemsWrapperClass);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.hasScrollButtons.visible && ctx_r1.hasScrollButtons.position !== "end" ? 1 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.hasScrollButtons.visible && ctx_r1.hasScrollButtons.position === "start" ? 2 : -1);
    ɵɵadvance();
    ɵɵproperty("ngClass", ɵɵpureFunction6(9, _c182, ctx_r1.tabAlignment === "start", ctx_r1.tabAlignment === "center", ctx_r1.tabAlignment === "end", ctx_r1.tabAlignment === "stretched", ctx_r1.tabAlignment === "justify", ctx_r1.mouseScrollEnabled));
    ɵɵattribute("aria-orientation", ctx_r1.tabPosition === "left" || ctx_r1.tabPosition === "right" ? "vertical" : "horizontal");
    ɵɵadvance(2);
    ɵɵrepeater(ctx_r1.tabs);
    ɵɵadvance(2);
    ɵɵconditional(ctx_r1.hasScrollButtons.visible && ctx_r1.hasScrollButtons.position === "end" ? 7 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.hasScrollButtons.visible && ctx_r1.hasScrollButtons.position !== "start" ? 8 : -1);
  }
}
function TabStripComponent_ng_template_5_For_1_Conditional_0_Defer_0_ng_template_1_Template(rf, ctx) {
}
function TabStripComponent_ng_template_5_For_1_Conditional_0_Defer_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 15);
    ɵɵtemplate(1, TabStripComponent_ng_template_5_For_1_Conditional_0_Defer_0_ng_template_1_Template, 0, 0, "ng-template", 16);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r10 = ɵɵnextContext(2);
    const tab_r12 = ctx_r10.$implicit;
    const ɵ$index_46_r13 = ctx_r10.$index;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("@state", tab_r12.selected && ctx_r1.animate ? "active" : "inactive")("ngClass", !ctx_r1.keepTabContent || tab_r12.selected ? "k-tabstrip-content k-active" : "k-tabstrip-content")("tabIndex", 0)("id", ctx_r1.getTabPanelId(ɵ$index_46_r13));
    ɵɵattribute("aria-hidden", !tab_r12.selected)("aria-labelledby", ctx_r1.getTabId(ɵ$index_46_r13))("aria-disabled", tab_r12.disabled);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", tab_r12.tabContent == null ? null : tab_r12.tabContent.templateRef);
  }
}
function TabStripComponent_ng_template_5_For_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵdomTemplate(0, TabStripComponent_ng_template_5_For_1_Conditional_0_Defer_0_Template, 2, 8);
    ɵɵdefer(1, 0, TabStripComponent_ng_template_5_For_1_Conditional_0_Defer_1_DepsFn);
    ɵɵdeferPrefetchOnIdle();
  }
  if (rf & 2) {
    const tab_r12 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵdeferWhen(tab_r12.selected || ctx_r1.keepTabContent === true);
  }
}
function TabStripComponent_ng_template_5_For_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, TabStripComponent_ng_template_5_For_1_Conditional_0_Template, 3, 1);
  }
  if (rf & 2) {
    const tab_r12 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵconditional(tab_r12.selected || ctx_r1.keepTabContent !== false ? 0 : -1);
  }
}
function TabStripComponent_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵrepeaterCreate(0, TabStripComponent_ng_template_5_For_1_Template, 1, 1, null, null, ɵɵrepeaterTrackByIdentity);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵrepeater(ctx_r1.tabs);
  }
}
function TabStripComponent_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r14 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-resize-sensor", 17);
    ɵɵlistener("resize", function TabStripComponent_Conditional_7_Template_kendo_resize_sensor_resize_0_listener() {
      ɵɵrestoreView(_r14);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onResize());
    });
    ɵɵelementEnd();
  }
}
function TabStripComponent_Conditional_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 7);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("licenseMessage", ctx_r1.licenseMessage);
  }
}
var _c202 = ["kendoDrawerItem", ""];
var _c212 = (a0, a1, a2, a3) => ({
  $implicit: a0,
  isItemExpanded: a1,
  hasChildren: a2,
  level: a3
});
function DrawerItemComponent_Conditional_0_ng_template_0_Template(rf, ctx) {
}
function DrawerItemComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, DrawerItemComponent_Conditional_0_ng_template_0_Template, 0, 0, "ng-template", 0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.itemTemplate)("ngTemplateOutletContext", ɵɵpureFunction4(2, _c212, ctx_r0.item, ctx_r0.viewItem.isExpanded, ctx_r0.viewItem.hasChildren, ctx_r0.viewItem.level));
  }
}
function DrawerItemComponent_Conditional_1_Conditional_0_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 1);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("name", ctx_r0.iconClasses)("customFontClass", ctx_r0.customIconClasses)("svgIcon", ctx_r0.item.svgIcon)("innerCssClass", ctx_r0.innerCssClasses);
  }
}
function DrawerItemComponent_Conditional_1_Conditional_0_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 3);
  }
}
function DrawerItemComponent_Conditional_1_Conditional_0_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("name", ctx_r0.viewItem.isExpanded ? "arrow-chevron-up" : "arrow-chevron-down")("svgIcon", ctx_r0.viewItem.isExpanded ? ctx_r0.arrowUpIcon : ctx_r0.arrowDownIcon);
  }
}
function DrawerItemComponent_Conditional_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, DrawerItemComponent_Conditional_1_Conditional_0_Conditional_0_Template, 1, 4, "kendo-icon-wrapper", 1);
    ɵɵelementStart(1, "span", 2);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵconditionalCreate(3, DrawerItemComponent_Conditional_1_Conditional_0_Conditional_3_Template, 1, 0, "span", 3);
    ɵɵconditionalCreate(4, DrawerItemComponent_Conditional_1_Conditional_0_Conditional_4_Template, 1, 2, "kendo-icon-wrapper", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵconditional(ctx_r0.item.icon || ctx_r0.item.iconClass || ctx_r0.item.svgIcon ? 0 : -1);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.item.text);
    ɵɵadvance();
    ɵɵconditional(ctx_r0.viewItem.hasChildren ? 3 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r0.viewItem.hasChildren ? 4 : -1);
  }
}
function DrawerItemComponent_Conditional_1_Conditional_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 1);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("name", ctx_r0.iconClasses)("customFontClass", ctx_r0.customIconClasses)("svgIcon", ctx_r0.item.svgIcon)("innerCssClass", ctx_r0.innerCssClasses);
  }
}
function DrawerItemComponent_Conditional_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, DrawerItemComponent_Conditional_1_Conditional_1_Conditional_0_Template, 1, 4, "kendo-icon-wrapper", 1);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵconditional(ctx_r0.item.icon || ctx_r0.item.iconClass || ctx_r0.item.svgIcon ? 0 : -1);
  }
}
function DrawerItemComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, DrawerItemComponent_Conditional_1_Conditional_0_Template, 5, 4);
    ɵɵconditionalCreate(1, DrawerItemComponent_Conditional_1_Conditional_1_Template, 1, 1);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵconditional(ctx_r0.expanded ? 0 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r0.mini && !ctx_r0.expanded ? 1 : -1);
  }
}
var _c222 = ["kendoDrawerList", ""];
function DrawerListComponent_For_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "li", 2);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    const v_r2 = ctx_r0.$implicit;
    const ɵ$index_1_r3 = ctx_r0.$index;
    const ctx_r3 = ɵɵnextContext();
    ɵɵclassMap(ɵɵinterpolate1("k-drawer-item ", ctx_r3.expanded ? " k-level-" + v_r2.level : ""));
    ɵɵproperty("viewItem", v_r2)("index", ɵ$index_1_r3)("mini", ctx_r3.mini)("expanded", ctx_r3.expanded)("itemTemplate", ctx_r3.itemTemplate)("ngClass", v_r2.item.cssClass)("ngStyle", v_r2.item.cssStyle)("tabindex", v_r2.index === 0 ? "0" : "-1");
    ɵɵattribute("data-kendo-drawer-index", v_r2.index);
  }
}
function DrawerListComponent_For_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "li", 1);
    ɵɵtext(1, "   ");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const v_r2 = ɵɵnextContext().$implicit;
    ɵɵproperty("ngClass", v_r2.item.cssClass)("ngStyle", v_r2.item.cssStyle);
  }
}
function DrawerListComponent_For_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, DrawerListComponent_For_1_Conditional_0_Template, 1, 12, "li", 0);
    ɵɵconditionalCreate(1, DrawerListComponent_For_1_Conditional_1_Template, 2, 2, "li", 1);
  }
  if (rf & 2) {
    const v_r2 = ctx.$implicit;
    ɵɵconditional(!v_r2.item.separator ? 0 : -1);
    ɵɵadvance();
    ɵɵconditional(v_r2.item.separator ? 1 : -1);
  }
}
function DrawerComponent_Conditional_0_Conditional_1_Conditional_0_ng_template_0_Template(rf, ctx) {
}
function DrawerComponent_Conditional_0_Conditional_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, DrawerComponent_Conditional_0_Conditional_1_Conditional_0_ng_template_0_Template, 0, 0, "ng-template", 3);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.headerTemplate == null ? null : ctx_r1.headerTemplate.templateRef);
  }
}
function DrawerComponent_Conditional_0_Conditional_1_Conditional_2_ng_template_0_Template(rf, ctx) {
}
function DrawerComponent_Conditional_0_Conditional_1_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, DrawerComponent_Conditional_0_Conditional_1_Conditional_2_ng_template_0_Template, 0, 0, "ng-template", 3);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.footerTemplate == null ? null : ctx_r1.footerTemplate.templateRef);
  }
}
function DrawerComponent_Conditional_0_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵconditionalCreate(0, DrawerComponent_Conditional_0_Conditional_1_Conditional_0_Template, 1, 1, null, 3);
    ɵɵelementStart(1, "ul", 4);
    ɵɵlistener("select", function DrawerComponent_Conditional_0_Conditional_1_Template_ul_select_1_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onSelect($event));
    });
    ɵɵelementEnd();
    ɵɵconditionalCreate(2, DrawerComponent_Conditional_0_Conditional_1_Conditional_2_Template, 1, 1, null, 3);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵconditional(ctx_r1.headerTemplate ? 0 : -1);
    ɵɵadvance();
    ɵɵproperty("mini", ctx_r1.mini)("expanded", ctx_r1.expanded)("view", ctx_r1.viewItems)("itemTemplate", ctx_r1.itemTemplate == null ? null : ctx_r1.itemTemplate.templateRef);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.footerTemplate ? 2 : -1);
  }
}
function DrawerComponent_Conditional_0_Conditional_2_ng_template_0_Template(rf, ctx) {
}
function DrawerComponent_Conditional_0_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, DrawerComponent_Conditional_0_Conditional_2_ng_template_0_Template, 0, 0, "ng-template", 3);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.drawerTemplate == null ? null : ctx_r1.drawerTemplate.templateRef);
  }
}
function DrawerComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 2);
    ɵɵconditionalCreate(1, DrawerComponent_Conditional_0_Conditional_1_Template, 3, 6);
    ɵɵconditionalCreate(2, DrawerComponent_Conditional_0_Conditional_2_Template, 1, 1, null, 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵstyleProp("width", ctx_r1.drawerWidth, "px");
    ɵɵadvance();
    ɵɵconditional(!ctx_r1.drawerTemplate ? 1 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.drawerTemplate ? 2 : -1);
  }
}
function DrawerComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 1);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("licenseMessage", ctx_r1.licenseMessage);
  }
}
function DrawerContainerComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵdomElementStart(0, "div", 1);
    ɵɵdomListener("click", function DrawerContainerComponent_Conditional_0_Template_div_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.closeDrawer());
    });
    ɵɵdomElementEnd();
  }
}
var _c232 = ["stepLink"];
var _c242 = ["kendoStepperStep", ""];
var _c252 = (a0, a1) => ({
  $implicit: a0,
  index: a1
});
function StepperStepComponent_Conditional_2_ng_template_0_Template(rf, ctx) {
}
function StepperStepComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, StepperStepComponent_Conditional_2_ng_template_0_Template, 0, 0, "ng-template", 2);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.stepTemplate)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c252, ctx_r1.step, ctx_r1.index));
  }
}
function StepperStepComponent_Conditional_3_Conditional_0_Conditional_1_ng_template_0_Template(rf, ctx) {
}
function StepperStepComponent_Conditional_3_Conditional_0_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, StepperStepComponent_Conditional_3_Conditional_0_Conditional_1_ng_template_0_Template, 0, 0, "ng-template", 2);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.indicatorTemplate)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c252, ctx_r1.step, ctx_r1.index));
  }
}
function StepperStepComponent_Conditional_3_Conditional_0_Conditional_2_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 6);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵproperty("name", ctx_r1.indicatorIconClass)("customFontClass", ctx_r1.customIndicatorIconClass)("svgIcon", ctx_r1.SVGIndicatorIcon);
  }
}
function StepperStepComponent_Conditional_3_Conditional_0_Conditional_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 7);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.indicatorText);
  }
}
function StepperStepComponent_Conditional_3_Conditional_0_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, StepperStepComponent_Conditional_3_Conditional_0_Conditional_2_Conditional_0_Template, 1, 3, "kendo-icon-wrapper", 6);
    ɵɵconditionalCreate(1, StepperStepComponent_Conditional_3_Conditional_0_Conditional_2_Conditional_1_Template, 2, 1, "span", 7);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵconditional(ctx_r1.showIndicatorIcon ? 0 : -1);
    ɵɵadvance();
    ɵɵconditional(!ctx_r1.showIndicatorIcon ? 1 : -1);
  }
}
function StepperStepComponent_Conditional_3_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 5);
    ɵɵconditionalCreate(1, StepperStepComponent_Conditional_3_Conditional_0_Conditional_1_Template, 1, 5, null, 2);
    ɵɵconditionalCreate(2, StepperStepComponent_Conditional_3_Conditional_0_Conditional_2_Template, 2, 2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵstyleProp("transition-duration", ctx_r1.transitionDuration, "ms");
    ɵɵadvance();
    ɵɵconditional(ctx_r1.indicatorTemplate ? 1 : -1);
    ɵɵadvance();
    ɵɵconditional(!ctx_r1.indicatorTemplate ? 2 : -1);
  }
}
function StepperStepComponent_Conditional_3_Conditional_1_Conditional_1_ng_template_0_Template(rf, ctx) {
}
function StepperStepComponent_Conditional_3_Conditional_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, StepperStepComponent_Conditional_3_Conditional_1_Conditional_1_ng_template_0_Template, 0, 0, "ng-template", 2);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.labelTemplate)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c252, ctx_r1.step, ctx_r1.index));
  }
}
function StepperStepComponent_Conditional_3_Conditional_1_Conditional_2_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 8);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.step.label);
  }
}
function StepperStepComponent_Conditional_3_Conditional_1_Conditional_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 9);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵproperty("name", ctx_r1.validationIconClasses)("customFontClass", ctx_r1.customValidationIconClasses)("svgIcon", ctx_r1.validationSVGIcon);
  }
}
function StepperStepComponent_Conditional_3_Conditional_1_Conditional_2_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 10);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵadvance();
    ɵɵtextInterpolate1("(", ctx_r1.optionalText, ")");
  }
}
function StepperStepComponent_Conditional_3_Conditional_1_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, StepperStepComponent_Conditional_3_Conditional_1_Conditional_2_Conditional_0_Template, 2, 1, "span", 8);
    ɵɵconditionalCreate(1, StepperStepComponent_Conditional_3_Conditional_1_Conditional_2_Conditional_1_Template, 1, 3, "kendo-icon-wrapper", 9);
    ɵɵconditionalCreate(2, StepperStepComponent_Conditional_3_Conditional_1_Conditional_2_Conditional_2_Template, 2, 1, "span", 10);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵconditional(ctx_r1.showLabelText ? 0 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.showLabelIcon ? 1 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.step.optional ? 2 : -1);
  }
}
function StepperStepComponent_Conditional_3_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 4);
    ɵɵconditionalCreate(1, StepperStepComponent_Conditional_3_Conditional_1_Conditional_1_Template, 1, 5, null, 2);
    ɵɵconditionalCreate(2, StepperStepComponent_Conditional_3_Conditional_1_Conditional_2_Template, 3, 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.labelTemplate ? 1 : -1);
    ɵɵadvance();
    ɵɵconditional(!ctx_r1.labelTemplate ? 2 : -1);
  }
}
function StepperStepComponent_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, StepperStepComponent_Conditional_3_Conditional_0_Template, 3, 4, "span", 3);
    ɵɵconditionalCreate(1, StepperStepComponent_Conditional_3_Conditional_1_Template, 3, 2, "span", 4);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵconditional(ctx_r1.showIndicator ? 0 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.showLabel ? 1 : -1);
  }
}
var _c262 = ["kendoStepperList", ""];
function StepperListComponent_For_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "li", 1);
  }
  if (rf & 2) {
    const step_r1 = ctx.$implicit;
    const ɵ$index_1_r2 = ctx.$index;
    const ctx_r2 = ɵɵnextContext();
    ɵɵstyleProp("max-width", ctx_r2.maxStepWidth, "%")("max-height", ctx_r2.maxStepHeight, "%");
    ɵɵclassProp("k-step-first", ɵ$index_1_r2 === 0)("k-step-last", ɵ$index_1_r2 === ctx_r2.steps.length - 1)("k-step-done", ɵ$index_1_r2 < ctx_r2.currentStep)("k-step-current", ɵ$index_1_r2 === ctx_r2.currentStep)("k-step-optional", step_r1.optional)("k-disabled", step_r1.disabled)("k-focus", ɵ$index_1_r2 === ctx_r2.focusedStep || !ctx_r2.isPresent(ctx_r2.focusedStep) && ɵ$index_1_r2 === ctx_r2.currentStep);
    ɵɵproperty("type", ctx_r2.stepType)("step", step_r1)("index", ɵ$index_1_r2)("current", ctx_r2.currentStep)("successIcon", ctx_r2.successIcon)("successSVGIcon", ctx_r2.successSVGIcon)("errorIcon", ctx_r2.errorIcon)("errorSVGIcon", ctx_r2.errorSVGIcon)("svgIcon", ctx_r2.svgIcon)("indicatorTemplate", ctx_r2.indicatorTemplate)("labelTemplate", ctx_r2.labelTemplate)("stepTemplate", ctx_r2.stepTemplate)("ngClass", step_r1.cssClass)("ngStyle", step_r1.cssStyle);
    ɵɵattribute("data-kendo-stepper-index", ɵ$index_1_r2);
  }
}
var _c272 = () => ({
  position: "start",
  visible: false
});
function StepperComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-progressbar", 2);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("animation", ctx_r0.progressAnimation)("max", ctx_r0.steps.length - 1)("label", ɵɵpureFunction0(8, _c272))("orientation", ctx_r0.orientation)("reverse", !ctx_r0.isHorizontal)("value", ctx_r0.currentStep)("ngStyle", ctx_r0.progressBarStyling);
    ɵɵattribute("aria-hidden", true);
  }
}
function AvatarComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
function AvatarComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 1);
    ɵɵelement(1, "img", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("src", ɵɵinterpolate(ctx_r0.imageSrc), ɵɵsanitizeUrl)("alt", ctx_r0.textFor("avatarAlt"))("ngStyle", ctx_r0.cssStyle);
  }
}
function AvatarComponent_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 2);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngStyle", ctx_r0.cssStyle);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.initials.substring(0, 2));
  }
}
function AvatarComponent_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 3);
    ɵɵelement(1, "kendo-icon-wrapper", 5);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngStyle", ctx_r0.cssStyle)("name", ctx_r0.icon)("customFontClass", ctx_r0.iconClass)("svgIcon", ctx_r0.svgIcon);
  }
}
function CardActionsComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
function CardActionsComponent_Conditional_1_For_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 2);
    ɵɵlistener("click", function CardActionsComponent_Conditional_1_For_1_Template_button_click_0_listener() {
      const action_r2 = ɵɵrestoreView(_r1).$implicit;
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.onClick(action_r2));
    });
    ɵɵelementStart(1, "span", 3);
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const action_r2 = ctx.$implicit;
    ɵɵclassProp("k-button-solid", !action_r2.flat)("k-button-flat", action_r2.flat)("k-button-solid-base", !action_r2.primary && !action_r2.flat)("k-button-solid-primary", action_r2.primary && !action_r2.flat)("k-button-flat-base", !action_r2.primary && action_r2.flat)("k-button-flat-primary", action_r2.primary && action_r2.flat);
    ɵɵadvance(2);
    ɵɵtextInterpolate(action_r2.text);
  }
}
function CardActionsComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵrepeaterCreate(0, CardActionsComponent_Conditional_1_For_1_Template, 3, 13, "button", 1, ɵɵrepeaterTrackByIdentity);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵrepeater(ctx_r2.actionsArray);
  }
}
function CardActionsComponent_Conditional_2_ng_template_0_Template(rf, ctx) {
}
function CardActionsComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, CardActionsComponent_Conditional_2_ng_template_0_Template, 0, 0, "ng-template", 0);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r2.actionsTemplate);
  }
}
var _c282 = ["content"];
function ExpansionPanelComponent_Conditional_2_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 8);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.title);
  }
}
function ExpansionPanelComponent_Conditional_2_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 10);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.subtitle, " ");
  }
}
function ExpansionPanelComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, ExpansionPanelComponent_Conditional_2_Conditional_0_Template, 2, 1, "div", 8);
    ɵɵelement(1, "span", 9);
    ɵɵconditionalCreate(2, ExpansionPanelComponent_Conditional_2_Conditional_2_Template, 2, 1, "div", 10);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵconditional(ctx_r1.title ? 0 : -1);
    ɵɵadvance(2);
    ɵɵconditional(ctx_r1.subtitle ? 2 : -1);
  }
}
function ExpansionPanelComponent_Conditional_3_ng_template_0_Template(rf, ctx) {
}
function ExpansionPanelComponent_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ExpansionPanelComponent_Conditional_3_ng_template_0_Template, 0, 0, "ng-template", 3);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.titleTemplate == null ? null : ctx_r1.titleTemplate.templateRef);
  }
}
function TileLayoutItemComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-tilelayout-item-header")(1, "h5", 0);
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("id", ctx_r0.titleId);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.title);
  }
}
function TileLayoutItemComponent_Conditional_2_For_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 2);
  }
  if (rf & 2) {
    const dir_r2 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵclassMap(ɵɵinterpolate1("k-resize-handle k-cursor-", dir_r2, "-resize"));
    ɵɵproperty("rtl", ctx_r0.rtl)("resizeDirection", dir_r2);
  }
}
function TileLayoutItemComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵrepeaterCreate(0, TileLayoutItemComponent_Conditional_2_For_1_Template, 1, 5, "div", 1, ɵɵrepeaterTrackByIdentity);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵrepeater(ctx_r0.resizeDirections);
  }
}
var _c292 = ["hint"];
function TileLayoutComponent_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 2);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("licenseMessage", ctx_r0.licenseMessage);
  }
}
var _c302 = ["callout"];
var _c312 = (a0) => ({
  "height": a0
});
var _c322 = (a0, a1, a2) => ({
  "k-callout-n": a0,
  "k-callout-w": a1,
  "k-callout-e": a2
});
var _c332 = (a0) => ({
  animationDuration: a0
});
var _c342 = (a0, a1) => ({
  value: a0,
  params: a1
});
function TimelineCardComponent_Conditional_3_Conditional_2_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0, " > ");
  }
}
function TimelineCardComponent_Conditional_3_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TimelineCardComponent_Conditional_3_Conditional_2_ng_template_0_Template, 1, 0, "ng-template", 4);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.headerTemplate == null ? null : ctx_r1.headerTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c252, ctx_r1.event, ctx_r1.index));
  }
}
function TimelineCardComponent_Conditional_3_Conditional_3_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "button", 8);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵproperty("icon", ctx_r1.calloutFontIcon)("svgIcon", ctx_r1.calloutSvgIcon);
    ɵɵattribute("aria-hidden", true);
  }
}
function TimelineCardComponent_Conditional_3_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 5)(1, "span", 7);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵconditionalCreate(3, TimelineCardComponent_Conditional_3_Conditional_3_Conditional_3_Template, 1, 3, "button", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r1.event.title);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.collapsible && ctx_r1.orientation === "vertical" ? 3 : -1);
  }
}
function TimelineCardComponent_Conditional_3_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 6);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.event.subtitle);
  }
}
function TimelineCardComponent_Conditional_3_Conditional_5_Conditional_1_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0, " > ");
  }
}
function TimelineCardComponent_Conditional_3_Conditional_5_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TimelineCardComponent_Conditional_3_Conditional_5_Conditional_1_ng_template_0_Template, 1, 0, "ng-template", 4);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.bodyTemplate == null ? null : ctx_r1.bodyTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c252, ctx_r1.event, ctx_r1.index));
  }
}
function TimelineCardComponent_Conditional_3_Conditional_5_Conditional_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "p");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.event.description);
  }
}
function TimelineCardComponent_Conditional_3_Conditional_5_Conditional_2_For_3_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "img", 10);
  }
  if (rf & 2) {
    const image_r4 = ɵɵnextContext().$implicit;
    ɵɵproperty("src", image_r4.src, ɵɵsanitizeUrl)("alt", image_r4.alt);
  }
}
function TimelineCardComponent_Conditional_3_Conditional_5_Conditional_2_For_3_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "img", 11);
  }
  if (rf & 2) {
    const image_r4 = ɵɵnextContext().$implicit;
    ɵɵproperty("src", image_r4.src, ɵɵsanitizeUrl);
  }
}
function TimelineCardComponent_Conditional_3_Conditional_5_Conditional_2_For_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, TimelineCardComponent_Conditional_3_Conditional_5_Conditional_2_For_3_Conditional_0_Template, 1, 2, "img", 10);
    ɵɵconditionalCreate(1, TimelineCardComponent_Conditional_3_Conditional_5_Conditional_2_For_3_Conditional_1_Template, 1, 1, "img", 11);
  }
  if (rf & 2) {
    const image_r4 = ctx.$implicit;
    ɵɵconditional(image_r4.alt ? 0 : -1);
    ɵɵadvance();
    ɵɵconditional(!image_r4.alt ? 1 : -1);
  }
}
function TimelineCardComponent_Conditional_3_Conditional_5_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 9);
    ɵɵconditionalCreate(1, TimelineCardComponent_Conditional_3_Conditional_5_Conditional_2_Conditional_1_Template, 2, 1, "p");
    ɵɵrepeaterCreate(2, TimelineCardComponent_Conditional_3_Conditional_5_Conditional_2_For_3_Template, 2, 2, null, null, ɵɵrepeaterTrackByIdentity);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.event.description ? 1 : -1);
    ɵɵadvance();
    ɵɵrepeater(ctx_r1.event.images);
  }
}
function TimelineCardComponent_Conditional_3_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-card-body");
    ɵɵlistener("@toggle.start", function TimelineCardComponent_Conditional_3_Conditional_5_Template_kendo_card_body_animation_toggle_start_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.animationStart());
    })("@toggle.done", function TimelineCardComponent_Conditional_3_Conditional_5_Template_kendo_card_body_animation_toggle_done_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.animationDone($event));
    });
    ɵɵconditionalCreate(1, TimelineCardComponent_Conditional_3_Conditional_5_Conditional_1_Template, 1, 5, null, 4);
    ɵɵconditionalCreate(2, TimelineCardComponent_Conditional_3_Conditional_5_Conditional_2_Template, 4, 1, "div", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("@toggle", ɵɵpureFunction2(5, _c342, ctx_r1.expanded ? "expanded" : "collapsed", ɵɵpureFunction1(3, _c332, ctx_r1.animationDuration || 0)));
    ɵɵadvance();
    ɵɵconditional(ctx_r1.bodyTemplate ? 1 : -1);
    ɵɵadvance();
    ɵɵconditional(!ctx_r1.bodyTemplate ? 2 : -1);
  }
}
function TimelineCardComponent_Conditional_3_Conditional_6_Conditional_1_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0, " > ");
  }
}
function TimelineCardComponent_Conditional_3_Conditional_6_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TimelineCardComponent_Conditional_3_Conditional_6_Conditional_1_ng_template_0_Template, 1, 0, "ng-template", 4);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.actionsTemplate == null ? null : ctx_r1.actionsTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c252, ctx_r1.event, ctx_r1.index));
  }
}
function TimelineCardComponent_Conditional_3_Conditional_6_Conditional_2_For_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 13);
    ɵɵlistener("click", function TimelineCardComponent_Conditional_3_Conditional_6_Conditional_2_For_1_Template_a_click_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r1.onActionClick($event));
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const action_r6 = ctx.$implicit;
    ɵɵproperty("href", action_r6.url, ɵɵsanitizeUrl)("target", action_r6.target === "blank" ? "_blank" : "_self");
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", action_r6.text, " ");
  }
}
function TimelineCardComponent_Conditional_3_Conditional_6_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵrepeaterCreate(0, TimelineCardComponent_Conditional_3_Conditional_6_Conditional_2_For_1_Template, 2, 3, "a", 12, ɵɵrepeaterTrackByIdentity);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵrepeater(ctx_r1.event.actions);
  }
}
function TimelineCardComponent_Conditional_3_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-card-actions");
    ɵɵconditionalCreate(1, TimelineCardComponent_Conditional_3_Conditional_6_Conditional_1_Template, 1, 5, null, 4);
    ɵɵconditionalCreate(2, TimelineCardComponent_Conditional_3_Conditional_6_Conditional_2_Template, 2, 0);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("@toggle", ɵɵpureFunction2(5, _c342, ctx_r1.expanded ? "expanded" : "collapsed", ɵɵpureFunction1(3, _c332, ctx_r1.animationDuration || 0)));
    ɵɵadvance();
    ɵɵconditional(ctx_r1.actionsTemplate ? 1 : -1);
    ɵɵadvance();
    ɵɵconditional(!ctx_r1.actionsTemplate ? 2 : -1);
  }
}
function TimelineCardComponent_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 3)(1, "kendo-card-header");
    ɵɵconditionalCreate(2, TimelineCardComponent_Conditional_3_Conditional_2_Template, 1, 5, null, 4);
    ɵɵconditionalCreate(3, TimelineCardComponent_Conditional_3_Conditional_3_Template, 4, 2, "div", 5);
    ɵɵconditionalCreate(4, TimelineCardComponent_Conditional_3_Conditional_4_Template, 2, 1, "div", 6);
    ɵɵelementEnd();
    ɵɵconditionalCreate(5, TimelineCardComponent_Conditional_3_Conditional_5_Template, 3, 8, "kendo-card-body");
    ɵɵconditionalCreate(6, TimelineCardComponent_Conditional_3_Conditional_6_Template, 3, 8, "kendo-card-actions");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵconditional(ctx_r1.headerTemplate ? 2 : -1);
    ɵɵadvance();
    ɵɵconditional(!ctx_r1.headerTemplate ? 3 : -1);
    ɵɵadvance();
    ɵɵconditional(!ctx_r1.headerTemplate ? 4 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.event.description || ctx_r1.event.images ? 5 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.event.actions ? 6 : -1);
  }
}
var _c352 = ["track"];
var _c362 = ["scrollableTrack"];
var _c372 = ["card"];
var _c382 = ["trackCircle"];
var _c392 = ["trackFlag"];
var _c40 = (a0) => ({
  transformValue: a0
});
var _c41 = () => ({
  "transform-origin": "left top"
});
var _c422 = () => ({});
var _c432 = (a0) => ({
  visibility: a0
});
function TimelineHorizontalComponent_For_8_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "li", 13, 2)(2, "span", 15);
    ɵɵtext(3);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const event_r2 = ɵɵnextContext().$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("ngStyle", ctx_r2.tabStyle());
    ɵɵattribute("role", "none")("aria-hidden", true);
    ɵɵadvance(3);
    ɵɵtextInterpolate(event_r2.isFlag);
  }
}
function TimelineHorizontalComponent_For_8_Conditional_1_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 18);
    ɵɵtext(1);
    ɵɵpipe(2, "kendoDate");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const event_r2 = ɵɵnextContext(2).$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind2(2, 1, event_r2.date, ctx_r2.dateFormat), " ");
  }
}
function TimelineHorizontalComponent_For_8_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "li", 16, 3);
    ɵɵlistener("click", function TimelineHorizontalComponent_For_8_Conditional_1_Template_li_click_0_listener() {
      ɵɵrestoreView(_r4);
      const ɵ$index_11_r5 = ɵɵnextContext().$index;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.navigateToEvent(ɵ$index_11_r5));
    });
    ɵɵelementStart(2, "div", 17);
    ɵɵconditionalCreate(3, TimelineHorizontalComponent_For_8_Conditional_1_Conditional_3_Template, 3, 4, "span", 18);
    ɵɵelementEnd();
    ɵɵelement(4, "span", 19);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("ngStyle", ctx_r2.tabStyle());
    ɵɵattribute("role", "tab");
    ɵɵadvance(3);
    ɵɵconditional(ctx_r2.showDateLabels ? 3 : -1);
  }
}
function TimelineHorizontalComponent_For_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, TimelineHorizontalComponent_For_8_Conditional_0_Template, 4, 4, "li", 13);
    ɵɵconditionalCreate(1, TimelineHorizontalComponent_For_8_Conditional_1_Template, 5, 3, "li", 14);
  }
  if (rf & 2) {
    const event_r2 = ctx.$implicit;
    ɵɵconditional(event_r2.isFlag ? 0 : -1);
    ɵɵadvance();
    ɵɵconditional(!event_r2.isFlag ? 1 : -1);
  }
}
function TimelineHorizontalComponent_Conditional_10_For_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "li", 21, 4);
    ɵɵlistener("transitionend", function TimelineHorizontalComponent_Conditional_10_For_2_Template_li_transitionend_0_listener() {
      ɵɵrestoreView(_r7);
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.onTransitionEnd());
    });
    ɵɵelement(2, "kendo-timeline-card", 22);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ɵ$index_35_r8 = ctx.$index;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance(2);
    ɵɵproperty("event", ctx_r2.selectedCardIndex === ɵ$index_35_r8 ? ctx_r2.selectedEvent : null)("expanded", true)("collapsible", ctx_r2.collapsibleEvents)("calloutStyle", ctx_r2.selectedCardIndex === ɵ$index_35_r8 ? ctx_r2.calloutStyle : ɵɵpureFunction0(12, _c422))("ngStyle", ɵɵpureFunction1(13, _c432, ctx_r2.selectedCardIndex === ɵ$index_35_r8 ? "visible" : "hidden"))("tabIndex", ctx_r2.selectedCardIndex === ɵ$index_35_r8 ? "0" : "-1")("navigable", ctx_r2.navigable)("index", ctx_r2.selectedEventIndex)("headerTemplate", ctx_r2.headerTemplate)("bodyTemplate", ctx_r2.bodyTemplate)("actionsTemplate", ctx_r2.actionsTemplate)("eventHeight", ctx_r2.eventHeight);
  }
}
function TimelineHorizontalComponent_Conditional_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "ul", 11);
    ɵɵlistener("@eventsSlide.done", function TimelineHorizontalComponent_Conditional_10_Template_ul_animation_eventsSlide_done_0_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onSlideDone());
    });
    ɵɵrepeaterCreate(1, TimelineHorizontalComponent_Conditional_10_For_2_Template, 3, 15, "li", 20, ɵɵrepeaterTrackByIdentity);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("@eventsSlide", ɵɵpureFunction2(4, _c342, ctx_r2.animationState, ɵɵpureFunction1(2, _c332, ctx_r2.animationDuration || 0)))("ngStyle", ɵɵpureFunction0(7, _c41));
    ɵɵadvance();
    ɵɵrepeater(ctx_r2.eventsInInterval);
  }
}
var _c44 = ["dateWrap"];
var _c45 = ["innerDate"];
var _c46 = (a0) => ({
  "k-reverse": a0
});
function TimelineVerticalComponent_Conditional_0_For_2_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "li", 3)(1, "span", 9);
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const event_r1 = ɵɵnextContext().$implicit;
    ɵɵadvance(2);
    ɵɵtextInterpolate(event_r1.flag);
  }
}
function TimelineVerticalComponent_Conditional_0_For_2_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 6, 2);
    ɵɵtext(2);
    ɵɵpipe(3, "kendoDate");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const event_r1 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ɵɵpipeBind2(3, 1, event_r1.date, ctx_r1.dateFormat), " ");
  }
}
function TimelineVerticalComponent_Conditional_0_For_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, TimelineVerticalComponent_Conditional_0_For_2_Conditional_0_Template, 3, 1, "li", 3);
    ɵɵelementStart(1, "li", 4)(2, "div", 5, 0);
    ɵɵconditionalCreate(4, TimelineVerticalComponent_Conditional_0_For_2_Conditional_4_Template, 4, 4, "span", 6);
    ɵɵelementEnd();
    ɵɵelement(5, "span", 7)(6, "kendo-timeline-card", 8, 1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const event_r1 = ctx.$implicit;
    const ɵ$index_4_r3 = ctx.$index;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵconditional(event_r1.flag ? 0 : -1);
    ɵɵadvance();
    ɵɵproperty("ngClass", ɵɵpureFunction1(15, _c46, ctx_r1.alterMode && ɵ$index_4_r3 % 2 === 0));
    ɵɵadvance(3);
    ɵɵconditional(ctx_r1.showDateLabels ? 4 : -1);
    ɵɵadvance(2);
    ɵɵproperty("event", event_r1)("expanded", event_r1.expanded || !ctx_r1.collapsibleEvents)("collapsible", ctx_r1.collapsibleEvents)("reversed", ctx_r1.alterMode && ɵ$index_4_r3 % 2 === 0)("tabIndex", "0")("navigable", ctx_r1.navigable)("animationDuration", ctx_r1.animationDuration)("headerTemplate", ctx_r1.headerTemplate)("bodyTemplate", ctx_r1.bodyTemplate)("actionsTemplate", ctx_r1.actionsTemplate)("index", ɵ$index_4_r3)("eventWidth", ctx_r1.eventWidth);
  }
}
function TimelineVerticalComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "ul");
    ɵɵrepeaterCreate(1, TimelineVerticalComponent_Conditional_0_For_2_Template, 8, 17, null, null, ɵɵrepeaterTrackByIdentity);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵrepeater(ctx_r1.events);
  }
}
function TimelineComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-timeline-vertical", 2);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("events", ctx_r0.events)("alterMode", ctx_r0.alterMode)("collapsibleEvents", ctx_r0.collapsibleEvents)("navigable", ctx_r0.navigable)("showDateLabels", ctx_r0.showDateLabels)("animationDuration", ctx_r0.animationDuration)("eventWidth", ctx_r0.eventWidth)("dateFormat", ctx_r0.dateFormat)("headerTemplate", ctx_r0.headerTemplate)("bodyTemplate", ctx_r0.bodyTemplate)("actionsTemplate", ctx_r0.actionsTemplate);
  }
}
function TimelineComponent_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-timeline-horizontal", 3);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("events", ctx_r0.events)("collapsibleEvents", false)("navigable", ctx_r0.navigable)("showDateLabels", ctx_r0.showDateLabels)("animationDuration", ctx_r0.animationDuration)("eventHeight", ctx_r0.eventHeight)("dateFormat", ctx_r0.dateFormat)("headerTemplate", ctx_r0.headerTemplate)("bodyTemplate", ctx_r0.bodyTemplate)("actionsTemplate", ctx_r0.actionsTemplate);
  }
}
var packageMetadata3 = {
  name: "@progress/kendo-angular-layout",
  productName: "Kendo UI for Angular",
  productCode: "KENDOUIANGULAR",
  productCodes: ["KENDOUIANGULAR"],
  publishDate: 1645546576,
  version: "22.0.1",
  licensingDocsUrl: "https://www.telerik.com/kendo-angular-ui/my-license/?utm_medium=product&utm_source=kendoangular&utm_campaign=kendo-ui-angular-purchase-license-keys-warning"
};
var PanelBarExpandMode;
(function(PanelBarExpandMode2) {
  PanelBarExpandMode2[PanelBarExpandMode2["Single"] = 0] = "Single";
  PanelBarExpandMode2[PanelBarExpandMode2["Full"] = 1] = "Full";
  PanelBarExpandMode2[PanelBarExpandMode2["Multiple"] = 2] = "Multiple";
  PanelBarExpandMode2[PanelBarExpandMode2["Default"] = 2] = "Default";
})(PanelBarExpandMode || (PanelBarExpandMode = {}));
var nextPanelbarId = 0;
var PanelBarService = class _PanelBarService {
  children$;
  keepContent$;
  parent$;
  pbId;
  animate;
  expandMode;
  itemClick;
  childSource;
  keepContentSource;
  parentSource;
  onKeepContent(keepContent) {
    this.keepContentSource.next(keepContent);
  }
  onSelect(event) {
    this.childSource.next(event);
  }
  onFocus() {
    this.parentSource.next(true);
  }
  onBlur() {
    this.parentSource.next(false);
  }
  constructor() {
    this.parentSource = new Subject();
    this.keepContentSource = new BehaviorSubject(false);
    this.childSource = new Subject();
    this.itemClick = new Subject();
    this.parent$ = this.parentSource.asObservable();
    this.children$ = this.childSource.asObservable();
    this.keepContent$ = this.keepContentSource.asObservable();
    this.pbId = nextPanelbarId++;
  }
  static ɵfac = function PanelBarService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PanelBarService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _PanelBarService,
    factory: _PanelBarService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PanelBarService, [{
    type: Injectable
  }], () => [], null);
})();
var PanelBarContentDirective = class _PanelBarContentDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function PanelBarContentDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PanelBarContentDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PanelBarContentDirective,
    selectors: [["", "kendoPanelBarContent", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PanelBarContentDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoPanelBarContent]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var PanelBarItemTitleDirective = class _PanelBarItemTitleDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function PanelBarItemTitleDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PanelBarItemTitleDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PanelBarItemTitleDirective,
    selectors: [["", "kendoPanelBarItemTitle", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PanelBarItemTitleDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoPanelBarItemTitle]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var nextId$1 = 0;
var SIZES = {
  small: "sm",
  medium: "md",
  large: "lg"
};
var ROUNDNESS = {
  small: "sm",
  medium: "md",
  large: "lg",
  full: "full"
};
var SHAPE_TO_ROUNDED = {
  rounded: "large",
  circle: "full"
};
var parsePanelBarItems = (data) => {
  return data.map((item) => {
    if (!isPresent5(item.id)) {
      item.id = `default-${nextId$1++}`;
    }
    if (item.children) {
      item.children = parsePanelBarItems(item.children);
    }
    return item;
  });
};
var isPresent5 = (value2) => value2 !== null && value2 !== void 0;
var isHorizontalArrowKey = (keyCode) => keyCode === Keys.ArrowLeft || keyCode === Keys.ArrowRight;
var isVerticalArrowKey = (keyCode) => keyCode === Keys.ArrowUp || keyCode === Keys.ArrowDown;
var isArrowKey = (keyCode) => isHorizontalArrowKey(keyCode) || isVerticalArrowKey(keyCode);
var isNavigationKey = (keyCode) => keyCode === Keys.PageUp || keyCode === Keys.PageDown || keyCode === Keys.Home || keyCode === Keys.End;
var getStylingClasses = (componentType, stylingOption, previousValue, newValue) => {
  switch (stylingOption) {
    case "size":
      return {
        toRemove: `k-${componentType}-${SIZES[previousValue]}`,
        toAdd: newValue !== "none" ? `k-${componentType}-${SIZES[newValue]}` : ""
      };
    case "rounded":
      return {
        toRemove: `k-rounded-${ROUNDNESS[previousValue]}`,
        toAdd: newValue !== "none" ? `k-rounded-${ROUNDNESS[newValue]}` : ""
      };
    default:
      break;
  }
};
var mapShapeToRounded = (shape) => SHAPE_TO_ROUNDED[shape] || "none";
var isNumber2 = (value2) => typeof value2 === "number" && isFinite(value2);
var focusableRegex = /^(?:a|input|select|option|textarea|button|object)$/i;
var toClassList = (classNames) => String(classNames).trim().split(" ");
var isFocusable2 = (element) => {
  if (element.tagName) {
    const tagName = element.tagName.toLowerCase();
    const tabIndex = element.getAttribute("tabindex");
    const skipTab = tabIndex === "-1";
    let focusable = tabIndex !== null && !skipTab;
    if (focusableRegex.test(tagName)) {
      focusable = !element.disabled && !skipTab;
    }
    return focusable;
  }
  return false;
};
var hasClass = (element, className) => Boolean(toClassList(element.className).find((name) => name === className));
var closestInScope3 = (target, predicate, scope, targetAttr) => {
  while (target && target !== scope && !predicate(target, targetAttr)) {
    target = target.parentNode;
  }
  if (target !== scope) {
    return target;
  }
};
var itemIndex = (item, indexAttr) => +item.getAttribute(indexAttr);
var hasItemIndex = (item, indexAttr) => isPresent5(item.getAttribute(indexAttr));
var closestItem = (target, targetAttr, scope) => closestInScope3(target, hasItemIndex, scope, targetAttr);
var nextId2 = 0;
var PanelBarItemComponent = class _PanelBarItemComponent {
  parent;
  eventService;
  element;
  renderer;
  /**
   * Sets the title of the PanelBar item ([see example]({% slug items_panelbar %}#toc-titles)).
   */
  title;
  /**
   * Allows the component to set the `"id"` property to each item.
   * Used to set the `id` attributes of the nested elements and to enable the WAI-ARIA support.
   */
  id = `default-${nextId2++}`;
  /**
   * Defines the icon that renders next to the title ([see example]({% slug items_panelbar %}#toc-title-icons)).
   *
   * @default ''
   */
  icon = "";
  /**
   * Defines the icon that renders next to the title by using a custom CSS class
   * ([see example]({% slug items_panelbar %}#toc-title-icons)).
   *
   * @default ''
   */
  iconClass = "";
  /**
   * Defines an SVG icon to render.
   * You can use either an [existing Kendo SVG icon](slug:svgicon_list) or a custom one.
   */
  set svgIcon(icon) {
    if (isDevMode() && icon && this.icon && this.iconClass) {
      throw new Error("Setting both icon/svgIcon and iconClass options at the same time is not supported.");
    }
    this._svgIcon = icon;
  }
  get svgIcon() {
    return this._svgIcon;
  }
  /**
   * Defines the location of the image that displays next to the title
   * ([see example]({% slug items_panelbar %}#toc-title-images)).
   *
   * @default ''
   */
  imageUrl = "";
  /**
   * When set to `true`, disables a PanelBar item ([see example]({% slug items_panelbar %}#toc-disabled-state)).
   *
   * @default false
   */
  disabled = false;
  /**
   * When set to `true`, expands the PanelBar item ([see example]({% slug items_panelbar %}#toc-expanded-state)).
   */
  set expanded(value2) {
    const activeState = this.animate ? "active" : "activeWithoutAnimation";
    this.state = value2 ? activeState : "inactive";
    if (!this.keepContent) {
      this.toggleExpandedChildAnimations(value2);
    }
    this._expanded = value2;
  }
  get expanded() {
    return this._expanded;
  }
  /**
   * Sets the selected state of a PanelBar item ([see example]({% slug items_panelbar %}#toc-selected-state)).
   *
   * @default false
   */
  selected = false;
  /**
   * Sets the content of the PanelBar item.
   * It is used when the [`items`]({% slug api_layout_panelbarcomponent %}#toc-items) property of the PanelBar is set.
   */
  content;
  /**
   * @hidden
   */
  items;
  /**
   * @hidden
   */
  template;
  header;
  contentWrapper;
  contentHeight;
  contentOverflow;
  keepContent = false;
  childrenItems;
  hasChildItems = false;
  hasItems = false;
  hasContent = false;
  state = "inactive";
  get animate() {
    return this.eventService.animate;
  }
  role = "treeitem";
  titleAttribute = null;
  // eslint-disable-line
  kItemClass = true;
  get kStateExpandedClass() {
    return !this.disabled && this.expanded && (this.hasChildItems || this.hasContent);
  }
  get itemId() {
    return "k-panelbar-" + this.eventService.pbId + "-item-" + this.id;
  }
  get ariaExpanded() {
    return this.hasChildItems || this.hasContent ? !this.disabled && this.expanded : null;
  }
  get ariaSelected() {
    return !this.disabled && this.selected;
  }
  get ariaDisabled() {
    return this.disabled ? true : null;
  }
  get headerClass() {
    return this.parent ? null : true;
  }
  /**
   * @hidden
   */
  get titleTemplate() {
    return this.titleTemplates.length > 0 ? this.titleTemplates.toArray()[0].templateRef : void 0;
  }
  viewChildItems;
  contentItems;
  //ContentChild does not support descendants property, so we use ContentChildren for contentTemplate instead
  contentTemplate;
  titleTemplates;
  focused = false;
  wrapperFocused = false;
  subscriptions = new Subscription(() => {
  });
  _expanded = false;
  level;
  _svgIcon;
  constructor(parent, eventService, element, renderer) {
    this.parent = parent;
    this.eventService = eventService;
    this.element = element;
    this.renderer = renderer;
    this.subscriptions.add(eventService.parent$.subscribe((focused) => this.onWrapperFocusChange(focused)));
    this.subscriptions.add(eventService.keepContent$.subscribe((keepContent) => this.keepContent = keepContent));
    this.wrapperFocused = parent ? parent.focused : false;
    this.level = this.parent ? this.parent.level + 1 : 0;
  }
  /**
   * @hidden
   */
  headerHeight() {
    return this.element.nativeElement.offsetHeight - (this.contentWrapper ? this.contentWrapper.nativeElement.offsetHeight : 0);
  }
  ngOnInit() {
    this.addLevelClass();
  }
  ngAfterContentChecked() {
    this.hasItems = this.items && this.items.filter((item) => !item.hidden).length > 0;
    this.hasChildItems = this.contentItems.filter((item) => item !== this).length > 0 || this.hasItems;
    this.hasContent = this.contentTemplate !== void 0 && this.contentTemplate.length > 0 || this.content !== void 0;
    this.validateConfiguration();
  }
  ngAfterViewChecked() {
    if (this.items) {
      this.childrenItems = this.viewChildItems.toArray();
    } else {
      this.childrenItems = this.contentItems.filter((item) => item !== this);
    }
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  /**
   * @hidden
   */
  onItemAction() {
    if (!this.disabled) {
      this.eventService.onSelect(this);
    }
  }
  /**
   * @hidden
   */
  onItemClick(e) {
    if (!isFocusable2(e.target)) {
      this.eventService.itemClick.next({
        item: this.serialize(),
        originalEvent: e
      });
      this.onItemAction();
    }
  }
  /**
   * @hidden
   */
  get iconClasses() {
    if (this.icon) {
      return `${this.icon}`;
    }
  }
  /**
   * @hidden
   */
  get customIconClasses() {
    if (this.iconClass) {
      return `${this.iconClass}`;
    }
  }
  /**
   * @hidden
   */
  get dirInnerCssClasses() {
    const dirClass = this.expanded ? "k-panelbar-collapse" : "k-panelbar-expand";
    return `k-panelbar-toggle ${dirClass}`;
  }
  /**
   * @hidden
   */
  get expanderSVGIcon() {
    return this.expanded ? chevronUpIcon : chevronDownIcon;
  }
  /**
   * @hidden
   */
  serialize() {
    return {
      content: this.content,
      disabled: this.disabled,
      expanded: this.expanded,
      focused: this.focused,
      icon: this.icon,
      iconClass: this.iconClass,
      svgIcon: this.svgIcon,
      id: this.id,
      imageUrl: this.imageUrl,
      selected: this.selected,
      title: this.title,
      children: this.items
    };
  }
  /**
   * @hidden
   */
  subTreeViewItems() {
    let subTree = [];
    this.viewChildItems.forEach((item) => {
      subTree = subTree.concat(item.subTreeViewItems());
      subTree.push(item);
    });
    return subTree;
  }
  /**
   * @hidden
   */
  validateConfiguration() {
    if (isDevMode()) {
      if (this.content && this.contentTemplate !== void 0 && this.contentTemplate.length > 0) {
        throw new Error("Invalid configuration: mixed template components and component property.");
      }
    }
  }
  /**
   * @hidden
   */
  toggleAnimationState(value2) {
    if (!this.animate) {
      return;
    }
    this.state = value2 && this.eventService.expandMode !== PanelBarExpandMode.Single ? "active" : "activeWithoutAnimation";
  }
  /**
   * @hidden
   */
  toggleExpandedChildAnimations(value2) {
    if (this.childrenItems) {
      this.childrenItems.forEach((child) => {
        if (child.expanded) {
          child.toggleAnimationState(value2);
          child.toggleExpandedChildAnimations(value2);
        }
      });
    }
  }
  /**
   * @hidden
   */
  addLevelClass() {
    if (this.level >= 0) {
      this.renderer.addClass(this.element.nativeElement, `k-level-${this.level}`);
    }
  }
  onWrapperFocusChange(focused) {
    this.wrapperFocused = focused;
  }
  static ɵfac = function PanelBarItemComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PanelBarItemComponent)(ɵɵdirectiveInject(_PanelBarItemComponent, 13), ɵɵdirectiveInject(PanelBarService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PanelBarItemComponent,
    selectors: [["kendo-panelbar-item"]],
    contentQueries: function PanelBarItemComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, _PanelBarItemComponent, 4)(dirIndex, PanelBarContentDirective, 4)(dirIndex, PanelBarItemTitleDirective, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.contentItems = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.contentTemplate = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.titleTemplates = _t);
      }
    },
    viewQuery: function PanelBarItemComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c03, 5)(_c111, 5)(_PanelBarItemComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.header = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.contentWrapper = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.viewChildItems = _t);
      }
    },
    hostVars: 12,
    hostBindings: function PanelBarItemComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵdomProperty("id", ctx.itemId);
        ɵɵattribute("role", ctx.role)("title", ctx.titleAttribute)("aria-expanded", ctx.ariaExpanded)("aria-selected", ctx.ariaSelected)("aria-disabled", ctx.ariaDisabled);
        ɵɵclassProp("k-panelbar-item", ctx.kItemClass)("k-expanded", ctx.kStateExpandedClass)("k-panelbar-header", ctx.headerClass);
      }
    },
    inputs: {
      title: "title",
      id: "id",
      icon: "icon",
      iconClass: "iconClass",
      svgIcon: "svgIcon",
      imageUrl: "imageUrl",
      disabled: "disabled",
      expanded: "expanded",
      selected: "selected",
      content: "content",
      items: "items",
      template: "template"
    },
    exportAs: ["kendoPanelbarItem"],
    ngContentSelectors: _c310,
    decls: 8,
    vars: 14,
    consts: [["header", ""], ["contentWrapper", ""], [3, "click"], ["innerCssClass", "k-panelbar-item-icon", 3, "name", "customFontClass", "svgIcon"], ["alt", "", 1, "k-image", "k-panelbar-item-icon", 3, "src"], [1, "k-panelbar-item-text"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "name", "svgIcon", "innerCssClass"], [1, "k-panelbar-group", 3, "overflow", "height"], [1, "k-panelbar-content", 3, "overflow", "height"], [1, "k-panelbar-group"], [1, "k-panelbar-content"], [3, "title", "id", "icon", "iconClass", "svgIcon", "imageUrl", "selected", "expanded", "disabled", "template", "items", "content"]],
    template: function PanelBarItemComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵprojectionDef(_c211);
        ɵɵelementStart(0, "span", 2, 0);
        ɵɵlistener("click", function PanelBarItemComponent_Template_span_click_0_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onItemClick($event));
        });
        ɵɵconditionalCreate(2, PanelBarItemComponent_Conditional_2_Template, 1, 3, "kendo-icon-wrapper", 3);
        ɵɵconditionalCreate(3, PanelBarItemComponent_Conditional_3_Template, 1, 1, "img", 4);
        ɵɵconditionalCreate(4, PanelBarItemComponent_Conditional_4_Template, 2, 1, "span", 5);
        ɵɵconditionalCreate(5, PanelBarItemComponent_Conditional_5_Template, 1, 16, null, 6);
        ɵɵconditionalCreate(6, PanelBarItemComponent_Conditional_6_Template, 1, 3, "kendo-icon-wrapper", 7);
        ɵɵelementEnd();
        ɵɵconditionalCreate(7, PanelBarItemComponent_Conditional_7_Template, 3, 1);
      }
      if (rf & 2) {
        ɵɵclassProp("k-link", true)("k-selected", !ctx.disabled && ctx.selected)("k-focus", ctx.focused && ctx.wrapperFocused)("k-disabled", ctx.disabled);
        ɵɵadvance(2);
        ɵɵconditional(ctx.icon || ctx.iconClass || ctx.svgIcon ? 2 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.imageUrl ? 3 : -1);
        ɵɵadvance();
        ɵɵconditional(!ctx.titleTemplate ? 4 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.titleTemplate ? 5 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.hasChildItems || ctx.hasContent ? 6 : -1);
        ɵɵadvance();
        ɵɵconditional(!ctx.disabled && ctx.expanded || ctx.keepContent !== false ? 7 : -1);
      }
    },
    dependencies: [IconWrapperComponent, NgTemplateOutlet],
    encapsulation: 2,
    data: {
      animation: [trigger("toggle", [state("inactive", style({
        display: "none"
      })), transition("* => active", [style({
        overflow: "hidden",
        display: "block",
        height: 0
      }), animate(200, style({
        height: AUTO_STYLE
      }))]), transition("active => *", [style({
        overflow: "hidden",
        height: AUTO_STYLE
      }), animate(200, style({
        height: 0,
        display: "none"
      }))])])]
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PanelBarItemComponent, [{
    type: Component,
    args: [{
      animations: [trigger("toggle", [state("inactive", style({
        display: "none"
      })), transition("* => active", [style({
        overflow: "hidden",
        display: "block",
        height: 0
      }), animate(200, style({
        height: AUTO_STYLE
      }))]), transition("active => *", [style({
        overflow: "hidden",
        height: AUTO_STYLE
      }), animate(200, style({
        height: 0,
        display: "none"
      }))])])],
      exportAs: "kendoPanelbarItem",
      selector: "kendo-panelbar-item",
      template: `
            <span
              #header
              [class.k-link]="true"
              [class.k-selected]="!disabled && selected"
              [class.k-focus]="focused && wrapperFocused"
              [class.k-disabled]="disabled"
              (click)="onItemClick($event)">
              @if (icon || iconClass || svgIcon) {
                <kendo-icon-wrapper
                  [name]="iconClasses"
                  [customFontClass]="customIconClasses"
                  [svgIcon]="svgIcon"
                  innerCssClass="k-panelbar-item-icon"
                  >
                </kendo-icon-wrapper>
              }
              @if (imageUrl) {
                <img
                  class="k-image k-panelbar-item-icon"
                  [src]="imageUrl"
                  alt="">
              }
              @if (!titleTemplate) {
                <span class="k-panelbar-item-text">{{title}}</span>
              }
              @if (titleTemplate) {
                <ng-template
                  [ngTemplateOutlet]="titleTemplate"
                [ngTemplateOutletContext]="{
                    item: {
                        title: title,
                        id: id,
                        icon: icon,
                        iconClass: iconClass,
                        svgIcon: svgIcon,
                        imageUrl: imageUrl,
                        selected: selected,
                        expanded: expanded,
                        disabled: disabled,
                        focused: focused,
                        content: content
                    }
                }"></ng-template>
            }
            @if (hasChildItems || hasContent) {
              <kendo-icon-wrapper
                [name]="expanded ? 'chevron-up' : 'chevron-down'"
                [svgIcon]="expanderSVGIcon"
                [innerCssClass]="dirInnerCssClasses"
                >
              </kendo-icon-wrapper>
            }
            </span>
            @if ((!disabled && expanded) || keepContent !== false) {
              @defer (when ((!disabled && expanded && keepContent !== true) || keepContent === true); prefetch on idle) {
                <div
                  #contentWrapper
                  [@toggle]="state"
                  [attr.role]="'group'"
                  [attr.aria-hidden]="!disabled && !expanded"
                  >
                @if (hasChildItems && !items?.length) {
                  <div
                    [style.overflow]="contentOverflow"
                    [style.height]="contentHeight"
                    class="k-panelbar-group"
                    >
                    <ng-content select="kendo-panelbar-item"></ng-content>
                  </div>
                }
                @if (hasContent && !content) {
                  <div
                    [style.overflow]="contentOverflow"
                    [style.height]="contentHeight"
                    class="k-panelbar-content">
                    <ng-template
                      [ngTemplateOutlet]="contentTemplate.first.templateRef"
                        [ngTemplateOutletContext]="{
                            $implicit: {
                                title: title,
                                id: id,
                                icon: icon,
                                imageUrl: imageUrl,
                                disabled: disabled,
                                content: content
                            }
                        }">
                  </ng-template>
                </div>
              }
              @if (hasItems) {
                <div
                  [style.overflow]="contentOverflow"
                  [style.height]="contentHeight"
                  class="k-panelbar-group">
                  @for (item of items; track item) {
                    @if (!item.hidden) {
                      <kendo-panelbar-item
                        [title]="item.title"
                        [id]="item.id"
                        [icon]="item.icon"
                        [iconClass]="item.iconClass"
                        [svgIcon]="item.svgIcon"
                        [imageUrl]="item.imageUrl"
                        [selected]="!!item.selected"
                        [expanded]="!!item.expanded"
                        [disabled]="!!item.disabled"
                        [template]="template"
                        [items]="item.children"
                        [content]="item.content">
                      </kendo-panelbar-item>
                    }
                  }
                </div>
              }
              @if (content) {
                <div
                  [style.overflow]="contentOverflow"
                  [style.height]="contentHeight"
                  class="k-panelbar-content">
                  <ng-template
                    [ngTemplateOutlet]="template"
                        [ngTemplateOutletContext]="{
                            $implicit: {
                                title: title,
                                id: id,
                                icon: icon,
                                imageUrl: imageUrl,
                                disabled: disabled,
                                content: content
                            }
                        }">
                </ng-template>
                @if (!template) {
                  {{content}}
                }
              </div>
            }
            </div>
              }
            }
    `,
      standalone: true,
      imports: [IconWrapperComponent, NgTemplateOutlet]
    }]
  }], () => [{
    type: PanelBarItemComponent,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }, {
      type: Optional
    }]
  }, {
    type: PanelBarService
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }], {
    title: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    icon: [{
      type: Input
    }],
    iconClass: [{
      type: Input
    }],
    svgIcon: [{
      type: Input
    }],
    imageUrl: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    expanded: [{
      type: Input
    }],
    selected: [{
      type: Input
    }],
    content: [{
      type: Input
    }],
    items: [{
      type: Input
    }],
    template: [{
      type: Input
    }],
    header: [{
      type: ViewChild,
      args: ["header", {
        static: false
      }]
    }],
    contentWrapper: [{
      type: ViewChild,
      args: ["contentWrapper", {
        static: false
      }]
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    titleAttribute: [{
      type: HostBinding,
      args: ["attr.title"]
    }],
    kItemClass: [{
      type: HostBinding,
      args: ["class.k-panelbar-item"]
    }],
    kStateExpandedClass: [{
      type: HostBinding,
      args: ["class.k-expanded"]
    }],
    itemId: [{
      type: HostBinding,
      args: ["id"]
    }],
    ariaExpanded: [{
      type: HostBinding,
      args: ["attr.aria-expanded"]
    }],
    ariaSelected: [{
      type: HostBinding,
      args: ["attr.aria-selected"]
    }],
    ariaDisabled: [{
      type: HostBinding,
      args: ["attr.aria-disabled"]
    }],
    headerClass: [{
      type: HostBinding,
      args: ["class.k-panelbar-header"]
    }],
    viewChildItems: [{
      type: ViewChildren,
      args: [PanelBarItemComponent]
    }],
    contentItems: [{
      type: ContentChildren,
      args: [PanelBarItemComponent]
    }],
    contentTemplate: [{
      type: ContentChildren,
      args: [PanelBarContentDirective, {
        descendants: false
      }]
    }],
    titleTemplates: [{
      type: ContentChildren,
      args: [PanelBarItemTitleDirective, {
        descendants: false
      }]
    }]
  });
})();
var PanelBarItemTemplateDirective = class _PanelBarItemTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function PanelBarItemTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PanelBarItemTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PanelBarItemTemplateDirective,
    selectors: [["", "kendoPanelBarItemTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PanelBarItemTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoPanelBarItemTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var PreventableEvent3 = class {
  prevented = false;
  /**
   * Prevents the default action for a specified event.
   * The source component suppresses the built-in behavior that follows the event.
   */
  preventDefault() {
    this.prevented = true;
  }
  /**
   * Returns `true` if the event was prevented by any of its subscribers.
   *
   * @returns `true` if the default action was prevented. Otherwise, returns `false`.
   */
  isDefaultPrevented() {
    return this.prevented;
  }
  /**
   * @hidden
   */
  constructor(args) {
    Object.assign(this, args);
  }
};
var PanelBarCollapseEvent = class extends PreventableEvent3 {
  /**
   * Defines the item that will be collapsed.
   */
  item;
};
var PanelBarExpandEvent = class extends PreventableEvent3 {
  /**
   * Defines the item that will be expanded.
   */
  item;
};
var PanelBarSelectEvent = class extends PreventableEvent3 {
  /**
   * Defines the item that will be selected.
   */
  item;
};
var PanelBarStateChangeEvent = class {
  /**
   * Defines a collection of all modified items.
   */
  items;
};
var PanelBarComponent = class _PanelBarComponent {
  localization;
  /**
   * Sets the expand mode of the PanelBar through the `PanelBarExpandMode` enum ([see example]({% slug expandmodes_panelbar %})).
   *
   * @default 'multiple
   */
  expandMode = PanelBarExpandMode.Default;
  /**
   * Allows the PanelBar to modify the selected state of the items.
   *
   * @default true
   */
  selectable = true;
  /**
   * Sets the animate state of the PanelBar ([see example]({% slug animations_panelbar %})).
   *
   * @default true
   */
  animate = true;
  /**
   * Sets the height of the component when the `"full"` expand mode is used.
   * This option is ignored when the `"multiple"` or `"single"` expand modes are used.
   *
   * @default '400px'
   */
  height = "400px";
  /**
  * Controls how the PanelBar renders item content.
  *
  * The available options are:
  *
  * * `true`&mdash;Renders all items' content and persists them in the DOM.
  * * `false`&mdash;Removes collapsed items' content from the DOM.
  * * `"loadOnDemand"`&mdash;Loads items' content only when expanded for the first time. Collapsed items' content is not rendered until the item is expanded.
  *
  * For more information, refer to the [Rendering Modes](slug:rendering_panelbar) article.
  *
  * @default false
  */
  get keepItemContent() {
    return this._keepItemContent;
  }
  set keepItemContent(keepItemContent) {
    this._keepItemContent = keepItemContent;
    this.eventService.onKeepContent(keepItemContent);
  }
  /**
   * Sets the items of the PanelBar as an array of `PanelBarItemModel` instances
   * ([see example]({% slug items_panelbar %})).
   */
  set items(data) {
    if (data) {
      this._items = parsePanelBarItems(data);
    }
  }
  get items() {
    return this._items;
  }
  /**
   * Fires when the state of the PanelBar changes.
   * This event is triggered when an item is selected, expanded, or collapsed.
   * ([see example](slug:routing_panelbar#using-router-service)).
   * The event data contains a collection of all items that are modified.
   */
  stateChange = new EventEmitter();
  /**
   * Fires when an item is about to be selected.
   * This event is preventable. If you cancel it, the item will not be selected
   * ([see example]({% slug events_panelbar %})).
   */
  select = new EventEmitter();
  /**
   * Fires when an item is about to be expanded.
   * This event is preventable. If you cancel it, the item will remain collapsed
   * ([see example]({% slug events_panelbar %})).
   */
  expand = new EventEmitter();
  /**
   * Fires when an item is about to be collapsed.
   * This event is preventable. If you cancel it, the item will remain expanded
   * ([see example]({% slug events_panelbar %})).
   */
  collapse = new EventEmitter();
  /**
   * Fires when an item is clicked ([see example]({% slug events_panelbar %})).
   */
  itemClick = new EventEmitter();
  hostClasses = true;
  tabIndex = 0;
  role = "tree";
  activeDescendant = "";
  get hostHeight() {
    return this.expandMode === PanelBarExpandMode.Full ? this.height : "auto";
  }
  get overflow() {
    return this.expandMode === PanelBarExpandMode.Full ? "hidden" : "visible";
  }
  get dir() {
    return this.localization.rtl ? "rtl" : "ltr";
  }
  template;
  contentItems;
  contentChildItems;
  viewChildItems;
  /**
   * @hidden
   */
  showLicenseWatermark = false;
  /**
   * @hidden
   */
  licenseMessage;
  allItems;
  childrenItems;
  isViewInit = true;
  focused = false;
  _items;
  _keepItemContent = false;
  elementRef;
  eventService;
  keyBindings;
  subs = new Subscription();
  constructor(elementRef, eventService, localization) {
    this.localization = localization;
    const isValid = N(packageMetadata3);
    this.licenseMessage = getLicenseMessage(packageMetadata3);
    this.showLicenseWatermark = shouldShowValidationUI(isValid);
    this.keyBindings = this.computedKeys;
    this.elementRef = elementRef;
    this.eventService = eventService;
    this.subs.add(this.eventService.children$.subscribe((event) => this.onItemAction(event)));
    this.subs.add(this.eventService.itemClick.subscribe((ev) => this.itemClick.emit(ev)));
  }
  /**
   * @hidden
   */
  invertKeys(original, inverted) {
    return this.localization.rtl ? inverted : original;
  }
  get computedKeys() {
    return {
      [Keys.Space]: () => this.selectFocusedItem(),
      [Keys.Enter]: () => this.selectFocusedItem(),
      [Keys.NumpadEnter]: () => this.selectFocusedItem(),
      [Keys.ArrowUp]: () => this.focusPreviousItem(),
      [this.invertKeys(Keys.ArrowLeft, Keys.ArrowRight)]: () => this.collapseItem(),
      [Keys.ArrowDown]: () => this.focusNextItem(),
      [this.invertKeys(Keys.ArrowRight, Keys.ArrowLeft)]: () => this.expandItem(),
      [Keys.End]: () => this.focusLastItem(),
      [Keys.Home]: () => this.focusFirstItem()
    };
  }
  ngOnDestroy() {
    this.subs.unsubscribe();
  }
  ngOnInit() {
    this.subs.add(this.localization.changes.subscribe(() => this.keyBindings = this.computedKeys));
    this.eventService.animate = this.animate;
    this.eventService.expandMode = this.expandMode;
  }
  ngAfterViewChecked() {
    if (this.items) {
      this.childrenItems = this.viewChildItems.toArray();
      this.allItems = this.viewItems;
    } else {
      this.childrenItems = this.contentChildItems.toArray();
      this.allItems = this.contentItems.toArray();
    }
    if (this.isViewInit && this.childrenItems.length) {
      this.isViewInit = false;
      setTimeout(() => this.updateChildrenHeight());
    }
    this.validateConfiguration();
  }
  ngOnChanges(changes) {
    if (changes["height"] || changes["expandMode"] || changes["items"]) {
      if (this.childrenItems) {
        setTimeout(this.updateChildrenHeight);
      }
    }
    if (changes["animate"]) {
      this.eventService.animate = this.animate;
    }
    if (changes["expandMode"]) {
      this.eventService.expandMode = this.expandMode;
    }
  }
  get templateRef() {
    return this.template ? this.template.templateRef : void 0;
  }
  /**
   * @hidden
   */
  onComponentClick(event) {
    const itemClicked = this.visibleItems().some((item) => {
      return item.header.nativeElement.contains(event.target);
    });
    if (!isFocusable2(event.target) && !this.focused && itemClicked) {
      this.elementRef.nativeElement.focus();
    }
  }
  /**
   * @hidden
   */
  onComponentFocus() {
    this.eventService.onFocus();
    this.focused = true;
    if (this.allItems.length > 0) {
      const visibleItems = this.visibleItems();
      const focusedItems = visibleItems.filter((item) => item.focused);
      if (!focusedItems.length && visibleItems.length > 0) {
        visibleItems[0].focused = true;
        this.activeDescendant = visibleItems[0].itemId;
      }
    }
  }
  /**
   * @hidden
   */
  onComponentBlur() {
    this.eventService.onBlur();
    this.focused = false;
    this.activeDescendant = "";
  }
  /**
   * @hidden
   */
  onComponentKeyDown(event) {
    if (event.target === this.elementRef.nativeElement) {
      const code = normalizeKeys(event);
      if (code === Keys.Space || code === Keys.ArrowUp || code === Keys.ArrowDown || code === Keys.ArrowLeft || code === Keys.ArrowRight || code === Keys.Home || code === Keys.End || code === Keys.PageUp || code === Keys.PageDown) {
        event.preventDefault();
      }
      const handler = this.keyBindings[code];
      if (handler) {
        handler();
      }
    }
  }
  /**
   * @hidden
   */
  emitEvent(event, item) {
    let eventArgs;
    switch (event) {
      case "select":
        eventArgs = new PanelBarSelectEvent();
        break;
      case "collapse":
        eventArgs = new PanelBarCollapseEvent();
        break;
      default:
        eventArgs = new PanelBarExpandEvent();
        break;
    }
    eventArgs.item = item.serialize();
    this[event].emit(eventArgs);
    return eventArgs;
  }
  get viewItems() {
    let treeItems = [];
    this.viewChildItems.toArray().forEach((item) => {
      treeItems.push(item);
      treeItems = treeItems.concat(item.subTreeViewItems());
    });
    return treeItems;
  }
  validateConfiguration() {
    if (isDevMode()) {
      if (this.items && this.contentItems && this.contentItems.length > 0) {
        throw new Error("Invalid configuration: mixed template components and items property.");
      }
    }
  }
  updateChildrenHeight = () => {
    let childrenHeight = 0;
    const panelbarHeight = this.elementRef.nativeElement.offsetHeight;
    const contentOverflow = this.expandMode === PanelBarExpandMode.Full ? "auto" : "visible";
    this.childrenItems.forEach((item) => {
      childrenHeight += item.headerHeight();
    });
    this.childrenItems.forEach((item) => {
      item.contentHeight = PanelBarExpandMode.Full === this.expandMode ? panelbarHeight - childrenHeight + "px" : "auto";
      item.contentOverflow = contentOverflow;
    });
  };
  onItemAction(item) {
    if (!item) {
      return;
    }
    const modifiedItems = new Array();
    const selectPreventedItems = [];
    let isSelectPrevented = false;
    if (this.selectable && !item.selected) {
      isSelectPrevented = this.emitEvent("select", item).isDefaultPrevented();
    }
    if (!isSelectPrevented) {
      this.allItems.forEach((currentItem) => {
        let selectedState = currentItem === item;
        const focusedState = selectedState;
        selectedState = this.selectable ? selectedState : currentItem.selected;
        if (currentItem.selected !== selectedState || currentItem.focused !== focusedState) {
          currentItem.selected = selectedState;
          currentItem.focused = focusedState;
          this.activeDescendant = focusedState ? currentItem.itemId : "";
          modifiedItems.push(currentItem);
        }
      });
    } else {
      selectPreventedItems.push(item);
      this.allItems.forEach((currentItem) => {
        const focusedState = currentItem === item;
        if (currentItem.focused !== focusedState) {
          currentItem.focused = focusedState;
          this.activeDescendant = focusedState ? currentItem.itemId : "";
          modifiedItems.push(currentItem);
        }
      });
    }
    if (this.expandMode === PanelBarExpandMode.Multiple) {
      if ((item.hasChildItems || item.hasContent) && !selectPreventedItems.includes(item)) {
        const isEventPrevented = item.expanded ? this.emitEvent("collapse", item).isDefaultPrevented() : this.emitEvent("expand", item).isDefaultPrevented();
        if (!isEventPrevented) {
          item.expanded = !item.expanded;
          if (modifiedItems.indexOf(item) < 0) {
            modifiedItems.push(item);
          }
        }
      }
    } else {
      const siblings = item.parent ? item.parent.childrenItems : this.childrenItems;
      let preventedCollapseItem;
      const expandedItems = [];
      if ((item.hasChildItems || item.hasContent) && !selectPreventedItems.includes(item)) {
        siblings.forEach((currentItem) => {
          const expandedState = currentItem === item;
          if (currentItem.expanded !== expandedState) {
            const isEventPrevented = currentItem.expanded ? this.emitEvent("collapse", currentItem).isDefaultPrevented() : this.emitEvent("expand", currentItem).isDefaultPrevented();
            if (!isEventPrevented) {
              currentItem.expanded = expandedState;
              if (currentItem.expanded) {
                expandedItems.push(currentItem);
              }
              if (modifiedItems.indexOf(currentItem) < 0) {
                modifiedItems.push(currentItem);
              }
            } else if (isEventPrevented && currentItem.expanded) {
              preventedCollapseItem = currentItem;
            }
          } else if (currentItem.expanded === expandedState && expandedState) {
            const isCollapsePrevented = this.emitEvent("collapse", currentItem).isDefaultPrevented();
            if (!isCollapsePrevented) {
              currentItem.expanded = !currentItem.expanded;
              if (modifiedItems.indexOf(currentItem) < 0) {
                modifiedItems.push(currentItem);
              }
            }
          }
        });
        expandedItems.forEach((item2) => {
          if (preventedCollapseItem && item2.id !== preventedCollapseItem.id) {
            item2.expanded = false;
            if (isDevMode()) {
              const expandMode = PanelBarExpandMode[this.expandMode].toLowerCase();
              console.warn(`
                            The ${expandMode} expandMode allows the expansion of only one item at a time.
                            See https://www.telerik.com/kendo-angular-ui/components/layout/panelbar/expand-modes/`);
            }
          }
        });
      }
    }
    if (modifiedItems.length > 0) {
      const eventArgs = new PanelBarStateChangeEvent();
      eventArgs.items = modifiedItems.map((currentItem) => currentItem.serialize());
      this.stateChange.emit(eventArgs);
    }
  }
  isVisible(item) {
    const visibleItems = this.visibleItems();
    return visibleItems.some((i) => i === item);
  }
  getVisibleParent(item) {
    const visibleItems = this.visibleItems();
    if (!item.parent) {
      return item;
    }
    return visibleItems.some((i) => i === item.parent) ? item.parent : this.getVisibleParent(item.parent);
  }
  focusItem(action) {
    const visibleItems = this.visibleItems();
    let currentIndex = visibleItems.findIndex((item) => item.focused);
    let currentItem = visibleItems[currentIndex];
    let nextItem;
    if (currentIndex === -1) {
      const focusedItem = this.allItems.find((item) => item.focused);
      focusedItem.focused = false;
      currentItem = this.getVisibleParent(focusedItem);
      currentIndex = visibleItems.findIndex((item) => item === currentItem);
    }
    switch (action) {
      case "lastItem":
        nextItem = visibleItems[visibleItems.length - 1];
        break;
      case "firstItem":
        nextItem = visibleItems[0];
        break;
      case "nextItem":
        nextItem = visibleItems[currentIndex < visibleItems.length - 1 ? currentIndex + 1 : 0];
        break;
      case "previousItem":
        nextItem = visibleItems[currentIndex > 0 ? currentIndex - 1 : visibleItems.length - 1];
        break;
      default:
    }
    if (currentItem && nextItem && currentItem !== nextItem) {
      this.moveFocus(currentItem, nextItem);
    }
  }
  moveFocus(from2, to) {
    if (!from2 || !to) {
      return;
    }
    from2.focused = false;
    to.focused = true;
    this.activeDescendant = to.itemId;
    const modifiedItems = new Array(from2.serialize(), to.serialize());
    const eventArgs = new PanelBarStateChangeEvent();
    eventArgs.items = modifiedItems;
    this.stateChange.emit(eventArgs);
  }
  focusLastItem() {
    this.focusItem("lastItem");
  }
  focusFirstItem() {
    this.focusItem("firstItem");
  }
  focusNextItem() {
    this.focusItem("nextItem");
  }
  focusPreviousItem() {
    this.focusItem("previousItem");
  }
  expandItem() {
    let currentItem = this.allItems.filter((item) => item.focused)[0];
    if (!this.isVisible(currentItem)) {
      currentItem.focused = false;
      currentItem = this.getVisibleParent(currentItem);
    }
    if (currentItem.hasChildItems || currentItem.hasContent) {
      if (!currentItem.expanded) {
        this.onItemAction(currentItem);
      } else if (currentItem.hasChildItems) {
        const firstChildIndex = currentItem.childrenItems.findIndex((item) => !item.disabled);
        if (firstChildIndex > -1) {
          this.moveFocus(currentItem, currentItem.childrenItems[firstChildIndex]);
        }
      }
    }
  }
  collapseItem() {
    const currentItem = this.allItems.filter((item) => item.focused)[0];
    if (currentItem.expanded) {
      this.onItemAction(currentItem);
    } else if (currentItem.parent) {
      this.moveFocus(currentItem, currentItem.parent);
    }
  }
  selectFocusedItem() {
    let focusedItem = this.allItems.filter((item) => item.focused)[0];
    if (!this.isVisible(focusedItem)) {
      focusedItem.focused = false;
      focusedItem = this.getVisibleParent(focusedItem);
    }
    if (focusedItem) {
      focusedItem.onItemAction();
    }
  }
  visibleItems() {
    return this.flatVisibleItems(this.childrenItems);
  }
  flatVisibleItems(listOfItems = new Array(), flattedItems = new Array()) {
    listOfItems.forEach((item) => {
      flattedItems.push(item);
      if (item.expanded && item.hasChildItems) {
        this.flatVisibleItems(item.childrenItems, flattedItems);
      }
    });
    return flattedItems;
  }
  static ɵfac = function PanelBarComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PanelBarComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(PanelBarService), ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PanelBarComponent,
    selectors: [["kendo-panelbar"]],
    contentQueries: function PanelBarComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, PanelBarItemTemplateDirective, 5)(dirIndex, PanelBarItemComponent, 5)(dirIndex, PanelBarItemComponent, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.template = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.contentItems = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.contentChildItems = _t);
      }
    },
    viewQuery: function PanelBarComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(PanelBarItemComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.viewChildItems = _t);
      }
    },
    hostVars: 10,
    hostBindings: function PanelBarComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("click", function PanelBarComponent_click_HostBindingHandler($event) {
          return ctx.onComponentClick($event);
        })("focus", function PanelBarComponent_focus_HostBindingHandler() {
          return ctx.onComponentFocus();
        })("blur", function PanelBarComponent_blur_HostBindingHandler() {
          return ctx.onComponentBlur();
        })("keydown", function PanelBarComponent_keydown_HostBindingHandler($event) {
          return ctx.onComponentKeyDown($event);
        });
      }
      if (rf & 2) {
        ɵɵattribute("tabIndex", ctx.tabIndex)("role", ctx.role)("aria-activedescendant", ctx.activeDescendant)("dir", ctx.dir);
        ɵɵstyleProp("height", ctx.hostHeight)("overflow", ctx.overflow);
        ɵɵclassProp("k-panelbar", ctx.hostClasses);
      }
    },
    inputs: {
      expandMode: "expandMode",
      selectable: "selectable",
      animate: "animate",
      height: "height",
      keepItemContent: "keepItemContent",
      items: "items"
    },
    outputs: {
      stateChange: "stateChange",
      select: "select",
      expand: "expand",
      collapse: "collapse",
      itemClick: "itemClick"
    },
    exportAs: ["kendoPanelbar"],
    features: [ɵɵProvidersFeature([PanelBarService, LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.panelbar"
    }]), ɵɵNgOnChangesFeature],
    ngContentSelectors: _c310,
    decls: 3,
    vars: 3,
    consts: [["kendoWatermarkOverlay", "", 3, "licenseMessage"], [3, "title", "id", "icon", "iconClass", "svgIcon", "imageUrl", "selected", "expanded", "disabled", "template", "items", "content"]],
    template: function PanelBarComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef(_c211);
        ɵɵconditionalCreate(0, PanelBarComponent_Conditional_0_Template, 1, 0);
        ɵɵconditionalCreate(1, PanelBarComponent_Conditional_1_Template, 2, 0);
        ɵɵconditionalCreate(2, PanelBarComponent_Conditional_2_Template, 1, 1, "div", 0);
      }
      if (rf & 2) {
        ɵɵconditional(ctx.contentChildItems && !ctx.items ? 0 : -1);
        ɵɵadvance();
        ɵɵconditional((ctx.items == null ? null : ctx.items.length) ? 1 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.showLicenseWatermark ? 2 : -1);
      }
    },
    dependencies: [PanelBarItemComponent, WatermarkOverlayComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PanelBarComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoPanelbar",
      providers: [PanelBarService, LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.panelbar"
      }],
      selector: "kendo-panelbar",
      template: `
        @if (contentChildItems && !items) {
          <ng-content select="kendo-panelbar-item"></ng-content>
        }
        @if (items?.length) {
          @for (item of items; track item) {
            @if (!item.hidden) {
              <kendo-panelbar-item
                [title]="item.title"
                [id]="item.id"
                [icon]="item.icon"
                [iconClass]="item.iconClass"
                [svgIcon]="item.svgIcon"
                [imageUrl]="item.imageUrl"
                [selected]="!!item.selected"
                [expanded]="!!item.expanded"
                [disabled]="!!item.disabled"
                [template]="templateRef"
                [items]="item.children"
                [content]="item.content"
                >
              </kendo-panelbar-item>
            }
          }
        }

        @if (showLicenseWatermark) {
          <div kendoWatermarkOverlay [licenseMessage]="licenseMessage"></div>
        }
        `,
      standalone: true,
      imports: [PanelBarItemComponent, WatermarkOverlayComponent]
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: PanelBarService
  }, {
    type: LocalizationService
  }], {
    expandMode: [{
      type: Input
    }],
    selectable: [{
      type: Input
    }],
    animate: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    keepItemContent: [{
      type: Input
    }],
    items: [{
      type: Input
    }],
    stateChange: [{
      type: Output
    }],
    select: [{
      type: Output
    }],
    expand: [{
      type: Output
    }],
    collapse: [{
      type: Output
    }],
    itemClick: [{
      type: Output
    }],
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-panelbar"]
    }],
    tabIndex: [{
      type: HostBinding,
      args: ["attr.tabIndex"]
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    activeDescendant: [{
      type: HostBinding,
      args: ["attr.aria-activedescendant"]
    }],
    hostHeight: [{
      type: HostBinding,
      args: ["style.height"]
    }],
    overflow: [{
      type: HostBinding,
      args: ["style.overflow"]
    }],
    dir: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    template: [{
      type: ContentChild,
      args: [PanelBarItemTemplateDirective, {
        static: false
      }]
    }],
    contentItems: [{
      type: ContentChildren,
      args: [PanelBarItemComponent, {
        descendants: true
      }]
    }],
    contentChildItems: [{
      type: ContentChildren,
      args: [PanelBarItemComponent]
    }],
    viewChildItems: [{
      type: ViewChildren,
      args: [PanelBarItemComponent]
    }],
    onComponentClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }],
    onComponentFocus: [{
      type: HostListener,
      args: ["focus"]
    }],
    onComponentBlur: [{
      type: HostListener,
      args: ["blur"]
    }],
    onComponentKeyDown: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }]
  });
})();
var shouldTogglePrev = (keyCode, prev, next2) => {
  const leftArrow = keyCode === Keys.ArrowLeft;
  const upArrow = keyCode === Keys.ArrowUp;
  const collapsePrev = !prev.collapsed && !next2.collapsed && (leftArrow || upArrow);
  const expandPrev = prev.collapsed && !(leftArrow || upArrow);
  return collapsePrev || expandPrev;
};
var shouldToggleNext = (keyCode, prev, next2) => {
  const leftArrow = keyCode === Keys.ArrowLeft;
  const upArrow = keyCode === Keys.ArrowUp;
  const collapseNext = !next2.collapsed && !prev.collapsed && !(leftArrow || upArrow);
  const expandNext = next2.collapsed && (leftArrow || upArrow);
  return collapseNext || expandNext;
};
var shouldToggleOrResize = (keyCode, orientation) => {
  const isHorizontal = orientation === "horizontal";
  const isHorizontalChange = isHorizontal && (keyCode === Keys.ArrowLeft || keyCode === Keys.ArrowRight);
  const isVerticalChange = !isHorizontal && (keyCode === Keys.ArrowUp || keyCode === Keys.ArrowDown);
  return isHorizontalChange || isVerticalChange;
};
var MAX_PANE_HEIGHT = 33554400;
var SplitterService = class _SplitterService {
  zone;
  panes;
  splitterBars;
  layoutChange = new EventEmitter();
  resizeStep = 10;
  fixedHeight;
  constructor(zone) {
    this.zone = zone;
  }
  tryToggle(paneIndex) {
    const pane = this.pane(paneIndex);
    if (pane.collapsible) {
      pane.collapsed = !pane.collapsed;
      pane.collapsedChange.emit(pane.collapsed);
      this.emit(this.layoutChange, {});
      if (pane.collapsed) {
        pane.detectChanges();
      }
    }
    const notCollapsed = this.panes.filter((p) => !p.collapsed);
    const allHaveFixedSize = notCollapsed.every((p) => p.fixedSize);
    notCollapsed.filter((p) => p.fixedSize).forEach((pane2) => {
      pane2.forceExpand = allHaveFixedSize ? true : false;
    });
    return pane.collapsible;
  }
  togglePane(keyCode, index) {
    const prev = this.pane(index);
    const next2 = this.pane(index + 1);
    if (shouldTogglePrev(keyCode, prev, next2)) {
      this.tryToggle(index);
    } else if (shouldToggleNext(keyCode, prev, next2)) {
      this.tryToggle(index + 1);
    }
  }
  resizePane(keyCode, index) {
    const state2 = this.dragState(index);
    const direction = keyCode === Keys.ArrowLeft || keyCode === (this.rtl ? Keys.ArrowDown : Keys.ArrowUp);
    let step = direction ? -this.resizeStep : this.resizeStep;
    if (this.rtl) {
      step = -step;
    }
    this.setSize(state2, step);
  }
  toggleContentOverlay(index, show) {
    this.pane(index).toggleOverlay(show);
    this.pane(index + 1).toggleOverlay(show);
  }
  dragState(splitbarIndex) {
    const prev = this.pane(splitbarIndex);
    const next2 = this.pane(splitbarIndex + 1);
    const total = prev.computedSize + next2.computedSize;
    const px = (s) => this.toPixels(s);
    return {
      prev: {
        index: splitbarIndex,
        initialSize: prev.computedSize,
        min: px(prev.min) || total - px(next2.max) || 0,
        max: px(prev.max) || total - px(next2.min) || total
      },
      next: {
        index: splitbarIndex + 1,
        initialSize: next2.computedSize,
        min: px(next2.min) || total - px(prev.max) || 0,
        max: px(next2.max) || total - px(prev.min) || total
      }
    };
  }
  setSize(state2, delta) {
    const clamp3 = (min, max, v) => Math.min(max, Math.max(min, v));
    const resize = (paneState, change, modifyMax = false) => {
      const pane = this.pane(paneState.index);
      const splitterSize = this.containerSize();
      const newSize = clamp3(paneState.min, modifyMax ? MAX_PANE_HEIGHT : paneState.max, paneState.initialSize + change);
      let size = "";
      if (this.isPercent(pane.size)) {
        size = 100 * newSize / splitterSize + "%";
      } else {
        size = newSize + "px";
      }
      pane.size = size;
      pane.isResized = true;
      this.emit(pane.sizeChange, size);
    };
    const prevPane = this.pane(state2.prev.index);
    const nextPane = this.pane(state2.next.index);
    const canResizeBothPanes = this.panes.length > 2;
    const modifyPrevMax = prevPane.orientation === "vertical" && !this.fixedHeight && !prevPane.max;
    const modifyNextMax = prevPane.orientation === "vertical" && !this.fixedHeight && !nextPane.max;
    if (prevPane.fixedSize && nextPane.fixedSize || canResizeBothPanes) {
      const bothVertical = prevPane.orientation === "vertical" && nextPane.orientation === "vertical";
      if (bothVertical) {
        if (modifyNextMax) {
          resize(state2.prev, delta, modifyPrevMax);
        } else if (modifyPrevMax) {
          resize(state2.next, -delta, modifyNextMax);
        } else {
          resize(state2.prev, delta, modifyNextMax);
          resize(state2.next, -delta, modifyPrevMax);
        }
      } else {
        resize(state2.prev, delta);
        resize(state2.next, -delta);
      }
    } else if (nextPane.fixedSize || nextPane.collapsible) {
      resize(state2.next, -delta, modifyNextMax);
    } else {
      resize(state2.prev, delta, modifyPrevMax);
    }
    this.emit(this.layoutChange, {});
  }
  isDraggable(splitBarIndex) {
    const prev = this.pane(splitBarIndex);
    const next2 = this.pane(splitBarIndex + 1);
    const betweenResizablePanes = prev?.resizable && next2?.resizable;
    const nearCollapsedPane = prev?.collapsed || next2?.collapsed;
    return betweenResizablePanes && !nearCollapsedPane;
  }
  isStatic(splitBarIndex) {
    const prev = this.pane(splitBarIndex);
    const next2 = this.pane(splitBarIndex + 1);
    const betweenResizablePanes = prev?.resizable && next2?.resizable;
    const nearCollapsiblePane = prev?.collapsible || next2?.collapsible;
    return !betweenResizablePanes && !nearCollapsiblePane;
  }
  pane(index) {
    if (!isDocumentAvailable()) {
      return;
    }
    if (!this.panes) {
      throw new Error("Panes not initialized");
    }
    if (index < 0 || index >= this.panes.length) {
      throw new Error("Index out of range");
    }
    return this.panes[index];
  }
  paneByIndex(pane) {
    if (!this.panes) {
      return -1;
    }
    return this.panes.findIndex((splitterPane) => splitterPane === pane);
  }
  getPaneSplitterBar(pane) {
    if (!this.splitterBars) {
      return;
    }
    const paneIndex = this.paneByIndex(pane);
    if (paneIndex < 0 || paneIndex >= this.splitterBars.length) {
      return null;
    }
    return this.splitterBars[paneIndex];
  }
  configure({
    panes,
    orientation,
    containerSize,
    direction
  }) {
    this.panes = panes;
    this.panes.forEach((pane, index) => {
      pane.order = index * 2;
      pane.orientation = orientation;
    });
    this.containerSize = containerSize;
    this.rtl = direction === "rtl";
  }
  containerSize = () => {
  };
  rtl;
  isPercent(size) {
    return /%$/.test(size);
  }
  toPixels(size) {
    let result = parseFloat(size);
    if (this.isPercent(size)) {
      result = this.containerSize() * result / 100;
    }
    return result;
  }
  emit(emitter, args) {
    if (emitter.observers.length) {
      this.zone.run(() => emitter.emit(args));
    }
  }
  static ɵfac = function SplitterService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SplitterService)(ɵɵinject(NgZone));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _SplitterService,
    factory: _SplitterService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SplitterService, [{
    type: Injectable
  }], () => [{
    type: NgZone
  }], null);
})();
var SplitterPaneComponent = class _SplitterPaneComponent {
  element;
  renderer;
  cdr;
  splitterService;
  /**
   * @hidden
   */
  set order(paneOrder) {
    this._order = paneOrder;
    this.setOrderStyles();
  }
  get order() {
    return this._order;
  }
  /**
   * Defines the initial size of the pane.
   * Accepts values in pixels and percentages.
   * The value must be between the `min` and `max` properties.
   */
  set size(newSize) {
    this._size = newSize;
    if (!this._collapsed) {
      this.renderer.setStyle(this.nativeElement, "-ms-flex-preferred-size", newSize);
      this.renderer.setStyle(this.nativeElement, "flex-basis", newSize);
    }
    this.setStaticPaneClass();
  }
  get size() {
    return this._size;
  }
  /**
   * Defines the HTML attributes of the splitter bar.
   * Accepts string key-value pairs.
   * You cannot change attributes that are essential for certain functionalities.
   */
  set splitterBarAttributes(attributes) {
    this._splitterBarAttributes = attributes;
    const splitterBar = this.splitterService.getPaneSplitterBar(this);
    if (splitterBar) {
      splitterBar.htmlAttributes = attributes;
    }
  }
  get splitterBarAttributes() {
    return this._splitterBarAttributes;
  }
  /**
   * Defines the CSS classes that are rendered on the splitter bar.
   * Supports the same values as [`ngClass`](link:site.data.urls.angular['ngclassapi']).
   */
  splitterBarClass;
  /**
   * Defines the minimum possible size of the pane.
   * Accepts values in pixels and percentages.
   */
  min;
  /**
   * Defines the maximum possible size of the pane.
   * Accepts values in pixels and percentages.
   */
  max;
  /**
   * Determines if you can resize the pane and provide space for other panes.
   *
   * @default true
   */
  resizable = true;
  /**
   * Determines if you can hide the pane and provide space for other panes.
   *
   * @default false
   */
  collapsible = false;
  /**
   * Determines if overflowing content is scrollable or hidden.
   *
   * @default true
   */
  scrollable = true;
  /**
   * Determines if the pane is initially collapsed.
   *
   * @default false
   */
  set collapsed(value2) {
    const hasChanged = this._collapsed !== value2;
    this._collapsed = value2;
    if (hasChanged && this.nativeElement) {
      if (this._collapsed) {
        this.renderer.setStyle(this.nativeElement, "-ms-flex-preferred-size", "0");
        this.renderer.setStyle(this.nativeElement, "flex-basis", "0");
      } else if (this._size) {
        this.renderer.setStyle(this.nativeElement, "-ms-flex-preferred-size", this._size);
        this.renderer.setStyle(this.nativeElement, "flex-basis", this._size);
      }
      if (this.splitterService?.panes) {
        const notCollapsed = this.splitterService.panes.filter((p) => !p.collapsed);
        const allHaveFixedSize = notCollapsed.every((p) => p.fixedSize);
        notCollapsed.filter((p) => p.fixedSize).forEach((pane) => {
          pane.forceExpand = allHaveFixedSize;
        });
      }
    }
  }
  get collapsed() {
    return this._collapsed;
  }
  /**
   * @hidden
   */
  orientation = "horizontal";
  /**
   * @hidden
   */
  set containsSplitter(value2) {
    if (value2) {
      this.renderer.addClass(this.nativeElement, "k-pane-flex");
    } else {
      this.renderer.removeClass(this.nativeElement, "k-pane-flex");
    }
  }
  /**
   * @hidden
   */
  overlayContent = false;
  /**
   * Fires when the Splitter pane size changes.
   * The event data contains the new pane size.
   * Enables two-way binding of the pane `size` property.
   */
  sizeChange = new EventEmitter();
  /**
   * Fires when the Splitter pane collapses or expands.
   * The event data contains the new property state.
   * Enables two-way binding of the `collapsed` pane property.
   */
  collapsedChange = new EventEmitter();
  get isHidden() {
    return this.collapsed;
  }
  ariaRole = "group";
  hostClass = true;
  get scrollablePaneClass() {
    return this.scrollable;
  }
  get fixedSize() {
    return this.size && this.size.length > 0;
  }
  /**
   * @hidden
   */
  forceExpand = false;
  /**
   * @hidden
   */
  isResized = false;
  _size;
  _order;
  _splitterBarAttributes;
  _collapsed = false;
  constructor(element, renderer, cdr, splitterService) {
    this.element = element;
    this.renderer = renderer;
    this.cdr = cdr;
    this.splitterService = splitterService;
  }
  ngAfterViewChecked() {
    if (this.isHidden) {
      this.renderer.addClass(this.nativeElement, "k-hidden");
      this.renderer.addClass(this.nativeElement, "hidden");
    } else {
      this.renderer.removeClass(this.nativeElement, "k-hidden");
      this.renderer.removeClass(this.nativeElement, "hidden");
    }
    this.setStaticPaneClass();
  }
  ngOnChanges(changes) {
    if (anyChanged(["resizable", "collapsible"], changes)) {
      this.setStaticPaneClass();
    }
  }
  /**
   * @hidden
   */
  get computedSize() {
    if (this.orientation === "vertical") {
      return this.nativeElement.offsetHeight;
    } else {
      return this.nativeElement.offsetWidth;
    }
  }
  /**
   * @hidden
   */
  get nativeElement() {
    return this.element.nativeElement;
  }
  /**
   * @hidden
   */
  toggleOverlay(show) {
    this.overlayContent = show;
    this.cdr.detectChanges();
  }
  /**
   * @hidden
   */
  detectChanges() {
    this.cdr.detectChanges();
  }
  setOrderStyles() {
    this.renderer.setStyle(this.nativeElement, "-ms-flex-order", this.order);
    this.renderer.setStyle(this.nativeElement, "order", this.order);
  }
  setStaticPaneClass() {
    if (this.forceExpand) {
      this.renderer.removeClass(this.nativeElement, "k-pane-static");
      return;
    }
    if (!this.resizable && !this.collapsible || this.fixedSize) {
      this.renderer.addClass(this.nativeElement, "k-pane-static");
    } else {
      this.renderer.removeClass(this.nativeElement, "k-pane-static");
    }
  }
  static ɵfac = function SplitterPaneComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SplitterPaneComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(SplitterService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _SplitterPaneComponent,
    selectors: [["kendo-splitter-pane"]],
    hostVars: 5,
    hostBindings: function SplitterPaneComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("role", ctx.ariaRole);
        ɵɵclassProp("k-pane", ctx.hostClass)("k-scrollable", ctx.scrollablePaneClass);
      }
    },
    inputs: {
      order: "order",
      size: "size",
      splitterBarAttributes: "splitterBarAttributes",
      splitterBarClass: "splitterBarClass",
      min: "min",
      max: "max",
      resizable: "resizable",
      collapsible: "collapsible",
      scrollable: "scrollable",
      collapsed: "collapsed",
      orientation: "orientation",
      containsSplitter: "containsSplitter",
      overlayContent: "overlayContent"
    },
    outputs: {
      sizeChange: "sizeChange",
      collapsedChange: "collapsedChange"
    },
    exportAs: ["kendoSplitterPane"],
    features: [ɵɵNgOnChangesFeature],
    ngContentSelectors: _c82,
    decls: 2,
    vars: 2,
    consts: [[1, "k-splitter-overlay", "k-overlay"]],
    template: function SplitterPaneComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵconditionalCreate(0, SplitterPaneComponent_Conditional_0_Template, 1, 0);
        ɵɵconditionalCreate(1, SplitterPaneComponent_Conditional_1_Template, 1, 0, "div", 0);
      }
      if (rf & 2) {
        ɵɵconditional(!ctx.collapsed ? 0 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.overlayContent ? 1 : -1);
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SplitterPaneComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoSplitterPane",
      selector: "kendo-splitter-pane",
      template: `
        @if (!collapsed) {
          <ng-content></ng-content>
        }
        @if (overlayContent) {
          <div class="k-splitter-overlay k-overlay"></div>
        }
        `,
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: ChangeDetectorRef
  }, {
    type: SplitterService
  }], {
    order: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    splitterBarAttributes: [{
      type: Input
    }],
    splitterBarClass: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    resizable: [{
      type: Input
    }],
    collapsible: [{
      type: Input
    }],
    scrollable: [{
      type: Input
    }],
    collapsed: [{
      type: Input
    }],
    orientation: [{
      type: Input
    }],
    containsSplitter: [{
      type: Input
    }],
    overlayContent: [{
      type: Input
    }],
    sizeChange: [{
      type: Output
    }],
    collapsedChange: [{
      type: Output
    }],
    ariaRole: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    hostClass: [{
      type: HostBinding,
      args: ["class.k-pane"]
    }],
    scrollablePaneClass: [{
      type: HostBinding,
      args: ["class.k-scrollable"]
    }]
  });
})();
var stopPropagation = ({
  originalEvent: event
}) => {
  event.stopPropagation();
  event.preventDefault();
};
var preventOnDblClick = (release) => (mouseDown) => of(mouseDown).pipe(delay(150), takeUntil(release));
var classFromObject = (classes) => Object.keys(classes).filter((c) => classes[c]).join(" ");
var createMoveStream = (draggable) => (mouseDown) => draggable.kendoDrag.pipe(takeUntil(draggable.kendoRelease), map(({
  pageX,
  pageY
}) => ({
  originalX: mouseDown.pageX,
  originalY: mouseDown.pageY,
  pageX,
  pageY
})));
var SplitterBarComponent = class _SplitterBarComponent {
  draggable;
  localization;
  splitterService;
  element;
  renderer;
  cdr;
  ariaRole = "separator";
  ariaLabel = "Splitter pane";
  focused = false;
  get hostOrientation() {
    return this.orientation === "horizontal" ? "vertical" : "horizontal";
  }
  get tabIndex() {
    return this.splitterService.isStatic(this.index) ? -1 : 0;
  }
  get hostClasses() {
    const isHorizontal = this.orientation === "horizontal";
    const isDraggable = this.splitterService.isDraggable(this.index);
    const isStatic = this.splitterService.isStatic(this.index);
    return classFromObject({
      "k-focus": this.focused,
      "k-splitbar": true,
      "k-splitbar-horizontal": isHorizontal,
      "k-splitbar-vertical": !isHorizontal,
      "k-splitbar-draggable-horizontal": isHorizontal && isDraggable,
      "k-splitbar-draggable-vertical": !isHorizontal && isDraggable,
      "k-splitbar-static-horizontal": isHorizontal && isStatic,
      "k-splitbar-static-vertical": !isHorizontal && isStatic,
      "k-touch-action-none": isDraggable
    });
  }
  get order() {
    return 2 * this.index + 1;
  }
  orientation = "horizontal";
  index = 0;
  set htmlAttributes(attributes) {
    if (isObjectPresent(this.parsedAttributes)) {
      removeHTMLAttributes(this.parsedAttributes, this.renderer, this.element.nativeElement);
    }
    this._htmlAttributes = attributes;
    this.parsedAttributes = this.htmlAttributes ? parseAttributes(this.htmlAttributes, this.defaultAttributes) : this.htmlAttributes;
    this.setHtmlAttributes();
  }
  get htmlAttributes() {
    return this._htmlAttributes;
  }
  subscriptions = new Subscription();
  _htmlAttributes;
  parsedAttributes = {};
  get defaultAttributes() {
    return {
      "aria-orientation": this.hostOrientation,
      role: this.ariaRole
    };
  }
  get mutableAttributes() {
    return {
      "tabindex": this.tabIndex
    };
  }
  constructor(draggable, localization, splitterService, element, renderer, cdr) {
    this.draggable = draggable;
    this.localization = localization;
    this.splitterService = splitterService;
    this.element = element;
    this.renderer = renderer;
    this.cdr = cdr;
  }
  ngOnInit() {
    let state2;
    const listener = this.draggable.kendoPress.pipe(tap(stopPropagation), filter(() => this.splitterService.isDraggable(this.index)), tap(() => state2 = this.splitterService.dragState(this.index)), tap(() => this.splitterService.toggleContentOverlay(this.index, true)), switchMap(preventOnDblClick(this.draggable.kendoRelease)), switchMap(createMoveStream(this.draggable))).subscribe(({
      pageX,
      pageY,
      originalX,
      originalY
    }) => {
      let delta;
      if (this.orientation === "vertical") {
        delta = pageY - originalY;
      } else if (this.direction === "rtl") {
        delta = originalX - pageX;
      } else {
        delta = pageX - originalX;
      }
      this.splitterService.setSize(state2, delta);
    });
    this.subscriptions.add(listener);
    this.subscriptions.add(this.draggable.kendoRelease.subscribe(() => this.splitterService.toggleContentOverlay(this.index, false)));
    const element = this.element.nativeElement;
    this.subscriptions.add(this.renderer.listen(element, "keydown", (event) => this.onKeyDown(event)));
    this.subscriptions.add(this.renderer.listen(element, "focusin", () => this.focused = true));
    this.subscriptions.add(this.renderer.listen(element, "focusout", () => this.focused = false));
    this.subscriptions.add(this.renderer.listen(element, "dblclick", () => this.togglePane()));
  }
  ngOnDestroy() {
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
    }
  }
  togglePrevious() {
    this.splitterService.tryToggle(this.index);
  }
  toggleNext() {
    this.splitterService.tryToggle(this.index + 1);
  }
  get direction() {
    return this.localization.rtl ? "rtl" : "ltr";
  }
  shouldShowIcon(iconName) {
    const paneIndex = iconName === "prev" ? this.index : this.index + 1;
    const relatedPaneIndex = iconName === "prev" ? this.index + 1 : this.index;
    const pane = this.splitterService.pane(paneIndex);
    const relatedPane = this.splitterService.pane(relatedPaneIndex);
    const isCollapsible = pane?.collapsible;
    return isCollapsible && !relatedPane?.isHidden;
  }
  previousArrowClass() {
    const pane = this.splitterService.pane(this.index);
    const isCollapsible = pane?.collapsible;
    const isCollapsed = pane?.collapsed;
    const isHorizontal = this.orientation === "horizontal";
    const isRTL = this.direction === "rtl";
    return classFromObject({
      "caret-alt-left": isCollapsible && isHorizontal && (!isCollapsed && !isRTL || isCollapsed && isRTL),
      "caret-alt-right": isCollapsible && isHorizontal && (isCollapsed && !isRTL || !isCollapsed && isRTL),
      "caret-alt-up": isCollapsible && !isHorizontal && !isCollapsed,
      "caret-alt-down": isCollapsible && !isHorizontal && isCollapsed
    });
  }
  previousSVGArrowClass() {
    const pane = this.splitterService.pane(this.index);
    const isCollapsible = pane?.collapsible;
    const isCollapsed = pane?.collapsed;
    const isHorizontal = this.orientation === "horizontal";
    const isRTL = this.direction === "rtl";
    if (isCollapsible && isHorizontal && (!isCollapsed && !isRTL || isCollapsed && isRTL)) {
      return caretAltLeftIcon;
    }
    if (isCollapsible && isHorizontal && (isCollapsed && !isRTL || !isCollapsed && isRTL)) {
      return caretAltRightIcon;
    }
    if (isCollapsible && !isHorizontal && !isCollapsed) {
      return caretAltUpIcon;
    }
    if (isCollapsible && !isHorizontal && isCollapsed) {
      return caretAltDownIcon;
    }
  }
  nextArrowClass() {
    const pane = this.splitterService.pane(this.index + 1);
    const isCollapsible = pane?.collapsible;
    const isCollapsed = pane?.collapsed;
    const isHorizontal = this.orientation === "horizontal";
    const isRTL = this.direction === "rtl";
    return classFromObject({
      "caret-alt-right": isCollapsible && isHorizontal && (!isCollapsed && !isRTL || isCollapsed && isRTL),
      "caret-alt-left": isCollapsible && isHorizontal && (isCollapsed && !isRTL || !isCollapsed && isRTL),
      "caret-alt-down": isCollapsible && !isHorizontal && !isCollapsed,
      "caret-alt-up": isCollapsible && !isHorizontal && isCollapsed
    });
  }
  nextSVGArrowClass() {
    const pane = this.splitterService.pane(this.index + 1);
    const isCollapsible = pane?.collapsible;
    const isCollapsed = pane?.collapsed;
    const isHorizontal = this.orientation === "horizontal";
    const isRTL = this.direction === "rtl";
    if (isCollapsible && isHorizontal && (!isCollapsed && !isRTL || isCollapsed && isRTL)) {
      return caretAltRightIcon;
    }
    if (isCollapsible && isHorizontal && (isCollapsed && !isRTL || !isCollapsed && isRTL)) {
      return caretAltLeftIcon;
    }
    if (isCollapsible && !isHorizontal && !isCollapsed) {
      return caretAltDownIcon;
    }
    if (isCollapsible && !isHorizontal && isCollapsed) {
      return caretAltUpIcon;
    }
  }
  togglePane() {
    if (this.expandLast) {
      this.toggleNext();
    } else {
      this.tryToggleNearest();
    }
    this.cdr.markForCheck();
  }
  get expandLast() {
    const panes = this.splitterService.panes;
    return panes.length === 2 && panes[1].collapsed;
  }
  onKeyDown(event) {
    const keyCode = normalizeKeys(event);
    const shouldToggle = event.ctrlKey || event.metaKey;
    if (keyCode === Keys.Enter || keyCode === Keys.NumpadEnter) {
      event.preventDefault();
      this.togglePane();
    } else if (shouldToggleOrResize(keyCode, this.orientation)) {
      event.preventDefault();
      if (shouldToggle) {
        this.splitterService.togglePane(keyCode, this.index);
      } else {
        this.splitterService.resizePane(keyCode, this.index);
      }
    }
  }
  tryToggleNearest() {
    const prev = this.index;
    const next2 = this.index + 1;
    if (!this.splitterService.tryToggle(prev)) {
      this.splitterService.tryToggle(next2);
    }
  }
  setHtmlAttributes() {
    const attributesToRender = __spreadValues(__spreadValues({}, this.mutableAttributes), this.parsedAttributes);
    setHTMLAttributes(attributesToRender, this.renderer, this.element.nativeElement);
  }
  static ɵfac = function SplitterBarComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SplitterBarComponent)(ɵɵdirectiveInject(DraggableDirective, 1), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(SplitterService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _SplitterBarComponent,
    selectors: [["kendo-splitter-bar"]],
    hostVars: 12,
    hostBindings: function SplitterBarComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("role", ctx.ariaRole)("aria-label", ctx.ariaLabel)("aria-orientation", ctx.hostOrientation)("tabindex", ctx.tabIndex);
        ɵɵclassMap(ctx.hostClasses);
        ɵɵstyleProp("-ms-flex-order", ctx.order)("order", ctx.order);
        ɵɵclassProp("k-focus", ctx.focused);
      }
    },
    inputs: {
      orientation: "orientation",
      index: "index",
      htmlAttributes: "htmlAttributes"
    },
    decls: 3,
    vars: 2,
    consts: [[1, "k-collapse-prev"], [1, "k-resize-handle"], [1, "k-collapse-next"], [1, "k-collapse-prev", 3, "click"], ["size", "xsmall", 3, "name", "svgIcon"], [1, "k-collapse-next", 3, "click"]],
    template: function SplitterBarComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵconditionalCreate(0, SplitterBarComponent_Conditional_0_Template, 2, 2, "div", 0);
        ɵɵelement(1, "div", 1);
        ɵɵconditionalCreate(2, SplitterBarComponent_Conditional_2_Template, 2, 2, "div", 2);
      }
      if (rf & 2) {
        ɵɵconditional(ctx.shouldShowIcon("prev") ? 0 : -1);
        ɵɵadvance(2);
        ɵɵconditional(ctx.shouldShowIcon("next") ? 2 : -1);
      }
    },
    dependencies: [IconWrapperComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SplitterBarComponent, [{
    type: Component,
    args: [{
      selector: "kendo-splitter-bar",
      template: `
        @if (shouldShowIcon('prev')) {
          <div class="k-collapse-prev" (click)="togglePrevious()">
            <kendo-icon-wrapper
              size="xsmall"
              [name]="previousArrowClass()"
              [svgIcon]="previousSVGArrowClass()"
            ></kendo-icon-wrapper>
          </div>
        }
        <div class="k-resize-handle"></div>
        @if (shouldShowIcon('next')) {
          <div class="k-collapse-next" (click)="toggleNext()">
            <kendo-icon-wrapper
              size="xsmall"
              [name]="nextArrowClass()"
              [svgIcon]="nextSVGArrowClass()"
            ></kendo-icon-wrapper>
          </div>
        }
        `,
      standalone: true,
      imports: [IconWrapperComponent]
    }]
  }], () => [{
    type: DraggableDirective,
    decorators: [{
      type: Host
    }]
  }, {
    type: LocalizationService
  }, {
    type: SplitterService
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: ChangeDetectorRef
  }], {
    ariaRole: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    ariaLabel: [{
      type: HostBinding,
      args: ["attr.aria-label"]
    }],
    focused: [{
      type: HostBinding,
      args: ["class.k-focus"]
    }],
    hostOrientation: [{
      type: HostBinding,
      args: ["attr.aria-orientation"]
    }],
    tabIndex: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    hostClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    order: [{
      type: HostBinding,
      args: ["style.-ms-flex-order"]
    }, {
      type: HostBinding,
      args: ["style.order"]
    }],
    orientation: [{
      type: Input
    }],
    index: [{
      type: Input
    }],
    htmlAttributes: [{
      type: Input
    }]
  });
})();
var SIZING_DOC_LINK = "https://www.telerik.com/kendo-angular-ui/components/layout/splitter/panes/#specifying-the-dimensions";
var SplitterComponent = class _SplitterComponent {
  element;
  splitterService;
  localization;
  renderer;
  ngZone;
  enclosingPane;
  /**
   * Defines the orientation of the panes within the Splitter.
   * Use `horizontal` to place panes horizontally or `vertical` to place them vertically.
   *
   * @default 'horizontal'
   */
  orientation = "horizontal";
  /**
   * Defines the width or height of the Splitter splitbars in pixels.
   * The dimension depends on the orientation of the Splitter.
   */
  splitbarWidth;
  /**
   * Defines the distance in pixels that you move the separator during keyboard navigation.
   *
   * @default 10
   */
  set resizeStep(value2) {
    this.splitterService.resizeStep = value2;
  }
  get resizeStep() {
    return this.splitterService.resizeStep;
  }
  /**
   * Defines the CSS classes that are rendered on the splitter bars.
   * Supports the same values as [`ngClass`](link:site.data.urls.angular['ngclassapi']).
   */
  splitterBarClass;
  /**
   * Fires when the layout of the Splitter changes.
   * Use this event to trigger layout calculations on components that are positioned inside the panes.
   */
  layoutChange;
  get hostClasses() {
    return true;
  }
  get horizontalHostClasses() {
    return this.orientation === "horizontal";
  }
  get verticalHostClasses() {
    return this.orientation === "vertical";
  }
  get dir() {
    return this.direction;
  }
  set splitbars(splitbars) {
    this.splitterService.splitterBars = splitbars ? splitbars.toArray() : [];
    if (!isPresent5(splitbars) || !isPresent5(this.panes)) {
      return;
    }
    if (!isDocumentAvailable()) {
      return;
    }
    const panesArray = this.panes.toArray();
    const splitBarsArray = splitbars.toArray();
    const components2 = [...panesArray, ...splitBarsArray].sort((a, b) => a.order - b.order);
    const elements = components2.map((component) => component.element.nativeElement);
    panesArray.forEach((pane, i) => {
      const splitbar = splitBarsArray[i];
      if (splitbar && pane.splitterBarAttributes) {
        splitbar.htmlAttributes = pane.splitterBarAttributes;
      }
    });
    elements.forEach((element) => this.renderer.appendChild(this.element.nativeElement, element));
  }
  /**
   * @hidden
   */
  panes;
  paneChangesSubscription;
  _styleObserver;
  constructor(element, splitterService, localization, renderer, ngZone, enclosingPane) {
    this.element = element;
    this.splitterService = splitterService;
    this.localization = localization;
    this.renderer = renderer;
    this.ngZone = ngZone;
    this.enclosingPane = enclosingPane;
    N(packageMetadata3);
    if (enclosingPane) {
      enclosingPane.containsSplitter = true;
    }
    this.layoutChange = this.splitterService.layoutChange;
    this.configure = this.configure.bind(this);
  }
  ngAfterContentInit() {
    if (!isDocumentAvailable()) {
      return;
    }
    this.reconfigure();
    this.setFixedHeight();
    const allHaveFixedSize = this.panes.length && Array.from(this.panes).every((p) => p.fixedSize);
    if (allHaveFixedSize && isDevMode()) {
      throw new Error(`
                The Splitter should have at least one pane without a set size.
                See ${SIZING_DOC_LINK} for more information.
            `);
    }
    this._styleObserver = new MutationObserver(() => {
      this.ngZone.runOutsideAngular(() => {
        this.setFixedHeight();
      });
    });
    this._styleObserver.observe(this.element.nativeElement, {
      attributeFilter: ["style"]
    });
  }
  ngOnChanges(changes) {
    if (changes.orientation && !changes.orientation.isFirstChange()) {
      this.reconfigure();
    }
  }
  ngOnDestroy() {
    if (this.enclosingPane) {
      this.enclosingPane.containsSplitter = false;
    }
    if (this._styleObserver) {
      this._styleObserver.disconnect();
      this._styleObserver = null;
    }
    this.unsubscribeChanges();
  }
  reconfigure() {
    this.unsubscribeChanges();
    this.configure();
    this.paneChangesSubscription = this.panes.changes.subscribe(this.configure);
  }
  unsubscribeChanges() {
    if (this.paneChangesSubscription) {
      this.paneChangesSubscription.unsubscribe();
      this.paneChangesSubscription = null;
    }
  }
  configure() {
    this.splitterService.configure({
      panes: this.panes.toArray(),
      orientation: this.orientation,
      containerSize: () => {
        if (this.orientation === "vertical") {
          return this.element.nativeElement.clientHeight;
        } else {
          return this.element.nativeElement.clientWidth;
        }
      },
      direction: this.direction
    });
  }
  get direction() {
    return this.localization.rtl ? "rtl" : "ltr";
  }
  setFixedHeight() {
    this.splitterService.fixedHeight = getComputedStyle(this.element.nativeElement).getPropertyValue("height") !== "auto";
  }
  static ɵfac = function SplitterComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SplitterComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(SplitterService), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(SplitterPaneComponent, 9));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _SplitterComponent,
    selectors: [["kendo-splitter"]],
    contentQueries: function SplitterComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, SplitterPaneComponent, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.panes = _t);
      }
    },
    viewQuery: function SplitterComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(SplitterBarComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.splitbars = _t);
      }
    },
    hostVars: 9,
    hostBindings: function SplitterComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.dir);
        ɵɵclassProp("k-splitter", ctx.hostClasses)("k-splitter-flex", ctx.hostClasses)("k-splitter-horizontal", ctx.horizontalHostClasses)("k-splitter-vertical", ctx.verticalHostClasses);
      }
    },
    inputs: {
      orientation: "orientation",
      splitbarWidth: "splitbarWidth",
      resizeStep: "resizeStep",
      splitterBarClass: "splitterBarClass"
    },
    outputs: {
      layoutChange: "layoutChange"
    },
    exportAs: ["kendoSplitter"],
    features: [ɵɵProvidersFeature([SplitterService, LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.spliter"
    }]), ɵɵNgOnChangesFeature],
    ngContentSelectors: _c102,
    decls: 3,
    vars: 0,
    consts: [["kendoDraggable", "", 3, "index", "orientation", "ngClass", "ngStyle"]],
    template: function SplitterComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef(_c92);
        ɵɵprojection(0);
        ɵɵrepeaterCreate(1, SplitterComponent_For_2_Template, 1, 1, null, null, ɵɵrepeaterTrackByIdentity);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵrepeater(ctx.panes);
      }
    },
    dependencies: [SplitterBarComponent, DraggableDirective, NgStyle, NgClass],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SplitterComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoSplitter",
      selector: "kendo-splitter",
      providers: [SplitterService, LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.spliter"
      }],
      template: `
      <ng-content select="kendo-splitter-pane"></ng-content>
      @for (
        pane of panes; track
        pane; let index = $index; let last = $last) {
        @if (!last) {
          <kendo-splitter-bar
            kendoDraggable
            [index]="index"
            [orientation]="orientation"
            [ngClass]="pane.splitterBarClass || splitterBarClass"
          [ngStyle]="{
            width: orientation === 'horizontal' ? splitbarWidth + 'px' : undefined,
            height: orientation === 'vertical' ? splitbarWidth + 'px' : undefined
          }">
          </kendo-splitter-bar>
        }
      }
      `,
      standalone: true,
      imports: [SplitterBarComponent, DraggableDirective, NgStyle, NgClass]
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: SplitterService
  }, {
    type: LocalizationService
  }, {
    type: Renderer2
  }, {
    type: NgZone
  }, {
    type: SplitterPaneComponent,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }, {
      type: Inject,
      args: [SplitterPaneComponent]
    }]
  }], {
    orientation: [{
      type: Input
    }],
    splitbarWidth: [{
      type: Input
    }],
    resizeStep: [{
      type: Input
    }],
    splitterBarClass: [{
      type: Input
    }],
    layoutChange: [{
      type: Output
    }],
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-splitter"]
    }, {
      type: HostBinding,
      args: ["class.k-splitter-flex"]
    }],
    horizontalHostClasses: [{
      type: HostBinding,
      args: ["class.k-splitter-horizontal"]
    }],
    verticalHostClasses: [{
      type: HostBinding,
      args: ["class.k-splitter-vertical"]
    }],
    dir: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    splitbars: [{
      type: ViewChildren,
      args: [SplitterBarComponent]
    }],
    panes: [{
      type: ContentChildren,
      args: [SplitterPaneComponent]
    }]
  });
})();
var TabContentDirective = class _TabContentDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function TabContentDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TabContentDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _TabContentDirective,
    selectors: [["", "kendoTabContent", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TabContentDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoTabContent]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var TabTitleDirective = class _TabTitleDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function TabTitleDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TabTitleDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _TabTitleDirective,
    selectors: [["", "kendoTabTitle", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TabTitleDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoTabTitle]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var TabTemplateDirective = class _TabTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function TabTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TabTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _TabTemplateDirective,
    selectors: [["", "kendoTabTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TabTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoTabTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var TabStripTabComponent = class _TabStripTabComponent {
  /**
   * Sets the title text for the tab ([see example](slug:tabs_tabstrip#toc-tab-titles)).
   */
  title;
  /**
   * Disables the tab and prevents user interaction ([see example]({% slug tabs_tabstrip %}#toc-disabled-tabs)).
   *
   * @default false
   */
  disabled = false;
  /**
   * Specifies the CSS classes to apply to the `tab` element.
   * Accepts the same values as [`ngClass`](link:site.data.urls.angular['ngclassapi']).
   */
  cssClass;
  /**
   * Specifies the CSS styles to apply to the `tab` element.
   * Accepts the same values as [`ngStyle`](link:site.data.urls.angular['ngstyleapi']).
   */
  cssStyle;
  /**
   * Selects the tab when the TabStrip loads
   * ([see example](slug:tabs_tabstrip#toc-selected-tab)).
   */
  selected;
  /**
   * Shows a close button inside the tab when set to `true`.
   * This setting overrides the TabStrip `closable` option.
   */
  closable;
  /**
   * Sets the name of an existing font icon in the Kendo UI theme for the close button.
   * This setting overrides the TabStrip `closeIcon` option.
   */
  closeIcon;
  /**
   * Sets custom CSS classes for the close button icon.
   * You can define a single class or multiple classes separated by spaces.
   * This setting overrides the TabStrip `closeIcon` option.
   */
  closeIconClass;
  /**
   * Sets an SVG icon for the close button.
   * You can use an [existing Kendo SVG icon](slug:svgicon_list) or provide a custom one.
   */
  closeSVGIcon;
  get tabContent() {
    return this._tabContent.first;
  }
  get tabTitle() {
    return this._tabTitleDirective.first;
  }
  get tabTemplate() {
    return this._tabDirective.first;
  }
  _tabDirective = new QueryList();
  _tabContent = new QueryList();
  // guards against nested tabstrip components; `descendants` is not defined by default;
  _tabTitleDirective;
  /**
   * @hidden
   *
   * Currently only disabled tabs can be focused. Otherwise they will be
   * immediately selected
   */
  focused = false;
  static ɵfac = function TabStripTabComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TabStripTabComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TabStripTabComponent,
    selectors: [["kendo-tabstrip-tab"]],
    contentQueries: function TabStripTabComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, TabTemplateDirective, 4)(dirIndex, TabContentDirective, 4)(dirIndex, TabTitleDirective, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._tabDirective = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._tabContent = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._tabTitleDirective = _t);
      }
    },
    inputs: {
      title: "title",
      disabled: "disabled",
      cssClass: "cssClass",
      cssStyle: "cssStyle",
      selected: "selected",
      closable: "closable",
      closeIcon: "closeIcon",
      closeIconClass: "closeIconClass",
      closeSVGIcon: "closeSVGIcon"
    },
    exportAs: ["kendoTabStripTab"],
    decls: 0,
    vars: 0,
    template: function TabStripTabComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TabStripTabComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoTabStripTab",
      selector: "kendo-tabstrip-tab",
      template: ``,
      standalone: true
    }]
  }], null, {
    title: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    cssClass: [{
      type: Input
    }],
    cssStyle: [{
      type: Input
    }],
    selected: [{
      type: Input
    }],
    closable: [{
      type: Input
    }],
    closeIcon: [{
      type: Input
    }],
    closeIconClass: [{
      type: Input
    }],
    closeSVGIcon: [{
      type: Input
    }],
    _tabDirective: [{
      type: ContentChildren,
      args: [TabTemplateDirective]
    }],
    _tabContent: [{
      type: ContentChildren,
      args: [TabContentDirective]
    }],
    _tabTitleDirective: [{
      type: ContentChildren,
      args: [TabTitleDirective]
    }]
  });
})();
var TabCloseEvent = class {
  index;
  tab;
  /**
   * Constructs the event arguments for the `tabClose` event.
   * @param index - The index of the closed tab.
   * @param tab - The closed tab instance
   * @hidden
   */
  constructor(index, tab) {
    this.index = index;
    this.tab = tab;
  }
};
var TabScrollEvent = class extends PreventableEvent {
  /**
   * The original DOM event that caused the tab scroll.
   */
  originalEvent;
  /**
   * @hidden
   */
  constructor(args) {
    super();
    Object.assign(this, args);
  }
};
var SelectEvent = class extends PreventableEvent {
  index;
  title;
  /**
   * Constructs the event arguments for the `select` event.
   * @param index - The index of the selected tab.
   * @param title - The title of the selected tab.
   *
   * @hidden
   */
  constructor(index, title) {
    super();
    this.index = index;
    this.title = title;
  }
};
var isTabElement = (target) => {
  const targetId = target.getAttribute("id");
  if (isPresent5(targetId) || targetId?.indexOf("k-tabstrip-tab-") >= 0) {
    return true;
  }
  return false;
};
var isTabClosable = (tab, tabStripClosable) => {
  if (tab.closable !== void 0) {
    return tab.closable;
  }
  return tabStripClosable;
};
var tabStripHasScrollButtons = (scrollableSettings) => {
  const visible = scrollableSettings.enabled && scrollableSettings.scrollButtons !== "hidden";
  const position2 = scrollableSettings.scrollButtonsPosition;
  return {
    visible,
    position: position2
  };
};
var mouseScrollEnabled = (scrollableSettings) => {
  return scrollableSettings.enabled && scrollableSettings.mouseScroll;
};
var getActiveTab = (tabs) => {
  let focusedTab;
  let selectedTab;
  let focusedIndex = -1;
  let selectedIndex = -1;
  tabs.forEach((tab, index) => {
    if (tab.selected) {
      selectedTab = tab;
      selectedIndex = index;
    } else if (tab.focused) {
      focusedTab = tab;
      focusedIndex = index;
    }
  });
  return focusedIndex >= 0 ? {
    tab: focusedTab,
    index: focusedIndex
  } : {
    tab: selectedTab,
    index: selectedIndex
  };
};
var getTabByIndex = (tabs, index) => {
  const filtered = tabs.filter((_tab, i) => i === index);
  if (filtered.length > 0) {
    return filtered[0];
  }
  return null;
};
var getTabHeaderByIndex = (tabHeaderContainers, index) => {
  const filtered = tabHeaderContainers.filter((_tabHeader, i) => i === index);
  if (filtered.length > 0) {
    return filtered[0];
  }
  return null;
};
var resetTabFocus = (tabs) => {
  tabs.forEach((tab) => {
    tab.focused = false;
  });
};
var resetTabSelection = (tabs) => {
  tabs.forEach((tab) => {
    tab.selected = false;
  });
};
var isTablistHorizontal = (tabPosition) => tabPosition === "top" || tabPosition === "bottom";
var getId$1 = (prefix2, tabStripId, tabIndex) => {
  return `${prefix2}-${tabStripId}-${tabIndex}`;
};
var TabStripService = class _TabStripService {
  localization;
  ngZone;
  owner;
  constructor(localization, ngZone) {
    this.localization = localization;
    this.ngZone = ngZone;
  }
  onKeyDown(event) {
    if (!isTabElement(event.target)) {
      return;
    }
    const code = normalizeKeys(event);
    if (this.shouldHandleKey(code)) {
      event.preventDefault();
    } else {
      return;
    }
    if (isNavigationKey(code) || isArrowKey(code)) {
      this.onNavigate(code);
    } else if (code === Keys.Delete || code === Keys.Backspace) {
      this.onDelete();
    }
  }
  onTabSelect(tab, index) {
    const selectArgs = new SelectEvent(index, tab.title);
    this.owner.tabSelect.emit(selectArgs);
    if (!selectArgs.isDefaultPrevented()) {
      if (tab.selected) {
        this.focusTabHeader(index);
        return;
      }
      this.selectTab(tab, index);
    }
  }
  selectTab(tab, index) {
    resetTabSelection(this.owner.tabs);
    this.focusTabHeader(index);
    tab.selected = true;
    if (this.owner.isScrollable) {
      this.owner.scrollToSelectedTab();
    }
  }
  onNavigate(keyCode) {
    const {
      tab: activeTab,
      index: activeIndex
    } = getActiveTab(this.owner.tabs);
    if (!NgZone.isInAngularZone()) {
      this.ngZone.run(() => {
        if (activeIndex < 0) {
          this.owner.selectTab(this.firstNavigableIndex());
          return;
        }
        activeTab.focused = false;
        const nextIndex = this.computeNextIndex(activeIndex, keyCode);
        this.activateTab(nextIndex);
      });
    }
  }
  onDelete() {
    const {
      tab: activeTab,
      index: activeTabIndex
    } = getActiveTab(this.owner.tabs);
    if (isTabClosable(activeTab, this.owner.closable) && !activeTab.disabled) {
      this.ngZone.run(() => {
        this.owner.tabClose.emit({
          tab: activeTab,
          index: activeTabIndex
        });
      });
    }
  }
  activateTab(index) {
    const tab = getTabByIndex(this.owner.tabs, index);
    if (tab.disabled) {
      this.focusTabHeader(index);
      tab.focused = true;
    } else {
      this.onTabSelect(tab, index);
    }
  }
  focusTabHeader(index) {
    const tabHeader = getTabHeaderByIndex(this.owner.tabHeaderContainers, index);
    tabHeader.nativeElement.focus();
  }
  shouldHandleKey(keyCode) {
    if (isNavigationKey(keyCode)) {
      return true;
    }
    if (isTablistHorizontal(this.owner.tabPosition) && isHorizontalArrowKey(keyCode)) {
      return true;
    }
    if (!isTablistHorizontal(this.owner.tabPosition) && isVerticalArrowKey(keyCode)) {
      return true;
    }
    if (keyCode === Keys.Delete || keyCode === Keys.Backspace) {
      return true;
    }
    return false;
  }
  computeNextIndex(activeIndex, keyCode) {
    switch (keyCode) {
      case this.invertKeys(Keys.ArrowLeft, Keys.ArrowRight):
      case this.invertKeys(Keys.ArrowUp, Keys.ArrowDown):
        return this.prevNavigableIndex(activeIndex);
      case this.invertKeys(Keys.ArrowRight, Keys.ArrowLeft):
      case this.invertKeys(Keys.ArrowDown, Keys.ArrowUp):
        return this.nextNavigableIndex(activeIndex);
      case Keys.Home:
        return this.firstNavigableIndex();
      case Keys.End:
        return this.lastNavigableIndex();
      default:
        return;
    }
  }
  invertKeys(original, inverted) {
    return this.localization.rtl ? inverted : original;
  }
  firstNavigableIndex() {
    return 0;
  }
  lastNavigableIndex() {
    return this.owner.tabs.length - 1;
  }
  prevNavigableIndex(selectedIndex) {
    if (selectedIndex - 1 < 0) {
      return this.lastNavigableIndex();
    }
    return selectedIndex - 1;
  }
  nextNavigableIndex(selectedIndex) {
    if (selectedIndex + 1 >= this.owner.tabs.length) {
      return this.firstNavigableIndex();
    }
    return selectedIndex + 1;
  }
  static ɵfac = function TabStripService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TabStripService)(ɵɵinject(LocalizationService), ɵɵinject(NgZone));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _TabStripService,
    factory: _TabStripService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TabStripService, [{
    type: Injectable
  }], () => [{
    type: LocalizationService
  }, {
    type: NgZone
  }], null);
})();
var BUTTON_SCROLL_SPEED = 100;
var HIDDEN_CLASS = "k-hidden";
var DIRECTION_CLASSES = {
  left: "caret-alt-left",
  right: "caret-alt-right",
  up: "caret-alt-up",
  down: "caret-alt-down"
};
var DEFAULT_SCROLL_BEHAVIOR = "smooth";
var ScrollService = class _ScrollService {
  ngZone;
  localization;
  owner;
  position = 0;
  scrollButtonActiveStateChange = new Subject();
  get tablistElement() {
    return this.owner.tablist.nativeElement;
  }
  get tabstripSize() {
    const hostElement = this.owner.wrapper.nativeElement;
    const wrapperWidth = parseFloat(getComputedStyle(hostElement).width);
    const wrapperHeight = parseFloat(getComputedStyle(hostElement).height);
    return isTablistHorizontal(this.owner.tabPosition) ? wrapperWidth : wrapperHeight;
  }
  get tablistOverflowSize() {
    if (!isDocumentAvailable()) {
      return 0;
    }
    const isHorizontal = isTablistHorizontal(this.owner.tabPosition);
    const overflowSize = Math.floor(this.tablistElement[isHorizontal ? "scrollWidth" : "scrollHeight"] - this.tablistElement.getBoundingClientRect()[isHorizontal ? "width" : "height"]);
    return overflowSize < 0 ? 0 : overflowSize;
  }
  get tabsOverflow() {
    return this.tablistOverflowSize > 0;
  }
  constructor(ngZone, localization) {
    this.ngZone = ngZone;
    this.localization = localization;
  }
  toggleScrollButtonsState() {
    const tabStrip = this.owner;
    if (!tabStrip.hasScrollButtons) {
      return;
    }
    const currentPrevButtonActive = !this.isDisabled("prev");
    const currentNextButtonActive = !this.isDisabled("next");
    const isHorizontal = isTablistHorizontal(this.owner.tabPosition);
    const rtlDelta = this.localization.rtl && isHorizontal ? -1 : 1;
    const calculatedPrevButtonActive = this.position * rtlDelta > 0 && this.tablistOverflowSize > 0;
    const calculatedNextButtonActive = this.position * rtlDelta < this.tablistOverflowSize && this.tablistOverflowSize > 0;
    if (calculatedPrevButtonActive !== currentPrevButtonActive) {
      this.ngZone.run(() => this.toggleButtonActiveState("prev", calculatedPrevButtonActive));
    }
    if (calculatedNextButtonActive !== currentNextButtonActive) {
      this.ngZone.run(() => this.toggleButtonActiveState("next", calculatedNextButtonActive));
    }
  }
  scrollToSelectedTab() {
    if (!this.tabsOverflow) {
      return;
    }
    const {
      index: activeIndex
    } = getActiveTab(this.owner.tabs);
    if (activeIndex === -1) {
      return;
    }
    this.position += this.getScrollOffset(activeIndex);
    if (isTablistHorizontal(this.owner.tabPosition)) {
      this.tablistElement.scrollLeft = this.position;
    } else {
      this.tablistElement.scrollTop = this.position;
    }
    this.toggleScrollButtonsState();
    const tabStrip = this.owner;
    if (!tabStrip.hasScrollButtons) {
      return;
    }
    const isFirstTabActive = activeIndex === 0;
    const isLastTabActive = activeIndex === this.owner.tabs.length - 1;
    if (isFirstTabActive && !this.isDisabled("prev")) {
      this.ngZone.run(() => this.toggleButtonActiveState("prev", false));
    }
    if (isLastTabActive && !this.isDisabled("next")) {
      this.ngZone.run(() => this.toggleButtonActiveState("next", false));
    }
  }
  getScrollOffset(activeIndex) {
    if (!isDocumentAvailable()) {
      return 0;
    }
    const isHorizontal = isTablistHorizontal(this.owner.tabPosition);
    this.tablistElement[`scroll${isHorizontal ? "Left" : "Top"}`] = this.position;
    const activeTabRect = this.tablistElement.children[activeIndex].getBoundingClientRect();
    const tablistRect = this.tablistElement.getBoundingClientRect();
    const end = isHorizontal ? "right" : "bottom";
    const start = isHorizontal ? "left" : "top";
    const activeTabStart = activeTabRect[start];
    const activeTabEnd = activeTabRect[end];
    const tablistStart = tablistRect[start];
    const tablistEnd = tablistRect[end];
    const tabEndIsInVisibleRange = activeTabEnd <= tablistEnd;
    const tabStartIsInVisibleRange = activeTabStart >= tablistStart;
    const isWholeTabVisible = tabEndIsInVisibleRange && tabStartIsInVisibleRange;
    if (isWholeTabVisible) {
      return 0;
    }
    if (!tabEndIsInVisibleRange) {
      return activeTabEnd - tablistEnd;
    }
    if (!tabStartIsInVisibleRange) {
      return activeTabStart - tablistStart;
    }
  }
  onScroll(e) {
    this.position = isTablistHorizontal(this.owner.tabPosition) ? e.target.scrollLeft : e.target.scrollTop;
    this.toggleScrollButtonsState();
  }
  scrollTabs(direction) {
    this.calculateListPosition(direction, this.owner.scrollable.buttonScrollSpeed);
    if (isTablistHorizontal(this.owner.tabPosition) && this.tablistElement) {
      this.tablistElement.scrollTo({
        left: this.position,
        behavior: DEFAULT_SCROLL_BEHAVIOR
      });
    } else {
      this.tablistElement.scrollTo({
        top: this.position,
        behavior: DEFAULT_SCROLL_BEHAVIOR
      });
    }
    this.toggleScrollButtonsState();
  }
  calculateListPosition(direction, scrollSpeed) {
    const isHorizontal = isTablistHorizontal(this.owner.tabPosition);
    if (direction === "prev") {
      if (this.localization.rtl && isHorizontal) {
        this.position = this.position + scrollSpeed >= 0 ? 0 : this.position + scrollSpeed;
      } else {
        this.position = this.position - scrollSpeed <= 0 ? 0 : this.position - scrollSpeed;
      }
    } else if (direction === "next" && this.position < this.tablistOverflowSize) {
      if (this.position + scrollSpeed > this.tablistOverflowSize) {
        this.position = this.tablistOverflowSize;
        return;
      }
      if (this.localization.rtl && isHorizontal) {
        this.position -= scrollSpeed;
      } else {
        this.position += scrollSpeed;
      }
    }
  }
  restoreScrollPosition() {
    if (isTablistHorizontal(this.owner.tabPosition)) {
      this.tablistElement.scrollLeft = this.position;
    } else {
      this.tablistElement.scrollTop = this.position;
    }
    this.toggleScrollButtonsState();
  }
  toggleButtonActiveState(buttonType, active) {
    this.scrollButtonActiveStateChange.next({
      buttonType,
      active
    });
  }
  isDisabled = (buttonType) => this.owner[`${buttonType}ScrollButton`]?.host.nativeElement.classList.contains("k-disabled");
  static ɵfac = function ScrollService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ScrollService)(ɵɵinject(NgZone), ɵɵinject(LocalizationService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ScrollService,
    factory: _ScrollService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollService, [{
    type: Injectable
  }], () => [{
    type: NgZone
  }, {
    type: LocalizationService
  }], null);
})();
var normalizeSettings = ({
  enabled = true,
  scrollButtons = "auto",
  mouseScroll = true,
  buttonScrollSpeed = BUTTON_SCROLL_SPEED,
  scrollButtonsPosition = "split",
  prevButtonIcon,
  nextButtonIcon,
  prevSVGButtonIcon,
  nextSVGButtonIcon
}) => ({
  enabled,
  scrollButtons,
  mouseScroll,
  buttonScrollSpeed,
  scrollButtonsPosition,
  prevButtonIcon,
  nextButtonIcon,
  prevSVGButtonIcon,
  nextSVGButtonIcon
});
var normalizeScrollableSettings = (settings) => normalizeSettings(settings === false ? {
  enabled: false
} : settings);
var TabStripScrollableButtonComponent = class _TabStripScrollableButtonComponent {
  host;
  renderer;
  ngZone;
  localization;
  get prevClass() {
    return this.prev;
  }
  get nextClass() {
    return !this.prev;
  }
  prev = false;
  tabPosition;
  scrollable;
  tabScroll = new EventEmitter();
  onClick = new EventEmitter();
  get hostBoundingClientRect() {
    return this.host.nativeElement.getBoundingClientRect();
  }
  get iconClass() {
    return this.scrollButtonIconClass;
  }
  get customIconClass() {
    return this.customScrollButtonIconClass;
  }
  get svgIcon() {
    return this.scrollButtonSVGIcon;
  }
  caretAltLeftIcon = caretAltLeftIcon;
  caretAltRightIcon = caretAltRightIcon;
  caretAltUpIcon = caretAltUpIcon;
  caretAltDownIcon = caretAltDownIcon;
  subs = new Subscription();
  constructor(host, renderer, ngZone, localization) {
    this.host = host;
    this.renderer = renderer;
    this.ngZone = ngZone;
    this.localization = localization;
  }
  ngAfterViewInit() {
    this.ngZone.runOutsideAngular(() => {
      this.subs.add(this.renderer.listen(this.host.nativeElement, "click", this.clickHandler));
    });
  }
  ngOnDestroy() {
    this.subs.unsubscribe();
  }
  toggle(show) {
    this.renderer[show ? "removeClass" : "addClass"](this.host.nativeElement, HIDDEN_CLASS);
  }
  clickHandler = (scrollEvent) => {
    const tabStripScrollEvent = this.emitScrollEvent(scrollEvent);
    const isTabStripScrollEventPrevented = tabStripScrollEvent.isDefaultPrevented();
    if (isTabStripScrollEventPrevented) {
      return;
    }
    const buttonType = this.prev ? "prev" : "next";
    this.onClick.emit(buttonType);
  };
  get scrollButtonIconClass() {
    const defaultPrevIcon = isTablistHorizontal(this.tabPosition) ? !this.localization.rtl ? DIRECTION_CLASSES.left : DIRECTION_CLASSES.right : DIRECTION_CLASSES.up;
    const defaultNextIcon = isTablistHorizontal(this.tabPosition) ? !this.localization.rtl ? DIRECTION_CLASSES.right : DIRECTION_CLASSES.left : DIRECTION_CLASSES.down;
    if (typeof this.scrollable === "object") {
      const prevIcon = typeof this.scrollable.prevButtonIcon === "undefined" ? defaultPrevIcon : "";
      const nextIcon = typeof this.scrollable.nextButtonIcon === "undefined" ? defaultNextIcon : "";
      if (prevIcon && this.prev) {
        return prevIcon;
      } else if (nextIcon && !this.prev) {
        return nextIcon;
      }
    }
  }
  get customScrollButtonIconClass() {
    if (typeof this.scrollable === "object") {
      const prevIcon = this.scrollable.prevButtonIcon;
      const nextIcon = this.scrollable.nextButtonIcon;
      if (prevIcon && this.prev) {
        return `k-icon ${prevIcon}`;
      }
      if (nextIcon && !this.prev) {
        return `k-icon ${nextIcon}`;
      }
    }
  }
  get scrollButtonSVGIcon() {
    const defaultPrevSVGIcon = isTablistHorizontal(this.tabPosition) ? !this.localization.rtl ? this.caretAltLeftIcon : this.caretAltRightIcon : this.caretAltUpIcon;
    const defaultNextSVGIcon = isTablistHorizontal(this.tabPosition) ? !this.localization.rtl ? this.caretAltRightIcon : this.caretAltLeftIcon : this.caretAltDownIcon;
    if (typeof this.scrollable === "object") {
      const prevIcon = this.scrollable.prevSVGButtonIcon !== void 0 ? this.scrollable.prevSVGButtonIcon : defaultPrevSVGIcon;
      const nextIcon = this.scrollable.nextSVGButtonIcon !== void 0 ? this.scrollable.nextSVGButtonIcon : defaultNextSVGIcon;
      if (prevIcon || nextIcon) {
        return this.prev ? prevIcon : nextIcon;
      }
    }
  }
  emitScrollEvent(event) {
    const scrollEvent = new TabScrollEvent({
      originalEvent: event
    });
    this.tabScroll.emit(scrollEvent);
    return scrollEvent;
  }
  static ɵfac = function TabStripScrollableButtonComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TabStripScrollableButtonComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TabStripScrollableButtonComponent,
    selectors: [["", "kendoTabStripScrollableButton", ""]],
    hostVars: 4,
    hostBindings: function TabStripScrollableButtonComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-tabstrip-prev", ctx.prevClass)("k-tabstrip-next", ctx.nextClass);
      }
    },
    inputs: {
      prev: "prev",
      tabPosition: "tabPosition",
      scrollable: "scrollable"
    },
    outputs: {
      tabScroll: "tabScroll",
      onClick: "onClick"
    },
    attrs: _c122,
    decls: 1,
    vars: 3,
    consts: [["innerCssClass", "k-button-icon", 3, "name", "customFontClass", "svgIcon"]],
    template: function TabStripScrollableButtonComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelement(0, "kendo-icon-wrapper", 0);
      }
      if (rf & 2) {
        ɵɵproperty("name", ctx.iconClass)("customFontClass", ctx.customIconClass)("svgIcon", ctx.svgIcon);
      }
    },
    dependencies: [IconWrapperComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TabStripScrollableButtonComponent, [{
    type: Component,
    args: [{
      template: `
        <kendo-icon-wrapper
            [name]="iconClass"
            [customFontClass]="customIconClass"
            [svgIcon]="svgIcon"
            innerCssClass="k-button-icon"
        >
        </kendo-icon-wrapper>
    `,
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "[kendoTabStripScrollableButton]",
      standalone: true,
      imports: [IconWrapperComponent]
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: NgZone
  }, {
    type: LocalizationService
  }], {
    prevClass: [{
      type: HostBinding,
      args: ["class.k-tabstrip-prev"]
    }],
    nextClass: [{
      type: HostBinding,
      args: ["class.k-tabstrip-next"]
    }],
    prev: [{
      type: Input
    }],
    tabPosition: [{
      type: Input
    }],
    scrollable: [{
      type: Input
    }],
    tabScroll: [{
      type: Output
    }],
    onClick: [{
      type: Output
    }]
  });
})();
var TabComponent = class _TabComponent {
  localization;
  tab;
  index;
  tabStripClosable;
  tabStripCloseIcon;
  customTabstripCloseIcon;
  closeSVGIcon;
  tabClose = new EventEmitter();
  hostClasses = true;
  get activeClass() {
    return this.tab.selected;
  }
  get disabledClass() {
    return this.tab.disabled;
  }
  get focusedClass() {
    return this.tab.focused;
  }
  get tabIndex() {
    return this.tab.selected || this.tab.focused ? 0 : -1;
  }
  constructor(localization) {
    this.localization = localization;
  }
  get tabClosable() {
    if (this.tab.closable !== void 0) {
      return this.tab.closable;
    }
    return this.tabStripClosable;
  }
  get closeSVGIconClass() {
    if (this.customCloseIconClasses) {
      return;
    }
    if (this.tab.closeSVGIcon) {
      return this.tab.closeSVGIcon;
    }
    if (this.closeSVGIcon) {
      return this.closeSVGIcon;
    }
    return xIcon;
  }
  get closeIconClasses() {
    if (!this.customTabstripCloseIcon && this.tabStripCloseIcon && !this.tab.closeIconClass) {
      if (this.tab.closeIcon) {
        return this.tab.closeIcon;
      }
      return this.tabStripCloseIcon;
    }
  }
  get customCloseIconClasses() {
    if (this.customTabstripCloseIcon || this.tab.closeIconClass) {
      if (this.tab.closeIconClass) {
        return this.tab.closeIconClass;
      }
      return this.customTabstripCloseIcon;
    }
  }
  get closeButtonTitle() {
    return this.localization.get("closeTitle");
  }
  closeTab(index) {
    const closeArgs = new TabCloseEvent(index, this.tab);
    this.tabClose.emit(closeArgs);
  }
  static ɵfac = function TabComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TabComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TabComponent,
    selectors: [["", "kendoTabStripTab", ""]],
    hostVars: 11,
    hostBindings: function TabComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("aria-selected", ctx.activeClass)("aria-disabled", ctx.disabledClass)("tabindex", ctx.tabIndex);
        ɵɵclassProp("k-tabstrip-item", ctx.hostClasses)("k-active", ctx.activeClass)("k-disabled", ctx.disabledClass)("k-focus", ctx.focusedClass);
      }
    },
    inputs: {
      tab: "tab",
      index: "index",
      tabStripClosable: "tabStripClosable",
      tabStripCloseIcon: "tabStripCloseIcon",
      customTabstripCloseIcon: "customTabstripCloseIcon",
      closeSVGIcon: "closeSVGIcon"
    },
    outputs: {
      tabClose: "tabClose"
    },
    attrs: _c132,
    decls: 3,
    vars: 2,
    consts: [["tabTemplate", ""], [3, "ngTemplateOutlet"], [1, "k-remove-tab", "k-icon-button", "k-button", "k-button-md", "k-rounded-md", "k-button-flat-base", "k-button-flat", 3, "title"], [1, "k-link"], [1, "k-link-text"], [1, "k-remove-tab", "k-icon-button", "k-button", "k-button-md", "k-rounded-md", "k-button-flat-base", "k-button-flat", 3, "click", "title"], ["innerCssClass", "k-button-icon", 3, "svgIcon", "name", "customFontClass"]],
    template: function TabComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵconditionalCreate(0, TabComponent_Conditional_0_Template, 2, 2)(1, TabComponent_Conditional_1_Template, 2, 1, null, 1);
        ɵɵconditionalCreate(2, TabComponent_Conditional_2_Template, 2, 4, "span", 2);
      }
      if (rf & 2) {
        ɵɵconditional(!ctx.tab.tabTemplate ? 0 : 1);
        ɵɵadvance(2);
        ɵɵconditional(ctx.tabClosable ? 2 : -1);
      }
    },
    dependencies: [NgTemplateOutlet, IconWrapperComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TabComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "[kendoTabStripTab]",
      template: `
        @if (!tab.tabTemplate) {
          @if (!tab.tabTitle) {
            <span class="k-link">
              <span class="k-link-text">{{ tab.title }}</span>
            </span>
          }
          @if (tab.tabTitle) {
            <span class="k-link">
              <ng-template [ngTemplateOutlet]="tab.tabTitle.templateRef">
              </ng-template>
            </span>
          }
        } @else {
          <ng-template #tabTemplate [ngTemplateOutlet]="tab.tabTemplate?.templateRef">
          </ng-template>
        }

        @if (tabClosable) {
          <span class="k-remove-tab k-icon-button k-button k-button-md k-rounded-md k-button-flat-base k-button-flat"
            (click)="closeTab(index)" [title]="closeButtonTitle">
            <kendo-icon-wrapper
              [svgIcon]="closeSVGIconClass" [name]="closeIconClasses"
            innerCssClass="k-button-icon" [customFontClass]="customCloseIconClasses"></kendo-icon-wrapper>
          </span>
        }
        `,
      standalone: true,
      imports: [NgTemplateOutlet, IconWrapperComponent]
    }]
  }], () => [{
    type: LocalizationService
  }], {
    tab: [{
      type: Input
    }],
    index: [{
      type: Input
    }],
    tabStripClosable: [{
      type: Input
    }],
    tabStripCloseIcon: [{
      type: Input
    }],
    customTabstripCloseIcon: [{
      type: Input
    }],
    closeSVGIcon: [{
      type: Input
    }],
    tabClose: [{
      type: Output
    }],
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-tabstrip-item"]
    }],
    activeClass: [{
      type: HostBinding,
      args: ["attr.aria-selected"]
    }, {
      type: HostBinding,
      args: ["class.k-active"]
    }],
    disabledClass: [{
      type: HostBinding,
      args: ["attr.aria-disabled"]
    }, {
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    focusedClass: [{
      type: HostBinding,
      args: ["class.k-focus"]
    }],
    tabIndex: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }]
  });
})();
var TabStripMessages = class _TabStripMessages extends ComponentMessages {
  /**
   * Sets the title for the **Close** button in the TabStrip tab.
   */
  closeTitle;
  /**
   * Sets the title for the **Previous Tab** button when the TabStrip is scrollable.
   */
  previousTabButton;
  /**
   * Sets the title for the **Next Tab** button when the TabStrip is scrollable.
   */
  nextTabButton;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵTabStripMessages_BaseFactory;
    return function TabStripMessages_Factory(__ngFactoryType__) {
      return (ɵTabStripMessages_BaseFactory || (ɵTabStripMessages_BaseFactory = ɵɵgetInheritedFactory(_TabStripMessages)))(__ngFactoryType__ || _TabStripMessages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _TabStripMessages,
    selectors: [["kendo-tabstrip-messages-base"]],
    inputs: {
      closeTitle: "closeTitle",
      previousTabButton: "previousTabButton",
      nextTabButton: "nextTabButton"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TabStripMessages, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line @angular-eslint/directive-selector
      selector: "kendo-tabstrip-messages-base"
    }]
  }], null, {
    closeTitle: [{
      type: Input
    }],
    previousTabButton: [{
      type: Input
    }],
    nextTabButton: [{
      type: Input
    }]
  });
})();
var LocalizedTabStripMessagesDirective = class _LocalizedTabStripMessagesDirective extends TabStripMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function LocalizedTabStripMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LocalizedTabStripMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LocalizedTabStripMessagesDirective,
    selectors: [["", "kendoTabStripLocalizedMessages", ""]],
    features: [ɵɵProvidersFeature([{
      provide: TabStripMessages,
      useExisting: forwardRef(() => _LocalizedTabStripMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalizedTabStripMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: TabStripMessages,
        useExisting: forwardRef(() => LocalizedTabStripMessagesDirective)
      }],
      selector: `[kendoTabStripLocalizedMessages]`,
      standalone: true
    }]
  }], () => [{
    type: LocalizationService
  }], null);
})();
var TabStripComponent = class _TabStripComponent {
  localization;
  renderer;
  wrapper;
  tabstripService;
  scrollService;
  ngZone;
  /**
   * Sets the height of the TabStrip.
   * Accepts a CSS size value, such as `100px`, `50%`, or `auto`.
   */
  set height(value2) {
    this._height = value2;
    this.renderer.setStyle(this.wrapper.nativeElement, "height", value2);
  }
  get height() {
    return this._height;
  }
  /**
   * Sets whether the TabStrip should animate when switching tabs.
   *
   * @default true
   */
  animate = true;
  /**
   * Sets the alignment of the tabs.
   *
   * @default 'start'
   */
  tabAlignment = "start";
  /**
   * Sets the position of the tabs.
   *
   * @default 'top'
   */
  tabPosition = "top";
  /**
  * Controls how the TabStrip renders tab content.
  *
  * The available options are:
  *
  * * `true`&mdash;Renders all tabs' content and persists them in the DOM.
  * * `false`&mdash;Removes inactive tabs' content from the DOM.
  * * `"loadOnDemand"`&mdash;Loads tabs' content only when activated for the first time. Inactive tabs' content is not rendered until the tab is activated.
  *
  * For more information, refer to the [Rendering Modes](slug:rendering_tabstrip) article.
  *
  * @default false
  */
  keepTabContent = false;
  /**
   * When set to `true`, renders a close button inside each tab.
   *
   * @default false
   */
  closable = false;
  /**
   * Enables scrolling of the tab list.
   * When set to `true` and the total size of all tabs exceeds the size of the TabStrip container, scroll buttons appear on each end of the tab list.
   *
   * @default false
   */
  set scrollable(value2) {
    this._scrollableSettings = normalizeScrollableSettings(value2);
    if (this.tablist) {
      this.toggleScrollButtons(this.scrollService.tabsOverflow);
      if (this.isScrollable && this.mouseScrollEnabled) {
        this.attachTablistScrollHandler(this.tablist.nativeElement);
      }
    }
  }
  get scrollable() {
    return this._scrollableSettings;
  }
  /**
   * Sets the size of the TabStrip.
   * [See example](slug:api_layout_tabstripcomponent#toc-size).
   * @default 'medium'
   */
  set size(value2) {
    switch (value2) {
      case "small":
        this.renderer.removeClass(this.wrapper.nativeElement, "k-tabstrip-md");
        this.renderer.removeClass(this.wrapper.nativeElement, "k-tabstrip-lg");
        this.renderer.addClass(this.wrapper.nativeElement, "k-tabstrip-sm");
        break;
      case "medium":
        this.renderer.removeClass(this.wrapper.nativeElement, "k-tabstrip-sm");
        this.renderer.removeClass(this.wrapper.nativeElement, "k-tabstrip-lg");
        this.renderer.addClass(this.wrapper.nativeElement, "k-tabstrip-md");
        break;
      case "large":
        this.renderer.removeClass(this.wrapper.nativeElement, "k-tabstrip-md");
        this.renderer.removeClass(this.wrapper.nativeElement, "k-tabstrip-sm");
        this.renderer.addClass(this.wrapper.nativeElement, "k-tabstrip-lg");
        break;
      case "none":
        this.renderer.removeClass(this.wrapper.nativeElement, "k-tabstrip-md");
        this.renderer.removeClass(this.wrapper.nativeElement, "k-tabstrip-lg");
        this.renderer.removeClass(this.wrapper.nativeElement, "k-tabstrip-sm");
    }
    this._size = value2;
    this.ngZone.onStable.pipe(take(1)).subscribe(() => this.onResize());
  }
  get size() {
    return this._size;
  }
  /**
   * Defines the name of an existing font icon in the Kendo UI theme for the close icon.
   * @default 'x'
   */
  closeIcon = "x";
  /**
   * Defines a custom CSS class, or multiple classes separated by spaces, applied to the close button.
   */
  closeIconClass;
  /**
   * Defines an SVGIcon to render for the close icon.
   * The input accepts either an [existing Kendo SVG icon](slug:svgicon_list) or a custom one.
   */
  set closeSVGIcon(icon) {
    if (isDevMode() && icon && this.closeIcon && this.closeIcon !== "x") {
      throw new Error("Setting both closeIcon and svgIcon options at the same time is not supported.");
    }
    this._closeSVGIcon = icon;
  }
  get closeSVGIcon() {
    return this._closeSVGIcon;
  }
  /**
   * If set to `false`, the content area is hidden, but the tab headers are still visible.
   *
   * @default true
   */
  showContentArea = true;
  /**
   * Fires each time a tab is selected.
   * The event data contains the index of the selected tab and its title.
   */
  tabSelect = new EventEmitter();
  /**
   * Fires each time a tab is closed.
   * The event data contains the index of the closed tab and its instance.
   */
  tabClose = new EventEmitter();
  /**
   * Fires when the tab list is scrolled.
   * The event is preventable.
   */
  tabScroll = new EventEmitter();
  hostClasses = true;
  get tabsAtTop() {
    return this.tabPosition === "top";
  }
  get tabsAtRight() {
    return this.tabPosition === "right";
  }
  get tabsAtBottom() {
    return this.tabPosition === "bottom";
  }
  get tabsAtLeft() {
    return this.tabPosition === "left";
  }
  get dir() {
    return this.localization.rtl ? "rtl" : "ltr";
  }
  get tabStripScrollable() {
    return this._scrollableSettings.enabled;
  }
  get tabStripScrollableOverlay() {
    return this._scrollableSettings.enabled && !this.hasScrollButtons.visible;
  }
  /**
   * A query list of all declared tabs.
   */
  tabs = new QueryList();
  /**
   * @hidden
   */
  tablist;
  /**
   * @hidden
   */
  tabHeaderContainers;
  /**
   * @hidden
   */
  prevScrollButton;
  /**
   * @hidden
   */
  nextScrollButton;
  /**
   * @hidden
   */
  localizationChangeSubscription;
  /**
   * @hidden
   */
  showLicenseWatermark = false;
  /**
   * @hidden
   */
  licenseMessage;
  _height;
  _scrollableSettings = normalizeScrollableSettings(false);
  subscriptions = new Subscription();
  subscriptionsArePresent = false;
  _closeSVGIcon;
  tabStripId = guid();
  tabsChangesSub;
  activeStateChangeSub;
  _size = "medium";
  constructor(localization, renderer, wrapper, tabstripService, scrollService, ngZone) {
    this.localization = localization;
    this.renderer = renderer;
    this.wrapper = wrapper;
    this.tabstripService = tabstripService;
    this.scrollService = scrollService;
    this.ngZone = ngZone;
    const isValid = N(packageMetadata3);
    this.licenseMessage = getLicenseMessage(packageMetadata3);
    this.showLicenseWatermark = shouldShowValidationUI(isValid);
    this.tabstripService.owner = this;
    this.scrollService.owner = this;
    this.subscriptions.add(this.scrollService.scrollButtonActiveStateChange.subscribe((activeButtonSettings) => {
      if (this.hasScrollButtons.visible) {
        const action = activeButtonSettings.active ? "remove" : "add";
        this.renderer[`${action}Class`](this[`${activeButtonSettings.buttonType}ScrollButton`].host.nativeElement, "k-disabled");
      }
    }));
  }
  ngAfterViewInit() {
    if (!isDocumentAvailable()) {
      return;
    }
    this.ngZone.runOutsideAngular(() => {
      if (this.scrollService.tabsOverflow) {
        this.toggleScrollButtons(true);
      } else {
        this.toggleScrollButtons(false);
      }
      setTimeout(() => {
        this.scrollToSelectedTab();
      });
    });
    this.initDomEvents();
    this.tabsChangesSub = this.tabs.changes.subscribe(() => {
      this.ngZone.onStable.pipe(take(1)).subscribe(() => {
        this.toggleScrollButtons(this.scrollService.tabsOverflow);
        this.scrollService.toggleScrollButtonsState();
      });
    });
    this.isScrollable && !this.hasScrollButtons.visible && this.setScrollableOverlayClasses();
  }
  ngOnChanges(changes) {
    if (!isDocumentAvailable()) {
      return;
    }
    const positionChange = changes["tabPosition"];
    if (positionChange) {
      const tabsAtBottomChanged = positionChange.previousValue === "bottom" || positionChange.currentValue === "bottom";
      this.ngZone.onStable.pipe(take(1)).subscribe(() => {
        if (tabsAtBottomChanged) {
          if (this.subscriptionsArePresent) {
            this.subscriptions.unsubscribe();
            this.subscriptions = new Subscription();
            this.subscriptionsArePresent = false;
            this.activeStateChangeSub = this.scrollService.scrollButtonActiveStateChange.subscribe((activeButtonSettings) => {
              if (this.hasScrollButtons.visible) {
                const action = activeButtonSettings.active ? "remove" : "add";
                this.renderer[`${action}Class`](this[`${activeButtonSettings.buttonType}ScrollButton`].host.nativeElement, "k-disabled");
              }
            });
          }
          this.initDomEvents();
        }
        this.scrollService.restoreScrollPosition();
      });
    }
  }
  ngOnDestroy() {
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
    }
    if (this.tabsChangesSub) {
      this.tabsChangesSub.unsubscribe();
    }
    if (this.activeStateChangeSub) {
      this.activeStateChangeSub.unsubscribe();
    }
  }
  /**
   * @hidden
   */
  get isScrollable() {
    return this._scrollableSettings.enabled;
  }
  /**
   * @hidden
   */
  get hasScrollButtons() {
    return tabStripHasScrollButtons(this._scrollableSettings);
  }
  /**
   * @hidden
   */
  get mouseScrollEnabled() {
    return mouseScrollEnabled(this._scrollableSettings);
  }
  /**
   * @hidden
   */
  get itemsWrapperClass() {
    return isTablistHorizontal(this.tabPosition) ? "k-hstack" : "k-vstack";
  }
  /**
   * Allows you to programmatically select a tab by its index.
   * If the tab is disabled, it will not be selected. The `tabSelect` event will not be fired.
   * @param {number} index The index of the tab that will be selected.
   */
  selectTab(index) {
    const tab = getTabByIndex(this.tabs, index);
    if (!tab || tab.disabled) {
      return;
    }
    this.tabstripService.selectTab(tab, index);
    this.scrollToSelectedTab();
  }
  /**
   * @hidden
   */
  getTabId(idx4) {
    return getId$1("k-tabstrip-tab", this.tabStripId, idx4);
  }
  /**
   * @hidden
   */
  getTabPanelId(idx4) {
    return getId$1("k-tabstrip-tabpanel", this.tabStripId, idx4);
  }
  /**
   * @hidden
   */
  onTabClick(originalEvent, tabIndex) {
    if (isFocusable2(originalEvent.target)) {
      return;
    }
    const targetElement = originalEvent.target;
    const isTargetCloseButton = hasClass(targetElement, "k-remove-tab") || hasClass(targetElement.parentElement, "k-remove-tab");
    if (isTargetCloseButton) {
      return;
    }
    const tab = getTabByIndex(this.tabs, tabIndex);
    this.tabstripService.onTabSelect(tab, tabIndex);
    this.scrollToSelectedTab();
  }
  /**
   * @hidden
   */
  onResize() {
    if (this.scrollService.tabsOverflow) {
      this.toggleScrollButtons(true);
    } else {
      this.toggleScrollButtons(false);
    }
    this.ngZone.runOutsideAngular(() => {
      this.scrollService.toggleScrollButtonsState();
    });
  }
  /**
   * @hidden
   */
  scrollToSelectedTab() {
    if (this._scrollableSettings.enabled) {
      this.scrollService.scrollToSelectedTab();
    }
  }
  /**
   * @hidden
   */
  onScrollButtonClick(buttonType) {
    this.scrollService.scrollTabs(buttonType);
  }
  initDomEvents() {
    if (!this.wrapper || this.subscriptionsArePresent) {
      return;
    }
    const tablist = this.tablist.nativeElement;
    this.ngZone.runOutsideAngular(() => {
      this.subscriptions.add(this.renderer.listen(tablist, "keydown", (ev) => {
        this.tabstripService.onKeyDown(ev);
      }));
    });
    this.subscriptions.add(this.renderer.listen(tablist, "focusout", () => {
      resetTabFocus(this.tabs);
    }));
    if (this.isScrollable && this.mouseScrollEnabled) {
      this.attachTablistScrollHandler(tablist);
    }
    this.subscriptionsArePresent = true;
  }
  toggleScrollButtons(tabsOverflow) {
    this.ngZone.onStable.pipe(take(1)).subscribe(() => {
      const scrollButtonsSetting = this._scrollableSettings.scrollButtons;
      const scrollButtonsArePresent = this.prevScrollButton && this.nextScrollButton;
      const shouldShowButtons = scrollButtonsArePresent && tabsOverflow;
      const shouldHideButtons = scrollButtonsArePresent && !tabsOverflow && scrollButtonsSetting !== "visible";
      const alwaysVisible = scrollButtonsSetting === "visible";
      if (shouldHideButtons) {
        this.prevScrollButton.toggle(false);
        this.nextScrollButton.toggle(false);
      } else if (shouldShowButtons || alwaysVisible) {
        this.prevScrollButton.toggle(true);
        this.nextScrollButton.toggle(true);
      }
      if (scrollButtonsArePresent) {
        this.ngZone.runOutsideAngular(() => {
          this.scrollService.toggleScrollButtonsState();
        });
      }
    });
  }
  attachTablistScrollHandler(tablist) {
    this.ngZone.runOutsideAngular(() => {
      this.subscriptions.add(this.renderer.listen(tablist, "scroll", (e) => {
        const scrollEvent = new TabScrollEvent({
          originalEvent: e
        });
        this.tabScroll.emit(scrollEvent);
        const isTabStripScrollEventPrevented = scrollEvent.isDefaultPrevented();
        if (isTabStripScrollEventPrevented || !this.scrollService.tabsOverflow) {
          return;
        }
        if (!this.hasScrollButtons.visible) {
          this.setScrollableOverlayClasses();
        }
        this.scrollService.onScroll(e);
      }));
    });
  }
  setScrollableOverlayClasses() {
    const wrapper = this.wrapper.nativeElement;
    const container = this.tablist?.nativeElement;
    if (!container) {
      return;
    }
    const scrollOffset = isTablistHorizontal(this.tabPosition) ? container.scrollLeft : container.scrollTop;
    if (scrollOffset === 0) {
      this.renderer.removeClass(wrapper, "k-tabstrip-scrollable-end");
      this.renderer.addClass(wrapper, "k-tabstrip-scrollable-start");
    } else if (scrollOffset > 0 && scrollOffset < this.scrollService.tablistOverflowSize) {
      this.renderer.removeClass(wrapper, "k-tabstrip-scrollable-end");
      this.renderer.removeClass(wrapper, "k-tabstrip-scrollable-start");
    } else {
      this.renderer.removeClass(wrapper, "k-tabstrip-scrollable-start");
      this.renderer.addClass(wrapper, "k-tabstrip-scrollable-end");
    }
  }
  static ɵfac = function TabStripComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TabStripComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(TabStripService), ɵɵdirectiveInject(ScrollService), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TabStripComponent,
    selectors: [["kendo-tabstrip"]],
    contentQueries: function TabStripComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, TabStripTabComponent, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tabs = _t);
      }
    },
    viewQuery: function TabStripComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c142, 5)(_c152, 5)(_c162, 5)(_c172, 5, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tablist = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.prevScrollButton = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.nextScrollButton = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tabHeaderContainers = _t);
      }
    },
    hostVars: 17,
    hostBindings: function TabStripComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.dir);
        ɵɵclassProp("k-tabstrip", ctx.hostClasses)("k-tabstrip-md", ctx.hostClasses)("k-tabstrip-top", ctx.tabsAtTop)("k-tabstrip-right", ctx.tabsAtRight)("k-tabstrip-bottom", ctx.tabsAtBottom)("k-tabstrip-left", ctx.tabsAtLeft)("k-tabstrip-scrollable", ctx.tabStripScrollable)("k-tabstrip-scrollable-overlay", ctx.tabStripScrollableOverlay);
      }
    },
    inputs: {
      height: "height",
      animate: "animate",
      tabAlignment: "tabAlignment",
      tabPosition: "tabPosition",
      keepTabContent: "keepTabContent",
      closable: "closable",
      scrollable: "scrollable",
      size: "size",
      closeIcon: "closeIcon",
      closeIconClass: "closeIconClass",
      closeSVGIcon: "closeSVGIcon",
      showContentArea: "showContentArea"
    },
    outputs: {
      tabSelect: "tabSelect",
      tabClose: "tabClose",
      tabScroll: "tabScroll"
    },
    exportAs: ["kendoTabStrip"],
    features: [ɵɵProvidersFeature([TabStripService, ScrollService, LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.tabstrip"
    }]), ɵɵNgOnChangesFeature],
    decls: 9,
    vars: 4,
    consts: () => {
      let i18n_0;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_LAYOUT_FESM2022_PROGRESS_KENDO_ANGULAR_LAYOUT_MJS_0 = goog.getMsg("Close");
        i18n_0 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_LAYOUT_FESM2022_PROGRESS_KENDO_ANGULAR_LAYOUT_MJS_0;
      } else {
        i18n_0 = $localize`:kendo.tabstrip.closeTitle|The title for the **Close** button in the TabStrip tab.:Close`;
      }
      let i18n_1;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_LAYOUT_FESM2022_PROGRESS_KENDO_ANGULAR_LAYOUT_MJS_1 = goog.getMsg("Previous Tab");
        i18n_1 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_LAYOUT_FESM2022_PROGRESS_KENDO_ANGULAR_LAYOUT_MJS_1;
      } else {
        i18n_1 = $localize`:kendo.tabstrip.previousTabButton|The title for the **Previous Tab** button when the Tabstrip is scrollable.:Previous Tab`;
      }
      let i18n_2;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_LAYOUT_FESM2022_PROGRESS_KENDO_ANGULAR_LAYOUT_MJS_2 = goog.getMsg("Next Tab");
        i18n_2 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_LAYOUT_FESM2022_PROGRESS_KENDO_ANGULAR_LAYOUT_MJS_2;
      } else {
        i18n_2 = $localize`:kendo.tabstrip.nextTabButton|The title for the **Next Tab** button when the Tabstrip is scrollable.:Next Tab`;
      }
      return [["heading", ""], ["content", ""], ["tablist", ""], ["prevScrollButton", ""], ["nextScrollButton", ""], ["tabHeaderContainer", ""], ["kendoTabStripLocalizedMessages", "", "closeTitle", i18n_0, "previousTabButton", i18n_1, "nextTabButton", i18n_2], ["kendoWatermarkOverlay", "", 3, "licenseMessage"], [4, "ngTemplateOutlet"], [1, "k-tabstrip-items-wrapper", 3, "ngClass"], ["role", "button", "kendoTabStripScrollableButton", "", 1, "k-icon-button", "k-button", "k-button-flat", "k-button-flat-base", 3, "scrollable", "tabPosition", "prev", "title", "ngClass"], ["role", "tablist", 1, "k-reset", "k-tabstrip-items", 3, "ngClass"], ["kendoTabStripTab", "", "role", "tab", 3, "k-first", "k-last", "ngClass", "ngStyle", "tab", "index", "tabStripClosable", "tabStripCloseIcon", "customTabstripCloseIcon", "closeSVGIcon", "id"], ["role", "button", "kendoTabStripScrollableButton", "", 1, "k-icon-button", "k-button", "k-button-flat", "k-button-flat-base", 3, "tabScroll", "onClick", "scrollable", "tabPosition", "prev", "title", "ngClass"], ["kendoTabStripTab", "", "role", "tab", 3, "tabClose", "click", "ngClass", "ngStyle", "tab", "index", "tabStripClosable", "tabStripCloseIcon", "customTabstripCloseIcon", "closeSVGIcon", "id"], ["role", "tabpanel", 3, "ngClass", "tabIndex", "id"], [3, "ngTemplateOutlet"], [3, "resize"]];
    },
    template: function TabStripComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainer(0, 6);
        ɵɵconditionalCreate(1, TabStripComponent_Conditional_1_Template, 2, 2);
        ɵɵconditionalCreate(2, TabStripComponent_Conditional_2_Template, 2, 2);
        ɵɵtemplate(3, TabStripComponent_ng_template_3_Template, 9, 16, "ng-template", null, 0, ɵɵtemplateRefExtractor)(5, TabStripComponent_ng_template_5_Template, 2, 0, "ng-template", null, 1, ɵɵtemplateRefExtractor);
        ɵɵconditionalCreate(7, TabStripComponent_Conditional_7_Template, 1, 0, "kendo-resize-sensor");
        ɵɵconditionalCreate(8, TabStripComponent_Conditional_8_Template, 1, 1, "div", 7);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵconditional(!ctx.tabsAtBottom ? 1 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.tabsAtBottom ? 2 : -1);
        ɵɵadvance(5);
        ɵɵconditional(ctx.isScrollable ? 7 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.showLicenseWatermark ? 8 : -1);
      }
    },
    dependencies: [LocalizedTabStripMessagesDirective, NgTemplateOutlet, NgClass, TabStripScrollableButtonComponent, TabComponent, NgStyle, ResizeSensorComponent, WatermarkOverlayComponent],
    encapsulation: 2,
    data: {
      animation: [trigger("state", [state("active", style({
        opacity: 1
      })), transition("* => active", [style({
        opacity: 0
      }), animate("400ms ease-in")])])]
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TabStripComponent, [{
    type: Component,
    args: [{
      animations: [trigger("state", [state("active", style({
        opacity: 1
      })), transition("* => active", [style({
        opacity: 0
      }), animate("400ms ease-in")])])],
      providers: [TabStripService, ScrollService, LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.tabstrip"
      }],
      exportAs: "kendoTabStrip",
      selector: "kendo-tabstrip",
      template: `
        <ng-container kendoTabStripLocalizedMessages
          i18n-closeTitle="kendo.tabstrip.closeTitle|The title for the **Close** button in the TabStrip tab."
          closeTitle="Close"

          i18n-previousTabButton="kendo.tabstrip.previousTabButton|The title for the **Previous Tab** button when the Tabstrip is scrollable."
          previousTabButton="Previous Tab"

          i18n-nextTabButton="kendo.tabstrip.nextTabButton|The title for the **Next Tab** button when the Tabstrip is scrollable."
          nextTabButton="Next Tab"
          >
        </ng-container>
        @if (!tabsAtBottom) {
          <ng-container *ngTemplateOutlet="heading"></ng-container>
          @if (showContentArea) {
            <ng-container *ngTemplateOutlet="content"></ng-container>
          }
        }

        @if (tabsAtBottom) {
          @if (showContentArea) {
            <ng-container *ngTemplateOutlet="content"></ng-container>
          }
          <ng-container *ngTemplateOutlet="heading"></ng-container>
        }
        <ng-template #heading>
          <div class="k-tabstrip-items-wrapper" [class.k-tabstrip-items-wrapper-scroll]="mouseScrollEnabled" [ngClass]="itemsWrapperClass">
            @if (hasScrollButtons.visible && hasScrollButtons.position !== 'end') {
              <span
                role="button"
                #prevScrollButton
                kendoTabStripScrollableButton
                [scrollable]="scrollable"
                [tabPosition]="tabPosition"
                [prev]="true"
                [title]="localization.get('previousTabButton')"
                (tabScroll)="tabScroll.emit($event)"
                class="k-icon-button k-button k-button-flat k-button-flat-base"
                    [ngClass]="{
                        'k-button-sm': size === 'small',
                        'k-button-md': size === 'medium' || !size,
                        'k-button-lg': size === 'large'
                    }"
              (onClick)="onScrollButtonClick($event)"></span>
            }
            @if (hasScrollButtons.visible && hasScrollButtons.position === 'start') {
              <span
                role="button"
                #nextScrollButton
                kendoTabStripScrollableButton
                [scrollable]="scrollable"
                [tabPosition]="tabPosition"
                [prev]="false"
                [title]="localization.get('nextTabButton')"
                (tabScroll)="tabScroll.emit($event)"
                class="k-icon-button k-button k-button-flat k-button-flat-base"
                    [ngClass]="{
                        'k-button-sm': size === 'small',
                        'k-button-md': size === 'medium' || !size,
                        'k-button-lg': size === 'large'
                    }"
              (onClick)="onScrollButtonClick($event)"></span>
            }
            <ul role="tablist" #tablist
              class="k-reset k-tabstrip-items"
                    [ngClass]="{
                        'k-tabstrip-items-start': tabAlignment === 'start',
                        'k-tabstrip-items-center': tabAlignment === 'center',
                        'k-tabstrip-items-end': tabAlignment === 'end',
                        'k-tabstrip-items-stretched': tabAlignment === 'stretched',
                        'k-tabstrip-items-justify': tabAlignment === 'justify',
                        'k-tabstrip-items-scroll': mouseScrollEnabled
                    }"
              [attr.aria-orientation]="tabPosition === 'left' || tabPosition === 'right' ? 'vertical' : 'horizontal'"
              >
              @for (tab of tabs; track tab; let i = $index) {
                <li
                    #tabHeaderContainer
                    kendoTabStripTab
                    [class.k-first]="i === 0"
                    [class.k-last]="i === tabs.length - 1"
                    [ngClass]="tab.cssClass"
                    [ngStyle]="tab.cssStyle"
                    [tab]="tab"
                    [index]="i"
                    role="tab"
                    [tabStripClosable]="closable"
                    [tabStripCloseIcon]="closeIcon"
                    [customTabstripCloseIcon]="closeIconClass"
                    [closeSVGIcon]="closeSVGIcon"
                    (tabClose)="tabClose.emit($event)"
                    (click)="onTabClick($event, i)"
                    [id]="getTabId(i)"
                    [attr.aria-controls]="(showContentArea && tab.selected) ? getTabPanelId(i) : undefined"></li>
              }
            </ul>
            @if (hasScrollButtons.visible && hasScrollButtons.position === 'end') {
              <span
                role="button"
                #prevScrollButton
                kendoTabStripScrollableButton
                [scrollable]="scrollable"
                [tabPosition]="tabPosition"
                [prev]="true"
                [title]="localization.get('previousTabButton')"
                (tabScroll)="tabScroll.emit($event)"
                class="k-icon-button k-button k-button-flat k-button-flat-base"
                    [ngClass]="{
                        'k-button-sm': size === 'small',
                        'k-button-md': size === 'medium' || !size,
                        'k-button-lg': size === 'large'
                    }"
              (onClick)="onScrollButtonClick($event)"></span>
            }
            @if (hasScrollButtons.visible && hasScrollButtons.position !== 'start') {
              <span
                role="button"
                #nextScrollButton
                kendoTabStripScrollableButton
                [scrollable]="scrollable"
                [tabPosition]="tabPosition"
                [prev]="false"
                [title]="localization.get('nextTabButton')"
                (tabScroll)="tabScroll.emit($event)"
                class="k-icon-button k-button k-button-flat k-button-flat-base"
                    [ngClass]="{
                        'k-button-sm': size === 'small',
                        'k-button-md': size === 'medium' || !size,
                        'k-button-lg': size === 'large'
                    }"
              (onClick)="onScrollButtonClick($event)"></span>
            }
          </div>
        </ng-template>
        <ng-template #content>
            @for (tab of tabs; track tab; let i = $index) {
                @if (tab.selected || keepTabContent !== false) {
                    @defer (when tab.selected || keepTabContent === true; prefetch on idle) {
                        <div
                            [@state]="tab.selected && animate ? 'active' : 'inactive'"
                            [ngClass]="!this.keepTabContent || tab.selected ? 'k-tabstrip-content k-active' : 'k-tabstrip-content'"
                            [tabIndex]="0"
                            role="tabpanel"
                            [id]="getTabPanelId(i)"
                            [attr.aria-hidden]="!tab.selected"
                            [attr.aria-labelledby]="getTabId(i)"
                            [attr.aria-disabled]="tab.disabled"
                        >
                            <ng-template [ngTemplateOutlet]="tab.tabContent?.templateRef"></ng-template>
                        </div>
                    }
                }
            }
        </ng-template>
        @if (isScrollable) {
          <kendo-resize-sensor (resize)="onResize()"></kendo-resize-sensor>
        }
        @if (showLicenseWatermark) {
          <div kendoWatermarkOverlay [licenseMessage]="licenseMessage"></div>
        }
        `,
      standalone: true,
      imports: [LocalizedTabStripMessagesDirective, NgTemplateOutlet, NgClass, TabStripScrollableButtonComponent, TabComponent, NgStyle, ResizeSensorComponent, WatermarkOverlayComponent]
    }]
  }], () => [{
    type: LocalizationService
  }, {
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: TabStripService
  }, {
    type: ScrollService
  }, {
    type: NgZone
  }], {
    height: [{
      type: Input
    }],
    animate: [{
      type: Input
    }],
    tabAlignment: [{
      type: Input
    }],
    tabPosition: [{
      type: Input
    }],
    keepTabContent: [{
      type: Input
    }],
    closable: [{
      type: Input
    }],
    scrollable: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    closeIcon: [{
      type: Input
    }],
    closeIconClass: [{
      type: Input
    }],
    closeSVGIcon: [{
      type: Input
    }],
    showContentArea: [{
      type: Input
    }],
    tabSelect: [{
      type: Output
    }],
    tabClose: [{
      type: Output
    }],
    tabScroll: [{
      type: Output
    }],
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-tabstrip"]
    }, {
      type: HostBinding,
      args: ["class.k-tabstrip-md"]
    }],
    tabsAtTop: [{
      type: HostBinding,
      args: ["class.k-tabstrip-top"]
    }],
    tabsAtRight: [{
      type: HostBinding,
      args: ["class.k-tabstrip-right"]
    }],
    tabsAtBottom: [{
      type: HostBinding,
      args: ["class.k-tabstrip-bottom"]
    }],
    tabsAtLeft: [{
      type: HostBinding,
      args: ["class.k-tabstrip-left"]
    }],
    dir: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    tabStripScrollable: [{
      type: HostBinding,
      args: ["class.k-tabstrip-scrollable"]
    }],
    tabStripScrollableOverlay: [{
      type: HostBinding,
      args: ["class.k-tabstrip-scrollable-overlay"]
    }],
    tabs: [{
      type: ContentChildren,
      args: [TabStripTabComponent]
    }],
    tablist: [{
      type: ViewChild,
      args: ["tablist"]
    }],
    tabHeaderContainers: [{
      type: ViewChildren,
      args: ["tabHeaderContainer", {
        read: ElementRef
      }]
    }],
    prevScrollButton: [{
      type: ViewChild,
      args: ["prevScrollButton"]
    }],
    nextScrollButton: [{
      type: ViewChild,
      args: ["nextScrollButton"]
    }]
  });
})();
var TabStripCustomMessagesComponent = class _TabStripCustomMessagesComponent extends TabStripMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function TabStripCustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TabStripCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TabStripCustomMessagesComponent,
    selectors: [["kendo-tabstrip-messages"]],
    features: [ɵɵProvidersFeature([{
      provide: TabStripMessages,
      useExisting: forwardRef(() => _TabStripCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function TabStripCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TabStripCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: TabStripMessages,
        useExisting: forwardRef(() => TabStripCustomMessagesComponent)
      }],
      selector: "kendo-tabstrip-messages",
      template: ``,
      standalone: true
    }]
  }], () => [{
    type: LocalizationService
  }], null);
})();
var DrawerTemplateDirective = class _DrawerTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function DrawerTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DrawerTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DrawerTemplateDirective,
    selectors: [["", "kendoDrawerTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DrawerTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDrawerTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var DrawerItemTemplateDirective = class _DrawerItemTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function DrawerItemTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DrawerItemTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DrawerItemTemplateDirective,
    selectors: [["", "kendoDrawerItemTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DrawerItemTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDrawerItemTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var DrawerHeaderTemplateDirective = class _DrawerHeaderTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function DrawerHeaderTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DrawerHeaderTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DrawerHeaderTemplateDirective,
    selectors: [["", "kendoDrawerHeaderTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DrawerHeaderTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDrawerHeaderTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var DrawerFooterTemplateDirective = class _DrawerFooterTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function DrawerFooterTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DrawerFooterTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DrawerFooterTemplateDirective,
    selectors: [["", "kendoDrawerFooterTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DrawerFooterTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDrawerFooterTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var defaultIsItemExpanded = (_item) => false;
var DrawerService = class _DrawerService {
  owner;
  selectedIndices = [];
  viewData;
  focusIndex = 0;
  originalItems = [];
  idxCounter = 0;
  init() {
    this.resetViewData();
    this.originalItems = this.owner.items || [];
    const rootItems = this.originalItems.filter((item) => !isPresent5(item.parentId));
    this.populateViewData(rootItems);
  }
  get view() {
    return Array.from(this.viewData);
  }
  changeFocusedItem(items, keyName, renderer) {
    const currentItem = items.get(this.focusIndex);
    let nextItem;
    if (keyName === "arrowUp") {
      if (this.focusIndex === 0) {
        nextItem = items.get(items.length - 1);
        this.focusIndex = items.length - 1;
      } else {
        nextItem = items.get(this.focusIndex - 1);
        this.focusIndex = this.focusIndex - 1;
      }
    } else if (keyName === "arrowDown") {
      if (this.focusIndex === items.length - 1) {
        nextItem = items.get(0);
        this.focusIndex = 0;
      } else {
        nextItem = items.get(this.focusIndex + 1);
        this.focusIndex = this.focusIndex + 1;
      }
    }
    renderer.setAttribute(currentItem.nativeElement, "tabindex", "-1");
    renderer.setAttribute(nextItem.nativeElement, "tabindex", "0");
    nextItem.nativeElement.focus();
  }
  populateViewData(items, level = 0) {
    items.forEach((item) => {
      this.setSelection(item);
      const children2 = this.loadChildren(item);
      const isExpanded = this.isItemExpanded(item);
      this.viewData.add({
        item,
        index: this.idxCounter++,
        level,
        hasChildren: children2.length > 0,
        isExpanded
      });
      if (children2.length > 0 && isExpanded) {
        this.populateViewData(children2, level + 1);
      }
    });
  }
  resetViewData() {
    this.idxCounter = 0;
    this.viewData = /* @__PURE__ */ new Set();
  }
  loadChildren(item) {
    return this.originalItems.filter((i) => {
      return isPresent5(i.parentId) && i.parentId === item.id;
    });
  }
  isItemExpanded = defaultIsItemExpanded;
  onSelect(selectedIdx) {
    this.selectedIndices = [selectedIdx];
    const drawer = this.owner;
    if (drawer.autoCollapse && !drawer.minimized) {
      drawer.toggle(false);
    }
  }
  setSelection(item) {
    if (this.selectedIndices.length === 0 && item.selected) {
      this.selectedIndices.push(this.idxCounter);
    }
  }
  resetSelection() {
    this.selectedIndices = [];
  }
  static ɵfac = function DrawerService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DrawerService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DrawerService,
    factory: _DrawerService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DrawerService, [{
    type: Injectable
  }], null, null);
})();
function miniExpandPush(duration, width2, miniWidth) {
  return [style({
    overflow: "hidden",
    flexBasis: `${miniWidth}px`
  }), animate(`${duration}ms ease-in`, style({
    flexBasis: `${width2}px`
  }))];
}
function miniCollapsePush(duration, width2, miniWidth) {
  return [style({
    overflow: "hidden",
    flexBasis: `${width2}px`
  }), animate(`${duration}ms ease-in`, style({
    flexBasis: `${miniWidth}px`
  }))];
}
function miniExpandOverlay(duration, width2, miniWidth) {
  return [style({
    width: `${miniWidth}px`
  }), animate(`${duration}ms ease-in`, style({
    overflow: "hidden",
    width: `${width2}px`
  }))];
}
function expandPush(duration, width2) {
  return [style({
    overflow: "hidden",
    flexBasis: "0px"
  }), animate(`${duration}ms ease-in`, style({
    flexBasis: `${width2}px`
  }))];
}
function collapsePush(duration, width2) {
  return [style({
    flexBasis: `${width2}px`
  }), animate(`${duration}ms ease-in`, style({
    overflow: "hidden",
    flexBasis: `0px`
  }))];
}
function expandRTLOverlay(duration) {
  return [style({
    transform: `translateX(100%)`
  }), animate(`${duration}ms ease-in`, style({
    overflow: "hidden",
    transform: `translateX(0)`
  }))];
}
function expandOverlay(duration, position2) {
  const translateDir = position2 !== "end" ? `-100%` : `100%`;
  return [style({
    transform: `translateX(${translateDir})`
  }), animate(`${duration}ms ease-in`, style({
    overflow: "hidden",
    transform: `translateX(0)`
  }))];
}
function miniCollapseOverlay(duration, width2, miniWidth) {
  return [style({
    width: `${width2}px`
  }), animate(`${duration}ms ease-in`, style({
    overflow: "hidden",
    width: `${miniWidth}px`
  }))];
}
function collapseOverlay(duration, position2) {
  const translateDir = position2 !== "end" ? "-100%" : "100%";
  return [style({
    transform: `translateX(0)`
  }), animate(`${duration}ms ease-in`, style({
    overflow: "hidden",
    transform: `translateX(${translateDir})`
  }))];
}
function collapseRTLOverlay(duration) {
  return [style({
    transform: `translateX(0)`
  }), animate(`${duration}ms ease-in`, style({
    overflow: "hidden",
    transform: `translateX(100%)`
  }))];
}
function expandAnimation(settings) {
  const duration = settings.animation.duration;
  const width2 = settings.width;
  const miniWidth = settings.miniWidth;
  const mode = settings.mode;
  const mini = settings.mini;
  const rtl = settings.rtl;
  const position2 = settings.position;
  if (mini && mode === "push") {
    return miniExpandPush(duration, width2, miniWidth);
  }
  if (!mini && mode === "push") {
    return expandPush(duration, width2);
  }
  if (!mini && mode === "overlay") {
    return rtl ? expandRTLOverlay(duration) : expandOverlay(duration, position2);
  }
  if (mini && mode === "overlay") {
    return miniExpandOverlay(duration, width2, miniWidth);
  }
}
function collapseAnimation(settings) {
  const duration = settings.animation.duration;
  const width2 = settings.width;
  const miniWidth = settings.miniWidth;
  const mode = settings.mode;
  const mini = settings.mini;
  const rtl = settings.rtl;
  const position2 = settings.position;
  if (mini && mode === "push") {
    return miniCollapsePush(duration, width2, miniWidth);
  }
  if (!mini && mode === "push") {
    return collapsePush(duration, width2);
  }
  if (!mini && mode === "overlay") {
    return rtl ? collapseRTLOverlay(duration) : collapseOverlay(duration, position2);
  }
  if (mini && mode === "overlay") {
    return miniCollapseOverlay(duration, width2, miniWidth);
  }
}
var DRAWER_ITEM_INDEX = "data-kendo-drawer-index";
var DRAWER_LINK_SELECTOR = ".k-drawer-link";
var ACTIVE_NESTED_LINK_SELECTOR = ":focus:not(.k-disabled) .k-drawer-link";
var nestedLink = (element, selector) => element.querySelector(selector);
var DrawerListSelectEvent = class extends PreventableEvent {
  /**
   * The index of the selected item in the `items` collection.
   */
  index;
  /**
   * The selected Drawer item.
   */
  item;
  /**
   * The DOM event that triggered the selection.
   */
  originalEvent;
  /**
   * @hidden
   */
  constructor(args) {
    super();
    Object.assign(this, args);
  }
};
var DrawerItemComponent = class _DrawerItemComponent {
  drawerService;
  element;
  renderer;
  viewItem;
  index;
  itemTemplate;
  mini;
  expanded;
  disabled;
  cssClass;
  cssStyle;
  get disabledClass() {
    return this.item.disabled;
  }
  get selectedClass() {
    return this.drawerService.selectedIndices.indexOf(this.index) >= 0;
  }
  get label() {
    return this.item.text ? this.item.text : null;
  }
  arrowUpIcon = chevronUpIcon;
  arrowDownIcon = chevronDownIcon;
  constructor(drawerService, element, renderer) {
    this.drawerService = drawerService;
    this.element = element;
    this.renderer = renderer;
  }
  ngAfterViewInit() {
    const elem = this.element.nativeElement;
    const link = nestedLink(elem, DRAWER_LINK_SELECTOR);
    if (link) {
      this.renderer.removeAttribute(link, "tabindex");
    }
  }
  get iconClasses() {
    if (this.item.icon) {
      const stripIcon = this.item.icon.replace("k-i-", "");
      return `${stripIcon}`;
    }
  }
  get innerCssClasses() {
    if (this.item.iconClass && this.item.icon) {
      return `${this.item.iconClass}`;
    }
  }
  get customIconClasses() {
    if (!this.item.icon && this.item.iconClass) {
      return this.item.iconClass;
    }
  }
  get item() {
    return this.viewItem.item;
  }
  static ɵfac = function DrawerItemComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DrawerItemComponent)(ɵɵdirectiveInject(DrawerService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DrawerItemComponent,
    selectors: [["", "kendoDrawerItem", ""]],
    hostVars: 7,
    hostBindings: function DrawerItemComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("aria-disabled", ctx.disabledClass)("aria-current", ctx.selectedClass)("aria-label", ctx.label);
        ɵɵclassProp("k-disabled", ctx.disabledClass)("k-selected", ctx.selectedClass);
      }
    },
    inputs: {
      viewItem: "viewItem",
      index: "index",
      itemTemplate: "itemTemplate",
      mini: "mini",
      expanded: "expanded",
      disabled: "disabled",
      cssClass: "cssClass",
      cssStyle: "cssStyle"
    },
    attrs: _c202,
    decls: 2,
    vars: 1,
    consts: [[3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "name", "customFontClass", "svgIcon", "innerCssClass"], [1, "k-item-text"], [1, "k-spacer"], ["innerCssClass", "k-drawer-toggle", 3, "name", "svgIcon"]],
    template: function DrawerItemComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵconditionalCreate(0, DrawerItemComponent_Conditional_0_Template, 1, 7, null, 0)(1, DrawerItemComponent_Conditional_1_Template, 2, 2);
      }
      if (rf & 2) {
        ɵɵconditional(ctx.itemTemplate ? 0 : 1);
      }
    },
    dependencies: [NgTemplateOutlet, IconWrapperComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DrawerItemComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "[kendoDrawerItem]",
      template: `
        @if (itemTemplate) {
          <ng-template
            [ngTemplateOutlet]="itemTemplate"
            [ngTemplateOutletContext]="{
                $implicit: item,
                isItemExpanded: viewItem.isExpanded,
                hasChildren: viewItem.hasChildren,
                level: viewItem.level
            }">
          </ng-template>
        } @else {
          @if (expanded) {
            @if (item.icon || item.iconClass || item.svgIcon) {
              <kendo-icon-wrapper
                [name]="iconClasses"
                [customFontClass]="customIconClasses"
                [svgIcon]="item.svgIcon"
                [innerCssClass]="innerCssClasses"
                >
              </kendo-icon-wrapper>
            }
            <span class="k-item-text">{{ item.text }}</span>
            @if (viewItem.hasChildren) {
              <span class="k-spacer"></span>
            }
            @if (viewItem.hasChildren) {
              <kendo-icon-wrapper
                [name]="viewItem.isExpanded ? 'arrow-chevron-up' : 'arrow-chevron-down'"
                innerCssClass="k-drawer-toggle"
                [svgIcon]="viewItem.isExpanded ? arrowUpIcon : arrowDownIcon"
                >
              </kendo-icon-wrapper>
            }
          }
          @if (mini && !expanded) {
            @if (item.icon || item.iconClass || item.svgIcon) {
              <kendo-icon-wrapper
                [name]="iconClasses"
                [customFontClass]="customIconClasses"
                [svgIcon]="item.svgIcon"
                [innerCssClass]="innerCssClasses"
                >
              </kendo-icon-wrapper>
            }
          }
        }
        
        `,
      standalone: true,
      imports: [NgTemplateOutlet, IconWrapperComponent]
    }]
  }], () => [{
    type: DrawerService
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }], {
    viewItem: [{
      type: Input
    }],
    index: [{
      type: Input
    }],
    itemTemplate: [{
      type: Input
    }],
    mini: [{
      type: Input
    }],
    expanded: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    cssClass: [{
      type: Input
    }],
    cssStyle: [{
      type: Input
    }],
    disabledClass: [{
      type: HostBinding,
      args: ["attr.aria-disabled"]
    }, {
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    selectedClass: [{
      type: HostBinding,
      args: ["attr.aria-current"]
    }, {
      type: HostBinding,
      args: ["class.k-selected"]
    }],
    label: [{
      type: HostBinding,
      args: ["attr.aria-label"]
    }]
  });
})();
var DrawerListComponent = class _DrawerListComponent {
  drawerService;
  renderer;
  ngZone;
  element;
  itemTemplate;
  mini;
  expanded;
  view = [];
  select = new EventEmitter();
  items;
  subscriptions = new Subscription();
  constructor(drawerService, renderer, ngZone, element) {
    this.drawerService = drawerService;
    this.renderer = renderer;
    this.ngZone = ngZone;
    this.element = element;
  }
  ngOnInit() {
    this.initDomEvents();
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  identifyItem(_index, viewItem) {
    return viewItem.item.id ?? viewItem.index;
  }
  initDomEvents() {
    if (!this.element) {
      return;
    }
    this.ngZone.runOutsideAngular(() => {
      const nativeElement = this.element.nativeElement;
      this.subscriptions.add(this.renderer.listen(nativeElement, "click", this.clickHandler.bind(this)));
      this.subscriptions.add(this.renderer.listen(nativeElement, "keydown", (e) => {
        const code = normalizeKeys(e);
        const isEnterOrSpace = code === Keys.Enter || code === Keys.Space;
        const isArrowUpOrDown = code === Keys.ArrowUp || code === Keys.ArrowDown;
        if (isEnterOrSpace) {
          this.onEnterOrSpaceKeyDown(e);
        } else if (isArrowUpOrDown) {
          if (e.target.classList.contains("k-drawer-item")) {
            e.preventDefault();
            const keyName = code === Keys.ArrowUp ? "arrowUp" : "arrowDown";
            this.drawerService.changeFocusedItem(this.items, keyName, this.renderer);
          }
        }
      }));
    });
  }
  clickHandler(e) {
    const viewItemIdx = this.getDrawerItemIndex(e.target);
    const viewItem = this.view[viewItemIdx];
    const filterItems = this.view.filter((items) => !items.item.separator);
    const selectedItemIndex = filterItems.findIndex((item) => item.index === viewItemIdx);
    if (!viewItem) {
      return;
    }
    if (viewItem.item.disabled) {
      e.preventDefault();
      return;
    }
    const args = {
      index: viewItem.index,
      item: viewItem.item,
      originalEvent: e
    };
    this.ngZone.run(() => {
      const event = new DrawerListSelectEvent(args);
      this.select.emit(event);
      if (!event.isDefaultPrevented()) {
        this.drawerService.focusIndex = selectedItemIndex;
        this.drawerService.onSelect(viewItemIdx);
        this.drawerService.init();
        this.view = this.drawerService.view;
      }
    });
  }
  onEnterOrSpaceKeyDown(e) {
    this.clickHandler(e);
    const link = nestedLink(this.element.nativeElement, ACTIVE_NESTED_LINK_SELECTOR);
    if (link) {
      link.click();
    }
    return false;
  }
  getDrawerItemIndex(target) {
    const item = closestItem(target, DRAWER_ITEM_INDEX, this.element.nativeElement);
    if (item) {
      return itemIndex(item, DRAWER_ITEM_INDEX);
    }
  }
  static ɵfac = function DrawerListComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DrawerListComponent)(ɵɵdirectiveInject(DrawerService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DrawerListComponent,
    selectors: [["", "kendoDrawerList", ""]],
    viewQuery: function DrawerListComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(DrawerItemComponent, 5, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.items = _t);
      }
    },
    inputs: {
      itemTemplate: "itemTemplate",
      mini: "mini",
      expanded: "expanded",
      view: "view"
    },
    outputs: {
      select: "select"
    },
    attrs: _c222,
    decls: 2,
    vars: 0,
    consts: [["kendoDrawerItem", "", "role", "menuitem", 3, "class", "viewItem", "index", "mini", "expanded", "itemTemplate", "ngClass", "ngStyle", "tabindex"], ["role", "separator", 1, "k-drawer-item", "k-drawer-separator", 3, "ngClass", "ngStyle"], ["kendoDrawerItem", "", "role", "menuitem", 3, "viewItem", "index", "mini", "expanded", "itemTemplate", "ngClass", "ngStyle", "tabindex"]],
    template: function DrawerListComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵrepeaterCreate(0, DrawerListComponent_For_1_Template, 2, 2, null, null, ctx.identifyItem, true);
      }
      if (rf & 2) {
        ɵɵrepeater(ctx.view);
      }
    },
    dependencies: [DrawerItemComponent, NgClass, NgStyle],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DrawerListComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "[kendoDrawerList]",
      template: `
        @for (v of view; track identifyItem(idx, v); let idx = $index) {
          @if (!v.item.separator) {
            <li kendoDrawerItem
              class="k-drawer-item {{expanded ? ' k-level-' + v.level : ''}}"
              role="menuitem"
              [viewItem]="v"
              [index]="idx"
              [mini]="mini"
              [expanded]="expanded"
              [itemTemplate]="itemTemplate"
              [attr.${DRAWER_ITEM_INDEX}]="v.index"
              [ngClass]="v.item.cssClass"
              [ngStyle]="v.item.cssStyle"
              [tabindex]="v.index === 0 ? '0' : '-1'">
            </li>
          }
          @if (v.item.separator) {
            <li
              role="separator"
              class="k-drawer-item k-drawer-separator"
              [ngClass]="v.item.cssClass"
              [ngStyle]="v.item.cssStyle">
              &nbsp;
            </li>
          }
        }
        `,
      standalone: true,
      imports: [DrawerItemComponent, NgClass, NgStyle]
    }]
  }], () => [{
    type: DrawerService
  }, {
    type: Renderer2
  }, {
    type: NgZone
  }, {
    type: ElementRef
  }], {
    itemTemplate: [{
      type: Input
    }],
    mini: [{
      type: Input
    }],
    expanded: [{
      type: Input
    }],
    view: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    items: [{
      type: ViewChildren,
      args: [DrawerItemComponent, {
        read: ElementRef
      }]
    }]
  });
})();
var DEFAULT_ANIMATION = {
  type: "slide",
  duration: 200
};
var DrawerComponent = class _DrawerComponent {
  element;
  builder;
  localizationService;
  drawerService;
  hostClasses = true;
  get startPositionClass() {
    return this.position === "start";
  }
  get endPositionClass() {
    return this.position === "end";
  }
  get overlayTransofrmStyles() {
    if (this.mode === "push") {
      return;
    }
    if (this.expanded || this.minimized) {
      return `translateX(0px)`;
    }
    return `translateX(-100%)`;
  }
  get flexStyles() {
    if (this.mode === "overlay") {
      return;
    }
    if (!this.expanded && !this.minimized) {
      return 0;
    }
    return this.drawerWidth;
  }
  /**
   * Specifies the mode in which the Drawer displays.
   *
   * @default 'overlay'
   */
  mode = "overlay";
  /**
   * Specifies the position of the Drawer
   * ([see example]({% slug positioning_drawer %})).
   *
   * @default 'start'
   */
  position = "start";
  /**
   * Enables the mini (compact) view of the Drawer which displays when the component is collapsed
   * ([see example]({% slug expandmodespositions_drawer %}#toc-mini-view)).
   *
   * @default false
   */
  mini = false;
  /**
   * Specifies the state of the Drawer.
   *
   * @default false
   */
  expanded = false;
  /**
   * Defines the width of the Drawer when it is expanded.
   *
   * @default 240
   */
  width = 240;
  /**
   * Defines the width of the Drawer when the mini view is enabled and the component is collapsed.
   *
   * @default 50
   */
  miniWidth = 50;
  /**
   * Specifies if the Drawer automatically collapses when an item or the overlay is clicked.
   *
   * @default true
   */
  autoCollapse = true;
  /**
   * Defines the collection of items that render in the Drawer.
   *
   * @default []
   */
  items = [];
  /**
   * Defines a callback function which determines if an item should be expanded.
   * This is useful for hierarchical data structures where the expansion state of an item depends on its parent or other items.
   */
  set isItemExpanded(fn) {
    if (isDevMode && isPresent5(fn) && typeof fn !== "function") {
      throw new Error(`isItemExpanded must be a function, but received ${JSON.stringify(fn)}.`);
    }
    this.drawerService.isItemExpanded = fn;
  }
  get isItemExpanded() {
    return this.drawerService.isItemExpanded;
  }
  /**
   * @hidden
   */
  direction;
  /**
   * Specifies the animation settings of the Drawer
   * ([see example]({% slug interaction_drawer %}#toc-toggling-between-states)).
   *
   * @default { type: 'slide', duration: 200 }
   */
  animation = DEFAULT_ANIMATION;
  /**
   * Fires when the Drawer is expanded and its animation is complete.
   */
  expand = new EventEmitter();
  /**
   * Fires when the Drawer is collapsed and its animation is complete.
   */
  collapse = new EventEmitter();
  /**
   * Fires when an item in the Drawer is selected.
   * This event is preventable.
   */
  select = new EventEmitter();
  /**
   * Fires when the `expanded` property of the component is updated.
   * Used to provide a two-way binding for the `expanded` property.
   */
  expandedChange = new EventEmitter();
  /**
   * @hidden
   */
  drawerTemplate;
  /**
   * @hidden
   */
  footerTemplate;
  /**
   * @hidden
   */
  headerTemplate;
  /**
   * @hidden
   */
  itemTemplate;
  /**
   * @hidden
   */
  showLicenseWatermark = false;
  /**
   * @hidden
   */
  licenseMessage;
  viewItems;
  animationEnd = new EventEmitter();
  dynamicRTLSubscription;
  rtl = false;
  constructor(element, builder, localizationService, drawerService) {
    this.element = element;
    this.builder = builder;
    this.localizationService = localizationService;
    this.drawerService = drawerService;
    const isValid = N(packageMetadata3);
    this.licenseMessage = getLicenseMessage(packageMetadata3);
    this.showLicenseWatermark = shouldShowValidationUI(isValid);
    this.dynamicRTLSubscription = this.localizationService.changes.subscribe(({
      rtl
    }) => {
      this.rtl = rtl;
      this.direction = this.rtl ? "rtl" : "ltr";
    });
    this.drawerService.owner = this;
  }
  ngOnChanges(changes) {
    if (changes && changes["items"]) {
      this.drawerService.resetSelection();
      this.drawerService.init();
      this.viewItems = this.drawerService.view;
    }
  }
  ngOnDestroy() {
    if (this.dynamicRTLSubscription) {
      this.dynamicRTLSubscription.unsubscribe();
    }
  }
  /**
   * @hidden
   */
  get minimized() {
    return this.mini && !this.expanded;
  }
  /**
   * @hidden
   */
  get drawerWidth() {
    return this.minimized ? this.miniWidth : this.width;
  }
  /**
   * Toggles the visibility of the Drawer.
   * If the `expanded` parameter is not provided, the Drawer will toggle between expanded and collapsed states.
   *
   * @param expanded Specifies if the Drawer will be expanded or collapsed.
   */
  toggle(expanded) {
    const previous = this.expanded;
    const current = isPresent5(expanded) ? expanded : !previous;
    if (current === previous) {
      return;
    }
    if (current === true) {
      this.setExpanded(true);
    } else if (current === false && !this.animation) {
      this.setExpanded(false);
    }
    if (this.animation) {
      this.animationEnd.pipe(take(1)).subscribe(() => {
        this.onAnimationEnd(current);
      });
      this.animate(current);
    } else {
      this[current ? "expand" : "collapse"].emit();
    }
  }
  /**
   * @hidden
   */
  onSelect(e) {
    this.select.emit(Object.assign(e, {
      sender: this
    }));
  }
  onAnimationEnd(currentExpanded) {
    if (currentExpanded) {
      this.expand.emit();
    } else {
      this.setExpanded(false);
      this.collapse.emit();
    }
  }
  setExpanded(value2) {
    this.expanded = value2;
    this.expandedChange.emit(value2);
  }
  animate(expanded) {
    const settings = {
      mode: this.mode,
      mini: this.mini,
      miniWidth: this.miniWidth,
      width: this.width,
      rtl: this.rtl,
      position: this.position,
      animation: typeof this.animation !== "boolean" ? this.animation : DEFAULT_ANIMATION
    };
    const animation = expanded ? expandAnimation(settings) : collapseAnimation(settings);
    const player = this.createPlayer(animation, this.element.nativeElement);
    player.play();
  }
  createPlayer(animation, animatedElement) {
    const factory = this.builder.build(animation);
    let player = factory.create(animatedElement);
    player.onDone(() => {
      if (player) {
        this.animationEnd.emit();
        player.destroy();
        player = null;
      }
    });
    return player;
  }
  static ɵfac = function DrawerComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DrawerComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(AnimationBuilder), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(DrawerService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DrawerComponent,
    selectors: [["kendo-drawer"]],
    contentQueries: function DrawerComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, DrawerTemplateDirective, 5)(dirIndex, DrawerFooterTemplateDirective, 5)(dirIndex, DrawerHeaderTemplateDirective, 5)(dirIndex, DrawerItemTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.drawerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.itemTemplate = _t.first);
      }
    },
    hostVars: 11,
    hostBindings: function DrawerComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.direction);
        ɵɵstyleProp("transform", ctx.overlayTransofrmStyles)("flex-basis", ctx.flexStyles, "px");
        ɵɵclassProp("k-drawer", ctx.hostClasses)("k-drawer-start", ctx.startPositionClass)("k-drawer-end", ctx.endPositionClass);
      }
    },
    inputs: {
      mode: "mode",
      position: "position",
      mini: "mini",
      expanded: "expanded",
      width: "width",
      miniWidth: "miniWidth",
      autoCollapse: "autoCollapse",
      items: "items",
      isItemExpanded: "isItemExpanded",
      animation: "animation"
    },
    outputs: {
      expand: "expand",
      collapse: "collapse",
      select: "select",
      expandedChange: "expandedChange"
    },
    exportAs: ["kendoDrawer"],
    features: [ɵɵProvidersFeature([LocalizationService, DrawerService, {
      provide: L10N_PREFIX,
      useValue: "kendo.drawer"
    }]), ɵɵNgOnChangesFeature],
    decls: 2,
    vars: 2,
    consts: [[1, "k-drawer-wrapper", 3, "width"], ["kendoWatermarkOverlay", "", 3, "licenseMessage"], [1, "k-drawer-wrapper"], [3, "ngTemplateOutlet"], ["kendoDrawerList", "", "role", "menubar", "aria-orientation", "vertical", 1, "k-drawer-items", 3, "select", "mini", "expanded", "view", "itemTemplate"]],
    template: function DrawerComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵconditionalCreate(0, DrawerComponent_Conditional_0_Template, 3, 4, "div", 0);
        ɵɵconditionalCreate(1, DrawerComponent_Conditional_1_Template, 1, 1, "div", 1);
      }
      if (rf & 2) {
        ɵɵconditional(ctx.expanded || ctx.mini ? 0 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.showLicenseWatermark ? 1 : -1);
      }
    },
    dependencies: [NgTemplateOutlet, DrawerListComponent, WatermarkOverlayComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DrawerComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoDrawer",
      providers: [LocalizationService, DrawerService, {
        provide: L10N_PREFIX,
        useValue: "kendo.drawer"
      }],
      selector: "kendo-drawer",
      template: `
        @if (expanded || mini) {
          <div class="k-drawer-wrapper" [style.width.px]="drawerWidth">
            @if (!drawerTemplate) {
              @if (headerTemplate) {
                <ng-template
                  [ngTemplateOutlet]="headerTemplate?.templateRef">
                </ng-template>
              }
              <ul kendoDrawerList
                role="menubar"
                aria-orientation="vertical"
                (select)="onSelect($event)"
                [mini]="mini"
                [expanded]="expanded"
                [view]="viewItems"
                [itemTemplate]="itemTemplate?.templateRef"
                class="k-drawer-items">
              </ul>
              @if (footerTemplate) {
                <ng-template
                  [ngTemplateOutlet]="footerTemplate?.templateRef">
                </ng-template>
              }
            }
            @if (drawerTemplate) {
              <ng-template
                [ngTemplateOutlet]="drawerTemplate?.templateRef">
              </ng-template>
            }
          </div>
        }
        
        @if (showLicenseWatermark) {
          <div kendoWatermarkOverlay [licenseMessage]="licenseMessage"></div>
        }
        `,
      standalone: true,
      imports: [NgTemplateOutlet, DrawerListComponent, WatermarkOverlayComponent]
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: AnimationBuilder
  }, {
    type: LocalizationService
  }, {
    type: DrawerService
  }], {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-drawer"]
    }],
    startPositionClass: [{
      type: HostBinding,
      args: ["class.k-drawer-start"]
    }],
    endPositionClass: [{
      type: HostBinding,
      args: ["class.k-drawer-end"]
    }],
    overlayTransofrmStyles: [{
      type: HostBinding,
      args: ["style.transform"]
    }],
    flexStyles: [{
      type: HostBinding,
      args: ["style.flexBasis.px"]
    }],
    mode: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    mini: [{
      type: Input
    }],
    expanded: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    miniWidth: [{
      type: Input
    }],
    autoCollapse: [{
      type: Input
    }],
    items: [{
      type: Input
    }],
    isItemExpanded: [{
      type: Input
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    animation: [{
      type: Input
    }],
    expand: [{
      type: Output
    }],
    collapse: [{
      type: Output
    }],
    select: [{
      type: Output
    }],
    expandedChange: [{
      type: Output
    }],
    drawerTemplate: [{
      type: ContentChild,
      args: [DrawerTemplateDirective]
    }],
    footerTemplate: [{
      type: ContentChild,
      args: [DrawerFooterTemplateDirective]
    }],
    headerTemplate: [{
      type: ContentChild,
      args: [DrawerHeaderTemplateDirective]
    }],
    itemTemplate: [{
      type: ContentChild,
      args: [DrawerItemTemplateDirective]
    }]
  });
})();
var DrawerContainerComponent = class _DrawerContainerComponent {
  localizationService;
  get hostClass() {
    return true;
  }
  get overlayClass() {
    return this.drawer.mode === "overlay";
  }
  get miniClass() {
    return this.drawer.mini && !this.drawer.expanded;
  }
  get pushClass() {
    return this.drawer.mode === "push";
  }
  get isExpandedClass() {
    return this.drawer.expanded;
  }
  /**
   * @hidden
   */
  direction;
  /**
   * @hidden
   */
  drawer;
  dynamicRTLSubscription;
  rtl = false;
  constructor(localizationService) {
    this.localizationService = localizationService;
    this.dynamicRTLSubscription = this.localizationService.changes.subscribe(({
      rtl
    }) => {
      this.rtl = rtl;
      this.direction = this.rtl ? "rtl" : "ltr";
    });
  }
  ngOnDestroy() {
    if (this.dynamicRTLSubscription) {
      this.dynamicRTLSubscription.unsubscribe();
    }
  }
  /**
   * @hidden
   */
  get overlay() {
    return isPresent5(this.drawer) && this.drawer.expanded && this.drawer.mode === "overlay";
  }
  /**
   * @hidden
   */
  closeDrawer() {
    if (this.overlay && this.drawer.autoCollapse) {
      this.drawer.toggle(false);
    }
  }
  static ɵfac = function DrawerContainerComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DrawerContainerComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DrawerContainerComponent,
    selectors: [["kendo-drawer-container"]],
    contentQueries: function DrawerContainerComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, DrawerComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.drawer = _t.first);
      }
    },
    hostVars: 11,
    hostBindings: function DrawerContainerComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.direction);
        ɵɵclassProp("k-drawer-container", ctx.hostClass)("k-drawer-overlay", ctx.overlayClass)("k-drawer-mini", ctx.miniClass)("k-drawer-push", ctx.pushClass)("k-drawer-expanded", ctx.isExpandedClass);
      }
    },
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.drawer.container"
    }])],
    ngContentSelectors: _c82,
    decls: 2,
    vars: 1,
    consts: [[1, "k-overlay"], [1, "k-overlay", 3, "click"]],
    template: function DrawerContainerComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵconditionalCreate(0, DrawerContainerComponent_Conditional_0_Template, 1, 0, "div", 0);
        ɵɵprojection(1);
      }
      if (rf & 2) {
        ɵɵconditional(ctx.overlay ? 0 : -1);
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DrawerContainerComponent, [{
    type: Component,
    args: [{
      selector: "kendo-drawer-container",
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.drawer.container"
      }],
      template: `
        @if (overlay) {
          <div class="k-overlay" (click)="closeDrawer()"></div>
        }
        <ng-content></ng-content>
        `,
      standalone: true
    }]
  }], () => [{
    type: LocalizationService
  }], {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-drawer-container"]
    }],
    overlayClass: [{
      type: HostBinding,
      args: ["class.k-drawer-overlay"]
    }],
    miniClass: [{
      type: HostBinding,
      args: ["class.k-drawer-mini"]
    }],
    pushClass: [{
      type: HostBinding,
      args: ["class.k-drawer-push"]
    }],
    isExpandedClass: [{
      type: HostBinding,
      args: ["class.k-drawer-expanded"]
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    drawer: [{
      type: ContentChild,
      args: [DrawerComponent]
    }]
  });
})();
var DrawerContentComponent = class _DrawerContentComponent {
  hostClasses = true;
  constructor() {
  }
  static ɵfac = function DrawerContentComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DrawerContentComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DrawerContentComponent,
    selectors: [["kendo-drawer-content"]],
    hostVars: 2,
    hostBindings: function DrawerContentComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-drawer-content", ctx.hostClasses);
      }
    },
    ngContentSelectors: _c82,
    decls: 1,
    vars: 0,
    template: function DrawerContentComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DrawerContentComponent, [{
    type: Component,
    args: [{
      selector: "kendo-drawer-content",
      template: `
        <ng-content></ng-content>
    `,
      encapsulation: ViewEncapsulation.None,
      standalone: true
    }]
  }], () => [], {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-drawer-content"]
    }]
  });
})();
var StepperStepTemplateDirective = class _StepperStepTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function StepperStepTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _StepperStepTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _StepperStepTemplateDirective,
    selectors: [["", "kendoStepperStepTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StepperStepTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoStepperStepTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var StepperLabelTemplateDirective = class _StepperLabelTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function StepperLabelTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _StepperLabelTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _StepperLabelTemplateDirective,
    selectors: [["", "kendoStepperLabelTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StepperLabelTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoStepperLabelTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var StepperIndicatorTemplateDirective = class _StepperIndicatorTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function StepperIndicatorTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _StepperIndicatorTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _StepperIndicatorTemplateDirective,
    selectors: [["", "kendoStepperIndicatorTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StepperIndicatorTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoStepperIndicatorTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var DEFAULT_CURRENT_STEP = 0;
var handlers = {};
handlers[Keys.ArrowLeft] = "left";
handlers[Keys.ArrowRight] = "right";
handlers[Keys.ArrowUp] = "up";
handlers[Keys.ArrowDown] = "down";
handlers[Keys.Home] = "home";
handlers[Keys.End] = "end";
handlers[Keys.Enter] = "enter";
handlers[Keys.NumpadEnter] = "enter";
handlers[Keys.Space] = "enter";
var handlersRTL = Object.assign({}, handlers);
handlersRTL[Keys.ArrowLeft] = "right";
handlersRTL[Keys.ArrowRight] = "left";
var StepperActivateEvent$1 = class StepperActivateEvent extends PreventableEvent {
  /**
   * Specifies the index of the activated step in the `steps` collection.
   */
  index;
  /**
   * Specifies the activated step.
   */
  step;
  /**
   * Specifies the DOM event that triggered the step activation.
   */
  originalEvent;
  /**
   * Specifies the Stepper that triggered the event.
   */
  sender;
  /**
   * @hidden
   */
  constructor(args) {
    super();
    Object.assign(this, args);
  }
};
var StepperService = class _StepperService {
  localization;
  ngZone;
  changeDetector;
  owner;
  currentStep = DEFAULT_CURRENT_STEP;
  focusedStep;
  triggerValidation = new EventEmitter();
  focusedStepChange = new EventEmitter();
  get handlers() {
    return this.localization.rtl ? handlersRTL : handlers;
  }
  constructor(localization, ngZone, changeDetector) {
    this.localization = localization;
    this.ngZone = ngZone;
    this.changeDetector = changeDetector;
  }
  emit(event, eventArgs) {
    const stepper2 = this.owner;
    if (hasObservers(stepper2[event])) {
      stepper2[event].emit(eventArgs);
    }
    return eventArgs.isDefaultPrevented();
  }
  onActivate(currentIdx, originalEvent) {
    const eventArgs = new StepperActivateEvent$1({
      index: currentIdx,
      step: this.owner.steps[currentIdx],
      originalEvent,
      sender: this.owner
    });
    this.ngZone.run(() => {
      if (!this.emit("activate", eventArgs)) {
        this.currentStep = currentIdx;
        this.owner["currentStepChange"].emit(currentIdx);
        this.changeDetector.detectChanges();
      }
    });
  }
  validateSteps() {
    this.triggerValidation.emit();
  }
  keydown(e) {
    const current = this.focusedStep || this.currentStep;
    const code = normalizeKeys(e);
    const handler = this.handlers[code];
    if (!isPresent5(current)) {
      return;
    }
    if (handler) {
      e.preventDefault();
      this[handler](e);
    }
  }
  left() {
    if (!this.isHorizontal) {
      return;
    }
    this.focusPrevStep();
  }
  right() {
    if (!this.isHorizontal) {
      return;
    }
    this.focusNextStep();
  }
  up() {
    if (this.isHorizontal) {
      return;
    }
    this.focusPrevStep();
  }
  down() {
    if (this.isHorizontal) {
      return;
    }
    this.focusNextStep();
  }
  home() {
    this.focusedStep = 0;
    this.focusedStepChange.emit();
  }
  end() {
    this.focusedStep = this.owner.steps.length - 1;
    this.focusedStepChange.emit();
  }
  enter(event) {
    if (this.focusedStep === this.currentStep) {
      return;
    }
    if (this.isStepDisabled(this.focusedStep)) {
      return;
    }
    if (this.owner.linear && this.isPrevOrNextStep(this.focusedStep) === false) {
      return;
    }
    this.onActivate(this.focusedStep, event);
  }
  focus(focusedIdx) {
    this.focusedStep = focusedIdx;
  }
  focusNextStep() {
    if (this.focusedStep < this.owner.steps.length) {
      this.focusedStep += 1;
      this.focusedStepChange.emit();
    }
  }
  focusPrevStep() {
    if (this.focusedStep > 0) {
      this.focusedStep -= 1;
      this.focusedStepChange.emit();
    }
  }
  isStepDisabled(index) {
    return this.owner.steps[index].disabled;
  }
  isPrevOrNextStep(index) {
    return index === this.currentStep + 1 || index === this.currentStep - 1;
  }
  get isHorizontal() {
    return this.owner.orientation === "horizontal";
  }
  static ɵfac = function StepperService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _StepperService)(ɵɵinject(LocalizationService), ɵɵinject(NgZone), ɵɵinject(ChangeDetectorRef));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _StepperService,
    factory: _StepperService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StepperService, [{
    type: Injectable
  }], () => [{
    type: LocalizationService
  }, {
    type: NgZone
  }, {
    type: ChangeDetectorRef
  }], null);
})();
var STEPPER_STEP_INDEX = "data-kendo-stepper-index";
var StepperStepComponent = class _StepperStepComponent {
  service;
  localization;
  ngZone;
  step;
  index;
  current;
  type;
  successIcon;
  successSVGIcon;
  errorIcon;
  errorSVGIcon;
  svgIcon;
  indicatorTemplate;
  labelTemplate;
  stepTemplate;
  stepLink;
  isStepValid = void 0;
  shouldCheckValidity = void 0;
  checkCircleIcon = checkCircleIcon;
  exclamationCircleIcon = exclamationCircleIcon;
  subs;
  constructor(service, localization, ngZone) {
    this.service = service;
    this.localization = localization;
    this.ngZone = ngZone;
    N(packageMetadata3);
    this.subs = this.service.focusedStepChange.subscribe(() => {
      this.onFocusedStepChange();
    });
    this.subs.add(this.service.triggerValidation.subscribe(() => {
      this.handleValidityChecks();
    }));
  }
  get errorStepClass() {
    if (isPresent5(this.isStepValid)) {
      return !this.isStepValid;
    }
    return false;
  }
  get successStepClass() {
    if (isPresent5(this.isStepValid)) {
      return this.isStepValid;
    }
    return false;
  }
  ngOnInit() {
    this.handleValidityChecks();
  }
  ngOnChanges(changes) {
    if (changes["current"] && !changes["current"].firstChange) {
      this.handleValidityChecks();
    }
  }
  ngOnDestroy() {
    if (this.subs) {
      this.subs.unsubscribe();
    }
  }
  onFocusedStepChange() {
    this.ngZone.runOutsideAngular(() => {
      if (this.index === this.service.focusedStep) {
        this.stepLink.nativeElement.focus();
      }
    });
  }
  onFocus() {
    this.service.focus(this.index);
  }
  get tabIndexAttr() {
    const active = this.service.focusedStep || this.service.currentStep;
    return this.index === active ? 0 : -1;
  }
  get indicatorIconClass() {
    if (this.step.icon && !this.step.iconClass) {
      return `${this.step.icon}`;
    }
    if (!this.step.icon && !this.step.iconClass && this.shouldCheckValidity) {
      return this.validationIconClasses;
    }
  }
  get customIndicatorIconClass() {
    if (this.step.iconClass) {
      return `${this.step.iconClass}`;
    }
    const renderCustomValidationIcon = !this.step.icon && !this.step.iconClass && this.shouldCheckValidity;
    if (renderCustomValidationIcon) {
      return this.customValidationIconClasses;
    }
  }
  get SVGIndicatorIcon() {
    if (this.step.svgIcon) {
      return this.step.svgIcon;
    }
    if (!this.step.svgIcon && this.shouldCheckValidity) {
      return this.validationSVGIcon;
    }
  }
  get validationIconClasses() {
    if (this.isStepValid) {
      return !this.successIcon ? "check-circle" : "";
    }
    return !this.errorIcon ? "exclamation-circle" : "";
  }
  get customValidationIconClasses() {
    if (this.isStepValid) {
      return this.successIcon ? this.successIcon : "";
    }
    return this.errorIcon ? this.errorIcon : "";
  }
  get validationSVGIcon() {
    if (this.isStepValid) {
      return this.successSVGIcon ? this.successSVGIcon : this.checkCircleIcon;
    }
    return this.errorSVGIcon ? this.errorSVGIcon : this.exclamationCircleIcon;
  }
  get showIndicatorIcon() {
    if (this.shouldCheckValidity) {
      return true;
    }
    if (this.step.icon || this.step.iconClass || this.step.svgIcon) {
      return true;
    }
    return false;
  }
  get showLabelIcon() {
    if (this.shouldCheckValidity) {
      if (this.type === "label") {
        return true;
      }
      if (this.step.icon || this.step.iconClass) {
        return true;
      }
    }
    return false;
  }
  get showLabelText() {
    return this.type === "label" || this.type === "full";
  }
  get indicatorText() {
    const text = this.step.text;
    return text ? text : (this.index + 1).toString();
  }
  updateStepValidity() {
    if (typeof this.step.isValid === "boolean") {
      return this.step.isValid;
    }
    if (typeof this.step.isValid === "function") {
      return this.step.isValid(this.index);
    }
    return void 0;
  }
  get showIndicator() {
    return this.type === "indicator" || this.type === "full";
  }
  get showLabel() {
    if (this.type === "label" || this.type === "full") {
      return true;
    }
    return this.step.optional;
  }
  get optionalText() {
    return this.localization.get("optional");
  }
  get transitionDuration() {
    return this.service.owner.animationDuration;
  }
  _shouldCheckValidity() {
    if (isPresent5(this.step.validate)) {
      if (typeof this.step.validate === "boolean") {
        return this.step.validate;
      }
      if (typeof this.step.validate === "function") {
        return this.step.validate(this.index);
      }
    }
    return isPresent5(this.step.isValid) && this.index < this.current;
  }
  handleValidityChecks() {
    this.isStepValid = void 0;
    this.shouldCheckValidity = this._shouldCheckValidity();
    if (this.shouldCheckValidity) {
      this.isStepValid = this.updateStepValidity();
    }
  }
  static ɵfac = function StepperStepComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _StepperStepComponent)(ɵɵdirectiveInject(StepperService), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _StepperStepComponent,
    selectors: [["", "kendoStepperStep", ""]],
    viewQuery: function StepperStepComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c232, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.stepLink = _t.first);
      }
    },
    hostVars: 4,
    hostBindings: function StepperStepComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-step-error", ctx.errorStepClass)("k-step-success", ctx.successStepClass);
      }
    },
    inputs: {
      step: "step",
      index: "index",
      current: "current",
      type: "type",
      successIcon: "successIcon",
      successSVGIcon: "successSVGIcon",
      errorIcon: "errorIcon",
      errorSVGIcon: "errorSVGIcon",
      svgIcon: "svgIcon",
      indicatorTemplate: "indicatorTemplate",
      labelTemplate: "labelTemplate",
      stepTemplate: "stepTemplate"
    },
    features: [ɵɵNgOnChangesFeature],
    attrs: _c242,
    decls: 4,
    vars: 6,
    consts: [["stepLink", ""], ["href", "#", 1, "k-step-link", 3, "focus"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["aria-hidden", "true", 1, "k-step-indicator", 3, "transition-duration"], [1, "k-step-label"], ["aria-hidden", "true", 1, "k-step-indicator"], ["innerCssClass", "k-step-indicator-icon", 3, "name", "customFontClass", "svgIcon"], [1, "k-step-indicator-text"], [1, "k-step-text"], ["aria-hidden", "true", 3, "name", "customFontClass", "svgIcon"], [1, "k-step-label-optional"]],
    template: function StepperStepComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "a", 1, 0);
        ɵɵlistener("focus", function StepperStepComponent_Template_a_focus_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onFocus());
        });
        ɵɵconditionalCreate(2, StepperStepComponent_Conditional_2_Template, 1, 5, null, 2);
        ɵɵconditionalCreate(3, StepperStepComponent_Conditional_3_Template, 2, 2);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵattribute("tabindex", ctx.tabIndexAttr)("title", ctx.step.label)("aria-disabled", ctx.step.disabled)("aria-current", ctx.index === ctx.current ? "step" : null);
        ɵɵadvance(2);
        ɵɵconditional(ctx.stepTemplate ? 2 : -1);
        ɵɵadvance();
        ɵɵconditional(!ctx.stepTemplate ? 3 : -1);
      }
    },
    dependencies: [NgTemplateOutlet, IconWrapperComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StepperStepComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "[kendoStepperStep]",
      template: `
        <a href='#' class='k-step-link' #stepLink
          [attr.tabindex]='tabIndexAttr'
          [attr.title]='step.label'
          [attr.aria-disabled]='step.disabled'
          [attr.aria-current]='index === current ? "step" : null'
          (focus)='onFocus()'
          >
          @if (stepTemplate) {
            <ng-template
              [ngTemplateOutlet]='stepTemplate'
              [ngTemplateOutletContext]='{ $implicit: step, index: index }'>
            </ng-template>
          }

          @if (!stepTemplate) {
            @if (showIndicator) {
              <span
                class='k-step-indicator'
                aria-hidden='true'
                [style.transition-duration.ms]='transitionDuration'
                >
                @if (indicatorTemplate) {
                  <ng-template
                    [ngTemplateOutlet]='indicatorTemplate'
                    [ngTemplateOutletContext]='{ $implicit: step, index: index }'>
                  </ng-template>
                }
                @if (!indicatorTemplate) {
                  @if (showIndicatorIcon) {
                    <kendo-icon-wrapper
                      [name]='indicatorIconClass'
                      [customFontClass]='customIndicatorIconClass'
                      [svgIcon]='SVGIndicatorIcon'
                      innerCssClass='k-step-indicator-icon'
                      >
                    </kendo-icon-wrapper>
                  }
                  @if (!showIndicatorIcon) {
                    <span class='k-step-indicator-text'>{{ indicatorText }}</span>
                  }
                }
              </span>
            }
            @if (showLabel) {
              <span class='k-step-label'>
                @if (labelTemplate) {
                  <ng-template
                    [ngTemplateOutlet]='labelTemplate'
                    [ngTemplateOutletContext]='{ $implicit: step, index: index }'>
                  </ng-template>
                }
                @if (!labelTemplate) {
                  @if (showLabelText) {
                    <span class='k-step-text'>{{ step.label }}</span>
                  }
                  @if (showLabelIcon) {
                    <kendo-icon-wrapper
                      aria-hidden='true'
                      [name]='validationIconClasses'
                      [customFontClass]='customValidationIconClasses'
                      [svgIcon]='validationSVGIcon'
                      >
                    </kendo-icon-wrapper>
                  }
                  @if (step.optional) {
                    <span class='k-step-label-optional'>({{optionalText}})</span>
                  }
                }
              </span>
            }
          }
        </a>
        `,
      standalone: true,
      imports: [NgTemplateOutlet, IconWrapperComponent]
    }]
  }], () => [{
    type: StepperService
  }, {
    type: LocalizationService
  }, {
    type: NgZone
  }], {
    step: [{
      type: Input
    }],
    index: [{
      type: Input
    }],
    current: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    successIcon: [{
      type: Input
    }],
    successSVGIcon: [{
      type: Input
    }],
    errorIcon: [{
      type: Input
    }],
    errorSVGIcon: [{
      type: Input
    }],
    svgIcon: [{
      type: Input
    }],
    indicatorTemplate: [{
      type: Input
    }],
    labelTemplate: [{
      type: Input
    }],
    stepTemplate: [{
      type: Input
    }],
    stepLink: [{
      type: ViewChild,
      args: ["stepLink", {
        static: true
      }]
    }],
    errorStepClass: [{
      type: HostBinding,
      args: ["class.k-step-error"]
    }],
    successStepClass: [{
      type: HostBinding,
      args: ["class.k-step-success"]
    }]
  });
})();
var StepperListComponent = class _StepperListComponent {
  renderer;
  ngZone;
  service;
  element;
  linear;
  stepType;
  orientation;
  currentStep;
  steps;
  successIcon;
  successSVGIcon;
  errorIcon;
  errorSVGIcon;
  svgIcon;
  indicatorTemplate;
  labelTemplate;
  stepTemplate;
  listKeydown = new EventEmitter();
  listClick = new EventEmitter();
  domSubs;
  constructor(renderer, ngZone, service, element) {
    this.renderer = renderer;
    this.ngZone = ngZone;
    this.service = service;
    this.element = element;
  }
  ngOnInit() {
    this.initDomEvents();
  }
  ngOnDestroy() {
    if (this.domSubs) {
      this.domSubs();
    }
  }
  get maxStepWidth() {
    return this.maxStepDimension("width");
  }
  get maxStepHeight() {
    return this.maxStepDimension("height");
  }
  get focusedStep() {
    return this.service.focusedStep;
  }
  isPresent(arg) {
    return isPresent(arg);
  }
  maxStepDimension(dimension) {
    if (dimension === "width" && this.orientation === "vertical") {
      return null;
    }
    if (dimension === "height" && this.orientation === "horizontal") {
      return null;
    }
    return 100 / this.steps.length;
  }
  initDomEvents() {
    if (!this.element) {
      return;
    }
    this.ngZone.runOutsideAngular(() => {
      const nativeElement = this.element.nativeElement;
      const clickSubscription = this.renderer.listen(nativeElement, "click", this.clickHandler.bind(this));
      const keydownSubscription = this.renderer.listen(nativeElement, "keydown", (e) => {
        if (hasClass(e.target, "k-step-link")) {
          this.listKeydown.emit(e);
        }
      });
      this.domSubs = () => {
        clickSubscription();
        keydownSubscription();
      };
    });
  }
  clickHandler(e) {
    e.preventDefault();
    const stepIdx = this.getStepIndex(e.target);
    const step = this.steps[stepIdx];
    if (!step || step.disabled) {
      return;
    }
    const eventArgs = {
      stepIdx,
      currentStep: this.currentStep,
      linear: this.linear,
      originalEvent: e
    };
    this.listClick.emit(eventArgs);
  }
  getStepIndex(target) {
    const step = closestItem(target, STEPPER_STEP_INDEX, this.element.nativeElement);
    if (step) {
      return itemIndex(step, STEPPER_STEP_INDEX);
    }
  }
  static ɵfac = function StepperListComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _StepperListComponent)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(StepperService), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _StepperListComponent,
    selectors: [["", "kendoStepperList", ""]],
    inputs: {
      linear: "linear",
      stepType: "stepType",
      orientation: "orientation",
      currentStep: "currentStep",
      steps: "steps",
      successIcon: "successIcon",
      successSVGIcon: "successSVGIcon",
      errorIcon: "errorIcon",
      errorSVGIcon: "errorSVGIcon",
      svgIcon: "svgIcon",
      indicatorTemplate: "indicatorTemplate",
      labelTemplate: "labelTemplate",
      stepTemplate: "stepTemplate"
    },
    outputs: {
      listKeydown: "listKeydown",
      listClick: "listClick"
    },
    attrs: _c262,
    decls: 2,
    vars: 0,
    consts: [["kendoStepperStep", "", 1, "k-step", 3, "type", "step", "index", "current", "successIcon", "successSVGIcon", "errorIcon", "errorSVGIcon", "svgIcon", "indicatorTemplate", "labelTemplate", "stepTemplate", "k-step-first", "k-step-last", "k-step-done", "k-step-current", "k-step-optional", "k-disabled", "k-focus", "ngClass", "ngStyle", "max-width", "max-height"], ["kendoStepperStep", "", 1, "k-step", 3, "type", "step", "index", "current", "successIcon", "successSVGIcon", "errorIcon", "errorSVGIcon", "svgIcon", "indicatorTemplate", "labelTemplate", "stepTemplate", "ngClass", "ngStyle"]],
    template: function StepperListComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵrepeaterCreate(0, StepperListComponent_For_1_Template, 1, 33, "li", 0, ɵɵrepeaterTrackByIdentity);
      }
      if (rf & 2) {
        ɵɵrepeater(ctx.steps);
      }
    },
    dependencies: [StepperStepComponent, NgClass, NgStyle],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StepperListComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "[kendoStepperList]",
      template: `
        @for (step of steps; track step; let idx = $index) {
          <li kendoStepperStep
            [attr.${STEPPER_STEP_INDEX}]='idx'
            [type]='stepType'
            [step]='step'
            [index]='idx'
            [current]='currentStep'
            [successIcon]='successIcon'
            [successSVGIcon]='successSVGIcon'
            [errorIcon]='errorIcon'
            [errorSVGIcon]='errorSVGIcon'
            [svgIcon]='svgIcon'
            [indicatorTemplate]='indicatorTemplate'
            [labelTemplate]='labelTemplate'
            [stepTemplate]='stepTemplate'
            class='k-step'
            [class.k-step-first]='idx === 0'
            [class.k-step-last]='idx === steps.length - 1'
            [class.k-step-done]='idx < currentStep'
            [class.k-step-current]='idx === currentStep'
            [class.k-step-optional]='step.optional'
            [class.k-disabled]='step.disabled'
            [class.k-focus]='idx === focusedStep || (!isPresent(focusedStep) && idx === currentStep)'
            [ngClass]='step.cssClass'
            [ngStyle]='step.cssStyle'
            [style.max-width.%] = 'maxStepWidth'
            [style.max-height.%] = 'maxStepHeight'
            >
          </li>
        }
        `,
      standalone: true,
      imports: [StepperStepComponent, NgClass, NgStyle]
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: NgZone
  }, {
    type: StepperService
  }, {
    type: ElementRef
  }], {
    linear: [{
      type: Input
    }],
    stepType: [{
      type: Input
    }],
    orientation: [{
      type: Input
    }],
    currentStep: [{
      type: Input
    }],
    steps: [{
      type: Input
    }],
    successIcon: [{
      type: Input
    }],
    successSVGIcon: [{
      type: Input
    }],
    errorIcon: [{
      type: Input
    }],
    errorSVGIcon: [{
      type: Input
    }],
    svgIcon: [{
      type: Input
    }],
    indicatorTemplate: [{
      type: Input
    }],
    labelTemplate: [{
      type: Input
    }],
    stepTemplate: [{
      type: Input
    }],
    listKeydown: [{
      type: Output
    }],
    listClick: [{
      type: Output
    }]
  });
})();
var StepperMessages = class _StepperMessages extends ComponentMessages {
  /**
   * Specifies the optional text.
   */
  optional;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵStepperMessages_BaseFactory;
    return function StepperMessages_Factory(__ngFactoryType__) {
      return (ɵStepperMessages_BaseFactory || (ɵStepperMessages_BaseFactory = ɵɵgetInheritedFactory(_StepperMessages)))(__ngFactoryType__ || _StepperMessages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _StepperMessages,
    selectors: [["kendo-stepper-messages-base"]],
    inputs: {
      optional: "optional"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StepperMessages, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line @angular-eslint/directive-selector
      selector: "kendo-stepper-messages-base"
    }]
  }], null, {
    optional: [{
      type: Input
    }]
  });
})();
var LocalizedStepperMessagesDirective = class _LocalizedStepperMessagesDirective extends StepperMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function LocalizedStepperMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LocalizedStepperMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LocalizedStepperMessagesDirective,
    selectors: [["", "kendoStepperLocalizedMessages", ""]],
    features: [ɵɵProvidersFeature([{
      provide: StepperMessages,
      useExisting: forwardRef(() => _LocalizedStepperMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalizedStepperMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: StepperMessages,
        useExisting: forwardRef(() => LocalizedStepperMessagesDirective)
      }],
      selector: `
      [kendoStepperLocalizedMessages]
    `,
      standalone: true
    }]
  }], () => [{
    type: LocalizationService
  }], null);
})();
var DEFAULT_ANIMATION_DURATION = 400;
var StepperComponent = class _StepperComponent {
  renderer;
  elem;
  localization;
  stepperService;
  hostClasses = true;
  get linearClass() {
    return this.linear;
  }
  ariaRole = "navigation";
  direction;
  displayStyle = "grid";
  /**
   * Specifies the type of the steps in the Stepper.
   *
   * @default 'indicator'
   */
  stepType = "indicator";
  /**
   * Specifies the linear flow of the Stepper.
   *
   * @default true
   */
  linear = true;
  /**
   * Specifies the orientation of the Stepper
   * ([see example]({% slug orientation_stepper %})).
   *
   * @default 'horizontal'
   */
  orientation = "horizontal";
  /**
   * Specifies the index of the current step.
   */
  set currentStep(value2) {
    this.stepperService.currentStep = value2;
  }
  get currentStep() {
    return this.stepperService.currentStep;
  }
  /**
   * Specifies the collection of steps that will be rendered in the Stepper
   * ([see example]({% slug step_appearance_stepper %})).
   */
  set steps(steps) {
    if (isPresent5(steps) && steps.length > 0) {
      this._steps = steps;
    }
  }
  get steps() {
    return this._steps;
  }
  /**
   * Specifies an SVG icon to be rendered inside the step indicator instead of the default numeric or text content.
   * You can use either an [existing Kendo SVG icon](slug:svgicon_list) or a custom one.
   */
  set svgIcon(icon) {
    this._svgIcon = icon;
  }
  get svgIcon() {
    return this._svgIcon;
  }
  /**
   * Specifies an SVG icon to be rendered for the success icon.
   * You can use either an [existing Kendo SVG icon](slug:svgicon_list) or a custom one.
   */
  successSVGIcon;
  /**
   * Specifies an SVG icon to be rendered for the error icon.
   * You can use either an [existing Kendo SVG icon](slug:svgicon_list) or a custom one.
   */
  errorSVGIcon;
  /**
   * Specifies an SVG icon that will be rendered inside the step for valid previous steps.
   * You can use either an [existing Kendo SVG icon](slug:svgicon_list) or a custom one.
   */
  successIcon;
  /**
  * Specifies an SVG icon that will be rendered inside the step for invalid previous steps.
  * You can use either an [existing Kendo SVG icon](slug:svgicon_list) or a custom one.
  */
  errorIcon;
  /**
   * Specifies the duration of the progress indicator animation in milliseconds.
   *
   * @default true
   */
  animation = true;
  /**
   * Fires when a step is about to be activated. You can prevent this event.
   */
  activate = new EventEmitter();
  /**
   * Fires when the `currentStep` property of the component was updated.
   * Use this event to provide a two-way binding for the `currentStep` property.
   */
  currentStepChange = new EventEmitter();
  /**
   * @hidden
   */
  stepTemplate;
  /**
   * @hidden
   */
  labelTemplate;
  /**
   * @hidden
   */
  indicatorTemplate;
  dynamicRTLSubscription;
  _steps = [];
  _successSVGIcon;
  _errorSVGIcon;
  _svgIcon;
  constructor(renderer, elem, localization, stepperService) {
    this.renderer = renderer;
    this.elem = elem;
    this.localization = localization;
    this.stepperService = stepperService;
    this.dynamicRTLSubscription = this.localization.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
    });
    this.stepperService.owner = this;
  }
  ngOnInit() {
    this.applyHostStyling();
  }
  ngOnChanges(changes) {
    if (changes["steps"] && !changes["steps"].firstChange) {
      this.applyHostStyling();
    }
    if (changes["orientation"]) {
      this.resetHostStyling();
      this.applyHostStyling();
    }
  }
  ngOnDestroy() {
    if (this.dynamicRTLSubscription) {
      this.dynamicRTLSubscription.unsubscribe();
    }
  }
  /**
   * Manually triggers the validity check configured by the [isValid]({% slug api_layout_stepperstep %}#toc-isvalid) property of the steps ([see example]({% slug step_validation_stepper %}#toc-triggering-the-validation)).
   *
   * Steps that have their [validate]({% slug api_layout_stepperstep %}#toc-validate) property set to `false`, will not be validated.
   */
  validateSteps() {
    this.stepperService.validateSteps();
  }
  applyHostStyling() {
    const stepFramesStyle = this.orientation === "horizontal" ? "grid-template-columns" : "grid-template-rows";
    const stepFramesValue = `repeat(${this.steps.length * 2}, 1fr)`;
    this.renderer.setStyle(this.elem.nativeElement, stepFramesStyle, stepFramesValue);
  }
  resetHostStyling() {
    this.renderer.removeStyle(this.elem.nativeElement, "grid-template-columns");
    this.renderer.removeStyle(this.elem.nativeElement, "grid-template-rows");
  }
  /**
   * @hidden
   */
  get progressAnimation() {
    return {
      duration: this.animationDuration
    };
  }
  /**
   * @hidden
   */
  get animationDuration() {
    if (typeof this.animation === "number") {
      return this.animation;
    }
    if (typeof this.animation === "boolean" && this.animation) {
      return DEFAULT_ANIMATION_DURATION;
    }
    return 0;
  }
  /**
   * @hidden
   */
  get stepsListStyling() {
    if (this.orientation === "horizontal") {
      return {
        "grid-column-start": 1,
        "grid-column-end": -1
      };
    }
    return {
      "grid-row-start": 1,
      "grid-row-end": -1
    };
  }
  /**
   * @hidden
   */
  get progressBarStyling() {
    if (this.orientation === "horizontal") {
      return {
        "grid-column-start": 2,
        "grid-column-end": this.steps.length * 2
      };
    }
    return {
      "grid-row-start": 2,
      "grid-row-end": this.steps.length * 2
    };
  }
  /**
   * @hidden
   */
  onListKeydown(e) {
    this.stepperService.keydown(e);
  }
  /**
   * @hidden
   */
  onListClick(e) {
    if (e.stepIdx === e.currentStep) {
      this.stepperService.focus(e.stepIdx);
      return;
    }
    if (e.linear && this.stepperService.isPrevOrNextStep(e.stepIdx) === false) {
      return;
    }
    this.stepperService.onActivate(e.stepIdx, e.originalEvent);
  }
  /**
   * @hidden
   */
  get isHorizontal() {
    return this.orientation === "horizontal";
  }
  static ɵfac = function StepperComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _StepperComponent)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(StepperService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _StepperComponent,
    selectors: [["kendo-stepper"]],
    contentQueries: function StepperComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, StepperStepTemplateDirective, 5)(dirIndex, StepperLabelTemplateDirective, 5)(dirIndex, StepperIndicatorTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.stepTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.labelTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.indicatorTemplate = _t.first);
      }
    },
    hostVars: 8,
    hostBindings: function StepperComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("role", ctx.ariaRole)("dir", ctx.direction);
        ɵɵstyleProp("display", ctx.displayStyle);
        ɵɵclassProp("k-stepper", ctx.hostClasses)("k-stepper-linear", ctx.linearClass);
      }
    },
    inputs: {
      stepType: "stepType",
      linear: "linear",
      orientation: "orientation",
      currentStep: "currentStep",
      steps: "steps",
      svgIcon: "svgIcon",
      successSVGIcon: "successSVGIcon",
      errorSVGIcon: "errorSVGIcon",
      successIcon: "successIcon",
      errorIcon: "errorIcon",
      animation: "animation"
    },
    outputs: {
      activate: "activate",
      currentStepChange: "currentStepChange"
    },
    exportAs: ["kendoStepper"],
    features: [ɵɵProvidersFeature([LocalizationService, StepperService, {
      provide: L10N_PREFIX,
      useValue: "kendo.stepper"
    }]), ɵɵNgOnChangesFeature],
    decls: 3,
    vars: 19,
    consts: () => {
      let i18n_3;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_LAYOUT_FESM2022_PROGRESS_KENDO_ANGULAR_LAYOUT_MJS_3 = goog.getMsg("Optional");
        i18n_3 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_LAYOUT_FESM2022_PROGRESS_KENDO_ANGULAR_LAYOUT_MJS_3;
      } else {
        i18n_3 = $localize`:kendo.stepper.optional|The text for the optional segment of the step label:Optional`;
      }
      return [["kendoStepperLocalizedMessages", "", "optional", i18n_3], ["kendoStepperList", "", 1, "k-step-list", 3, "listKeydown", "listClick", "stepType", "linear", "orientation", "steps", "currentStep", "successIcon", "successSVGIcon", "errorIcon", "errorSVGIcon", "svgIcon", "indicatorTemplate", "labelTemplate", "stepTemplate", "ngStyle"], [3, "animation", "max", "label", "orientation", "reverse", "value", "ngStyle"]];
    },
    template: function StepperComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainer(0, 0);
        ɵɵelementStart(1, "ol", 1);
        ɵɵlistener("listKeydown", function StepperComponent_Template_ol_listKeydown_1_listener($event) {
          return ctx.onListKeydown($event);
        })("listClick", function StepperComponent_Template_ol_listClick_1_listener($event) {
          return ctx.onListClick($event);
        });
        ɵɵelementEnd();
        ɵɵconditionalCreate(2, StepperComponent_Conditional_2_Template, 1, 9, "kendo-progressbar", 2);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵclassProp("k-step-list-horizontal", ctx.isHorizontal)("k-step-list-vertical", !ctx.isHorizontal);
        ɵɵproperty("stepType", ctx.stepType)("linear", ctx.linear)("orientation", ctx.orientation)("steps", ctx.steps)("currentStep", ctx.currentStep)("successIcon", ctx.successIcon)("successSVGIcon", ctx.successSVGIcon)("errorIcon", ctx.errorIcon)("errorSVGIcon", ctx.errorSVGIcon)("svgIcon", ctx.svgIcon)("indicatorTemplate", ctx.indicatorTemplate == null ? null : ctx.indicatorTemplate.templateRef)("labelTemplate", ctx.labelTemplate == null ? null : ctx.labelTemplate.templateRef)("stepTemplate", ctx.stepTemplate == null ? null : ctx.stepTemplate.templateRef)("ngStyle", ctx.stepsListStyling);
        ɵɵadvance();
        ɵɵconditional(ctx.steps.length > 0 ? 2 : -1);
      }
    },
    dependencies: [LocalizedStepperMessagesDirective, StepperListComponent, NgStyle, ProgressBarComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StepperComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoStepper",
      providers: [LocalizationService, StepperService, {
        provide: L10N_PREFIX,
        useValue: "kendo.stepper"
      }],
      selector: "kendo-stepper",
      template: `
        <ng-container kendoStepperLocalizedMessages
          i18n-optional="kendo.stepper.optional|The text for the optional segment of the step label"
          optional="Optional"
          >
        </ng-container>
        <ol kendoStepperList
          [stepType]='stepType'
          [linear]='linear'
          [orientation]='orientation'
          [steps]='steps'
          [currentStep]='currentStep'
          [successIcon]='successIcon'
          [successSVGIcon]='successSVGIcon'
          [errorIcon]='errorIcon'
          [errorSVGIcon]='errorSVGIcon'
          [svgIcon]="svgIcon"
          [indicatorTemplate]='indicatorTemplate?.templateRef'
          [labelTemplate]='labelTemplate?.templateRef'
          [stepTemplate]='stepTemplate?.templateRef'
          class='k-step-list'
          [class.k-step-list-horizontal]='isHorizontal'
          [class.k-step-list-vertical]='!isHorizontal'
          [ngStyle]='stepsListStyling'
          (listKeydown)="onListKeydown($event)"
          (listClick)="onListClick($event)">
        </ol>
        
        @if (steps.length > 0) {
          <kendo-progressbar
            [attr.aria-hidden]='true'
            [animation]='progressAnimation'
            [max]='steps.length - 1'
            [label]='{position: "start", visible: false}'
            [orientation]='orientation'
            [reverse]='!isHorizontal'
            [value]='currentStep'
            [ngStyle]='progressBarStyling'>
          </kendo-progressbar>
        }
        `,
      standalone: true,
      imports: [LocalizedStepperMessagesDirective, StepperListComponent, NgStyle, ProgressBarComponent]
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: LocalizationService
  }, {
    type: StepperService
  }], {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-stepper"]
    }],
    linearClass: [{
      type: HostBinding,
      args: ["class.k-stepper-linear"]
    }],
    ariaRole: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    displayStyle: [{
      type: HostBinding,
      args: ["style.display"]
    }],
    stepType: [{
      type: Input
    }],
    linear: [{
      type: Input
    }],
    orientation: [{
      type: Input
    }],
    currentStep: [{
      type: Input
    }],
    steps: [{
      type: Input
    }],
    svgIcon: [{
      type: Input
    }],
    successSVGIcon: [{
      type: Input
    }],
    errorSVGIcon: [{
      type: Input
    }],
    successIcon: [{
      type: Input
    }],
    errorIcon: [{
      type: Input
    }],
    animation: [{
      type: Input
    }],
    activate: [{
      type: Output
    }],
    currentStepChange: [{
      type: Output
    }],
    stepTemplate: [{
      type: ContentChild,
      args: [StepperStepTemplateDirective, {
        static: false
      }]
    }],
    labelTemplate: [{
      type: ContentChild,
      args: [StepperLabelTemplateDirective, {
        static: false
      }]
    }],
    indicatorTemplate: [{
      type: ContentChild,
      args: [StepperIndicatorTemplateDirective, {
        static: false
      }]
    }]
  });
})();
var StepperCustomMessagesComponent = class _StepperCustomMessagesComponent extends StepperMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function StepperCustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _StepperCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _StepperCustomMessagesComponent,
    selectors: [["kendo-stepper-messages"]],
    features: [ɵɵProvidersFeature([{
      provide: StepperMessages,
      useExisting: forwardRef(() => _StepperCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function StepperCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StepperCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: StepperMessages,
        useExisting: forwardRef(() => StepperCustomMessagesComponent)
      }],
      selector: "kendo-stepper-messages",
      template: ``,
      standalone: true
    }]
  }], () => [{
    type: LocalizationService
  }], null);
})();
var Messages2 = class _Messages extends ComponentMessages {
  /**
   * Defines the alt attribute text of the image in the Avatar.
   */
  avatarAlt;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵMessages_BaseFactory;
    return function Messages_Factory(__ngFactoryType__) {
      return (ɵMessages_BaseFactory || (ɵMessages_BaseFactory = ɵɵgetInheritedFactory(_Messages)))(__ngFactoryType__ || _Messages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _Messages,
    selectors: [["kendoAvatarMessages"]],
    inputs: {
      avatarAlt: "avatarAlt"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Messages2, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line @angular-eslint/directive-selector
      selector: "kendoAvatarMessages"
    }]
  }], null, {
    avatarAlt: [{
      type: Input
    }]
  });
})();
var LocalizedAvatarMessagesDirective = class _LocalizedAvatarMessagesDirective extends Messages2 {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function LocalizedAvatarMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LocalizedAvatarMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LocalizedAvatarMessagesDirective,
    selectors: [["", "kendoAvatarLocalizedMessages", ""]],
    features: [ɵɵProvidersFeature([{
      provide: Messages2,
      useExisting: forwardRef(() => _LocalizedAvatarMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalizedAvatarMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: Messages2,
        useExisting: forwardRef(() => LocalizedAvatarMessagesDirective)
      }],
      selector: "[kendoAvatarLocalizedMessages]",
      standalone: true
    }]
  }], () => [{
    type: LocalizationService
  }], null);
})();
var DEFAULT_ROUNDED2 = "full";
var DEFAULT_SIZE2 = "medium";
var DEFAULT_THEME_COLOR = "primary";
var DEFAULT_FILL_MODE2 = "solid";
var AvatarComponent = class _AvatarComponent {
  localization;
  renderer;
  element;
  hostClass = true;
  /**
   * @hidden
   */
  get borderClass() {
    return this.border;
  }
  /**
   * @hidden
   */
  get flexBasis() {
    return this.width;
  }
  /**
   * Sets the shape for the avatar.
   * @hidden
   */
  set shape(shape) {
    this.rounded = mapShapeToRounded(shape);
  }
  /**
   * Specifies the size of the Avatar
   * ([see example]({% slug appearance_avatar %}#toc-size)).
   *
   * @default 'medium'
   */
  set size(size) {
    if (size !== this._size) {
      const newSize = size ? size : DEFAULT_SIZE2;
      this.handleClasses("size", newSize);
      this._size = newSize;
    }
  }
  get size() {
    return this._size;
  }
  /**
   * Specifies the rounded styling of the Avatar
   * ([see example](slug:appearance_avatar#toc-roundness)).
   *
   * @default 'full'
   */
  set rounded(rounded) {
    if (rounded !== this._rounded) {
      const newRounded = rounded ? rounded : DEFAULT_ROUNDED2;
      this.handleClasses("rounded", newRounded);
      this._rounded = newRounded;
    }
  }
  get rounded() {
    return this._rounded;
  }
  /**
   * Specifies the theme color of the Avatar.
   * The theme color applies as background and border color while adjusting the text color accordingly.
   *
   * @default 'primary'
   */
  set themeColor(themeColor) {
    if (themeColor !== this._themeColor) {
      const newThemeColor = themeColor ? themeColor : DEFAULT_THEME_COLOR;
      this._themeColor = newThemeColor;
      this.handleFillModeAndThemeColorClasses(this.fillMode, this.themeColor);
    }
  }
  get themeColor() {
    return this._themeColor;
  }
  /**
   * Specifies the fill style of the Avatar.
   *
   * @default 'solid'
   */
  set fillMode(fillMode) {
    if (fillMode !== this.fillMode) {
      const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE2;
      this._fillMode = newFillMode;
      this.handleFillModeAndThemeColorClasses(this.fillMode, this.themeColor);
    }
  }
  get fillMode() {
    return this._fillMode;
  }
  /**
   * Specifies the appearance fill style of the avatar.
   * Deprecated, left for backward compatibility.
   *
   * @hidden
   */
  set fill(fillMode) {
    this.fillMode = fillMode;
  }
  /**
   * Adds a border to the Avatar.
   *
   * @default false
   */
  border = false;
  /**
   * Defines a CSS class or multiple classes separated by spaces.
   * You can apply these classes to a `span` element inside the Avatar and also use custom icons.
   */
  iconClass;
  /**
   * Sets the width of the Avatar.
   */
  width;
  /**
   * @hidden
   */
  get avatarWidth() {
    return this.width;
  }
  /**
   * Sets the height of the Avatar.
   */
  height;
  /**
   * @hidden
   */
  get avatarHeight() {
    return this.height;
  }
  /**
   * Defines the CSS styles that render on the content element of the Avatar.
   * Supports the type of values that [`ngStyle`](link:site.data.urls.angular['ngstyleapi']) supports.
   */
  cssStyle;
  /**
   * Sets the initials for the Avatar.
   */
  initials;
  /**
   * Sets the icon for the Avatar.
   * All [Kendo UI Icons](slug:icons#icons-list) are supported.
   */
  icon;
  /**
   * Sets the image source of the Avatar.
   */
  imageSrc;
  /**
   * Defines an SVG icon to render.
   * You can use either an [existing Kendo SVG icon](slug:svgicon_list) or a custom one.
   */
  set svgIcon(icon) {
    if (isDevMode() && icon && this.icon && this.iconClass) {
      throw new Error("Setting both icon/svgIcon and iconClass options at the same time is not supported.");
    }
    this._svgIcon = icon;
  }
  get svgIcon() {
    return this._svgIcon;
  }
  _themeColor = DEFAULT_THEME_COLOR;
  _size = DEFAULT_SIZE2;
  _fillMode = DEFAULT_FILL_MODE2;
  _rounded = DEFAULT_ROUNDED2;
  _svgIcon;
  constructor(localization, renderer, element) {
    this.localization = localization;
    this.renderer = renderer;
    this.element = element;
    N(packageMetadata3);
  }
  ngOnInit() {
    this.verifyProperties();
  }
  ngAfterViewInit() {
    const stylingInputs = ["size", "rounded"];
    stylingInputs.forEach((input) => {
      this.handleClasses(input, this[input]);
    });
    this.handleFillModeAndThemeColorClasses(this.fillMode, this.themeColor);
  }
  /**
   * @hidden
   */
  get customAvatar() {
    return !(this.imageSrc || this.initials || this.icon || this.iconClass);
  }
  verifyProperties() {
    if (!isDevMode()) {
      return;
    }
    const inputs = [this.icon || this.iconClass, this.imageSrc, this.initials];
    const inputsLength = inputs.filter((value2) => value2).length;
    if (inputsLength > 1) {
      throw new Error(`
                Invalid property configuration given.
                The kendo-avatar component can accept only one of:
                icon, imageSrc or initials properties.
            `);
    }
  }
  handleClasses(styleType, value2) {
    const elem = this.element.nativeElement;
    const classes = getStylingClasses("avatar", styleType, this[styleType], value2);
    if (classes.toRemove) {
      this.renderer.removeClass(elem, classes.toRemove);
    }
    if (classes.toAdd) {
      this.renderer.addClass(elem, classes.toAdd);
    }
  }
  handleFillModeAndThemeColorClasses(fill, themeColor) {
    const wrapperElement = this.element.nativeElement;
    const currentClasses = Array.from(wrapperElement.classList);
    const classesToRemove = currentClasses.filter((cl) => {
      return cl.startsWith("k-avatar-solid") || cl.startsWith("k-avatar-outline");
    });
    classesToRemove.forEach((cl) => this.renderer.removeClass(wrapperElement, cl));
    if (fill !== "none") {
      this.renderer.addClass(wrapperElement, `k-avatar-${fill}`);
    }
    if (fill !== "none" && themeColor !== "none") {
      this.renderer.addClass(wrapperElement, `k-avatar-${fill}-${themeColor}`);
    }
  }
  /**
   * @hidden
   */
  textFor(key) {
    return this.localization.get(key);
  }
  static ɵfac = function AvatarComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AvatarComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _AvatarComponent,
    selectors: [["kendo-avatar"]],
    hostVars: 10,
    hostBindings: function AvatarComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵstyleProp("flex-basis", ctx.flexBasis)("width", ctx.avatarWidth)("height", ctx.avatarHeight);
        ɵɵclassProp("k-avatar", ctx.hostClass)("k-avatar-bordered", ctx.borderClass);
      }
    },
    inputs: {
      shape: "shape",
      size: "size",
      rounded: "rounded",
      themeColor: "themeColor",
      fillMode: "fillMode",
      fill: "fill",
      border: "border",
      iconClass: "iconClass",
      width: "width",
      height: "height",
      cssStyle: "cssStyle",
      initials: "initials",
      icon: "icon",
      imageSrc: "imageSrc",
      svgIcon: "svgIcon"
    },
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.avatar"
    }])],
    ngContentSelectors: _c82,
    decls: 5,
    vars: 4,
    consts: () => {
      let i18n_4;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_LAYOUT_FESM2022_PROGRESS_KENDO_ANGULAR_LAYOUT_MJS_4 = goog.getMsg("Avatar");
        i18n_4 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_LAYOUT_FESM2022_PROGRESS_KENDO_ANGULAR_LAYOUT_MJS_4;
      } else {
        i18n_4 = $localize`:kendo.avatar.avatarAlt|The alt attribute text of the image in the avatar.:Avatar`;
      }
      return [["kendoAvatarLocalizedMessages", "", "avatarAlt", i18n_4], [1, "k-avatar-image"], [1, "k-avatar-text", 3, "ngStyle"], [1, "k-avatar-icon"], [3, "src", "alt", "ngStyle"], [3, "ngStyle", "name", "customFontClass", "svgIcon"]];
    },
    template: function AvatarComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵelementContainer(0, 0);
        ɵɵconditionalCreate(1, AvatarComponent_Conditional_1_Template, 1, 0);
        ɵɵconditionalCreate(2, AvatarComponent_Conditional_2_Template, 2, 4, "span", 1);
        ɵɵconditionalCreate(3, AvatarComponent_Conditional_3_Template, 2, 2, "span", 2);
        ɵɵconditionalCreate(4, AvatarComponent_Conditional_4_Template, 2, 4, "span", 3);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵconditional(ctx.customAvatar ? 1 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.imageSrc ? 2 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.initials ? 3 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.icon || ctx.iconClass || ctx.svgIcon ? 4 : -1);
      }
    },
    dependencies: [NgStyle, IconWrapperComponent, LocalizedAvatarMessagesDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AvatarComponent, [{
    type: Component,
    args: [{
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.avatar"
      }],
      selector: "kendo-avatar",
      template: `
        <ng-container kendoAvatarLocalizedMessages
          i18n-avatarAlt="kendo.avatar.avatarAlt|The alt attribute text of the image in the avatar."
          avatarAlt="Avatar"
          >
        </ng-container>
        
        @if (customAvatar) {
          <ng-content></ng-content>
        }
        
        @if (imageSrc) {
          <span class="k-avatar-image">
            <img src="{{ imageSrc }}" [alt]="textFor('avatarAlt')" [ngStyle]="cssStyle" />
          </span>
        }
        
        @if (initials) {
          <span class="k-avatar-text" [ngStyle]="cssStyle">{{ initials.substring(0, 2) }}</span>
        }
        
        @if (icon || iconClass || svgIcon) {
          <span class="k-avatar-icon">
            <kendo-icon-wrapper
              [ngStyle]="cssStyle"
              [name]="icon"
              [customFontClass]="iconClass"
              [svgIcon]="svgIcon"
              >
            </kendo-icon-wrapper>
          </span>
        }
        `,
      standalone: true,
      imports: [NgStyle, IconWrapperComponent, LocalizedAvatarMessagesDirective]
    }]
  }], () => [{
    type: LocalizationService
  }, {
    type: Renderer2
  }, {
    type: ElementRef
  }], {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-avatar"]
    }],
    borderClass: [{
      type: HostBinding,
      args: ["class.k-avatar-bordered"]
    }],
    flexBasis: [{
      type: HostBinding,
      args: ["style.flexBasis"]
    }],
    shape: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }],
    themeColor: [{
      type: Input
    }],
    fillMode: [{
      type: Input
    }],
    fill: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    iconClass: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    avatarWidth: [{
      type: HostBinding,
      args: ["style.width"]
    }],
    height: [{
      type: Input
    }],
    avatarHeight: [{
      type: HostBinding,
      args: ["style.height"]
    }],
    cssStyle: [{
      type: Input
    }],
    initials: [{
      type: Input
    }],
    icon: [{
      type: Input
    }],
    imageSrc: [{
      type: Input
    }],
    svgIcon: [{
      type: Input
    }]
  });
})();
var AvatarCustomMessagesComponent = class _AvatarCustomMessagesComponent extends Messages2 {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function AvatarCustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AvatarCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _AvatarCustomMessagesComponent,
    selectors: [["kendo-avatar-messages"]],
    features: [ɵɵProvidersFeature([{
      provide: Messages2,
      useExisting: forwardRef(() => _AvatarCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function AvatarCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AvatarCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: Messages2,
        useExisting: forwardRef(() => AvatarCustomMessagesComponent)
      }],
      selector: "kendo-avatar-messages",
      template: ``,
      standalone: true
    }]
  }], () => [{
    type: LocalizationService
  }], null);
})();
var CardComponent = class _CardComponent {
  localizationService;
  hostClass = true;
  get widthStyle() {
    return this.width;
  }
  get vertical() {
    return this.orientation === "vertical";
  }
  get horizontal() {
    return this.orientation === "horizontal";
  }
  /**
   * @hidden
   */
  direction;
  /**
   * Specifies the layout of the Card content.
   *
   * @default 'vertical'
   */
  orientation = "vertical";
  /**
   * Defines the width of the Card.
   *
   * @default '285px'
   */
  width = "285px";
  dynamicRTLSubscription;
  rtl = false;
  constructor(localizationService) {
    this.localizationService = localizationService;
    N(packageMetadata3);
    this.dynamicRTLSubscription = this.localizationService.changes.subscribe(({
      rtl
    }) => {
      this.rtl = rtl;
      this.direction = this.rtl ? "rtl" : "ltr";
    });
  }
  ngOnDestroy() {
    if (this.dynamicRTLSubscription) {
      this.dynamicRTLSubscription.unsubscribe();
    }
  }
  static ɵfac = function CardComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CardComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _CardComponent,
    selectors: [["kendo-card"]],
    hostVars: 9,
    hostBindings: function CardComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.direction);
        ɵɵstyleProp("width", ctx.widthStyle);
        ɵɵclassProp("k-card", ctx.hostClass)("k-card-vertical", ctx.vertical)("k-card-horizontal", ctx.horizontal);
      }
    },
    inputs: {
      orientation: "orientation",
      width: "width"
    },
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.card.component"
    }])],
    ngContentSelectors: _c82,
    decls: 1,
    vars: 0,
    template: function CardComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CardComponent, [{
    type: Component,
    args: [{
      selector: "kendo-card",
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.card.component"
      }],
      template: `
        <ng-content></ng-content>
    `,
      standalone: true
    }]
  }], () => [{
    type: LocalizationService
  }], {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-card"]
    }],
    widthStyle: [{
      type: HostBinding,
      args: ["style.width"]
    }],
    vertical: [{
      type: HostBinding,
      args: ["class.k-card-vertical"]
    }],
    horizontal: [{
      type: HostBinding,
      args: ["class.k-card-horizontal"]
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    orientation: [{
      type: Input
    }],
    width: [{
      type: Input
    }]
  });
})();
var CardHeaderComponent = class _CardHeaderComponent {
  hostClass = true;
  static ɵfac = function CardHeaderComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CardHeaderComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _CardHeaderComponent,
    selectors: [["kendo-card-header"]],
    hostVars: 2,
    hostBindings: function CardHeaderComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-card-header", ctx.hostClass);
      }
    },
    ngContentSelectors: _c82,
    decls: 1,
    vars: 0,
    template: function CardHeaderComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CardHeaderComponent, [{
    type: Component,
    args: [{
      selector: "kendo-card-header",
      template: `
        <ng-content></ng-content>
    `,
      standalone: true
    }]
  }], null, {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-card-header"]
    }]
  });
})();
var CardBodyComponent = class _CardBodyComponent {
  hostClass = true;
  static ɵfac = function CardBodyComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CardBodyComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _CardBodyComponent,
    selectors: [["kendo-card-body"]],
    hostVars: 2,
    hostBindings: function CardBodyComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-card-body", ctx.hostClass);
      }
    },
    ngContentSelectors: _c82,
    decls: 1,
    vars: 0,
    template: function CardBodyComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CardBodyComponent, [{
    type: Component,
    args: [{
      selector: "kendo-card-body",
      template: `
        <ng-content></ng-content>
    `,
      standalone: true
    }]
  }], null, {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-card-body"]
    }]
  });
})();
var CardFooterComponent = class _CardFooterComponent {
  hostClass = true;
  static ɵfac = function CardFooterComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CardFooterComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _CardFooterComponent,
    selectors: [["kendo-card-footer"]],
    hostVars: 2,
    hostBindings: function CardFooterComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-card-footer", ctx.hostClass);
      }
    },
    ngContentSelectors: _c82,
    decls: 1,
    vars: 0,
    template: function CardFooterComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CardFooterComponent, [{
    type: Component,
    args: [{
      selector: "kendo-card-footer",
      template: `
        <ng-content></ng-content>
    `,
      standalone: true
    }]
  }], null, {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-card-footer"]
    }]
  });
})();
var CardActionsComponent = class _CardActionsComponent {
  hostClass = true;
  get stretchedClass() {
    return this.layout === "stretched";
  }
  get startClass() {
    return this.layout === "start";
  }
  get endClass() {
    return this.layout === "end";
  }
  get centerClass() {
    return this.layout === "center";
  }
  get verticalClass() {
    return this.orientation === "vertical";
  }
  get horizontalClass() {
    return this.orientation === "horizontal";
  }
  /**
   * Specifies the orientation of the Card action buttons.
   *
   * @default 'horizontal'
   */
  orientation = "horizontal";
  /**
   * Specifies the layout of the Card action buttons.
   *
   * @default 'start'
   */
  layout = "start";
  /**
   * Defines the Card actions declaratively.
   * You can pass an array of `CardAction` objects or a `TemplateRef`.
   */
  set actions(value2) {
    if (Array.isArray(value2)) {
      this.actionsArray = value2;
    } else if (value2 instanceof TemplateRef) {
      this.actionsTemplate = value2;
    }
  }
  /**
   * Fires when you click an action button.
   */
  action = new EventEmitter();
  /**
   * @hidden
   */
  actionsArray;
  /**
   * @hidden
   */
  actionsTemplate;
  /**
   * @hidden
   */
  onClick(action) {
    this.action.emit(action);
  }
  static ɵfac = function CardActionsComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CardActionsComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _CardActionsComponent,
    selectors: [["kendo-card-actions"]],
    hostVars: 16,
    hostBindings: function CardActionsComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-actions", ctx.hostClass)("k-card-actions", ctx.hostClass)("k-actions-stretched", ctx.stretchedClass)("k-actions-start", ctx.startClass)("k-actions-end", ctx.endClass)("k-actions-center", ctx.centerClass)("k-actions-vertical", ctx.verticalClass)("k-actions-horizontal", ctx.horizontalClass);
      }
    },
    inputs: {
      orientation: "orientation",
      layout: "layout",
      actions: "actions"
    },
    outputs: {
      action: "action"
    },
    ngContentSelectors: _c82,
    decls: 3,
    vars: 3,
    consts: [[3, "ngTemplateOutlet"], ["type", "button", 1, "k-button", "k-button-md", "k-rounded-md", 3, "k-button-solid", "k-button-flat", "k-button-solid-base", "k-button-solid-primary", "k-button-flat-base", "k-button-flat-primary"], ["type", "button", 1, "k-button", "k-button-md", "k-rounded-md", 3, "click"], [1, "k-button-text"]],
    template: function CardActionsComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵconditionalCreate(0, CardActionsComponent_Conditional_0_Template, 1, 0);
        ɵɵconditionalCreate(1, CardActionsComponent_Conditional_1_Template, 2, 0);
        ɵɵconditionalCreate(2, CardActionsComponent_Conditional_2_Template, 1, 1, null, 0);
      }
      if (rf & 2) {
        ɵɵconditional(!ctx.actionsArray && !ctx.actionsTemplate ? 0 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.actionsArray ? 1 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.actionsTemplate ? 2 : -1);
      }
    },
    dependencies: [NgTemplateOutlet],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CardActionsComponent, [{
    type: Component,
    args: [{
      selector: "kendo-card-actions",
      template: `
        @if (!actionsArray && !actionsTemplate) {
          <ng-content></ng-content>
        }
        
        @if (actionsArray) {
          @for (action of actionsArray; track action) {
            <button
              type="button"
              class="k-button k-button-md k-rounded-md"
              [class.k-button-solid]="!action.flat"
              [class.k-button-flat]="action.flat"
              [class.k-button-solid-base]="!action.primary && !action.flat"
              [class.k-button-solid-primary]="action.primary && !action.flat"
              [class.k-button-flat-base]="!action.primary && action.flat"
              [class.k-button-flat-primary]="action.primary && action.flat"
              (click)="onClick(action)"
              >
              <span class="k-button-text">{{ action.text }}</span>
            </button>
          }
        }
        
        @if (actionsTemplate) {
          <ng-template [ngTemplateOutlet]="actionsTemplate"></ng-template>
        }
        `,
      standalone: true,
      imports: [NgTemplateOutlet]
    }]
  }], null, {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-actions"]
    }, {
      type: HostBinding,
      args: ["class.k-card-actions"]
    }],
    stretchedClass: [{
      type: HostBinding,
      args: ["class.k-actions-stretched"]
    }],
    startClass: [{
      type: HostBinding,
      args: ["class.k-actions-start"]
    }],
    endClass: [{
      type: HostBinding,
      args: ["class.k-actions-end"]
    }],
    centerClass: [{
      type: HostBinding,
      args: ["class.k-actions-center"]
    }],
    verticalClass: [{
      type: HostBinding,
      args: ["class.k-actions-vertical"]
    }],
    horizontalClass: [{
      type: HostBinding,
      args: ["class.k-actions-horizontal"]
    }],
    orientation: [{
      type: Input
    }],
    layout: [{
      type: Input
    }],
    actions: [{
      type: Input
    }],
    action: [{
      type: Output
    }]
  });
})();
var CardSeparatorDirective = class _CardSeparatorDirective {
  hostClass = true;
  get verticalClass() {
    return this.orientation === "vertical";
  }
  get horizontalClass() {
    return this.orientation === "horizontal";
  }
  /**
   * Sets the color of the Card separator.
   */
  color;
  /**
   * Specifies the orientation of the Card separator.
   *
   * @default 'horizontal'
   */
  orientation = "horizontal";
  static ɵfac = function CardSeparatorDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CardSeparatorDirective)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CardSeparatorDirective,
    selectors: [["", "kendoCardSeparator", ""]],
    hostVars: 8,
    hostBindings: function CardSeparatorDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵstyleProp("color", ctx.color);
        ɵɵclassProp("k-card-separator", ctx.hostClass)("k-separator-vertical", ctx.verticalClass)("k-separator-horizontal", ctx.horizontalClass);
      }
    },
    inputs: {
      color: "color",
      orientation: "orientation"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CardSeparatorDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoCardSeparator]",
      standalone: true
    }]
  }], null, {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-card-separator"]
    }],
    verticalClass: [{
      type: HostBinding,
      args: ["class.k-separator-vertical"]
    }],
    horizontalClass: [{
      type: HostBinding,
      args: ["class.k-separator-horizontal"]
    }],
    color: [{
      type: HostBinding,
      args: ["style.color"]
    }, {
      type: Input
    }],
    orientation: [{
      type: Input
    }]
  });
})();
var CardTitleDirective = class _CardTitleDirective {
  hostClass = true;
  static ɵfac = function CardTitleDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CardTitleDirective)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CardTitleDirective,
    selectors: [["", "kendoCardTitle", ""]],
    hostVars: 2,
    hostBindings: function CardTitleDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-card-title", ctx.hostClass);
      }
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CardTitleDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoCardTitle]",
      standalone: true
    }]
  }], null, {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-card-title"]
    }]
  });
})();
var CardSubtitleDirective = class _CardSubtitleDirective {
  hostClass = true;
  static ɵfac = function CardSubtitleDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CardSubtitleDirective)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CardSubtitleDirective,
    selectors: [["", "kendoCardSubtitle", ""]],
    hostVars: 2,
    hostBindings: function CardSubtitleDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-card-subtitle", ctx.hostClass);
      }
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CardSubtitleDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoCardSubtitle]",
      standalone: true
    }]
  }], null, {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-card-subtitle"]
    }]
  });
})();
var CardMediaDirective = class _CardMediaDirective {
  hostClass = true;
  static ɵfac = function CardMediaDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CardMediaDirective)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CardMediaDirective,
    selectors: [["", "kendoCardMedia", ""]],
    hostVars: 2,
    hostBindings: function CardMediaDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-card-media", ctx.hostClass);
      }
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CardMediaDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoCardMedia]",
      standalone: true
    }]
  }], null, {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-card-media"]
    }]
  });
})();
var ExpansionPanelTitleDirective = class _ExpansionPanelTitleDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function ExpansionPanelTitleDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ExpansionPanelTitleDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ExpansionPanelTitleDirective,
    selectors: [["", "kendoExpansionPanelTitleDirective", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExpansionPanelTitleDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoExpansionPanelTitleDirective]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
function expand(duration, height2) {
  return [style({
    overflow: "hidden",
    display: "block",
    height: 0
  }), animate(`${duration}ms ease-in`, style({
    height: `${height2}`
  }))];
}
function collapse(duration, height2) {
  return [style({
    overflow: "hidden",
    height: `${height2}`
  }), animate(`${duration}ms ease-in`, style({
    overflow: "hidden",
    height: 0
  }))];
}
var ExpansionPanelActionEvent = class extends PreventableEvent {
  /**
   * Defines the action that takes place upon interaction with the ExpansionPanel.
   */
  action;
  /**
   * @hidden
   */
  constructor(args) {
    super();
    Object.assign(this, args);
  }
};
var DEFAULT_DURATION = 200;
var CONTENT_HIDDEN_CLASS = "k-hidden";
var incrementingId = 0;
var ExpansionPanelComponent = class _ExpansionPanelComponent {
  renderer;
  hostElement;
  ngZone;
  localizationService;
  builder;
  /**
   * Specifies the primary text in the header of the ExpansionPanel
   * ([see example](slug:title_expansionpanel#toc-titles-and-subtitles)).
   */
  title = "";
  /**
   * Specifies the secondary text in the header of the ExpansionPanel, which renders next to the collapse/expand icon
   * ([see example](slug:title_expansionpanel#toc-titles-and-subtitles)).
   */
  subtitle = "";
  /**
   * Specifies whether the ExpansionPanel is disabled. If disabled, the ExpansionPanel can be neither expanded nor collapsed
   * ([see example]({% slug disabled_expansionpanel %})).
   *
   * @default false
   */
  disabled = false;
  /**
   * Specifies whether the ExpansionPanel is expanded. The property supports two-way binding
   * ([see example]({% slug interaction_expansionpanel %}#toc-setting-the-initial-state)).
   *
   * @default false
   */
  set expanded(value2) {
    if (value2 === this.expanded) {
      return;
    }
    this._expanded = value2;
    if (this.expanded) {
      this.removeContentHiddenClass();
    } else {
      this.addContentHiddenClass();
    }
  }
  get expanded() {
    return this._expanded;
  }
  /**
   * Defines an SVG icon for the expanded state of the component.
   * You can use either an [existing Kendo SVG icon](slug:svgicon_list) or a custom one.
   */
  set svgExpandIcon(icon) {
    if (isDevMode() && icon && this.expandIcon) {
      throw new Error("Setting both expandIcon/svgExpandIcon options at the same time is not supported.");
    }
    this._svgExpandIcon = icon;
  }
  get svgExpandIcon() {
    return this._svgExpandIcon;
  }
  /**
   * Defines an SVG icon for the collapsed state of the component.
   * You can use either an [existing Kendo SVG icon](slug:svgicon_list) or a custom one.
   */
  set svgCollapseIcon(icon) {
    if (isDevMode() && icon && this.collapseIcon) {
      throw new Error("Setting both collapseIcon/svgCollapseIcon options at the same time is not supported.");
    }
    this._svgCollapseIcon = icon;
  }
  get svgCollapseIcon() {
    return this._svgCollapseIcon;
  }
  /**
   * Sets a custom icon via CSS class(es) for the collapsed state of the component
   * ([see example]({% slug icons_expansionpanel %}#toc-icons)).
   */
  expandIcon;
  /**
   * Sets a custom icon via CSS class(es) for the expanded state of the component
   * ([see example]({% slug icons_expansionpanel %}#toc-icons)).
   */
  collapseIcon;
  /**
   * Specifies the animation settings of the ExpansionPanel
   * ([see example]({% slug animations_expansionpanel %})).
   *
   * @default true
   */
  animation = true;
  /**
   * Fires when the `expanded` property of the component is updated.
   * Used to provide a two-way binding for the `expanded` property
   * ([see example](slug:events_expansionpanel)).
   */
  expandedChange = new EventEmitter();
  /**
   * Fires when the expanded state of the ExpansionPanel is about to change. This event is preventable
   * ([see example](slug:events_expansionpanel)).
   */
  action = new EventEmitter();
  /**
   * Fires when the ExpansionPanel is expanded. If there is animation it fires when the animation is complete
   * ([see example](slug:events_expansionpanel)).
   */
  expand = new EventEmitter();
  /**
   * Fires when the ExpansionPanel is collapsed. If there is animation it fires when the animation is complete
   * ([see example](slug:events_expansionpanel)).
   */
  collapse = new EventEmitter();
  /**
   * @hidden
   */
  titleTemplate;
  content;
  header;
  hostClass = true;
  get expandedClass() {
    return this.expanded && !this.disabled;
  }
  direction;
  /**
   * @hidden
   */
  focused = false;
  animationEnd = new EventEmitter();
  subscriptions = new Subscription();
  _expanded = false;
  _svgExpandIcon = chevronDownIcon;
  _svgCollapseIcon = chevronUpIcon;
  nextId = incrementingId++;
  constructor(renderer, hostElement, ngZone, localizationService, builder) {
    this.renderer = renderer;
    this.hostElement = hostElement;
    this.ngZone = ngZone;
    this.localizationService = localizationService;
    this.builder = builder;
    N(packageMetadata3);
    this.direction = localizationService.rtl ? "rtl" : "ltr";
  }
  ngOnInit() {
    this.renderer.removeAttribute(this.hostElement.nativeElement, "title");
    this.subscriptions = this.localizationService.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
    });
    const elem = this.hostElement.nativeElement;
    const header = this.header.nativeElement;
    this.subscriptions.add(this.renderer.listen(header, "focus", () => this.focusExpansionPanel(elem)));
    this.subscriptions.add(this.renderer.listen(header, "blur", () => this.blurExpansionPanel(elem)));
  }
  ngAfterViewInit() {
    this.initDomEvents();
    if (!this.expanded) {
      this.renderer.addClass(this.content.nativeElement, CONTENT_HIDDEN_CLASS);
    }
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  /**
   * @hidden
   */
  initDomEvents() {
    if (!this.hostElement) {
      return;
    }
    this.ngZone.runOutsideAngular(() => {
      const elem = this.hostElement.nativeElement;
      this.subscriptions.add(this.renderer.listen(elem, "keydown", this.keyDownHandler.bind(this)));
    });
  }
  /**
   * @hidden
   */
  keyDownHandler(ev) {
    const isEnterOrSpace = ev.code === Keys.Enter || ev.code === Keys.NumpadEnter || ev.code === Keys.Space;
    if (this.disabled || !isEnterOrSpace) {
      return;
    }
    if (hasClass(ev.target, "k-expander-header")) {
      ev.preventDefault();
      this.ngZone.run(() => {
        this.onHeaderAction();
      });
    }
  }
  /**
   * @hidden
   */
  onHeaderClick(ev) {
    const header = this.header.nativeElement;
    if (!isFocusable2(ev.target) || ev.target === header && !this.disabled) {
      this.onHeaderAction();
    }
  }
  /**
   * @hidden
   */
  onHeaderAction() {
    const eventArgs = new ExpansionPanelActionEvent();
    eventArgs.action = this.expanded ? "collapse" : "expand";
    this.action.emit(eventArgs);
    if (!eventArgs.isDefaultPrevented()) {
      this.setExpanded(!this.expanded);
      if (this.expanded) {
        this.removeContentHiddenClass();
      }
      if (this.animation) {
        this.animateContent();
        return;
      }
      if (!this.expanded) {
        this.addContentHiddenClass();
      }
      this.emitExpandCollapseEvent();
    }
  }
  /**
   * @hidden
   */
  get contentWrapperId() {
    return `k-expansion-panel-content-wrapper-${this.nextId}`;
  }
  /**
   * @hidden
   */
  get expanderIndicatorClasses() {
    if (this.expanded) {
      return !this.collapseIcon ? `chevron-up` : "";
    } else {
      return !this.expandIcon ? `chevron-down` : "";
    }
  }
  /**
   * @hidden
   */
  get customExpanderIndicatorClasses() {
    if (this.expanded) {
      return this.collapseIcon ? this.collapseIcon : "";
    } else {
      return this.expandIcon ? this.expandIcon : "";
    }
  }
  /**
   * @hidden
   */
  get expanderSvgIcon() {
    return this.expanded ? this.svgCollapseIcon : this.svgExpandIcon;
  }
  /**
   * Toggles the visibility of the ExpansionPanel
   * ([see example](slug:interaction_expansionpanel#toggling-between-states)).
   *
   * @param expanded Specifies whether the ExpansionPanel will be expanded or collapsed.
   */
  toggle(expanded) {
    const previous = this.expanded;
    const current = isPresent5(expanded) ? expanded : !previous;
    if (current === previous) {
      return;
    }
    this.setExpanded(current);
    if (this.expanded) {
      this.removeContentHiddenClass();
    }
    if (this.animation) {
      this.animateContent();
      return;
    }
    if (!this.expanded) {
      this.addContentHiddenClass();
    }
    this.emitExpandCollapseEvent();
  }
  focusExpansionPanel(el) {
    if (!this.focused) {
      this.focused = true;
      this.renderer.addClass(el, "k-focus");
    }
  }
  blurExpansionPanel(el) {
    if (this.focused) {
      this.focused = false;
      this.renderer.removeClass(el, "k-focus");
    }
  }
  setExpanded(value2) {
    this._expanded = value2;
    this.expandedChange.emit(value2);
  }
  animateContent() {
    const duration = typeof this.animation === "boolean" ? DEFAULT_DURATION : this.animation;
    const contentHeight = getComputedStyle(this.content.nativeElement).height;
    const animation = this.expanded ? expand(duration, contentHeight) : collapse(duration, contentHeight);
    const player = this.createPlayer(animation, this.content.nativeElement);
    this.animationEnd.pipe(take(1)).subscribe(() => {
      if (!this.expanded) {
        this.addContentHiddenClass();
      }
      this.emitExpandCollapseEvent();
    });
    player.play();
  }
  createPlayer(animation, animatedElement) {
    const factory = this.builder.build(animation);
    let player = factory.create(animatedElement);
    player.onDone(() => {
      if (player) {
        this.animationEnd.emit();
        player.destroy();
        player = null;
      }
    });
    return player;
  }
  emitExpandCollapseEvent() {
    this[this.expanded ? "expand" : "collapse"].emit();
  }
  addContentHiddenClass() {
    this.renderer.addClass(this.content.nativeElement, CONTENT_HIDDEN_CLASS);
  }
  removeContentHiddenClass() {
    this.renderer.removeClass(this.content.nativeElement, CONTENT_HIDDEN_CLASS);
  }
  static ɵfac = function ExpansionPanelComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ExpansionPanelComponent)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(AnimationBuilder));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ExpansionPanelComponent,
    selectors: [["kendo-expansionpanel"]],
    contentQueries: function ExpansionPanelComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, ExpansionPanelTitleDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.titleTemplate = _t.first);
      }
    },
    viewQuery: function ExpansionPanelComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c282, 7)(_c03, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.content = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.header = _t.first);
      }
    },
    hostVars: 5,
    hostBindings: function ExpansionPanelComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.direction);
        ɵɵclassProp("k-expander", ctx.hostClass)("k-expanded", ctx.expandedClass);
      }
    },
    inputs: {
      title: "title",
      subtitle: "subtitle",
      disabled: "disabled",
      expanded: "expanded",
      svgExpandIcon: "svgExpandIcon",
      svgCollapseIcon: "svgCollapseIcon",
      expandIcon: "expandIcon",
      collapseIcon: "collapseIcon",
      animation: "animation"
    },
    outputs: {
      expandedChange: "expandedChange",
      action: "action",
      expand: "expand",
      collapse: "collapse"
    },
    exportAs: ["kendoExpansionPanel"],
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.expansionpanel"
    }])],
    ngContentSelectors: _c82,
    decls: 10,
    vars: 14,
    consts: [["header", ""], ["content", ""], ["role", "button", "tabindex", "0", 3, "click"], [3, "ngTemplateOutlet"], [1, "k-expander-indicator"], [3, "name", "customFontClass", "svgIcon"], [1, "k-expander-content-wrapper", 3, "id"], [1, "k-expander-content"], [1, "k-expander-title"], [1, "k-spacer"], [1, "k-expander-sub-title"]],
    template: function ExpansionPanelComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵprojectionDef();
        ɵɵelementStart(0, "div", 2, 0);
        ɵɵlistener("click", function ExpansionPanelComponent_Template_div_click_0_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onHeaderClick($event));
        });
        ɵɵconditionalCreate(2, ExpansionPanelComponent_Conditional_2_Template, 3, 2);
        ɵɵconditionalCreate(3, ExpansionPanelComponent_Conditional_3_Template, 1, 1, null, 3);
        ɵɵelementStart(4, "span", 4);
        ɵɵelement(5, "kendo-icon-wrapper", 5);
        ɵɵelementEnd()();
        ɵɵelementStart(6, "div", 6, 1)(8, "div", 7);
        ɵɵprojection(9);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵclassProp("k-expander-header", true)("k-disabled", ctx.disabled);
        ɵɵattribute("aria-disabled", ctx.disabled)("aria-expanded", ctx.expanded && !ctx.disabled)("aria-controls", ctx.contentWrapperId);
        ɵɵadvance(2);
        ɵɵconditional(!ctx.titleTemplate ? 2 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.titleTemplate ? 3 : -1);
        ɵɵadvance(2);
        ɵɵproperty("name", ctx.expanderIndicatorClasses)("customFontClass", ctx.customExpanderIndicatorClasses)("svgIcon", ctx.expanderSvgIcon);
        ɵɵadvance();
        ɵɵproperty("id", ctx.contentWrapperId);
        ɵɵadvance(2);
        ɵɵattribute("aria-hidden", !ctx.expanded);
      }
    },
    dependencies: [NgTemplateOutlet, IconWrapperComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExpansionPanelComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoExpansionPanel",
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.expansionpanel"
      }],
      selector: "kendo-expansionpanel",
      template: `
        <div
          #header
          [class.k-expander-header]="true"
          [class.k-disabled]="disabled"
          [attr.aria-disabled]="disabled"
          [attr.aria-expanded]="expanded && !disabled"
          role="button"
          tabindex="0"
          [attr.aria-controls]="contentWrapperId"
          (click)="onHeaderClick($event)"
          >
          @if (!titleTemplate) {
            @if (title) {
              <div class="k-expander-title">{{ title }}</div>
            }
            <span class="k-spacer"></span>
            @if (subtitle) {
              <div class="k-expander-sub-title">
                {{ subtitle }}
              </div>
            }
          }
          @if (titleTemplate) {
            <ng-template
              [ngTemplateOutlet]="titleTemplate?.templateRef">
            </ng-template>
          }
          <span class="k-expander-indicator">
            <kendo-icon-wrapper
              [name]="expanderIndicatorClasses"
              [customFontClass]="customExpanderIndicatorClasses"
              [svgIcon]="expanderSvgIcon"
              >
            </kendo-icon-wrapper>
          </span>
        </div>
        <div #content [id]="contentWrapperId" class="k-expander-content-wrapper">
          <div class="k-expander-content" [attr.aria-hidden]="!expanded">
            <ng-content></ng-content>
          </div>
        </div>
        `,
      standalone: true,
      imports: [NgTemplateOutlet, IconWrapperComponent]
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: NgZone
  }, {
    type: LocalizationService
  }, {
    type: AnimationBuilder
  }], {
    title: [{
      type: Input
    }],
    subtitle: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    expanded: [{
      type: Input
    }],
    svgExpandIcon: [{
      type: Input
    }],
    svgCollapseIcon: [{
      type: Input
    }],
    expandIcon: [{
      type: Input
    }],
    collapseIcon: [{
      type: Input
    }],
    animation: [{
      type: Input
    }],
    expandedChange: [{
      type: Output
    }],
    action: [{
      type: Output
    }],
    expand: [{
      type: Output
    }],
    collapse: [{
      type: Output
    }],
    titleTemplate: [{
      type: ContentChild,
      args: [ExpansionPanelTitleDirective, {
        static: false
      }]
    }],
    content: [{
      type: ViewChild,
      args: ["content", {
        static: true
      }]
    }],
    header: [{
      type: ViewChild,
      args: ["header", {
        static: true
      }]
    }],
    hostClass: [{
      type: HostBinding,
      args: ["class.k-expander"]
    }],
    expandedClass: [{
      type: HostBinding,
      args: ["class.k-expanded"]
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }]
  });
})();
var idx = 0;
var getId = (prefix2) => {
  return `${prefix2}-${++idx}`;
};
var normalizeValue = (value2, max = Infinity) => {
  const normalizedValue = isPresent5(value2) ? Math.min(Math.max(+value2, 1), max) : value2;
  return normalizedValue;
};
var isRowItemPresent = (items) => {
  return items.some((item) => isPresent5(item.row));
};
var propsChanged = (initialProps, newProps) => {
  for (let i = 0; i < initialProps.length; i++) {
    if (initialProps[i] !== newProps[i]) {
      return true;
    }
  }
  return false;
};
var getDropTarget = (event) => {
  if (!(isDocumentAvailable() && isPresent5(document.elementsFromPoint))) {
    return [event.target];
  }
  return document.elementsFromPoint(event.clientX, event.clientY).filter((item) => item.classList && (item.classList.contains("k-tilelayout-item") || item.classList.contains("k-layout-item-hint")));
};
var setElementStyles = (renderer, elem, styles) => {
  const props = Object.keys(styles);
  props.forEach((p) => {
    renderer.setStyle(elem, p, styles[p]);
  });
};
var calculateCellFromPosition = (coordinates, tileLayoutElement, gap, cellSize, columns, rtl = false) => {
  const tileLayoutRect = tileLayoutElement.getBoundingClientRect();
  const totalRows = (tileLayoutRect.height - gap.rows) / (cellSize.height + gap.rows);
  const distanceFromTop = coordinates.y - tileLayoutRect.y;
  const distanceFromLeft = coordinates.x - tileLayoutRect.x;
  const distanceFromRight = tileLayoutRect.right - coordinates.x;
  const distanceToCellWidthRatio = Math.floor((rtl ? distanceFromRight : distanceFromLeft) / (gap.columns + cellSize.width));
  const cappedColumnPosition = Math.min(distanceToCellWidthRatio + 1, columns);
  const distanceToCellHeightRatio = Math.floor(distanceFromTop / (gap.rows + cellSize.height));
  const cappedRowPosition = Math.min(distanceToCellHeightRatio + 1, totalRows);
  const col = Math.max(cappedColumnPosition, 0);
  const row2 = Math.max(cappedRowPosition, 0);
  return {
    row: row2,
    col
  };
};
var shouldResize = (keyCode, col, selectedTile, settings) => {
  const resizeRight = keyCode === Keys.ArrowRight && col + selectedTile.colSpan <= settings.columns;
  const resizeLeft = keyCode === Keys.ArrowLeft && selectedTile.colSpan > 1;
  const resizeDown = keyCode === Keys.ArrowDown;
  const resizeUp = keyCode === Keys.ArrowUp && selectedTile.rowSpan > 1;
  return {
    resizeRight,
    resizeLeft,
    resizeDown,
    resizeUp
  };
};
var shouldReorder = (keyCode, col, selectedTile, settings) => {
  let reorderRight;
  let reorderLeft;
  if (selectedTile.col) {
    reorderRight = keyCode === Keys.ArrowRight && selectedTile.colSpan + col <= settings.columns;
    reorderLeft = keyCode === Keys.ArrowLeft && col > 1;
  } else {
    reorderRight = keyCode === Keys.ArrowRight && selectedTile.colSpan + selectedTile.order < settings.items.length;
    reorderLeft = keyCode === Keys.ArrowLeft && selectedTile.order > 0;
  }
  return {
    reorderLeft,
    reorderRight
  };
};
var getCurrentCol = (selectedTile, settings, rtl) => {
  const rects = selectedTile.elem.nativeElement.getBoundingClientRect();
  const targetSize = {
    rowSpan: selectedTile.rowSpan,
    colSpan: selectedTile.colSpan
  };
  const width2 = (rects.width - (targetSize.colSpan - 1) * settings.gap.columns) / targetSize.colSpan;
  const height2 = (rects.height - (targetSize.rowSpan - 1) * settings.gap.rows) / targetSize.rowSpan;
  const {
    col
  } = calculateCellFromPosition({
    x: rects.x,
    y: rects.y
  }, settings.tileLayoutElement, settings.gap, {
    width: width2,
    height: height2
  }, settings.columns, rtl);
  return col;
};
var RESIZE_HANDLE_UNIDIRECTIONAL_SIZE = 9;
var RESIZE_HANDLE_BIDIRECTIONAL_SIZE = 25;
var RESIZE_HANDLE_UNIDIRECTIONAL_OVERLAP = 5;
var RESIZE_HANDLE_BIDIRECTIONAL_OVERLAP = 18;
var DRAGGED_ZINDEX = 10;
var RESIZE_DIRECTIONS = ["ew", "ns", "nwse"];
var RTL_RESIZE_DIRECTIONS = ["ew", "ns", "nesw"];
var RESIZE_HANDLE_DIMENSIONS = {
  // numeric values represent pixels
  ew: {
    width: RESIZE_HANDLE_UNIDIRECTIONAL_SIZE,
    overlapX: RESIZE_HANDLE_UNIDIRECTIONAL_OVERLAP
  },
  ns: {
    height: RESIZE_HANDLE_UNIDIRECTIONAL_SIZE,
    overlapY: RESIZE_HANDLE_UNIDIRECTIONAL_OVERLAP
  },
  nwse: {
    width: RESIZE_HANDLE_BIDIRECTIONAL_SIZE,
    height: RESIZE_HANDLE_BIDIRECTIONAL_SIZE,
    overlapX: RESIZE_HANDLE_BIDIRECTIONAL_OVERLAP,
    overlapY: RESIZE_HANDLE_BIDIRECTIONAL_OVERLAP
  },
  nesw: {
    width: RESIZE_HANDLE_BIDIRECTIONAL_SIZE,
    height: RESIZE_HANDLE_BIDIRECTIONAL_SIZE,
    overlapX: RESIZE_HANDLE_BIDIRECTIONAL_OVERLAP,
    overlapY: RESIZE_HANDLE_BIDIRECTIONAL_OVERLAP
  }
};
var OVERLAP_THRESHOLD = 0.3;
var REVERSE_OVERLAP_THRESHOLD = -0.7;
var HINT_BORDERS_HEIGHT = 2;
var TileLayoutReorderEvent = class extends PreventableEvent {
  item;
  items;
  newIndex;
  oldIndex;
  newCol;
  oldCol;
  newRow;
  oldRow;
  /**
   * Constructs the event arguments for the `reorder` event.
   * @param item - The TileLayoutItem being reordered.
   * @param items - The TileLayoutItem collection that holds the currently rendered items and their internal state.
   * @param newIndex - The new order index of the reordered item used to determine its positioning relative to the other items.
   * @param oldIndex - The initial order index of the reordered item used to determine its positioning relative to the other items.
   * @param newCol - The new start column of the reordered item.
   * @param oldCol - The initial start column of the reordered item.
   * @param newRow - The new start row of the reordered item.
   * @param oldRow - The initial start row of the reordered item.
   * @hidden
   */
  constructor(item, items, newIndex, oldIndex, newCol, oldCol, newRow, oldRow) {
    super();
    this.item = item;
    this.items = items;
    this.newIndex = newIndex;
    this.oldIndex = oldIndex;
    this.newCol = newCol;
    this.oldCol = oldCol;
    this.newRow = newRow;
    this.oldRow = oldRow;
  }
};
var TileLayoutResizeEvent = class extends PreventableEvent {
  item;
  items;
  newRowSpan;
  oldRowSpan;
  newColSpan;
  oldColSpan;
  /**
   * Constructs the event arguments for the `resize` event.
   * @param item - The TileLayoutItem being resized
   * @param items - The TileLayoutItem collection
   * @param newRowSpan - The new rowSpan of the resized item
   * @param oldRowSpan - The initial rowSpan of the resized item
   * @param newColSpan - The new colSpan of the resized item
   * @param oldColSpan - The initial colSpan of the resized item
   * @hidden
   */
  constructor(item, items, newRowSpan, oldRowSpan, newColSpan, oldColSpan) {
    super();
    this.item = item;
    this.items = items;
    this.newRowSpan = newRowSpan;
    this.oldRowSpan = oldRowSpan;
    this.newColSpan = newColSpan;
    this.oldColSpan = oldColSpan;
  }
};
var TileLayoutDraggingService = class _TileLayoutDraggingService {
  zone;
  renderer;
  cdr;
  localization;
  reorderable = new BehaviorSubject(null);
  resizable = new BehaviorSubject(null);
  reorder = new Subject();
  resize = new Subject();
  tileLayoutSettings;
  get colStart() {
    return this.currentColStart;
  }
  get rowStart() {
    return this.currentRowStart;
  }
  get itemWrapper() {
    return this.draggedItemWrapper;
  }
  get order() {
    return this.targetOrder;
  }
  draggedItem;
  draggedItemWrapper;
  reordering;
  resizing;
  offset;
  targetSize;
  cellSize;
  targetOrder;
  currentColStart;
  currentRowStart;
  startingPoint;
  currentResizingColSpan;
  currentResizingRowSpan;
  direction;
  lastDragCursorOffset = {
    x: 0,
    y: 0
  };
  localizationSubscription;
  rtl;
  constructor(zone, renderer, cdr, localization) {
    this.zone = zone;
    this.renderer = renderer;
    this.cdr = cdr;
    this.localization = localization;
    this.localizationSubscription = this.localization.changes.subscribe(({
      rtl
    }) => this.rtl = rtl);
  }
  ngOnDestroy() {
    this.localizationSubscription.unsubscribe();
  }
  handlePress(originalEvent) {
    const resizing = !!originalEvent.target.classList.contains("k-resize-handle");
    const closestTile = closestInScope3(originalEvent.target, (el) => el.classList.contains("k-tilelayout-item"), this.tileLayoutSettings.tileLayoutElement);
    const closestHeader = closestInScope3(originalEvent.target, (el) => el.classList.contains("k-tilelayout-item-header"), this.tileLayoutSettings.tileLayoutElement);
    if (!closestTile) {
      return;
    }
    this.zone.run(() => {
      this.draggedItemWrapper = closestTile;
      this.draggedItem = this.tileLayoutSettings.items.find((item) => item.order === +closestTile.style.order);
    });
    const reordering = !resizing && this.reorderable.getValue() && this.draggedItem.reorderable && closestHeader;
    const focusableTarget = isFocusable2(originalEvent.target);
    if (!(reordering || resizing) || focusableTarget) {
      return;
    } else {
      originalEvent.preventDefault();
    }
    this.zone.run(() => {
      this.reordering = reordering;
      this.resizing = resizing;
    });
    const tileRect = this.draggedItemWrapper.getBoundingClientRect();
    this.zone.run(() => {
      this.offset = {
        top: originalEvent.clientY - tileRect.top,
        left: originalEvent.clientX - tileRect.left,
        x: tileRect.x,
        y: tileRect.y,
        width: tileRect.width,
        height: tileRect.height
      };
      this.targetSize = {
        rowSpan: this.draggedItem.rowSpan,
        colSpan: this.draggedItem.colSpan
      };
      this.cellSize = {
        width: (tileRect.width - (this.targetSize.colSpan - 1) * this.tileLayoutSettings.gap.columns) / this.targetSize.colSpan,
        height: (tileRect.height - (this.targetSize.rowSpan - 1) * this.tileLayoutSettings.gap.rows) / this.targetSize.rowSpan
      };
      this.lastDragCursorOffset = {
        x: originalEvent.clientX,
        y: originalEvent.clientY
      };
    });
    setElementStyles(this.renderer, this.draggedItemWrapper, {
      left: tileRect.left + window.pageXOffset - window.scrollX + "px",
      top: tileRect.top + window.pageYOffset - window.scrollY + "px",
      width: tileRect.width + "px",
      height: tileRect.height + "px",
      zIndex: DRAGGED_ZINDEX
    });
    setElementStyles(this.renderer, this.tileLayoutSettings.hintElement, {
      display: "flex",
      height: tileRect.height - HINT_BORDERS_HEIGHT + "px"
    });
    this.zone.run(() => this.targetOrder = this.draggedItem.order);
    this.cdr.markForCheck();
    setElementStyles(this.renderer, this.draggedItemWrapper, {
      position: "fixed"
    });
    if (this.reorderable.getValue() && !resizing) {
      this.zone.run(() => {
        this.currentColStart = this.draggedItem.colStart;
        this.currentRowStart = this.draggedItem.rowStart;
      });
      this.cdr.markForCheck();
    } else if (this.resizable && resizing) {
      this.zone.run(() => {
        this.startingPoint = {
          top: originalEvent.clientY,
          left: originalEvent.clientX
        };
        this.currentResizingColSpan = this.draggedItem.colSpan;
        this.currentResizingRowSpan = this.draggedItem.rowSpan;
        if (this.draggedItem.col) {
          this.currentColStart = this.draggedItem.col.toString();
        }
        if (this.draggedItem.row) {
          this.currentRowStart = this.draggedItem.row.toString();
        }
        this.direction = originalEvent.target.classList[1];
      });
    }
  }
  handleDrag(originalEvent) {
    if (this.draggedItemWrapper) {
      if (this.reordering) {
        this.reorderItems(originalEvent);
      } else if (this.resizing) {
        this.resizeItem(originalEvent);
      }
      this.lastDragCursorOffset = {
        x: originalEvent.clientX,
        y: originalEvent.clientY
      };
    }
  }
  handleRelease(originalEvent) {
    originalEvent.preventDefault();
    if (this.reordering) {
      const initialOrder = this.draggedItem.order;
      const initialCol = this.draggedItem.col;
      const initialRow = this.draggedItem.row;
      const targetCol = normalizeValue(this.currentColStart);
      const targetRow = normalizeValue(this.currentRowStart);
      if (propsChanged([this.targetOrder, targetCol, targetRow], [initialOrder, initialCol, initialRow])) {
        const reorderEvent = new TileLayoutReorderEvent(this.draggedItem, this.tileLayoutSettings.items, this.targetOrder, initialOrder, targetCol, initialCol, targetRow, initialRow);
        this.reorder.next(reorderEvent);
        if (!reorderEvent.isDefaultPrevented()) {
          if (this.targetOrder > initialOrder) {
            this.zone.run(() => {
              for (let i = initialOrder + 1; i <= this.targetOrder; i++) {
                const item = this.tileLayoutSettings.items.find((item2) => item2.order === i);
                item && (item.order = i - 1);
              }
            });
          } else {
            this.zone.run(() => {
              for (let i = initialOrder - 1; i >= this.targetOrder; i--) {
                const item = this.tileLayoutSettings.items.find((item2) => item2.order === i);
                item && (item.order = i + 1);
              }
            });
          }
          this.draggedItem.order = this.targetOrder;
          if (this.draggedItem.col) {
            this.draggedItem.col = +this.currentColStart;
          }
          if (this.draggedItem.row) {
            this.draggedItem.row = +this.currentRowStart;
          }
        }
      }
      this.tileLayoutSettings.tileLayoutElement.appendChild(this.tileLayoutSettings.hintElement);
      this.cdr.markForCheck();
      this.zone.run(() => this.cleanUp());
    } else if (!this.reordering && this.resizing) {
      const initialRowSpan = this.draggedItem.rowSpan;
      const initialColSpan = this.draggedItem.colSpan;
      const {
        targetColSpan,
        targetRowSpan
      } = isRowItemPresent(this.tileLayoutSettings.items) ? this.targetSpan() : {
        targetColSpan: this.currentResizingColSpan,
        targetRowSpan: this.currentResizingRowSpan
      };
      if (propsChanged([initialRowSpan, initialColSpan], [targetRowSpan, targetColSpan])) {
        const resizeEvent = new TileLayoutResizeEvent(this.draggedItem, this.tileLayoutSettings.items, targetRowSpan, initialRowSpan, targetColSpan, initialColSpan);
        this.resize.next(resizeEvent);
        if (!resizeEvent.isDefaultPrevented()) {
          this.draggedItem.colSpan = this.currentResizingColSpan;
          this.draggedItem.rowSpan = this.currentResizingRowSpan;
        }
      }
      this.zone.run(() => this.cleanUp());
    }
  }
  reorderItems(event) {
    const targets = getDropTarget(event);
    const closestTile = targets.find((t) => t !== this.draggedItemWrapper);
    const tileOrder = closestTile ? +closestTile.style.order : +this.draggedItemWrapper.style.order;
    if (this.tileLayoutSettings.autoFlow !== "none") {
      const deltaX = event.clientX - this.lastDragCursorOffset.x;
      const deltaY = event.clientY - this.lastDragCursorOffset.y;
      const directionX = deltaX > 0 ? "right" : deltaX < 0 ? "left" : void 0;
      const directionY = deltaY > 0 ? "down" : deltaX < 0 ? "up" : void 0;
      const rect = this.draggedItemWrapper.getBoundingClientRect();
      const horizontalGap = this.tileLayoutSettings.gap.columns;
      const verticalGap = this.tileLayoutSettings.gap.rows;
      if (directionX && this.draggedItem.col) {
        const {
          col
        } = calculateCellFromPosition({
          x: directionX === "right" ? rect.right - horizontalGap : rect.left + horizontalGap,
          y: event.clientY
        }, this.tileLayoutSettings.tileLayoutElement, this.tileLayoutSettings.gap, this.cellSize, this.tileLayoutSettings.columns, this.rtl);
        const targetStartCol = this.getTargetCol(col, directionX);
        this.currentColStart = targetStartCol.toString();
      }
      if (directionY && this.draggedItem.row) {
        const {
          row: row2
        } = calculateCellFromPosition({
          x: event.clientX,
          y: directionY === "down" ? rect.bottom - verticalGap : rect.top + verticalGap
        }, this.tileLayoutSettings.tileLayoutElement, this.tileLayoutSettings.gap, this.cellSize, this.tileLayoutSettings.columns, this.rtl);
        const targetStartRow = this.getTargetRow(row2, directionY);
        this.currentRowStart = targetStartRow.toString();
      }
    }
    const hintBefore = tileOrder < this.targetOrder;
    const hintAfter = tileOrder > this.targetOrder;
    this.zone.run(() => this.targetOrder = tileOrder);
    if (hintBefore) {
      this.tileLayoutSettings.tileLayoutElement.insertBefore(this.tileLayoutSettings.hintElement, this.tileLayoutSettings.tileLayoutElement.firstChild);
    } else if (hintAfter) {
      this.tileLayoutSettings.tileLayoutElement.appendChild(this.tileLayoutSettings.hintElement);
    }
    setElementStyles(this.renderer, this.draggedItemWrapper, {
      top: event.pageY - this.offset.top - window.scrollY + "px",
      left: event.pageX - this.offset.left - window.scrollX + "px"
    });
    this.cdr.markForCheck();
  }
  resizeItem(event) {
    setElementStyles(this.renderer, this.tileLayoutSettings.tileLayoutElement, {
      cursor: this.direction.split("k-cursor-")[1]
    });
    const currentWidth = this.rtl ? this.offset.width + (this.offset.x - event.clientX) : this.offset.width + (event.clientX - this.startingPoint.left);
    const currentHeight = this.offset.height + (event.clientY - this.startingPoint.top);
    const hintRect = this.tileLayoutSettings.hintElement.getBoundingClientRect();
    const hintWidth = hintRect.width;
    const hintHeight = hintRect.height;
    const horizontalDragDirection = event.clientX - this.lastDragCursorOffset.x;
    const verticalDragDirection = event.clientY - this.lastDragCursorOffset.y;
    const startCol = this.draggedItem.col ? this.draggedItem.col : calculateCellFromPosition({
      x: this.rtl ? hintRect.right : hintRect.x,
      y: hintRect.y
    }, this.tileLayoutSettings.tileLayoutElement, this.tileLayoutSettings.gap, this.cellSize, this.tileLayoutSettings.columns, this.rtl).col;
    const maxWidth = (this.tileLayoutSettings.columns - startCol) * (this.cellSize.width + this.tileLayoutSettings.gap.columns) + this.cellSize.width;
    const resizeHorizontally = () => {
      setElementStyles(this.renderer, this.draggedItemWrapper, {
        width: Math.min(Math.max(currentWidth, this.cellSize.width), maxWidth) + "px"
      });
      if (this.rtl && currentWidth > this.cellSize.width) {
        const totalWidth = this.tileLayoutSettings.columns * (this.cellSize.width + this.tileLayoutSettings.gap.columns);
        const leftBoundary = this.tileLayoutSettings.tileLayoutElement.getBoundingClientRect().right - totalWidth;
        setElementStyles(this.renderer, this.draggedItemWrapper, {
          left: Math.max(event.clientX, leftBoundary) + "px"
        });
      }
      const deltaX = currentWidth - hintWidth;
      const {
        x,
        y,
        right: right2
      } = this.draggedItem.elem.nativeElement.getBoundingClientRect();
      const {
        col
      } = calculateCellFromPosition({
        x: this.rtl ? right2 : x,
        y
      }, this.tileLayoutSettings.tileLayoutElement, this.tileLayoutSettings.gap, this.cellSize, this.tileLayoutSettings.columns, this.rtl);
      const resizedColSpan = col + this.currentResizingColSpan;
      const expandingCondition = this.rtl ? horizontalDragDirection < 0 : horizontalDragDirection > 0;
      const shrinkingCondition = this.rtl ? horizontalDragDirection > 0 : horizontalDragDirection < 0;
      if (deltaX > OVERLAP_THRESHOLD * this.cellSize.width && expandingCondition && resizedColSpan <= this.tileLayoutSettings.columns) {
        this.currentResizingColSpan++;
      } else if (this.currentResizingColSpan > 1 && shrinkingCondition && deltaX < REVERSE_OVERLAP_THRESHOLD * this.cellSize.width) {
        this.currentResizingColSpan--;
      }
      setElementStyles(this.renderer, this.tileLayoutSettings.hintElement, {
        gridColumnEnd: `span ${this.currentResizingColSpan}`
      });
    };
    const resizeVertically = () => {
      setElementStyles(this.renderer, this.draggedItemWrapper, {
        height: Math.max(currentHeight, this.cellSize.height) + "px"
      });
      const deltaY = currentHeight - hintHeight;
      if (deltaY > OVERLAP_THRESHOLD * this.cellSize.height && verticalDragDirection > 0) {
        this.currentResizingRowSpan++;
      } else if (this.currentResizingRowSpan > 1 && verticalDragDirection < 0 && deltaY < REVERSE_OVERLAP_THRESHOLD * this.cellSize.height) {
        this.currentResizingRowSpan--;
      }
      setElementStyles(this.renderer, this.tileLayoutSettings.hintElement, {
        gridRowEnd: `span ${this.currentResizingRowSpan}`
      });
      setElementStyles(this.renderer, this.tileLayoutSettings.hintElement, {
        height: `${this.calculateHintHeight()}px`
      });
    };
    if (this.direction.indexOf("ew") > -1) {
      resizeHorizontally();
    } else if (this.direction.indexOf("ns") > -1) {
      resizeVertically();
    } else {
      resizeHorizontally();
      resizeVertically();
    }
  }
  cleanUp() {
    this.targetOrder = this.currentResizingColSpan = this.currentColStart = this.currentResizingRowSpan = this.currentRowStart = void 0;
    this.resizing = this.reordering = false;
    this.direction = null;
    if (this.draggedItemWrapper) {
      setElementStyles(this.renderer, this.draggedItemWrapper, {
        top: "",
        left: "",
        display: "",
        width: "",
        height: "",
        zIndex: "",
        position: ""
      });
      setElementStyles(this.renderer, this.tileLayoutSettings.hintElement, {
        display: "none",
        height: "auto"
      });
      setElementStyles(this.renderer, this.tileLayoutSettings.tileLayoutElement, {
        cursor: "default"
      });
      this.draggedItemWrapper = this.offset = this.draggedItem = this.resizing = this.reordering = this.currentResizingColSpan = this.currentResizingRowSpan = this.startingPoint = void 0;
      this.lastDragCursorOffset = {
        x: 0,
        y: 0
      };
    }
  }
  targetSpan() {
    const itemRect = this.draggedItem.elem.nativeElement.getBoundingClientRect();
    const startingCell = calculateCellFromPosition({
      x: this.rtl ? itemRect.right : itemRect.x,
      y: itemRect.y
    }, this.tileLayoutSettings.tileLayoutElement, this.tileLayoutSettings.gap, this.cellSize, this.tileLayoutSettings.columns, this.rtl);
    const targetEndCell = calculateCellFromPosition({
      x: this.rtl ? itemRect.x + OVERLAP_THRESHOLD * this.cellSize.width : itemRect.right - OVERLAP_THRESHOLD * this.cellSize.width,
      y: itemRect.bottom - OVERLAP_THRESHOLD * this.cellSize.height
    }, this.tileLayoutSettings.tileLayoutElement, this.tileLayoutSettings.gap, this.cellSize, this.tileLayoutSettings.columns, this.rtl);
    return {
      targetColSpan: targetEndCell.col - startingCell.col + 1,
      targetRowSpan: targetEndCell.row - startingCell.row + 1
    };
  }
  getTargetCol(col, direction) {
    if (this.rtl) {
      return normalizeValue(direction === "left" ? col - this.draggedItem.colSpan + 1 : col, this.tileLayoutSettings.columns);
    }
    return normalizeValue(direction === "right" ? col - this.draggedItem.colSpan + 1 : col);
  }
  getTargetRow(row2, direction) {
    return direction === "down" ? row2 - this.draggedItem.rowSpan + 1 : row2;
  }
  calculateHintHeight() {
    const totalHintCellsHeight = this.currentResizingRowSpan * this.cellSize.height;
    const totalHintGapsHeight = (this.currentResizingRowSpan - 1) * this.tileLayoutSettings.gap.rows;
    const hintHeight = totalHintCellsHeight + totalHintGapsHeight - HINT_BORDERS_HEIGHT;
    return hintHeight;
  }
  static ɵfac = function TileLayoutDraggingService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TileLayoutDraggingService)(ɵɵinject(NgZone), ɵɵinject(Renderer2), ɵɵinject(ChangeDetectorRef), ɵɵinject(LocalizationService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _TileLayoutDraggingService,
    factory: _TileLayoutDraggingService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TileLayoutDraggingService, [{
    type: Injectable
  }], () => [{
    type: NgZone
  }, {
    type: Renderer2
  }, {
    type: ChangeDetectorRef
  }, {
    type: LocalizationService
  }], null);
})();
var TileLayoutKeyboardNavigationService = class _TileLayoutKeyboardNavigationService {
  zone;
  renderer;
  localization;
  navigable = new BehaviorSubject(true);
  owner;
  mousedown;
  localizationSubscription;
  rtl;
  lastFocused;
  constructor(zone, renderer, localization) {
    this.zone = zone;
    this.renderer = renderer;
    this.localization = localization;
    this.localizationSubscription = this.localization.changes.subscribe(({
      rtl
    }) => this.rtl = rtl);
  }
  ngOnDestroy() {
    this.localizationSubscription.unsubscribe();
  }
  onKeyDown(event, elem, focusableItems, settings) {
    const keyCode = normalizeKeys(event);
    const isTileFocused = document.activeElement === elem;
    const focusedTile = settings.items.find((item) => item.elem.nativeElement === elem);
    const col = getCurrentCol(focusedTile, settings, this.rtl);
    const isArrow = [Keys.ArrowLeft, Keys.ArrowRight, Keys.ArrowDown, Keys.ArrowUp].some((key) => key === keyCode);
    this.lastFocused = focusedTile;
    if (keyCode === Keys.Enter && isTileFocused && focusableItems.length > 0) {
      this.changeTabIndex("0", elem, focusableItems);
      focusableItems[0].focus();
    } else if (keyCode === Keys.Escape) {
      this.changeTabIndex("-1", elem, focusableItems);
      elem.focus();
    } else if (isArrow && (event.ctrlKey || event.metaKey) && isTileFocused && focusedTile.isResizable) {
      event.preventDefault();
      this.zone.run(() => {
        this.resizeItem(keyCode, focusedTile, settings, col);
      });
    } else if (isArrow && event.shiftKey && isTileFocused && focusedTile.isReorderable) {
      this.zone.run(() => {
        this.reorderItem(keyCode, focusedTile, settings, col);
      });
    } else if (keyCode === Keys.Tab) {
      if (!isTileFocused) {
        this.keepFocusWithinComponent(event, elem);
      } else {
        const dir = event.shiftKey ? -1 : 1;
        const nextFocusableTileOrder = focusedTile.order + dir;
        if (nextFocusableTileOrder < 0 || nextFocusableTileOrder >= settings.items.length) {
          const first = settings.items[0];
          const last4 = settings.items[settings.items.length - 1];
          if (dir > 0) {
            last4.focus();
          } else {
            first.focus();
          }
          return;
        }
        event.preventDefault();
        this.lastFocused = settings.items.find((item) => item.order === nextFocusableTileOrder);
        this.lastFocused?.focus();
      }
    }
  }
  onFocusOut(event, elem, focusableItems) {
    const isTargetFocusable = focusableItems.includes(event.target);
    const isRelatedTargetFocusable = focusableItems.includes(event.relatedTarget);
    if (isTargetFocusable && !isRelatedTargetFocusable) {
      this.changeTabIndex("-1", elem, focusableItems);
      event.relatedTarget?.focus();
    }
  }
  onMousedown(event, elem, focusableItems, tile) {
    this.mousedown = true;
    const isTargetFocusable = focusableItems.includes(event.target);
    this.lastFocused = tile;
    if (isTargetFocusable) {
      this.changeTabIndex("0", elem, focusableItems);
      event.target.focus();
    }
  }
  changeTabIndex(tabIndex, elem, focusableItems) {
    this.renderer.setAttribute(elem, "tabindex", tabIndex === "0" ? "-1" : "0");
    focusableItems.forEach((focusItem) => {
      this.renderer.setAttribute(focusItem, "tabindex", tabIndex);
    });
  }
  getAllFocusableChildren(parent) {
    return Array.from(parent.querySelectorAll(focusableSelector)).filter((element) => element.offsetParent !== null);
  }
  returnFocus() {
    this.lastFocused ? this.lastFocused.focus() : this.owner.items.find((item) => item.order === 0).focus();
  }
  resizeItem(keyCode, focusedTile, settings, col) {
    const {
      resizeRight,
      resizeLeft,
      resizeDown,
      resizeUp
    } = shouldResize(keyCode, col, focusedTile, settings);
    const resizeHorizontal = resizeLeft || resizeRight;
    const resizeVertical = resizeDown || resizeUp;
    const resizeDir = resizeLeft || resizeUp ? -1 : 1;
    if (!(resizeHorizontal || resizeVertical)) {
      return;
    }
    const resizeEvent = new TileLayoutResizeEvent(focusedTile, this.owner.items ? this.owner.items.toArray() : [], focusedTile.rowSpan + resizeDir, focusedTile.rowSpan, focusedTile.colSpan + resizeDir, focusedTile.colSpan);
    this.owner.resize.emit(resizeEvent);
    if (!resizeEvent.isDefaultPrevented()) {
      if (resizeHorizontal) {
        focusedTile.colSpan += resizeDir;
      } else if (resizeVertical) {
        focusedTile.rowSpan += resizeDir;
      }
    }
  }
  reorderItem(keyCode, focusedTile, settings, col) {
    const {
      reorderLeft,
      reorderRight
    } = shouldReorder(keyCode, col, focusedTile, settings);
    if (!(reorderLeft || reorderRight)) {
      return;
    }
    const reorder = (dir) => {
      const relatedTile = this.targetTile(focusedTile, settings.items, dir);
      if (relatedTile) {
        relatedTile.order -= dir;
        if (relatedTile.col) {
          relatedTile.col -= dir;
        }
        focusedTile.order += dir;
        if (focusedTile.col) {
          focusedTile.col += dir;
        }
      }
    };
    const reorderDir = reorderRight ? 1 : -1;
    const reorderEvent = new TileLayoutReorderEvent(focusedTile, this.owner.items ? this.owner.items.toArray() : [], focusedTile.order + reorderDir, focusedTile.order, focusedTile.col ? focusedTile.col + reorderDir : void 0, focusedTile.col, focusedTile.row, focusedTile.row);
    this.owner.reorder.next(reorderEvent);
    if (!reorderEvent.isDefaultPrevented()) {
      reorder(reorderDir);
    }
  }
  keepFocusWithinComponent(event, wrapper) {
    const [firstFocusable, lastFocusable] = this.getFirstAndLastFocusable(wrapper);
    const tabAfterLastFocusable = !event.shiftKey && event.target === lastFocusable;
    const shiftTabAfterFirstFocusable = event.shiftKey && event.target === firstFocusable;
    if (tabAfterLastFocusable) {
      event.preventDefault();
      firstFocusable.focus();
      wrapper.blur();
    }
    if (shiftTabAfterFirstFocusable) {
      event.preventDefault();
      lastFocusable.focus();
    }
  }
  getFirstAndLastFocusable(parent) {
    const all = this.getAllFocusableChildren(parent);
    const firstFocusable = all.length > 0 ? all[0] : parent;
    const lastFocusable = all.length > 0 ? all[all.length - 1] : parent;
    return [firstFocusable, lastFocusable];
  }
  targetTile(focusedTile, items, offset3) {
    return items.find((item) => item.order === focusedTile.order + offset3);
  }
  static ɵfac = function TileLayoutKeyboardNavigationService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TileLayoutKeyboardNavigationService)(ɵɵinject(NgZone), ɵɵinject(Renderer2), ɵɵinject(LocalizationService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _TileLayoutKeyboardNavigationService,
    factory: _TileLayoutKeyboardNavigationService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TileLayoutKeyboardNavigationService, [{
    type: Injectable
  }], () => [{
    type: NgZone
  }, {
    type: Renderer2
  }, {
    type: LocalizationService
  }], null);
})();
var TileLayoutItemHeaderComponent = class _TileLayoutItemHeaderComponent {
  hostClass = true;
  static ɵfac = function TileLayoutItemHeaderComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TileLayoutItemHeaderComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TileLayoutItemHeaderComponent,
    selectors: [["kendo-tilelayout-item-header"]],
    hostVars: 4,
    hostBindings: function TileLayoutItemHeaderComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-tilelayout-item-header", ctx.hostClass)("k-card-header", ctx.hostClass);
      }
    },
    ngContentSelectors: _c82,
    decls: 1,
    vars: 0,
    template: function TileLayoutItemHeaderComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TileLayoutItemHeaderComponent, [{
    type: Component,
    args: [{
      selector: "kendo-tilelayout-item-header",
      template: `
        <ng-content></ng-content>
    `,
      standalone: true
    }]
  }], null, {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-tilelayout-item-header"]
    }, {
      type: HostBinding,
      args: ["class.k-card-header"]
    }]
  });
})();
var TileLayoutResizeHandleDirective = class _TileLayoutResizeHandleDirective {
  el;
  renderer;
  resizeDirection;
  rtl;
  constructor(el, renderer) {
    this.el = el;
    this.renderer = renderer;
  }
  ngOnInit() {
    this.sizeHandle();
  }
  setHorizontalPosition(element) {
    this.renderer.setStyle(element, this.rtl ? "left" : "right", -RESIZE_HANDLE_DIMENSIONS[this.resizeDirection].overlapX + "px");
  }
  setBottom(element) {
    this.renderer.setStyle(element, "bottom", -RESIZE_HANDLE_DIMENSIONS[this.resizeDirection].overlapY + "px");
  }
  sizeHandle() {
    const element = this.el.nativeElement;
    const handleWidth = RESIZE_HANDLE_DIMENSIONS[this.resizeDirection].width ? `${RESIZE_HANDLE_DIMENSIONS[this.resizeDirection].width}px` : "100%";
    const handleHeight = RESIZE_HANDLE_DIMENSIONS[this.resizeDirection].height ? `${RESIZE_HANDLE_DIMENSIONS[this.resizeDirection].height}px` : "100%";
    this.renderer.setStyle(element, "width", handleWidth);
    this.renderer.setStyle(element, "height", handleHeight);
    if (this.resizeDirection === "ew") {
      this.setHorizontalPosition(element);
    } else if (this.resizeDirection === "ns") {
      this.setBottom(element);
    } else {
      this.setHorizontalPosition(element);
      this.setBottom(element);
    }
  }
  static ɵfac = function TileLayoutResizeHandleDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TileLayoutResizeHandleDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _TileLayoutResizeHandleDirective,
    selectors: [["", "kendoTileLayoutResizeHandle", ""]],
    inputs: {
      resizeDirection: "resizeDirection",
      rtl: "rtl"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TileLayoutResizeHandleDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoTileLayoutResizeHandle]",
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }], {
    resizeDirection: [{
      type: Input
    }],
    rtl: [{
      type: Input
    }]
  });
})();
var TileLayoutItemComponent = class _TileLayoutItemComponent {
  elem;
  zone;
  renderer;
  localization;
  draggingService;
  keyboardNavigationService;
  /**
   * Sets the title text that appears in the item header ([see example]({% slug tiles_tilelayout %}#toc-tiles-configuration)).
   */
  title;
  /**
   * Sets how many rows the tile item spans ([see example](slug:resizing_tilelayout#programmatic-resizing)).
   * @default 1
   */
  rowSpan = 1;
  /**
   *  Sets how many columns the tile item spans ([see example](slug:resizing_tilelayout#programmatic-resizing)).
   * @default 1
   */
  colSpan = 1;
  /**
   * Sets the order of the tile item within the TileLayout.
   * When not set, items receive increasing order values based on their DOM position.
   */
  set order(value2) {
    this._order = value2;
    this.renderer.setStyle(this.elem.nativeElement, "order", `${this._order}`);
  }
  get order() {
    return this._order;
  }
  /**
   * Sets the starting column position of the item ([see example](slug:tiles_tilelayout#size-and-position)).
   */
  col;
  /**
   * Sets the starting row position of the item ([see example](slug:tiles_tilelayout#size-and-position)).
   */
  row;
  /**
   * Enables or disables individual item reordering.
   *
   * @default true
   */
  reorderable = true;
  /**
   * Enables or disables individual item resizing.
   * @default true
   */
  resizable = true;
  itemClass = true;
  hostRole = "listitem";
  get hostDropEffect() {
    return this.isResizable || this.isReorderable ? "execute" : void 0;
  }
  get hostTabindex() {
    return this.isNavigable ? "0" : void 0;
  }
  get ariaKeyShortcuts() {
    return this.isNavigable ? "Enter" : void 0;
  }
  get hostGrabbed() {
    return this.isResizable || this.isReorderable;
  }
  get hostLabelledBy() {
    return this.title ? this.titleId : void 0;
  }
  get colEnd() {
    return `span ${this.colSpan}`;
  }
  get rowEnd() {
    return `span ${this.rowSpan}`;
  }
  get colStart() {
    return isPresent5(this.col) ? this.col.toString() : void 0;
  }
  get rowStart() {
    return isPresent5(this.row) ? this.row.toString() : void 0;
  }
  /**
   * @hidden
   */
  get isReorderable() {
    return this.reorderable && this.draggingService.reorderable.getValue();
  }
  /**
   * @hidden
   */
  get isNavigable() {
    return this.keyboardNavigationService.navigable.getValue();
  }
  /**
   * @hidden
   */
  get isResizable() {
    return this.resizable && this.draggingService.resizable.getValue();
  }
  /**
   * @hidden
   */
  resizeDirections;
  /**
   * @hidden
   */
  rtl;
  headers;
  /**
   * @hidden
   */
  titleId = "";
  subs = new Subscription();
  keyboardNavigationSubs;
  focusableItems;
  _order;
  constructor(elem, zone, renderer, localization, draggingService, keyboardNavigationService) {
    this.elem = elem;
    this.zone = zone;
    this.renderer = renderer;
    this.localization = localization;
    this.draggingService = draggingService;
    this.keyboardNavigationService = keyboardNavigationService;
    this.subs.add(this.localization.changes.subscribe(({
      rtl
    }) => {
      this.rtl = rtl;
    }));
    this.subs.add(this.draggingService.resizable.subscribe((resizable) => {
      this.resizeDirections = resizable && this.resizable ? this.rtl ? RTL_RESIZE_DIRECTIONS : RESIZE_DIRECTIONS : void 0;
    }));
    this.titleId = getId("k-tilelayout-title");
  }
  ngAfterViewInit() {
    const elem = this.elem.nativeElement;
    const keyboardNavigation = this.keyboardNavigationService;
    this.subs.add(this.draggingService.reorderable.subscribe((reorderable2) => {
      this.toggleCursorClass(reorderable2 && this.reorderable);
    }));
    this.subs.add(keyboardNavigation.navigable.subscribe((isNavigable2) => {
      if (isNavigable2) {
        this.keyboardNavigationSubs = new Subscription();
        this.focusableItems = keyboardNavigation.getAllFocusableChildren(elem);
        this.zone.runOutsideAngular(() => {
          keyboardNavigation.changeTabIndex("-1", elem, this.focusableItems);
          this.keyboardNavigationSubs.add(this.renderer.listen(elem, "keydown", (event) => keyboardNavigation.onKeyDown(event, elem, this.focusableItems, this.draggingService.tileLayoutSettings)));
          this.keyboardNavigationSubs.add(this.renderer.listen(elem, "mousedown", (event) => keyboardNavigation.onMousedown(event, elem, this.focusableItems, this)));
          this.keyboardNavigationSubs.add(this.renderer.listen(elem, "focusout", (event) => keyboardNavigation.onFocusOut(event, elem, this.focusableItems)));
        });
      } else if (this.focusableItems) {
        this.focusableItems.forEach((focusItem) => {
          this.renderer.setAttribute(focusItem, "tabindex", "0");
        });
        this.keyboardNavigationSubs.unsubscribe();
      }
    }));
  }
  ngOnChanges(changes) {
    if (changes["reorderable"] && !changes["reorderable"].firstChange) {
      this.toggleCursorClass(changes["reorderable"].currentValue && this.draggingService.reorderable.getValue());
    }
    if (changes["resizable"]) {
      this.resizeDirections = this.resizable && this.draggingService.resizable.getValue() ? this.rtl ? RTL_RESIZE_DIRECTIONS : RESIZE_DIRECTIONS : void 0;
    }
  }
  ngOnDestroy() {
    this.subs.unsubscribe();
    if (this.keyboardNavigationSubs) {
      this.keyboardNavigationSubs.unsubscribe();
    }
  }
  /**
   * @hidden
   */
  focus() {
    this.elem.nativeElement.focus();
  }
  toggleCursorClass(isReorderable) {
    const headerEl = this.elem.nativeElement.querySelector(".k-tilelayout-item-header");
    if (!headerEl) {
      return;
    }
    if (isReorderable) {
      this.renderer.addClass(headerEl, "k-cursor-move");
    } else {
      this.renderer.removeClass(headerEl, "k-cursor-move");
    }
  }
  static ɵfac = function TileLayoutItemComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TileLayoutItemComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(TileLayoutDraggingService), ɵɵdirectiveInject(TileLayoutKeyboardNavigationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TileLayoutItemComponent,
    selectors: [["kendo-tilelayout-item"]],
    contentQueries: function TileLayoutItemComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, TileLayoutItemHeaderComponent, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headers = _t);
      }
    },
    hostVars: 18,
    hostBindings: function TileLayoutItemComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("role", ctx.hostRole)("aria-dropeffect", ctx.hostDropEffect)("tabindex", ctx.hostTabindex)("aria-keyshortcuts", ctx.ariaKeyShortcuts)("aria-grabbed", ctx.hostGrabbed)("aria-labelledby", ctx.hostLabelledBy);
        ɵɵstyleProp("grid-column-end", ctx.colEnd)("grid-row-end", ctx.rowEnd)("grid-column-start", ctx.colStart)("grid-row-start", ctx.rowStart);
        ɵɵclassProp("k-tilelayout-item", ctx.itemClass)("k-card", ctx.itemClass);
      }
    },
    inputs: {
      title: "title",
      rowSpan: "rowSpan",
      colSpan: "colSpan",
      order: "order",
      col: "col",
      row: "row",
      reorderable: "reorderable",
      resizable: "resizable"
    },
    features: [ɵɵNgOnChangesFeature],
    ngContentSelectors: _c82,
    decls: 3,
    vars: 2,
    consts: [[1, "k-card-title", 3, "id"], ["kendoTileLayoutResizeHandle", "", 3, "class", "rtl", "resizeDirection"], ["kendoTileLayoutResizeHandle", "", 3, "rtl", "resizeDirection"]],
    template: function TileLayoutItemComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵconditionalCreate(0, TileLayoutItemComponent_Conditional_0_Template, 3, 2, "kendo-tilelayout-item-header");
        ɵɵprojection(1);
        ɵɵconditionalCreate(2, TileLayoutItemComponent_Conditional_2_Template, 2, 0);
      }
      if (rf & 2) {
        ɵɵconditional(ctx.title ? 0 : -1);
        ɵɵadvance(2);
        ɵɵconditional(ctx.resizable ? 2 : -1);
      }
    },
    dependencies: [TileLayoutItemHeaderComponent, TileLayoutResizeHandleDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TileLayoutItemComponent, [{
    type: Component,
    args: [{
      selector: "kendo-tilelayout-item",
      template: `
        @if (title) {
          <kendo-tilelayout-item-header>
            <h5 [id]="titleId" class="k-card-title">{{ title }}</h5>
          </kendo-tilelayout-item-header>
        }
        <ng-content></ng-content>
        @if (resizable) {
          @for (dir of resizeDirections; track dir) {
            <div
              class="k-resize-handle k-cursor-{{dir}}-resize"
              kendoTileLayoutResizeHandle
              [rtl]="rtl"
              [resizeDirection]="dir">
            </div>
          }
        }
        `,
      standalone: true,
      imports: [TileLayoutItemHeaderComponent, TileLayoutResizeHandleDirective]
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NgZone
  }, {
    type: Renderer2
  }, {
    type: LocalizationService
  }, {
    type: TileLayoutDraggingService
  }, {
    type: TileLayoutKeyboardNavigationService
  }], {
    title: [{
      type: Input
    }],
    rowSpan: [{
      type: Input
    }],
    colSpan: [{
      type: Input
    }],
    order: [{
      type: Input
    }],
    col: [{
      type: Input
    }],
    row: [{
      type: Input
    }],
    reorderable: [{
      type: Input
    }],
    resizable: [{
      type: Input
    }],
    itemClass: [{
      type: HostBinding,
      args: ["class.k-tilelayout-item"]
    }, {
      type: HostBinding,
      args: ["class.k-card"]
    }],
    hostRole: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    hostDropEffect: [{
      type: HostBinding,
      args: ["attr.aria-dropeffect"]
    }],
    hostTabindex: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    ariaKeyShortcuts: [{
      type: HostBinding,
      args: ["attr.aria-keyshortcuts"]
    }],
    hostGrabbed: [{
      type: HostBinding,
      args: ["attr.aria-grabbed"]
    }],
    hostLabelledBy: [{
      type: HostBinding,
      args: ["attr.aria-labelledby"]
    }],
    colEnd: [{
      type: HostBinding,
      args: ["style.grid-column-end"]
    }],
    rowEnd: [{
      type: HostBinding,
      args: ["style.grid-row-end"]
    }],
    colStart: [{
      type: HostBinding,
      args: ["style.grid-column-start"]
    }],
    rowStart: [{
      type: HostBinding,
      args: ["style.grid-row-start"]
    }],
    headers: [{
      type: ContentChildren,
      args: [TileLayoutItemHeaderComponent]
    }]
  });
})();
var autoFlowClasses = {
  column: "k-grid-flow-col",
  row: "k-grid-flow-row",
  "column-dense": "k-grid-flow-col-dense",
  "row-dense": "k-grid-flow-row-dense"
};
var TileLayoutComponent = class _TileLayoutComponent {
  zone;
  elem;
  renderer;
  localization;
  draggingService;
  navigationService;
  /**
   * Specifies the number of columns ([see example](slug:tiles_tilelayout#size-and-position)).
   * @default 1
   */
  columns = 1;
  /**
   * Sets the width of the columns.
   * Use numeric values for pixels or string values for other CSS units ([see example](slug:tiles_tilelayout#size-and-position)).
   * @default '1fr'
   */
  columnWidth = "1fr";
  /**
   * Sets the spacing between layout items in pixels.
   * Use an object with `rows` and `columns` properties to set different horizontal and vertical spacing.
   * Use a single number to apply the same spacing to both directions.
   *
   * @default { rows: 16, columns: 16 }
   */
  set gap(value2) {
    this._gap = typeof value2 === "number" ? {
      rows: value2,
      columns: value2
    } : Object.assign(this._gap, value2);
  }
  get gap() {
    return this._gap;
  }
  /**
   * Enables or disables item reordering ([see example]({% slug reordering_tilelayout %})).
   * @default false
   */
  reorderable = false;
  /**
   * Enables or disables item resizing ([see example]({% slug resizing_tilelayout %})).
   * @default false
   */
  resizable = false;
  /**
   * Sets the height of the rows.
   * Use numeric values for pixels or string values for other CSS units ([see example](slug:tiles_tilelayout#size-and-position)).
   * @default '1fr'
   */
  rowHeight = "1fr";
  /**
   *
   * Controls how the auto-placement algorithm works, specifying exactly how auto-placed items are flowed in the TileLayout ([see example]({% slug tiles_autoflow_tilelayout %})).
   *
   * For further reference, check the [grid-auto-flow CSS article](https://developer.mozilla.org/en-US/docs/Web/CSS/grid-auto-flow).
   * @default 'column'
   */
  autoFlow = "column";
  /**
   * Enables or disables [keyboard navigation](slug:keyboard_navigation_tilelayout).
   * @default true
   */
  navigable = true;
  /**
   * Fires when item reordering is completed ([see example]({% slug reordering_tilelayout %})).
   * You can prevent this event to cancel the reorder operation.
   */
  reorder = new EventEmitter();
  /**
   * Fires when item resizing is completed ([see example]({% slug resizing_tilelayout %})).
   * You can prevent this event to cancel the resize operation.
   */
  resize = new EventEmitter();
  hostClass = true;
  hostRole = "list";
  get gapStyle() {
    return `${this.gap.rows}px ${this.gap.columns}px`;
  }
  direction;
  get currentColStart() {
    return this.draggingService.colStart;
  }
  get currentRowStart() {
    return this.draggingService.rowStart;
  }
  get draggedItemWrapper() {
    return this.draggingService.itemWrapper;
  }
  get targetOrder() {
    return this.draggingService.order;
  }
  /**
   * Contains a query list of the `TileLayoutItemComponent` instances that are used in the TileLayout.
   * This allows you to access the items programmatically and manipulate their properties or listen to their events.
   */
  items;
  hint;
  /**
   * @hidden
   */
  showLicenseWatermark = false;
  /**
   * @hidden
   */
  licenseMessage;
  draggable;
  subs = new Subscription();
  _gap = {
    rows: 16,
    columns: 16
  };
  constructor(zone, elem, renderer, localization, draggingService, navigationService) {
    this.zone = zone;
    this.elem = elem;
    this.renderer = renderer;
    this.localization = localization;
    this.draggingService = draggingService;
    this.navigationService = navigationService;
    const isValid = N(packageMetadata3);
    this.licenseMessage = getLicenseMessage(packageMetadata3);
    this.showLicenseWatermark = shouldShowValidationUI(isValid);
  }
  ngOnInit() {
    this.applyColStyling();
    this.applyRowStyling();
    this.draggingService.reorderable.next(this.reorderable);
    this.draggingService.resizable.next(this.resizable);
    this.navigationService.owner = this;
    this.navigationService.navigable.next(this.navigable);
    if (hasObservers(this.reorder)) {
      this.subs.add(this.draggingService.reorder.subscribe((e) => this.reorder.emit(e)));
    }
    if (hasObservers(this.resize)) {
      this.subs.add(this.draggingService.resize.subscribe((e) => this.resize.emit(e)));
    }
    this.subs.add(this.draggingService.reorderable.subscribe((reorderable2) => {
      if (reorderable2 && !this.draggable) {
        this.initializeDraggable();
      }
    }));
    this.subs.add(this.draggingService.resizable.subscribe((resizable) => {
      if (resizable && !this.draggable) {
        this.initializeDraggable();
      }
    }));
    this.subs.add(this.localization.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
    }));
  }
  ngAfterViewInit() {
    this.draggingService.tileLayoutSettings = this.draggingServiceConfig();
    this.applyAutoFlow(null, autoFlowClasses[this.autoFlow]);
    this.items.changes.subscribe(() => {
      this.setItemsOrder();
      this.draggingService.tileLayoutSettings.items = this.items.toArray();
    });
    this.zone.runOutsideAngular(() => {
      this.elem.nativeElement.addEventListener("focusin", this.onFocusIn);
    });
  }
  ngAfterContentInit() {
    this.setItemsOrder();
  }
  ngOnChanges(changes) {
    if (changes["columns"] || changes["columnWidth"]) {
      this.applyColStyling();
    }
    if (changes["rowHeight"]) {
      this.applyRowStyling();
    }
    if (isChanged("reorderable", changes)) {
      this.draggingService.reorderable.next(changes["reorderable"].currentValue);
    }
    if (isChanged("resizable", changes)) {
      this.draggingService.resizable.next(changes["resizable"].currentValue);
    }
    if (changes["gap"] || changes["autoFlow"] || changes["columns"]) {
      this.draggingService.tileLayoutSettings = this.draggingServiceConfig();
      if (changes["autoFlow"]) {
        this.applyAutoFlow(autoFlowClasses[changes["autoFlow"].previousValue] || "", autoFlowClasses[changes["autoFlow"].currentValue]);
      }
    }
    if (isChanged("navigable", changes)) {
      this.navigationService.navigable.next(changes["navigable"].currentValue);
    }
  }
  ngOnDestroy() {
    if (this.draggable) {
      this.draggable.destroy();
    }
    this.subs.unsubscribe();
    this.elem.nativeElement.removeEventListener("focusin", this.onFocusIn);
  }
  handlePress({
    originalEvent
  }) {
    this.draggingService.handlePress(originalEvent);
  }
  handleDrag({
    originalEvent
  }) {
    this.draggingService.handleDrag(originalEvent);
  }
  handleRelease({
    originalEvent
  }) {
    this.draggingService.handleRelease(originalEvent);
  }
  applyColStyling() {
    const colWidth = typeof this.columnWidth === "number" ? `${this.columnWidth}px` : this.columnWidth;
    const gridTemplateColumnsStyle = `repeat(${this.columns}, ${colWidth})`;
    this.renderer.setStyle(this.elem.nativeElement, "grid-template-columns", gridTemplateColumnsStyle);
  }
  applyRowStyling() {
    const rowHeight = typeof this.rowHeight === "number" ? `${this.rowHeight}px` : this.rowHeight;
    const gridAutoRowsStyle = `${rowHeight}`;
    this.renderer.setStyle(this.elem.nativeElement, "grid-auto-rows", gridAutoRowsStyle);
  }
  draggingServiceConfig() {
    return {
      tileLayoutElement: this.elem ? this.elem.nativeElement : void 0,
      hintElement: this.hint ? this.hint.nativeElement : void 0,
      gap: this.gap,
      columns: this.columns,
      autoFlow: this.autoFlow,
      items: this.items ? this.items.toArray() : []
    };
  }
  initializeDraggable() {
    this.draggable = new Draggable({
      press: this.handlePress.bind(this),
      drag: this.handleDrag.bind(this),
      release: this.handleRelease.bind(this)
    });
    this.zone.runOutsideAngular(() => this.draggable.bindTo(this.elem.nativeElement));
  }
  applyAutoFlow(classToRemove, classToAdd) {
    const element = this.elem.nativeElement;
    if (classToRemove) {
      this.renderer.removeClass(element, classToRemove);
    }
    if (this.autoFlow !== "none" && isPresent5(classToAdd)) {
      this.renderer.addClass(element, classToAdd);
    }
  }
  setItemsOrder() {
    this.items.forEach((item, index) => {
      if (!isPresent5(item.order)) {
        item.order = index;
      }
    });
  }
  onFocusIn = (e) => {
    if (!this.navigable || this.navigationService.mousedown || !e.relatedTarget) {
      this.navigationService.mousedown = false;
      return;
    }
    if (!(this.elem.nativeElement.compareDocumentPosition(e.relatedTarget) & Node.DOCUMENT_POSITION_CONTAINED_BY)) {
      this.navigationService.returnFocus();
    }
  };
  static ɵfac = function TileLayoutComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TileLayoutComponent)(ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(TileLayoutDraggingService), ɵɵdirectiveInject(TileLayoutKeyboardNavigationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TileLayoutComponent,
    selectors: [["kendo-tilelayout"]],
    contentQueries: function TileLayoutComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, TileLayoutItemComponent, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.items = _t);
      }
    },
    viewQuery: function TileLayoutComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c292, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.hint = _t.first);
      }
    },
    hostVars: 8,
    hostBindings: function TileLayoutComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("role", ctx.hostRole)("dir", ctx.direction);
        ɵɵstyleProp("gap", ctx.gapStyle)("padding", ctx.gapStyle);
        ɵɵclassProp("k-tilelayout", ctx.hostClass);
      }
    },
    inputs: {
      columns: "columns",
      columnWidth: "columnWidth",
      gap: "gap",
      reorderable: "reorderable",
      resizable: "resizable",
      rowHeight: "rowHeight",
      autoFlow: "autoFlow",
      navigable: "navigable"
    },
    outputs: {
      reorder: "reorder",
      resize: "resize"
    },
    features: [ɵɵProvidersFeature([LocalizationService, TileLayoutDraggingService, TileLayoutKeyboardNavigationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.tilelayout.component"
    }]), ɵɵNgOnChangesFeature],
    ngContentSelectors: _c82,
    decls: 4,
    vars: 15,
    consts: [["hint", ""], [1, "k-layout-item-hint"], ["kendoWatermarkOverlay", "", 3, "licenseMessage"]],
    template: function TileLayoutComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
        ɵɵelement(1, "div", 1, 0);
        ɵɵconditionalCreate(3, TileLayoutComponent_Conditional_3_Template, 1, 1, "div", 2);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵstyleProp("display", "none")("order", ctx.targetOrder)("grid-column-end", ctx.draggedItemWrapper == null ? null : ctx.draggedItemWrapper.style.gridColumnEnd)("grid-row-end", ctx.draggedItemWrapper == null ? null : ctx.draggedItemWrapper.style.gridRowEnd)("grid-column-start", ctx.currentColStart)("grid-row-start", ctx.currentRowStart)("z-index", "1");
        ɵɵadvance(2);
        ɵɵconditional(ctx.showLicenseWatermark ? 3 : -1);
      }
    },
    dependencies: [WatermarkOverlayComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TileLayoutComponent, [{
    type: Component,
    args: [{
      selector: "kendo-tilelayout",
      providers: [LocalizationService, TileLayoutDraggingService, TileLayoutKeyboardNavigationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.tilelayout.component"
      }],
      template: `
        <ng-content></ng-content>
        <div #hint class="k-layout-item-hint"
          [style.display]="'none'"
          [style.order]="targetOrder"
          [style.gridColumnEnd]="draggedItemWrapper?.style.gridColumnEnd"
          [style.gridRowEnd]="draggedItemWrapper?.style.gridRowEnd"
          [style.gridColumnStart]="currentColStart"
          [style.gridRowStart]="currentRowStart"
          [style.zIndex]="'1'">
        </div>
        @if (showLicenseWatermark) {
          <div kendoWatermarkOverlay [licenseMessage]="licenseMessage"></div>
        }
        `,
      standalone: true,
      imports: [WatermarkOverlayComponent]
    }]
  }], () => [{
    type: NgZone
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: LocalizationService
  }, {
    type: TileLayoutDraggingService
  }, {
    type: TileLayoutKeyboardNavigationService
  }], {
    columns: [{
      type: Input
    }],
    columnWidth: [{
      type: Input
    }],
    gap: [{
      type: Input
    }],
    reorderable: [{
      type: Input
    }],
    resizable: [{
      type: Input
    }],
    rowHeight: [{
      type: Input
    }],
    autoFlow: [{
      type: Input
    }],
    navigable: [{
      type: Input
    }],
    reorder: [{
      type: Output
    }],
    resize: [{
      type: Output
    }],
    hostClass: [{
      type: HostBinding,
      args: ["class.k-tilelayout"]
    }],
    hostRole: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    gapStyle: [{
      type: HostBinding,
      args: ["style.gap"]
    }, {
      type: HostBinding,
      args: ["style.padding"]
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    items: [{
      type: ContentChildren,
      args: [TileLayoutItemComponent]
    }],
    hint: [{
      type: ViewChild,
      args: ["hint", {
        static: false
      }]
    }]
  });
})();
var TileLayoutItemBodyComponent = class _TileLayoutItemBodyComponent {
  hostClass = true;
  minHeight = 0;
  static ɵfac = function TileLayoutItemBodyComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TileLayoutItemBodyComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TileLayoutItemBodyComponent,
    selectors: [["kendo-tilelayout-item-body"]],
    hostVars: 6,
    hostBindings: function TileLayoutItemBodyComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵstyleProp("min-height", ctx.minHeight);
        ɵɵclassProp("k-tilelayout-item-body", ctx.hostClass)("k-card-body", ctx.hostClass);
      }
    },
    ngContentSelectors: _c82,
    decls: 1,
    vars: 0,
    template: function TileLayoutItemBodyComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TileLayoutItemBodyComponent, [{
    type: Component,
    args: [{
      selector: "kendo-tilelayout-item-body",
      template: `
        <ng-content></ng-content>
    `,
      standalone: true
    }]
  }], null, {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-tilelayout-item-body"]
    }, {
      type: HostBinding,
      args: ["class.k-card-body"]
    }],
    minHeight: [{
      type: HostBinding,
      args: ["style.min-height"]
    }]
  });
})();
var VERTICAL_SUFFIX = {
  top: "start",
  middle: "center",
  bottom: "end",
  stretch: "stretch"
};
var JUSTIFY_PREFIX = `k-justify-content`;
var GRID_JUSTIFY_PREFIX = `k-justify-items`;
var ALIGN_PREFIX = `k-align-items`;
var normalizeGap = (gap) => {
  if (typeof gap === "number" || typeof gap === "string") {
    return {
      cols: gap,
      rows: gap
    };
  } else {
    const parsedGap = {};
    parsedGap.rows = gap.rows ? gap.rows : 0;
    parsedGap.cols = gap.cols ? gap.cols : 0;
    return parsedGap;
  }
};
var generateGapStyle = (gap) => {
  if (gap.rows === gap.cols) {
    return typeof gap.rows === "number" ? `${gap.rows}px` : gap.rows;
  } else {
    const rowStyle = `${typeof gap.rows === "number" ? gap.rows + "px" : gap.rows}`;
    const colStyle = `${typeof gap.cols === "number" ? gap.cols + "px" : gap.cols}`;
    return `${rowStyle} ${colStyle}`;
  }
};
var generateGridStyle = (items, itemType) => {
  const styling = [];
  items.forEach((item) => {
    if (typeof item === "number") {
      styling.push(`${item}px`);
    } else if (typeof item === "string") {
      styling.push(item);
    } else {
      if (itemType === "rows") {
        const rowHeight = item.height;
        if (rowHeight) {
          styling.push(typeof rowHeight === "number" ? `${rowHeight}px` : rowHeight);
        } else {
          styling.push("0px");
        }
      } else {
        const colWidth = item.width;
        if (colWidth) {
          styling.push(typeof colWidth === "number" ? `${colWidth}px` : colWidth);
        } else {
          styling.push("0px");
        }
      }
    }
  });
  return styling;
};
var validateGridLayoutRowsCols = (arr) => {
  for (const el of arr) {
    const isNum = typeof el === "number";
    const isStr = typeof el === "string";
    const isObject2 = typeof el === "object" && el !== null;
    if (!isNum && !isStr && !isObject2) {
      return false;
    }
  }
  return true;
};
var GridLayoutComponent = class _GridLayoutComponent {
  renderer;
  element;
  localization;
  hostClass = true;
  get dir() {
    return this.direction;
  }
  /**
   * Specifies the number of rows and their height
   * ([More details](slug:layout_gridlayout#toc-rows-and-columns)).
   *
   * You can define rows by passing an array where the number of elements determines the number of rows or each element defines the size of the corresponding row.
   * For example, you can use CSS units like `px`, `%`, `fr`, or `auto` to define the row sizes.
   */
  rows;
  /**
   * Specifies the number of columns and their widths
   * ([More details](slug:layout_gridlayout#toc-rows-and-columns)).
   *
   * You can define columns by passing an array where the number of elements determines the number of columns or each element defines the size of the corresponding column.
   * For example, you can use CSS units like `px`, `%`, `fr`, or `auto` to define the column sizes.
   */
  cols;
  /**
   * Specifies the gaps between the elements ([see example](slug:layout_gridlayout#toc-gap)).
   *
   * @default 0
   */
  gap = 0;
  /**
   * Specifies the horizontal and vertical alignment of the inner GridLayout elements
   * ([see example]({% slug layout_gridlayout %}#toc-alignment)).
   */
  set align(align) {
    this._align = Object.assign({}, this._align, align);
    this.handleAlignClasses();
  }
  get align() {
    return this._align;
  }
  _align = {
    horizontal: "stretch",
    vertical: "stretch"
  };
  justifyClass;
  alignClass;
  constructor(renderer, element, localization) {
    this.renderer = renderer;
    this.element = element;
    this.localization = localization;
    N(packageMetadata3);
  }
  ngAfterViewInit() {
    this.handleAlignClasses();
    this.handleGridTemplateStyling("rows");
    this.handleGridTemplateStyling("cols");
    this.setGap();
  }
  ngOnChanges(changes) {
    if (isChanged("gap", changes)) {
      this.setGap();
    }
    if (isChanged("rows", changes)) {
      this.handleGridTemplateStyling("rows");
    }
    if (isChanged("cols", changes)) {
      this.handleGridTemplateStyling("cols");
    }
  }
  handleAlignClasses() {
    const elem = this.element.nativeElement;
    if (isPresent5(this.justifyClass)) {
      this.renderer.removeClass(elem, this.justifyClass);
    }
    if (isPresent5(this.alignClass)) {
      this.renderer.removeClass(elem, this.alignClass);
    }
    this.justifyClass = `${GRID_JUSTIFY_PREFIX}-${this.align.horizontal}`;
    this.alignClass = `${ALIGN_PREFIX}-${VERTICAL_SUFFIX[this.align.vertical]}`;
    this.renderer.addClass(elem, this.justifyClass);
    this.renderer.addClass(elem, this.alignClass);
  }
  setGap() {
    const parsedGap = normalizeGap(this.gap);
    const gapStyle = generateGapStyle(parsedGap);
    this.renderer.setStyle(this.element.nativeElement, "gap", gapStyle);
  }
  handleGridTemplateStyling(type) {
    if (!isPresent5(this[type])) {
      return;
    }
    const isValid = validateGridLayoutRowsCols(this[type]);
    if (!isValid && isDevMode()) {
      const valueType = type === "rows" ? "GridLayoutRowSize" : "GridLayoutColSize";
      throw new Error(`The provided ${type} value contains invalid elements. The array supports values of type number, string or ${valueType}.`);
    }
    const gridTemplateStyle = type === "rows" ? "grid-template-rows" : "grid-template-columns";
    const gridStyle = generateGridStyle(this[type], type);
    this.renderer.setStyle(this.element.nativeElement, gridTemplateStyle, gridStyle.join(" "));
  }
  get direction() {
    return this.localization.rtl ? "rtl" : "ltr";
  }
  static ɵfac = function GridLayoutComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _GridLayoutComponent)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _GridLayoutComponent,
    selectors: [["kendo-gridlayout"]],
    hostVars: 3,
    hostBindings: function GridLayoutComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.dir);
        ɵɵclassProp("k-grid-layout", ctx.hostClass);
      }
    },
    inputs: {
      rows: "rows",
      cols: "cols",
      gap: "gap",
      align: "align"
    },
    exportAs: ["kendoGridLayout"],
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.gridlayout"
    }]), ɵɵNgOnChangesFeature],
    ngContentSelectors: _c82,
    decls: 1,
    vars: 0,
    template: function GridLayoutComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GridLayoutComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoGridLayout",
      selector: "kendo-gridlayout",
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.gridlayout"
      }],
      template: `
        <ng-content></ng-content>
    `,
      standalone: true
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: LocalizationService
  }], {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-grid-layout"]
    }],
    dir: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    rows: [{
      type: Input
    }],
    cols: [{
      type: Input
    }],
    gap: [{
      type: Input
    }],
    align: [{
      type: Input
    }]
  });
})();
var GridLayoutItemComponent = class _GridLayoutItemComponent {
  renderer;
  element;
  /**
   * Sets the row of the item in the GridLayout
   * ([see example]({% slug items_gridlayout %}#toc-size-and-position)).
   */
  row;
  /**
   * Sets the column of the item in the GridLayout
   * ([see example]({% slug items_gridlayout %}#toc-size-and-position)).
   */
  col;
  /**
   * Specifies how many rows the item spans ([see example]({% slug items_gridlayout %}#toc-size-and-position)).
   *
   * @default 1
   */
  rowSpan;
  /**
   * Specifies how many columns the item spans ([see example]({% slug items_gridlayout %}#toc-size-and-position)).
   *
   * @default 1
   */
  colSpan;
  constructor(renderer, element) {
    this.renderer = renderer;
    this.element = element;
  }
  ngOnInit() {
    this.setItemStyle();
  }
  ngOnChanges() {
    this.setItemStyle();
  }
  setItemStyle() {
    const row2 = this.row || "auto";
    const col = this.col || "auto";
    const rowSpan = this.rowSpan ? `span ${this.rowSpan}` : "auto";
    const colSpan = this.colSpan ? `span ${this.colSpan}` : "auto";
    const gridAreaStyle = `${row2} / ${col} / ${rowSpan} / ${colSpan}`;
    this.renderer.setStyle(this.element.nativeElement, "grid-area", gridAreaStyle);
  }
  static ɵfac = function GridLayoutItemComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _GridLayoutItemComponent)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _GridLayoutItemComponent,
    selectors: [["kendo-gridlayout-item"]],
    inputs: {
      row: "row",
      col: "col",
      rowSpan: "rowSpan",
      colSpan: "colSpan"
    },
    features: [ɵɵNgOnChangesFeature],
    ngContentSelectors: _c82,
    decls: 1,
    vars: 0,
    template: function GridLayoutItemComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GridLayoutItemComponent, [{
    type: Component,
    args: [{
      selector: "kendo-gridlayout-item",
      template: `
        <ng-content></ng-content>
    `,
      standalone: true
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }], {
    row: [{
      type: Input
    }],
    col: [{
      type: Input
    }],
    rowSpan: [{
      type: Input
    }],
    colSpan: [{
      type: Input
    }]
  });
})();
var StackLayoutComponent = class _StackLayoutComponent {
  renderer;
  element;
  localization;
  hostClass = true;
  get horizontalClass() {
    return this.orientation === "horizontal";
  }
  get verticalClass() {
    return this.orientation === "vertical";
  }
  get dir() {
    return this.direction;
  }
  /**
   * Specifies the horizontal and vertical alignment of the inner StackLayout elements
   * ([see example]({% slug layout_stacklayout %}#toc-alignment)).
   */
  set align(align) {
    this._align = Object.assign({}, this._align, align);
    this.handleAlignClasses();
  }
  get align() {
    return this._align;
  }
  /**
   * Specifies the gap between the inner StackLayout elements ([see example](slug:layout_stacklayout#toc-gap)).
   *
   * @default 0
   */
  gap = 0;
  /**
   * Specifies the orientation of the StackLayout
   * ([see example]({% slug layout_stacklayout %}#toc-orientation)).
   *
   * @default 'horizontal'
   */
  orientation = "horizontal";
  _align = {
    horizontal: "stretch",
    vertical: "stretch"
  };
  justifyClass;
  alignClass;
  constructor(renderer, element, localization) {
    this.renderer = renderer;
    this.element = element;
    this.localization = localization;
    N(packageMetadata3);
  }
  ngAfterViewInit() {
    this.handleAlignClasses();
    this.setGap();
  }
  ngOnChanges(changes) {
    if (isChanged("gap", changes)) {
      this.setGap();
    }
    if (isChanged("orientation", changes)) {
      this.handleAlignClasses();
    }
  }
  handleAlignClasses() {
    const elem = this.element.nativeElement;
    if (isPresent5(this.justifyClass)) {
      this.renderer.removeClass(elem, this.justifyClass);
    }
    if (isPresent5(this.alignClass)) {
      this.renderer.removeClass(elem, this.alignClass);
    }
    if (this.orientation === "horizontal") {
      this.justifyClass = `${JUSTIFY_PREFIX}-${this.align.horizontal}`;
      this.alignClass = `${ALIGN_PREFIX}-${VERTICAL_SUFFIX[this.align.vertical]}`;
    } else {
      this.justifyClass = `${JUSTIFY_PREFIX}-${VERTICAL_SUFFIX[this.align.vertical]}`;
      this.alignClass = `${ALIGN_PREFIX}-${this.align.horizontal}`;
    }
    this.renderer.addClass(elem, this.justifyClass);
    this.renderer.addClass(elem, this.alignClass);
  }
  setGap() {
    const parsedGap = isNumber2(this.gap) ? `${this.gap}px` : this.gap;
    this.renderer.setStyle(this.element.nativeElement, "gap", parsedGap);
  }
  get direction() {
    return this.localization.rtl ? "rtl" : "ltr";
  }
  static ɵfac = function StackLayoutComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _StackLayoutComponent)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _StackLayoutComponent,
    selectors: [["kendo-stacklayout"]],
    hostVars: 7,
    hostBindings: function StackLayoutComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.dir);
        ɵɵclassProp("k-stack-layout", ctx.hostClass)("k-hstack", ctx.horizontalClass)("k-vstack", ctx.verticalClass);
      }
    },
    inputs: {
      align: "align",
      gap: "gap",
      orientation: "orientation"
    },
    exportAs: ["kendoStackLayout"],
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.stacklayout"
    }]), ɵɵNgOnChangesFeature],
    ngContentSelectors: _c82,
    decls: 1,
    vars: 0,
    template: function StackLayoutComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StackLayoutComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoStackLayout",
      selector: "kendo-stacklayout",
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.stacklayout"
      }],
      template: `
        <ng-content></ng-content>
    `,
      standalone: true
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: LocalizationService
  }], {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-stack-layout"]
    }],
    horizontalClass: [{
      type: HostBinding,
      args: ["class.k-hstack"]
    }],
    verticalClass: [{
      type: HostBinding,
      args: ["class.k-vstack"]
    }],
    dir: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    align: [{
      type: Input
    }],
    gap: [{
      type: Input
    }],
    orientation: [{
      type: Input
    }]
  });
})();
var TimelineMessages = class _TimelineMessages extends ComponentMessages {
  /**
   * The title of the previous button in horizontal orientation.
   */
  previous;
  /**
   * The title of the next button in horizontal orientation.
   */
  next;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵTimelineMessages_BaseFactory;
    return function TimelineMessages_Factory(__ngFactoryType__) {
      return (ɵTimelineMessages_BaseFactory || (ɵTimelineMessages_BaseFactory = ɵɵgetInheritedFactory(_TimelineMessages)))(__ngFactoryType__ || _TimelineMessages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _TimelineMessages,
    selectors: [["kendo-timeline-messages-base"]],
    inputs: {
      previous: "previous",
      next: "next"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimelineMessages, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line @angular-eslint/directive-selector
      selector: "kendo-timeline-messages-base"
    }]
  }], null, {
    previous: [{
      type: Input
    }],
    next: [{
      type: Input
    }]
  });
})();
var TimelineCustomMessagesComponent = class _TimelineCustomMessagesComponent extends TimelineMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function TimelineCustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TimelineCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TimelineCustomMessagesComponent,
    selectors: [["kendo-timeline-messages"]],
    features: [ɵɵProvidersFeature([{
      provide: TimelineMessages,
      useExisting: forwardRef(() => _TimelineCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function TimelineCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimelineCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: TimelineMessages,
        useExisting: forwardRef(() => TimelineCustomMessagesComponent)
      }],
      selector: "kendo-timeline-messages",
      template: ``,
      standalone: true
    }]
  }], () => [{
    type: LocalizationService
  }], null);
})();
var TimelineCardActionsTemplateDirective = class _TimelineCardActionsTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function TimelineCardActionsTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TimelineCardActionsTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _TimelineCardActionsTemplateDirective,
    selectors: [["", "kendoTimelineCardActionsTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimelineCardActionsTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoTimelineCardActionsTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var TimelineCardBodyTemplateDirective = class _TimelineCardBodyTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function TimelineCardBodyTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TimelineCardBodyTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _TimelineCardBodyTemplateDirective,
    selectors: [["", "kendoTimelineCardBodyTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimelineCardBodyTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoTimelineCardBodyTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var TimelineCardHeaderTemplateDirective = class _TimelineCardHeaderTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function TimelineCardHeaderTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TimelineCardHeaderTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _TimelineCardHeaderTemplateDirective,
    selectors: [["", "kendoTimelineCardHeaderTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimelineCardHeaderTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoTimelineCardHeaderTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var defaultModelFields = {
  title: "title",
  subtitle: "subtitle",
  description: "description",
  date: "date",
  expanded: "expanded",
  images: "images",
  actions: "actions"
};
var processItems = (items, fields) => {
  return items.map((item) => parseItem(item, fields));
};
var parseItem = (item, fields) => ({
  title: item[fields.title] || item.title,
  date: item[fields.date] || item.date,
  subtitle: item[fields.subtitle] || item.subtitle,
  description: item[fields.description] || item.description,
  expanded: item[fields.expanded] || item.expanded,
  images: item[fields.images] || item.images,
  actions: item[fields.actions] || item.actions
});
var TimelineService = class _TimelineService {
  timeline;
  onToggle(event) {
    if (this.timeline) {
      this.timeline["onToggle"]?.emit(event);
    }
  }
  onActionClick(event) {
    if (this.timeline) {
      this.timeline["onActionClick"]?.emit(event);
    }
  }
  onNavigate(event) {
    if (this.timeline) {
      this.timeline["onNavigate"]?.emit(event);
    }
  }
  static ɵfac = function TimelineService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TimelineService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _TimelineService,
    factory: _TimelineService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimelineService, [{
    type: Injectable
  }], null, null);
})();
var TimelineCardComponent = class _TimelineCardComponent {
  element;
  timelineService;
  renderer;
  event;
  expanded = false;
  collapsible = true;
  reversed = false;
  orientation;
  navigable;
  tabIndex;
  animationDuration;
  index;
  eventWidth;
  eventHeight;
  headerTemplate;
  bodyTemplate;
  actionsTemplate;
  set calloutStyle(value2) {
    if (!this.calloutElementRef || !this.calloutElementRef.nativeElement.classList.contains("k-callout-n")) {
      return;
    }
    this.calloutElementRef.nativeElement.style.left = value2?.left;
  }
  calloutElementRef;
  hostClass = true;
  get collapsedClass() {
    return !this.expanded && !this.animationInProgress && this.animationState === "collapsed";
  }
  onComponentKeyDown(event) {
    if (!this.navigable) {
      return;
    }
    if (event.code === Keys.Space || event.code === Keys.Enter || event.code === Keys.NumpadEnter) {
      event.preventDefault();
      if (this.collapsible && this.orientation === "vertical") {
        this.expanded = !this.expanded;
      }
    }
  }
  get role() {
    return this.orientation === "vertical" ? "button" : "tabpanel";
  }
  get ariaLive() {
    return this.orientation === "vertical" ? "polite" : null;
  }
  get ariaExpanded() {
    return this.orientation === "vertical" ? this.expanded : null;
  }
  calloutSvgIcon = chevronRightIcon;
  calloutFontIcon = "arrow-chevron-right";
  animationState = this.expanded ? "expanded" : "collapsed";
  animationInProgress = false;
  constructor(element, timelineService, renderer) {
    this.element = element;
    this.timelineService = timelineService;
    this.renderer = renderer;
  }
  ngAfterViewInit() {
    this.makeOverflowVisible();
  }
  ngOnChanges(changes) {
    if (isChanged("collapsible", changes, false)) {
      if (!this.collapsible) {
        this.expanded = true;
      }
    }
  }
  toggle() {
    if (this.orientation === "vertical") {
      this.expanded = this.collapsible ? !this.expanded : true;
      this.timelineService.onToggle(this.index);
    }
  }
  expand() {
    if (!this.expanded) {
      this.expanded = true;
      this.timelineService.onToggle(this.index);
    }
  }
  collapse() {
    if (!this.collapsible || !this.expanded) {
      return;
    }
    this.expanded = false;
    this.timelineService.onToggle(this.index);
  }
  onActionClick(event) {
    event.stopPropagation();
    this.timelineService.onActionClick(this.index);
  }
  animationStart() {
    this.animationInProgress = true;
  }
  animationDone(event) {
    this.animationInProgress = false;
    if (event.toState === "expanded" && event.fromState !== "expanded") {
      this.animationState = "expanded";
      this.makeOverflowVisible();
    } else if (event.toState === "collapsed" && event.fromState !== "collapsed") {
      this.animationState = "collapsed";
    }
  }
  makeOverflowVisible() {
    if (this.orientation === "vertical") {
      return;
    }
    const cardBody = this.element?.nativeElement.querySelector(".k-card-body");
    if (cardBody) {
      this.renderer.setStyle(cardBody, "overflow", "auto");
    }
  }
  static ɵfac = function TimelineCardComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TimelineCardComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(TimelineService), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TimelineCardComponent,
    selectors: [["kendo-timeline-card"]],
    viewQuery: function TimelineCardComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c302, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.calloutElementRef = _t.first);
      }
    },
    hostVars: 4,
    hostBindings: function TimelineCardComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("keydown", function TimelineCardComponent_keydown_HostBindingHandler($event) {
          return ctx.onComponentKeyDown($event);
        });
      }
      if (rf & 2) {
        ɵɵclassProp("k-timeline-card", ctx.hostClass)("k-collapsed", ctx.collapsedClass);
      }
    },
    inputs: {
      event: "event",
      expanded: "expanded",
      collapsible: "collapsible",
      reversed: "reversed",
      orientation: "orientation",
      navigable: "navigable",
      tabIndex: "tabIndex",
      animationDuration: "animationDuration",
      index: "index",
      eventWidth: "eventWidth",
      eventHeight: "eventHeight",
      headerTemplate: "headerTemplate",
      bodyTemplate: "bodyTemplate",
      actionsTemplate: "actionsTemplate",
      calloutStyle: "calloutStyle"
    },
    exportAs: ["kendoTimelineCard"],
    features: [ɵɵProvidersFeature([]), ɵɵNgOnChangesFeature],
    decls: 4,
    vars: 14,
    consts: [["callout", ""], [1, "k-card-with-callout", "k-card-vertical", 3, "click", "ngStyle", "width"], [1, "k-timeline-card-callout", "k-card-callout", 3, "ngClass"], [1, "k-card-inner"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["kendoCardTitle", ""], ["kendoCardSubtitle", ""], [1, "k-event-title"], ["kendoButton", "", "fillMode", "flat", "tabindex", "-1", "type", "button", 1, "k-event-collapse", 3, "icon", "svgIcon"], [1, "k-card-description"], ["kendoCardMedia", "", 3, "src", "alt"], ["kendoCardMedia", "", 3, "src"], ["role", "button", 1, "k-button", "k-button-md", "k-rounded-md", "k-button-flat", "k-button-flat-primary", 3, "href", "target"], ["role", "button", 1, "k-button", "k-button-md", "k-rounded-md", "k-button-flat", "k-button-flat-primary", 3, "click", "href", "target"]],
    template: function TimelineCardComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "kendo-card", 1);
        ɵɵlistener("click", function TimelineCardComponent_Template_kendo_card_click_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.toggle());
        });
        ɵɵelement(1, "span", 2, 0);
        ɵɵconditionalCreate(3, TimelineCardComponent_Conditional_3_Template, 7, 5, "div", 3);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("ngStyle", ɵɵpureFunction1(8, _c312, ctx.orientation === "horizontal" ? ctx.eventHeight + "px" : null))("width", ctx.orientation === "horizontal" ? "auto" : ctx.eventWidth + "px");
        ɵɵattribute("role", ctx.role)("aria-live", ctx.ariaLive)("aria-expanded", ctx.ariaExpanded)("tabindex", ctx.tabIndex);
        ɵɵadvance();
        ɵɵproperty("ngClass", ɵɵpureFunction3(10, _c322, ctx.orientation === "horizontal", ctx.orientation === "vertical" && !ctx.reversed, ctx.orientation === "vertical" && ctx.reversed));
        ɵɵadvance(2);
        ɵɵconditional(ctx.event ? 3 : -1);
      }
    },
    dependencies: [CardComponent, NgStyle, NgClass, CardHeaderComponent, NgTemplateOutlet, CardTitleDirective, ButtonComponent, CardSubtitleDirective, CardBodyComponent, CardMediaDirective, CardActionsComponent],
    encapsulation: 2,
    data: {
      animation: [trigger("toggle", [state("collapsed", style({
        height: "0",
        "overflow-y": "hidden",
        display: "none"
      })), state("expanded", style({
        height: "*",
        "overflow-y": "hidden",
        display: "block"
      })), transition("collapsed <=> expanded", [animate("{{animationDuration}}ms")], {
        params: {
          animationDuration: "400"
        }
      })])]
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimelineCardComponent, [{
    type: Component,
    args: [{
      animations: [trigger("toggle", [state("collapsed", style({
        height: "0",
        "overflow-y": "hidden",
        display: "none"
      })), state("expanded", style({
        height: "*",
        "overflow-y": "hidden",
        display: "block"
      })), transition("collapsed <=> expanded", [animate("{{animationDuration}}ms")], {
        params: {
          animationDuration: "400"
        }
      })])],
      providers: [],
      exportAs: "kendoTimelineCard",
      selector: "kendo-timeline-card",
      template: `
        <kendo-card
          [ngStyle]="{ 'height': orientation === 'horizontal' ? eventHeight + 'px' : null }"
          [width]="orientation === 'horizontal' ? 'auto' : eventWidth + 'px'"
          class="k-card-with-callout k-card-vertical"
          (click)="toggle()"
          [attr.role]="role"
          [attr.aria-live]="ariaLive"
          [attr.aria-expanded]="ariaExpanded"
          [attr.tabindex]="tabIndex"
          >
          <span
            #callout
            class="k-timeline-card-callout k-card-callout"
                [ngClass]="{
                    'k-callout-n': orientation === 'horizontal',
                    'k-callout-w': orientation === 'vertical' && !this.reversed,
                    'k-callout-e': orientation === 'vertical' && this.reversed
                }"
            >
          </span>
          @if (event) {
            <div class="k-card-inner">
              <kendo-card-header>
                @if (headerTemplate) {
                  <ng-template
                    [ngTemplateOutlet]="headerTemplate?.templateRef"
                    [ngTemplateOutletContext]="{ $implicit: event, index: index}">
                    >
                  </ng-template>
                }
                @if (!headerTemplate) {
                  <div kendoCardTitle>
                    <span class="k-event-title">{{ event.title }}</span>
                    @if (collapsible && orientation === 'vertical') {
                      <button
                        kendoButton
                        [icon]="calloutFontIcon"
                        [svgIcon]="calloutSvgIcon"
                        class="k-event-collapse"
                        fillMode="flat"
                        [attr.aria-hidden]="true"
                        tabindex="-1"
                        type="button"
                      ></button>
                    }
                  </div>
                }
                @if (!headerTemplate) {
                  <div kendoCardSubtitle >{{ event.subtitle }}</div>
                }
              </kendo-card-header>
              @if (event.description || event.images) {
                <kendo-card-body
                  [@toggle]="{value: expanded ? 'expanded' : 'collapsed', params: {animationDuration: this.animationDuration || 0}}"
                  (@toggle.start)="animationStart()"
                  (@toggle.done)="animationDone($event)"
                  >
                  @if (bodyTemplate) {
                    <ng-template
                      [ngTemplateOutlet]="bodyTemplate?.templateRef"
                      [ngTemplateOutletContext]="{ $implicit: event, index: index}">
                      >
                    </ng-template>
                  }
                  @if (!bodyTemplate) {
                    <div class="k-card-description">
                      @if (event.description) {
                        <p>{{ event.description }}</p>
                      }
                      @for (image of event.images; track image) {
                        @if (image.alt) {
                          <img kendoCardMedia [src]="image.src" [alt]="image.alt" />
                        }
                        @if (!image.alt) {
                          <img kendoCardMedia [src]="image.src" />
                        }
                      }
                    </div>
                  }
                </kendo-card-body>
              }
              @if (event.actions) {
                <kendo-card-actions
                  [@toggle]="{value: expanded ? 'expanded' : 'collapsed', params: {animationDuration: this.animationDuration || 0}}"
                  >
                  @if (actionsTemplate) {
                    <ng-template
                      [ngTemplateOutlet]="actionsTemplate?.templateRef"
                      [ngTemplateOutletContext]="{ $implicit: event, index: index}">
                      >
                    </ng-template>
                  }
                  @if (!actionsTemplate) {
                    @for (action of event.actions; track action) {
                      <a
                        [href]="action.url"
                        [target]="action.target === 'blank' ? '_blank' : '_self'"
                        (click)="onActionClick($event)"
                        class="k-button k-button-md k-rounded-md k-button-flat k-button-flat-primary"
                        role="button"
                        >
                        {{ action.text }}
                      </a>
                    }
                  }
                </kendo-card-actions>
              }
            </div>
          }
        </kendo-card>
        `,
      standalone: true,
      imports: [CardComponent, NgStyle, NgClass, CardHeaderComponent, NgTemplateOutlet, CardTitleDirective, ButtonComponent, CardSubtitleDirective, CardBodyComponent, CardMediaDirective, CardActionsComponent]
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: TimelineService
  }, {
    type: Renderer2
  }], {
    event: [{
      type: Input
    }],
    expanded: [{
      type: Input
    }],
    collapsible: [{
      type: Input
    }],
    reversed: [{
      type: Input
    }],
    orientation: [{
      type: Input
    }],
    navigable: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    animationDuration: [{
      type: Input
    }],
    index: [{
      type: Input
    }],
    eventWidth: [{
      type: Input
    }],
    eventHeight: [{
      type: Input
    }],
    headerTemplate: [{
      type: Input
    }],
    bodyTemplate: [{
      type: Input
    }],
    actionsTemplate: [{
      type: Input
    }],
    calloutStyle: [{
      type: Input
    }],
    calloutElementRef: [{
      type: ViewChild,
      args: ["callout"]
    }],
    hostClass: [{
      type: HostBinding,
      args: ["class.k-timeline-card"]
    }],
    collapsedClass: [{
      type: HostBinding,
      args: ["class.k-collapsed"]
    }],
    onComponentKeyDown: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }]
  });
})();
var DEFAULT_TAB_WIDTH = 200;
var SPACE_BETWEEN_TABS = 25;
var TRANSITION_EVENTS_COUNT = 3;
var TimelineHorizontalComponent = class _TimelineHorizontalComponent {
  cdr;
  _zone;
  renderer;
  timelineService;
  localization;
  events = [];
  alterMode;
  collapsibleEvents;
  navigable;
  showDateLabels;
  animationDuration;
  eventHeight;
  dateFormat;
  headerTemplate;
  bodyTemplate;
  actionsTemplate;
  cardElementRefs;
  circleElementRefs;
  flagElementRefs;
  trackElementRef;
  scrollableTrackElementRef;
  cardComponents;
  get selectedEvent() {
    return this._selectedEvent;
  }
  set selectedEvent(value2) {
    if (this._selectedEvent === value2) {
      return;
    }
    const newSelectedIndex = this.events.findIndex((event) => event === value2);
    if (newSelectedIndex === -1 && value2 !== null) {
      return;
    }
    this._selectedEvent = value2;
    this.selectedEventIndex = newSelectedIndex;
    this.calloutStyle = this.calloutOffset;
  }
  trackWrapWidth;
  scrollableTrackWidth;
  cardWidth;
  svgLeftIcon = caretAltLeftIcon;
  svgRightIcon = caretAltRightIcon;
  calloutStyle;
  animationState = "center";
  translateValue = 0;
  eventsInInterval = [0, 1, 2];
  selectedCardIndex = 0;
  selectedEventIndex;
  tabFlex;
  tabWidth = DEFAULT_TAB_WIDTH;
  visibleTabsCount;
  firstCircleInView = 0;
  visibleEvents = [];
  trackItems = [];
  previousTitle = "previous";
  nextTitle = "next";
  _selectedEvent;
  subscriptions = new Subscription();
  constructor(cdr, _zone, renderer, timelineService, localization) {
    this.cdr = cdr;
    this._zone = _zone;
    this.renderer = renderer;
    this.timelineService = timelineService;
    this.localization = localization;
  }
  ngOnInit() {
    this.l10nChange();
    this.subscriptions.add(this.localization.changes.subscribe(this.l10nChange.bind(this)));
    if (this.events.length > 0) {
      this.selectedEvent = this.events[0];
    }
    this.events.forEach((event) => {
      if (event.flag) {
        this.trackItems.push({
          isFlag: event.flag
        });
      }
      this.trackItems.push(event);
    });
  }
  ngAfterViewInit() {
    if (!isDocumentAvailable()) {
      return;
    }
    this.subscriptions.add(this.renderer.listen(this.trackElementRef.nativeElement, "keydown", this.onKeyDown.bind(this)));
    this.trackWrapWidth = this.trackElementRef.nativeElement.getBoundingClientRect().width;
    this.scrollableTrackWidth = this.scrollableTrackElementRef.nativeElement.getBoundingClientRect().width;
    this._zone.runOutsideAngular(() => {
      this.onCirclesChange();
      this.subscriptions.add(this.circleElementRefs.changes.subscribe(this.onCirclesChange.bind(this)));
      this.subscriptions.add(this.cardElementRefs.changes.subscribe(this.onCardsChange.bind(this)));
    });
    if (this.events.length === 0) {
      return;
    }
    this.onCardsChange();
    if (this.cardComponents.get(this.selectedCardIndex)) {
      this.cardComponents.get(this.selectedCardIndex).calloutStyle = this.calloutOffset;
      this.focusTrackItem(0);
    }
  }
  ngOnChanges(changes) {
    if (isChanged("events", changes)) {
      if (!this.events || this.events.length === 0) {
        this.selectedEvent = null;
        this.trackItems = [];
        this.visibleEvents = [];
      } else {
        this.trackItems = [];
        this.events.forEach((event) => {
          if (event.flag) {
            this.trackItems.push({
              isFlag: event.flag
            });
          }
          this.trackItems.push(event);
        });
        this.navigateToFirstInterval();
      }
    }
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  onResize() {
    if (!isDocumentAvailable()) {
      return;
    }
    if (this.trackWrapWidth === this.trackElementRef.nativeElement.getBoundingClientRect().width) {
      return;
    }
    this.cardWidth = this.cardComponents.get(this.selectedCardIndex).element.nativeElement.offsetWidth;
    this.transformCards();
    this.trackWrapWidth = this.trackElementRef.nativeElement.getBoundingClientRect().width;
    this.scrollableTrackWidth = this.scrollableTrackElementRef.nativeElement.getBoundingClientRect().width;
    this.changeTabsCount();
    this._zone.run(() => {
      this.cardComponents.get(this.selectedCardIndex).calloutStyle = this.calloutOffset;
    });
  }
  onTransitionEnd() {
    this.cardElementRefs?.forEach((card) => this.renderer.removeStyle(card.nativeElement, "transition-duration"));
    this.cardComponents.get(this.selectedCardIndex).event = this.selectedEvent;
    this.calloutStyle = this.calloutOffset;
  }
  onTrackTransitionEnd() {
    this.calloutStyle = this.calloutOffset;
  }
  onSlideDone() {
    this.calloutStyle = this.calloutOffset;
  }
  previous() {
    if (this.firstCircleInView === 0) {
      return;
    }
    this.updateInterval(false);
  }
  previousClick() {
    this.previous();
    this.timelineService.onNavigate("previous");
  }
  next() {
    if (!this.visibleTabsCount || this.firstCircleInView + this.visibleTabsCount > this.trackItems.length) {
      return;
    }
    this.updateInterval(true);
  }
  nextClick() {
    this.next();
    this.timelineService.onNavigate("next");
  }
  open(index) {
    if (index < 0 || index >= this.events.length) {
      return;
    }
    if (this.visibleEvents.findIndex((event) => event === this.events[index]) === -1) {
      const trackItemIndex = this.trackItems.findIndex((event) => event === this.events[index]);
      const start = Math.floor(trackItemIndex / this.visibleTabsCount) * this.visibleTabsCount;
      this.navigateToInterval(start, index);
    }
    this.selectedEvent = this.events[index];
    this.selectedCardIndex = this.getOtherSelectedCardIndex(index > this.selectedEventIndex);
    this.calloutStyle = this.calloutOffset;
    this.focusTrackItem(this.selectedEventIndex);
    this.animateCards();
  }
  navigateToEvent(index) {
    const eventIndex = this.events.findIndex((event) => event === this.trackItems[index]);
    if (this.selectedEventIndex === eventIndex) {
      return;
    }
    this.selectedEvent = this.events[eventIndex];
    this.selectedCardIndex = this.getOtherSelectedCardIndex(index > eventIndex);
    this.calloutStyle = this.calloutOffset;
    this.animateCards();
  }
  getOtherSelectedCardIndex(forward) {
    if (forward) {
      return this.selectedCardIndex === 0 ? TRANSITION_EVENTS_COUNT - 1 : this.selectedCardIndex - 1;
    }
    return this.selectedCardIndex === TRANSITION_EVENTS_COUNT - 1 ? 0 : this.selectedCardIndex + 1;
  }
  tabStyle() {
    if (!this.tabFlex) {
      return {};
    }
    return {
      "flex": `1 0 ${this.tabFlex}%`
    };
  }
  getTransformation(width2, position2) {
    if (position2 === this.selectedCardIndex - 1 || position2 === this.selectedCardIndex + 2) {
      return `translate3d(${-width2}px, 0, 0)`;
    }
    if (position2 === this.selectedCardIndex + 1 || position2 === this.selectedCardIndex - 2) {
      return `translate3d(${width2}px, 0, 0)`;
    }
    return `translate3d(0, 0, 0)`;
  }
  getState(position2) {
    if (position2 === this.selectedCardIndex) {
      return "center";
    }
    if (position2 === this.selectedCardIndex - 1 || position2 === this.selectedCardIndex + 2) {
      return "left";
    }
    return "right";
  }
  get calloutOffset() {
    if (!isDocumentAvailable() || !this.circleElementRefs?.first || !this.trackElementRef || !isPresent(this.selectedEventIndex)) {
      return {};
    }
    const circleCenter = this.circleElementRefs.get(this.selectedEventIndex).nativeElement.getBoundingClientRect().left + this.circleElementRefs.get(this.selectedEventIndex).nativeElement.offsetWidth / 2;
    const trackOffset = this.trackElementRef.nativeElement.getBoundingClientRect().left;
    return {
      left: `${circleCenter - trackOffset}px`
    };
  }
  get isFirstRange() {
    return this.firstCircleInView === 0;
  }
  get isLastRange() {
    if (!this.circleElementRefs?.first && !this.flagElementRefs?.first) {
      return false;
    }
    return this.trackItems.length === 0 || this.firstCircleInView + this.visibleTabsCount >= this.trackItems.length;
  }
  onCardsChange() {
    if (this.cardElementRefs?.get(this.selectedCardIndex)) {
      this.cardWidth = this.cardElementRefs.get(this.selectedCardIndex).nativeElement.offsetWidth;
      this.transformCards();
    }
  }
  onCirclesChange() {
    if (!this.circleElementRefs?.first) {
      return;
    }
    this.circleElementRefs.map((element) => element.nativeElement).forEach((element, index) => {
      this.subscriptions.add(this.renderer.listen(element, "click", () => {
        this.focusTrackItem(index);
      }));
    });
    const width2 = this.circleElementRefs.first.nativeElement.getBoundingClientRect().width;
    if (width2 > DEFAULT_TAB_WIDTH) {
      this.tabWidth = this.circleElementRefs.first.nativeElement.getBoundingClientRect().width + SPACE_BETWEEN_TABS;
    }
    this.changeTabsCount();
    this.visibleEvents = this.trackItems.slice(this.firstCircleInView, this.firstCircleInView + this.visibleTabsCount).filter((event) => !event.isFlag);
  }
  onKeyDown(event) {
    if (!this.navigable) {
      return;
    }
    const code = normalizeKeys(event);
    event.preventDefault();
    if (code === Keys.Home) {
      this.onHomeKey();
    } else if (code === Keys.End) {
      this.onEndKey();
    } else if (code === Keys.ArrowRight) {
      this.onArrowRightKey();
    } else if (code === Keys.ArrowLeft) {
      this.onArrowLeftKey();
    }
  }
  focusTrackItem(index) {
    if (!isDocumentAvailable()) {
      return;
    }
    if (!this.circleElementRefs || index < 0 || index >= this.circleElementRefs.length) {
      return;
    }
    const selectedTrackItem = this.circleElementRefs.find((element) => element.nativeElement.hasAttribute("aria-selected"));
    if (selectedTrackItem) {
      this.removeTrackItemAttributes(selectedTrackItem);
      this.removeCardsAttributes();
    }
    const newTrackItem = this.circleElementRefs.get(index).nativeElement;
    this.setTrackItemAttributes(newTrackItem, index);
  }
  setTrackItemAttributes(element, index) {
    if (!isDocumentAvailable()) {
      return;
    }
    const innerCard = this.cardComponents.get(this.selectedCardIndex).element.nativeElement.querySelector(".k-card");
    const selectedCircle = this.circleElementRefs.get(index).nativeElement;
    this.renderer.addClass(element, "k-focus");
    this.renderer.setAttribute(element, "aria-selected", "true");
    this.assignAriaLabel(innerCard, selectedCircle);
    this.assignAriaDescribedBy(innerCard, selectedCircle);
  }
  removeTrackItemAttributes(element) {
    this.renderer.removeClass(element.nativeElement, "k-focus");
    this.renderer.removeAttribute(element.nativeElement, "aria-selected");
    this.renderer.removeAttribute(element.nativeElement, "id");
    this.renderer.removeAttribute(element.nativeElement, "aria-describedby");
  }
  removeCardsAttributes() {
    this.cardElementRefs.forEach((card) => {
      this.renderer.removeAttribute(card.nativeElement.querySelector(".k-card"), "id");
      this.renderer.removeAttribute(card.nativeElement.querySelector(".k-card"), "aria-label");
    });
  }
  assignAriaLabel(cardElement, dateElement) {
    const dateLabelId = `k-${guid()}`;
    this.renderer.setAttribute(dateElement, "id", dateLabelId);
    this.renderer.setAttribute(cardElement, "aria-label", dateLabelId);
  }
  assignAriaDescribedBy(cardElement, dateElement) {
    const cardId = `k-${guid()}`;
    this.renderer.setAttribute(cardElement, "id", cardId);
    this.renderer.setAttribute(dateElement, "aria-describedby", cardId);
  }
  updateInterval(forward) {
    let start = forward ? this.firstCircleInView + this.visibleTabsCount : this.firstCircleInView - this.visibleTabsCount;
    if (start < 0 || start >= this.trackItems.length) {
      start = 0;
    }
    this.navigateToInterval(start, 0, forward, !forward);
  }
  onHomeKey() {
    if (this.selectedEvent === this.events[0]) {
      return;
    }
    this.navigateToFirstInterval();
  }
  onEndKey() {
    if (this.selectedEvent === this.events[this.events.length - 1]) {
      return;
    }
    this.navigateToLastInterval();
  }
  onArrowRightKey() {
    this.navigateToOtherEvent(true);
  }
  onArrowLeftKey() {
    this.navigateToOtherEvent(false);
  }
  navigateToFirstInterval() {
    this.navigateToInterval(0);
  }
  navigateToLastInterval() {
    const start = Math.floor((this.trackItems.length - 1) / this.visibleTabsCount) * this.visibleTabsCount;
    this.navigateToInterval(start, this.events.length - 1);
  }
  navigateToOtherEvent(direction) {
    const offset3 = direction ? 1 : -1;
    const newIndex = this.selectedEventIndex + offset3;
    if (newIndex < 0 || newIndex >= this.events.length) {
      return;
    }
    if (this.visibleEvents.findIndex((event) => event === this.events[newIndex]) === -1) {
      this.updateInterval(direction);
    } else {
      this.selectedEvent = this.events[newIndex];
      this.selectedCardIndex = this.getOtherSelectedCardIndex(direction);
      this.focusTrackItem(this.selectedEventIndex);
      this.animateCards();
      this.cdr.markForCheck();
    }
  }
  navigateToInterval(start, selectedIndex = 0, selectFirst = false, selectLast = false) {
    const end = start + this.visibleTabsCount < this.trackItems.length ? start + this.visibleTabsCount : void 0;
    const forward = this.firstCircleInView < start;
    this.firstCircleInView = start;
    const interval2 = Math.floor(start / this.visibleTabsCount);
    this.translateValue = interval2 * -100;
    this.animationState = forward ? "right" : "left";
    this.visibleEvents = this.trackItems.slice(this.firstCircleInView, end).filter((event) => !event.isFlag);
    if (selectFirst) {
      this.selectedEvent = this.visibleEvents[0];
    } else if (selectLast) {
      this.selectedEvent = this.visibleEvents[this.visibleEvents.length - 1];
    } else {
      this.selectedEvent = this.events[selectedIndex];
    }
    this.selectedCardIndex = this.getOtherSelectedCardIndex(forward);
    this.cdr.detectChanges();
    this.focusTrackItem(this.selectedEventIndex);
    this.animateCards();
    this.calloutStyle = this.calloutOffset;
    this.cdr.markForCheck();
  }
  animateCards() {
    if (this.animationDuration) {
      this.cardComponents.get(this.selectedCardIndex).event = null;
    }
    this.cardElementRefs.forEach((card, index) => {
      this.renderer.setStyle(card.nativeElement, "transform", this.getTransformation(this.cardWidth, index));
      this.renderer.setStyle(card.nativeElement, "transition-duration", `${this.animationDuration || 0}ms`);
    });
  }
  transformCards() {
    this.cardElementRefs.forEach((card, index) => this.renderer.setStyle(card.nativeElement, "transform", this.getTransformation(this.cardWidth, index)));
  }
  changeTabsCount() {
    this.visibleTabsCount = Math.round(this.scrollableTrackWidth / this.tabWidth);
    if (this.tabFlex !== 100 / this.visibleTabsCount) {
      this.tabFlex = 100 / this.visibleTabsCount;
      this.circleElementRefs.forEach((item) => this.renderer.setStyle(item.nativeElement, "flex", `1 0 ${this.tabFlex}%`));
      this.flagElementRefs.forEach((item) => this.renderer.setStyle(item.nativeElement, "flex", `1 0 ${this.tabFlex}%`));
      this.cdr.detectChanges();
      this.visibleEvents = this.trackItems.slice(this.firstCircleInView, this.firstCircleInView + this.visibleTabsCount).filter((event) => !event.isFlag);
      if (!this.visibleEvents.find((event) => event === this.selectedEvent)) {
        const trackItemIndex = this.trackItems.findIndex((event) => event === this.selectedEvent);
        this.navigateToInterval(trackItemIndex, this.selectedEventIndex);
      }
    }
  }
  l10nChange() {
    if (this.localization.get("previous")) {
      this.previousTitle = this.localization.get("previous");
    }
    if (this.localization.get("next")) {
      this.nextTitle = this.localization.get("next");
    }
    this.cdr.markForCheck();
  }
  static ɵfac = function TimelineHorizontalComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TimelineHorizontalComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(TimelineService), ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TimelineHorizontalComponent,
    selectors: [["kendo-timeline-horizontal"]],
    viewQuery: function TimelineHorizontalComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c352, 5)(_c362, 5)(_c372, 5, ElementRef)(_c382, 5)(_c392, 5)(TimelineCardComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.trackElementRef = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.scrollableTrackElementRef = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.cardElementRefs = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.circleElementRefs = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.flagElementRefs = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.cardComponents = _t);
      }
    },
    inputs: {
      events: "events",
      alterMode: "alterMode",
      collapsibleEvents: "collapsibleEvents",
      navigable: "navigable",
      showDateLabels: "showDateLabels",
      animationDuration: "animationDuration",
      eventHeight: "eventHeight",
      dateFormat: "dateFormat",
      headerTemplate: "headerTemplate",
      bodyTemplate: "bodyTemplate",
      actionsTemplate: "actionsTemplate"
    },
    exportAs: ["kendoTimelineHorizontal"],
    features: [ɵɵProvidersFeature([]), ɵɵNgOnChangesFeature],
    decls: 12,
    vars: 16,
    consts: [["track", ""], ["scrollableTrack", ""], ["trackFlag", ""], ["trackCircle", ""], ["card", ""], [1, "k-timeline-track-wrap"], ["kendoButton", "", "icon", "caret-alt-left", "rounded", "full", "tabindex", "-1", "type", "button", 1, "k-timeline-arrow", "k-timeline-arrow-left", 3, "click", "svgIcon", "title", "disabled"], ["kendoButton", "", "icon", "caret-alt-right", "rounded", "full", "tabindex", "-1", "type", "button", 1, "k-timeline-arrow", "k-timeline-arrow-right", 3, "click", "svgIcon", "title", "disabled"], [1, "k-timeline-track"], [1, "k-timeline-scrollable-wrap", 3, "transitionend"], [1, "k-timeline-events-list"], [1, "k-timeline-scrollable-wrap", 3, "ngStyle"], [3, "resize", "rateLimit"], [1, "k-timeline-flag-wrap", "k-timeline-track-item", 3, "ngStyle"], [1, "k-timeline-track-item", 3, "ngStyle"], [1, "k-timeline-flag"], [1, "k-timeline-track-item", 3, "click", "ngStyle"], [1, "k-timeline-date-wrap"], [1, "k-timeline-date"], [1, "k-timeline-circle"], [1, "k-timeline-event"], [1, "k-timeline-event", 3, "transitionend"], ["orientation", "horizontal", 3, "event", "expanded", "collapsible", "calloutStyle", "ngStyle", "tabIndex", "navigable", "index", "headerTemplate", "bodyTemplate", "actionsTemplate", "eventHeight"]],
    template: function TimelineHorizontalComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "div", 5, 0)(2, "button", 6);
        ɵɵlistener("click", function TimelineHorizontalComponent_Template_button_click_2_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.previousClick());
        });
        ɵɵelementEnd();
        ɵɵelementStart(3, "button", 7);
        ɵɵlistener("click", function TimelineHorizontalComponent_Template_button_click_3_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.nextClick());
        });
        ɵɵelementEnd();
        ɵɵelementStart(4, "div", 8)(5, "ul", 9, 1);
        ɵɵlistener("@trackSlide.done", function TimelineHorizontalComponent_Template_ul_animation_trackSlide_done_5_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onSlideDone());
        })("transitionend", function TimelineHorizontalComponent_Template_ul_transitionend_5_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onTrackTransitionEnd());
        });
        ɵɵrepeaterCreate(7, TimelineHorizontalComponent_For_8_Template, 2, 2, null, null, ɵɵrepeaterTrackByIdentity);
        ɵɵelementEnd()()();
        ɵɵelementStart(9, "div", 10);
        ɵɵconditionalCreate(10, TimelineHorizontalComponent_Conditional_10_Template, 3, 8, "ul", 11);
        ɵɵelementStart(11, "kendo-resize-sensor", 12);
        ɵɵlistener("resize", function TimelineHorizontalComponent_Template_kendo_resize_sensor_resize_11_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onResize());
        });
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵadvance(2);
        ɵɵproperty("svgIcon", ctx.svgLeftIcon)("title", ctx.previousTitle)("disabled", ctx.isFirstRange);
        ɵɵadvance();
        ɵɵproperty("svgIcon", ctx.svgRightIcon)("title", ctx.nextTitle)("disabled", ctx.isLastRange);
        ɵɵadvance(2);
        ɵɵproperty("@trackSlide", ɵɵpureFunction2(13, _c342, ctx.animationState, ɵɵpureFunction1(11, _c40, ctx.translateValue)));
        ɵɵattribute("role", "tablist")("tabindex", "0");
        ɵɵadvance(2);
        ɵɵrepeater(ctx.trackItems);
        ɵɵadvance(3);
        ɵɵconditional(ctx.selectedEvent ? 10 : -1);
        ɵɵadvance();
        ɵɵproperty("rateLimit", 10);
      }
    },
    dependencies: [ButtonComponent, NgStyle, TimelineCardComponent, DatePipe, ResizeSensorComponent],
    encapsulation: 2,
    data: {
      animation: [trigger("trackSlide", [state("left", style({
        transform: `translateX({{transformValue}}%)`
      }), {
        params: {
          transformValue: "0"
        }
      }), state("right", style({
        transform: `translateX({{transformValue}}%)`
      }), {
        params: {
          transformValue: "0"
        }
      }), state("center", style({
        transform: `translateX(0)`
      }))]), trigger("eventsSlide", [transition("* => right", [animate("{{animationDuration}}ms", style({
        transform: `translateX(-100%)`
      }))], {
        params: {
          animationDuration: "400"
        }
      }), transition("* => left", [animate("{{animationDuration}}ms", style({
        transform: `translateX(100%)`
      }))], {
        params: {
          animationDuration: "400"
        }
      })])]
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimelineHorizontalComponent, [{
    type: Component,
    args: [{
      animations: [trigger("trackSlide", [state("left", style({
        transform: `translateX({{transformValue}}%)`
      }), {
        params: {
          transformValue: "0"
        }
      }), state("right", style({
        transform: `translateX({{transformValue}}%)`
      }), {
        params: {
          transformValue: "0"
        }
      }), state("center", style({
        transform: `translateX(0)`
      }))]), trigger("eventsSlide", [transition("* => right", [animate("{{animationDuration}}ms", style({
        transform: `translateX(-100%)`
      }))], {
        params: {
          animationDuration: "400"
        }
      }), transition("* => left", [animate("{{animationDuration}}ms", style({
        transform: `translateX(100%)`
      }))], {
        params: {
          animationDuration: "400"
        }
      })])],
      providers: [],
      exportAs: "kendoTimelineHorizontal",
      selector: "kendo-timeline-horizontal",
      template: `
        <div class="k-timeline-track-wrap" #track>
          <button
            kendoButton
            [svgIcon]="svgLeftIcon"
            icon="caret-alt-left"
            class="k-timeline-arrow k-timeline-arrow-left"
            rounded="full"
            [title]="previousTitle"
            (click)="previousClick()"
            [disabled]="isFirstRange"
            tabindex="-1"
            type="button"
          ></button>
          <button
            kendoButton
            [svgIcon]="svgRightIcon"
            icon="caret-alt-right"
            class="k-timeline-arrow k-timeline-arrow-right"
            rounded="full"
            [title]="nextTitle"
            (click)="nextClick()"
            [disabled]="isLastRange"
            tabindex="-1"
            type="button"
          ></button>
          <div class="k-timeline-track">
            <ul class="k-timeline-scrollable-wrap"
              #scrollableTrack
              [attr.role]="'tablist'"
              [attr.tabindex]="'0'"
              [@trackSlide]="{value: animationState, params: {transformValue: this.translateValue}}"
              (@trackSlide.done)="onSlideDone()"
              (transitionend)="onTrackTransitionEnd()"
              >
              @for (event of trackItems; track event; let index = $index) {
                @if (event.isFlag) {
                  <li
                    #trackFlag
                    class="k-timeline-flag-wrap k-timeline-track-item"
                    [attr.role]="'none'"
                    [attr.aria-hidden]="true"
                    [ngStyle]="tabStyle()"
                    >
                    <span class="k-timeline-flag">{{ event.isFlag }}</span>
                  </li>
                }
                @if (!event.isFlag) {
                  <li
                    #trackCircle
                    class="k-timeline-track-item"
                    [attr.role]="'tab'"
                    (click)="navigateToEvent(index)"
                    [ngStyle]="tabStyle()"
                    >
                    <div class="k-timeline-date-wrap">
                      @if (showDateLabels) {
                        <span class="k-timeline-date">
                          {{ event.date | kendoDate: dateFormat }}
                        </span>
                      }
                    </div>
                    <span class="k-timeline-circle"></span>
                  </li>
                }
              }
            </ul>
          </div>
        </div>
        <div class="k-timeline-events-list">
          @if (selectedEvent) {
            <ul
              class="k-timeline-scrollable-wrap"
              [@eventsSlide]="{value: animationState, params: {animationDuration: this.animationDuration || 0}}"
              (@eventsSlide.done)="onSlideDone()"
              [ngStyle]="{'transform-origin': 'left top'}"
              >
              @for (event of eventsInInterval; track event; let index = $index) {
                <li
                  #card
                  class="k-timeline-event"
                  (transitionend)="onTransitionEnd()"
                  >
                  <kendo-timeline-card
                    [event]="selectedCardIndex === index ? selectedEvent : null"
                    [expanded]="true"
                    [collapsible]="collapsibleEvents"
                    [calloutStyle]="selectedCardIndex === index ? calloutStyle : {}"
                    [ngStyle]="{visibility: selectedCardIndex === index ? 'visible' : 'hidden' }"
                    [tabIndex]="selectedCardIndex === index ? '0' : '-1'"
                    [navigable]="navigable"
                    [index]="selectedEventIndex"
                    [headerTemplate]="headerTemplate"
                    [bodyTemplate]="bodyTemplate"
                    [actionsTemplate]="actionsTemplate"
                    [eventHeight]="eventHeight"
                    orientation="horizontal"
                    >
                  </kendo-timeline-card>
                </li>
              }
            </ul>
          }
          <kendo-resize-sensor (resize)="onResize()" [rateLimit]="10"></kendo-resize-sensor>
        </div>
        `,
      standalone: true,
      imports: [ButtonComponent, NgStyle, TimelineCardComponent, DatePipe, ResizeSensorComponent]
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: NgZone
  }, {
    type: Renderer2
  }, {
    type: TimelineService
  }, {
    type: LocalizationService
  }], {
    events: [{
      type: Input
    }],
    alterMode: [{
      type: Input
    }],
    collapsibleEvents: [{
      type: Input
    }],
    navigable: [{
      type: Input
    }],
    showDateLabels: [{
      type: Input
    }],
    animationDuration: [{
      type: Input
    }],
    eventHeight: [{
      type: Input
    }],
    dateFormat: [{
      type: Input
    }],
    headerTemplate: [{
      type: Input
    }],
    bodyTemplate: [{
      type: Input
    }],
    actionsTemplate: [{
      type: Input
    }],
    cardElementRefs: [{
      type: ViewChildren,
      args: ["card", {
        read: ElementRef
      }]
    }],
    circleElementRefs: [{
      type: ViewChildren,
      args: ["trackCircle"]
    }],
    flagElementRefs: [{
      type: ViewChildren,
      args: ["trackFlag"]
    }],
    trackElementRef: [{
      type: ViewChild,
      args: ["track"]
    }],
    scrollableTrackElementRef: [{
      type: ViewChild,
      args: ["scrollableTrack"]
    }],
    cardComponents: [{
      type: ViewChildren,
      args: [TimelineCardComponent]
    }]
  });
})();
var TimelineVerticalComponent = class _TimelineVerticalComponent {
  renderer;
  events = [];
  alterMode;
  collapsibleEvents;
  navigable;
  showDateLabels;
  animationDuration;
  eventWidth;
  dateFormat;
  headerTemplate;
  bodyTemplate;
  actionsTemplate;
  cards;
  dateElementRefs;
  innerDateElementRefs;
  subscriptions = new Subscription();
  constructor(renderer) {
    this.renderer = renderer;
  }
  ngAfterViewInit() {
    this.ariaDescribedByAllEvents();
    this.subscriptions.add(this.innerDateElementRefs.changes.subscribe(() => {
      if (this.innerDateElementRefs?.length > 0) {
        this.ariaDescribedByAllEvents();
      } else {
        this.removeAriaDescribedBy();
      }
    }));
  }
  expand(index) {
    if (index < 0 || index >= this.cards.length) {
      return;
    }
    this.cards.get(index).expand();
  }
  collapse(index) {
    if (index < 0 || index >= this.cards.length) {
      return;
    }
    this.cards.get(index).collapse();
  }
  ariaDescribedByAllEvents() {
    this.cards?.forEach((card, index) => {
      const innerCard = card.element.nativeElement.querySelector(".k-card");
      const innerDate = this.dateElementRefs.get(index).nativeElement.querySelector(".k-timeline-date");
      if (innerDate) {
        this.assignAriaDescribedBy(innerCard, innerDate);
      }
    });
  }
  removeAriaDescribedBy() {
    this.cards?.forEach((card) => {
      const innerCard = card.element.nativeElement.querySelector(".k-card");
      this.renderer.removeAttribute(innerCard, "aria-describedby");
    });
  }
  assignAriaDescribedBy(cardElement, dateElement) {
    const dateLabelId = `k-${guid()}`;
    this.renderer.setAttribute(dateElement, "id", dateLabelId);
    this.renderer.setAttribute(cardElement, "aria-describedby", dateLabelId);
  }
  static ɵfac = function TimelineVerticalComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TimelineVerticalComponent)(ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TimelineVerticalComponent,
    selectors: [["kendo-timeline-vertical"]],
    viewQuery: function TimelineVerticalComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c372, 5)(_c44, 5)(_c45, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.cards = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dateElementRefs = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.innerDateElementRefs = _t);
      }
    },
    inputs: {
      events: "events",
      alterMode: "alterMode",
      collapsibleEvents: "collapsibleEvents",
      navigable: "navigable",
      showDateLabels: "showDateLabels",
      animationDuration: "animationDuration",
      eventWidth: "eventWidth",
      dateFormat: "dateFormat",
      headerTemplate: "headerTemplate",
      bodyTemplate: "bodyTemplate",
      actionsTemplate: "actionsTemplate"
    },
    exportAs: ["kendoTimelineVertical"],
    features: [ɵɵProvidersFeature([])],
    decls: 1,
    vars: 1,
    consts: [["dateWrap", ""], ["card", ""], ["innerDate", ""], [1, "k-timeline-flag-wrap"], [1, "k-timeline-event", 3, "ngClass"], [1, "k-timeline-date-wrap"], [1, "k-timeline-date"], [1, "k-timeline-circle"], ["orientation", "vertical", 3, "event", "expanded", "collapsible", "reversed", "tabIndex", "navigable", "animationDuration", "headerTemplate", "bodyTemplate", "actionsTemplate", "index", "eventWidth"], [1, "k-timeline-flag"]],
    template: function TimelineVerticalComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵconditionalCreate(0, TimelineVerticalComponent_Conditional_0_Template, 3, 0, "ul");
      }
      if (rf & 2) {
        ɵɵconditional(ctx.events && ctx.events.length > 0 ? 0 : -1);
      }
    },
    dependencies: [NgClass, TimelineCardComponent, DatePipe],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimelineVerticalComponent, [{
    type: Component,
    args: [{
      providers: [],
      exportAs: "kendoTimelineVertical",
      selector: "kendo-timeline-vertical",
      template: `
        @if (events && events.length > 0) {
          <ul>
            @for (event of events; track event; let i = $index) {
              @if (event.flag) {
                <li class="k-timeline-flag-wrap">
                  <span class="k-timeline-flag">{{ event.flag }}</span>
                </li>
              }
              <li class="k-timeline-event" [ngClass]="{ 'k-reverse': alterMode && i % 2 === 0 }">
                <div class="k-timeline-date-wrap" #dateWrap>
                  @if (showDateLabels) {
                    <span class="k-timeline-date" #innerDate>
                      {{ event.date | kendoDate: dateFormat }}
                    </span>
                  }
                </div>
                <span class="k-timeline-circle"></span>
                <kendo-timeline-card
                  #card
                  [event]="event"
                  [expanded]="event.expanded || !collapsibleEvents"
                  [collapsible]="collapsibleEvents"
                  [reversed]="alterMode && i % 2 === 0"
                  [tabIndex]="'0'"
                  [navigable]="navigable"
                  [animationDuration]="animationDuration"
                  [headerTemplate]="headerTemplate"
                  [bodyTemplate]="bodyTemplate"
                  [actionsTemplate]="actionsTemplate"
                  [index]="i"
                  [eventWidth]="eventWidth"
                  orientation="vertical"
                  >
                </kendo-timeline-card>
              </li>
            }
          </ul>
        }
        `,
      standalone: true,
      imports: [NgClass, TimelineCardComponent, DatePipe]
    }]
  }], () => [{
    type: Renderer2
  }], {
    events: [{
      type: Input
    }],
    alterMode: [{
      type: Input
    }],
    collapsibleEvents: [{
      type: Input
    }],
    navigable: [{
      type: Input
    }],
    showDateLabels: [{
      type: Input
    }],
    animationDuration: [{
      type: Input
    }],
    eventWidth: [{
      type: Input
    }],
    dateFormat: [{
      type: Input
    }],
    headerTemplate: [{
      type: Input
    }],
    bodyTemplate: [{
      type: Input
    }],
    actionsTemplate: [{
      type: Input
    }],
    cards: [{
      type: ViewChildren,
      args: ["card"]
    }],
    dateElementRefs: [{
      type: ViewChildren,
      args: ["dateWrap"]
    }],
    innerDateElementRefs: [{
      type: ViewChildren,
      args: ["innerDate"]
    }]
  });
})();
var LocalizedTimelineMessagesDirective = class _LocalizedTimelineMessagesDirective extends TimelineMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function LocalizedTimelineMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LocalizedTimelineMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LocalizedTimelineMessagesDirective,
    selectors: [["", "kendoTimelineLocalizedMessages", ""]],
    features: [ɵɵProvidersFeature([{
      provide: TimelineMessages,
      useExisting: forwardRef(() => _LocalizedTimelineMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalizedTimelineMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: TimelineMessages,
        useExisting: forwardRef(() => LocalizedTimelineMessagesDirective)
      }],
      selector: `[kendoTimelineLocalizedMessages]`,
      standalone: true
    }]
  }], () => [{
    type: LocalizationService
  }], null);
})();
var DEFAULT_HORIZONTAL_ANIMATION_DURATION = 400;
var DEFAULT_VERTICAL_ANIMATION_DURATION = 300;
var DEFAULT_EVENT_WIDTH = 400;
var DEFAULT_EVENT_HEIGHT = 600;
var DEFAULT_DATE_FORMAT = "MMMM dd, yyyy";
var TimelineComponent = class _TimelineComponent {
  timelineService;
  /**
   * An array of event instances which will be shown by the Timeline.
   */
  set events(events) {
    if (!isPresent(events)) {
      return;
    }
    this.originalData = events;
    this._events = processItems(this.originalData, this.modelFields);
    this.updateEvents();
  }
  get events() {
    return this._events;
  }
  /**
   * The names of the model fields from which the Timeline will read its data.
   */
  set modelFields(value2) {
    this._modelFields = __spreadValues(__spreadValues({}, defaultModelFields), value2);
    if (this.originalData) {
      this.events = this.originalData;
    }
  }
  get modelFields() {
    return this._modelFields;
  }
  /**
   * Specifies the orientation of the axis.
   *
   * @default 'vertical'
   */
  orientation = "vertical";
  /**
   * Specifies whether to render events alternatingly on both sides of the axis.
   * Applicable when `orientation` is set to `vertical`.
   *
   * @default false
   */
  alterMode = false;
  /**
   * Specifies whether the event cards can be collapsed.
   *
   * @default true
   */
  collapsibleEvents = true;
  /**
   * Specifies whether the user can use dedicated shortcuts to interact with the Timeline.
   *
   * @default true
   */
  navigable = true;
  /**
   * Specifies whether an event's date label will be visible.
   *
   * @default true
   */
  showDateLabels = true;
  /**
   * Specifies the time for sliding to the next event in `horizontal` mode and the time for collapsing the event in `vertical` mode.
   * The default animation duration values are `300ms` for `horizontal` mode and `400ms` for `vertical` mode.
   *
   * @default true
   */
  animation;
  /**
   * Specifies the order of the Timeline events.
   * `asc` - chronological order
   * `desc` - reverse-chronological order
   *
   * @default 'asc'
   */
  set eventsOrder(order) {
    if (order === this._eventsOrder) {
      return;
    }
    this._eventsOrder = order;
    this.updateEvents();
  }
  get eventsOrder() {
    return this._eventsOrder;
  }
  /**
   * Sets a specific width for the event.
   * This setting is supported only in `vertical` mode.
   *
   * @default 400
   */
  get eventWidth() {
    return this._eventWidth;
  }
  set eventWidth(value2) {
    if (value2) {
      this._eventWidth = value2;
    } else {
      this._eventWidth = DEFAULT_EVENT_WIDTH;
    }
  }
  /**
   * Sets a specific height for the event.
   * This setting is supported only in `horizontal` mode.
   *
   * @default 600
   */
  get eventHeight() {
    return this._eventHeight;
  }
  set eventHeight(value2) {
    if (value2) {
      this._eventHeight = value2;
    } else {
      this._eventHeight = DEFAULT_EVENT_HEIGHT;
    }
  }
  /**
   * @hidden
   */
  get animationDuration() {
    if (typeof this.animation === "number") {
      return this.animation;
    }
    if (typeof this.animation === "boolean" && this.animation || !isPresent(this.animation)) {
      return this.orientation === "horizontal" ? DEFAULT_HORIZONTAL_ANIMATION_DURATION : DEFAULT_VERTICAL_ANIMATION_DURATION;
    }
    return 0;
  }
  /**
   * Specifies the date format for displaying the event date.
   *
   * @default 'MMMM dd, yyyy'
   */
  set dateFormat(value2) {
    if (isPresent(value2) && value2 !== "") {
      this._dateFormat = value2;
    } else {
      this._dateFormat = DEFAULT_DATE_FORMAT;
    }
  }
  get dateFormat() {
    return this._dateFormat;
  }
  hostClass = true;
  get verticalClass() {
    return this.orientation === "vertical";
  }
  get horizontalClass() {
    return this.orientation === "horizontal";
  }
  get alternatingClass() {
    return this.alterMode === true && this.orientation === "vertical";
  }
  get collapsibleClass() {
    return this.collapsibleEvents === true && this.orientation === "vertical";
  }
  /**
   * @hidden
   */
  timelineHorizontal;
  /**
   * @hidden
   */
  timelineVertical;
  /**
   * @hidden
   */
  cardHeaderTemplate;
  /**
   * @hidden
   */
  cardBodyTemplate;
  /**
   * @hidden
   */
  cardActionsTemplate;
  /**
   * Fires when a card is toggled.
   * This event is supported only in `vertical` mode.
   */
  onToggle = new EventEmitter();
  /**
   * Fires when a card's action is clicked.
   */
  onActionClick = new EventEmitter();
  /**
   * Fires when the left or right arrow is clicked.
   * This event is supported only in `horizontal` mode.
   */
  onNavigate = new EventEmitter();
  /**
   * @hidden
   */
  headerTemplate;
  /**
   * @hidden
   */
  bodyTemplate;
  /**
   * @hidden
   */
  actionsTemplate;
  _events = [];
  _modelFields = defaultModelFields;
  _eventWidth = DEFAULT_EVENT_WIDTH;
  _eventHeight = DEFAULT_EVENT_HEIGHT;
  _dateFormat = DEFAULT_DATE_FORMAT;
  originalData = [];
  _eventsOrder = "asc";
  subscriptions = new Subscription();
  constructor(timelineService) {
    this.timelineService = timelineService;
    this.timelineService.timeline = this;
  }
  ngAfterContentInit() {
    this.initTemplates();
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  /**
   * Switches to the previous portion of events.
   * This method is supported only in `horizontal` mode.
   */
  previous() {
    this.timelineHorizontal?.previous();
  }
  /**
   * Switches to the next portion of events.
   * This method is supported only in `horizontal` mode.
   */
  next() {
    this.timelineHorizontal?.next();
  }
  /**
   * Open event details.
   * This method is supported only in `horizontal` mode.
   */
  open(index) {
    this.timelineHorizontal?.open(index);
  }
  /**
   * Expands an event.
   * This method is supported only in `vertical` mode.
   */
  expand(index) {
    this.timelineVertical?.expand(index);
  }
  /**
   * Collapses an event.
   * This method is supported only in `vertical` mode.
   */
  collapse(index) {
    this.timelineVertical?.collapse(index);
  }
  updateEvents() {
    const sortOrder = this._eventsOrder === "asc" ? 1 : -1;
    this._events = [...this._events].sort((a, b) => {
      return sortOrder * (a.date.getTime() - b.date.getTime());
    });
    if (this._events.length > 0) {
      let flag = this._events[0].date.getFullYear() - sortOrder;
      this._events.forEach((event) => {
        if (event.date.getFullYear() === flag) {
          event.flag = null;
        } else {
          flag = event.date.getFullYear();
          event.flag = flag;
        }
      });
    }
  }
  initTemplates() {
    this.headerTemplate = this.cardHeaderTemplate?.first;
    this.bodyTemplate = this.cardBodyTemplate?.first;
    this.actionsTemplate = this.cardActionsTemplate?.first;
    this.subscriptions.add(this.cardHeaderTemplate?.changes.subscribe(() => {
      this.headerTemplate = this.cardHeaderTemplate?.first || null;
    }));
    this.subscriptions.add(this.cardBodyTemplate?.changes.subscribe(() => {
      this.bodyTemplate = this.cardBodyTemplate?.first || null;
    }));
    this.subscriptions.add(this.cardActionsTemplate?.changes.subscribe(() => {
      this.actionsTemplate = this.cardActionsTemplate?.first || null;
    }));
  }
  static ɵfac = function TimelineComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TimelineComponent)(ɵɵdirectiveInject(TimelineService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TimelineComponent,
    selectors: [["kendo-timeline"]],
    contentQueries: function TimelineComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, TimelineCardHeaderTemplateDirective, 4)(dirIndex, TimelineCardBodyTemplateDirective, 4)(dirIndex, TimelineCardActionsTemplateDirective, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.cardHeaderTemplate = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.cardBodyTemplate = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.cardActionsTemplate = _t);
      }
    },
    viewQuery: function TimelineComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(TimelineHorizontalComponent, 5)(TimelineVerticalComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.timelineHorizontal = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.timelineVertical = _t.first);
      }
    },
    hostVars: 10,
    hostBindings: function TimelineComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-timeline", ctx.hostClass)("k-timeline-vertical", ctx.verticalClass)("k-timeline-horizontal", ctx.horizontalClass)("k-timeline-alternating", ctx.alternatingClass)("k-timeline-collapsible", ctx.collapsibleClass);
      }
    },
    inputs: {
      events: "events",
      modelFields: "modelFields",
      orientation: "orientation",
      alterMode: "alterMode",
      collapsibleEvents: "collapsibleEvents",
      navigable: "navigable",
      showDateLabels: "showDateLabels",
      animation: "animation",
      eventsOrder: "eventsOrder",
      eventWidth: "eventWidth",
      eventHeight: "eventHeight",
      dateFormat: "dateFormat"
    },
    outputs: {
      onToggle: "onToggle",
      onActionClick: "onActionClick",
      onNavigate: "onNavigate"
    },
    exportAs: ["kendoTimeline"],
    features: [ɵɵProvidersFeature([TimelineService, LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.timeline"
    }])],
    decls: 4,
    vars: 2,
    consts: () => {
      let i18n_5;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_LAYOUT_FESM2022_PROGRESS_KENDO_ANGULAR_LAYOUT_MJS_5 = goog.getMsg("previous");
        i18n_5 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_LAYOUT_FESM2022_PROGRESS_KENDO_ANGULAR_LAYOUT_MJS_5;
      } else {
        i18n_5 = $localize`:kendo.timeline.previous|The title of the previous button in horizontal orientation.:previous`;
      }
      let i18n_6;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_LAYOUT_FESM2022_PROGRESS_KENDO_ANGULAR_LAYOUT_MJS_6 = goog.getMsg("next");
        i18n_6 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_LAYOUT_FESM2022_PROGRESS_KENDO_ANGULAR_LAYOUT_MJS_6;
      } else {
        i18n_6 = $localize`:kendo.timeline.next|The title of the next button in horizontal orientation.:next`;
      }
      return [["kendoTimelineLocalizedMessages", "", "previous", i18n_5], ["kendoTimelineLocalizedMessages", "", "next", i18n_6], [3, "events", "alterMode", "collapsibleEvents", "navigable", "showDateLabels", "animationDuration", "eventWidth", "dateFormat", "headerTemplate", "bodyTemplate", "actionsTemplate"], [3, "events", "collapsibleEvents", "navigable", "showDateLabels", "animationDuration", "eventHeight", "dateFormat", "headerTemplate", "bodyTemplate", "actionsTemplate"]];
    },
    template: function TimelineComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainer(0, 0)(1, 1);
        ɵɵconditionalCreate(2, TimelineComponent_Conditional_2_Template, 1, 11, "kendo-timeline-vertical", 2);
        ɵɵconditionalCreate(3, TimelineComponent_Conditional_3_Template, 1, 10, "kendo-timeline-horizontal", 3);
      }
      if (rf & 2) {
        ɵɵadvance(2);
        ɵɵconditional(ctx.orientation === "vertical" ? 2 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.orientation === "horizontal" ? 3 : -1);
      }
    },
    dependencies: [LocalizedTimelineMessagesDirective, TimelineVerticalComponent, TimelineHorizontalComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimelineComponent, [{
    type: Component,
    args: [{
      providers: [TimelineService, LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.timeline"
      }],
      exportAs: "kendoTimeline",
      selector: "kendo-timeline",
      template: `
        <ng-container kendoTimelineLocalizedMessages
          i18n-previous="kendo.timeline.previous|The title of the previous button in horizontal orientation."
          previous="previous"
          >
        </ng-container>
        <ng-container kendoTimelineLocalizedMessages
          i18n-next="kendo.timeline.next|The title of the next button in horizontal orientation."
          next="next"
          >
        </ng-container>
        @if (orientation === 'vertical') {
          <kendo-timeline-vertical
            [events]="events"
            [alterMode]="alterMode"
            [collapsibleEvents]="collapsibleEvents"
            [navigable]="navigable"
            [showDateLabels]="showDateLabels"
            [animationDuration]="animationDuration"
            [eventWidth]="eventWidth"
            [dateFormat]="dateFormat"
            [headerTemplate]="headerTemplate"
            [bodyTemplate]="bodyTemplate"
            [actionsTemplate]="actionsTemplate"
            >
          </kendo-timeline-vertical>
        }
        @if (orientation === 'horizontal') {
          <kendo-timeline-horizontal
            [events]="events"
            [collapsibleEvents]="false"
            [navigable]="navigable"
            [showDateLabels]="showDateLabels"
            [animationDuration]="animationDuration"
            [eventHeight]="eventHeight"
            [dateFormat]="dateFormat"
            [headerTemplate]="headerTemplate"
            [bodyTemplate]="bodyTemplate"
            [actionsTemplate]="actionsTemplate"
            >
          </kendo-timeline-horizontal>
        }
        `,
      standalone: true,
      imports: [LocalizedTimelineMessagesDirective, TimelineVerticalComponent, TimelineHorizontalComponent]
    }]
  }], () => [{
    type: TimelineService
  }], {
    events: [{
      type: Input
    }],
    modelFields: [{
      type: Input
    }],
    orientation: [{
      type: Input
    }],
    alterMode: [{
      type: Input
    }],
    collapsibleEvents: [{
      type: Input
    }],
    navigable: [{
      type: Input
    }],
    showDateLabels: [{
      type: Input
    }],
    animation: [{
      type: Input
    }],
    eventsOrder: [{
      type: Input
    }],
    eventWidth: [{
      type: Input
    }],
    eventHeight: [{
      type: Input
    }],
    dateFormat: [{
      type: Input
    }],
    hostClass: [{
      type: HostBinding,
      args: ["class.k-timeline"]
    }],
    verticalClass: [{
      type: HostBinding,
      args: ["class.k-timeline-vertical"]
    }],
    horizontalClass: [{
      type: HostBinding,
      args: ["class.k-timeline-horizontal"]
    }],
    alternatingClass: [{
      type: HostBinding,
      args: ["class.k-timeline-alternating"]
    }],
    collapsibleClass: [{
      type: HostBinding,
      args: ["class.k-timeline-collapsible"]
    }],
    timelineHorizontal: [{
      type: ViewChild,
      args: [TimelineHorizontalComponent]
    }],
    timelineVertical: [{
      type: ViewChild,
      args: [TimelineVerticalComponent]
    }],
    cardHeaderTemplate: [{
      type: ContentChildren,
      args: [TimelineCardHeaderTemplateDirective, {
        descendants: false
      }]
    }],
    cardBodyTemplate: [{
      type: ContentChildren,
      args: [TimelineCardBodyTemplateDirective, {
        descendants: false
      }]
    }],
    cardActionsTemplate: [{
      type: ContentChildren,
      args: [TimelineCardActionsTemplateDirective, {
        descendants: false
      }]
    }],
    onToggle: [{
      type: Output
    }],
    onActionClick: [{
      type: Output
    }],
    onNavigate: [{
      type: Output
    }]
  });
})();
var KENDO_AVATAR = [AvatarComponent, AvatarCustomMessagesComponent];
var KENDO_CARD = [CardComponent, CardActionsComponent, CardBodyComponent, CardFooterComponent, CardHeaderComponent, CardMediaDirective, CardSeparatorDirective, CardSubtitleDirective, CardTitleDirective];
var KENDO_DRAWER = [DrawerComponent, DrawerContainerComponent, DrawerContentComponent, DrawerTemplateDirective, DrawerFooterTemplateDirective, DrawerHeaderTemplateDirective, DrawerItemTemplateDirective];
var KENDO_EXPANSIONPANEL = [ExpansionPanelComponent, ExpansionPanelTitleDirective];
var KENDO_GRIDLAYOUT = [GridLayoutComponent, GridLayoutItemComponent];
var KENDO_PANELBAR = [PanelBarComponent, PanelBarItemComponent, PanelBarContentDirective, PanelBarItemTemplateDirective, PanelBarItemTitleDirective];
var KENDO_SPLITTER = [SplitterComponent, SplitterPaneComponent];
var KENDO_STACKLAYOUT = [StackLayoutComponent];
var KENDO_STEPPER = [StepperComponent, StepperCustomMessagesComponent, StepperIndicatorTemplateDirective, StepperLabelTemplateDirective, StepperStepTemplateDirective];
var KENDO_TABSTRIP = [TabStripComponent, TabStripTabComponent, TabContentDirective, TabTitleDirective, TabStripCustomMessagesComponent];
var KENDO_TILELAYOUT = [TileLayoutComponent, TileLayoutItemBodyComponent, TileLayoutItemComponent, TileLayoutItemHeaderComponent];
var KENDO_TIMELINE = [TimelineComponent, TimelineCustomMessagesComponent, TimelineCardActionsTemplateDirective, TimelineCardBodyTemplateDirective, TimelineCardHeaderTemplateDirective];
var KENDO_LAYOUT = [...KENDO_AVATAR, ...KENDO_CARD, ...KENDO_DRAWER, ...KENDO_EXPANSIONPANEL, ...KENDO_GRIDLAYOUT, ...KENDO_PANELBAR, ...KENDO_SPLITTER, ...KENDO_STACKLAYOUT, ...KENDO_STEPPER, ...KENDO_TABSTRIP, ...KENDO_TILELAYOUT, ...KENDO_TIMELINE];
var AvatarModule = class _AvatarModule {
  static ɵfac = function AvatarModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AvatarModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _AvatarModule,
    imports: [AvatarComponent, AvatarCustomMessagesComponent],
    exports: [AvatarComponent, AvatarCustomMessagesComponent]
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [AvatarComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AvatarModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_AVATAR],
      imports: [...KENDO_AVATAR]
    }]
  }], null, null);
})();
var CardModule = class _CardModule {
  static ɵfac = function CardModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CardModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _CardModule,
    imports: [CardComponent, CardActionsComponent, CardBodyComponent, CardFooterComponent, CardHeaderComponent, CardMediaDirective, CardSeparatorDirective, CardSubtitleDirective, CardTitleDirective],
    exports: [CardComponent, CardActionsComponent, CardBodyComponent, CardFooterComponent, CardHeaderComponent, CardMediaDirective, CardSeparatorDirective, CardSubtitleDirective, CardTitleDirective]
  });
  static ɵinj = ɵɵdefineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CardModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_CARD],
      imports: [...KENDO_CARD]
    }]
  }], null, null);
})();
var DrawerModule = class _DrawerModule {
  static ɵfac = function DrawerModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DrawerModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _DrawerModule,
    imports: [DrawerComponent, DrawerContainerComponent, DrawerContentComponent, DrawerTemplateDirective, DrawerFooterTemplateDirective, DrawerHeaderTemplateDirective, DrawerItemTemplateDirective],
    exports: [DrawerComponent, DrawerContainerComponent, DrawerContentComponent, DrawerTemplateDirective, DrawerFooterTemplateDirective, DrawerHeaderTemplateDirective, DrawerItemTemplateDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [DrawerComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DrawerModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_DRAWER],
      imports: [...KENDO_DRAWER]
    }]
  }], null, null);
})();
var LayoutModule = class _LayoutModule {
  static ɵfac = function LayoutModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LayoutModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _LayoutModule,
    imports: [AvatarComponent, AvatarCustomMessagesComponent, CardComponent, CardActionsComponent, CardBodyComponent, CardFooterComponent, CardHeaderComponent, CardMediaDirective, CardSeparatorDirective, CardSubtitleDirective, CardTitleDirective, DrawerComponent, DrawerContainerComponent, DrawerContentComponent, DrawerTemplateDirective, DrawerFooterTemplateDirective, DrawerHeaderTemplateDirective, DrawerItemTemplateDirective, ExpansionPanelComponent, ExpansionPanelTitleDirective, GridLayoutComponent, GridLayoutItemComponent, PanelBarComponent, PanelBarItemComponent, PanelBarContentDirective, PanelBarItemTemplateDirective, PanelBarItemTitleDirective, SplitterComponent, SplitterPaneComponent, StackLayoutComponent, StepperComponent, StepperCustomMessagesComponent, StepperIndicatorTemplateDirective, StepperLabelTemplateDirective, StepperStepTemplateDirective, TabStripComponent, TabStripTabComponent, TabContentDirective, TabTitleDirective, TabStripCustomMessagesComponent, TileLayoutComponent, TileLayoutItemBodyComponent, TileLayoutItemComponent, TileLayoutItemHeaderComponent, TimelineComponent, TimelineCustomMessagesComponent, TimelineCardActionsTemplateDirective, TimelineCardBodyTemplateDirective, TimelineCardHeaderTemplateDirective],
    exports: [AvatarComponent, AvatarCustomMessagesComponent, CardComponent, CardActionsComponent, CardBodyComponent, CardFooterComponent, CardHeaderComponent, CardMediaDirective, CardSeparatorDirective, CardSubtitleDirective, CardTitleDirective, DrawerComponent, DrawerContainerComponent, DrawerContentComponent, DrawerTemplateDirective, DrawerFooterTemplateDirective, DrawerHeaderTemplateDirective, DrawerItemTemplateDirective, ExpansionPanelComponent, ExpansionPanelTitleDirective, GridLayoutComponent, GridLayoutItemComponent, PanelBarComponent, PanelBarItemComponent, PanelBarContentDirective, PanelBarItemTemplateDirective, PanelBarItemTitleDirective, SplitterComponent, SplitterPaneComponent, StackLayoutComponent, StepperComponent, StepperCustomMessagesComponent, StepperIndicatorTemplateDirective, StepperLabelTemplateDirective, StepperStepTemplateDirective, TabStripComponent, TabStripTabComponent, TabContentDirective, TabTitleDirective, TabStripCustomMessagesComponent, TileLayoutComponent, TileLayoutItemBodyComponent, TileLayoutItemComponent, TileLayoutItemHeaderComponent, TimelineComponent, TimelineCustomMessagesComponent, TimelineCardActionsTemplateDirective, TimelineCardBodyTemplateDirective, TimelineCardHeaderTemplateDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [AvatarComponent, DrawerComponent, ExpansionPanelComponent, PanelBarComponent, PanelBarItemComponent, SplitterComponent, StepperComponent, TabStripComponent, TileLayoutComponent, TimelineComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LayoutModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_LAYOUT],
      imports: [...KENDO_LAYOUT]
    }]
  }], null, null);
})();
var PanelBarModule = class _PanelBarModule {
  static ɵfac = function PanelBarModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PanelBarModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PanelBarModule,
    imports: [PanelBarComponent, PanelBarItemComponent, PanelBarContentDirective, PanelBarItemTemplateDirective, PanelBarItemTitleDirective],
    exports: [PanelBarComponent, PanelBarItemComponent, PanelBarContentDirective, PanelBarItemTemplateDirective, PanelBarItemTitleDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [PanelBarComponent, PanelBarItemComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PanelBarModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_PANELBAR],
      imports: [...KENDO_PANELBAR]
    }]
  }], null, null);
})();
var SplitterModule = class _SplitterModule {
  static ɵfac = function SplitterModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SplitterModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _SplitterModule,
    imports: [SplitterComponent, SplitterPaneComponent],
    exports: [SplitterComponent, SplitterPaneComponent]
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [SplitterComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SplitterModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_SPLITTER],
      imports: [...KENDO_SPLITTER]
    }]
  }], null, null);
})();
var StepperModule = class _StepperModule {
  static ɵfac = function StepperModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _StepperModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _StepperModule,
    imports: [StepperComponent, StepperCustomMessagesComponent, StepperIndicatorTemplateDirective, StepperLabelTemplateDirective, StepperStepTemplateDirective],
    exports: [StepperComponent, StepperCustomMessagesComponent, StepperIndicatorTemplateDirective, StepperLabelTemplateDirective, StepperStepTemplateDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [StepperComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StepperModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_STEPPER],
      imports: [...KENDO_STEPPER]
    }]
  }], null, null);
})();
var TabStripModule = class _TabStripModule {
  static ɵfac = function TabStripModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TabStripModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _TabStripModule,
    imports: [TabStripComponent, TabStripTabComponent, TabContentDirective, TabTitleDirective, TabStripCustomMessagesComponent],
    exports: [TabStripComponent, TabStripTabComponent, TabContentDirective, TabTitleDirective, TabStripCustomMessagesComponent]
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [TabStripComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TabStripModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_TABSTRIP],
      imports: [...KENDO_TABSTRIP]
    }]
  }], null, null);
})();
var ExpansionPanelModule = class _ExpansionPanelModule {
  static ɵfac = function ExpansionPanelModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ExpansionPanelModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _ExpansionPanelModule,
    imports: [ExpansionPanelComponent, ExpansionPanelTitleDirective],
    exports: [ExpansionPanelComponent, ExpansionPanelTitleDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [ExpansionPanelComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExpansionPanelModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_EXPANSIONPANEL],
      imports: [...KENDO_EXPANSIONPANEL]
    }]
  }], null, null);
})();
var TileLayoutModule = class _TileLayoutModule {
  static ɵfac = function TileLayoutModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TileLayoutModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _TileLayoutModule,
    imports: [TileLayoutComponent, TileLayoutItemBodyComponent, TileLayoutItemComponent, TileLayoutItemHeaderComponent],
    exports: [TileLayoutComponent, TileLayoutItemBodyComponent, TileLayoutItemComponent, TileLayoutItemHeaderComponent]
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [TileLayoutComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TileLayoutModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_TILELAYOUT],
      imports: [...KENDO_TILELAYOUT]
    }]
  }], null, null);
})();
var StackLayoutModule = class _StackLayoutModule {
  static ɵfac = function StackLayoutModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _StackLayoutModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _StackLayoutModule,
    imports: [StackLayoutComponent],
    exports: [StackLayoutComponent]
  });
  static ɵinj = ɵɵdefineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StackLayoutModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_STACKLAYOUT],
      imports: [...KENDO_STACKLAYOUT]
    }]
  }], null, null);
})();
var GridLayoutModule = class _GridLayoutModule {
  static ɵfac = function GridLayoutModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _GridLayoutModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _GridLayoutModule,
    imports: [GridLayoutComponent, GridLayoutItemComponent],
    exports: [GridLayoutComponent, GridLayoutItemComponent]
  });
  static ɵinj = ɵɵdefineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GridLayoutModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_GRIDLAYOUT],
      imports: [...KENDO_GRIDLAYOUT]
    }]
  }], null, null);
})();
var TimelineModule = class _TimelineModule {
  static ɵfac = function TimelineModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TimelineModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _TimelineModule,
    imports: [TimelineComponent, TimelineCustomMessagesComponent, TimelineCardActionsTemplateDirective, TimelineCardBodyTemplateDirective, TimelineCardHeaderTemplateDirective],
    exports: [TimelineComponent, TimelineCustomMessagesComponent, TimelineCardActionsTemplateDirective, TimelineCardBodyTemplateDirective, TimelineCardHeaderTemplateDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [TimelineComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimelineModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_TIMELINE],
      imports: [...KENDO_TIMELINE]
    }]
  }], null, null);
})();

// node_modules/@progress/kendo-angular-pdf-export/fesm2022/progress-kendo-angular-pdf-export.mjs
var _c04 = ["*"];
var packageMetadata4 = {
  name: "@progress/kendo-angular-pdf-export",
  productName: "Kendo UI for Angular",
  productCode: "KENDOUIANGULAR",
  productCodes: ["KENDOUIANGULAR"],
  publishDate: 0,
  version: "22.0.1",
  licensingDocsUrl: "https://www.telerik.com/kendo-angular-ui/my-license/"
};
var PDFExportTemplateDirective = class _PDFExportTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function PDFExportTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PDFExportTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PDFExportTemplateDirective,
    selectors: [["", "kendoPDFTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PDFExportTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoPDFTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var FIELDS = ["bottom", "left", "right", "top"];
var PDFExportMarginComponent = class _PDFExportMarginComponent {
  /**
   * Sets the left margin of the PDF page. Accepts a `number` or `string` value.
   *
   * The supported units are `"mm"`, `"cm"`, `"in"`, and `"pt"`. Numbers use points (`"pt"`).
   * @default "pt"
   */
  left;
  /**
   * Sets the top margin of the PDF page. Accepts a `number` or `string` value.
   *
   * The supported units are `"mm"`, `"cm"`, `"in"`, and `"pt"`. Numbers use points (`"pt"`).
   * @default "pt"
   */
  top;
  /**
   * Sets the right margin of the PDF page. Accepts a `number` or `string` value.
   *
   * The supported units are `"mm"`, `"cm"`, `"in"`, and `"pt"`. Numbers use points (`"pt"`).
   * @default "pt"
   */
  right;
  /**
   * Sets the bottom margin of the PDF page. Accepts a `number` or `string` value.
   *
   * The supported units are `"mm"`, `"cm"`, `"in"`, and `"pt"`. Numbers use points (`"pt"`).
   * @default "pt"
   */
  bottom;
  /**
   * @hidden
   */
  get options() {
    const options = {};
    for (let idx4 = 0; idx4 < FIELDS.length; idx4++) {
      const field = FIELDS[idx4];
      const value2 = this[field];
      if (typeof value2 !== "undefined") {
        options[field] = value2;
      }
    }
    return options;
  }
  static ɵfac = function PDFExportMarginComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PDFExportMarginComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PDFExportMarginComponent,
    selectors: [["kendo-pdf-export-margin"]],
    inputs: {
      left: "left",
      top: "top",
      right: "right",
      bottom: "bottom"
    },
    decls: 0,
    vars: 0,
    template: function PDFExportMarginComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PDFExportMarginComponent, [{
    type: Component,
    args: [{
      selector: "kendo-pdf-export-margin",
      template: ``,
      standalone: true
    }]
  }], null, {
    left: [{
      type: Input
    }],
    top: [{
      type: Input
    }],
    right: [{
      type: Input
    }],
    bottom: [{
      type: Input
    }]
  });
})();
var compileTemplate = (templateRef) => {
  const context = {};
  let embeddedView = templateRef.createEmbeddedView(context);
  const result = (data) => {
    Object.assign(context, data);
    embeddedView.detectChanges();
    const templateWrap = document.createElement("span");
    embeddedView.rootNodes.forEach((rootNode) => {
      templateWrap.appendChild(rootNode.cloneNode(true));
    });
    return templateWrap;
  };
  result.destroy = () => {
    embeddedView.destroy();
    embeddedView = null;
  };
  return result;
};
var PDFExportComponent = class _PDFExportComponent {
  element;
  /**
   * If `true`, opens the Print dialog immediately after the PDF loads ([see example](slug:autoprint_pdfexport)).
   * Requires `@progress/kendo-drawing` v1.9.0 or later.
   * @default false
   */
  autoPrint;
  /**
   * Sets the author metadata for the PDF document.
   */
  author;
  /**
   * Specifies whether actual hyperlinks will be produced in the exported PDF file ([see example](slug:hyperlinks_pdfexport)). You can also set a CSS selector to ignore matching links.
   */
  avoidLinks;
  /**
   * Sets a CSS selector for elements that cause page breaks
   * ([see example](slug:multipagecontent_pdfexport#toc-manual-page-breaking)).
   */
  forcePageBreak;
  /**
   * Sets a CSS selector for elements that should not split across pages
   * ([see example](slug:multipagecontent_pdfexport#toc-preventing-page-breaking-in-elements)).
   */
  keepTogether;
  /**
   * Sets the creator metadata for the PDF document.
   * @default "Kendo UI PDF Generator"
   */
  creator = "Kendo UI PDF Generator";
  /**
   * Sets the creation date for the PDF document. Defaults to `new Date()`.
   * @default new Date()
   */
  date;
  /**
   * Sets the image resolution in the exported PDF ([see example](slug:embeddedimages_pdfexport)). By default, images use full resolution.
   */
  imageResolution;
  /**
   * Sets the name of the exported PDF file.
   * @default "export.pdf"
   */
  fileName = "export.pdf";
  /**
   * If `true`, forwards content to `proxyURL` even if the browser supports local file saving.
   */
  forceProxy;
  /**
   * Sets the keywords metadata for the PDF document.
   */
  keywords;
  /**
   * If `true`, sets the page orientation to landscape. The default page orientation is portrait.
   * @default false
   */
  landscape;
  /**
   * Sets the page margins. Numbers use points (`"pt"`).
   */
  margin;
  /**
   * Sets the paper size for the PDF document. Defaults to `"auto"`, which means the content determines the size of the document.
   * The size of the content in pixels matches the size of the output in points (1 pixel = 1/72 inch).
   *
   * If set, the content splits across pages, and allows you to use `repeatHeaders`, `scale`, and a template.
   *
   * The value can be a `PaperSize`, an array of two numbers (width and height in points), or an array of two strings (width and height in units: `"mm"`, `"cm"`, `"in"`, or `"pt"`).
   * @default "auto"
   */
  paperSize;
  /**
   * If `true`, repeats the `<thead>` elements of tables on each page. This helps keep table headers visible on every page
   * ([see example](slug:recurrenttableheaders_pdfexport)).
   */
  repeatHeaders;
  /**
   * Sets a scale factor for the PDF output. Use this to make the PDF content smaller or larger
   * ([see example](slug:scalingofcontent_pdfexport)).
   *
   * @default 1
   */
  scale;
  /**
   * Sets a key/value dictionary of form values sent to the proxy. Use this to send extra data, like Anti-Forgery tokens.
   */
  proxyData;
  /**
   * Sets the server-side proxy URL for streaming the file to the user. You need to implement a proxy if
   * the browser is not capable of saving files locally.
   * The proxy returns the decoded file with the `"Content-Disposition"` header set to `attachment; filename="<fileName.pdf>"`.
   *
   * In the request body, the proxy receives a POST request with the specific parameters
   * ([see example](slug:server_proxy#toc-implementations)).
   */
  proxyURL;
  /**
   * Sets where to display the document returned from the proxy. Use `"_self"` to display in the same window.
   * To display the document in a new window or iframe,
   * the proxy must have the `"Content-Disposition"` header set to `inline; filename="<fileName.pdf>"`.
   * @default "_self"
   */
  proxyTarget;
  /**
   * Sets the producer metadata for the PDF document.
   */
  producer;
  /**
   * Sets the subject metadata for the PDF document.
   */
  subject;
  /**
   * Sets the title metadata for the PDF document.
   */
  title;
  /**
   * @hidden
   */
  pageTemplateDirective;
  /**
   * @hidden
   */
  marginComponent;
  get drawMargin() {
    const marginComponent = this.marginComponent;
    let margin = this.margin;
    if (marginComponent) {
      margin = Object.assign(margin || {}, marginComponent.options);
    }
    return margin;
  }
  pageTemplate;
  constructor(element) {
    this.element = element;
    N(packageMetadata4);
  }
  /**
   * Saves the content as a PDF file with the specified name.
   * @param fileName - The name of the exported file.
   */
  saveAs(fileName = this.fileName) {
    this.save(this.element.nativeElement, fileName);
  }
  /**
   * Exports the content as a `Group` for further processing.
   *
   * @return The root group of the exported scene.
   */
  export() {
    return this.exportElement(this.element.nativeElement);
  }
  save(element, fileName) {
    this.exportElement(element).then((group2) => this.exportGroup(group2, this.pdfOptions())).then((dataUri) => this.saveDataUri(dataUri, fileName, this.saveOptions()));
  }
  exportElement(element) {
    const promise = this.drawElement(element, this.drawOptions());
    const cleanup = this.cleanup.bind(this);
    promise.then(cleanup, cleanup);
    return promise;
  }
  cleanup() {
    if (this.pageTemplate) {
      this.pageTemplate.destroy();
      delete this.pageTemplate;
    }
  }
  drawOptions() {
    if (this.pageTemplateDirective) {
      this.pageTemplate = compileTemplate(this.pageTemplateDirective.templateRef);
    }
    return {
      avoidLinks: this.avoidLinks,
      forcePageBreak: this.forcePageBreak,
      keepTogether: this.keepTogether,
      margin: this.drawMargin,
      paperSize: this.paperSize,
      landscape: this.landscape,
      repeatHeaders: this.repeatHeaders,
      scale: this.scale,
      template: this.pageTemplate
    };
  }
  pdfOptions() {
    return {
      autoPrint: this.autoPrint,
      author: this.author,
      creator: this.creator,
      date: this.date,
      imgDPI: this.imageResolution,
      keywords: this.keywords,
      landscape: this.landscape,
      margin: this.drawMargin,
      multiPage: true,
      paperSize: this.paperSize,
      producer: this.producer,
      subject: this.subject,
      title: this.title
    };
  }
  saveOptions() {
    return {
      forceProxy: this.forceProxy,
      proxyData: this.proxyData,
      proxyTarget: this.proxyTarget,
      proxyURL: this.proxyURL
    };
  }
  drawElement(element, options) {
    return drawDOM(element, options);
  }
  exportGroup(group2, options) {
    return exportPDF(group2, options);
  }
  saveDataUri(dataUri, fileName, options) {
    saveAs(dataUri, fileName, options);
  }
  static ɵfac = function PDFExportComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PDFExportComponent)(ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PDFExportComponent,
    selectors: [["kendo-pdf-export"]],
    contentQueries: function PDFExportComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, PDFExportTemplateDirective, 5)(dirIndex, PDFExportMarginComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.pageTemplateDirective = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.marginComponent = _t.first);
      }
    },
    inputs: {
      autoPrint: "autoPrint",
      author: "author",
      avoidLinks: "avoidLinks",
      forcePageBreak: "forcePageBreak",
      keepTogether: "keepTogether",
      creator: "creator",
      date: "date",
      imageResolution: "imageResolution",
      fileName: "fileName",
      forceProxy: "forceProxy",
      keywords: "keywords",
      landscape: "landscape",
      margin: "margin",
      paperSize: "paperSize",
      repeatHeaders: "repeatHeaders",
      scale: "scale",
      proxyData: "proxyData",
      proxyURL: "proxyURL",
      proxyTarget: "proxyTarget",
      producer: "producer",
      subject: "subject",
      title: "title"
    },
    ngContentSelectors: _c04,
    decls: 2,
    vars: 0,
    template: function PDFExportComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵdomElementStart(0, "div");
        ɵɵprojection(1);
        ɵɵdomElementEnd();
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PDFExportComponent, [{
    type: Component,
    args: [{
      selector: "kendo-pdf-export",
      template: `<div><ng-content></ng-content></div>`,
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }], {
    autoPrint: [{
      type: Input
    }],
    author: [{
      type: Input
    }],
    avoidLinks: [{
      type: Input
    }],
    forcePageBreak: [{
      type: Input
    }],
    keepTogether: [{
      type: Input
    }],
    creator: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    imageResolution: [{
      type: Input
    }],
    fileName: [{
      type: Input
    }],
    forceProxy: [{
      type: Input
    }],
    keywords: [{
      type: Input
    }],
    landscape: [{
      type: Input
    }],
    margin: [{
      type: Input
    }],
    paperSize: [{
      type: Input
    }],
    repeatHeaders: [{
      type: Input
    }],
    scale: [{
      type: Input
    }],
    proxyData: [{
      type: Input
    }],
    proxyURL: [{
      type: Input
    }],
    proxyTarget: [{
      type: Input
    }],
    producer: [{
      type: Input
    }],
    subject: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    pageTemplateDirective: [{
      type: ContentChild,
      args: [PDFExportTemplateDirective, {
        static: false
      }]
    }],
    marginComponent: [{
      type: ContentChild,
      args: [PDFExportMarginComponent, {
        static: false
      }]
    }]
  });
})();
var KENDO_PDFEXPORT = [PDFExportComponent, PDFExportMarginComponent, PDFExportTemplateDirective];
var PDFExportModule = class _PDFExportModule {
  static ɵfac = function PDFExportModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PDFExportModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PDFExportModule,
    imports: [PDFExportComponent, PDFExportMarginComponent, PDFExportTemplateDirective],
    exports: [PDFExportComponent, PDFExportMarginComponent, PDFExportTemplateDirective]
  });
  static ɵinj = ɵɵdefineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PDFExportModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_PDFEXPORT],
      exports: [...KENDO_PDFEXPORT]
    }]
  }], null, null);
})();

// node_modules/@progress/kendo-angular-label/fesm2022/progress-kendo-angular-label.mjs
var _c05 = ["*"];
function FloatingLabelComponent_Conditional_2_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 2);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1("(", ctx_r0.textFor("optional"), ")");
  }
}
function FloatingLabelComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "label", 1);
    ɵɵtext(1);
    ɵɵconditionalCreate(2, FloatingLabelComponent_Conditional_2_Conditional_2_Template, 2, 1, "span", 2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ctx_r0.labelCssClass)("ngStyle", ctx_r0.labelCssStyle)("for", ctx_r0.id);
    ɵɵattribute("id", ctx_r0.labelId);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.text);
    ɵɵadvance();
    ɵɵconditional(ctx_r0.optional ? 2 : -1);
  }
}
function LabelComponent_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 2);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1("(", ctx_r0.textFor("optional"), ")");
  }
}
var isInputElement = (component) => component instanceof HTMLElement;
var inputElementHasAttr = (element, attribute) => element.hasAttribute(attribute);
var getWrappedNativeInput = (element) => element.querySelector("kendo-label > input, kendo-label > textarea, kendo-label > select");
var getRootElement = (element) => {
  if (!element) {
    return null;
  }
  let rootElement = element;
  while (rootElement.parentElement) {
    rootElement = rootElement.parentElement;
  }
  return rootElement;
};
var nativeLabelForTargets = ["BUTTON", "INPUT", "METER", "OUTPUT", "PROGRESS", "SELECT", "TEXTAREA"];
var LabelDirective = class _LabelDirective {
  label;
  renderer;
  zone;
  /**
   * Sets the focusable target for the label.
   * Accepts a [template reference variable](link:site.data.urls.angular['templatesyntax']#template-reference-variables--var-) or an `id` HTML string value.
   */
  for;
  get labelFor() {
    if (typeof this.for === "string") {
      return this.for;
    }
    if (!isDocumentAvailable()) {
      return null;
    }
    const component = this.getFocusableComponent() || {};
    if (isInputElement(component) && !inputElementHasAttr(component, "id")) {
      this.renderer.setAttribute(component, "id", `k-${guid()}`);
    }
    return component.focusableId || component.id || null;
  }
  /**
   * @hidden
   * Allows the user to specify if the label CSS class should be rendered or not.
   */
  labelClass = true;
  clickListener;
  constructor(label, renderer, zone) {
    this.label = label;
    this.renderer = renderer;
    this.zone = zone;
  }
  /**
   * @hidden
   */
  ngAfterViewInit() {
    this.setAriaLabelledby();
    this.zone.runOutsideAngular(() => this.clickListener = this.renderer.listen(this.label.nativeElement, "click", this.handleClick));
  }
  /**
   * @hidden
   */
  ngOnDestroy() {
    if (this.clickListener) {
      this.clickListener();
    }
  }
  /**
   * @hidden
   */
  setAriaLabelledby() {
    if (!isDocumentAvailable()) {
      return;
    }
    const component = this.getFocusableComponent();
    if (component && component.focusableId) {
      const rootElement = getRootElement(this.label.nativeElement);
      const labelTarget = rootElement.querySelector(`#${component.focusableId}`);
      const labelElement = this.label.nativeElement;
      const id3 = labelElement.id || `k-${guid()}`;
      if (!labelElement.getAttribute("id")) {
        this.renderer.setAttribute(labelElement, "id", id3);
      }
      if (component.focusableId.startsWith("k-editor") && component.iframe) {
        component.contentAreaLoaded.subscribe(() => {
          this.zone.runOutsideAngular(() => {
            setTimeout(() => {
              const editableElement = component.container.element.nativeElement.contentDocument.body.firstElementChild;
              this.renderer.setAttribute(editableElement, "aria-label", labelElement.textContent);
            });
          });
        });
      }
      if (!labelTarget) {
        return;
      }
      const existingAriaLabelledBy = labelTarget.hasAttribute("aria-labelledby") && labelTarget.getAttribute("aria-labelledby");
      this.renderer.setAttribute(labelTarget, nativeLabelForTargets.includes(labelTarget.tagName) ? "data-kendo-label-id" : "aria-labelledby", existingAriaLabelledBy && existingAriaLabelledBy !== id3 ? `${existingAriaLabelledBy} ${id3}` : id3);
    }
  }
  getFocusableComponent() {
    const target = this.for;
    return target && target.focus !== void 0 ? target : null;
  }
  handleClick = () => {
    const component = this.getFocusableComponent();
    if (!component) {
      return;
    }
    if (component.focus) {
      component.focus();
    }
  };
  static ɵfac = function LabelDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LabelDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LabelDirective,
    selectors: [["label", "for", ""]],
    hostVars: 3,
    hostBindings: function LabelDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("for", ctx.labelFor);
        ɵɵclassProp("k-label", ctx.labelClass);
      }
    },
    inputs: {
      for: "for",
      labelClass: "labelClass"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LabelDirective, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line @angular-eslint/directive-selector
      selector: "label[for]",
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: NgZone
  }], {
    for: [{
      type: Input
    }],
    labelFor: [{
      type: HostBinding,
      args: ["attr.for"]
    }],
    labelClass: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-label"]
    }]
  });
})();
var packageMetadata5 = {
  name: "@progress/kendo-angular-label",
  productName: "Kendo UI for Angular",
  productCode: "KENDOUIANGULAR",
  productCodes: ["KENDOUIANGULAR"],
  publishDate: 0,
  version: "22.0.1",
  licensingDocsUrl: "https://www.telerik.com/kendo-angular-ui/my-license/"
};
var FloatingLabelInputAdapter = class {
  component;
  onFocus;
  onBlur;
  autoFillStart;
  autoFillEnd;
  onValueChange;
  get focusableId() {
    const component = this.component;
    if ("focusableId" in component) {
      return component.focusableId;
    } else if ("id" in component) {
      return component.id;
    }
    return "";
  }
  set focusableId(value2) {
    const component = this.component;
    if ("focusableId" in component) {
      component.focusableId = value2;
    } else if ("id" in component) {
      component.id = value2;
    }
  }
  constructor(component, formControl) {
    this.component = component;
    const isObservableOrEventEmitter = (event) => event instanceof Observable || event instanceof EventEmitter;
    if (isObservableOrEventEmitter(component.onFocus)) {
      this.onFocus = component.onFocus;
    }
    if (isObservableOrEventEmitter(component.autoFillStart)) {
      this.autoFillStart = component.autoFillStart;
    }
    if (isObservableOrEventEmitter(component.autoFillEnd)) {
      this.autoFillEnd = component.autoFillEnd;
    }
    if (isObservableOrEventEmitter(component.onBlur)) {
      this.onBlur = component.onBlur;
    }
    if (formControl) {
      this.onValueChange = formControl.valueChanges;
    } else if (component.valueChange) {
      this.onValueChange = component.valueChange;
    }
  }
};
var Messages3 = class _Messages extends ComponentMessages {
  /**
   * The optional text.
   */
  optional;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵMessages_BaseFactory;
    return function Messages_Factory(__ngFactoryType__) {
      return (ɵMessages_BaseFactory || (ɵMessages_BaseFactory = ɵɵgetInheritedFactory(_Messages)))(__ngFactoryType__ || _Messages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _Messages,
    selectors: [["kendo-label-messages-base"]],
    inputs: {
      optional: "optional"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Messages3, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line @angular-eslint/directive-selector
      selector: "kendo-label-messages-base"
    }]
  }], null, {
    optional: [{
      type: Input
    }]
  });
})();
var LocalizedMessagesDirective2 = class _LocalizedMessagesDirective extends Messages3 {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function LocalizedMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LocalizedMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LocalizedMessagesDirective,
    selectors: [["", "kendoLabelLocalizedMessages", ""], ["", "kendoFloatingLabelLocalizedMessages", ""]],
    features: [ɵɵProvidersFeature([{
      provide: Messages3,
      useExisting: forwardRef(() => _LocalizedMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalizedMessagesDirective2, [{
    type: Directive,
    args: [{
      providers: [{
        provide: Messages3,
        useExisting: forwardRef(() => LocalizedMessagesDirective2)
      }],
      selector: `
      [kendoLabelLocalizedMessages],
      [kendoFloatingLabelLocalizedMessages]
    `,
      standalone: true
    }]
  }], () => [{
    type: LocalizationService
  }], null);
})();
var isFunction3 = (x) => Object.prototype.toString.call(x) === "[object Function]";
var FloatingLabelComponent = class _FloatingLabelComponent {
  elementRef;
  renderer;
  changeDetectorRef;
  localization;
  /**
   * Gets the current floating label position.
   */
  get labelPosition() {
    if (!this.empty) {
      return "Out";
    }
    return this.focused ? "Out" : "In";
  }
  hostClasses = true;
  get focusedClass() {
    return this.focused;
  }
  get invalidClass() {
    return this.invalid;
  }
  /**
   * @hidden
   */
  direction;
  /**
   * Sets the CSS styles for the internal label element.
   * Accepts values supported by the [`ngStyle`](link:site.data.urls.angular['ngstyleapi']) directive.
   */
  labelCssStyle;
  /**
   * Sets the CSS classes for the label element.
   * Accepts values supported by the [`ngClass`](link:site.data.urls.angular['ngclassapi']) directive.
   */
  labelCssClass;
  /**
   * Sets the `id` attribute of the input inside the floating label.
   */
  id;
  /**
   * Sets the text content of the floating label that describes the input.
   */
  text;
  /**
   * Marks a form field as optional. When enabled, renders the `Optional` text by default.
   * You can customize the text by providing a custom message ([see example]({% slug label_globalization %}#toc-custom-messages)).
   *
   * @default false
   */
  optional;
  /**
   * Fires after the FloatingLabel position changes.
   */
  positionChange = new EventEmitter();
  kendoInput;
  formControl;
  /**
   * @hidden
   */
  focused = false;
  /**
   * @hidden
   */
  empty = true;
  /**
   * @hidden
   */
  invalid = false;
  /**
   * @hidden
   */
  labelId = `k-${guid()}`;
  subscription;
  autoFillStarted = false;
  constructor(elementRef, renderer, changeDetectorRef, localization) {
    this.elementRef = elementRef;
    this.renderer = renderer;
    this.changeDetectorRef = changeDetectorRef;
    this.localization = localization;
    N(packageMetadata5);
    this.direction = localization.rtl ? "rtl" : "ltr";
    this.renderer.removeAttribute(this.elementRef.nativeElement, "id");
  }
  /**
   * @hidden
   */
  ngAfterContentInit() {
    if (!isDocumentAvailable()) {
      return;
    }
    this.validateSetup();
    const control = new FloatingLabelInputAdapter(this.kendoInput || this.formControl.valueAccessor, this.formControl);
    this.addHandlers(control);
    this.setLabelFor(control);
  }
  ngAfterViewInit() {
    if (this.kendoInput) {
      this.setAriaLabelledby(this.kendoInput);
    }
  }
  /**
   * @hidden
   */
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
  }
  /**
   * @hidden
   */
  textFor(key) {
    return this.localization.get(key);
  }
  subscribe(control, eventName, handler) {
    if (control[eventName] instanceof EventEmitter) {
      const subscription = control[eventName].subscribe(handler);
      if (!this.subscription) {
        this.subscription = subscription;
      } else {
        this.subscription.add(subscription);
      }
    }
  }
  updateState() {
    const empty2 = (value2) => {
      if (value2 === 0 || value2 === false) {
        return false;
      }
      if (Array.isArray(value2) && !value2.length) {
        return true;
      }
      return !value2;
    };
    const formControl = this.formControl;
    if (formControl) {
      const valueAccessor = formControl.valueAccessor;
      if (isFunction3(valueAccessor.isEmpty)) {
        this.empty = valueAccessor.isEmpty();
      } else {
        this.empty = empty2(formControl.value);
      }
      this.invalid = formControl.invalid && (formControl.touched || formControl.dirty);
    } else {
      this.empty = isFunction3(this.kendoInput.isEmpty) ? this.kendoInput.isEmpty() : empty2(this.kendoInput.value);
    }
    if (this.empty) {
      this.renderer.addClass(this.elementRef.nativeElement, "k-empty");
    } else {
      this.renderer.removeClass(this.elementRef.nativeElement, "k-empty");
    }
    this.changeDetectorRef.markForCheck();
  }
  setAriaLabelledby(component) {
    const componentId = component.focusableId || component.id;
    if (componentId) {
      const focusableElement = this.elementRef.nativeElement.querySelector(`#${componentId}`);
      if (!focusableElement) {
        return;
      }
      const existingAriaLabelledBy = focusableElement.hasAttribute("aria-labelledby") && focusableElement.getAttribute("aria-labelledby");
      this.renderer.setAttribute(focusableElement, nativeLabelForTargets.includes(focusableElement.tagName) ? "data-kendo-label-id" : "aria-labelledby", existingAriaLabelledBy && existingAriaLabelledBy !== this.labelId ? `${existingAriaLabelledBy} ${this.labelId}` : this.labelId);
    }
  }
  setLabelFor(control) {
    const controlId = control.focusableId || control.id;
    if (this.id && controlId) {
      this.id = controlId;
    } else if (this.id) {
      control.focusableId = this.id;
    } else if (controlId) {
      this.id = controlId;
    } else {
      const id3 = `k-${guid()}`;
      control.focusableId = id3;
      this.id = id3;
    }
  }
  handleAutofill(control) {
    this.subscribe(control, "autoFillStart", () => {
      this.autoFillStarted = true;
      this.renderer.removeClass(this.elementRef.nativeElement, "k-empty");
    });
    this.subscribe(control, "autoFillEnd", () => {
      if (this.autoFillStarted) {
        this.autoFillStarted = false;
        if (this.empty) {
          this.renderer.addClass(this.elementRef.nativeElement, "k-empty");
        }
      }
    });
  }
  addHandlers(control) {
    const setFocus = (isFocused) => () => {
      this.focused = isFocused;
      this.updateState();
      if (!this.empty) {
        return;
      }
      if (hasObservers(this.positionChange)) {
        this.positionChange.emit(isFocused ? "Out" : "In");
      }
    };
    this.subscribe(control, "onFocus", setFocus(true));
    this.subscribe(control, "onBlur", setFocus(false));
    this.handleAutofill(control);
    const updateState = () => this.updateState();
    updateState();
    this.subscribe(control, "onValueChange", updateState);
  }
  validateSetup() {
    if (!this.formControl && !this.kendoInput) {
      if (isDevMode()) {
        throw new Error("The FloatingLabelComponent requires a Kendo Input component or a forms-bound component to function properly.");
      }
      return;
    }
  }
  static ɵfac = function FloatingLabelComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FloatingLabelComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _FloatingLabelComponent,
    selectors: [["kendo-floatinglabel"]],
    contentQueries: function FloatingLabelComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, KendoInput, 5)(dirIndex, NgControl, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.kendoInput = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.formControl = _t.first);
      }
    },
    hostVars: 7,
    hostBindings: function FloatingLabelComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.direction);
        ɵɵclassProp("k-floating-label-container", ctx.hostClasses)("k-focus", ctx.focusedClass)("k-invalid", ctx.invalidClass);
      }
    },
    inputs: {
      labelCssStyle: "labelCssStyle",
      labelCssClass: "labelCssClass",
      id: "id",
      text: "text",
      optional: "optional"
    },
    outputs: {
      positionChange: "positionChange"
    },
    exportAs: ["kendoFloatingLabel"],
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.floatinglabel"
    }])],
    ngContentSelectors: _c05,
    decls: 3,
    vars: 1,
    consts: () => {
      let i18n_0;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_LABEL_FESM2022_PROGRESS_KENDO_ANGULAR_LABEL_MJS_0 = goog.getMsg("Optional");
        i18n_0 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_LABEL_FESM2022_PROGRESS_KENDO_ANGULAR_LABEL_MJS_0;
      } else {
        i18n_0 = $localize`:kendo.floatinglabel.optional|The text for the optional segment of a FloatingLabel component:Optional`;
      }
      return [["kendoFloatingLabelLocalizedMessages", "", "optional", i18n_0], [1, "k-floating-label", 3, "ngClass", "ngStyle", "for"], [1, "k-label-optional"]];
    },
    template: function FloatingLabelComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵelementContainer(0, 0);
        ɵɵprojection(1);
        ɵɵconditionalCreate(2, FloatingLabelComponent_Conditional_2_Template, 3, 6, "label", 1);
      }
      if (rf & 2) {
        ɵɵadvance(2);
        ɵɵconditional(ctx.text ? 2 : -1);
      }
    },
    dependencies: [LocalizedMessagesDirective2, NgClass, NgStyle],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FloatingLabelComponent, [{
    type: Component,
    args: [{
      selector: "kendo-floatinglabel",
      exportAs: "kendoFloatingLabel",
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.floatinglabel"
      }],
      template: `
        <ng-container kendoFloatingLabelLocalizedMessages
          i18n-optional="kendo.floatinglabel.optional|The text for the optional segment of a FloatingLabel component"
          optional="Optional"
          >
        </ng-container>
        <ng-content></ng-content>
        @if (text) {
          <label [ngClass]="labelCssClass" [ngStyle]="labelCssStyle" [for]="id" [attr.id]="labelId" class="k-floating-label">
            {{ text }}@if (optional) {
            <span class="k-label-optional">({{textFor('optional')}})</span>
          }
        </label>
        }
        `,
      standalone: true,
      imports: [LocalizedMessagesDirective2, NgClass, NgStyle]
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: ChangeDetectorRef
  }, {
    type: LocalizationService
  }], {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-floating-label-container"]
    }],
    focusedClass: [{
      type: HostBinding,
      args: ["class.k-focus"]
    }],
    invalidClass: [{
      type: HostBinding,
      args: ["class.k-invalid"]
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    labelCssStyle: [{
      type: Input
    }],
    labelCssClass: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    text: [{
      type: Input
    }],
    optional: [{
      type: Input
    }],
    positionChange: [{
      type: Output
    }],
    kendoInput: [{
      type: ContentChild,
      args: [KendoInput, {
        static: false
      }]
    }],
    formControl: [{
      type: ContentChild,
      args: [NgControl, {
        static: false
      }]
    }]
  });
})();
var LabelComponent = class _LabelComponent {
  elementRef;
  renderer;
  localization;
  /**
   * Specifies the `dir` attribute value for the component.
   * @hidden
   */
  direction;
  /**
   * Sets the text content of the Label. Use this property to describe the input.
   *
   * @example
   * ```html
   * <kendo-label text="Email"></kendo-label>
   * ```
   */
  text;
  /**
   * Associates the label with a component by a template reference or with an HTML element by `id`.
   *
   * @example
   * ```html
   * <input #myInput />
   * <kendo-label [for]="myInput" text="Username"></kendo-label>
   * ```
   */
  set for(forValue) {
    if (forValue !== this._for) {
      this._for = forValue;
      this.control = forValue;
    }
  }
  get for() {
    return this._for;
  }
  /**
   * Marks a form field as optional. When enabled, the label displays the `Optional` text by default.
   * You can customize the text by providing a custom message. ([See example]({% slug label_globalization %}#toc-custom-messages)).
   *
   * @default false
   * @example
   * ```html
   * <kendo-label text="Phone" [optional]="true"></kendo-label>
   * ```
   */
  optional;
  /**
   * Sets the CSS styles for the label element.
   * Accepts values supported by the [`ngStyle`](link:site.data.urls.angular['ngstyleapi']) directive.
   *
   * @example
   * ```html
   * <kendo-label text="Name" [labelCssStyle]="{ color: 'red' }"></kendo-label>
   * ```
   */
  labelCssStyle;
  /**
   * Sets the CSS classes for the label element.
   * Accepts values supported by the [`ngClass`](link:site.data.urls.angular['ngclassapi']) directive.
   *
   * @example
   * ```html
   * <kendo-label text="Address" [labelCssClass]="'custom-label'"></kendo-label>
   * ```
   */
  labelCssClass;
  labelDirective;
  kendoInput;
  /**
   * @hidden
   */
  control;
  subscriptions = new Subscription();
  _for;
  constructor(elementRef, renderer, localization) {
    this.elementRef = elementRef;
    this.renderer = renderer;
    this.localization = localization;
    N(packageMetadata5);
    this.direction = localization.rtl ? "rtl" : "ltr";
    this.renderer.removeAttribute(this.elementRef.nativeElement, "id");
  }
  /**
   * @hidden
   */
  ngAfterContentInit() {
    if (this.for) {
      return;
    }
    const wrappedNativeInput = getWrappedNativeInput(this.elementRef.nativeElement);
    if (wrappedNativeInput) {
      if (!wrappedNativeInput.hasAttribute("id")) {
        this.renderer.setAttribute(wrappedNativeInput, "id", `k-${guid()}`);
      }
      this.control = wrappedNativeInput;
      return;
    }
    this.control = this.kendoInput;
  }
  /**
   * @hidden
   */
  ngOnInit() {
    this.subscriptions.add(this.localization.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
    }));
  }
  /**
   * @hidden
   */
  ngAfterViewInit() {
    this.labelDirective.setAriaLabelledby();
  }
  /**
   * @hidden
   */
  ngOnDestroy() {
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
    }
  }
  /**
   * @hidden
   */
  textFor(key) {
    return this.localization.get(key);
  }
  static ɵfac = function LabelComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LabelComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _LabelComponent,
    selectors: [["kendo-label"]],
    contentQueries: function LabelComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, KendoInput, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.kendoInput = _t.first);
      }
    },
    viewQuery: function LabelComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(LabelDirective, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.labelDirective = _t.first);
      }
    },
    hostVars: 1,
    hostBindings: function LabelComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.direction);
      }
    },
    inputs: {
      text: "text",
      for: "for",
      optional: "optional",
      labelCssStyle: "labelCssStyle",
      labelCssClass: "labelCssClass"
    },
    exportAs: ["kendoLabel"],
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.label"
    }])],
    ngContentSelectors: _c05,
    decls: 5,
    vars: 7,
    consts: () => {
      let i18n_1;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_LABEL_FESM2022_PROGRESS_KENDO_ANGULAR_LABEL_MJS_1 = goog.getMsg("Optional");
        i18n_1 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_LABEL_FESM2022_PROGRESS_KENDO_ANGULAR_LABEL_MJS_1;
      } else {
        i18n_1 = $localize`:kendo.label.optional|The text for the optional segment of a Label component:Optional`;
      }
      return [["kendoLabelLocalizedMessages", "", "optional", i18n_1], [3, "for", "ngClass", "ngStyle"], [1, "k-label-optional"]];
    },
    template: function LabelComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵelementContainer(0, 0);
        ɵɵelementStart(1, "label", 1);
        ɵɵtext(2);
        ɵɵconditionalCreate(3, LabelComponent_Conditional_3_Template, 2, 1, "span", 2);
        ɵɵelementEnd();
        ɵɵprojection(4);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵclassProp("k-label-empty", !ctx.text);
        ɵɵproperty("for", ctx.control)("ngClass", ctx.labelCssClass)("ngStyle", ctx.labelCssStyle);
        ɵɵadvance();
        ɵɵtextInterpolate1(" ", ctx.text);
        ɵɵadvance();
        ɵɵconditional(ctx.optional ? 3 : -1);
      }
    },
    dependencies: [LocalizedMessagesDirective2, LabelDirective, NgClass, NgStyle],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LabelComponent, [{
    type: Component,
    args: [{
      selector: "kendo-label",
      exportAs: "kendoLabel",
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.label"
      }],
      template: `
        <ng-container kendoLabelLocalizedMessages
          i18n-optional="kendo.label.optional|The text for the optional segment of a Label component"
          optional="Optional"
          >
        </ng-container>
        <label
          [for]="control"
          [class.k-label-empty]="!text"
          [ngClass]="labelCssClass"
          [ngStyle]="labelCssStyle"
          >
          {{ text }}@if (optional) {
          <span class="k-label-optional">({{textFor('optional')}})</span>
        }
        </label>
        <ng-content></ng-content>
        `,
      standalone: true,
      imports: [LocalizedMessagesDirective2, LabelDirective, NgClass, NgStyle]
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: LocalizationService
  }], {
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    text: [{
      type: Input
    }],
    for: [{
      type: Input
    }],
    optional: [{
      type: Input
    }],
    labelCssStyle: [{
      type: Input
    }],
    labelCssClass: [{
      type: Input
    }],
    labelDirective: [{
      type: ViewChild,
      args: [LabelDirective, {
        static: true
      }]
    }],
    kendoInput: [{
      type: ContentChild,
      args: [KendoInput, {
        static: true
      }]
    }]
  });
})();
var CustomMessagesComponent2 = class _CustomMessagesComponent extends Messages3 {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function CustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _CustomMessagesComponent,
    selectors: [["kendo-label-messages"], ["kendo-floatinglabel-messages"]],
    features: [ɵɵProvidersFeature([{
      provide: Messages3,
      useExisting: forwardRef(() => _CustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function CustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CustomMessagesComponent2, [{
    type: Component,
    args: [{
      providers: [{
        provide: Messages3,
        useExisting: forwardRef(() => CustomMessagesComponent2)
      }],
      selector: "kendo-label-messages, kendo-floatinglabel-messages",
      template: ``,
      standalone: true
    }]
  }], () => [{
    type: LocalizationService
  }], null);
})();
var KENDO_LABEL = [LabelDirective, LabelComponent, CustomMessagesComponent2];
var KENDO_FLOATINGLABEL = [FloatingLabelComponent, CustomMessagesComponent2];
var KENDO_LABELS = [...KENDO_LABEL, ...KENDO_FLOATINGLABEL];
var LabelModule = class _LabelModule {
  static ɵfac = function LabelModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LabelModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _LabelModule,
    imports: [LabelDirective, LabelComponent, CustomMessagesComponent2, FloatingLabelComponent, CustomMessagesComponent2],
    exports: [LabelDirective, LabelComponent, CustomMessagesComponent2, FloatingLabelComponent, CustomMessagesComponent2]
  });
  static ɵinj = ɵɵdefineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LabelModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_LABELS],
      exports: [...KENDO_LABELS]
    }]
  }], null, null);
})();
var FloatingLabelModule = class _FloatingLabelModule {
  static ɵfac = function FloatingLabelModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FloatingLabelModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _FloatingLabelModule,
    imports: [FloatingLabelComponent, CustomMessagesComponent2],
    exports: [FloatingLabelComponent, CustomMessagesComponent2]
  });
  static ɵinj = ɵɵdefineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FloatingLabelModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_FLOATINGLABEL],
      imports: [...KENDO_FLOATINGLABEL]
    }]
  }], null, null);
})();

// node_modules/@progress/kendo-angular-upload/fesm2022/progress-kendo-angular-upload.mjs
var _c06 = ["fileSelectButton"];
var _c113 = ["clearButton"];
var _c213 = ["uploadButton"];
function FileListItemActionButtonComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 1);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1("", ctx_r0.progress, "%");
  }
}
function FileListItemActionButtonComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 5);
    ɵɵlistener("pointerdown", function FileListItemActionButtonComponent_Conditional_2_Template_button_pointerdown_0_listener($event) {
      ɵɵrestoreView(_r2);
      return ɵɵresetView($event.preventDefault());
    })("click", function FileListItemActionButtonComponent_Conditional_2_Template_button_click_0_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.onRetryClick());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("svgIcon", ctx_r0.retrySVGIcon);
    ɵɵattribute("tabIndex", -1)("aria-hidden", true)("title", ctx_r0.retryButtonTitle);
  }
}
function FileListItemActionButtonComponent_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 6);
    ɵɵlistener("pointerdown", function FileListItemActionButtonComponent_Conditional_3_Template_button_pointerdown_0_listener($event) {
      ɵɵrestoreView(_r3);
      return ɵɵresetView($event.preventDefault());
    })("click", function FileListItemActionButtonComponent_Conditional_3_Template_button_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.onPauseResumeClick());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("svgIcon", ctx_r0.isPaused ? ctx_r0.playSVGIcon : ctx_r0.pauseSVGIcon)("icon", ctx_r0.isPaused ? "play-sm" : "pause-sm");
    ɵɵattribute("tabIndex", -1)("aria-hidden", true)("title", ctx_r0.pauseResumeButtonTitle);
  }
}
function FileListItemActionButtonComponent_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 7);
    ɵɵlistener("click", function FileListItemActionButtonComponent_Conditional_4_Template_button_click_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.onRemoveCancelClick($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassProp("k-delete", !ctx_r0.isUploading);
    ɵɵproperty("svgIcon", ctx_r0.isUploading ? ctx_r0.cancelSVGIcon : ctx_r0.deleteSVGIcon)("icon", ctx_r0.isUploading ? "cancel" : "x");
    ɵɵattribute("tabIndex", -1)("aria-hidden", true)("title", ctx_r0.actionButtonTitle);
  }
}
var _c311 = () => ({
  visible: false
});
var _c47 = (a0, a1) => ({
  "k-file-validation-message": a0,
  "k-file-size": a1
});
var _c54 = (a0, a1, a2) => ({
  templateRef: a0,
  state: a1,
  $implicit: a2
});
function FileListMultipleItemsComponent_Conditional_4_For_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 6)(1, "span", 8);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelementStart(3, "span", 9);
    ɵɵtext(4);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const file_r1 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("title", file_r1.name);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", file_r1.name, " ");
    ɵɵadvance();
    ɵɵproperty("ngClass", ɵɵpureFunction2(5, _c47, file_r1.validationErrors, !file_r1.validationErrors));
    ɵɵattribute("aria-live", "polite");
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.fileStatusText(file_r1));
  }
}
function FileListMultipleItemsComponent_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵrepeaterCreate(0, FileListMultipleItemsComponent_Conditional_4_For_1_Template, 5, 8, "span", 6, ɵɵrepeaterTrackByIdentity);
    ɵɵelementStart(2, "span", 7);
    ɵɵtext(3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵrepeater(ctx_r1.files);
    ɵɵadvance(3);
    ɵɵtextInterpolate(ctx_r1.batchStatusText);
  }
}
function FileListMultipleItemsComponent_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 4);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.fileInfoTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction3(2, _c54, ctx_r1.fileInfoTemplate.templateRef, ctx_r1.files[0].state, ctx_r1.files));
  }
}
var _c63 = (a0, a1, a2) => ({
  "k-file-validation-message": a0,
  "k-file-size": a1,
  "k-file-summary": a2
});
var _c73 = (a0) => [a0];
function FileListSingleItemComponent_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 6);
    ɵɵtext(1);
    ɵɵelementEnd();
    ɵɵelementStart(2, "span", 7);
    ɵɵtext(3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("title", ctx_r0.file.name);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.file.name);
    ɵɵadvance();
    ɵɵproperty("ngClass", ɵɵpureFunction3(5, _c63, ctx_r0.file.validationErrors, !ctx_r0.file.validationErrors && ctx_r0.isNotYetUploaded, ctx_r0.isUploadSuccessful || ctx_r0.isUploadFailed));
    ɵɵattribute("aria-live", "polite");
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.fileStatusText);
  }
}
function FileListSingleItemComponent_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.fileInfoTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction3(4, _c54, ctx_r0.fileInfoTemplate.templateRef, ctx_r0.file.state, ɵɵpureFunction1(2, _c73, ctx_r0.file)));
  }
}
var _c83 = ["kendo-upload-file-list", ""];
function FileListComponent_For_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-upload-file-list-single-item", 1);
  }
  if (rf & 2) {
    const files_r1 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("disabled", ctx_r1.disabled)("file", files_r1[0])("fileInfoTemplate", ctx_r1.fileInfoTemplate);
  }
}
function FileListComponent_For_1_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-upload-file-list-multiple-items", 2);
  }
  if (rf & 2) {
    const files_r1 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("disabled", ctx_r1.disabled)("files", files_r1)("fileInfoTemplate", ctx_r1.fileInfoTemplate);
  }
}
function FileListComponent_For_1_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 3);
  }
  if (rf & 2) {
    const files_r1 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.fileTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction3(2, _c54, ctx_r1.fileTemplate.templateRef, files_r1[0].state, files_r1));
  }
}
function FileListComponent_For_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "li", 0);
    ɵɵconditionalCreate(1, FileListComponent_For_1_Conditional_1_Template, 1, 3, "kendo-upload-file-list-single-item", 1);
    ɵɵconditionalCreate(2, FileListComponent_For_1_Conditional_2_Template, 1, 3, "kendo-upload-file-list-multiple-items", 2);
    ɵɵconditionalCreate(3, FileListComponent_For_1_Conditional_3_Template, 1, 6, "ng-container", 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const files_r1 = ctx.$implicit;
    const ɵ$index_1_r3 = ctx.$index;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("files", files_r1)("index", ɵ$index_1_r3);
    ɵɵadvance();
    ɵɵconditional(files_r1.length === 1 && !ctx_r1.fileTemplate ? 1 : -1);
    ɵɵadvance();
    ɵɵconditional(files_r1.length > 1 && !ctx_r1.fileTemplate ? 2 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.fileTemplate ? 3 : -1);
  }
}
var _c93 = ["fileSelectInput"];
function UploadComponent_Conditional_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-upload-status-total", 7);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("fileList", ctx_r2.fileList);
  }
}
function UploadComponent_Conditional_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "ul", 9);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("disabled", ctx_r2.disabled)("fileList", ctx_r2.fileList.files)("fileTemplate", ctx_r2.fileTemplate)("fileInfoTemplate", ctx_r2.fileInfoTemplate)("id", ctx_r2.fileListId);
  }
}
function UploadComponent_Conditional_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-upload-action-buttons", 10);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("disabled", ctx_r2.disabled)("actionsLayout", ctx_r2.actionsLayout);
  }
}
var _c103 = ["*"];
function FileSelectComponent_Conditional_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "ul", 8);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("disabled", ctx_r2.disabled)("fileList", ctx_r2.fileList.files)("fileTemplate", ctx_r2.fileTemplate)("fileInfoTemplate", ctx_r2.fileInfoTemplate)("id", ctx_r2.fileListId);
  }
}
var FileState;
(function(FileState2) {
  FileState2[FileState2["Failed"] = 0] = "Failed";
  FileState2[FileState2["Initial"] = 1] = "Initial";
  FileState2[FileState2["Selected"] = 2] = "Selected";
  FileState2[FileState2["Uploaded"] = 3] = "Uploaded";
  FileState2[FileState2["Uploading"] = 4] = "Uploading";
  FileState2[FileState2["Paused"] = 5] = "Paused";
})(FileState || (FileState = {}));
var FileMap = class {
  _files;
  constructor() {
    this._files = {};
  }
  add(file) {
    const uid = file.uid;
    if (this.has(uid)) {
      if (file.validationErrors && file.validationErrors.length > 0) {
        this._files[uid].unshift(file);
      } else {
        this._files[uid].push(file);
      }
    } else {
      this._files[uid] = [file];
    }
  }
  remove(uid) {
    if (this.has(uid)) {
      this._files[uid] = null;
      delete this._files[uid];
    }
  }
  clear() {
    const allFiles = this._files;
    for (const uid in allFiles) {
      if (allFiles.hasOwnProperty(uid)) {
        for (const file of allFiles[uid]) {
          if (file.httpSubscription) {
            file.httpSubscription.unsubscribe();
          }
        }
        allFiles[uid] = null;
        delete allFiles[uid];
      }
    }
  }
  has(uid) {
    return uid in this._files;
  }
  get(uid) {
    return this._files[uid];
  }
  setFilesState(files, state2) {
    for (const file of files) {
      this.setFilesStateByUid(file.uid, state2);
    }
  }
  setFilesStateByUid(uid, state2) {
    this.get(uid).forEach((f) => {
      f.state = state2;
    });
  }
  get count() {
    return Object.getOwnPropertyNames(this._files).length;
  }
  get files() {
    const initial2 = this._files;
    const transformed = [];
    for (const uid in initial2) {
      if (initial2.hasOwnProperty(uid)) {
        transformed.push(initial2[uid]);
      }
    }
    return transformed;
  }
  get filesFlat() {
    const initial2 = this._files;
    const transformed = [];
    for (const uid in initial2) {
      if (initial2.hasOwnProperty(uid)) {
        const current = initial2[uid];
        current.forEach((file) => {
          transformed.push(file);
        });
      }
    }
    return transformed;
  }
  get filesToUpload() {
    const files = this._files;
    const notUploaded = [];
    for (const uid in files) {
      if (files.hasOwnProperty(uid)) {
        const currentFiles = files[uid];
        let currentFilesValid = true;
        for (const file of currentFiles) {
          if (file.state !== FileState.Selected || file.validationErrors && file.validationErrors.length > 0) {
            currentFilesValid = false;
          }
        }
        if (currentFilesValid) {
          notUploaded.push(currentFiles);
        }
      }
    }
    return notUploaded;
  }
  get firstFileToUpload() {
    const files = this._files;
    for (const uid in files) {
      if (files.hasOwnProperty(uid)) {
        const currentFiles = files[uid];
        let currentFilesValid = true;
        for (const file of currentFiles) {
          if (file.state !== FileState.Selected || file.validationErrors && file.validationErrors.length > 0) {
            currentFilesValid = false;
          }
        }
        if (currentFilesValid) {
          return currentFiles;
        }
      }
    }
    return null;
  }
  getFilesWithState(state2) {
    return this.filesFlat.filter((file) => file.state === state2);
  }
  hasFileWithState(fileStates) {
    const files = this._files;
    for (const uid in files) {
      if (files.hasOwnProperty(uid)) {
        const currentFiles = files[uid];
        for (const file of currentFiles) {
          if (fileStates.indexOf(file.state) >= 0) {
            return true;
          }
        }
      }
    }
    return false;
  }
};
var CancelEvent = class {
  /**
   * The files that you canceled during the upload process.
   */
  files;
  /**
   * @hidden
   * Constructs the event arguments for the `cancel` event.
   * @param files - The list of the files that were going to be uploaded.
   */
  constructor(files) {
    this.files = files;
  }
};
var PreventableEvent4 = class {
  prevented = false;
  /**
   * Prevents the default action for a specified event.
   * In this way, the source component suppresses the built-in behavior that follows the event.
   */
  preventDefault() {
    this.prevented = true;
  }
  /**
   * If the event is prevented by any of its subscribers, returns `true`.
   *
   * @returns `true` if the default action was prevented. Otherwise, returns `false`.
   */
  isDefaultPrevented() {
    return this.prevented;
  }
};
var ClearEvent = class extends PreventableEvent4 {
  /**
   * @hidden
   * Constructs the event arguments for the `clear` event.
   */
  constructor() {
    super();
  }
};
var ErrorEvent = class {
  /**
   * The array of files that failed to be uploaded or removed.
   */
  files;
  /**
   * The operation type that failed (`upload` or `remove`).
   */
  operation;
  /**
   * The HTTP response returned by the server containing error details.
   */
  response;
  /**
   * @hidden
   * Constructs the event arguments for the `error` event.
   *
   * @param files - The list of the files that failed to be uploaded or removed.
   * @param operation - The operation type (`upload` or `remove`).
   * @param response - The response object returned by the server.
   */
  constructor(files, operation, response) {
    this.files = files;
    this.operation = operation;
    this.response = response;
  }
};
var PauseEvent = class {
  /**
   * The file that you paused during the upload process.
   */
  file;
  /**
   * @hidden
   * Constructs the event arguments for the `pause` event.
   * @param file - The file that is going to be paused.
   */
  constructor(file) {
    this.file = file;
  }
};
var RemoveEvent = class extends PreventableEvent4 {
  /**
   * An optional object that you send to the `remove` handler as key/value pairs.
   *
   */
  data;
  /**
   * The files that you will remove from the server.
   */
  files;
  /**
   * The headers of the request.
   * You can use this to add custom headers to the remove request.
   */
  headers;
  /**
   * @hidden
   * Constructs the event arguments for the `remove` event.
   * @param files - The list of the files that will be removed.
   * @param headers - The headers of the request.
   */
  constructor(files, headers) {
    super();
    this.files = files;
    this.headers = headers;
  }
};
var ResumeEvent = class {
  /**
   * The file that you resumed during the upload process.
   */
  file;
  /**
   * @hidden
   * Constructs the event arguments for the `resume` event.
   * @param file - The file that is going to be resumed.
   */
  constructor(file) {
    this.file = file;
  }
};
var SelectEvent2 = class extends PreventableEvent4 {
  /**
   * The files that are selected for upload.
   */
  files;
  /**
   * @hidden
   * Constructs the event arguments for the `select` event.
   * @param files - The list of the selected files.
   */
  constructor(files) {
    super();
    this.files = files;
  }
};
var SuccessEvent = class extends PreventableEvent4 {
  /**
   * The files that you successfully uploaded or removed.
   */
  files;
  /**
   * The operation type that succeeded (`upload` or `remove`).
   */
  operation;
  /**
   * The HTTP response that the server returns to confirm success.
   */
  response;
  /**
   * @hidden
   * Constructs the event arguments for the `success` event.
   * @param files - The list of the files that were uploaded or removed.
   * @param operation - The operation type (`upload` or `remove`).
   * @param response - The response object returned by the server.
   */
  constructor(files, operation, response) {
    super();
    this.files = files;
    this.operation = operation;
    this.response = response;
  }
};
var UploadEvent = class extends PreventableEvent4 {
  /**
   * The optional object that you send to the `upload` handler as key/value pairs.
   *
   */
  data;
  /**
   * The files that you will upload to the server.
   */
  files;
  /**
   * The headers of the request.
   * You can use this to add custom headers to the upload request.
   */
  headers;
  /**
   * @hidden
   * Constructs the event arguments for the `upload` event.
   * @param files - The list of the files that will be uploaded.
   * @param headers - The headers of the request.
   */
  constructor(files, headers) {
    super();
    this.files = files;
    this.headers = headers;
  }
};
var UploadProgressEvent = class {
  /**
   * The files that you are currently uploading.
   */
  files;
  /**
   * The upload progress as a percentage from 0 to 100.
   */
  percentComplete;
  /**
   * @hidden
   * Constructs the event arguments for the `uploadprogress` event.
   * @param files - The list of files that are being uploaded.
   * @param percentComplete - The portion that has been uploaded.
   */
  constructor(files, percentComplete) {
    this.files = files;
    this.percentComplete = percentComplete;
  }
};
var fileGroupMap = {
  audio: [".aif", ".iff", ".m3u", ".m4a", ".mid", ".mp3", ".mpa", ".wav", ".wma", ".ogg", ".wav", ".wma", ".wpl"],
  video: [".3g2", ".3gp", ".avi", ".asf", ".flv", ".m4u", ".rm", ".h264", ".m4v", ".mkv", ".mov", ".mp4", ".mpg", ".rm", ".swf", ".vob", ".wmv"],
  image: [".ai", ".dds", ".heic", ".jpe", "jfif", ".jif", ".jp2", ".jps", ".eps", ".bmp", ".gif", ".jpeg", ".jpg", ".png", ".ps", ".psd", ".svg", ".svgz", ".tif", ".tiff"],
  txt: [".doc", ".docx", ".log", ".pages", ".tex", ".wpd", ".wps", ".odt", ".rtf", ".text", ".txt", ".wks"],
  presentation: [".key", ".odp", ".pps", ".ppt", ".pptx"],
  data: [".xlr", ".xls", ".xlsx"],
  programming: [".tmp", ".bak", ".msi", ".cab", ".cpl", ".cur", ".dll", ".dmp", ".drv", ".icns", ".ico", ".link", ".sys", ".cfg", ".ini", ".asp", ".aspx", ".cer", ".csr", ".css", ".dcr", ".htm", ".html", ".js", ".php", ".rss", ".xhtml"],
  pdf: [".pdf"],
  config: [".apk", ".app", ".bat", ".cgi", ".com", ".exe", ".gadget", ".jar", ".wsf"],
  zip: [".7z", ".cbr", ".gz", ".sitx", ".arj", ".deb", ".pkg", ".rar", ".rpm", ".tar.gz", ".z", ".zip", ".zipx"],
  discImage: [".dmg", ".iso", ".toast", ".vcd", ".bin", ".cue", ".mdf"]
};
var fileSVGGroupMap = {
  audio: fileAudioIcon,
  video: fileVideoIcon,
  image: fileImageIcon,
  txt: fileTxtIcon,
  presentation: filePresentationIcon,
  data: fileDataIcon,
  programming: fileProgrammingIcon,
  pdf: filePdfIcon,
  config: fileConfigIcon,
  zip: fileZipIcon,
  discImage: fileDiscImageIcon
};
var getTotalFilesSizeMessage = (files) => {
  let totalSize = 0;
  let i;
  if (typeof files[0].size === "number") {
    for (i = 0; i < files.length; i++) {
      if (files[i].size) {
        totalSize += files[i].size;
      }
    }
  } else {
    return "";
  }
  totalSize /= 1024;
  if (totalSize < 1024) {
    return totalSize.toFixed(2) + " KB";
  } else {
    return (totalSize / 1024).toFixed(2) + " MB";
  }
};
var stripPath = (name) => {
  const slashIndex = name.lastIndexOf("\\");
  return slashIndex !== -1 ? name.substr(slashIndex + 1) : name;
};
var getFileExtension = (fileName) => {
  const rFileExtension = /\.([^\.]+)$/;
  const matches2 = fileName.match(rFileExtension);
  return matches2 ? matches2[0] : "";
};
var validateInitialFileInfo = (file) => {
  if (file instanceof Object && file.hasOwnProperty("name")) {
    return true;
  }
  return false;
};
var validateInitialFileSelectFile = (file) => {
  if (file instanceof File || validateInitialFileInfo(file)) {
    return true;
  }
  return false;
};
var getInitialFileInfo = (fakeFile) => {
  fakeFile.extension = fakeFile.extension || getFileExtension(fakeFile.name);
  fakeFile.name = fakeFile.name;
  fakeFile.size = fakeFile.size || 0;
  if (!fakeFile.hasOwnProperty("state")) {
    fakeFile.state = FileState.Initial;
  }
  if (!fakeFile.hasOwnProperty("uid")) {
    fakeFile.uid = guid();
  }
  return fakeFile;
};
var convertFileToFileInfo = (file) => {
  const fileInfo = getFileInfo(file);
  fileInfo.uid = guid();
  fileInfo.state = FileState.Selected;
  return fileInfo;
};
var getFileInfo = (rawFile) => {
  const fileName = rawFile.name;
  const fileSize = rawFile.size;
  return {
    extension: getFileExtension(fileName),
    name: fileName,
    rawFile,
    size: fileSize,
    state: FileState.Selected
  };
};
var getAllFileInfo = (rawFiles) => {
  const allFileInfo = new Array();
  let i;
  for (i = 0; i < rawFiles.length; i++) {
    allFileInfo.push(getFileInfo(rawFiles[i]));
  }
  return allFileInfo;
};
var fileHasValidationErrors = (file) => {
  if (file.validationErrors && file.validationErrors.length > 0) {
    return true;
  }
  return false;
};
var filesHaveValidationErrors = (files) => {
  for (const file of files) {
    if (fileHasValidationErrors(file)) {
      return true;
    }
  }
  return false;
};
var inputFiles = (input) => {
  if (input.files) {
    return getAllFileInfo(input.files);
  } else {
    const fileNames = input.value.split("|").map((file, index) => {
      const fileName = file.trim();
      return {
        extension: getFileExtension(fileName),
        name: stripPath(fileName),
        rawFile: null,
        size: (index + 1) * 1e3,
        state: FileState.Selected
      };
    });
    return fileNames;
  }
};
var assignGuidToFiles = (files, isUnique) => {
  const uid = guid();
  return files.map((file) => {
    file.uid = isUnique ? guid() : uid;
    return file;
  });
};
var focusableRegex2 = /^(?:a|input|select|textarea|button|object)$/i;
var IGNORE_TARGET_CLASSES = "k-icon k-select k-input k-multiselect-wrap";
var UPLOAD_CLASSES = "k-upload-button k-clear-selected k-upload-selected k-upload-action k-file";
var isVisible = (element) => {
  if (!isDocumentAvailable()) {
    return false;
  }
  const rect = element.getBoundingClientRect();
  return !!(rect.width && rect.height) && window.getComputedStyle(element).visibility !== "hidden";
};
var toClassList2 = (classNames) => String(classNames).trim().split(" ");
var hasClasses2 = (element, classNames) => {
  const namesList = toClassList2(classNames);
  return Boolean(toClassList2(element.className).find((className) => namesList.indexOf(className) >= 0));
};
var isFocusable3 = (element, checkVisibility = true) => {
  if (element.tagName) {
    const tagName = element.tagName.toLowerCase();
    const tabIndex = element.getAttribute("tabIndex");
    const validTabIndex = tabIndex !== null && !isNaN(tabIndex) && tabIndex > -1;
    let focusable = false;
    if (focusableRegex2.test(tagName)) {
      focusable = !element.disabled;
    } else {
      focusable = validTabIndex;
    }
    return focusable && (!checkVisibility || isVisible(element));
  }
  return false;
};
var getFileGroupCssClass = (fileExtension) => {
  const initial2 = "file";
  for (const group2 in fileGroupMap) {
    if (fileGroupMap[group2].indexOf(fileExtension) >= 0) {
      if (group2 === "discImage") {
        return `${initial2}-disc-image`;
      }
      return `${initial2}-${group2}`;
    }
  }
  return initial2;
};
var isPresent6 = (value2) => value2 !== null && value2 !== void 0;
var fileSVGGroupIcon = (extension) => {
  const initial2 = fileIcon;
  if (extension) {
    for (const group2 in fileGroupMap) {
      if (fileGroupMap[group2].indexOf(extension.toLowerCase()) >= 0) {
        return fileSVGGroupMap[group2];
      }
    }
  }
  return initial2;
};
var fileGroupClass = (extension) => getFileGroupCssClass(extension || "");
var ChunkMap = class {
  _files;
  constructor() {
    this._files = {};
  }
  add(uid, totalChunks) {
    const initialChunkInfo = {
      index: 0,
      position: 0,
      retries: 0,
      totalChunks
    };
    this._files[uid] = initialChunkInfo;
    return initialChunkInfo;
  }
  remove(uid) {
    if (this.has(uid)) {
      this._files[uid] = null;
      delete this._files[uid];
    }
  }
  has(uid) {
    return uid in this._files;
  }
  get(uid) {
    return this._files[uid];
  }
};
var UploadService = class _UploadService {
  http;
  cancelEvent = new EventEmitter();
  clearEvent = new EventEmitter();
  completeEvent = new EventEmitter();
  errorEvent = new EventEmitter();
  pauseEvent = new EventEmitter();
  removeEvent = new EventEmitter();
  resumeEvent = new EventEmitter();
  selectEvent = new EventEmitter();
  successEvent = new EventEmitter();
  uploadEvent = new EventEmitter();
  uploadProgressEvent = new EventEmitter();
  /**
   * Required for the `ControlValueAccessor` integration
   */
  changeEvent = new EventEmitter();
  /**
   * Default async settings
   */
  async = {
    autoUpload: true,
    batch: false,
    chunk: false,
    concurrent: true,
    removeField: "fileNames",
    removeHeaders: new HttpHeaders(),
    removeMethod: "POST",
    removeUrl: "",
    responseType: "json",
    saveField: "files",
    saveHeaders: new HttpHeaders(),
    saveMethod: "POST",
    saveUrl: "",
    withCredentials: true
  };
  /**
   * Default chunk settings
   */
  chunk = {
    autoRetryAfter: 100,
    size: 1024 * 1024,
    maxAutoRetries: 1,
    resumable: true
  };
  component = "Upload";
  chunkMap = new ChunkMap();
  fileList = new FileMap();
  constructor(http) {
    this.http = http;
  }
  get files() {
    return this.fileList;
  }
  setChunkSettings(settings) {
    if (settings !== false) {
      this.async.chunk = true;
      if (typeof settings === "object") {
        this.chunk = Object.assign({}, this.chunk, settings);
      }
    }
  }
  onChange() {
    const files = this.fileList.filesFlat.filter((file) => {
      return file.state === FileState.Initial || file.state === FileState.Uploaded;
    });
    this.changeEvent.emit(files.length > 0 ? files : null);
  }
  addFiles(files) {
    const selectEventArgs = new SelectEvent2(files);
    this.selectEvent.emit(selectEventArgs);
    if (!selectEventArgs.isDefaultPrevented()) {
      for (const file of files) {
        this.fileList.add(file);
      }
      if (this.async.autoUpload) {
        this.uploadFiles();
      }
    }
    if (this.component === "FileSelect") {
      const flatFiles = this.fileList.filesFlat;
      this.changeEvent.emit(flatFiles.length > 0 ? flatFiles : null);
    }
  }
  addInitialFiles(initialFiles) {
    this.fileList.clear();
    initialFiles.forEach((file) => {
      const fakeFile = getInitialFileInfo(file);
      this.fileList.add(fakeFile);
    });
  }
  addInitialFileSelectFiles(initialFiles) {
    this.fileList.clear();
    initialFiles.forEach((file) => {
      if (file instanceof File) {
        this.fileList.add(convertFileToFileInfo(file));
      } else {
        this.fileList.add(getInitialFileInfo(file));
      }
    });
  }
  resumeFile(uid) {
    const fileToResume = this.fileList.get(uid);
    this.resumeEvent.emit(new ResumeEvent(fileToResume[0]));
    this.fileList.setFilesStateByUid(uid, FileState.Uploading);
    this._uploadFiles([fileToResume]);
  }
  pauseFile(uid) {
    const pausedFile = this.fileList.get(uid)[0];
    this.pauseEvent.emit(new PauseEvent(pausedFile));
    this.fileList.setFilesStateByUid(uid, FileState.Paused);
  }
  removeFiles(uid) {
    const removedFiles = this.fileList.get(uid);
    const removeEventArgs = new RemoveEvent(removedFiles, this.cloneRequestHeaders(this.async.removeHeaders));
    this.removeEvent.emit(removeEventArgs);
    if (!removeEventArgs.isDefaultPrevented()) {
      if (this.component === "Upload" && (removedFiles[0].state === FileState.Uploaded || removedFiles[0].state === FileState.Initial)) {
        this.performRemove(removedFiles, removeEventArgs);
      } else {
        this.fileList.remove(uid);
        if (this.component === "FileSelect") {
          const flatFiles = this.fileList.filesFlat;
          this.changeEvent.emit(flatFiles.length > 0 ? flatFiles : null);
        }
      }
    }
  }
  cancelFiles(uid) {
    const canceledFiles = this.fileList.get(uid);
    const cancelEventArgs = new CancelEvent(canceledFiles);
    this.cancelEvent.emit(cancelEventArgs);
    for (const file of canceledFiles) {
      if (file.httpSubscription) {
        file.httpSubscription.unsubscribe();
      }
    }
    this.fileList.remove(uid);
    this.checkAllComplete();
  }
  clearFiles() {
    const clearEventArgs = new ClearEvent();
    this.clearEvent.emit(clearEventArgs);
    if (!clearEventArgs.isDefaultPrevented()) {
      const triggerChange = this.fileList.hasFileWithState([FileState.Initial, FileState.Uploaded]);
      this.fileList.clear();
      if (triggerChange) {
        this.onChange();
      }
    }
  }
  uploadFiles() {
    let filesToUpload = [];
    if (this.async.concurrent) {
      filesToUpload = this.fileList.filesToUpload;
    }
    if (!this.async.concurrent && !this.fileList.hasFileWithState([FileState.Uploading])) {
      filesToUpload = this.fileList.firstFileToUpload ? [this.fileList.firstFileToUpload] : [];
    }
    if (filesToUpload && filesToUpload.length > 0) {
      this._uploadFiles(filesToUpload);
    }
  }
  retryFiles(uid) {
    const filesToRetry = [this.fileList.get(uid)];
    if (filesToRetry) {
      this._uploadFiles(filesToRetry);
    }
  }
  _uploadFiles(allFiles) {
    for (const filesToUpload of allFiles) {
      if (filesToUpload[0].state === FileState.Paused) {
        return;
      }
      const uploadEventArgs = new UploadEvent(filesToUpload, this.cloneRequestHeaders(this.async.saveHeaders));
      this.uploadEvent.emit(uploadEventArgs);
      if (!uploadEventArgs.isDefaultPrevented()) {
        this.fileList.setFilesState(filesToUpload, FileState.Uploading);
        const httpSubcription = this.performUpload(filesToUpload, uploadEventArgs);
        filesToUpload.forEach((file) => {
          file.httpSubscription = httpSubcription;
        });
      } else {
        this.fileList.remove(filesToUpload[0].uid);
        this.checkAllComplete();
      }
    }
  }
  performRemove(files, removeEventArgs) {
    const async = this.async;
    const fileNames = files.map((file) => {
      return file.name;
    });
    const formData = this.populateRemoveFormData(fileNames, removeEventArgs.data);
    const options = this.populateRequestOptions(removeEventArgs.headers, false);
    const removeRequest = new HttpRequest(async.removeMethod, async.removeUrl, formData, options);
    this.http.request(removeRequest).subscribe((success) => {
      this.onSuccess(success, files, "remove");
    }, (error) => {
      this.onError(error, files, "remove");
    });
  }
  performUpload(files, uploadEventArgs) {
    const async = this.async;
    const formData = this.populateUploadFormData(files, uploadEventArgs.data);
    const options = this.populateRequestOptions(uploadEventArgs.headers);
    const uploadRequest = new HttpRequest(async.saveMethod, async.saveUrl, formData, options);
    const httpSubscription = this.http.request(uploadRequest).subscribe((event) => {
      if (event.type === HttpEventType.UploadProgress && !this.async.chunk) {
        this.onProgress(event, files);
      } else if (event instanceof HttpResponse) {
        this.onSuccess(event, files, "upload");
        this.checkAllComplete();
      }
    }, (error) => {
      this.onError(error, files, "upload");
      this.checkAllComplete();
    });
    return httpSubscription;
  }
  onSuccess(successResponse, files, operation) {
    if (operation === "upload" && this.async.chunk) {
      this.onChunkProgress(files);
      if (this.isChunkUploadComplete(files[0].uid)) {
        this.removeChunkInfo(files[0].uid);
      } else {
        this.updateChunkInfo(files[0].uid);
        this._uploadFiles([files]);
        return;
      }
    }
    const successArgs = new SuccessEvent(files, operation, successResponse);
    this.successEvent.emit(successArgs);
    if (operation === "upload") {
      this.fileList.setFilesState(files, successArgs.isDefaultPrevented() ? FileState.Failed : FileState.Uploaded);
    } else {
      if (!successArgs.isDefaultPrevented()) {
        this.fileList.remove(files[0].uid);
      }
    }
    if (!successArgs.isDefaultPrevented()) {
      this.onChange();
    }
  }
  onError(errorResponse, files, operation) {
    if (operation === "upload" && this.async.chunk) {
      const maxRetries = this.chunk.maxAutoRetries;
      const chunkInfo = this.chunkMap.get(files[0].uid);
      if (chunkInfo.retries < maxRetries) {
        chunkInfo.retries += 1;
        setTimeout(() => {
          this.retryFiles(files[0].uid);
        }, this.chunk.autoRetryAfter);
        return;
      }
    }
    const errorArgs = new ErrorEvent(files, operation, errorResponse);
    this.errorEvent.emit(errorArgs);
    if (operation === "upload") {
      this.fileList.setFilesState(files, FileState.Failed);
    }
  }
  onProgress(event, files) {
    const percentComplete = Math.round(100 * event.loaded / event.total);
    const progressArgs = new UploadProgressEvent(files, percentComplete < 100 ? percentComplete : 100);
    this.uploadProgressEvent.emit(progressArgs);
  }
  onChunkProgress(files) {
    const chunkInfo = this.chunkMap.get(files[0].uid);
    let percentComplete = 0;
    if (chunkInfo) {
      if (chunkInfo.index === chunkInfo.totalChunks - 1) {
        percentComplete = 100;
      } else {
        percentComplete = Math.round((chunkInfo.index + 1) / chunkInfo.totalChunks * 100);
      }
    }
    const progressArgs = new UploadProgressEvent(files, percentComplete < 100 ? percentComplete : 100);
    this.uploadProgressEvent.emit(progressArgs);
  }
  checkAllComplete() {
    if (!this.fileList.hasFileWithState([FileState.Uploading, FileState.Paused]) && this.areAllSelectedFilesHandled()) {
      this.completeEvent.emit();
    } else if (this.shouldUploadNextFile()) {
      this.uploadFiles();
    }
  }
  shouldUploadNextFile() {
    return !this.async.concurrent && this.fileList.hasFileWithState([FileState.Selected]) && !this.fileList.hasFileWithState([FileState.Uploading]);
  }
  areAllSelectedFilesHandled() {
    const validSelectedFiles = this.fileList.getFilesWithState(FileState.Selected).filter((file) => !file.validationErrors);
    return validSelectedFiles.length === 0;
  }
  cloneRequestHeaders(headers) {
    const cloned = {};
    if (headers) {
      headers.keys().forEach((key) => {
        if (key !== "constructor" && key !== "__proto__" && key !== "prototype") cloned[key] = headers.get(key);
      });
    }
    return new HttpHeaders(cloned);
  }
  populateRequestOptions(headers, reportProgress = true) {
    return {
      headers,
      reportProgress,
      responseType: this.async.responseType,
      withCredentials: this.async.withCredentials
    };
  }
  populateUploadFormData(files, clientData) {
    const saveField = this.async.saveField;
    const data = new FormData();
    this.populateClientFormData(data, clientData);
    if (this.async.chunk) {
      data.append(saveField, this.getNextChunk(files[0]));
      data.append("metadata", this.getChunkMetadata(files[0]));
    } else {
      for (const file of files) {
        data.append(saveField, file.rawFile);
      }
    }
    return data;
  }
  populateRemoveFormData(fileNames, clientData) {
    const data = new FormData();
    this.populateClientFormData(data, clientData);
    for (const fileName of fileNames) {
      data.append(this.async.removeField, fileName);
    }
    return data;
  }
  populateClientFormData(data, clientData) {
    for (const key in clientData) {
      if (clientData.hasOwnProperty(key)) {
        data.append(key, clientData[key]);
      }
    }
  }
  /* Chunking Helper Methods Section */
  getNextChunk(file) {
    const info = this.getChunkInfo(file);
    const newPosition = info.position + this.chunk.size;
    return file.rawFile.slice(info.position, newPosition);
  }
  getChunkInfo(file) {
    let chunkInfo = this.chunkMap.get(file.uid);
    if (!chunkInfo) {
      const totalChunks = file.size > 0 ? Math.ceil(file.size / this.chunk.size) : 1;
      chunkInfo = this.chunkMap.add(file.uid, totalChunks);
    }
    return chunkInfo;
  }
  updateChunkInfo(uid) {
    const chunkInfo = this.chunkMap.get(uid);
    if (chunkInfo.index < chunkInfo.totalChunks - 1) {
      chunkInfo.index += 1;
      chunkInfo.position += this.chunk.size;
      chunkInfo.retries = 0;
    }
  }
  removeChunkInfo(uid) {
    this.chunkMap.remove(uid);
  }
  getChunkMetadata(file) {
    const chunkInfo = this.chunkMap.get(file.uid);
    const chunkMetadata = {
      chunkIndex: chunkInfo.index,
      contentType: file.rawFile.type,
      fileName: file.name,
      fileSize: file.size,
      fileUid: file.uid,
      totalChunks: chunkInfo.totalChunks
    };
    return JSON.stringify(chunkMetadata);
  }
  isChunkUploadComplete(uid) {
    const chunkInfo = this.chunkMap.get(uid);
    if (chunkInfo) {
      return chunkInfo.index + 1 === chunkInfo.totalChunks;
    }
    return false;
  }
  static ɵfac = function UploadService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _UploadService)(ɵɵinject(HttpClient));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _UploadService,
    factory: _UploadService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UploadService, [{
    type: Injectable
  }], () => [{
    type: HttpClient
  }], null);
})();
var NavigationService2 = class _NavigationService {
  uploadService;
  zone;
  onActionButtonFocus = new EventEmitter();
  onFileAction = new EventEmitter();
  onFileFocus = new EventEmitter();
  onTabOut = new EventEmitter();
  onWrapperFocus = new EventEmitter();
  onSelectButtonFocus = new EventEmitter();
  actionButtonsVisible = false;
  fileListVisible = false;
  focused = false;
  keyBindings;
  focusedFileIndex = 0;
  _focusedIndex = -1;
  constructor(uploadService, zone) {
    this.uploadService = uploadService;
    this.zone = zone;
  }
  action(event) {
    const key = normalizeKeys(event);
    return this.keyBindings[key];
  }
  process(event, component) {
    const handler = this.action(event);
    if (handler) {
      handler(event, component);
    }
  }
  computeKeys() {
    this.keyBindings = {
      [Keys.Space]: () => this.handleSpace(),
      [Keys.Enter]: () => this.handleEnter(),
      [Keys.NumpadEnter]: () => this.handleEnter(),
      [Keys.Escape]: () => this.handleEscape(),
      [Keys.Delete]: () => this.handleDelete(),
      [Keys.Tab]: (event, component) => this.handleTab(event, component),
      [Keys.ArrowUp]: (event) => this.handleUpDown(event, -1),
      [Keys.ArrowDown]: (event) => this.handleUpDown(event, 1)
    };
  }
  focusSelectButton() {
    this.focused = true;
    this._focusedIndex = -1;
    this.onSelectButtonFocus.emit();
  }
  handleEnter() {
    if (this.lastIndex >= 0 && this.focusedIndex >= 0 && this.focusedIndex <= this.lastFileIndex) {
      this.zone.run(() => this.onFileAction.emit(Keys.Enter));
    }
  }
  handleSpace() {
    if (this.lastIndex >= 0 && this.focusedIndex >= 0 && this.focusedIndex <= this.lastFileIndex) {
      this.zone.run(() => this.onFileAction.emit(Keys.Space));
    }
  }
  handleDelete() {
    if (this.focusedIndex >= 0 && this.focusedIndex <= this.lastFileIndex) {
      this.zone.run(() => this.onFileAction.emit(Keys.Delete));
    }
  }
  handleEscape() {
    if (this.focusedIndex >= 0 && this.focusedIndex <= this.lastFileIndex) {
      this.zone.run(() => this.onFileAction.emit(Keys.Escape));
    }
  }
  handleTab(event, component) {
    const shifted = event.shiftKey;
    if (this.focusedIndex === -1 && this.fileListVisible && !shifted) {
      this.focusedIndex = this.focusedFileIndex;
      event.preventDefault();
      this.onFileFocus.emit(this.focusedFileIndex);
      return;
    }
    if (this.focusedIndex > -1 && this.focusedIndex <= this.lastFileIndex) {
      if (shifted) {
        this.focusedIndex = -1;
      } else if (component !== "fileselect" && this.actionButtonsVisible) {
        this.focusedIndex = this.lastFileIndex + 1;
        return;
      }
    }
    if (this.focusedIndex === this.lastFileIndex + 1) {
      this.focusedIndex = shifted ? this.focusedFileIndex : this.lastIndex;
      if (shifted) {
        event.preventDefault();
        this.onFileFocus.emit(this.focusedFileIndex);
      }
      return;
    }
    if (this.focusedIndex === this.lastIndex && this.actionButtonsVisible && shifted) {
      this.focusedIndex -= 1;
      return;
    }
    this.onTabOut.emit();
  }
  handleUpDown(event, direction) {
    const focusOnFileList = this.focusedIndex > -1 && this.uploadService.files.count >= 0;
    const nextFocusableIndexInBoundaries = direction > 0 ? this.focusedFileIndex < this.lastFileIndex : this.focusedFileIndex > 0;
    const focusNextFile = focusOnFileList && nextFocusableIndexInBoundaries;
    if (focusNextFile) {
      event.preventDefault();
      this.zone.run(() => {
        this.focusedIndex += direction;
        this.focusedFileIndex += direction;
      });
    }
  }
  get focusedIndex() {
    return this._focusedIndex;
  }
  set focusedIndex(index) {
    if (!this.focused) {
      this.onWrapperFocus.emit();
    }
    this._focusedIndex = index;
    this.focused = true;
    if (this._focusedIndex >= 0 && this._focusedIndex <= this.lastFileIndex) {
      this.onFileFocus.emit(index);
    }
  }
  get lastFileIndex() {
    return this.actionButtonsVisible ? this.lastIndex - 2 : this.lastIndex;
  }
  get lastIndex() {
    const fileCount = this.uploadService.files.count;
    return this.actionButtonsVisible ? fileCount + 1 : fileCount - 1;
  }
  static ɵfac = function NavigationService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NavigationService)(ɵɵinject(UploadService), ɵɵinject(NgZone));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _NavigationService,
    factory: _NavigationService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigationService2, [{
    type: Injectable
  }], () => [{
    type: UploadService
  }, {
    type: NgZone
  }], null);
})();
var components = {};
var DropZoneService = class _DropZoneService {
  addComponent(component, zoneId) {
    if (this.has(zoneId)) {
      components[zoneId].push(component);
    } else {
      components[zoneId] = [component];
    }
  }
  clearComponent(component, zoneId) {
    if (this.has(zoneId)) {
      const componentIdx = components[zoneId].indexOf(component);
      components[zoneId].splice(componentIdx, 1);
    }
  }
  getComponents(zoneId) {
    return components[zoneId];
  }
  has(id3) {
    return id3 in components;
  }
  static ɵfac = function DropZoneService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DropZoneService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DropZoneService,
    factory: _DropZoneService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DropZoneService, [{
    type: Injectable
  }], null, null);
})();
var INVALIDMAXFILESIZE = "invalidMaxFileSize";
var INVALIDMINFILESIZE = "invalidMinFileSize";
var INVALIDFILEEXTENSION = "invalidFileExtension";
var validateFileExtension = (file, allowedExtensions) => {
  if (allowedExtensions.length > 0) {
    if (allowedExtensions.indexOf(file.extension.toLowerCase()) < 0) {
      file.validationErrors = file.validationErrors || [];
      if (file.validationErrors.indexOf(INVALIDFILEEXTENSION) < 0) {
        file.validationErrors.push(INVALIDFILEEXTENSION);
      }
    }
  }
};
var validateFileSize = (file, minFileSize, maxFileSize) => {
  if (minFileSize !== 0 && file.size < minFileSize) {
    file.validationErrors = file.validationErrors || [];
    if (file.validationErrors.indexOf(INVALIDMINFILESIZE) < 0) {
      file.validationErrors.push(INVALIDMINFILESIZE);
    }
  }
  if (maxFileSize !== 0 && file.size > maxFileSize) {
    file.validationErrors = file.validationErrors || [];
    if (file.validationErrors.indexOf(INVALIDMAXFILESIZE) < 0) {
      file.validationErrors.push(INVALIDMAXFILESIZE);
    }
  }
};
var parseAllowedExtensions = (extensions) => {
  const allowedExtensions = extensions.map((ext) => {
    const parsedExt = ext.substring(0, 1) === "." ? ext : "." + ext;
    return parsedExt.toLowerCase();
  });
  return allowedExtensions;
};
var validateFiles = (files, restrictionInfo) => {
  const allowedExtensions = parseAllowedExtensions(restrictionInfo.allowedExtensions);
  const maxFileSize = restrictionInfo.maxFileSize;
  const minFileSize = restrictionInfo.minFileSize;
  let i;
  for (i = 0; i < files.length; i++) {
    validateFileExtension(files[i], allowedExtensions);
    validateFileSize(files[i], minFileSize, maxFileSize);
  }
};
var packageMetadata6 = {
  name: "@progress/kendo-angular-upload",
  productName: "Kendo UI for Angular",
  productCode: "KENDOUIANGULAR",
  productCodes: ["KENDOUIANGULAR"],
  publishDate: 0,
  version: "22.0.1",
  licensingDocsUrl: "https://www.telerik.com/kendo-angular-ui/my-license/"
};
var FileTemplateDirective = class _FileTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function FileTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FileTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FileTemplateDirective,
    selectors: [["", "kendoUploadFileTemplate", ""], ["", "kendoFileSelectFileTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FileTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoUploadFileTemplate], [kendoFileSelectFileTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var FileInfoTemplateDirective = class _FileInfoTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function FileInfoTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FileInfoTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FileInfoTemplateDirective,
    selectors: [["", "kendoUploadFileInfoTemplate", ""], ["", "kendoFileSelectFileInfoTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FileInfoTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoUploadFileInfoTemplate], [kendoFileSelectFileInfoTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var UploadFileSelectBase = class _UploadFileSelectBase {
  uploadService;
  navigation;
  cdr;
  injector;
  zone;
  /**
   * @hidden
   */
  fileTemplate;
  /**
   * @hidden
   */
  fileInfoTemplate;
  /**
   * @hidden
   */
  fileSelectButton;
  /**
   * Sets the `accept` attribute of the internal `input` element of the component.
   */
  accept;
  /**
   * Disables the component.
   *
   * @default false
   */
  disabled = false;
  /**
   * Allows you to select multiple files.
   * When you set this to `false`, you can select only one file at a time.
   *
   * @default true
   */
  multiple = true;
  /**
   * Controls the visibility of the file list.
   *
   * @default true
   */
  showFileList = true;
  /**
   * Sets the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
   *
   * @default 0
   */
  tabindex = 0;
  /**
   * Sets the restrictions for selected files.
   */
  set restrictions(restrictions) {
    const parsedRestrictions = Object.assign({}, this.restrictions, restrictions);
    this._restrictions = parsedRestrictions;
  }
  get restrictions() {
    return this._restrictions;
  }
  /**
   * Sets the `id` of the external drop zone that you want to associate with the component.
   *
   */
  zoneId;
  /**
   * @hidden
   */
  focusableId = `k-${guid()}`;
  /**
   * @hidden
   */
  hostDefaultClasses = true;
  /**
   * @hidden
   */
  get hostDisabledClass() {
    return this.disabled;
  }
  /**
   * Fires when you navigate outside the component.
   */
  onBlur = new EventEmitter();
  /**
   * Fires when you focus the component.
   */
  onFocus = new EventEmitter();
  /**
   * Fires when you select files. If you prevent this event, the component will not add the selected files to the list.
   */
  select = new EventEmitter();
  /**
   * Fires when you are about to remove a file. If you prevent this event, the file will remain in the list.
   */
  remove = new EventEmitter();
  /**
   * @hidden
   */
  _restrictions = {
    allowedExtensions: [],
    maxFileSize: 0,
    minFileSize: 0
  };
  /**
   * @hidden
   */
  fileList;
  constructor(uploadService, navigation, cdr, injector, zone) {
    this.uploadService = uploadService;
    this.navigation = navigation;
    this.cdr = cdr;
    this.injector = injector;
    this.zone = zone;
    this.fileList = this.uploadService.files;
  }
  /**
   * @hidden
   */
  get formControl() {
    const ngControl = this.injector.get(NgControl, null);
    return ngControl?.control || null;
  }
  /**
   * @hidden
   */
  get isControlRequired() {
    return isControlRequired(this.formControl);
  }
  /**
   * @hidden
   */
  get hasFileList() {
    const hasFileList = this.showFileList && this.fileList.count > 0;
    this.navigation.fileListVisible = hasFileList;
    return hasFileList;
  }
  /**
   * @hidden
   */
  writeValue(newValue, validation, callback) {
    let isValid = true;
    if (newValue instanceof Array) {
      newValue.forEach((file) => {
        if (!validation(file)) {
          isValid = false;
        }
      });
      if (isValid) {
        this.uploadService[callback](newValue);
      }
    }
    if (newValue === null) {
      this.fileList.clear();
    }
    this.cdr.markForCheck();
  }
  onTouchedCallback = (_) => {
  };
  onChangeCallback = (_) => {
  };
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.onChangeCallback = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.onTouchedCallback = fn;
  }
  /**
   * @hidden
   */
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  /**
   * @hidden
   */
  onFileSelectButtonFocus() {
    if (!this.navigation.focused) {
      this.navigation.focusedIndex = -1;
    }
  }
  /**
   * Focuses the component's **Select files** button.
   */
  focus() {
    this.zone.runOutsideAngular(() => {
      setTimeout(() => {
        this.fileSelectButton.nativeElement.focus();
        this.navigation.focused = true;
      });
    });
  }
  /**
   * @hidden
   * @deprecated
   */
  focusComponent() {
    this.focus();
  }
  /**
   * Blurs the component if you previously focused it.
   */
  blur() {
    if (this.navigation.focused) {
      this.navigation.focused = false;
      document.activeElement.blur();
    }
  }
  /**
   * @hidden
   * @deprecated
   */
  blurComponent() {
    this.blur();
  }
  static ɵfac = function UploadFileSelectBase_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _UploadFileSelectBase)(ɵɵdirectiveInject(UploadService), ɵɵdirectiveInject(NavigationService2), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(NgZone));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _UploadFileSelectBase,
    contentQueries: function UploadFileSelectBase_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, FileTemplateDirective, 5)(dirIndex, FileInfoTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.fileTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.fileInfoTemplate = _t.first);
      }
    },
    viewQuery: function UploadFileSelectBase_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c06, 7, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.fileSelectButton = _t.first);
      }
    },
    hostVars: 4,
    hostBindings: function UploadFileSelectBase_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-upload", ctx.hostDefaultClasses)("k-disabled", ctx.hostDisabledClass);
      }
    },
    inputs: {
      accept: "accept",
      disabled: "disabled",
      multiple: "multiple",
      showFileList: "showFileList",
      tabindex: "tabindex",
      restrictions: "restrictions",
      zoneId: "zoneId",
      focusableId: "focusableId"
    },
    outputs: {
      onBlur: "blur",
      onFocus: "focus",
      select: "select",
      remove: "remove"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UploadFileSelectBase, [{
    type: Directive,
    args: [{}]
  }], () => [{
    type: UploadService
  }, {
    type: NavigationService2
  }, {
    type: ChangeDetectorRef
  }, {
    type: Injector
  }, {
    type: NgZone
  }], {
    fileTemplate: [{
      type: ContentChild,
      args: [FileTemplateDirective]
    }],
    fileInfoTemplate: [{
      type: ContentChild,
      args: [FileInfoTemplateDirective]
    }],
    fileSelectButton: [{
      type: ViewChild,
      args: ["fileSelectButton", {
        static: true,
        read: ElementRef
      }]
    }],
    accept: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    multiple: [{
      type: Input
    }],
    showFileList: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    restrictions: [{
      type: Input
    }],
    zoneId: [{
      type: Input
    }],
    focusableId: [{
      type: Input
    }],
    hostDefaultClasses: [{
      type: HostBinding,
      args: ["class.k-upload"]
    }],
    hostDisabledClass: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    select: [{
      type: Output
    }],
    remove: [{
      type: Output
    }]
  });
})();
var UploadActionButtonsComponent = class _UploadActionButtonsComponent {
  uploadService;
  localization;
  navigation;
  disabled;
  actionsLayout;
  clearButton;
  uploadButton;
  hostDefaultClass = true;
  get actionButtonsEndClassName() {
    return this.actionsLayout === "end";
  }
  get actionButtonsStretchedClassName() {
    return this.actionsLayout === "stretched";
  }
  get actionButtonsStartClassName() {
    return this.actionsLayout === "start";
  }
  get actionButtonsCenterClassName() {
    return this.actionsLayout === "center";
  }
  constructor(uploadService, localization, navigation) {
    this.uploadService = uploadService;
    this.localization = localization;
    this.navigation = navigation;
  }
  onUploadButtonFocus() {
    if (!this.navigation.focused) {
      this.navigation.focusedIndex = this.navigation.lastIndex;
    }
  }
  onUploadButtonClick(event) {
    event.stopImmediatePropagation();
    this.performUpload();
  }
  performUpload() {
    if (!this.disabled) {
      this.uploadService.uploadFiles();
      this.navigation.focusSelectButton();
    }
  }
  onClearButtonClick(event) {
    event.stopImmediatePropagation();
    this.clearFiles();
  }
  clearFiles() {
    if (!this.disabled) {
      this.uploadService.clearFiles();
      this.navigation.focusSelectButton();
    }
  }
  textFor(key) {
    return this.localization.get(key);
  }
  static ɵfac = function UploadActionButtonsComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _UploadActionButtonsComponent)(ɵɵdirectiveInject(UploadService), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(NavigationService2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _UploadActionButtonsComponent,
    selectors: [["kendo-upload-action-buttons"]],
    viewQuery: function UploadActionButtonsComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c113, 7)(_c213, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.clearButton = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.uploadButton = _t.first);
      }
    },
    hostVars: 10,
    hostBindings: function UploadActionButtonsComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-actions", ctx.hostDefaultClass)("k-actions-end", ctx.actionButtonsEndClassName)("k-actions-stretched", ctx.actionButtonsStretchedClassName)("k-actions-start", ctx.actionButtonsStartClassName)("k-actions-center", ctx.actionButtonsCenterClassName);
      }
    },
    inputs: {
      disabled: "disabled",
      actionsLayout: "actionsLayout"
    },
    decls: 6,
    vars: 2,
    consts: [["clearButton", ""], ["uploadButton", ""], ["role", "button", 1, "k-button", "k-button-md", "k-rounded-md", "k-button-solid", "k-button-solid-base", "k-clear-selected", 3, "click"], ["role", "button", 1, "k-button", "k-button-md", "k-rounded-md", "k-button-solid", "k-button-solid-primary", "k-upload-selected", 3, "focus", "click"]],
    template: function UploadActionButtonsComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵdomElementStart(0, "button", 2, 0);
        ɵɵdomListener("click", function UploadActionButtonsComponent_Template_button_click_0_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onClearButtonClick($event));
        });
        ɵɵtext(2);
        ɵɵdomElementEnd();
        ɵɵdomElementStart(3, "button", 3, 1);
        ɵɵdomListener("focus", function UploadActionButtonsComponent_Template_button_focus_3_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onUploadButtonFocus());
        })("click", function UploadActionButtonsComponent_Template_button_click_3_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onUploadButtonClick($event));
        });
        ɵɵtext(5);
        ɵɵdomElementEnd();
      }
      if (rf & 2) {
        ɵɵadvance(2);
        ɵɵtextInterpolate1(" ", ctx.textFor("clearSelectedFiles"), " ");
        ɵɵadvance(3);
        ɵɵtextInterpolate1(" ", ctx.textFor("uploadSelectedFiles"), " ");
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UploadActionButtonsComponent, [{
    type: Component,
    args: [{
      selector: "kendo-upload-action-buttons",
      template: `
        <button #clearButton role="button" class="k-button k-button-md k-rounded-md k-button-solid k-button-solid-base k-clear-selected"
            (click)="onClearButtonClick($event)">
                {{textFor('clearSelectedFiles')}}
        </button>
        <button #uploadButton role="button" class="k-button k-button-md k-rounded-md k-button-solid k-button-solid-primary k-upload-selected"
            (focus)="onUploadButtonFocus()"
            (click)="onUploadButtonClick($event)">
                {{textFor('uploadSelectedFiles')}}
        </button>
    `,
      standalone: true
    }]
  }], () => [{
    type: UploadService
  }, {
    type: LocalizationService
  }, {
    type: NavigationService2
  }], {
    disabled: [{
      type: Input
    }],
    actionsLayout: [{
      type: Input
    }],
    clearButton: [{
      type: ViewChild,
      args: ["clearButton", {
        static: true
      }]
    }],
    uploadButton: [{
      type: ViewChild,
      args: ["uploadButton", {
        static: true
      }]
    }],
    hostDefaultClass: [{
      type: HostBinding,
      args: ["class.k-actions"]
    }],
    actionButtonsEndClassName: [{
      type: HostBinding,
      args: ["class.k-actions-end"]
    }],
    actionButtonsStretchedClassName: [{
      type: HostBinding,
      args: ["class.k-actions-stretched"]
    }],
    actionButtonsStartClassName: [{
      type: HostBinding,
      args: ["class.k-actions-start"]
    }],
    actionButtonsCenterClassName: [{
      type: HostBinding,
      args: ["class.k-actions-center"]
    }]
  });
})();
var FileListItemDirective = class _FileListItemDirective {
  navigationService;
  uploadService;
  files;
  index;
  fileClass = true;
  focused = false;
  element;
  constructor(el, navigationService, uploadService) {
    this.navigationService = navigationService;
    this.uploadService = uploadService;
    this.element = el;
  }
  focus() {
    this.element.nativeElement.focus();
  }
  get uidAttribute() {
    return this.files[0].uid;
  }
  get tabIndex() {
    return this.navigationService.focusedFileIndex === this.index ? "0" : "-1";
  }
  get kFileError() {
    return this.files[0].state === FileState.Failed;
  }
  get kFileInvalid() {
    return filesHaveValidationErrors(this.files);
  }
  get kFileProgress() {
    return this.files[0].state === FileState.Uploading || this.files[0].state === FileState.Paused;
  }
  get kFileSuccess() {
    if (this.uploadService.component === "Upload") {
      return this.files[0].state === FileState.Uploaded || this.files[0].state === FileState.Initial;
    }
    return false;
  }
  get kStateFocused() {
    return this.focused;
  }
  onFocus() {
    this.focused = true;
  }
  onBlur() {
    this.focused = false;
  }
  onClick(event) {
    if (!isFocusable3(event.target) && !hasClasses2(event.target, IGNORE_TARGET_CLASSES) || !!event.target.closest(".k-upload-action")) {
      this.navigationService.focusedIndex = this.navigationService.focusedFileIndex = this.index;
    }
  }
  static ɵfac = function FileListItemDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FileListItemDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NavigationService2), ɵɵdirectiveInject(UploadService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FileListItemDirective,
    selectors: [["", "kendoUploadFileListItem", ""]],
    hostVars: 14,
    hostBindings: function FileListItemDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("focus", function FileListItemDirective_focus_HostBindingHandler() {
          return ctx.onFocus();
        })("blur", function FileListItemDirective_blur_HostBindingHandler() {
          return ctx.onBlur();
        })("click", function FileListItemDirective_click_HostBindingHandler($event) {
          return ctx.onClick($event);
        });
      }
      if (rf & 2) {
        ɵɵattribute("data-uid", ctx.uidAttribute)("tabIndex", ctx.tabIndex);
        ɵɵclassProp("k-file", ctx.fileClass)("k-file-error", ctx.kFileError)("k-file-invalid", ctx.kFileInvalid)("k-file-progress", ctx.kFileProgress)("k-file-success", ctx.kFileSuccess)("k-focus", ctx.kStateFocused);
      }
    },
    inputs: {
      files: "files",
      index: "index"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FileListItemDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoUploadFileListItem]",
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NavigationService2
  }, {
    type: UploadService
  }], {
    files: [{
      type: Input
    }],
    index: [{
      type: Input
    }],
    fileClass: [{
      type: HostBinding,
      args: ["class.k-file"]
    }],
    uidAttribute: [{
      type: HostBinding,
      args: ["attr.data-uid"]
    }],
    tabIndex: [{
      type: HostBinding,
      args: ["attr.tabIndex"]
    }],
    kFileError: [{
      type: HostBinding,
      args: ["class.k-file-error"]
    }],
    kFileInvalid: [{
      type: HostBinding,
      args: ["class.k-file-invalid"]
    }],
    kFileProgress: [{
      type: HostBinding,
      args: ["class.k-file-progress"]
    }],
    kFileSuccess: [{
      type: HostBinding,
      args: ["class.k-file-success"]
    }],
    kStateFocused: [{
      type: HostBinding,
      args: ["class.k-focus"]
    }],
    onFocus: [{
      type: HostListener,
      args: ["focus"]
    }],
    onBlur: [{
      type: HostListener,
      args: ["blur"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var FileListItemBase = class _FileListItemBase {
  uploadService;
  progressComplete = 0;
  localization;
  uploadProgressSubscription;
  constructor(uploadService) {
    this.uploadService = uploadService;
  }
  subscribeUploadProgress(uploadProgressHandler) {
    this.uploadProgressSubscription = this.uploadService.uploadProgressEvent.subscribe(uploadProgressHandler);
  }
  fileHasValidationErrors(file) {
    return fileHasValidationErrors(file);
  }
  filesHaveValidationErrors(files) {
    return filesHaveValidationErrors(files);
  }
  ngOnDestroy() {
    this.uploadProgressSubscription.unsubscribe();
  }
  getFileValidationMessage(file) {
    let validationMessage;
    if (file.validationErrors && file.validationErrors.length > 0) {
      validationMessage = this.localization.get(file.validationErrors[0]);
    }
    return validationMessage;
  }
  getTotalFilesSizeMessage(files) {
    return getTotalFilesSizeMessage(files);
  }
  textFor(key) {
    return this.localization.get(key);
  }
  static ɵfac = function FileListItemBase_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FileListItemBase)(ɵɵdirectiveInject(UploadService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _FileListItemBase,
    selectors: [["ng-component"]],
    decls: 0,
    vars: 0,
    template: function FileListItemBase_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FileListItemBase, [{
    type: Component,
    args: [{
      template: ""
    }]
  }], () => [{
    type: UploadService
  }], null);
})();
var FileListItemActionButtonComponent = class _FileListItemActionButtonComponent {
  uploadService;
  localization;
  navigation;
  file;
  disabled;
  progress;
  retrySVGIcon = arrowRotateCwSmallIcon;
  playSVGIcon = playSmIcon;
  pauseSVGIcon = pauseSmIcon;
  cancelSVGIcon = cancelIcon;
  deleteSVGIcon = xIcon;
  constructor(uploadService, localization, navigation) {
    this.uploadService = uploadService;
    this.localization = localization;
    this.navigation = navigation;
  }
  onRetryClick() {
    if (this.disabled) {
      return;
    }
    this.uploadService.retryFiles(this.file.uid);
  }
  onRemoveCancelClick(event) {
    if (this.disabled) {
      return;
    }
    event.stopImmediatePropagation();
    const uid = this.file.uid;
    if (this.file.state === FileState.Uploading) {
      this.uploadService.cancelFiles(uid);
    } else {
      this.uploadService.removeFiles(uid);
    }
    this.navigation.focusSelectButton();
  }
  onPauseResumeClick() {
    if (this.disabled) {
      return;
    }
    const uid = this.file.uid;
    if (this.file.state === FileState.Paused) {
      this.uploadService.resumeFile(uid);
    } else {
      this.uploadService.pauseFile(uid);
    }
  }
  get actionButtonTitle() {
    if (this.file.state === FileState.Uploading) {
      return this.localization.get("cancel");
    }
    return this.localization.get("remove");
  }
  get retryButtonTitle() {
    return this.localization.get("retry");
  }
  get pauseResumeButtonTitle() {
    if (this.file.state === FileState.Uploading) {
      return this.localization.get("pause");
    }
    return this.localization.get("resume");
  }
  get isUploading() {
    return this.file.state === FileState.Uploading;
  }
  get isFailed() {
    return this.file.state === FileState.Failed;
  }
  get isPaused() {
    return this.file.state === FileState.Paused;
  }
  get isResumable() {
    const service = this.uploadService;
    const isResumable = service.async.chunk && service.chunk.resumable;
    const isUploading = this.file.state === FileState.Paused || this.file.state === FileState.Uploading;
    return isResumable && isUploading;
  }
  get isActionButtonVisible() {
    if ((this.file.state === FileState.Uploaded || this.file.state === FileState.Initial) && !this.uploadService.async.removeUrl && this.uploadService.component === "Upload") {
      return false;
    }
    return true;
  }
  static ɵfac = function FileListItemActionButtonComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FileListItemActionButtonComponent)(ɵɵdirectiveInject(UploadService), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(NavigationService2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _FileListItemActionButtonComponent,
    selectors: [["kendo-upload-file-list-item-action-button"]],
    inputs: {
      file: "file",
      disabled: "disabled",
      progress: "progress"
    },
    decls: 5,
    vars: 4,
    consts: [[1, "k-upload-actions"], [1, "k-upload-pct"], ["kendoButton", "", "type", "button", "fillMode", "flat", "icon", "refresh-sm", 1, "k-upload-action", "k-retry", 3, "svgIcon"], ["kendoButton", "", "type", "button", "fillMode", "flat", 1, "k-upload-action", 3, "svgIcon", "icon"], ["kendoButton", "", "fillMode", "flat", "type", "button", 1, "k-upload-action", 3, "k-delete", "svgIcon", "icon"], ["kendoButton", "", "type", "button", "fillMode", "flat", "icon", "refresh-sm", 1, "k-upload-action", "k-retry", 3, "pointerdown", "click", "svgIcon"], ["kendoButton", "", "type", "button", "fillMode", "flat", 1, "k-upload-action", 3, "pointerdown", "click", "svgIcon", "icon"], ["kendoButton", "", "fillMode", "flat", "type", "button", 1, "k-upload-action", 3, "click", "svgIcon", "icon"]],
    template: function FileListItemActionButtonComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "span", 0);
        ɵɵconditionalCreate(1, FileListItemActionButtonComponent_Conditional_1_Template, 2, 1, "span", 1);
        ɵɵconditionalCreate(2, FileListItemActionButtonComponent_Conditional_2_Template, 1, 4, "button", 2);
        ɵɵconditionalCreate(3, FileListItemActionButtonComponent_Conditional_3_Template, 1, 5, "button", 3);
        ɵɵconditionalCreate(4, FileListItemActionButtonComponent_Conditional_4_Template, 1, 7, "button", 4);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵconditional(ctx.isUploading || ctx.isPaused ? 1 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.isFailed ? 2 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.isResumable ? 3 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.isActionButtonVisible ? 4 : -1);
      }
    },
    dependencies: [ButtonComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FileListItemActionButtonComponent, [{
    type: Component,
    args: [{
      selector: "kendo-upload-file-list-item-action-button",
      template: `
    <span class="k-upload-actions">
      @if (isUploading || isPaused) {
        <span class="k-upload-pct">{{progress}}%</span>
      }
    
      @if (isFailed) {
        <button
          kendoButton
          type="button"
          class="k-upload-action k-retry"
          fillMode="flat"
          [attr.tabIndex]="-1"
          [attr.aria-hidden]="true"
          [attr.title]="retryButtonTitle"
          [svgIcon]="retrySVGIcon"
          icon="refresh-sm"
          (pointerdown)="$event.preventDefault()"
          (click)="onRetryClick()"
        ></button>
      }
    
      @if (isResumable) {
        <button
          kendoButton
          type="button"
          class="k-upload-action"
          fillMode="flat"
          [attr.tabIndex]="-1"
          [attr.aria-hidden]="true"
          [attr.title]="pauseResumeButtonTitle"
          [svgIcon]="isPaused ? playSVGIcon : pauseSVGIcon"
          [icon]="isPaused ? 'play-sm' : 'pause-sm'"
          (pointerdown)="$event.preventDefault()"
          (click)="onPauseResumeClick()"
        ></button>
      }
    
      @if (isActionButtonVisible) {
        <button
          kendoButton
          class="k-upload-action"
          [class.k-delete]="!isUploading"
          fillMode="flat"
          type="button"
          [attr.tabIndex]="-1"
          [attr.aria-hidden]="true"
          [attr.title]="actionButtonTitle"
          [svgIcon]="isUploading ? cancelSVGIcon : deleteSVGIcon"
          [icon]="isUploading ? 'cancel' : 'x'"
          (click)="onRemoveCancelClick($event)"
        ></button>
      }
    </span>
    `,
      standalone: true,
      imports: [ButtonComponent]
    }]
  }], () => [{
    type: UploadService
  }, {
    type: LocalizationService
  }, {
    type: NavigationService2
  }], {
    file: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    progress: [{
      type: Input
    }]
  });
})();
var FileListMultipleItemsComponent = class _FileListMultipleItemsComponent extends FileListItemBase {
  localization;
  disabled;
  files;
  fileInfoTemplate;
  filesHaveErrors;
  copySVGIcon = copyIcon;
  constructor(localization, uploadService) {
    super(uploadService);
    this.localization = localization;
    this.subscribeUploadProgress((args) => {
      if (args.files[0].uid === this.files[0].uid) {
        this.progressComplete = args.percentComplete;
      }
    });
  }
  get showProgress() {
    const showProgress = this.files[0].state === FileState.Uploading || this.files[0].state === FileState.Paused;
    return showProgress ? "active" : "inactive";
  }
  ngOnInit() {
    this.filesHaveErrors = super.filesHaveValidationErrors(this.files);
  }
  fileStatusText(file) {
    const errors = file.validationErrors;
    if (!isPresent6(errors)) {
      return this.getTotalFilesSizeMessage([file]);
    }
    return this.getFileValidationMessage(file);
  }
  get batchStatusText() {
    const state2 = this.files[0].state;
    const fileCount = this.files.length;
    if (state2 === FileState.Uploaded) {
      return `${fileCount} ${this.textFor("filesBatchStatusUploaded")}`;
    }
    if (state2 === FileState.Failed) {
      return `${fileCount} ${this.textFor("filesBatchStatusFailed")}`;
    }
    return `${fileCount} ${this.textFor("filesBatchStatus")}`;
  }
  get isUploadSuccessful() {
    return this.files[0].state === FileState.Uploaded;
  }
  get isUploadFailed() {
    return this.files[0].state === FileState.Failed;
  }
  static ɵfac = function FileListMultipleItemsComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FileListMultipleItemsComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(UploadService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _FileListMultipleItemsComponent,
    selectors: [["kendo-upload-file-list-multiple-items"]],
    inputs: {
      disabled: "disabled",
      files: "files",
      fileInfoTemplate: "fileInfoTemplate"
    },
    features: [ɵɵInheritDefinitionFeature],
    decls: 7,
    vars: 10,
    consts: [[3, "value", "label"], [1, "k-file-icon-wrapper"], ["name", "copy", "size", "xxlarge", "innerCssClass", "k-file-icon", 3, "svgIcon"], [1, "k-multiple-files-wrapper"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "file", "disabled", "progress"], [1, "k-file-info"], [1, "k-file-summary"], [1, "k-file-name", 3, "title"], [3, "ngClass"]],
    template: function FileListMultipleItemsComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelement(0, "kendo-progressbar", 0);
        ɵɵelementStart(1, "span", 1);
        ɵɵelement(2, "kendo-icon-wrapper", 2);
        ɵɵelementEnd();
        ɵɵelementStart(3, "span", 3);
        ɵɵconditionalCreate(4, FileListMultipleItemsComponent_Conditional_4_Template, 4, 1);
        ɵɵconditionalCreate(5, FileListMultipleItemsComponent_Conditional_5_Template, 1, 6, "ng-container", 4);
        ɵɵelementEnd();
        ɵɵelement(6, "kendo-upload-file-list-item-action-button", 5);
      }
      if (rf & 2) {
        ɵɵproperty("@progressState", ctx.showProgress)("value", ctx.progressComplete)("label", ɵɵpureFunction0(9, _c311));
        ɵɵadvance(2);
        ɵɵproperty("svgIcon", ctx.copySVGIcon);
        ɵɵadvance(2);
        ɵɵconditional(!ctx.fileInfoTemplate ? 4 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.fileInfoTemplate ? 5 : -1);
        ɵɵadvance();
        ɵɵproperty("file", ctx.files[0])("disabled", ctx.disabled)("progress", ctx.progressComplete);
      }
    },
    dependencies: [ProgressBarComponent, IconWrapperComponent, NgClass, NgTemplateOutlet, FileListItemActionButtonComponent],
    encapsulation: 2,
    data: {
      animation: [trigger("progressState", [state("active", style({
        opacity: 1
      })), state("inactive", style({
        opacity: 0
      })), transition("void => active", style({
        opacity: 0
      })), transition("inactive => active", style({
        opacity: 1
      })), transition("active => inactive", animate("1s 2s ease-out"))])]
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FileListMultipleItemsComponent, [{
    type: Component,
    args: [{
      animations: [trigger("progressState", [state("active", style({
        opacity: 1
      })), state("inactive", style({
        opacity: 0
      })), transition("void => active", style({
        opacity: 0
      })), transition("inactive => active", style({
        opacity: 1
      })), transition("active => inactive", animate("1s 2s ease-out"))])],
      selector: "kendo-upload-file-list-multiple-items",
      template: `
        <kendo-progressbar
          [@progressState]="showProgress"
          [value]="progressComplete"
          [label]="{ visible: false }"
          >
        </kendo-progressbar>
        <span class="k-file-icon-wrapper">
          <kendo-icon-wrapper
            name="copy"
            size="xxlarge"
            [svgIcon]="copySVGIcon"
            innerCssClass="k-file-icon"
            >
          </kendo-icon-wrapper>
        </span>
        <span class="k-multiple-files-wrapper">
          @if (!fileInfoTemplate) {
            @for (file of files; track file) {
              <span class="k-file-info">
                <span [title]="file.name" class="k-file-name">
                  {{file.name}}
                </span>
                    <span [attr.aria-live]="'polite'" [ngClass]="{
                        'k-file-validation-message': file.validationErrors,
                        'k-file-size': !file.validationErrors
                        }"
                >{{fileStatusText(file)}}</span>
              </span>
            }
            <span class="k-file-summary"
            >{{batchStatusText}}</span>
          }
          @if (fileInfoTemplate) {
            <ng-container
              [ngTemplateOutlet]="fileInfoTemplate.templateRef"
                [ngTemplateOutletContext]="{
                    templateRef: fileInfoTemplate.templateRef,
                    state: files[0].state,
                    $implicit: files
                }"></ng-container>
          }
        </span>
        <kendo-upload-file-list-item-action-button
          [file]='files[0]'
          [disabled]='disabled'
          [progress]='progressComplete'>
        </kendo-upload-file-list-item-action-button>
        `,
      standalone: true,
      imports: [ProgressBarComponent, IconWrapperComponent, NgClass, NgTemplateOutlet, FileListItemActionButtonComponent]
    }]
  }], () => [{
    type: LocalizationService
  }, {
    type: UploadService
  }], {
    disabled: [{
      type: Input
    }],
    files: [{
      type: Input
    }],
    fileInfoTemplate: [{
      type: Input
    }]
  });
})();
var FileListSingleItemComponent = class _FileListSingleItemComponent extends FileListItemBase {
  localization;
  disabled;
  file;
  fileInfoTemplate;
  constructor(localization, uploadService) {
    super(uploadService);
    this.localization = localization;
    this.subscribeUploadProgress((args) => {
      if (args.files[0].uid === this.file.uid) {
        this.progressComplete = args.percentComplete;
      }
    });
  }
  get fileStatusText() {
    const errors = this.file.validationErrors;
    if (this.file.state === FileState.Uploaded) {
      return `${this.textFor("fileStatusUploaded")}`;
    }
    if (this.file.state === FileState.Failed) {
      return `${this.textFor("fileStatusFailed")}`;
    }
    if (!isPresent6(errors)) {
      return this.getTotalFilesSizeMessage([this.file]);
    }
    return this.getFileValidationMessage(this.file);
  }
  get showProgress() {
    const showProgress = this.file.state === FileState.Uploading || this.file.state === FileState.Paused;
    return showProgress ? "active" : "inactive";
  }
  get fileGroupClass() {
    return fileGroupClass(this.file.extension);
  }
  get fileSVGGroupIcon() {
    return fileSVGGroupIcon(this.file.extension);
  }
  get isUploadSuccessful() {
    return this.file.state === FileState.Uploaded;
  }
  get isUploadFailed() {
    return this.file.state === FileState.Failed;
  }
  get isNotYetUploaded() {
    return !this.isUploadFailed && !this.isUploadSuccessful;
  }
  static ɵfac = function FileListSingleItemComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FileListSingleItemComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(UploadService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _FileListSingleItemComponent,
    selectors: [["kendo-upload-file-list-single-item"]],
    inputs: {
      disabled: "disabled",
      file: "file",
      fileInfoTemplate: "fileInfoTemplate"
    },
    features: [ɵɵInheritDefinitionFeature],
    decls: 7,
    vars: 11,
    consts: [[3, "value", "label"], [1, "k-file-icon-wrapper"], ["size", "xxlarge", "innerCssClass", "k-file-icon", 3, "name", "svgIcon"], [1, "k-file-info"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "file", "disabled", "progress"], [1, "k-file-name", 3, "title"], [3, "ngClass"]],
    template: function FileListSingleItemComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelement(0, "kendo-progressbar", 0);
        ɵɵelementStart(1, "span", 1);
        ɵɵelement(2, "kendo-icon-wrapper", 2);
        ɵɵelementEnd();
        ɵɵelementStart(3, "span", 3);
        ɵɵconditionalCreate(4, FileListSingleItemComponent_Conditional_4_Template, 4, 9);
        ɵɵconditionalCreate(5, FileListSingleItemComponent_Conditional_5_Template, 1, 8, "ng-container", 4);
        ɵɵelementEnd();
        ɵɵelement(6, "kendo-upload-file-list-item-action-button", 5);
      }
      if (rf & 2) {
        ɵɵproperty("@progressState", ctx.showProgress)("value", ctx.progressComplete)("label", ɵɵpureFunction0(10, _c311));
        ɵɵadvance(2);
        ɵɵproperty("name", ctx.fileGroupClass)("svgIcon", ctx.fileSVGGroupIcon);
        ɵɵadvance(2);
        ɵɵconditional(!ctx.fileInfoTemplate ? 4 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.fileInfoTemplate ? 5 : -1);
        ɵɵadvance();
        ɵɵproperty("file", ctx.file)("disabled", ctx.disabled)("progress", ctx.progressComplete);
      }
    },
    dependencies: [ProgressBarComponent, IconWrapperComponent, NgClass, NgTemplateOutlet, FileListItemActionButtonComponent],
    encapsulation: 2,
    data: {
      animation: [trigger("progressState", [state("active", style({
        opacity: 1
      })), state("inactive", style({
        opacity: 0
      })), transition("void => active", style({
        opacity: 0
      })), transition("inactive => active", style({
        opacity: 1
      })), transition("active => inactive", animate("1s 2s ease-out"))])]
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FileListSingleItemComponent, [{
    type: Component,
    args: [{
      animations: [trigger("progressState", [state("active", style({
        opacity: 1
      })), state("inactive", style({
        opacity: 0
      })), transition("void => active", style({
        opacity: 0
      })), transition("inactive => active", style({
        opacity: 1
      })), transition("active => inactive", animate("1s 2s ease-out"))])],
      selector: "kendo-upload-file-list-single-item",
      template: `
        <kendo-progressbar
          [@progressState]="showProgress"
          [value]="progressComplete"
          [label]="{ visible: false }"
          >
        </kendo-progressbar>
        <span class="k-file-icon-wrapper">
          <kendo-icon-wrapper
            size="xxlarge"
            [name]="fileGroupClass"
            [svgIcon]="fileSVGGroupIcon"
            innerCssClass="k-file-icon"
            >
          </kendo-icon-wrapper>
        </span>
        <span class="k-file-info">
          @if (!fileInfoTemplate) {
            <span class="k-file-name" [title]="file.name">{{ file.name }}</span>
                <span [attr.aria-live]="'polite'" [ngClass]="{
                    'k-file-validation-message': file.validationErrors,
                    'k-file-size': !file.validationErrors && isNotYetUploaded,
                    'k-file-summary': isUploadSuccessful || isUploadFailed
                    }"
            >{{fileStatusText}}</span>
          }
          @if (fileInfoTemplate) {
<ng-container [ngTemplateOutlet]="fileInfoTemplate.templateRef" [ngTemplateOutletContext]="{
                    templateRef: fileInfoTemplate.templateRef,
                    state: file.state,
                    $implicit: [file]
                }"></ng-container>
          }
        </span>
        <kendo-upload-file-list-item-action-button
          [file]='file'
          [disabled]='disabled'
          [progress]='progressComplete'>
        </kendo-upload-file-list-item-action-button>
        `,
      standalone: true,
      imports: [ProgressBarComponent, IconWrapperComponent, NgClass, NgTemplateOutlet, FileListItemActionButtonComponent]
    }]
  }], () => [{
    type: LocalizationService
  }, {
    type: UploadService
  }], {
    disabled: [{
      type: Input
    }],
    file: [{
      type: Input
    }],
    fileInfoTemplate: [{
      type: Input
    }]
  });
})();
var FileListComponent = class _FileListComponent {
  uploadService;
  navigation;
  disabled;
  fileList;
  fileTemplate;
  fileInfoTemplate;
  fileListItems;
  fileListRole = "list";
  focusSubscription;
  actionSubscription;
  constructor(uploadService, navigation) {
    this.uploadService = uploadService;
    this.navigation = navigation;
    this.onItemFocus();
    this.onItemAction();
  }
  onItemFocus() {
    this.focusSubscription = this.navigation.onFileFocus.subscribe((index) => {
      this.fileListItems.toArray()[index].focus();
    });
  }
  onItemAction() {
    this.actionSubscription = this.navigation.onFileAction.subscribe((key) => {
      this.itemActionHandler(key);
    });
  }
  itemActionHandler(key) {
    const index = this.navigation.focusedIndex;
    const filesArray = this.fileListItems.toArray();
    const numberOfFiles = filesArray.length;
    const item = filesArray[index];
    const uid = item.uidAttribute;
    const files = this.uploadService.files.get(uid);
    if (key === Keys.Escape && files[0].state === FileState.Uploading) {
      this.uploadService.cancelFiles(uid);
      this.navigation.focusSelectButton();
      return;
    }
    if ((key === Keys.Enter || key === Keys.NumpadEnter) && files[0].state === FileState.Failed) {
      this.uploadService.retryFiles(uid);
      return;
    }
    if (key === Keys.Delete) {
      if (files[0].state === FileState.Uploading) {
        this.uploadService.cancelFiles(uid);
      } else if (this.hasDelete(item)) {
        this.uploadService.removeFiles(uid);
      }
      if (index < numberOfFiles - 1) {
        filesArray[index + 1].focus();
      } else if (numberOfFiles === 1) {
        this.navigation.focusSelectButton();
      } else if (index === numberOfFiles - 1) {
        this.navigation.focusedIndex = this.navigation.focusedFileIndex = index - 1;
        filesArray[index - 1].focus();
      }
    }
    const isUploadChunk = this.uploadService.async.chunk;
    const canTogglePauseResume = key === Keys.Space && files[0].state !== FileState.Uploaded;
    if (canTogglePauseResume && isUploadChunk) {
      if (files[0].state === FileState.Paused) {
        this.uploadService.resumeFile(uid);
      } else {
        this.uploadService.pauseFile(uid);
      }
    }
  }
  hasDelete(item) {
    return item.element.nativeElement.getElementsByClassName("k-svg-i-x").length > 0;
  }
  /**
   * Tracks files array by the UID of the first file in the batch.
   * Each batch of files shares the same UID, which remains stable
   * throughout the file lifecycle until the batch is removed.
   */
  trackByUid(index, files) {
    return files[0]?.uid || index.toString();
  }
  ngOnDestroy() {
    this.focusSubscription.unsubscribe();
    this.actionSubscription.unsubscribe();
  }
  static ɵfac = function FileListComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FileListComponent)(ɵɵdirectiveInject(UploadService), ɵɵdirectiveInject(NavigationService2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _FileListComponent,
    selectors: [["", "kendo-upload-file-list", ""]],
    viewQuery: function FileListComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(FileListItemDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.fileListItems = _t);
      }
    },
    hostVars: 1,
    hostBindings: function FileListComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("role", ctx.fileListRole);
      }
    },
    inputs: {
      disabled: "disabled",
      fileList: "fileList",
      fileTemplate: "fileTemplate",
      fileInfoTemplate: "fileInfoTemplate"
    },
    attrs: _c83,
    decls: 2,
    vars: 0,
    consts: [["kendoUploadFileListItem", "", "role", "listitem", 3, "files", "index"], [1, "k-file-single", 3, "disabled", "file", "fileInfoTemplate"], [1, "k-file-multiple", 3, "disabled", "files", "fileInfoTemplate"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
    template: function FileListComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵrepeaterCreate(0, FileListComponent_For_1_Template, 4, 5, "li", 0, ctx.trackByUid, true);
      }
      if (rf & 2) {
        ɵɵrepeater(ctx.fileList);
      }
    },
    dependencies: [FileListItemDirective, FileListSingleItemComponent, FileListMultipleItemsComponent, NgTemplateOutlet],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FileListComponent, [{
    type: Component,
    args: [{
      selector: "[kendo-upload-file-list]",
      template: `
        @for (files of fileList; track trackByUid($index, files); let index = $index) {
          <li kendoUploadFileListItem [files]='files' [index]='index' role="listitem">
            @if (files.length === 1 && !fileTemplate) {
              <kendo-upload-file-list-single-item
                class='k-file-single'
                [disabled]='disabled'
                [file]='files[0]'
              [fileInfoTemplate]="fileInfoTemplate"></kendo-upload-file-list-single-item>
            }
            @if (files.length > 1 && !fileTemplate) {
              <kendo-upload-file-list-multiple-items
                class='k-file-multiple'
                [disabled]='disabled'
                [files]='files'
              [fileInfoTemplate]="fileInfoTemplate"></kendo-upload-file-list-multiple-items>
            }
            @if (fileTemplate) {
              <ng-container
                    [ngTemplateOutlet]="fileTemplate.templateRef" [ngTemplateOutletContext]="{
                            templateRef: fileTemplate.templateRef,
                            state: files[0].state,
                            $implicit: files
                        }"></ng-container>
            }
          </li>
        }
        `,
      standalone: true,
      imports: [FileListItemDirective, FileListSingleItemComponent, FileListMultipleItemsComponent, NgTemplateOutlet]
    }]
  }], () => [{
    type: UploadService
  }, {
    type: NavigationService2
  }], {
    disabled: [{
      type: Input
    }],
    fileList: [{
      type: Input
    }],
    fileTemplate: [{
      type: Input
    }],
    fileInfoTemplate: [{
      type: Input
    }],
    fileListItems: [{
      type: ViewChildren,
      args: [FileListItemDirective]
    }],
    fileListRole: [{
      type: HostBinding,
      args: ["attr.role"]
    }]
  });
})();
var UploadStatusTotalComponent = class _UploadStatusTotalComponent {
  localization;
  fileList;
  isFailed;
  isPaused;
  isUploading;
  statusText;
  checkmarkIcon = checkIcon;
  exceptionSVGIcon = exclamationCircleIcon;
  uploadSVGIcon = uploadIcon;
  pauseSVGIcon = pauseSmIcon;
  constructor(localization) {
    this.localization = localization;
  }
  get iconClass() {
    if (!this.isUploading && !this.isFailed) {
      return "checkmark";
    }
    if (!this.isUploading && this.isFailed) {
      return "exception";
    }
    if (this.isUploading) {
      return "upload";
    }
    if (this.isPaused) {
      return "pause-sm";
    }
  }
  get SVGIconClass() {
    if (!this.isUploading && !this.isFailed) {
      return this.checkmarkIcon;
    }
    if (!this.isUploading && this.isFailed) {
      return this.exceptionSVGIcon;
    }
    if (this.isUploading) {
      return this.uploadSVGIcon;
    }
    if (this.isPaused) {
      return this.pauseSVGIcon;
    }
  }
  ngDoCheck() {
    this.isPaused = this.fileList.hasFileWithState([FileState.Paused]);
    this.isFailed = this.fileList.hasFileWithState([FileState.Failed]);
    this.isUploading = this.fileList.hasFileWithState([FileState.Uploading]);
    if (this.isPaused && !this.isUploading) {
      this.statusText = this.localization.get("headerStatusPaused");
    } else {
      this.statusText = this.isUploading ? this.localization.get("headerStatusUploading") : this.localization.get("headerStatusUploaded");
    }
  }
  static ɵfac = function UploadStatusTotalComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _UploadStatusTotalComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _UploadStatusTotalComponent,
    selectors: [["kendo-upload-status-total"]],
    inputs: {
      fileList: "fileList"
    },
    decls: 2,
    vars: 3,
    consts: [[3, "name", "svgIcon"]],
    template: function UploadStatusTotalComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelement(0, "kendo-icon-wrapper", 0);
        ɵɵtext(1);
      }
      if (rf & 2) {
        ɵɵproperty("name", ctx.iconClass)("svgIcon", ctx.SVGIconClass);
        ɵɵadvance();
        ɵɵtextInterpolate1(" ", ctx.statusText, " ");
      }
    },
    dependencies: [IconWrapperComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UploadStatusTotalComponent, [{
    type: Component,
    args: [{
      selector: "kendo-upload-status-total",
      template: `
        <kendo-icon-wrapper
            [name]="iconClass"
            [svgIcon]="SVGIconClass"
        >
        </kendo-icon-wrapper>
        {{statusText}}
    `,
      standalone: true,
      imports: [IconWrapperComponent]
    }]
  }], () => [{
    type: LocalizationService
  }], {
    fileList: [{
      type: Input
    }]
  });
})();
var FileSelectDirective = class _FileSelectDirective {
  uploadService;
  navigation;
  dir;
  disabled;
  multiple;
  restrictions;
  accept;
  required;
  type = "file";
  autocomplete = "off";
  tabIndex = -1;
  ariaHidden = true;
  element;
  constructor(uploadService, navigation, el) {
    this.uploadService = uploadService;
    this.navigation = navigation;
    this.element = el;
  }
  classNames = true;
  get nameAttribute() {
    return this.uploadService.async.saveField;
  }
  get multipleAttribute() {
    return this.multiple ? "multiple" : null;
  }
  get dirAttribute() {
    return this.dir;
  }
  get disabledAttribute() {
    return this.disabled ? "true" : null;
  }
  get acceptAttribute() {
    return this.accept ? this.accept : null;
  }
  get requiredAttribute() {
    return this.required ? "" : null;
  }
  onInputChange(event) {
    const ua = navigator.userAgent;
    const webkit = /(webkit)[ \/]([\w.]+)/i;
    const msBrowsers = /(windows)[ \/]([\w.]+)/i;
    let selectedFiles = inputFiles(event.target);
    selectedFiles = assignGuidToFiles(selectedFiles, !this.uploadService.async.batch);
    validateFiles(selectedFiles, this.restrictions);
    if (!this.multiple) {
      this.uploadService.clearFiles();
    }
    this.uploadService.addFiles(selectedFiles);
    const native = this.element.nativeElement;
    if (ua.match(webkit) || ua.match(msBrowsers)) {
      native.type = "";
      native.type = "file";
    }
    setTimeout(() => {
      this.navigation.focusedIndex = -1;
    });
  }
  static ɵfac = function FileSelectDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FileSelectDirective)(ɵɵdirectiveInject(UploadService), ɵɵdirectiveInject(NavigationService2), ɵɵdirectiveInject(ElementRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FileSelectDirective,
    selectors: [["", "kendoFileSelect", ""]],
    hostVars: 12,
    hostBindings: function FileSelectDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("change", function FileSelectDirective_change_HostBindingHandler($event) {
          return ctx.onInputChange($event);
        });
      }
      if (rf & 2) {
        ɵɵattribute("type", ctx.type)("autocomplete", ctx.autocomplete)("tabindex", ctx.tabIndex)("aria-hidden", ctx.ariaHidden)("name", ctx.nameAttribute)("multiple", ctx.multipleAttribute)("dir", ctx.dirAttribute)("disabled", ctx.disabledAttribute)("accept", ctx.acceptAttribute)("required", ctx.requiredAttribute);
        ɵɵclassProp("k-hidden", ctx.classNames);
      }
    },
    inputs: {
      dir: "dir",
      disabled: "disabled",
      multiple: "multiple",
      restrictions: "restrictions",
      accept: "accept",
      required: "required"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FileSelectDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoFileSelect]",
      standalone: true
    }]
  }], () => [{
    type: UploadService
  }, {
    type: NavigationService2
  }, {
    type: ElementRef
  }], {
    dir: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    multiple: [{
      type: Input
    }],
    restrictions: [{
      type: Input
    }],
    accept: [{
      type: Input
    }],
    required: [{
      type: Input
    }],
    type: [{
      type: HostBinding,
      args: ["attr.type"]
    }],
    autocomplete: [{
      type: HostBinding,
      args: ["attr.autocomplete"]
    }],
    tabIndex: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    ariaHidden: [{
      type: HostBinding,
      args: ["attr.aria-hidden"]
    }],
    classNames: [{
      type: HostBinding,
      args: ["class.k-hidden"]
    }],
    nameAttribute: [{
      type: HostBinding,
      args: ["attr.name"]
    }],
    multipleAttribute: [{
      type: HostBinding,
      args: ["attr.multiple"]
    }],
    dirAttribute: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    disabledAttribute: [{
      type: HostBinding,
      args: ["attr.disabled"]
    }],
    acceptAttribute: [{
      type: HostBinding,
      args: ["attr.accept"]
    }],
    requiredAttribute: [{
      type: HostBinding,
      args: ["attr.required"]
    }],
    onInputChange: [{
      type: HostListener,
      args: ["change", ["$event"]]
    }]
  });
})();
var DropZoneBase = class _DropZoneBase {
  element;
  renderer;
  hoverClass;
  lastDragElement;
  hideIntervalElement = null;
  /**
   * @hidden
   */
  onElementDragEnterListener() {
    this.addClass(this.hoverClass);
    this.lastDragElement = /* @__PURE__ */ new Date();
    if (!this.hideIntervalElement) {
      this.hideIntervalElement = setInterval(() => {
        if (this.calculateTimeDiff(this.lastDragElement) < 100) {
          return;
        }
        this.removeClass(this.hoverClass);
        clearInterval(this.hideIntervalElement);
        this.hideIntervalElement = null;
      }, 100);
    }
    return false;
  }
  /**
   * @hidden
   */
  onElementDragOverListener() {
    this.lastDragElement = /* @__PURE__ */ new Date();
    return false;
  }
  constructor(element, renderer, cssClass) {
    this.element = element;
    this.renderer = renderer;
    this.hoverClass = cssClass;
  }
  calculateTimeDiff(prevEvent) {
    return (/* @__PURE__ */ new Date()).getTime() - prevEvent.getTime();
  }
  addClass(className) {
    this.renderer.addClass(this.element.nativeElement, className);
  }
  removeClass(className) {
    this.renderer.removeClass(this.element.nativeElement, className);
  }
  static ɵfac = function DropZoneBase_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DropZoneBase)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject("hoverClass"));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DropZoneBase,
    hostBindings: function DropZoneBase_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("dragenter", function DropZoneBase_dragenter_HostBindingHandler() {
          return ctx.onElementDragEnterListener();
        })("dragover", function DropZoneBase_dragover_HostBindingHandler() {
          return ctx.onElementDragOverListener();
        });
      }
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DropZoneBase, [{
    type: Directive
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: ["hoverClass"]
    }]
  }], {
    onElementDragEnterListener: [{
      type: HostListener,
      args: ["dragenter"]
    }],
    onElementDragOverListener: [{
      type: HostListener,
      args: ["dragover"]
    }]
  });
})();
var DropZoneInternalDirective = class _DropZoneInternalDirective extends DropZoneBase {
  ngZone;
  uploadService;
  disabled;
  multiple;
  restrictions;
  initialClassName = true;
  unsubscribeDocumentDragEnter;
  unsubscribeDocumentDragOver;
  lastDragDocument;
  hideIntervalDocument = null;
  activeClass = "k-dropzone-active";
  constructor(element, renderer, ngZone, uploadService) {
    super(element, renderer, "k-hover");
    this.ngZone = ngZone;
    this.uploadService = uploadService;
    this.ngZone.runOutsideAngular(() => {
      this.unsubscribeDocumentDragEnter = this.renderer.listen("document", "dragenter", () => this.onDocumentDragEnter());
      this.unsubscribeDocumentDragOver = this.renderer.listen("document", "dragover", () => this.onDocumentDragOver());
    });
  }
  ngOnDestroy() {
    this.ngZone.runOutsideAngular(() => {
      if (this.unsubscribeDocumentDragEnter) {
        this.unsubscribeDocumentDragEnter();
      }
      if (this.unsubscribeDocumentDragOver) {
        this.unsubscribeDocumentDragOver();
      }
    });
  }
  onDocumentDragEnter() {
    this.addClass(this.activeClass);
    this.lastDragDocument = /* @__PURE__ */ new Date();
    if (!this.hideIntervalDocument) {
      this.hideIntervalDocument = setInterval(() => {
        if (this.calculateTimeDiff(this.lastDragDocument) < 100) {
          return;
        }
        this.removeClass(this.activeClass);
        clearInterval(this.hideIntervalDocument);
        this.hideIntervalDocument = null;
      }, 100);
    }
    return false;
  }
  /**
   * @hidden
   */
  onDocumentDragOver() {
    this.lastDragDocument = /* @__PURE__ */ new Date();
    return false;
  }
  onDropListener(event) {
    const droppedFiles = event.dataTransfer.files;
    if (droppedFiles.length > 0 && !this.disabled) {
      let files = getAllFileInfo(droppedFiles);
      files = assignGuidToFiles(files, !this.uploadService.async.batch);
      if (!this.multiple) {
        files.splice(1, files.length - 1);
        this.uploadService.clearFiles();
      }
      validateFiles(files, this.restrictions);
      this.uploadService.addFiles(files);
    }
    return false;
  }
  static ɵfac = function DropZoneInternalDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DropZoneInternalDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(UploadService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DropZoneInternalDirective,
    selectors: [["", "kendoUploadInternalDropZone", ""], ["", "kendoFileSelectInternalDropZone", ""]],
    hostVars: 4,
    hostBindings: function DropZoneInternalDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("drop", function DropZoneInternalDirective_drop_HostBindingHandler($event) {
          return ctx.onDropListener($event);
        });
      }
      if (rf & 2) {
        ɵɵclassProp("k-dropzone", ctx.initialClassName)("k-upload-dropzone", ctx.initialClassName);
      }
    },
    inputs: {
      disabled: "disabled",
      multiple: "multiple",
      restrictions: "restrictions"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DropZoneInternalDirective, [{
    type: Directive,
    args: [{
      selector: `
      [kendoUploadInternalDropZone],
      [kendoFileSelectInternalDropZone]
    `,
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: NgZone
  }, {
    type: UploadService
  }], {
    disabled: [{
      type: Input
    }],
    multiple: [{
      type: Input
    }],
    restrictions: [{
      type: Input
    }],
    initialClassName: [{
      type: HostBinding,
      args: ["class.k-dropzone"]
    }, {
      type: HostBinding,
      args: ["class.k-upload-dropzone"]
    }],
    onDropListener: [{
      type: HostListener,
      args: ["drop", ["$event"]]
    }]
  });
})();
var Messages4 = class _Messages extends ComponentMessages {
  /**
   * Sets the text for the **Cancel** button.
   *
   * @default 'Cancel'
   */
  cancel;
  /**
   * Sets the text for the **Clear** button.
   *
   * @default 'Clear'
   */
  clearSelectedFiles;
  /**
   * Sets the drop-zone hint.
   *
   * @default 'Drop files here to upload'
   */
  dropFilesHere;
  /**
   * Sets the external drop-zone hint.
   *
   * @default 'Drag and drop files here to upload'
   */
  externalDropFilesHere;
  /**
   * Sets the status message for a batch of files.
   *
   * @default 'files'
   */
  filesBatchStatus;
  /**
   * Sets the status message for a batch of files after failed upload.
   *
   * @default 'files failed to upload.'
   */
  filesBatchStatusFailed;
  /**
   * Sets the status message for a batch of files after successful upload.
   *
   * @default 'files successfully uploaded.'
   */
  filesBatchStatusUploaded;
  /**
   * Sets the file status message after failed upload.
   *
   * @default 'File failed to upload.'
   */
  fileStatusFailed;
  /**
   * Sets the file status message after successful upload.
   *
   * @default 'File successfully uploaded.'
   */
  fileStatusUploaded;
  /**
   * Sets the header status message when the file upload is paused.
   *
   * @default 'Paused'
   */
  headerStatusPaused;
  /**
   * Sets the header status message after the file upload completes.
   *
   * @default 'Done'
   */
  headerStatusUploaded;
  /**
   * Sets the header status message during the upload of the file.
   *
   * @default 'Uploading...'
   */
  headerStatusUploading;
  /**
   * Sets the text for the invalid `allowedExtensions` restriction message.
   *
   * @default 'File type not allowed.'
   */
  invalidFileExtension;
  /**
   * Sets the text for the invalid `maxFileSize` restriction message.
   *
   * @default 'File size too large.'
   */
  invalidMaxFileSize;
  /**
   * Sets the text for the invalid `minFileSize` restriction message.
   *
   * @default 'File size too small.'
   */
  invalidMinFileSize;
  /**
   * Sets the text for the **Pause** button.
   *
   * @default 'Pause'
   */
  pause;
  /**
   * Sets the text for the **Remove** button.
   *
   * @default 'Remove'
   */
  remove;
  /**
   * Sets the text for the **Resume** button.
   *
   * @default 'Resume'
   */
  resume;
  /**
   * Sets the text for the **Retry** button.
   *
   * @default 'Retry'
   */
  retry;
  /**
   * Sets the text for the **Select** button.
   *
   * @default 'Select files...'
   */
  select;
  /**
   * Sets the text for the **Upload files** button.
   *
   * @default 'Upload'
   */
  uploadSelectedFiles;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵMessages_BaseFactory;
    return function Messages_Factory(__ngFactoryType__) {
      return (ɵMessages_BaseFactory || (ɵMessages_BaseFactory = ɵɵgetInheritedFactory(_Messages)))(__ngFactoryType__ || _Messages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _Messages,
    inputs: {
      cancel: "cancel",
      clearSelectedFiles: "clearSelectedFiles",
      dropFilesHere: "dropFilesHere",
      externalDropFilesHere: "externalDropFilesHere",
      filesBatchStatus: "filesBatchStatus",
      filesBatchStatusFailed: "filesBatchStatusFailed",
      filesBatchStatusUploaded: "filesBatchStatusUploaded",
      fileStatusFailed: "fileStatusFailed",
      fileStatusUploaded: "fileStatusUploaded",
      headerStatusPaused: "headerStatusPaused",
      headerStatusUploaded: "headerStatusUploaded",
      headerStatusUploading: "headerStatusUploading",
      invalidFileExtension: "invalidFileExtension",
      invalidMaxFileSize: "invalidMaxFileSize",
      invalidMinFileSize: "invalidMinFileSize",
      pause: "pause",
      remove: "remove",
      resume: "resume",
      retry: "retry",
      select: "select",
      uploadSelectedFiles: "uploadSelectedFiles"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Messages4, [{
    type: Directive
  }], null, {
    cancel: [{
      type: Input
    }],
    clearSelectedFiles: [{
      type: Input
    }],
    dropFilesHere: [{
      type: Input
    }],
    externalDropFilesHere: [{
      type: Input
    }],
    filesBatchStatus: [{
      type: Input
    }],
    filesBatchStatusFailed: [{
      type: Input
    }],
    filesBatchStatusUploaded: [{
      type: Input
    }],
    fileStatusFailed: [{
      type: Input
    }],
    fileStatusUploaded: [{
      type: Input
    }],
    headerStatusPaused: [{
      type: Input
    }],
    headerStatusUploaded: [{
      type: Input
    }],
    headerStatusUploading: [{
      type: Input
    }],
    invalidFileExtension: [{
      type: Input
    }],
    invalidMaxFileSize: [{
      type: Input
    }],
    invalidMinFileSize: [{
      type: Input
    }],
    pause: [{
      type: Input
    }],
    remove: [{
      type: Input
    }],
    resume: [{
      type: Input
    }],
    retry: [{
      type: Input
    }],
    select: [{
      type: Input
    }],
    uploadSelectedFiles: [{
      type: Input
    }]
  });
})();
var LocalizedMessagesDirective3 = class _LocalizedMessagesDirective extends Messages4 {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function LocalizedMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LocalizedMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LocalizedMessagesDirective,
    selectors: [["", "kendoUploadLocalizedMessages", ""], ["", "kendoFileSelectLocalizedMessages", ""], ["", "kendoUploadDropZoneLocalizedMessages", ""]],
    features: [ɵɵProvidersFeature([{
      provide: Messages4,
      useExisting: forwardRef(() => _LocalizedMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalizedMessagesDirective3, [{
    type: Directive,
    args: [{
      providers: [{
        provide: Messages4,
        useExisting: forwardRef(() => LocalizedMessagesDirective3)
      }],
      selector: `
    [kendoUploadLocalizedMessages],
    [kendoFileSelectLocalizedMessages],
    [kendoUploadDropZoneLocalizedMessages]
  `,
      standalone: true
    }]
  }], () => [{
    type: LocalizationService
  }], null);
})();
var UPLOAD_VALUE_ACCESSOR = {
  multi: true,
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => UploadComponent)
};
var idx$1 = 0;
var UploadComponent = class _UploadComponent extends UploadFileSelectBase {
  uploadService;
  localization;
  navigation;
  dropZoneService;
  zone;
  renderer;
  cdr;
  injector;
  /**
   * Specifies whether selected files upload automatically
   * ([see example]({% slug fileprocessing_upload %}#toc-automatic-upload-of-files)).
   * Set `autoUpload` to `false` to change this behavior.
   *
   * @default true
   */
  set autoUpload(autoUpload) {
    this.uploadService.async.autoUpload = autoUpload;
  }
  get autoUpload() {
    return this.uploadService.async.autoUpload;
  }
  /**
   * Specifies whether all files in the selection upload in a single request
   * ([see example]({% slug fileprocessing_upload %}#toc-upload-of-batches-of-files)).
   * Files selected one after the other upload in separate requests.
   *
   * @default false
   */
  set batch(batch) {
    this.uploadService.async.batch = batch;
  }
  get batch() {
    return this.uploadService.async.batch;
  }
  /**
   * Specifies whether credentials (cookies, headers) are sent for cross-site requests
   * ([see example]({% slug credentials_upload %}#toc-attaching-credentials-to-requests)).
   * Set `withCredentials` has no effect on same-site requests.
   * Use the `saveHeaders` or `removeHeaders` property to add credentials to the request.
   * You can also use the [`upload`]({% slug api_upload_uploadevent %}) event.
   *
   * @default true
   */
  set withCredentials(withCredentials) {
    this.uploadService.async.withCredentials = withCredentials;
  }
  get withCredentials() {
    return this.uploadService.async.withCredentials;
  }
  /**
   * Specifies the [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) key which contains the files submitted to `saveUrl`.
   *
   */
  set saveField(saveField) {
    this.uploadService.async.saveField = saveField;
  }
  get saveField() {
    return this.uploadService.async.saveField;
  }
  /**
   * Specifies the [`HttpHeaders`](https://angular.io/api/common/http/HttpHeaders) attached to each upload request.
   */
  set saveHeaders(saveHeaders) {
    this.uploadService.async.saveHeaders = saveHeaders;
  }
  get saveHeaders() {
    return this.uploadService.async.saveHeaders;
  }
  /**
   * Specifies the [`RequestMethod`](https://angular.io/api/http/RequestMethod) of the upload request.
   *
   */
  set saveMethod(saveMethod) {
    this.uploadService.async.saveMethod = saveMethod;
  }
  get saveMethod() {
    return this.uploadService.async.saveMethod;
  }
  /**
   * Specifies the URL of the endpoint for the upload request.
   * The request [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) key uses the name from the `saveField` property.
   * This key contains the list of files to be uploaded.
   */
  set saveUrl(saveUrl) {
    this.uploadService.async.saveUrl = saveUrl;
  }
  get saveUrl() {
    return this.uploadService.async.saveUrl;
  }
  /**
   * Specifies the expected [`response type`](https://angular.io/api/common/http/HttpRequest#responseType) of the server.
   * The response type determines how the response is parsed.
   *
   * @default 'json'
   */
  set responseType(responseType) {
    this.uploadService.async.responseType = responseType;
  }
  get responseType() {
    return this.uploadService.async.responseType;
  }
  /**
   * Specifies the [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) key which contains the list of file names submitted to `removeUrl`.
   *
   */
  set removeField(removeField) {
    this.uploadService.async.removeField = removeField;
  }
  get removeField() {
    return this.uploadService.async.removeField;
  }
  /**
   * Specifies the [`HttpHeaders`](https://angular.io/api/common/http/HttpHeaders) attached to each `remove` request.
   */
  set removeHeaders(removeHeaders) {
    this.uploadService.async.removeHeaders = removeHeaders;
  }
  get removeHeaders() {
    return this.uploadService.async.removeHeaders;
  }
  /**
   * Specifies the [`RequestMethod`](https://angular.io/api/http/RequestMethod) of the `remove` request.
   *
   */
  set removeMethod(removeMethod) {
    this.uploadService.async.removeMethod = removeMethod;
  }
  get removeMethod() {
    return this.uploadService.async.removeMethod;
  }
  /**
   * Specifies the URL of the endpoint for the `remove` request.
   * The [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) request key uses the name from the `removeField` property.
   * This key contains the list of file names to be removed.
   */
  set removeUrl(removeUrl) {
    this.uploadService.async.removeUrl = removeUrl;
  }
  get removeUrl() {
    return this.uploadService.async.removeUrl;
  }
  /**
   * Specifies whether the chunk functionality of the Upload is enabled.
   *
   * @default false
   */
  chunkable = false;
  /**
   * Specifies whether selected files upload simultaneously or one by one.
   *
   * @default true
   */
  set concurrent(concurrent) {
    this.uploadService.async.concurrent = concurrent;
  }
  get concurrent() {
    return this.uploadService.async.concurrent;
  }
  /**
   * Specifies whether the file list is visible.
   *
   * @default true
   */
  showFileList = true;
  /**
   * @hidden
   */
  set tabIndex(tabIndex) {
    this.tabindex = tabIndex;
  }
  get tabIndex() {
    return this.tabindex;
  }
  /**
   * Specifies the layout of the action buttons.
   *
   * @default 'end'
   */
  actionsLayout = "end";
  fileSelectInput;
  /**
   * Fires when the upload is canceled while in progress.
   */
  cancel = new EventEmitter();
  /**
   * Fires when the file list is about to be cleared.
   * Prevent this event to keep the files in the list.
   */
  clear = new EventEmitter();
  /**
   * Fires when all active uploads complete successfully or with errors.
   */
  complete = new EventEmitter();
  /**
   * Fires when an `upload` or `remove` operation fails.
   */
  error = new EventEmitter();
  /**
   * Fires when the upload of a file is paused.
   */
  pause = new EventEmitter();
  /**
   * Fires when the upload of a file is resumed.
   */
  resume = new EventEmitter();
  /**
   * Fires when an `upload` or `remove` operation completes successfully.
   */
  success = new EventEmitter();
  /**
   * Fires when one or more files are about to be uploaded.
   * Prevent this event to stop the files from uploading and being added to the file list.
   */
  upload = new EventEmitter();
  /**
   * Fires when one or more files are uploading.
   */
  uploadProgress = new EventEmitter();
  /**
   * Fires when the component value changes after a successful `upload`, `remove`, or `clear` operation.
   */
  valueChange = new EventEmitter();
  get dir() {
    return this.direction;
  }
  direction;
  wrapper;
  fileListId;
  documentClick;
  blurSubscription;
  wrapperFocusSubscription;
  selectButtonFocusSubscription;
  localizationChangeSubscription;
  subs;
  constructor(uploadService, localization, navigation, dropZoneService, zone, renderer, cdr, wrapper, injector) {
    super(uploadService, navigation, cdr, injector, zone);
    this.uploadService = uploadService;
    this.localization = localization;
    this.navigation = navigation;
    this.dropZoneService = dropZoneService;
    this.zone = zone;
    this.renderer = renderer;
    this.cdr = cdr;
    this.injector = injector;
    N(packageMetadata6);
    this.fileList = this.uploadService.files;
    this.localizationChangeSubscription = localization.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
    });
    this.direction = localization.rtl ? "rtl" : "ltr";
    this.navigation.computeKeys();
    this.wrapper = wrapper.nativeElement;
    this.subscribeBlur();
    this.subscribeFocus();
    this.attachEventHandlers();
  }
  ngOnInit() {
    this.verifySettings();
    const {
      buttonId,
      fileListId
    } = this.getIds();
    this.focusableId = buttonId;
    this.fileListId = fileListId;
    this.uploadService.setChunkSettings(this.chunkable);
    if (this.zoneId) {
      this.dropZoneService.addComponent(this, this.zoneId);
    }
    this.zone.runOutsideAngular(() => {
      this.subs.add(this.renderer.listen(this.wrapper, "keydown", (event) => this.handleKeydown(event)));
    });
  }
  ngOnChanges(changes) {
    if (isChanged("chunkable", changes)) {
      const newChunkable = changes.chunkable.currentValue;
      if (typeof newChunkable === "boolean") {
        this.uploadService.async.chunk = newChunkable;
      }
      if (typeof newChunkable === "object" && newChunkable !== null) {
        this.uploadService.async.chunk = true;
        this.uploadService.chunk = Object.assign({}, this.uploadService.chunk, newChunkable);
      }
    }
  }
  ngOnDestroy() {
    this.fileList.clear();
    if (this.zoneId) {
      this.dropZoneService.clearComponent(this, this.zoneId);
    }
    if (this.blurSubscription) {
      this.blurSubscription.unsubscribe();
    }
    if (this.wrapperFocusSubscription) {
      this.wrapperFocusSubscription.unsubscribe();
    }
    if (this.selectButtonFocusSubscription) {
      this.selectButtonFocusSubscription.unsubscribe();
    }
    if (this.localizationChangeSubscription) {
      this.localizationChangeSubscription.unsubscribe();
    }
    if (this.subs) {
      this.subs.unsubscribe();
    }
  }
  /**
   * @hidden
   */
  writeValue(newValue) {
    super.writeValue(newValue, validateInitialFileInfo, "addInitialFiles");
  }
  /**
   * @hidden
   */
  get showActionButtons() {
    let areVisible = false;
    if (!this.autoUpload) {
      const hasFilesToUpload = this.fileList.filesToUpload.length > 0;
      const uploadingFiles = this.fileList.hasFileWithState([FileState.Uploading]);
      if (this.concurrent && hasFilesToUpload) {
        areVisible = true;
      }
      if (!this.concurrent && hasFilesToUpload && !uploadingFiles) {
        areVisible = true;
      }
    }
    this.navigation.actionButtonsVisible = areVisible;
    return areVisible;
  }
  /**
   * @hidden
   */
  get showTotalStatus() {
    const states = [FileState.Uploaded, FileState.Uploading, FileState.Failed, FileState.Paused];
    if (this.fileList.hasFileWithState(states)) {
      return true;
    }
    return false;
  }
  /**
   * @hidden
   */
  textFor(key) {
    return this.localization.get(key);
  }
  /**
   * @hidden
   */
  getIds() {
    const id3 = ++idx$1;
    const buttonId = `k-upload-button-${id3}`;
    const fileListId = `k-upload-file-list-${id3}`;
    return {
      buttonId,
      fileListId
    };
  }
  /**
   * Pauses the upload process of a file that is currently uploading.
   * This method requires the `chunkable` option of the Upload to be enabled.
   *
   * @param uid The `uid` of the file that will be paused.
   */
  pauseFileByUid(uid) {
    this.uploadService.pauseFile(uid);
  }
  /**
   * Resumes the upload process for a file that was previously paused.
   * This method requires the `chunkable` option of the Upload to be enabled.
   *
   * @param uid The `uid` of the file that will be resumed.
   */
  resumeFileByUid(uid) {
    this.uploadService.resumeFile(uid);
  }
  /**
   * Removes a file or a batch of files.
   *
   * @param uid The `uid` of the file or a batch of files that will be removed.
   */
  removeFilesByUid(uid) {
    this.uploadService.removeFiles(uid);
  }
  /**
   * Retries the upload of a file or batch of files that failed to upload.
   *
   * @param uid The `uid` of the file or a batch of files to be retried.
   */
  retryUploadByUid(uid) {
    this.uploadService.retryFiles(uid);
  }
  /**
   * Cancels the upload of a file or a batch of files.
   *
   * @param uid The `uid` of the file or a batch of files that will be canceled.
   */
  cancelUploadByUid(uid) {
    this.uploadService.cancelFiles(uid);
  }
  /**
   * Uploads the currently selected files that pass the set restrictions.
   */
  uploadFiles() {
    if (this.fileList.filesToUpload.length) {
      this.uploadService.uploadFiles();
    }
  }
  /**
   * Clears all files from the UI without sending requests to the remove handler.
   */
  clearFiles() {
    this.uploadService.clearFiles();
  }
  /**
   * @hidden
   * Used by the external dropzone to add files to the Upload
   */
  addFiles(files) {
    this.uploadService.addFiles(files);
  }
  /**
   * @hidden
   * Used to determine if the component is empty.
   */
  isEmpty() {
    return false;
  }
  verifySettings() {
    if (isDevMode()) {
      if (this.batch && this.chunkable !== false) {
        throw new Error("The file chunking functionality requires the batch setting to be disabled.");
      }
    }
  }
  subscribeBlur() {
    if (!isDocumentAvailable()) {
      return;
    }
    this.zone.runOutsideAngular(() => {
      this.documentClick = fromEvent(document, "click").pipe(filter((event) => {
        return !(this.wrapper !== event.target && this.wrapper.contains(event.target));
      }));
      this.blurSubscription = merge(this.documentClick, this.navigation.onTabOut).subscribe(() => {
        if (this.navigation.focused) {
          this.zone.run(() => {
            this.navigation.focused = false;
            this.onTouchedCallback();
            this.onBlur.emit();
          });
        }
      });
    });
  }
  handleKeydown(event) {
    if (this.disabled) {
      return;
    }
    if (event.target === this.fileSelectButton.nativeElement && (event.code === Keys.Enter || event.code === Keys.Space)) {
      event.preventDefault();
      this.fileSelectInput.nativeElement.click();
      return;
    }
    if (hasClasses2(event.target, UPLOAD_CLASSES) || !isFocusable3(event.target) && !hasClasses2(event.target, IGNORE_TARGET_CLASSES)) {
      this.navigation.process(event);
    }
  }
  subscribeFocus() {
    this.wrapperFocusSubscription = this.navigation.onWrapperFocus.subscribe(() => {
      this.onFocus.emit();
    });
    this.selectButtonFocusSubscription = this.navigation.onSelectButtonFocus.subscribe(() => {
      this.fileSelectButton.nativeElement.focus();
    });
  }
  attachEventHandlers() {
    this.subs = this.uploadService.cancelEvent.subscribe((args) => {
      this.cancel.emit(args);
    });
    this.subs.add(this.uploadService.changeEvent.subscribe((files) => {
      this.onChangeCallback(files);
      this.valueChange.emit(files);
    }));
    this.subs.add(this.uploadService.clearEvent.subscribe((args) => {
      this.clear.emit(args);
    }));
    this.subs.add(this.uploadService.completeEvent.subscribe(() => {
      this.complete.emit();
    }));
    this.subs.add(this.uploadService.errorEvent.subscribe((args) => {
      this.error.emit(args);
    }));
    this.subs.add(this.uploadService.pauseEvent.subscribe((args) => {
      this.pause.emit(args);
    }));
    this.subs.add(this.uploadService.removeEvent.subscribe((args) => {
      this.remove.emit(args);
    }));
    this.subs.add(this.uploadService.resumeEvent.subscribe((args) => {
      this.resume.emit(args);
    }));
    this.subs.add(this.uploadService.selectEvent.subscribe((args) => {
      this.select.emit(args);
    }));
    this.subs.add(this.uploadService.successEvent.subscribe((args) => {
      this.success.emit(args);
    }));
    this.subs.add(this.uploadService.uploadEvent.subscribe((args) => {
      this.upload.emit(args);
    }));
    this.subs.add(this.uploadService.uploadProgressEvent.subscribe((args) => {
      this.uploadProgress.emit(args);
    }));
  }
  static ɵfac = function UploadComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _UploadComponent)(ɵɵdirectiveInject(UploadService), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(NavigationService2), ɵɵdirectiveInject(DropZoneService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Injector));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _UploadComponent,
    selectors: [["kendo-upload"]],
    viewQuery: function UploadComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c93, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.fileSelectInput = _t.first);
      }
    },
    hostVars: 1,
    hostBindings: function UploadComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.dir);
      }
    },
    inputs: {
      autoUpload: "autoUpload",
      batch: "batch",
      withCredentials: "withCredentials",
      saveField: "saveField",
      saveHeaders: "saveHeaders",
      saveMethod: "saveMethod",
      saveUrl: "saveUrl",
      responseType: "responseType",
      removeField: "removeField",
      removeHeaders: "removeHeaders",
      removeMethod: "removeMethod",
      removeUrl: "removeUrl",
      chunkable: "chunkable",
      concurrent: "concurrent",
      showFileList: "showFileList",
      tabIndex: "tabIndex",
      actionsLayout: "actionsLayout"
    },
    outputs: {
      cancel: "cancel",
      clear: "clear",
      complete: "complete",
      error: "error",
      pause: "pause",
      resume: "resume",
      success: "success",
      upload: "upload",
      uploadProgress: "uploadProgress",
      valueChange: "valueChange"
    },
    exportAs: ["kendoUpload"],
    features: [ɵɵProvidersFeature([LocalizationService, NavigationService2, UploadService, DropZoneService, UPLOAD_VALUE_ACCESSOR, {
      provide: L10N_PREFIX,
      useValue: "kendo.upload"
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _UploadComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
    decls: 13,
    vars: 19,
    consts: () => {
      let i18n_0;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_0 = goog.getMsg("Cancel");
        i18n_0 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_0;
      } else {
        i18n_0 = $localize`:kendo.upload.cancel|The text for the Cancel button:Cancel`;
      }
      let i18n_1;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_1 = goog.getMsg("Clear");
        i18n_1 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_1;
      } else {
        i18n_1 = $localize`:kendo.upload.clearSelectedFiles|The text for the Clear button:Clear`;
      }
      let i18n_2;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_2 = goog.getMsg("Drop files here to upload");
        i18n_2 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_2;
      } else {
        i18n_2 = $localize`:kendo.upload.dropFilesHere|The drop zone hint:Drop files here to upload`;
      }
      let i18n_3;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_3 = goog.getMsg("files");
        i18n_3 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_3;
      } else {
        i18n_3 = $localize`:kendo.upload.filesBatchStatus|The status message for a batch of files:files`;
      }
      let i18n_4;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_4 = goog.getMsg("files failed to upload.");
        i18n_4 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_4;
      } else {
        i18n_4 = $localize`:kendo.upload.filesBatchStatusFailed|The status message for a batch of files after failed upload:files failed to upload.`;
      }
      let i18n_5;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_5 = goog.getMsg("files successfully uploaded.");
        i18n_5 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_5;
      } else {
        i18n_5 = $localize`:kendo.upload.filesBatchStatusUploaded|The status message for a batch of files after successful upload:files successfully uploaded.`;
      }
      let i18n_6;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_6 = goog.getMsg("File failed to upload.");
        i18n_6 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_6;
      } else {
        i18n_6 = $localize`:kendo.upload.fileStatusFailed|The file status message after failed upload:File failed to upload.`;
      }
      let i18n_7;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_7 = goog.getMsg("File successfully uploaded.");
        i18n_7 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_7;
      } else {
        i18n_7 = $localize`:kendo.upload.fileStatusUploaded|The file status message after successful upload:File successfully uploaded.`;
      }
      let i18n_8;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_8 = goog.getMsg("Paused");
        i18n_8 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_8;
      } else {
        i18n_8 = $localize`:kendo.upload.headerStatusPaused|The header status message when the file upload is paused:Paused`;
      }
      let i18n_9;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_9 = goog.getMsg("Done");
        i18n_9 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_9;
      } else {
        i18n_9 = $localize`:kendo.upload.headerStatusUploaded|The header status message after file upload completion:Done`;
      }
      let i18n_10;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_10 = goog.getMsg("Uploading...");
        i18n_10 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_10;
      } else {
        i18n_10 = $localize`:kendo.upload.headerStatusUploading|The header status message during file upload:Uploading...`;
      }
      let i18n_11;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_11 = goog.getMsg("File type not allowed.");
        i18n_11 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_11;
      } else {
        i18n_11 = $localize`:kendo.upload.invalidFileExtension|The text for the invalid allowed extensions restriction message:File type not allowed.`;
      }
      let i18n_12;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_12 = goog.getMsg("File size too large.");
        i18n_12 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_12;
      } else {
        i18n_12 = $localize`:kendo.upload.invalidMaxFileSize|The text for the invalid max file size restriction message:File size too large.`;
      }
      let i18n_13;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_13 = goog.getMsg("File size too small.");
        i18n_13 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_13;
      } else {
        i18n_13 = $localize`:kendo.upload.invalidMinFileSize|The text for the invalid min file size restriction message:File size too small.`;
      }
      let i18n_14;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_14 = goog.getMsg("Pause");
        i18n_14 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_14;
      } else {
        i18n_14 = $localize`:kendo.upload.pause|The text for the Pause button:Pause`;
      }
      let i18n_15;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_15 = goog.getMsg("Remove");
        i18n_15 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_15;
      } else {
        i18n_15 = $localize`:kendo.upload.remove|The text for the Remove button:Remove`;
      }
      let i18n_16;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_16 = goog.getMsg("Resume");
        i18n_16 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_16;
      } else {
        i18n_16 = $localize`:kendo.upload.resume|The text for the Resume button:Resume`;
      }
      let i18n_17;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_17 = goog.getMsg("Retry");
        i18n_17 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_17;
      } else {
        i18n_17 = $localize`:kendo.upload.retry|The text for the Retry button:Retry`;
      }
      let i18n_18;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_18 = goog.getMsg("Select files...");
        i18n_18 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_18;
      } else {
        i18n_18 = $localize`:kendo.upload.select|The text for the Select button:Select files...`;
      }
      let i18n_19;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_19 = goog.getMsg("Upload");
        i18n_19 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_19;
      } else {
        i18n_19 = $localize`:kendo.upload.uploadSelectedFiles|The text for the Upload files button:Upload`;
      }
      return [["fileSelectButton", ""], ["fileSelectInput", ""], ["kendoUploadLocalizedMessages", "", "cancel", i18n_0, "clearSelectedFiles", i18n_1, "dropFilesHere", i18n_2, "filesBatchStatus", i18n_3, "filesBatchStatusFailed", i18n_4, "filesBatchStatusUploaded", i18n_5, "fileStatusFailed", i18n_6, "fileStatusUploaded", i18n_7, "headerStatusPaused", i18n_8, "headerStatusUploaded", i18n_9, "headerStatusUploading", i18n_10, "invalidFileExtension", i18n_11, "invalidMaxFileSize", i18n_12, "invalidMinFileSize", i18n_13, "pause", i18n_14, "remove", i18n_15, "resume", i18n_16, "retry", i18n_17, "select", i18n_18, "uploadSelectedFiles", i18n_19], ["kendoUploadInternalDropZone", "", 3, "restrictions", "multiple", "disabled"], [1, "k-upload-button-wrap"], ["kendoButton", "", "type", "button", 1, "k-upload-button", 3, "click", "focus", "id"], ["kendoFileSelect", "", 3, "dir", "accept", "restrictions", "multiple", "disabled", "required"], [1, "k-upload-status", 3, "fileList"], [1, "k-dropzone-hint"], ["kendo-upload-file-list", "", 1, "k-upload-files", "k-reset", 3, "disabled", "fileList", "fileTemplate", "fileInfoTemplate", "id"], [3, "disabled", "actionsLayout"]];
    },
    template: function UploadComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainer(0, 2);
        ɵɵelementStart(1, "div", 3)(2, "div", 4)(3, "button", 5, 0);
        ɵɵlistener("click", function UploadComponent_Template_button_click_3_listener() {
          ɵɵrestoreView(_r1);
          const fileSelectInput_r2 = ɵɵreference(7);
          return ɵɵresetView(fileSelectInput_r2.click());
        })("focus", function UploadComponent_Template_button_focus_3_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onFileSelectButtonFocus());
        });
        ɵɵtext(5);
        ɵɵelementEnd();
        ɵɵelement(6, "input", 6, 1);
        ɵɵelementEnd();
        ɵɵconditionalCreate(8, UploadComponent_Conditional_8_Template, 1, 1, "kendo-upload-status-total", 7);
        ɵɵelementStart(9, "div", 8);
        ɵɵtext(10);
        ɵɵelementEnd()();
        ɵɵconditionalCreate(11, UploadComponent_Conditional_11_Template, 1, 5, "ul", 9);
        ɵɵconditionalCreate(12, UploadComponent_Conditional_12_Template, 1, 2, "kendo-upload-action-buttons", 10);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("restrictions", ctx.restrictions)("multiple", ctx.multiple)("disabled", ctx.disabled);
        ɵɵadvance(2);
        ɵɵproperty("id", ctx.focusableId);
        ɵɵattribute("aria-label", ctx.textFor("select"))("tabindex", ctx.tabindex)("aria-expanded", ctx.hasFileList)("aria-controls", ctx.hasFileList ? ctx.fileListId : void 0);
        ɵɵadvance(2);
        ɵɵtextInterpolate1(" ", ctx.textFor("select"), " ");
        ɵɵadvance();
        ɵɵproperty("dir", ctx.direction)("accept", ctx.accept)("restrictions", ctx.restrictions)("multiple", ctx.multiple)("disabled", ctx.disabled)("required", ctx.isControlRequired);
        ɵɵadvance(2);
        ɵɵconditional(ctx.showTotalStatus ? 8 : -1);
        ɵɵadvance(2);
        ɵɵtextInterpolate(ctx.textFor("dropFilesHere"));
        ɵɵadvance();
        ɵɵconditional(ctx.hasFileList ? 11 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.showActionButtons ? 12 : -1);
      }
    },
    dependencies: [LocalizedMessagesDirective3, DropZoneInternalDirective, ButtonComponent, FileSelectDirective, UploadStatusTotalComponent, FileListComponent, UploadActionButtonsComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UploadComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoUpload",
      providers: [LocalizationService, NavigationService2, UploadService, DropZoneService, UPLOAD_VALUE_ACCESSOR, {
        provide: L10N_PREFIX,
        useValue: "kendo.upload"
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => UploadComponent)
      }],
      selector: "kendo-upload",
      template: `
    <ng-container kendoUploadLocalizedMessages
      i18n-cancel="kendo.upload.cancel|The text for the Cancel button"
      cancel="Cancel"
    
      i18n-clearSelectedFiles="kendo.upload.clearSelectedFiles|The text for the Clear button"
      clearSelectedFiles="Clear"
    
      i18n-dropFilesHere="kendo.upload.dropFilesHere|The drop zone hint"
      dropFilesHere="Drop files here to upload"
    
      i18n-filesBatchStatus="kendo.upload.filesBatchStatus|The status message for a batch of files"
      filesBatchStatus="files"
    
      i18n-filesBatchStatusFailed="kendo.upload.filesBatchStatusFailed|The status message for a batch of files after failed upload"
      filesBatchStatusFailed="files failed to upload."
    
      i18n-filesBatchStatusUploaded="kendo.upload.filesBatchStatusUploaded|The status message for a batch of files after successful upload"
      filesBatchStatusUploaded="files successfully uploaded."
    
      i18n-fileStatusFailed="kendo.upload.fileStatusFailed|The file status message after failed upload"
      fileStatusFailed="File failed to upload."
    
      i18n-fileStatusUploaded="kendo.upload.fileStatusUploaded|The file status message after successful upload"
      fileStatusUploaded="File successfully uploaded."
    
      i18n-headerStatusPaused="kendo.upload.headerStatusPaused|The header status message when the file upload is paused"
      headerStatusPaused="Paused"
    
      i18n-headerStatusUploaded="kendo.upload.headerStatusUploaded|The header status message after file upload completion"
      headerStatusUploaded="Done"
    
      i18n-headerStatusUploading="kendo.upload.headerStatusUploading|The header status message during file upload"
      headerStatusUploading="Uploading..."
    
      i18n-invalidFileExtension="kendo.upload.invalidFileExtension|The text for the invalid allowed extensions restriction message"
      invalidFileExtension="File type not allowed."
    
      i18n-invalidMaxFileSize="kendo.upload.invalidMaxFileSize|The text for the invalid max file size restriction message"
      invalidMaxFileSize="File size too large."
    
      i18n-invalidMinFileSize="kendo.upload.invalidMinFileSize|The text for the invalid min file size restriction message"
      invalidMinFileSize="File size too small."
    
      i18n-pause="kendo.upload.pause|The text for the Pause button"
      pause="Pause"
    
      i18n-remove="kendo.upload.remove|The text for the Remove button"
      remove="Remove"
    
      i18n-resume="kendo.upload.resume|The text for the Resume button"
      resume="Resume"
    
      i18n-retry="kendo.upload.retry|The text for the Retry button"
      retry="Retry"
    
      i18n-select="kendo.upload.select|The text for the Select button"
      select="Select files..."
    
      i18n-uploadSelectedFiles="kendo.upload.uploadSelectedFiles|The text for the Upload files button"
      uploadSelectedFiles="Upload"
      >
    </ng-container>
    <div kendoUploadInternalDropZone
      [restrictions]="restrictions"
      [multiple]="multiple"
      [disabled]="disabled"
      >
      <div class="k-upload-button-wrap">
        <button
          kendoButton
          #fileSelectButton
          class="k-upload-button"
          type="button"
          (click)="fileSelectInput.click()"
          (focus)="onFileSelectButtonFocus()"
          [id]="focusableId"
          [attr.aria-label]="textFor('select')"
          [attr.tabindex]="tabindex"
          [attr.aria-expanded]="hasFileList"
          [attr.aria-controls]="hasFileList ? fileListId : undefined"
          >
          {{textFor('select')}}
        </button>
        <input kendoFileSelect #fileSelectInput
          [dir]="direction"
          [accept]="accept"
          [restrictions]="restrictions"
          [multiple]="multiple"
          [disabled]="disabled"
          [required]="isControlRequired" />
      </div>
      @if (showTotalStatus) {
        <kendo-upload-status-total
          class="k-upload-status"
          [fileList]="fileList">
        </kendo-upload-status-total>
      }
      <div class="k-dropzone-hint">{{textFor('dropFilesHere')}}</div>
    </div>
    @if (hasFileList) {
      <ul kendo-upload-file-list
        class="k-upload-files k-reset"
        [disabled]="disabled"
        [fileList]="fileList.files"
        [fileTemplate]="fileTemplate"
        [fileInfoTemplate]="fileInfoTemplate"
        [id]="fileListId">
      </ul>
    }
    @if (showActionButtons) {
      <kendo-upload-action-buttons
        [disabled]="disabled"
        [actionsLayout]="actionsLayout">
      </kendo-upload-action-buttons>
    }
    `,
      standalone: true,
      imports: [LocalizedMessagesDirective3, DropZoneInternalDirective, ButtonComponent, FileSelectDirective, UploadStatusTotalComponent, FileListComponent, UploadActionButtonsComponent]
    }]
  }], () => [{
    type: UploadService
  }, {
    type: LocalizationService
  }, {
    type: NavigationService2
  }, {
    type: DropZoneService
  }, {
    type: NgZone
  }, {
    type: Renderer2
  }, {
    type: ChangeDetectorRef
  }, {
    type: ElementRef
  }, {
    type: Injector
  }], {
    autoUpload: [{
      type: Input
    }],
    batch: [{
      type: Input
    }],
    withCredentials: [{
      type: Input
    }],
    saveField: [{
      type: Input
    }],
    saveHeaders: [{
      type: Input
    }],
    saveMethod: [{
      type: Input
    }],
    saveUrl: [{
      type: Input
    }],
    responseType: [{
      type: Input
    }],
    removeField: [{
      type: Input
    }],
    removeHeaders: [{
      type: Input
    }],
    removeMethod: [{
      type: Input
    }],
    removeUrl: [{
      type: Input
    }],
    chunkable: [{
      type: Input
    }],
    concurrent: [{
      type: Input
    }],
    showFileList: [{
      type: Input
    }],
    tabIndex: [{
      type: Input,
      args: ["tabIndex"]
    }],
    actionsLayout: [{
      type: Input
    }],
    fileSelectInput: [{
      type: ViewChild,
      args: ["fileSelectInput", {
        static: true
      }]
    }],
    cancel: [{
      type: Output
    }],
    clear: [{
      type: Output
    }],
    complete: [{
      type: Output
    }],
    error: [{
      type: Output
    }],
    pause: [{
      type: Output
    }],
    resume: [{
      type: Output
    }],
    success: [{
      type: Output
    }],
    upload: [{
      type: Output
    }],
    uploadProgress: [{
      type: Output
    }],
    valueChange: [{
      type: Output
    }],
    dir: [{
      type: HostBinding,
      args: ["attr.dir"]
    }]
  });
})();
var UploadDropZoneDirective = class _UploadDropZoneDirective {
  dropZoneService;
  /**
   * The id of the drop zone to associate with an existing Upload component.
   */
  zoneId;
  /**
   * The id of the drop zone to associate with an existing FileSelect component.
   */
  fileSelectZoneId;
  constructor(dropZoneService) {
    this.dropZoneService = dropZoneService;
  }
  /**
   * @hidden
   */
  onElementDragEnter() {
    return false;
  }
  /**
   * @hidden
   */
  onElementDragOver() {
    return false;
  }
  /**
   * @hidden
   */
  onDropListener(event) {
    const components2 = this.componentInstance;
    if (!isPresent6(components2)) {
      return;
    }
    components2.forEach((component) => {
      const droppedFiles = event.dataTransfer.files;
      if (droppedFiles.length > 0 && !component.disabled) {
        let files = getAllFileInfo(droppedFiles);
        if (component instanceof UploadComponent) {
          files = assignGuidToFiles(files, !component.batch);
        } else {
          files = assignGuidToFiles(files, true);
        }
        if (!component.multiple) {
          files.splice(1, files.length - 1);
          component.clearFiles();
        }
        validateFiles(files, component.restrictions);
        component.addFiles(files);
      }
    });
    return false;
  }
  /**
   * @hidden
   */
  get componentInstance() {
    const id3 = this.zoneId || this.fileSelectZoneId;
    return this.dropZoneService.getComponents(id3);
  }
  static ɵfac = function UploadDropZoneDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _UploadDropZoneDirective)(ɵɵdirectiveInject(DropZoneService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _UploadDropZoneDirective,
    selectors: [["", "kendoUploadDropZone", ""], ["", "kendoFileSelectDropZone", ""]],
    hostBindings: function UploadDropZoneDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("dragenter", function UploadDropZoneDirective_dragenter_HostBindingHandler() {
          return ctx.onElementDragEnter();
        })("dragover", function UploadDropZoneDirective_dragover_HostBindingHandler() {
          return ctx.onElementDragOver();
        })("drop", function UploadDropZoneDirective_drop_HostBindingHandler($event) {
          return ctx.onDropListener($event);
        });
      }
    },
    inputs: {
      zoneId: [0, "kendoUploadDropZone", "zoneId"],
      fileSelectZoneId: [0, "kendoFileSelectDropZone", "fileSelectZoneId"]
    },
    features: [ɵɵProvidersFeature([DropZoneService])]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UploadDropZoneDirective, [{
    type: Directive,
    args: [{
      providers: [DropZoneService],
      selector: "[kendoUploadDropZone], [kendoFileSelectDropZone]",
      standalone: true
    }]
  }], () => [{
    type: DropZoneService
  }], {
    zoneId: [{
      type: Input,
      args: ["kendoUploadDropZone"]
    }],
    fileSelectZoneId: [{
      type: Input,
      args: ["kendoFileSelectDropZone"]
    }],
    onElementDragEnter: [{
      type: HostListener,
      args: ["dragenter"]
    }],
    onElementDragOver: [{
      type: HostListener,
      args: ["dragover"]
    }],
    onDropListener: [{
      type: HostListener,
      args: ["drop", ["$event"]]
    }]
  });
})();
var UploadDropZoneComponent = class _UploadDropZoneComponent extends DropZoneBase {
  localization;
  hostClass = true;
  get dirAttribute() {
    return this.direction;
  }
  /**
   * Specifies the id of the component.
   * Use this id to associate the DropZone with an existing Upload or FileSelect component.
   */
  zoneId;
  /**
   * Specifies the name for an existing icon in a Kendo UI theme.
   * The icon renders inside the DropZone.
   */
  icon;
  /**
   * Specifies a CSS class or multiple classes separated by spaces which apply to a span element.
   * Use this property to apply custom icons.
   */
  iconClass;
  /**
   * Specifies an SVGIcon to render inside the DropZone.
   * The input accepts either an [existing Kendo SVG icon](slug:svgicon_list) or a custom one.
   */
  set svgIcon(icon) {
    if (isDevMode() && icon && this.icon && this.iconClass) {
      throw new Error("Setting both icon/svgIcon and iconClass options at the same time is not supported.");
    }
    this._svgIcon = icon;
  }
  get svgIcon() {
    return this._svgIcon;
  }
  direction;
  localizationChangeSubscription;
  _svgIcon = uploadIcon;
  constructor(element, renderer, localization) {
    super(element, renderer, "k-external-dropzone-hover");
    this.localization = localization;
    this.localizationChangeSubscription = this.localization.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
    });
  }
  /**
   * @hidden
   */
  textFor(key) {
    return this.localization.get(key);
  }
  /**
   * @hidden
   */
  get iconClasses() {
    if (this.icon) {
      return `${this.icon}`;
    }
    if (!this.icon && !this.iconClass) {
      return "upload";
    }
  }
  ngOnDestroy() {
    if (this.localizationChangeSubscription) {
      this.localizationChangeSubscription.unsubscribe();
    }
  }
  static ɵfac = function UploadDropZoneComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _UploadDropZoneComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _UploadDropZoneComponent,
    selectors: [["kendo-uploaddropzone"]],
    hostVars: 3,
    hostBindings: function UploadDropZoneComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.dirAttribute);
        ɵɵclassProp("k-external-dropzone", ctx.hostClass);
      }
    },
    inputs: {
      zoneId: "zoneId",
      icon: "icon",
      iconClass: "iconClass",
      svgIcon: "svgIcon"
    },
    exportAs: ["kendoUploadDropZone"],
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.uploaddropzone"
    }]), ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c103,
    decls: 7,
    vars: 5,
    consts: () => {
      let i18n_20;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_20 = goog.getMsg("Drag and drop files here to upload");
        i18n_20 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_20;
      } else {
        i18n_20 = $localize`:kendo.uploaddropzone.externalDropFilesHere|Sets the external drop-zone hint:Drag and drop files here to upload`;
      }
      return [["kendoUploadDropZoneLocalizedMessages", "", "externalDropFilesHere", i18n_20], [1, "k-dropzone-inner", 3, "kendoUploadDropZone"], ["size", "xxxlarge", "innerCssClass", "k-dropzone-icon", 3, "name", "customFontClass", "svgIcon"], [1, "k-dropzone-hint"], [1, "k-dropzone-note"]];
    },
    template: function UploadDropZoneComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵelementContainer(0, 0);
        ɵɵelementStart(1, "div", 1);
        ɵɵelement(2, "kendo-icon-wrapper", 2);
        ɵɵelementStart(3, "span", 3);
        ɵɵtext(4);
        ɵɵelementEnd();
        ɵɵelementStart(5, "span", 4);
        ɵɵprojection(6);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("kendoUploadDropZone", ctx.zoneId);
        ɵɵadvance();
        ɵɵproperty("name", ctx.iconClasses)("customFontClass", ctx.iconClass)("svgIcon", ctx.svgIcon);
        ɵɵadvance(2);
        ɵɵtextInterpolate(ctx.textFor("externalDropFilesHere"));
      }
    },
    dependencies: [LocalizedMessagesDirective3, UploadDropZoneDirective, IconWrapperComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UploadDropZoneComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoUploadDropZone",
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.uploaddropzone"
      }],
      selector: "kendo-uploaddropzone",
      template: `
        <ng-container kendoUploadDropZoneLocalizedMessages
            i18n-externalDropFilesHere='kendo.uploaddropzone.externalDropFilesHere|Sets the external drop-zone hint'
            externalDropFilesHere='Drag and drop files here to upload'>
        </ng-container>
        <div class='k-dropzone-inner' [kendoUploadDropZone]="zoneId">
            <kendo-icon-wrapper
                size="xxxlarge"
                innerCssClass="k-dropzone-icon"
                [name]="iconClasses"
                [customFontClass]="iconClass"
                [svgIcon]="svgIcon"
            ></kendo-icon-wrapper>
            <span class="k-dropzone-hint">{{ textFor('externalDropFilesHere') }}</span>
            <span class="k-dropzone-note">
                <ng-content></ng-content>
            </span>
        </div>
    `,
      standalone: true,
      imports: [LocalizedMessagesDirective3, UploadDropZoneDirective, IconWrapperComponent]
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: LocalizationService
  }], {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-external-dropzone"]
    }],
    dirAttribute: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    zoneId: [{
      type: Input
    }],
    icon: [{
      type: Input
    }],
    iconClass: [{
      type: Input
    }],
    svgIcon: [{
      type: Input
    }]
  });
})();
var FILESELECT_VALUE_ACCESSOR = {
  multi: true,
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => FileSelectComponent)
};
var idx2 = 0;
var FileSelectComponent = class _FileSelectComponent extends UploadFileSelectBase {
  uploadService;
  localization;
  navigation;
  dropZoneService;
  ngZone;
  renderer;
  cdr;
  injector;
  fileSelectInput;
  get dir() {
    return this.direction;
  }
  /**
   * Specifies the `name` attribute of the `input` element of the FileSelect.
   */
  set name(name) {
    this.uploadService.async.saveField = name;
  }
  get name() {
    return this.uploadService.async.saveField;
  }
  /**
   * Fires when the component value changes after a successful `select` or `remove` operation.
   */
  valueChange = new EventEmitter();
  /**
   * @hidden
   */
  _restrictions = {
    allowedExtensions: [],
    maxFileSize: 0,
    minFileSize: 0
  };
  direction;
  wrapper;
  fileListId;
  documentClick;
  blurSubscription;
  wrapperFocusSubscription;
  selectButtonFocusSubscription;
  localizationChangeSubscription;
  subs;
  constructor(uploadService, localization, navigation, dropZoneService, ngZone, renderer, cdr, wrapper, injector) {
    super(uploadService, navigation, cdr, injector, ngZone);
    this.uploadService = uploadService;
    this.localization = localization;
    this.navigation = navigation;
    this.dropZoneService = dropZoneService;
    this.ngZone = ngZone;
    this.renderer = renderer;
    this.cdr = cdr;
    this.injector = injector;
    N(packageMetadata6);
    this.wrapper = wrapper.nativeElement;
    this.direction = localization.rtl ? "rtl" : "ltr";
    this.navigation.computeKeys();
    this.localizationChangeSubscription = localization.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
    });
    this.subscribeBlur();
    this.subscribeFocus();
    this.attachEventHandlers();
    this.setDefaultSettings();
  }
  ngOnInit() {
    const {
      buttonId,
      fileListId
    } = this.getIds();
    this.focusableId = buttonId;
    this.fileListId = fileListId;
    if (this.zoneId) {
      this.dropZoneService.addComponent(this, this.zoneId);
    }
    this.subs.add(this.renderer.listen(this.fileSelectInput.nativeElement, "mouseenter", () => {
      this.renderer.addClass(this.fileSelectButton.nativeElement, "k-hover");
    }));
    this.subs.add(this.renderer.listen(this.fileSelectInput.nativeElement, "mouseleave", () => {
      this.renderer.removeClass(this.fileSelectButton.nativeElement, "k-hover");
    }));
    this.ngZone.runOutsideAngular(() => {
      this.subs.add(this.renderer.listen(this.wrapper, "keydown", (event) => this.handleKeydown(event)));
    });
  }
  /**
   * @hidden
   */
  textFor(key) {
    return this.localization.get(key);
  }
  ngOnDestroy() {
    this.fileList.clear();
    if (this.blurSubscription) {
      this.blurSubscription.unsubscribe();
    }
    if (this.wrapperFocusSubscription) {
      this.wrapperFocusSubscription.unsubscribe();
    }
    if (this.selectButtonFocusSubscription) {
      this.selectButtonFocusSubscription.unsubscribe();
    }
    if (this.localizationChangeSubscription) {
      this.localizationChangeSubscription.unsubscribe();
    }
    if (this.subs) {
      this.subs.unsubscribe();
    }
  }
  /**
   * Removes a specific file from the file list.
   *
   * @param uid The `uid` of the file to be removed.
   */
  removeFileByUid(uid) {
    this.uploadService.removeFiles(uid);
  }
  /**
   * Clears all files from the UI.
   */
  clearFiles() {
    this.uploadService.clearFiles();
  }
  /**
   * @hidden
   * Used to determine if the component is empty.
   */
  isEmpty() {
    return false;
  }
  /**
   * @hidden
   * Used by the external dropzone to add files to the FileSelect
   */
  addFiles(files) {
    this.uploadService.addFiles(files);
  }
  /**
   * @hidden
   */
  get selectButtonTabIndex() {
    return this.disabled ? void 0 : this.tabindex;
  }
  /**
   * @hidden
   */
  getIds() {
    const id3 = ++idx2;
    const buttonId = `k-fileselect-button-${id3}`;
    const fileListId = `k-fileselect-file-list-${id3}`;
    return {
      buttonId,
      fileListId
    };
  }
  /**
   * @hidden
   */
  writeValue(newValue) {
    super.writeValue(newValue, validateInitialFileSelectFile, "addInitialFileSelectFiles");
  }
  subscribeBlur() {
    if (!isDocumentAvailable()) {
      return;
    }
    this.ngZone.runOutsideAngular(() => {
      this.documentClick = fromEvent(document, "click").pipe(filter((event) => {
        return !(this.wrapper !== event.target && this.wrapper.contains(event.target));
      }));
      this.blurSubscription = merge(this.documentClick, this.navigation.onTabOut).subscribe(() => {
        if (this.navigation.focused) {
          this.ngZone.run(() => {
            this.navigation.focused = false;
            this.onTouchedCallback();
            this.onBlur.emit();
          });
        }
      });
    });
  }
  subscribeFocus() {
    this.wrapperFocusSubscription = this.navigation.onWrapperFocus.subscribe(() => {
      this.onFocus.emit();
    });
    this.selectButtonFocusSubscription = this.navigation.onSelectButtonFocus.subscribe(() => {
      this.fileSelectButton.nativeElement.focus();
    });
  }
  handleKeydown(event) {
    if (this.disabled) {
      return;
    }
    if (event.target === this.fileSelectButton.nativeElement && (event.code === Keys.Enter || event.code === Keys.NumpadEnter || event.code === Keys.Space)) {
      event.preventDefault();
      this.fileSelectInput.nativeElement.click();
      return;
    }
    if (hasClasses2(event.target, UPLOAD_CLASSES) || !isFocusable3(event.target) && !hasClasses2(event.target, IGNORE_TARGET_CLASSES)) {
      this.navigation.process(event, "fileselect");
    }
  }
  attachEventHandlers() {
    this.subs = this.uploadService.changeEvent.subscribe((files) => {
      let model = [];
      if (files !== null) {
        files.forEach((file) => {
          if (file.state === FileState.Initial) {
            model.push(file);
          }
          if (file.state === FileState.Selected && file.rawFile && !file.validationErrors) {
            model.push(file.rawFile);
          }
        });
      }
      if (model.length === 0) {
        model = null;
      }
      this.onChangeCallback(model);
      this.valueChange.emit(model);
    });
    this.subs.add(this.uploadService.removeEvent.subscribe((args) => {
      this.remove.emit(args);
    }));
    this.subs.add(this.uploadService.selectEvent.subscribe((args) => {
      this.select.emit(args);
    }));
  }
  setDefaultSettings() {
    this.uploadService.async.autoUpload = false;
    this.uploadService.component = "FileSelect";
  }
  static ɵfac = function FileSelectComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FileSelectComponent)(ɵɵdirectiveInject(UploadService), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(NavigationService2), ɵɵdirectiveInject(DropZoneService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Injector));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _FileSelectComponent,
    selectors: [["kendo-fileselect"]],
    viewQuery: function FileSelectComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c93, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.fileSelectInput = _t.first);
      }
    },
    hostVars: 1,
    hostBindings: function FileSelectComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.dir);
      }
    },
    inputs: {
      name: "name"
    },
    outputs: {
      valueChange: "valueChange"
    },
    exportAs: ["kendoFileSelect"],
    features: [ɵɵProvidersFeature([LocalizationService, NavigationService2, UploadService, DropZoneService, FILESELECT_VALUE_ACCESSOR, {
      provide: L10N_PREFIX,
      useValue: "kendo.fileselect"
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _FileSelectComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 11,
    vars: 17,
    consts: () => {
      let i18n_21;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_21 = goog.getMsg("Drop files here to select");
        i18n_21 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_21;
      } else {
        i18n_21 = $localize`:kendo.fileselect.dropFilesHere|The drop zone hint:Drop files here to select`;
      }
      let i18n_22;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_22 = goog.getMsg("File type not allowed.");
        i18n_22 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_22;
      } else {
        i18n_22 = $localize`:kendo.fileselect.invalidFileExtension|The text for the invalid allowed extensions restriction message:File type not allowed.`;
      }
      let i18n_23;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_23 = goog.getMsg("File size too large.");
        i18n_23 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_23;
      } else {
        i18n_23 = $localize`:kendo.fileselect.invalidMaxFileSize|The text for the invalid max file size restriction message:File size too large.`;
      }
      let i18n_24;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_24 = goog.getMsg("File size too small.");
        i18n_24 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_24;
      } else {
        i18n_24 = $localize`:kendo.fileselect.invalidMinFileSize|The text for the invalid min file size restriction message:File size too small.`;
      }
      let i18n_25;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_25 = goog.getMsg("Remove");
        i18n_25 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_25;
      } else {
        i18n_25 = $localize`:kendo.fileselect.remove|The text for the Remove button:Remove`;
      }
      let i18n_26;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_26 = goog.getMsg("Select files...");
        i18n_26 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_UPLOAD_FESM2022_PROGRESS_KENDO_ANGULAR_UPLOAD_MJS_26;
      } else {
        i18n_26 = $localize`:kendo.fileselect.select|The text for the Select button:Select files...`;
      }
      return [["fileSelectButton", ""], ["fileSelectInput", ""], ["kendoFileSelectLocalizedMessages", "", "dropFilesHere", i18n_21, "invalidFileExtension", i18n_22, "invalidMaxFileSize", i18n_23, "invalidMinFileSize", i18n_24, "remove", i18n_25, "select", i18n_26], ["kendoFileSelectInternalDropZone", "", 3, "restrictions", "multiple", "disabled"], [1, "k-upload-button-wrap"], ["kendoButton", "", "type", "button", "role", "button", 1, "k-upload-button", 3, "click", "focus", "id"], ["kendoFileSelect", "", 3, "dir", "accept", "restrictions", "multiple", "disabled", "required"], [1, "k-dropzone-hint"], ["kendo-upload-file-list", "", 1, "k-upload-files", "k-reset", 3, "disabled", "fileList", "fileTemplate", "fileInfoTemplate", "id"]];
    },
    template: function FileSelectComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainer(0, 2);
        ɵɵelementStart(1, "div", 3)(2, "div", 4)(3, "button", 5, 0);
        ɵɵlistener("click", function FileSelectComponent_Template_button_click_3_listener() {
          ɵɵrestoreView(_r1);
          const fileSelectInput_r2 = ɵɵreference(7);
          return ɵɵresetView(fileSelectInput_r2.click());
        })("focus", function FileSelectComponent_Template_button_focus_3_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onFileSelectButtonFocus());
        });
        ɵɵtext(5);
        ɵɵelementEnd();
        ɵɵelement(6, "input", 6, 1);
        ɵɵelementEnd();
        ɵɵelementStart(8, "div", 7);
        ɵɵtext(9);
        ɵɵelementEnd()();
        ɵɵconditionalCreate(10, FileSelectComponent_Conditional_10_Template, 1, 5, "ul", 8);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("restrictions", ctx.restrictions)("multiple", ctx.multiple)("disabled", ctx.disabled);
        ɵɵadvance(2);
        ɵɵproperty("id", ctx.focusableId);
        ɵɵattribute("aria-label", ctx.textFor("select"))("tabindex", ctx.tabindex)("aria-expanded", ctx.hasFileList)("aria-controls", ctx.hasFileList ? ctx.fileListId : void 0);
        ɵɵadvance(2);
        ɵɵtextInterpolate1(" ", ctx.textFor("select"), " ");
        ɵɵadvance();
        ɵɵproperty("dir", ctx.direction)("accept", ctx.accept)("restrictions", ctx.restrictions)("multiple", ctx.multiple)("disabled", ctx.disabled)("required", ctx.isControlRequired);
        ɵɵadvance(3);
        ɵɵtextInterpolate(ctx.textFor("dropFilesHere"));
        ɵɵadvance();
        ɵɵconditional(ctx.hasFileList ? 10 : -1);
      }
    },
    dependencies: [LocalizedMessagesDirective3, DropZoneInternalDirective, ButtonComponent, FileSelectDirective, FileListComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FileSelectComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoFileSelect",
      providers: [LocalizationService, NavigationService2, UploadService, DropZoneService, FILESELECT_VALUE_ACCESSOR, {
        provide: L10N_PREFIX,
        useValue: "kendo.fileselect"
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => FileSelectComponent)
      }],
      selector: "kendo-fileselect",
      template: `
        <ng-container kendoFileSelectLocalizedMessages
          i18n-dropFilesHere="kendo.fileselect.dropFilesHere|The drop zone hint"
          dropFilesHere="Drop files here to select"
        
          i18n-invalidFileExtension="kendo.fileselect.invalidFileExtension|The text for the invalid allowed extensions restriction message"
          invalidFileExtension="File type not allowed."
        
          i18n-invalidMaxFileSize="kendo.fileselect.invalidMaxFileSize|The text for the invalid max file size restriction message"
          invalidMaxFileSize="File size too large."
        
          i18n-invalidMinFileSize="kendo.fileselect.invalidMinFileSize|The text for the invalid min file size restriction message"
          invalidMinFileSize="File size too small."
        
          i18n-remove="kendo.fileselect.remove|The text for the Remove button"
          remove="Remove"
        
          i18n-select="kendo.fileselect.select|The text for the Select button"
          select="Select files..."
          >
        </ng-container>
        <div kendoFileSelectInternalDropZone
          [restrictions]="restrictions"
          [multiple]="multiple"
          [disabled]="disabled">
          <div class="k-upload-button-wrap">
            <button
              kendoButton
              #fileSelectButton
              class="k-upload-button"
              type="button"
              role="button"
              (click)="fileSelectInput.click()"
              (focus)="onFileSelectButtonFocus()"
              [id]="focusableId"
              [attr.aria-label]="textFor('select')"
              [attr.tabindex]="tabindex"
              [attr.aria-expanded]="hasFileList"
              [attr.aria-controls]="hasFileList ? fileListId : undefined"
              >
              {{textFor('select')}}
            </button>
            <input kendoFileSelect #fileSelectInput
              [dir]="direction"
              [accept]="accept"
              [restrictions]="restrictions"
              [multiple]="multiple"
              [disabled]="disabled"
              [required]="isControlRequired"
              />
          </div>
          <div class="k-dropzone-hint">{{textFor('dropFilesHere')}}</div>
        </div>
        @if (hasFileList) {
          <ul kendo-upload-file-list
            class="k-upload-files k-reset"
            [disabled]="disabled"
            [fileList]="fileList.files"
            [fileTemplate]="fileTemplate"
            [fileInfoTemplate]="fileInfoTemplate"
            [id]="fileListId">
          </ul>
        }
        `,
      standalone: true,
      imports: [LocalizedMessagesDirective3, DropZoneInternalDirective, ButtonComponent, FileSelectDirective, FileListComponent]
    }]
  }], () => [{
    type: UploadService
  }, {
    type: LocalizationService
  }, {
    type: NavigationService2
  }, {
    type: DropZoneService
  }, {
    type: NgZone
  }, {
    type: Renderer2
  }, {
    type: ChangeDetectorRef
  }, {
    type: ElementRef
  }, {
    type: Injector
  }], {
    fileSelectInput: [{
      type: ViewChild,
      args: ["fileSelectInput", {
        static: true
      }]
    }],
    dir: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    name: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }]
  });
})();
var CustomMessagesComponent3 = class _CustomMessagesComponent extends Messages4 {
  service;
  get override() {
    return true;
  }
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function CustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _CustomMessagesComponent,
    selectors: [["kendo-upload-messages"], ["kendo-fileselect-messages"], ["kendo-uploaddropzone-messages"]],
    features: [ɵɵProvidersFeature([{
      provide: Messages4,
      useExisting: forwardRef(() => _CustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function CustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CustomMessagesComponent3, [{
    type: Component,
    args: [{
      providers: [{
        provide: Messages4,
        useExisting: forwardRef(() => CustomMessagesComponent3)
      }],
      selector: "kendo-upload-messages, kendo-fileselect-messages, kendo-uploaddropzone-messages",
      template: ``,
      standalone: true
    }]
  }], () => [{
    type: LocalizationService
  }], null);
})();
var KENDO_FILESELECT = [FileSelectComponent, FileTemplateDirective, FileInfoTemplateDirective, CustomMessagesComponent3, UploadDropZoneDirective, UploadDropZoneComponent];
var KENDO_UPLOAD = [UploadComponent, UploadActionButtonsComponent, UploadStatusTotalComponent, FileTemplateDirective, FileInfoTemplateDirective, CustomMessagesComponent3, UploadDropZoneDirective, UploadDropZoneComponent];
var KENDO_UPLOADS = [...KENDO_FILESELECT, ...KENDO_UPLOAD];
var FileSelectModule = class _FileSelectModule {
  static ɵfac = function FileSelectModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FileSelectModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _FileSelectModule,
    imports: [FileSelectComponent, FileTemplateDirective, FileInfoTemplateDirective, CustomMessagesComponent3, UploadDropZoneDirective, UploadDropZoneComponent],
    exports: [FileSelectComponent, FileTemplateDirective, FileInfoTemplateDirective, CustomMessagesComponent3, UploadDropZoneDirective, UploadDropZoneComponent]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService, PopupService, ResizeBatchService],
    imports: [FileSelectComponent, UploadDropZoneComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FileSelectModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_FILESELECT],
      imports: [...KENDO_FILESELECT],
      providers: [IconsService, PopupService, ResizeBatchService]
    }]
  }], null, null);
})();
var UploadModule = class _UploadModule {
  static ɵfac = function UploadModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _UploadModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _UploadModule,
    imports: [UploadComponent, UploadActionButtonsComponent, UploadStatusTotalComponent, FileTemplateDirective, FileInfoTemplateDirective, CustomMessagesComponent3, UploadDropZoneDirective, UploadDropZoneComponent],
    exports: [UploadComponent, UploadActionButtonsComponent, UploadStatusTotalComponent, FileTemplateDirective, FileInfoTemplateDirective, CustomMessagesComponent3, UploadDropZoneDirective, UploadDropZoneComponent]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService, PopupService, ResizeBatchService],
    imports: [UploadComponent, UploadStatusTotalComponent, UploadDropZoneComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UploadModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_UPLOAD],
      imports: [...KENDO_UPLOAD],
      providers: [IconsService, PopupService, ResizeBatchService]
    }]
  }], null, null);
})();
var UploadsModule = class _UploadsModule {
  static ɵfac = function UploadsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _UploadsModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _UploadsModule,
    imports: [FileSelectComponent, FileTemplateDirective, FileInfoTemplateDirective, CustomMessagesComponent3, UploadDropZoneDirective, UploadDropZoneComponent, UploadComponent, UploadActionButtonsComponent, UploadStatusTotalComponent, FileTemplateDirective, FileInfoTemplateDirective, CustomMessagesComponent3, UploadDropZoneDirective, UploadDropZoneComponent],
    exports: [FileSelectComponent, FileTemplateDirective, FileInfoTemplateDirective, CustomMessagesComponent3, UploadDropZoneDirective, UploadDropZoneComponent, UploadComponent, UploadActionButtonsComponent, UploadStatusTotalComponent, FileTemplateDirective, FileInfoTemplateDirective, CustomMessagesComponent3, UploadDropZoneDirective, UploadDropZoneComponent]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService, PopupService, ResizeBatchService],
    imports: [FileSelectComponent, UploadDropZoneComponent, UploadComponent, UploadStatusTotalComponent, UploadDropZoneComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UploadsModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_UPLOADS],
      imports: [...KENDO_UPLOADS],
      providers: [IconsService, PopupService, ResizeBatchService]
    }]
  }], null, null);
})();

// node_modules/@progress/kendo-angular-menu/fesm2022/progress-kendo-angular-menu.mjs
var _c07 = ["kendoMenuList", ""];
function ListComponent_For_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "li", 2);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    const item_r2 = ctx_r0.$implicit;
    const ɵ$index_1_r3 = ctx_r0.$index;
    const ctx_r3 = ɵɵnextContext();
    ɵɵclassProp("k-first", ɵ$index_1_r3 === 0)("k-last", ɵ$index_1_r3 === ctx_r3.items.length - 1)("k-disabled", item_r2.disabled);
    ɵɵproperty("appendTo", ctx_r3.appendTo)("item", item_r2)("level", ctx_r3.level)("size", ctx_r3.size)("vertical", ctx_r3.vertical)("animate", ctx_r3.animate)("rtl", ctx_r3.rtl)("itemTemplate", ctx_r3.itemTemplate)("itemLinkTemplate", ctx_r3.itemLinkTemplate)("popupSettings", ctx_r3.popupSettings)("openOnClick", ctx_r3.openOnClick)("index", ctx_r3.hierarchyIndex(ɵ$index_1_r3))("siblingIndex", ɵ$index_1_r3)("ngClass", item_r2.cssClass)("ngStyle", item_r2.cssStyle);
    ɵɵattribute("data-kendo-menu-index", ctx_r3.hierarchyIndex(ɵ$index_1_r3));
  }
}
function ListComponent_For_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "li", 1);
    ɵɵtext(1, "   ");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r2 = ɵɵnextContext().$implicit;
    ɵɵproperty("ngClass", item_r2.cssClass)("ngStyle", item_r2.cssStyle);
  }
}
function ListComponent_For_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, ListComponent_For_1_Conditional_0_Template, 1, 22, "li", 0);
    ɵɵconditionalCreate(1, ListComponent_For_1_Conditional_1_Template, 2, 2, "li", 1);
  }
  if (rf & 2) {
    const item_r2 = ctx.$implicit;
    ɵɵconditional(!item_r2.separator ? 0 : -1);
    ɵɵadvance();
    ɵɵconditional(item_r2.separator ? 1 : -1);
  }
}
var _c114 = ["link"];
var _c214 = ["popupTemplate"];
var _c313 = ["kendoMenuItem", ""];
var _c48 = (a0, a1) => ({
  item: a0,
  index: a1
});
function ItemComponent_Conditional_0_ng_template_2_Template(rf, ctx) {
}
function ItemComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 7, 2);
    ɵɵtemplate(2, ItemComponent_Conditional_0_ng_template_2_Template, 0, 0, "ng-template", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    const itemcontent_r2 = ɵɵreference(7);
    ɵɵclassProp("k-active", ctx_r0.opened);
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", itemcontent_r2);
  }
}
function ItemComponent_Conditional_1_ng_template_2_Template(rf, ctx) {
}
function ItemComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "a", 9, 2);
    ɵɵtemplate(2, ItemComponent_Conditional_1_ng_template_2_Template, 0, 0, "ng-template", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    const itemcontent_r2 = ɵɵreference(7);
    ɵɵclassProp("k-active", ctx_r0.opened);
    ɵɵattribute("href", ctx_r0.item.url, ɵɵsanitizeUrl);
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", itemcontent_r2);
  }
}
function ItemComponent_Conditional_2_ng_template_0_Template(rf, ctx) {
}
function ItemComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ItemComponent_Conditional_2_ng_template_0_Template, 0, 0, "ng-template", 5);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.linkTemplate)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c48, ctx_r0.item, ctx_r0.index));
  }
}
function ItemComponent_Conditional_3_ng_template_1_Template(rf, ctx) {
}
function ItemComponent_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 6);
    ɵɵtemplate(1, ItemComponent_Conditional_3_ng_template_1_Template, 0, 0, "ng-template", 5);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.item.content)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c48, ctx_r0.item.owner, ctx_r0.item.ownerIndex));
  }
}
function ItemComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "ul", 10);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("appendTo", ctx_r0.appendTo)("animate", ctx_r0.animate)("rtl", ctx_r0.rtl)("vertical", ctx_r0.vertical)("size", ctx_r0.size)("openOnClick", ctx_r0.openOnClick)("items", ctx_r0.children)("level", ctx_r0.level + 1)("index", ctx_r0.index)("itemTemplate", ctx_r0.itemTemplate)("itemLinkTemplate", ctx_r0.itemLinkTemplate)("popupSettings", ctx_r0.popupSettings)("ngClass", ctx_r0.menuListClasses);
    ɵɵattribute("id", ctx_r0.childId);
  }
}
function ItemComponent_ng_template_6_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 11);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("name", ctx_r0.item.icon)("svgIcon", ctx_r0.item.svgIcon);
  }
}
function ItemComponent_ng_template_6_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 12);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.item.text);
  }
}
function ItemComponent_ng_template_6_Conditional_2_ng_template_0_Template(rf, ctx) {
}
function ItemComponent_ng_template_6_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ItemComponent_ng_template_6_Conditional_2_ng_template_0_Template, 0, 0, "ng-template", 5);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.template)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c48, ctx_r0.item, ctx_r0.index));
  }
}
function ItemComponent_ng_template_6_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 13);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("name", ctx_r0.fontIcon(ctx_r0.horizontal, ctx_r0.rtl))("svgIcon", ctx_r0.SVGIcon(ctx_r0.horizontal, ctx_r0.rtl));
  }
}
function ItemComponent_ng_template_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, ItemComponent_ng_template_6_Conditional_0_Template, 1, 2, "kendo-icon-wrapper", 11);
    ɵɵconditionalCreate(1, ItemComponent_ng_template_6_Conditional_1_Template, 2, 1, "span", 12);
    ɵɵconditionalCreate(2, ItemComponent_ng_template_6_Conditional_2_Template, 1, 5, null, 5);
    ɵɵconditionalCreate(3, ItemComponent_ng_template_6_Conditional_3_Template, 1, 2, "kendo-icon-wrapper", 13);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵconditional(ctx_r0.item.icon || ctx_r0.item.svgIcon ? 0 : -1);
    ɵɵadvance();
    ɵɵconditional(!ctx_r0.template ? 1 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r0.template ? 2 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r0.hasContent ? 3 : -1);
  }
}
var _c55 = ["kendoMenuExpandArrow", ""];
var _c64 = ["default"];
function ContextMenuComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-menu", 1);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("items", ctx_r0.rootItems)("appendTo", ctx_r0.appendTo)("size", ctx_r0.size)("vertical", ctx_r0.vertical)("openOnClick", ctx_r0.openOnClick)("hoverDelay", ctx_r0.hoverDelay)("animate", ctx_r0.animate)("popupSettings", ctx_r0.popupSettings)("menuItemTemplate", ctx_r0.itemTemplate.first == null ? null : ctx_r0.itemTemplate.first.templateRef)("menuItemLinkTemplate", ctx_r0.itemLinkTemplate.first == null ? null : ctx_r0.itemLinkTemplate.first.templateRef);
  }
}
var packageMetadata7 = {
  name: "@progress/kendo-angular-menu",
  productName: "Kendo UI for Angular",
  productCode: "KENDOUIANGULAR",
  productCodes: ["KENDOUIANGULAR"],
  publishDate: 0,
  version: "22.0.1",
  licensingDocsUrl: "https://www.telerik.com/kendo-angular-ui/my-license/"
};
var PARENT_REGEX = /_?\d+$/;
var SEPARATOR = "_";
var id = 0;
var itemIndexComparer = (a, b) => a.siblingIndex - b.siblingIndex;
var next = (idx4, items, dir) => {
  let current = items[idx4 + dir];
  while (!current) {
    if (idx4 < 0) {
      idx4 = items.length - 1;
    } else if (idx4 >= items.length) {
      idx4 = 0;
    } else {
      idx4 += dir;
    }
    current = items[idx4];
  }
  return current;
};
var ItemsService = class _ItemsService {
  items = {};
  lists = [];
  idPrefix = `k-menu${id++}`;
  get hasItems() {
    return Object.keys(this.items).length > 0;
  }
  childId(index) {
    return `${this.idPrefix}-child${index}`;
  }
  itemIndex(parentIndex, index) {
    return (parentIndex ? parentIndex + SEPARATOR : "") + index;
  }
  get(index) {
    return this.items[index];
  }
  add(item) {
    this.items[item.index] = item;
  }
  remove(item) {
    if (this.items[item.index] === item) {
      delete this.items[item.index];
    }
  }
  addList(list2) {
    this.lists.push(list2);
  }
  removeList(list2) {
    const index = this.lists.indexOf(list2);
    if (index >= 0) {
      this.lists.splice(index, 1);
    }
  }
  containsList(element) {
    return Boolean(this.lists.find((list2) => list2.element.nativeElement === element));
  }
  siblings(item) {
    const parentIndex = this.parentIndex(item.index);
    return this.filter((index) => this.parentIndex(index) === parentIndex);
  }
  otherSiblings(item) {
    const parentIndex = this.parentIndex(item.index);
    return this.filter((index) => this.parentIndex(index) === parentIndex && index !== item.index);
  }
  children(item) {
    return this.filter((index) => this.parentIndex(index) === item.index);
  }
  parent(item) {
    return this.items[this.parentIndex(item.index)];
  }
  root(item) {
    return this.items[this.indices(item.index)[0]];
  }
  indices(index) {
    return index.split(SEPARATOR);
  }
  filter(predicate) {
    const result = [];
    const items = this.items;
    for (const index in items) {
      if (predicate(index, items[index])) {
        result.push(items[index]);
      }
    }
    return result.sort(itemIndexComparer);
  }
  previous(item) {
    const siblings = this.siblings(item);
    const itemIndex2 = siblings.indexOf(item);
    return next(itemIndex2, siblings, -1);
  }
  next(item) {
    const siblings = this.siblings(item);
    const itemIndex2 = siblings.indexOf(item);
    return next(itemIndex2, siblings, 1);
  }
  hasParent(item, parent) {
    return item.index.startsWith(parent.index);
  }
  areSiblings(item1, item2) {
    return item1 !== item2 && this.parent(item1) === this.parent(item2);
  }
  forEach(callback) {
    const items = this.items;
    for (const index in items) {
      if (items.hasOwnProperty(index)) {
        callback(items[index]);
      }
    }
  }
  parentIndex(index) {
    return index.replace(PARENT_REGEX, "");
  }
  static ɵfac = function ItemsService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ItemsService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ItemsService,
    factory: _ItemsService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ItemsService, [{
    type: Injectable
  }], null, null);
})();
var canPerformAction = (item, action) => !(action === "open" && item.opened || action === "close" && !item.opened);
var MenuStateEvent = class extends PreventableEvent {
  /**
   * The MenuComponent that triggered the event.
   */
  sender;
  /**
   * The item data of the event.
   */
  item;
  /**
   * The item index of the event.
   */
  index;
  constructor(args) {
    super();
    Object.assign(this, args);
  }
};
var ActionsService = class _ActionsService {
  ngZone;
  items;
  owner;
  actions = [];
  constructor(ngZone, items) {
    this.ngZone = ngZone;
    this.items = items;
  }
  open(item, finished) {
    if (item.disabled) {
      return;
    }
    if (item.hasContent && !item.opened) {
      this.actions.push({
        name: "open",
        requiresZone: item.hasContentTemplates(),
        item,
        finished
      });
    } else if (finished) {
      finished();
    }
  }
  close(item) {
    this.closeChildren(item);
    this.closeItem(item);
  }
  closeItem(item) {
    if (item.opened) {
      this.actions.push({
        name: "close",
        item
      });
    }
  }
  closeToRoot(item) {
    this.closeChildren(item);
    let current = item;
    do {
      this.closeItem(current);
      current = this.items.parent(current);
    } while (current);
  }
  closeOthers(item) {
    this.closeChildren(item);
    let current = item;
    while (current) {
      const siblings = this.items.otherSiblings(current);
      this.closeItems(siblings);
      current = this.items.parent(current);
    }
  }
  closeAll() {
    this.items.forEach((item) => {
      if (item.opened && item.level === 0) {
        this.close(item);
      }
    });
  }
  select(item, domEvent, prevented, finished) {
    this.actions.push({
      name: "select",
      item,
      prevented,
      finished,
      domEvent
    });
  }
  emit(name, item, domEvent) {
    const owner = this.owner;
    const eventArgs = new MenuStateEvent({
      sender: owner,
      item: item.item,
      index: item.index,
      originalEvent: domEvent,
      hasContent: item.hasContent
    });
    owner[name].emit(eventArgs);
    if (owner.contextService) {
      owner.contextService.emit(name, eventArgs);
    }
    return eventArgs.isDefaultPrevented();
  }
  get hasPending() {
    return this.actions.length > 0;
  }
  execute(toExecute) {
    if (!this.hasPending && !toExecute) {
      return;
    }
    const actions = toExecute || this.clear();
    if (!NgZone.isInAngularZone() && this.requiresZone(actions)) {
      this.ngZone.run(() => {
        this.executeActions(actions);
      });
    } else {
      this.executeActions(actions);
    }
  }
  clear() {
    const actions = this.actions;
    this.actions = [];
    return actions;
  }
  executeActions(actions) {
    for (let idx4 = 0; idx4 < actions.length; idx4++) {
      const {
        item,
        name,
        prevented,
        finished,
        domEvent
      } = actions[idx4];
      if (!canPerformAction(item, name)) {
        continue;
      }
      if (!this.emit(name, item, domEvent)) {
        if (item[name]) {
          item[name]();
        }
        if (finished) {
          finished();
        }
      } else if (prevented) {
        prevented();
      }
    }
  }
  requiresZone(toExecute) {
    const actions = toExecute || this.actions;
    const owner = this.owner;
    const contextService = owner.contextService;
    for (let idx4 = 0; idx4 < actions.length; idx4++) {
      const action = actions[idx4];
      const name = action.name;
      if (action.requiresZone || name && (hasObservers(owner[name]) || contextService && contextService.hasObservers(name))) {
        return true;
      }
    }
    return false;
  }
  closeChildren(item) {
    if (!item.opened) {
      return;
    }
    const children2 = this.items.children(item);
    this.closeItems(children2);
  }
  closeItems(items) {
    for (let idx4 = 0; idx4 < items.length; idx4++) {
      this.close(items[idx4]);
    }
  }
  static ɵfac = function ActionsService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ActionsService)(ɵɵinject(NgZone), ɵɵinject(ItemsService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ActionsService,
    factory: _ActionsService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ActionsService, [{
    type: Injectable
  }], () => [{
    type: NgZone
  }, {
    type: ItemsService
  }], null);
})();
var DEFAULT_ACTIVE = "0";
var NO_SPACE_REGEX = /\S/;
var handlers2 = {};
handlers2[Keys.ArrowLeft] = "left";
handlers2[Keys.ArrowRight] = "right";
handlers2[Keys.ArrowUp] = "up";
handlers2[Keys.ArrowDown] = "down";
handlers2[Keys.Home] = "home";
handlers2[Keys.End] = "end";
handlers2[Keys.Space] = "enter";
handlers2[Keys.Enter] = "enter";
handlers2[Keys.NumpadEnter] = "enter";
handlers2[Keys.KeyN] = "enter";
handlers2[Keys.Escape] = "esc";
handlers2[Keys.Tab] = "tab";
var handlersRTL2 = Object.assign({}, handlers2, {
  "ArrowLeft": "right",
  "ArrowRight": "left"
});
function isPrintableCharacter(key) {
  return key.length === 1 && NO_SPACE_REGEX.test(key);
}
var resolvedPromise = Promise.resolve(null);
var NavigationService3 = class _NavigationService {
  items;
  actions;
  localization;
  ngZone;
  vertical = false;
  activeIndex = DEFAULT_ACTIVE;
  focusedIdx;
  get focusedItem() {
    return this.items.get(this.focusedIdx);
  }
  get activeItem() {
    return this.items.get(this.activeIndex);
  }
  get handlers() {
    return this.localization.rtl ? handlersRTL2 : handlers2;
  }
  constructor(items, actions, localization, ngZone) {
    this.items = items;
    this.actions = actions;
    this.localization = localization;
    this.ngZone = ngZone;
  }
  focus(item) {
    if (item.index === this.focusedIdx) {
      return;
    }
    if (!this.activeItem || !this.items.hasParent(item, this.activeItem)) {
      this.setActive(item);
    }
    this.setFocus(item);
  }
  setFocus(item) {
    this.focusedIdx = item.index;
    item.focus();
  }
  focusLeave() {
    const focused = this.focusedItem;
    if (focused) {
      this.actions.closeToRoot(focused);
      this.actions.execute();
    }
    this.focusedIdx = null;
  }
  updateActive() {
    if (!this.activeItem && this.items.hasItems) {
      const firstItem = this.items.get(DEFAULT_ACTIVE);
      firstItem.toggleActive(true);
      this.ngZone.runOutsideAngular(() => {
        resolvedPromise.then(() => {
          this.activeIndex = DEFAULT_ACTIVE;
        });
      });
    }
  }
  keydown(e) {
    const current = this.focusedItem || this.activeItem;
    if (!current) {
      return;
    }
    const code = normalizeKeys(e);
    const handler = this.handlers[code];
    if (handler) {
      if (handler !== "tab") {
        e.preventDefault();
      }
      this[handler](current, e);
    } else if (isPrintableCharacter(e.key)) {
      this.search(current, e.key);
    }
    this.actions.execute();
  }
  focusIndex(index) {
    if (!index && this.activeItem) {
      this.setFocus(this.activeItem);
    } else if (index === "first") {
      this.focusFirst();
    } else if (index === "last") {
      this.focusLast();
    } else {
      const item = this.items.get(index);
      if (item) {
        this.focus(item);
      }
    }
  }
  focusFirst() {
    const items = this.items.siblings(this.items.get("0"));
    this.focus(items[0]);
  }
  focusLast() {
    const items = this.items.siblings(this.items.get("0"));
    this.focus(items[items.length - 1]);
  }
  search(current, key) {
    const siblings = this.items.siblings(current);
    const startIndex = siblings.indexOf(current);
    const items = siblings.slice(startIndex + 1).concat(siblings.slice(0, startIndex));
    for (let idx4 = 0; idx4 < items.length; idx4++) {
      const sibling = items[idx4];
      const text = sibling.item.text || "";
      if (text.toLowerCase().startsWith(key.toLowerCase())) {
        this.focus(sibling);
        break;
      }
    }
  }
  down(current) {
    if (current.level === 0 && !this.vertical) {
      if (current.hasContent) {
        this.actions.open(current, this.focusChild(current, 0));
      }
    } else {
      this.focus(this.items.next(current));
    }
  }
  up(current) {
    if (current.level === 0 && !this.vertical) {
      if (current.hasContent) {
        this.actions.open(current, this.focusChild(current, current.children.length - 1));
      }
    } else {
      this.focus(this.items.previous(current));
    }
  }
  left(current) {
    if (this.vertical && current.level === 0 && current.disabled) {
      return;
    }
    if (current.level > 1 || this.vertical && current.level > 0) {
      const parent = this.items.parent(current);
      this.focus(parent);
      this.actions.close(parent);
    } else if (this.vertical && current.level === 0 && !current.disabled) {
      if (current.hasContent) {
        this.actions.open(current, this.focusChild(current, current.children.length - 1));
      }
    } else {
      this.focus(this.items.previous(this.activeItem));
    }
  }
  right(current) {
    if (this.vertical && current.level === 0 && current.disabled) {
      return;
    }
    if (current.horizontal && !current.disabled) {
      if (current.hasContent) {
        this.actions.open(current, this.focusChild(current, 0));
      } else if (!this.vertical || current.level > 0) {
        this.focus(this.items.next(this.activeItem));
      }
    } else {
      this.focus(this.items.next(this.activeItem));
    }
  }
  home(current) {
    const siblings = this.items.siblings(current);
    this.focus(siblings[0]);
  }
  end(current) {
    const siblings = this.items.siblings(current);
    this.focus(siblings[siblings.length - 1]);
  }
  enter(current, domEvent) {
    const actions = this.actions;
    if (current.disabled) {
      return;
    }
    if (current.hasContent) {
      actions.select(current, domEvent);
      actions.open(current, this.focusChild(current, 0));
    } else {
      actions.select(current, domEvent, null, () => {
        current.navigate();
      });
      this.focus(this.items.root(current));
      actions.closeToRoot(current);
    }
  }
  esc(current) {
    if (current.level > 0) {
      const parent = this.items.parent(current);
      this.actions.close(parent);
      this.focus(parent);
    }
  }
  tab(current) {
    if (current.level > 0) {
      this.activeItem.focus();
    }
  }
  focusChild(item, index) {
    return () => {
      const child = this.items.children(item)[index];
      this.setFocus(child);
    };
  }
  setActive(item) {
    const focused = this.focusedItem;
    const active = this.items.root(item);
    if (this.activeItem) {
      this.activeItem.toggleActive(false);
    }
    this.activeIndex = active.index;
    active.toggleActive(true);
    if (focused) {
      this.actions.closeToRoot(focused);
      if (focused.level > 0) {
        this.actions.open(active);
      }
    }
  }
  static ɵfac = function NavigationService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NavigationService)(ɵɵinject(ItemsService), ɵɵinject(ActionsService), ɵɵinject(LocalizationService), ɵɵinject(NgZone));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _NavigationService,
    factory: _NavigationService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigationService3, [{
    type: Injectable
  }], () => [{
    type: ItemsService
  }, {
    type: ActionsService
  }, {
    type: LocalizationService
  }, {
    type: NgZone
  }], null);
})();
var DISABLE_OPEN_ON_OVER_DELAY = 500;
var HoverService = class _HoverService {
  actions;
  items;
  delay = 100;
  get openOnOver() {
    return this._openOnOver;
  }
  set openOnOver(value2) {
    this.cancelActions();
    this._openOnOver = value2;
  }
  _openOnOver = true;
  hoveredIdx;
  get hovered() {
    return this.items.get(this.hoveredIdx);
  }
  set hovered(item) {
    this.hoveredIdx = item ? item.index : null;
  }
  scheduled = [];
  constructor(actions, items) {
    this.actions = actions;
    this.items = items;
  }
  ngOnDestroy() {
    this.cancelActions();
  }
  over(item) {
    this.cancelActions((action) => action.name === "openOnOver");
    if (!this.hovered || this.hovered !== item) {
      this.actions.closeOthers(item);
      this.hovered = item;
      if ((item.level > 0 || this.openOnOver) && !item.disabled) {
        this.actions.open(item);
        this.cancelActions((action) => action.name === "close" && (item === action.item || this.items.hasParent(item, action.item)) || action.name === "open" && !this.items.hasParent(item, action.item));
      }
      this.scheduleActions();
    }
  }
  leave(disableOpenOnOver) {
    const hovered = this.hovered;
    if (hovered) {
      this.actions.closeToRoot(hovered);
      this.cancelActions((action) => action.name === "open");
      this.scheduleActions();
    }
    if (disableOpenOnOver && this._openOnOver) {
      this.scheduleDisableOpenOnOver();
    }
    this.hovered = null;
  }
  closeCurrent() {
    const hovered = this.hovered;
    if (hovered) {
      this.actions.closeToRoot(hovered);
      this.hovered = null;
    }
  }
  scheduleActions() {
    if (this.actions.hasPending) {
      const item = {};
      item.actions = this.actions.clear();
      item.id = setTimeout(() => {
        this.actions.execute(item.actions);
        this.removeScheduled(item);
      }, this.delay);
      this.scheduled.push(item);
    }
  }
  scheduleDisableOpenOnOver() {
    const item = {
      actions: [{
        name: "openOnOver"
      }]
    };
    item.id = setTimeout(() => {
      this._openOnOver = false;
      this.removeScheduled(item);
    }, Math.max(this.delay, DISABLE_OPEN_ON_OVER_DELAY));
    this.scheduled.push(item);
  }
  removeScheduled(item) {
    const scheduled = this.scheduled;
    for (let idx4 = 0; idx4 < scheduled.length; idx4++) {
      if (scheduled[idx4] === item) {
        scheduled.splice(idx4, 1);
        return;
      }
    }
  }
  cancelActions(predicate) {
    const scheduled = this.scheduled;
    for (let idx4 = scheduled.length - 1; idx4 >= 0; idx4--) {
      const item = scheduled[idx4];
      const actions = item.actions;
      if (predicate) {
        for (let actionIdx = actions.length - 1; actionIdx >= 0; actionIdx--) {
          if (predicate(actions[actionIdx])) {
            actions.splice(actionIdx, 1);
          }
        }
      }
      if (!predicate || actions.length === 0) {
        clearTimeout(item.id);
        scheduled.splice(idx4, 1);
      }
    }
  }
  static ɵfac = function HoverService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HoverService)(ɵɵinject(ActionsService), ɵɵinject(ItemsService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _HoverService,
    factory: _HoverService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HoverService, [{
    type: Injectable
  }], () => [{
    type: ActionsService
  }, {
    type: ItemsService
  }], null);
})();
var normalize3 = (settings) => settings && Object.assign({
  toggle: "select"
}, settings);
var NODE_INDEX = "data-kendo-menu-index";
var DEFAULT_ID = "kendo-matches-container";
var focusableRegex3 = /^(?:a|input|select|option|textarea|button|object)$/i;
var matches = (element, selector) => (element.matches || element.msMatchesSelector).call(element, selector);
var closest3 = (node, predicate) => {
  while (node && !predicate(node)) {
    node = node.parentNode;
  }
  return node;
};
var closestInScope4 = (node, predicate, scope) => {
  while (node && node !== scope && !predicate(node)) {
    node = node.parentNode;
  }
  if (node !== scope) {
    return node;
  }
};
var isFocusable4 = (element) => {
  if (element.tagName) {
    const tagName = element.tagName.toLowerCase();
    const tabIndex = element.getAttribute("tabIndex");
    const skipTab = tabIndex === "-1";
    let focusable = tabIndex !== null && !skipTab;
    if (focusableRegex3.test(tagName)) {
      focusable = !element.disabled && !skipTab;
    }
    return focusable;
  }
  return false;
};
var toClassList3 = (classNames) => String(classNames).trim().split(" ");
var hasClass2 = (element, name) => {
  return toClassList3(element.className).indexOf(name) >= 0;
};
var matchesClasses = (classes) => {
  const list2 = toClassList3(classes);
  return (element) => {
    const classList = toClassList3(element.className);
    return Boolean(list2.find((name) => classList.indexOf(name) >= 0));
  };
};
var nodeIndex = (node) => node.getAttribute(NODE_INDEX);
var closestItem2 = (node, scope) => closestInScope4(node, nodeIndex, scope);
var closestList = (node) => {
  let list2 = closest3(node, matchesClasses("k-menu-popup k-menu k-menu-group"));
  if (list2 && hasClass2(list2, "k-menu-popup")) {
    list2 = list2.querySelector(".k-menu-group");
  }
  return list2;
};
var inMenu = (node, itemsService) => {
  if (node === itemsService.lists[0].element.nativeElement) {
    return false;
  }
  const list2 = closestList(node);
  return list2 && itemsService.containsList(list2);
};
var findInContainer = (element, selector, container) => {
  const id3 = container.getAttribute("id");
  if (!id3) {
    container.setAttribute("id", DEFAULT_ID);
  }
  const contextSelector = `#${id3 || DEFAULT_ID} ${selector}`;
  const match = closestInScope4(element, (node) => matches(node, contextSelector), container);
  if (!id3) {
    container.removeAttribute("id");
  }
  return match;
};
var ContextMenuService = class _ContextMenuService {
  keydown = new EventEmitter();
  owner;
  items;
  emit(name, args) {
    this.owner.emitMenuEvent(name, args);
  }
  hasObservers(name) {
    return this.owner && hasObservers(this.owner[name]);
  }
  leaveMenu(e) {
    return this.items ? !inMenu(e.target, this.items) : true;
  }
  static ɵfac = function ContextMenuService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ContextMenuService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ContextMenuService,
    factory: _ContextMenuService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ContextMenuService, [{
    type: Injectable
  }], null, null);
})();
var ItemTemplateDirective = class _ItemTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function ItemTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ItemTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ItemTemplateDirective,
    selectors: [["", "kendoMenuItemTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ItemTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoMenuItemTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var ItemLinkTemplateDirective = class _ItemLinkTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function ItemLinkTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ItemLinkTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ItemLinkTemplateDirective,
    selectors: [["", "kendoMenuItemLinkTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ItemLinkTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoMenuItemLinkTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var ItemContentTemplateDirective = class _ItemContentTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function ItemContentTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ItemContentTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ItemContentTemplateDirective,
    selectors: [["", "kendoMenuItemContentTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ItemContentTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoMenuItemContentTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var MenuItemComponent = class _MenuItemComponent {
  text;
  url;
  disabled;
  cssClass;
  cssStyle;
  icon;
  svgIcon;
  data;
  separator;
  /**
   * @hidden
   */
  itemTemplate;
  /**
   * @hidden
   */
  itemLinkTemplate;
  /**
   * @hidden
   */
  itemContentTemplate;
  /**
   * @hidden
   */
  children;
  /**
   * @hidden
   */
  get template() {
    if (this.itemTemplate && this.itemTemplate.length) {
      return this.itemTemplate.first.templateRef;
    }
  }
  /**
   * @hidden
   */
  get linkTemplate() {
    if (this.itemLinkTemplate && this.itemLinkTemplate.length) {
      return this.itemLinkTemplate.first.templateRef;
    }
  }
  /**
   * @hidden
   */
  get contentTemplate() {
    if (this.itemContentTemplate && this.itemContentTemplate.length) {
      return this.itemContentTemplate.first.templateRef;
    }
  }
  /**
   * @hidden
   */
  get items() {
    if (this.children.length) {
      return this.children.toArray().filter((c) => c !== this);
    }
  }
  static ɵfac = function MenuItemComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MenuItemComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _MenuItemComponent,
    selectors: [["kendo-menu-item"]],
    contentQueries: function MenuItemComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, ItemTemplateDirective, 4)(dirIndex, ItemLinkTemplateDirective, 4)(dirIndex, ItemContentTemplateDirective, 4)(dirIndex, _MenuItemComponent, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.itemTemplate = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.itemLinkTemplate = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.itemContentTemplate = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
      }
    },
    inputs: {
      text: "text",
      url: "url",
      disabled: "disabled",
      cssClass: "cssClass",
      cssStyle: "cssStyle",
      icon: "icon",
      svgIcon: "svgIcon",
      data: "data",
      separator: "separator"
    },
    decls: 0,
    vars: 0,
    template: function MenuItemComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MenuItemComponent, [{
    type: Component,
    args: [{
      selector: "kendo-menu-item",
      template: ``,
      standalone: true
    }]
  }], null, {
    text: [{
      type: Input
    }],
    url: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    cssClass: [{
      type: Input
    }],
    cssStyle: [{
      type: Input
    }],
    icon: [{
      type: Input
    }],
    svgIcon: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    separator: [{
      type: Input
    }],
    itemTemplate: [{
      type: ContentChildren,
      args: [ItemTemplateDirective]
    }],
    itemLinkTemplate: [{
      type: ContentChildren,
      args: [ItemLinkTemplateDirective]
    }],
    itemContentTemplate: [{
      type: ContentChildren,
      args: [ItemContentTemplateDirective]
    }],
    children: [{
      type: ContentChildren,
      args: [MenuItemComponent]
    }]
  });
})();
var MenuBase = class _MenuBase {
  /**
   * Specifies the Menu items.
   */
  items;
  /**
   * Specifies if the Menu will be vertical ([see example]({% slug vertical_menu %})).
   */
  vertical = false;
  /**
   * Specifies that the root items can be opened only on click
   * ([see example]({% slug openclose_menu %}#toc-opening-on-click)).
   */
  openOnClick = false;
  /**
   * Specifies the delay in milliseconds before the Menu items are opened or closed on item hover
   * or leave ([see example]({% slug openclose_menu %}#toc-delay-on-hover)). Used to avoid the accidental
   * opening or closing of the items.
   */
  hoverDelay = 100;
  /**
   * Sets the Menu animation.
   */
  animate = true;
  /**
   * Sets the Menu size.
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `none`
   *
   */
  size = "medium";
  /**
   * Configures the popup settings for the Menu items.
   * Allows customization of the popup class and margin.
   */
  popupSettings;
  /**
   * @hidden
   */
  itemTemplate;
  /**
   * @hidden
   */
  itemLinkTemplate;
  /**
   * @hidden
   */
  children;
  /**
   * @hidden
   */
  get rootItems() {
    return this.items || (this.children ? this.children.toArray() : []);
  }
  static ɵfac = function MenuBase_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MenuBase)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _MenuBase,
    selectors: [["kendo-menu-base"]],
    contentQueries: function MenuBase_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, ItemTemplateDirective, 4)(dirIndex, ItemLinkTemplateDirective, 4)(dirIndex, MenuItemComponent, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.itemTemplate = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.itemLinkTemplate = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
      }
    },
    inputs: {
      items: "items",
      vertical: "vertical",
      openOnClick: "openOnClick",
      hoverDelay: "hoverDelay",
      animate: "animate",
      size: "size",
      popupSettings: "popupSettings"
    },
    decls: 0,
    vars: 0,
    template: function MenuBase_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MenuBase, [{
    type: Component,
    args: [{
      selector: "kendo-menu-base",
      template: ``
    }]
  }], null, {
    items: [{
      type: Input
    }],
    vertical: [{
      type: Input
    }],
    openOnClick: [{
      type: Input
    }],
    hoverDelay: [{
      type: Input
    }],
    animate: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    popupSettings: [{
      type: Input
    }],
    itemTemplate: [{
      type: ContentChildren,
      args: [ItemTemplateDirective]
    }],
    itemLinkTemplate: [{
      type: ContentChildren,
      args: [ItemLinkTemplateDirective]
    }],
    children: [{
      type: ContentChildren,
      args: [MenuItemComponent]
    }]
  });
})();
var defined = (value2) => typeof value2 !== "undefined";
var bodyFactory = () => {
  if (isDocumentAvailable()) {
    return new ElementRef(document.body);
  }
};
var getSizeClass2 = (size) => {
  const SIZE_CLASSES = {
    "small": "k-menu-group-sm",
    "medium": "k-menu-group-md",
    "large": "k-menu-group-lg"
  };
  return SIZE_CLASSES[size];
};
var getFontIcon = (horizontal2, rtl) => {
  const icon = horizontal2 ? rtl ? "caret-alt-left" : "caret-alt-right" : "caret-alt-down";
  return icon;
};
var getSVGIcon = (horizontal2, rtl) => {
  const icon = horizontal2 ? rtl ? caretAltLeftIcon : caretAltRightIcon : caretAltDownIcon;
  return icon;
};
var POPUP_ALIGN = {
  vertical: "top",
  horizontal: "left"
};
var POPUP_ALIGN_RTL = {
  vertical: "top",
  horizontal: "right"
};
var VERTICAL_COLLISION = {
  vertical: "flip",
  horizontal: "fit"
};
var HORIZONTAL_COLLISION = {
  vertical: "fit",
  horizontal: "flip"
};
var DEFAULT_MARGIN = {
  horizontal: 0,
  vertical: 0
};
var POPUP_SETTINGS_RTL = {
  vertical: {
    anchor: {
      vertical: "bottom",
      horizontal: "right"
    },
    popup: POPUP_ALIGN_RTL,
    collision: VERTICAL_COLLISION,
    animate: "down",
    popupClass: ["k-rtl", "k-menu-popup"]
  },
  horizontal: {
    anchor: {
      vertical: "top",
      horizontal: "left"
    },
    popup: POPUP_ALIGN_RTL,
    collision: HORIZONTAL_COLLISION,
    animate: "left",
    popupClass: ["k-rtl", "k-menu-popup"]
  }
};
var POPUP_SETTINGS = {
  vertical: {
    anchor: {
      vertical: "bottom",
      horizontal: "left"
    },
    popup: POPUP_ALIGN,
    collision: VERTICAL_COLLISION,
    animate: "down",
    popupClass: ["k-menu-popup"]
  },
  horizontal: {
    anchor: {
      vertical: "top",
      horizontal: "right"
    },
    popup: POPUP_ALIGN,
    collision: HORIZONTAL_COLLISION,
    animate: "right",
    popupClass: ["k-menu-popup"]
  }
};
var ListComponent = class _ListComponent {
  itemsService;
  hover;
  actions;
  navigation;
  renderer;
  ngZone;
  element;
  appendTo;
  items;
  level;
  index;
  animate = true;
  size = "medium";
  vertical;
  rtl;
  openOnClick;
  itemTemplate;
  itemLinkTemplate;
  popupSettings;
  domSubscriptions;
  constructor(itemsService, hover, actions, navigation, renderer, ngZone, element) {
    this.itemsService = itemsService;
    this.hover = hover;
    this.actions = actions;
    this.navigation = navigation;
    this.renderer = renderer;
    this.ngZone = ngZone;
    this.element = element;
  }
  hierarchyIndex(index) {
    return this.itemsService.itemIndex(this.index, index);
  }
  ngOnInit() {
    this.itemsService.addList(this);
    this.initDomEvents();
  }
  ngOnDestroy() {
    this.itemsService.removeList(this);
    if (this.domSubscriptions) {
      this.domSubscriptions();
    }
  }
  initDomEvents() {
    if (!isDocumentAvailable() || !this.element) {
      return;
    }
    this.ngZone.runOutsideAngular(() => {
      const element = this.element.nativeElement;
      const container = this.level > 0 ? closest3(element, (node) => hasClass2(node, "k-popup")) : element;
      const overSubscription = this.renderer.listen(element, "mouseover", (e) => {
        if (e.target === element && this.level === 0) {
          this.onLeave();
        } else {
          const item = this.nodeItem(e.target) || this.itemsService.get(this.index);
          if (item && !(this.openOnClick && this.openOnClick.toggle === "click" && item.level === 0 && !item.hasContent)) {
            this.hover.over(item);
          }
        }
      });
      const leaveSubscription = this.renderer.listen(container, "mouseleave", (e) => {
        if (this.leavesMenu(e)) {
          this.onLeave();
        }
      });
      const keydownSubscription = this.renderer.listen(element, "keydown", (e) => {
        if (hasClass2(e.target, "k-menu-item")) {
          this.navigation.keydown(e);
        }
      });
      const blurSubscription = this.renderer.listen(element, "focusout", (e) => {
        if (this.leavesMenu(e)) {
          this.navigation.focusLeave();
        }
      });
      const touchSubscription = this.renderer.listen(document, "touchstart", (e) => {
        if (inMenu(e.target, this.itemsService)) {
          const item = this.nodeItem(e.target);
          this.navigation.focus(item);
          if (!item.opened) {
            this.hover.over(item);
          }
        } else if (this.navigation.focusedIdx) {
          const activeItem = this.itemsService.get(this.navigation.activeIndex);
          this.onLeave();
          activeItem.blur();
        }
      });
      const clickSubscription = this.renderer.listen(element, "click", this.clickHandler.bind(this));
      this.domSubscriptions = () => {
        overSubscription();
        leaveSubscription();
        keydownSubscription();
        blurSubscription();
        clickSubscription();
        touchSubscription();
      };
    });
  }
  leavesMenu(e) {
    if (!e.relatedTarget) {
      return true;
    }
    return !inMenu(e.relatedTarget, this.itemsService);
  }
  onLeave() {
    const openOnClick = this.openOnClick;
    if (!openOnClick || openOnClick.toggle !== "click") {
      this.hover.leave(openOnClick && openOnClick.toggle === "leave");
    }
  }
  nodeItem(target) {
    const node = closestItem2(target, this.element.nativeElement);
    if (node) {
      const index = nodeIndex(node);
      return this.itemsService.get(index);
    }
  }
  clickHandler(e) {
    if (isFocusable4(e.target) && !hasClass2(e.target, "k-menu-item")) {
      return;
    }
    const item = this.nodeItem(e.target);
    if (!item || item.isContent || item.navigating) {
      return;
    }
    if (item.disabled) {
      e.preventDefault();
      return;
    }
    this.actions.select(item, e, () => {
      e.preventDefault();
    });
    this.navigation.focus(item);
    if (item.level > 0 && !item.hasContent) {
      this.actions.closeToRoot(item);
    }
    if (this.openOnClick) {
      const hover = this.hover;
      if (item.opened) {
        if (item.level === 0) {
          hover.openOnOver = false;
          this.actions.close(item);
        }
      } else if (item.hasContent) {
        hover.openOnOver = true;
        this.actions.closeOthers(item);
        this.actions.open(item);
      } else {
        hover.openOnOver = false;
        if (item.level === 0 && this.openOnClick.toggle === "click") {
          this.hover.closeCurrent();
        }
      }
    }
    this.actions.execute();
  }
  static ɵfac = function ListComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ListComponent)(ɵɵdirectiveInject(ItemsService), ɵɵdirectiveInject(HoverService), ɵɵdirectiveInject(ActionsService), ɵɵdirectiveInject(NavigationService3), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ListComponent,
    selectors: [["", "kendoMenuList", ""]],
    inputs: {
      appendTo: "appendTo",
      items: "items",
      level: "level",
      index: "index",
      animate: "animate",
      size: "size",
      vertical: "vertical",
      rtl: "rtl",
      openOnClick: "openOnClick",
      itemTemplate: "itemTemplate",
      itemLinkTemplate: "itemLinkTemplate",
      popupSettings: "popupSettings"
    },
    attrs: _c07,
    decls: 2,
    vars: 0,
    consts: [["kendoMenuItem", "", "role", "menuitem", 1, "k-item", "k-menu-item", 3, "appendTo", "item", "level", "size", "vertical", "animate", "rtl", "itemTemplate", "itemLinkTemplate", "popupSettings", "openOnClick", "index", "siblingIndex", "ngClass", "ngStyle", "k-first", "k-last", "k-disabled"], ["aria-hidden", "true", 1, "k-separator", "k-item", 3, "ngClass", "ngStyle"], ["kendoMenuItem", "", "role", "menuitem", 1, "k-item", "k-menu-item", 3, "appendTo", "item", "level", "size", "vertical", "animate", "rtl", "itemTemplate", "itemLinkTemplate", "popupSettings", "openOnClick", "index", "siblingIndex", "ngClass", "ngStyle"]],
    template: function ListComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵrepeaterCreate(0, ListComponent_For_1_Template, 2, 2, null, null, ɵɵrepeaterTrackByIdentity);
      }
      if (rf & 2) {
        ɵɵrepeater(ctx.items);
      }
    },
    dependencies: () => [ItemComponent, NgClass, NgStyle],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ListComponent, [{
    type: Component,
    args: [{
      selector: "[kendoMenuList]",
      template: `
        @for (item of items; track item; let idx = $index) {
          @if (!item.separator) {
            <li
              kendoMenuItem
              [appendTo]="appendTo"
              [item]="item"
              [level]="level"
              [size]="size"
              [vertical]="vertical"
              [animate]="animate"
              [rtl]="rtl"
              [itemTemplate]="itemTemplate"
              [itemLinkTemplate]="itemLinkTemplate"
              [popupSettings]="popupSettings"
              [openOnClick]="openOnClick"
              [index]="hierarchyIndex(idx)"
              [siblingIndex]="idx"
              [attr.${NODE_INDEX}]="hierarchyIndex(idx)"
              [ngClass]="item.cssClass"
              [ngStyle]="item.cssStyle"
              role="menuitem"
              class="k-item k-menu-item"
              [class.k-first]="idx === 0"
              [class.k-last]="idx === items.length - 1"
            [class.k-disabled]="item.disabled"></li>
          }
          @if (item.separator) {
            <li
              class="k-separator k-item"
              [ngClass]="item.cssClass"
              aria-hidden="true"
              [ngStyle]="item.cssStyle">
              &nbsp;
            </li>
          }
        }
        `,
      standalone: true,
      imports: [forwardRef(() => ItemComponent), NgClass, NgStyle]
    }]
  }], () => [{
    type: ItemsService
  }, {
    type: HoverService
  }, {
    type: ActionsService
  }, {
    type: NavigationService3
  }, {
    type: Renderer2
  }, {
    type: NgZone
  }, {
    type: ElementRef
  }], {
    appendTo: [{
      type: Input
    }],
    items: [{
      type: Input
    }],
    level: [{
      type: Input
    }],
    index: [{
      type: Input
    }],
    animate: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    vertical: [{
      type: Input
    }],
    rtl: [{
      type: Input
    }],
    openOnClick: [{
      type: Input
    }],
    itemTemplate: [{
      type: Input
    }],
    itemLinkTemplate: [{
      type: Input
    }],
    popupSettings: [{
      type: Input
    }]
  });
})();
var ItemComponent = class _ItemComponent {
  itemsService;
  navigation;
  changeDetector;
  renderer;
  popupService;
  element;
  contextService;
  appendTo;
  item;
  level;
  set index(index) {
    if (this._index && this._index !== index) {
      this.itemsService.remove(this);
      this._index = index;
      this.itemsService.add(this);
    } else {
      this._index = index;
    }
    this.childId = this.itemsService.childId(index);
  }
  get index() {
    return this._index;
  }
  siblingIndex;
  animate = true;
  size = "medium";
  vertical;
  rtl;
  openOnClick = false;
  itemTemplate;
  itemLinkTemplate;
  popupSettings;
  link;
  popupTemplate;
  get disabled() {
    return this.item.disabled;
  }
  get hasPopup() {
    return this.hasContent ? true : null;
  }
  get label() {
    return this.item.text ? this.item.text : null;
  }
  get defaultPopupSettings() {
    const settings = this.rtl ? POPUP_SETTINGS_RTL : POPUP_SETTINGS;
    return this.horizontal ? settings.horizontal : settings.vertical;
  }
  get horizontal() {
    return this.vertical || this.level > 0;
  }
  get hasLink() {
    return Boolean(this.item.url);
  }
  get linkTemplate() {
    return this.item.linkTemplate || this.itemLinkTemplate;
  }
  get hasContent() {
    const items = this.item.items;
    return items && items.length || this.item.contentTemplate;
  }
  get isContent() {
    return Boolean(this.item.content);
  }
  get iconClass() {
    return `k-i-${this.item.icon}`;
  }
  get isContextMenu() {
    return Boolean(this.contextService);
  }
  get menuListClasses() {
    const sizeClass = getSizeClass2(this.size);
    return this.isContextMenu ? `k-context-menu k-menu-group ${sizeClass}` : `k-menu-group ${sizeClass}`;
  }
  get children() {
    const item = this.item;
    if (item.contentTemplate) {
      if (!this.contentItems) {
        this.contentItems = [{
          content: item.contentTemplate,
          owner: item,
          ownerIndex: this.index
        }];
      }
      return this.contentItems;
    }
    return item.items;
  }
  get template() {
    return this.item.template || this.itemTemplate;
  }
  /**
   * @hidden
   */
  fontIcon = getFontIcon;
  /**
   * @hidden
   */
  SVGIcon = getSVGIcon;
  opened = false;
  navigating = false;
  childId;
  contentItems;
  popupRef;
  _index;
  destroyed = false;
  constructor(itemsService, navigation, changeDetector, renderer, popupService, element, contextService) {
    this.itemsService = itemsService;
    this.navigation = navigation;
    this.changeDetector = changeDetector;
    this.renderer = renderer;
    this.popupService = popupService;
    this.element = element;
    this.contextService = contextService;
  }
  hasContentTemplates() {
    const item = this.item;
    return this.itemTemplate || item.contentTemplate || this.itemLinkTemplate || item.items && item.items.find((current) => current.template || current.linkTemplate);
  }
  ngOnInit() {
    this.itemsService.add(this);
  }
  ngAfterViewInit() {
    if (this.hasContent) {
      this.setAttribute("aria-expanded", this.opened.toString());
    }
    this.index === this.navigation.activeIndex ? this.setAttribute("tabindex", "0") : this.setAttribute("tabindex", "-1");
  }
  ngOnDestroy() {
    this.itemsService.remove(this);
    this.destroyed = true;
    if (this.popupRef) {
      this.popupRef.close();
      this.popupRef = null;
    }
  }
  focus() {
    this.element.nativeElement.focus();
  }
  blur() {
    this.element.nativeElement.blur();
  }
  toggleActive(isActive2) {
    if (isActive2) {
      this.setAttribute("tabindex", "0");
    } else {
      this.setAttribute("tabindex", "-1");
    }
  }
  open() {
    if (!this.destroyed && this.hasContent && !this.opened) {
      const popupSettings = this.getMergedPopupSettings();
      const animate2 = this.animate ? Object.assign({}, this.animate, {
        direction: popupSettings.animate
      }) : false;
      this.opened = true;
      this.popupRef = this.popupService.open({
        appendTo: this.appendTo,
        popupAlign: popupSettings.popup,
        anchorAlign: popupSettings.anchor,
        collision: popupSettings.collision,
        anchor: this.element,
        positionMode: "absolute",
        content: this.popupTemplate,
        popupClass: popupSettings.popupClass,
        margin: popupSettings.margin,
        animate: animate2
      });
      this.setAttribute("aria-expanded", "true");
      this.setAttribute("aria-controls", this.childId);
      this.changeDetector.detectChanges();
    }
  }
  close() {
    if (!this.destroyed && this.opened) {
      this.opened = false;
      if (this.popupRef) {
        this.popupRef.close();
        this.popupRef = null;
      }
      this.changeDetector.detectChanges();
      this.setAttribute("aria-expanded", "false");
      this.renderer.removeAttribute(this.element.nativeElement, "aria-controls");
    }
  }
  navigate() {
    let link;
    if (this.linkTemplate) {
      link = this.element.nativeElement.querySelector("a.k-menu-link");
    } else if (this.hasLink) {
      link = this.link.nativeElement;
    }
    if (link) {
      this.navigating = true;
      link.click();
      this.navigating = false;
    }
  }
  setAttribute(name, value2) {
    this.renderer.setAttribute(this.element.nativeElement, name, value2);
  }
  getMergedPopupSettings() {
    if (!isPresent(this.popupSettings)) {
      return this.defaultPopupSettings;
    }
    const defaultSettings = this.defaultPopupSettings;
    const customClasses = this.popupSettings.popupClass ? parseCSSClassNames(this.popupSettings.popupClass) : [];
    return __spreadProps(__spreadValues({}, defaultSettings), {
      popupClass: customClasses.length ? [...defaultSettings.popupClass, ...customClasses] : defaultSettings.popupClass,
      margin: this.popupSettings.margin ?? DEFAULT_MARGIN
    });
  }
  static ɵfac = function ItemComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ItemComponent)(ɵɵdirectiveInject(ItemsService), ɵɵdirectiveInject(NavigationService3), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ContextMenuService, 8));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ItemComponent,
    selectors: [["", "kendoMenuItem", ""]],
    viewQuery: function ItemComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c114, 5)(_c214, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.link = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);
      }
    },
    hostVars: 3,
    hostBindings: function ItemComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("aria-disabled", ctx.disabled)("aria-haspopup", ctx.hasPopup)("aria-label", ctx.label);
      }
    },
    inputs: {
      appendTo: "appendTo",
      item: "item",
      level: "level",
      index: "index",
      siblingIndex: "siblingIndex",
      animate: "animate",
      size: "size",
      vertical: "vertical",
      rtl: "rtl",
      openOnClick: "openOnClick",
      itemTemplate: "itemTemplate",
      itemLinkTemplate: "itemLinkTemplate",
      popupSettings: "popupSettings"
    },
    features: [ɵɵProvidersFeature([PopupService, {
      provide: POPUP_CONTAINER,
      useFactory: bodyFactory
    }])],
    attrs: _c313,
    decls: 8,
    vars: 4,
    consts: [["popupTemplate", ""], ["itemcontent", ""], ["link", ""], ["role", "presentation", 1, "k-link", "k-menu-link", 3, "k-active"], ["tabindex", "-1", "role", "presentation", 1, "k-link", "k-menu-link", 3, "k-active"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["role", "presentation", 1, "k-content"], ["role", "presentation", 1, "k-link", "k-menu-link"], [3, "ngTemplateOutlet"], ["tabindex", "-1", "role", "presentation", 1, "k-link", "k-menu-link"], ["kendoMenuList", "", "role", "menu", 3, "appendTo", "animate", "rtl", "vertical", "size", "openOnClick", "items", "level", "index", "itemTemplate", "itemLinkTemplate", "popupSettings", "ngClass"], ["role", "presentation", 3, "name", "svgIcon"], [1, "k-menu-link-text"], ["aria-hidden", "true", 1, "k-menu-expand-arrow", 3, "name", "svgIcon"]],
    template: function ItemComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵconditionalCreate(0, ItemComponent_Conditional_0_Template, 3, 3, "span", 3);
        ɵɵconditionalCreate(1, ItemComponent_Conditional_1_Template, 3, 4, "a", 4);
        ɵɵconditionalCreate(2, ItemComponent_Conditional_2_Template, 1, 5, null, 5);
        ɵɵconditionalCreate(3, ItemComponent_Conditional_3_Template, 2, 5, "div", 6);
        ɵɵtemplate(4, ItemComponent_ng_template_4_Template, 1, 14, "ng-template", null, 0, ɵɵtemplateRefExtractor)(6, ItemComponent_ng_template_6_Template, 4, 4, "ng-template", null, 1, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        ɵɵconditional(!ctx.hasLink && !ctx.item.content && !ctx.linkTemplate ? 0 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.item.url && !ctx.linkTemplate ? 1 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.linkTemplate && !ctx.item.content ? 2 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.item.content ? 3 : -1);
      }
    },
    dependencies: [NgTemplateOutlet, ListComponent, NgClass, IconWrapperComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ItemComponent, [{
    type: Component,
    args: [{
      providers: [PopupService, {
        provide: POPUP_CONTAINER,
        useFactory: bodyFactory
      }],
      selector: "[kendoMenuItem]",
      template: `
    @if (!hasLink && !item.content && !linkTemplate) {
      <span class="k-link k-menu-link" #link
        [class.k-active]="opened" role="presentation">
        <ng-template [ngTemplateOutlet]="itemcontent">
        </ng-template>
      </span>
    }
    @if (item.url && !linkTemplate) {
      <a class="k-link k-menu-link" #link [attr.href]="item.url"
        [class.k-active]="opened" tabindex="-1" role="presentation">
        <ng-template [ngTemplateOutlet]="itemcontent">
        </ng-template>
      </a>
    }
    @if (linkTemplate && !item.content) {
      <ng-template [ngTemplateOutlet]="linkTemplate"
        [ngTemplateOutletContext]="{ item: item, index: index }">
      </ng-template>
    }
    
    @if (item.content) {
      <div class="k-content" role="presentation">
        <ng-template [ngTemplateOutlet]="item.content" [ngTemplateOutletContext]="{ item: item.owner, index: item.ownerIndex }">
        </ng-template>
      </div>
    }
    
    <ng-template #popupTemplate>
      <ul kendoMenuList
        [appendTo]="appendTo"
        [attr.id]="childId"
        [animate]="animate"
        [rtl]="rtl"
        [vertical]="vertical"
        [size]="size"
        [openOnClick]="openOnClick"
        [items]="children"
        [level]="level + 1"
        [index]="index"
        [itemTemplate]="itemTemplate"
        [itemLinkTemplate]="itemLinkTemplate"
        [popupSettings]="popupSettings"
        [ngClass]="menuListClasses"
        role="menu">
      </ul>
    </ng-template>
    
    <ng-template #itemcontent>
      @if (item.icon || item.svgIcon) {
        <kendo-icon-wrapper [name]="item.icon" [svgIcon]="item.svgIcon" role="presentation"></kendo-icon-wrapper>
      }
      @if (!template) {
        <span class="k-menu-link-text">{{ item.text }}</span>
      }
      @if (template) {
        <ng-template [ngTemplateOutlet]="template" [ngTemplateOutletContext]="{ item: item, index: index }">
        </ng-template>
      }
      @if (hasContent) {
        <kendo-icon-wrapper [name]="fontIcon(horizontal, rtl)" [svgIcon]="SVGIcon(horizontal, rtl)" class="k-menu-expand-arrow" aria-hidden="true"></kendo-icon-wrapper>
      }
    </ng-template>
    `,
      standalone: true,
      imports: [NgTemplateOutlet, ListComponent, NgClass, IconWrapperComponent]
    }]
  }], () => [{
    type: ItemsService
  }, {
    type: NavigationService3
  }, {
    type: ChangeDetectorRef
  }, {
    type: Renderer2
  }, {
    type: PopupService
  }, {
    type: ElementRef
  }, {
    type: ContextMenuService,
    decorators: [{
      type: Optional
    }]
  }], {
    appendTo: [{
      type: Input
    }],
    item: [{
      type: Input
    }],
    level: [{
      type: Input
    }],
    index: [{
      type: Input
    }],
    siblingIndex: [{
      type: Input
    }],
    animate: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    vertical: [{
      type: Input
    }],
    rtl: [{
      type: Input
    }],
    openOnClick: [{
      type: Input
    }],
    itemTemplate: [{
      type: Input
    }],
    itemLinkTemplate: [{
      type: Input
    }],
    popupSettings: [{
      type: Input
    }],
    link: [{
      type: ViewChild,
      args: ["link", {
        static: false
      }]
    }],
    popupTemplate: [{
      type: ViewChild,
      args: ["popupTemplate", {
        static: true
      }]
    }],
    disabled: [{
      type: HostBinding,
      args: ["attr.aria-disabled"]
    }],
    hasPopup: [{
      type: HostBinding,
      args: ["attr.aria-haspopup"]
    }],
    label: [{
      type: HostBinding,
      args: ["attr.aria-label"]
    }]
  });
})();
var MenuComponent = class _MenuComponent extends MenuBase {
  itemsService;
  hover;
  actions;
  navigation;
  localization;
  ngZone;
  renderer;
  contextService;
  /**
   * Defines the container to which the popups will be appended.
   */
  appendTo;
  /**
   * @hidden
   */
  menuItemTemplate;
  /**
   * @hidden
   */
  ariaRole = "menubar";
  /**
   * @hidden
   */
  menuItemLinkTemplate;
  /**
   * Fires when a Menu item is selected ([see example](slug:events_menu)).
   */
  select = new EventEmitter();
  /**
   * Fires when a Menu item is opened ([see example](slug:events_menu)).
   */
  open = new EventEmitter();
  /**
   * Fires when a Menu item is closed ([see example](slug:events_menu)).
   */
  close = new EventEmitter();
  /**
   * @hidden
   */
  get ariaOrientation() {
    if (this.vertical) {
      return "vertical";
    }
  }
  /**
   * @hidden
   */
  get isContextMenu() {
    return Boolean(this.contextService);
  }
  get direction() {
    return this.rtl;
  }
  get rtl() {
    return this.localization.rtl;
  }
  /**
   * @hidden
   */
  get menuClasses() {
    const sizeClass = getSizeClass2(this.size);
    const staticClasses = "k-reset k-header k-menu";
    if (this.isContextMenu) {
      return `k-context-menu k-menu-group ${sizeClass}`;
    }
    return `${staticClasses} k-menu-${this.vertical ? "vertical" : "horizontal"}`;
  }
  closeClickSubscription;
  contextKeyDownSubscription;
  constructor(itemsService, hover, actions, navigation, localization, ngZone, renderer, contextService) {
    super();
    this.itemsService = itemsService;
    this.hover = hover;
    this.actions = actions;
    this.navigation = navigation;
    this.localization = localization;
    this.ngZone = ngZone;
    this.renderer = renderer;
    this.contextService = contextService;
    N(packageMetadata7);
    this.actions.owner = this;
    if (contextService) {
      contextService.items = this.itemsService;
      this.contextKeyDownSubscription = contextService.keydown.subscribe(this.contextKeyDown.bind(this));
    }
  }
  /**
   * Opens or closes the specified Menu items.
   *
   * @param open - A Boolean value which indicates if the items will be opened or closed.
   * @param indices - One or more values which represent the hierarchical indices of the items that will be opened or closed.
   */
  toggle(open, ...indices) {
    for (let idx4 = 0; idx4 < indices.length; idx4++) {
      const item = this.itemsService.get(indices[idx4]);
      if (item && !item.disabled) {
        if (open) {
          item.open();
        } else {
          item.close();
        }
      }
    }
  }
  /**
   * @hidden
   */
  focus(index) {
    this.navigation.focusIndex(index);
  }
  ngOnChanges(changes) {
    this.navigation.vertical = this.vertical;
    this.hover.delay = this.hoverDelay;
    if (changes.openOnClick) {
      const openOnClick = this.openOnClick = normalize3(this.openOnClick);
      this.hover.openOnOver = !openOnClick;
      if (openOnClick && openOnClick.toggle === "click") {
        this.attachCloseClick();
      } else {
        this.unsubscribeClick();
      }
    }
  }
  ngAfterViewChecked() {
    this.navigation.updateActive();
  }
  ngOnDestroy() {
    this.unsubscribeClick();
    if (this.contextService) {
      this.contextService.items = null;
      this.contextKeyDownSubscription.unsubscribe();
    }
  }
  attachCloseClick() {
    if (!this.closeClickSubscription && isDocumentAvailable()) {
      this.ngZone.runOutsideAngular(() => {
        this.closeClickSubscription = this.renderer.listen("document", "click", (e) => {
          if (!inMenu(e.target, this.itemsService)) {
            this.hover.openOnOver = false;
            this.actions.closeAll();
            this.actions.execute();
          }
        });
      });
    }
  }
  unsubscribeClick() {
    if (this.closeClickSubscription) {
      this.closeClickSubscription();
    }
  }
  contextKeyDown(e) {
    if (!this.itemsService.hasItems) {
      return;
    }
    const keyCode = normalizeKeys(e);
    const rtl = this.localization.rtl;
    const first = keyCode === Keys.ArrowDown || keyCode === Keys.ArrowRight;
    const last4 = keyCode === Keys.ArrowUp || keyCode === Keys.ArrowLeft;
    let index;
    if (first && !rtl || last4 && rtl) {
      index = "first";
    } else if (first && rtl || last4 && !rtl) {
      index = "last";
    }
    if (index) {
      e.preventDefault();
      this.focus(index);
    }
  }
  static ɵfac = function MenuComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MenuComponent)(ɵɵdirectiveInject(ItemsService), ɵɵdirectiveInject(HoverService), ɵɵdirectiveInject(ActionsService), ɵɵdirectiveInject(NavigationService3), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ContextMenuService, 8));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _MenuComponent,
    selectors: [["kendo-menu"]],
    hostVars: 2,
    hostBindings: function MenuComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-rtl", ctx.direction);
      }
    },
    inputs: {
      appendTo: "appendTo",
      menuItemTemplate: "menuItemTemplate",
      ariaRole: "ariaRole",
      menuItemLinkTemplate: "menuItemLinkTemplate"
    },
    outputs: {
      select: "select",
      open: "open",
      close: "close"
    },
    exportAs: ["kendoMenu"],
    features: [ɵɵProvidersFeature([ItemsService, ActionsService, NavigationService3, HoverService, LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.menu"
    }, {
      provide: MenuBase,
      useExisting: forwardRef(() => _MenuComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
    decls: 1,
    vars: 14,
    consts: [["kendoMenuList", "", 3, "items", "level", "appendTo", "size", "vertical", "rtl", "animate", "openOnClick", "itemTemplate", "itemLinkTemplate", "popupSettings", "ngClass"]],
    template: function MenuComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelement(0, "ul", 0);
      }
      if (rf & 2) {
        ɵɵproperty("items", ctx.rootItems)("level", 0)("appendTo", ctx.appendTo)("size", ctx.size)("vertical", ctx.vertical)("rtl", ctx.rtl)("animate", ctx.animate)("openOnClick", ctx.openOnClick)("itemTemplate", (ctx.itemTemplate.first == null ? null : ctx.itemTemplate.first.templateRef) || ctx.menuItemTemplate)("itemLinkTemplate", (ctx.itemLinkTemplate.first == null ? null : ctx.itemLinkTemplate.first.templateRef) || ctx.menuItemLinkTemplate)("popupSettings", ctx.popupSettings)("ngClass", ctx.menuClasses);
        ɵɵattribute("role", ctx.ariaRole)("aria-orientation", ctx.ariaOrientation);
      }
    },
    dependencies: [ListComponent, NgClass],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MenuComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoMenu",
      providers: [ItemsService, ActionsService, NavigationService3, HoverService, LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.menu"
      }, {
        provide: MenuBase,
        useExisting: forwardRef(() => MenuComponent)
      }],
      selector: "kendo-menu",
      template: `
        <ul
            [attr.role]="ariaRole"
            [attr.aria-orientation]="ariaOrientation"
            kendoMenuList [items]="rootItems" [level]="0" [appendTo]="appendTo"
            [size]="size" [vertical]="vertical" [rtl]="rtl" [animate]="animate" [openOnClick]="openOnClick"
            [itemTemplate]="itemTemplate.first?.templateRef || menuItemTemplate"
            [itemLinkTemplate]="itemLinkTemplate.first?.templateRef || menuItemLinkTemplate"
            [popupSettings]="popupSettings"
            [ngClass]="menuClasses">
        </ul>
    `,
      standalone: true,
      imports: [ListComponent, NgClass]
    }]
  }], () => [{
    type: ItemsService
  }, {
    type: HoverService
  }, {
    type: ActionsService
  }, {
    type: NavigationService3
  }, {
    type: LocalizationService
  }, {
    type: NgZone
  }, {
    type: Renderer2
  }, {
    type: ContextMenuService,
    decorators: [{
      type: Optional
    }]
  }], {
    appendTo: [{
      type: Input
    }],
    menuItemTemplate: [{
      type: Input
    }],
    ariaRole: [{
      type: Input
    }],
    menuItemLinkTemplate: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    open: [{
      type: Output
    }],
    close: [{
      type: Output
    }],
    direction: [{
      type: HostBinding,
      args: ["class.k-rtl"]
    }]
  });
})();
var LinkDirective = class _LinkDirective {
  itemsService;
  /**
   * Specifies the index of the Menu item. The input is mandatory.
   */
  index;
  hostClasses = true;
  role = "presentation";
  tabindex = "-1";
  get activeClass() {
    return this.item.opened;
  }
  item;
  constructor(itemsService) {
    this.itemsService = itemsService;
  }
  ngOnInit() {
    if (isDevMode() && !this.index) {
      throw new Error("The kendoMenuItemLink directive requires the item index to be set.");
    }
    this.item = this.itemsService.get(this.index) || {};
  }
  static ɵfac = function LinkDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LinkDirective)(ɵɵdirectiveInject(ItemsService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LinkDirective,
    selectors: [["", "kendoMenuItemLink", ""]],
    hostVars: 8,
    hostBindings: function LinkDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("role", ctx.role)("tabindex", ctx.tabindex);
        ɵɵclassProp("k-link", ctx.hostClasses)("k-menu-link", ctx.hostClasses)("k-active", ctx.activeClass);
      }
    },
    inputs: {
      index: [0, "kendoMenuItemLink", "index"]
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LinkDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoMenuItemLink]",
      standalone: true
    }]
  }], () => [{
    type: ItemsService
  }], {
    index: [{
      type: Input,
      args: ["kendoMenuItemLink"]
    }],
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-link"]
    }, {
      type: HostBinding,
      args: ["class.k-menu-link"]
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    tabindex: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    activeClass: [{
      type: HostBinding,
      args: ["class.k-active"]
    }]
  });
})();
var ExpandArrowComponent = class _ExpandArrowComponent {
  itemsService;
  /**
   * Specifies the index of the Menu item. The input is mandatory.
   */
  index;
  hostClasses = true;
  ariaHidden = "true";
  item;
  /**
   * @hidden
   */
  fontIcon;
  /**
   * @hidden
   */
  SVGIcon;
  constructor(itemsService) {
    this.itemsService = itemsService;
  }
  ngOnInit() {
    if (isDevMode() && !this.index) {
      throw new Error("The kendoMenuExpandArrow component requires the item index to be set.");
    }
    this.item = this.itemsService.get(this.index) || {};
    this.fontIcon = getFontIcon(this.item.horizontal, this.item.rtl);
    this.SVGIcon = getSVGIcon(this.item.horizontal, this.item.rtl);
  }
  static ɵfac = function ExpandArrowComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ExpandArrowComponent)(ɵɵdirectiveInject(ItemsService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ExpandArrowComponent,
    selectors: [["", "kendoMenuExpandArrow", ""]],
    hostVars: 3,
    hostBindings: function ExpandArrowComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("aria-hidden", ctx.ariaHidden);
        ɵɵclassProp("k-menu-expand-arrow", ctx.hostClasses);
      }
    },
    inputs: {
      index: [0, "kendoMenuExpandArrow", "index"]
    },
    attrs: _c55,
    decls: 1,
    vars: 2,
    consts: [[3, "name", "svgIcon"]],
    template: function ExpandArrowComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelement(0, "kendo-icon-wrapper", 0);
      }
      if (rf & 2) {
        ɵɵproperty("name", ctx.fontIcon)("svgIcon", ctx.SVGIcon);
      }
    },
    dependencies: [IconWrapperComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExpandArrowComponent, [{
    type: Component,
    args: [{
      selector: "[kendoMenuExpandArrow]",
      template: `<kendo-icon-wrapper [name]="fontIcon" [svgIcon]="SVGIcon"></kendo-icon-wrapper>`,
      standalone: true,
      imports: [IconWrapperComponent]
    }]
  }], () => [{
    type: ItemsService
  }], {
    index: [{
      type: Input,
      args: ["kendoMenuExpandArrow"]
    }],
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-menu-expand-arrow"]
    }],
    ariaHidden: [{
      type: HostBinding,
      args: ["attr.aria-hidden"]
    }]
  });
})();
var PreventableEvent5 = class {
  prevented = false;
  /**
   * Prevents the default action for a specified event.
   * In this way, the source component suppresses
   * the built-in behavior that follows the event.
   */
  preventDefault() {
    this.prevented = true;
  }
  /**
   * Returns `true` if the event was prevented
   * by any of its subscribers.
   *
   * @returns `true` if the default action was prevented.
   * Otherwise, returns `false`.
   */
  isDefaultPrevented() {
    return this.prevented;
  }
  /**
   * @hidden
   */
  constructor(args) {
    Object.assign(this, args);
  }
};
var ITEM_FIELDS = ["textField", "urlField", "iconField", "svgIconField", "disabledField", "cssClassField", "cssStyleField", "separatorField"];
var BindingDirectiveBase = class _BindingDirectiveBase {
  menu;
  data;
  fields;
  constructor(menu) {
    this.menu = menu;
  }
  ngOnChanges() {
    this.rebind();
  }
  /**
   *  Rebinds the Menu items.
   */
  rebind() {
    const fields = this.fields = [];
    for (let idx4 = 0; idx4 < ITEM_FIELDS.length; idx4++) {
      const inputName = ITEM_FIELDS[idx4];
      const inputValue = this[inputName];
      if (inputValue) {
        fields.push({
          target: inputName.replace("Field", ""),
          source: inputValue
        });
      }
    }
    this.menu.items = this.data ? this.mapItems(this.data) : [];
  }
  static ɵfac = function BindingDirectiveBase_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BindingDirectiveBase)(ɵɵdirectiveInject(MenuBase));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _BindingDirectiveBase,
    selectors: [["kendoBindingBase"]],
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BindingDirectiveBase, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line
      selector: "kendoBindingBase"
    }]
  }], () => [{
    type: MenuBase
  }], null);
})();
var FIELD_REGEX2 = /\[(?:(\d+)|['"](.*?)['"])\]|((?:(?!\[.*?\]|\.).)+)/g;
var getterCache2 = {};
getterCache2["undefined"] = (obj) => obj;
var getter4 = (field) => {
  if (getterCache2[field]) {
    return getterCache2[field];
  }
  const fields = [];
  field.replace(FIELD_REGEX2, (_match, index, indexAccessor, name) => {
    fields.push(index !== void 0 ? index : indexAccessor || name);
  });
  getterCache2[field] = (obj) => {
    let result = obj;
    for (let idx4 = 0; idx4 < fields.length && result; idx4++) {
      result = result[fields[idx4]];
    }
    return result;
  };
  return getterCache2[field];
};
var last2 = (arr) => arr[arr.length - 1];
var getField = (field, level) => Array.isArray(field) ? field[level] || last2(field) : field;
var HierarchyBindingDirective = class _HierarchyBindingDirective extends BindingDirectiveBase {
  /**
   * Specifies the array of data which will be used to populate the Menu.
   */
  data;
  /**
   * Defines the `text` field (or fields) of an item.
   */
  textField;
  /**
   * Defines the `url` field (or fields) of an item.
   */
  urlField;
  /**
   * Defines the `icon` field (or fields) of an item.
   */
  iconField;
  /**
   * Defines the `svgIcon` field of the items.
   */
  svgIconField;
  /**
   * Defines the `disabled` field (or fields) of an item.
   */
  disabledField;
  /**
   * Defines the `cssClass` field (or fields) of an item.
   */
  cssClassField;
  /**
   * Defines the `cssStyle` field (or fields) of an item.
   */
  cssStyleField;
  /**
   * Defines the `separator` field (or fields) of the items.
   */
  separatorField;
  /**
   * Defines the `children` field (or fields) of the items.
   */
  childrenField;
  constructor(menu) {
    super(menu);
  }
  mapItems(items, level = 0) {
    return items.map((item) => {
      const menuItem = this.createItem(item, level);
      const children2 = this.getChildren(item, level);
      if (children2) {
        menuItem.items = this.mapItems(children2, level + 1);
      }
      return menuItem;
    });
  }
  createItem(item, level) {
    const result = {
      data: item
    };
    const fields = this.fields;
    for (let idx4 = 0; idx4 < fields.length; idx4++) {
      const {
        target,
        source
      } = fields[idx4];
      result[target] = getter4(getField(source, level))(item);
    }
    return result;
  }
  getChildren(item, level) {
    if (this.childrenField) {
      const field = getField(this.childrenField, level);
      return item[field];
    }
  }
  static ɵfac = function HierarchyBindingDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HierarchyBindingDirective)(ɵɵdirectiveInject(MenuBase));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _HierarchyBindingDirective,
    selectors: [["", "kendoMenuHierarchyBinding", ""]],
    inputs: {
      data: [0, "kendoMenuHierarchyBinding", "data"],
      textField: "textField",
      urlField: "urlField",
      iconField: "iconField",
      svgIconField: "svgIconField",
      disabledField: "disabledField",
      cssClassField: "cssClassField",
      cssStyleField: "cssStyleField",
      separatorField: "separatorField",
      childrenField: "childrenField"
    },
    exportAs: ["kendoMenuHierarchyBinding"],
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HierarchyBindingDirective, [{
    type: Directive,
    args: [{
      exportAs: "kendoMenuHierarchyBinding",
      selector: "[kendoMenuHierarchyBinding]",
      standalone: true
    }]
  }], () => [{
    type: MenuBase
  }], {
    data: [{
      type: Input,
      args: ["kendoMenuHierarchyBinding"]
    }],
    textField: [{
      type: Input
    }],
    urlField: [{
      type: Input
    }],
    iconField: [{
      type: Input
    }],
    svgIconField: [{
      type: Input
    }],
    disabledField: [{
      type: Input
    }],
    cssClassField: [{
      type: Input
    }],
    cssStyleField: [{
      type: Input
    }],
    separatorField: [{
      type: Input
    }],
    childrenField: [{
      type: Input
    }]
  });
})();
var FlatBindingDirective = class _FlatBindingDirective extends BindingDirectiveBase {
  /**
   * Specifies the array of data which will be used to populate the Menu.
   */
  data;
  /**
   * Defines the `text` field of the items.
   */
  textField;
  /**
   * Defines the `url` field of the items.
   */
  urlField;
  /**
   * Defines the `icon` field of the items.
   */
  iconField;
  /**
   * Defines the `svgIcon` field of the items.
   */
  svgIconField;
  /**
   * Defines the `disabled` field of the items.
   */
  disabledField;
  /**
   * Defines the `cssClass` field of the items.
   */
  cssClassField;
  /**
   * Defines the `cssStyle` field of the items.
   */
  cssStyleField;
  /**
   * Defines the `separator` field of the items.
   */
  separatorField;
  /**
   * Defines the `id` field of the items.
   */
  idField;
  /**
   * Defines the parent `id` field of the items.
   */
  parentIdField;
  constructor(menu) {
    super(menu);
  }
  mapItems(items) {
    if (!this.idField || !this.parentIdField) {
      return items.map((item) => this.createItem(item));
    }
    const result = [];
    const map3 = {};
    for (let idx4 = 0; idx4 < items.length; idx4++) {
      const item = items[idx4];
      const menuItem = this.createItem(item);
      const id3 = getter4(this.idField)(item);
      const parentId = getter4(this.parentIdField)(item);
      if (parentId === null || parentId === void 0) {
        result.push(menuItem);
      } else {
        const parent = map3[parentId] = map3[parentId] || {};
        parent.items = parent.items || [];
        parent.items.push(menuItem);
      }
      if (map3[id3]) {
        menuItem.items = map3[id3].items;
      }
      map3[id3] = menuItem;
    }
    return result;
  }
  createItem(dataItem) {
    const result = {
      data: dataItem
    };
    const fields = this.fields;
    for (let idx4 = 0; idx4 < fields.length; idx4++) {
      const {
        source,
        target
      } = fields[idx4];
      result[target] = getter4(source)(dataItem);
    }
    return result;
  }
  static ɵfac = function FlatBindingDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FlatBindingDirective)(ɵɵdirectiveInject(MenuBase));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FlatBindingDirective,
    selectors: [["", "kendoMenuFlatBinding", ""]],
    inputs: {
      data: [0, "kendoMenuFlatBinding", "data"],
      textField: "textField",
      urlField: "urlField",
      iconField: "iconField",
      svgIconField: "svgIconField",
      disabledField: "disabledField",
      cssClassField: "cssClassField",
      cssStyleField: "cssStyleField",
      separatorField: "separatorField",
      idField: "idField",
      parentIdField: "parentIdField"
    },
    exportAs: ["kendoMenuFlatBinding"],
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FlatBindingDirective, [{
    type: Directive,
    args: [{
      exportAs: "kendoMenuFlatBinding",
      selector: "[kendoMenuFlatBinding]",
      standalone: true
    }]
  }], () => [{
    type: MenuBase
  }], {
    data: [{
      type: Input,
      args: ["kendoMenuFlatBinding"]
    }],
    textField: [{
      type: Input
    }],
    urlField: [{
      type: Input
    }],
    iconField: [{
      type: Input
    }],
    svgIconField: [{
      type: Input
    }],
    disabledField: [{
      type: Input
    }],
    cssClassField: [{
      type: Input
    }],
    cssStyleField: [{
      type: Input
    }],
    separatorField: [{
      type: Input
    }],
    idField: [{
      type: Input
    }],
    parentIdField: [{
      type: Input
    }]
  });
})();
var ContextMenuPopupEvent = class extends PreventableEvent5 {
  /**
   * Specifies the target element for which the ContextMenu is opened.
   */
  target;
  /**
   * Specifies the DOM event that started the action.
   */
  originalEvent;
  /**
   * Specifies the ContextMenuComponent that triggered the event.
   */
  sender;
  /**
   * @hidden
   */
  constructor(args) {
    super();
    Object.assign(this, args);
  }
};
var ContextMenuItemsService = class _ContextMenuItemsService {
  contextService;
  constructor(contextService) {
    this.contextService = contextService;
  }
  get(index) {
    if (this.contextService.items) {
      return this.contextService.items.get(index);
    }
  }
  static ɵfac = function ContextMenuItemsService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ContextMenuItemsService)(ɵɵinject(ContextMenuService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ContextMenuItemsService,
    factory: _ContextMenuItemsService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ContextMenuItemsService, [{
    type: Injectable
  }], () => [{
    type: ContextMenuService
  }], null);
})();
var ContextMenuTemplateDirective = class _ContextMenuTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function ContextMenuTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ContextMenuTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ContextMenuTemplateDirective,
    selectors: [["", "kendoContextMenuTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ContextMenuTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoContextMenuTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var ContextMenuTargetService = class _ContextMenuTargetService {
  targets = [];
  add(target) {
    this.targets.push(target);
  }
  remove(target) {
    const index = this.targets.indexOf(target);
    this.targets.splice(index, 1);
  }
  find(targetElement) {
    return this.targets.find((target) => target.element === targetElement);
  }
  static ɵfac = function ContextMenuTargetService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ContextMenuTargetService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ContextMenuTargetService,
    factory: _ContextMenuTargetService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ContextMenuTargetService, [{
    type: Injectable
  }], null, null);
})();
var ContextMenuTargetContainerDirective = class _ContextMenuTargetContainerDirective {
  targetService;
  /**
   * @hidden
   */
  element;
  /**
   * @hidden
   */
  constructor(elementRef, targetService) {
    this.targetService = targetService;
    if (elementRef) {
      this.element = elementRef.nativeElement;
    }
  }
  static ɵfac = function ContextMenuTargetContainerDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ContextMenuTargetContainerDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ContextMenuTargetService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ContextMenuTargetContainerDirective,
    selectors: [["", "kendoContextMenuTargetContainer", ""]],
    exportAs: ["kendoContextMenuTargetContainer"],
    features: [ɵɵProvidersFeature([ContextMenuTargetService])]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ContextMenuTargetContainerDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoContextMenuTargetContainer]",
      exportAs: "kendoContextMenuTargetContainer",
      providers: [ContextMenuTargetService],
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: ContextMenuTargetService
  }], null);
})();
var TARGET_CLASS = "k-contextmenu-target";
var ContextMenuTargetDirective = class _ContextMenuTargetDirective {
  targetService;
  /**
   * Specifies the data which is associated with the target.
   */
  data;
  /**
   * Specifies the target DOM element.
   */
  element;
  /**
   * @hidden
   */
  hostClass = true;
  constructor(elementRef, targetService) {
    this.targetService = targetService;
    if (elementRef) {
      this.element = elementRef.nativeElement;
    }
    targetService.add(this);
  }
  ngOnDestroy() {
    this.targetService.remove(this);
  }
  static ɵfac = function ContextMenuTargetDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ContextMenuTargetDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ContextMenuTargetService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ContextMenuTargetDirective,
    selectors: [["", "kendoContextMenuTarget", ""]],
    hostVars: 2,
    hostBindings: function ContextMenuTargetDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-contextmenu-target", ctx.hostClass);
      }
    },
    inputs: {
      data: [0, "kendoContextMenuTarget", "data"]
    },
    exportAs: ["kendoContextMenuTarget"]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ContextMenuTargetDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoContextMenuTarget]",
      exportAs: "kendoContextMenuTarget",
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: ContextMenuTargetService
  }], {
    data: [{
      type: Input,
      args: ["kendoContextMenuTarget"]
    }],
    hostClass: [{
      type: HostBinding,
      args: [`class.${TARGET_CLASS}`]
    }]
  });
})();
var CONTEXT_MENU = "contextmenu";
var DEFAULT_ANCHOR_ALIGN = {
  horizontal: "left",
  vertical: "bottom"
};
var DEFAULT_POPUP_ALIGN = {
  horizontal: "left",
  vertical: "top"
};
var DEFAULT_COLLISION = {
  horizontal: "fit",
  vertical: "flip"
};
var preventDefault2 = (e) => e.preventDefault();
var ContextMenuComponent = class _ContextMenuComponent extends MenuBase {
  popupService;
  service;
  ngZone;
  renderer;
  /**
   * Specifies the event on which the ContextMenu will open ([see example]({% slug showon_contextmenu %})).
   * Accepts the name of a native DOM event. For example, `click`, `dblclick`, `mouseover`, etc.
   *
   * @default 'contextmenu'
   */
  showOn = CONTEXT_MENU;
  /**
   * Specifies the element for which the ContextMenu will open ([see example]({% slug target_contextmenu %}#toc-configuration)).
   */
  target;
  /**
   * Specifies a CSS selector which filters the elements in the target for which the ContextMenu will open
   * ([see example](slug:target_contextmenu#toc-changing-items-for-specific-targets)).
   */
  filter;
  /**
   * Specifies if the ContextMenu will be aligned to the target or to the `filter` element (if specified).
   *
   * @default false
   */
  alignToAnchor = false;
  /**
   * Specifies if the Menu will be vertically rendered ([see example]({% slug orientation_contextmenu %})).
   *
   * @default true
   */
  vertical = true;
  /**
   * Specifies the popup animation.
   *
   * @default true
   */
  popupAnimate;
  /**
   * Specifies the pivot point of the popup.
   *
   * @default { horizontal: 'left', vertical: 'top' }
   */
  popupAlign;
  /**
   * Specifies the pivot point of the anchor. Applicable if `alignToAnchor` is `true`.
   *
   * @default { horizontal: 'left', vertical: 'bottom' }
   */
  anchorAlign;
  /**
   * Configures the collision behavior of the popup.
   *
   * @default { horizontal: 'fit', vertical: 'flip' }
   */
  collision;
  /**
   * Defines the container to which the popups will be appended.
   */
  appendTo;
  /**
   * Sets the value for the [`aria-label`](https://www.w3.org/TR/wai-aria-1.1/#aria-label) attribute of the ContextMenu.
   */
  ariaLabel;
  /**
   * Fires when the Menu is opened ([see example](slug:events_contextmenu)).
   */
  popupOpen = new EventEmitter();
  /**
   * Fires when the Menu is closed ([see example](slug:events_contextmenu)).
   */
  popupClose = new EventEmitter();
  /**
   * Fires when a Menu item is selected ([see example](slug:events_contextmenu)).
   */
  select = new EventEmitter();
  /**
   * Fires when a Menu item is opened ([see example](slug:events_contextmenu)).
   */
  open = new EventEmitter();
  /**
   * Fires when a Menu item is closed ([see example](slug:events_contextmenu)).
   */
  close = new EventEmitter();
  /**
   * @hidden
   */
  contentTemplate;
  /**
   * @hidden
   */
  defaultContentTemplate;
  closeSubscription;
  showSubscription;
  keydownSubscription;
  popupSubscriptions;
  popupRef;
  currentTarget;
  directiveTarget;
  activeTarget;
  constructor(popupService, service, ngZone, renderer) {
    super();
    this.popupService = popupService;
    this.service = service;
    this.ngZone = ngZone;
    this.renderer = renderer;
    this.service.owner = this;
    this.popupKeyDownHandler = this.popupKeyDownHandler.bind(this);
  }
  /**
   * Hides the ContextMenu.
   */
  hide() {
    this.removePopup();
  }
  /**
   * Shows the ContextMenu for the specified target.
   *
   * @param target - The offset or the target element for which the ContextMenu will open.
   */
  show(target) {
    if (!target) {
      return;
    }
    const showTarget = target;
    this.removePopup();
    if (defined(showTarget.left) && defined(showTarget.top)) {
      this.createPopup({
        offset: showTarget
      });
    } else {
      this.currentTarget = showTarget.nativeElement || showTarget;
      this.createPopup({
        anchor: this.currentTarget
      });
    }
  }
  ngOnChanges(changes) {
    if (changes.target || changes.showOn) {
      this.bindShowHandler();
    }
  }
  ngOnInit() {
    this.ngZone.runOutsideAngular(() => {
      const closeClickSubscription = this.renderer.listen("document", "mousedown", (e) => {
        if (this.popupRef && !closest3(e.target, (node) => node === this.popupRef.popupElement) && this.service.leaveMenu(e)) {
          this.closePopup(e);
        }
      });
      const closeBlurSubscription = this.renderer.listen("window", "blur", (e) => {
        if (this.popupRef) {
          this.closePopup(e);
        }
      });
      this.closeSubscription = () => {
        closeClickSubscription();
        closeBlurSubscription();
      };
    });
  }
  ngOnDestroy() {
    if (this.closeSubscription) {
      this.closeSubscription();
      this.closeSubscription = null;
    }
    this.unbindShowHandler();
    this.removePopup();
  }
  /**
   * @hidden
   */
  emitMenuEvent(name, args) {
    args.target = this.currentTarget;
    args.sender = this;
    this[name].emit(args);
    if (name === "select" && !args.hasContent) {
      this.closeAndFocus(args.originalEvent);
    }
  }
  bindShowHandler() {
    this.unbindShowHandler();
    this.ngZone.runOutsideAngular(() => {
      const element = this.targetElement();
      if (!element) {
        return;
      }
      const eventName = this.showOn || CONTEXT_MENU;
      this.showSubscription = this.renderer.listen(element, this.showOn || CONTEXT_MENU, (e) => {
        this.showContextMenu(e, element);
      });
      if (eventName === CONTEXT_MENU) {
        this.keydownSubscription = this.renderer.listen(element, "keydown", (e) => {
          if (e.shiftKey && e.code === Keys.F10) {
            this.showContextMenu(e, element);
          }
        });
      }
    });
  }
  showContextMenu(e, element) {
    const filter3 = this.targetFilter();
    let currentTarget = element;
    if (filter3) {
      currentTarget = findInContainer(e.target, filter3, element);
      if (currentTarget && currentTarget !== e.target && isFocusable4(e.target)) {
        return;
      }
      if (currentTarget && this.directiveTarget) {
        currentTarget = this.target.targetService.find(currentTarget);
      }
    }
    if (!currentTarget) {
      this.closePopup(e);
      return;
    }
    this.ngZone.run(() => {
      if (!this.closePopup(e)) {
        this.currentTarget = currentTarget;
        this.openPopup(e);
      }
    });
  }
  unbindShowHandler() {
    if (this.showSubscription) {
      this.showSubscription();
      this.showSubscription = null;
    }
    if (this.keydownSubscription) {
      this.keydownSubscription();
      this.keydownSubscription = null;
    }
  }
  targetElement() {
    if (!isDocumentAvailable()) {
      return;
    }
    this.directiveTarget = false;
    let target = this.target;
    if (typeof target === "string") {
      target = document.querySelector(target);
    } else if (target && target.nativeElement) {
      target = target.nativeElement;
    } else if (target instanceof ContextMenuTargetContainerDirective) {
      target = target.element;
      this.directiveTarget = true;
    }
    return target;
  }
  targetFilter() {
    if (this.directiveTarget) {
      return `.${TARGET_CLASS}`;
    }
    return this.filter;
  }
  closePopup(e) {
    if (!this.popupRef) {
      return;
    }
    return this.popupAction("popupClose", e, () => {
      this.removePopup();
    });
  }
  removePopup() {
    if (this.popupRef) {
      this.popupRef.close();
      this.popupRef = null;
      this.currentTarget = null;
    }
    if (this.popupSubscriptions) {
      this.popupSubscriptions();
      this.popupSubscriptions = null;
    }
  }
  openPopup(e) {
    this.popupAction("popupOpen", e, () => {
      e.preventDefault();
      let anchor, offset3;
      if (this.alignToAnchor || e.type === "keydown") {
        anchor = this.currentTargetElement;
      } else {
        offset3 = {
          left: e.pageX,
          top: e.pageY
        };
      }
      this.createPopup({
        anchor,
        offset: offset3
      });
    });
  }
  createPopup(options) {
    const customClasses = this.popupSettings?.popupClass ? parseCSSClassNames(this.popupSettings.popupClass) : [];
    this.popupRef = this.popupService.open(Object.assign({
      animate: defined(this.popupAnimate) ? this.popupAnimate : true,
      appendTo: this.appendTo,
      collision: this.collision || DEFAULT_COLLISION,
      popupAlign: this.popupAlign || DEFAULT_POPUP_ALIGN,
      anchorAlign: this.anchorAlign || DEFAULT_ANCHOR_ALIGN,
      content: this.contentTemplate ? this.contentTemplate.templateRef : this.defaultContentTemplate,
      popupClass: ["k-menu-popup", ...customClasses],
      margin: this.popupSettings?.margin ?? DEFAULT_MARGIN,
      positionMode: "absolute"
    }, options));
    const element = this.popupRef.popupElement;
    this.renderer.addClass(element, "k-context-menu-popup");
    this.renderer.setAttribute(element, "tabindex", "-1");
    this.renderer.setStyle(element, "outline", "0");
    if (this.ariaLabel) {
      this.renderer.setAttribute(element, "aria-label", this.ariaLabel);
    }
    this.activeTarget = this.currentTargetElement === document.activeElement;
    this.ngZone.runOutsideAngular(() => {
      const unbindKeyDown = this.renderer.listen(element, "keydown", this.popupKeyDownHandler);
      const unbindContextmenu = this.renderer.listen(element, "contextmenu", preventDefault2);
      this.popupSubscriptions = () => {
        unbindKeyDown();
        unbindContextmenu();
      };
    });
    element.focus();
  }
  closeAndFocus(e) {
    const currentTarget = this.currentTargetElement;
    if (!this.closePopup(e) && this.activeTarget) {
      currentTarget.focus();
    }
  }
  popupKeyDownHandler(e) {
    const element = this.popupRef.popupElement;
    if (e.code === Keys.Escape && (hasClass2(e.target, "k-menu-item") || e.target === element)) {
      this.closeAndFocus(e);
    } else if (e.target === element) {
      this.service.keydown.emit(e);
    }
  }
  popupAction(name, originalEvent, callback) {
    const emitter = this[name];
    let prevented = false;
    if (hasObservers(emitter)) {
      this.ngZone.run(() => {
        const args = new ContextMenuPopupEvent({
          originalEvent,
          sender: this,
          target: this.currentTarget
        });
        emitter.emit(args);
        if (!args.isDefaultPrevented()) {
          callback();
        }
        prevented = args.isDefaultPrevented();
      });
    } else {
      callback();
    }
    return prevented;
  }
  get currentTargetElement() {
    return this.directiveTarget && this.currentTarget ? this.currentTarget.element : this.currentTarget;
  }
  static ɵfac = function ContextMenuComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ContextMenuComponent)(ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(ContextMenuService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ContextMenuComponent,
    selectors: [["kendo-contextmenu"]],
    contentQueries: function ContextMenuComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, ContextMenuTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.contentTemplate = _t.first);
      }
    },
    viewQuery: function ContextMenuComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c64, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.defaultContentTemplate = _t.first);
      }
    },
    inputs: {
      showOn: "showOn",
      target: "target",
      filter: "filter",
      alignToAnchor: "alignToAnchor",
      vertical: "vertical",
      popupAnimate: "popupAnimate",
      popupAlign: "popupAlign",
      anchorAlign: "anchorAlign",
      collision: "collision",
      appendTo: "appendTo",
      ariaLabel: "ariaLabel"
    },
    outputs: {
      popupOpen: "popupOpen",
      popupClose: "popupClose",
      select: "select",
      open: "open",
      close: "close"
    },
    exportAs: ["kendoContextMenu"],
    features: [ɵɵProvidersFeature([ContextMenuService, LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.contextmenu"
    }, {
      provide: ItemsService,
      useClass: ContextMenuItemsService
    }, {
      provide: MenuBase,
      useExisting: forwardRef(() => _ContextMenuComponent)
    }, PopupService, {
      provide: POPUP_CONTAINER,
      useFactory: bodyFactory
    }]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
    decls: 2,
    vars: 0,
    consts: [["default", ""], ["ariaRole", "menu", 3, "items", "appendTo", "size", "vertical", "openOnClick", "hoverDelay", "animate", "popupSettings", "menuItemTemplate", "menuItemLinkTemplate"]],
    template: function ContextMenuComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, ContextMenuComponent_ng_template_0_Template, 1, 10, "ng-template", null, 0, ɵɵtemplateRefExtractor);
      }
    },
    dependencies: [MenuComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ContextMenuComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoContextMenu",
      providers: [ContextMenuService, LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.contextmenu"
      }, {
        provide: ItemsService,
        useClass: ContextMenuItemsService
      }, {
        provide: MenuBase,
        useExisting: forwardRef(() => ContextMenuComponent)
      }, PopupService, {
        provide: POPUP_CONTAINER,
        useFactory: bodyFactory
      }],
      selector: "kendo-contextmenu",
      template: `
        <ng-template #default>
            <kendo-menu [items]="rootItems"
                [appendTo]="appendTo"
                [size]="size"
                ariaRole="menu"
                [vertical]="vertical"
                [openOnClick]="openOnClick"
                [hoverDelay]="hoverDelay"
                [animate]="animate"
                [popupSettings]="popupSettings"
                [menuItemTemplate]="itemTemplate.first?.templateRef"
                [menuItemLinkTemplate]="itemLinkTemplate.first?.templateRef"
            ></kendo-menu>
        </ng-template>
    `,
      standalone: true,
      imports: [MenuComponent]
    }]
  }], () => [{
    type: PopupService
  }, {
    type: ContextMenuService
  }, {
    type: NgZone
  }, {
    type: Renderer2
  }], {
    showOn: [{
      type: Input
    }],
    target: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    alignToAnchor: [{
      type: Input
    }],
    vertical: [{
      type: Input
    }],
    popupAnimate: [{
      type: Input
    }],
    popupAlign: [{
      type: Input
    }],
    anchorAlign: [{
      type: Input
    }],
    collision: [{
      type: Input
    }],
    appendTo: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input
    }],
    popupOpen: [{
      type: Output
    }],
    popupClose: [{
      type: Output
    }],
    select: [{
      type: Output
    }],
    open: [{
      type: Output
    }],
    close: [{
      type: Output
    }],
    contentTemplate: [{
      type: ContentChild,
      args: [ContextMenuTemplateDirective, {
        static: false
      }]
    }],
    defaultContentTemplate: [{
      type: ViewChild,
      args: ["default", {
        static: false
      }]
    }]
  });
})();
var KENDO_MENU = [MenuComponent, MenuItemComponent, ItemTemplateDirective, ItemLinkTemplateDirective, ItemContentTemplateDirective, HierarchyBindingDirective, FlatBindingDirective, LinkDirective, ExpandArrowComponent];
var KENDO_CONTEXTMENU = [ContextMenuComponent, ContextMenuTemplateDirective, ContextMenuTargetDirective, ContextMenuTargetContainerDirective, ...KENDO_MENU];
var KENDO_MENUS = [...KENDO_MENU, ...KENDO_CONTEXTMENU];
var MenuModule = class _MenuModule {
  static ɵfac = function MenuModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MenuModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _MenuModule,
    imports: [MenuComponent, MenuItemComponent, ItemTemplateDirective, ItemLinkTemplateDirective, ItemContentTemplateDirective, HierarchyBindingDirective, FlatBindingDirective, LinkDirective, ExpandArrowComponent],
    exports: [MenuComponent, MenuItemComponent, ItemTemplateDirective, ItemLinkTemplateDirective, ItemContentTemplateDirective, HierarchyBindingDirective, FlatBindingDirective, LinkDirective, ExpandArrowComponent]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [PopupService, IconsService, ResizeBatchService],
    imports: [MenuComponent, ExpandArrowComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MenuModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_MENU],
      imports: [...KENDO_MENU],
      providers: [PopupService, IconsService, ResizeBatchService]
    }]
  }], null, null);
})();
var ContextMenuModule = class _ContextMenuModule {
  static ɵfac = function ContextMenuModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ContextMenuModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _ContextMenuModule,
    imports: [ContextMenuComponent, ContextMenuTemplateDirective, ContextMenuTargetDirective, ContextMenuTargetContainerDirective, MenuComponent, MenuItemComponent, ItemTemplateDirective, ItemLinkTemplateDirective, ItemContentTemplateDirective, HierarchyBindingDirective, FlatBindingDirective, LinkDirective, ExpandArrowComponent],
    exports: [ContextMenuComponent, ContextMenuTemplateDirective, ContextMenuTargetDirective, ContextMenuTargetContainerDirective, MenuComponent, MenuItemComponent, ItemTemplateDirective, ItemLinkTemplateDirective, ItemContentTemplateDirective, HierarchyBindingDirective, FlatBindingDirective, LinkDirective, ExpandArrowComponent]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [PopupService, IconsService, ResizeBatchService],
    imports: [ContextMenuComponent, MenuComponent, ExpandArrowComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ContextMenuModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_CONTEXTMENU],
      imports: [...KENDO_CONTEXTMENU],
      providers: [PopupService, IconsService, ResizeBatchService]
    }]
  }], null, null);
})();
var MenusModule = class _MenusModule {
  static ɵfac = function MenusModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MenusModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _MenusModule,
    imports: [MenuComponent, MenuItemComponent, ItemTemplateDirective, ItemLinkTemplateDirective, ItemContentTemplateDirective, HierarchyBindingDirective, FlatBindingDirective, LinkDirective, ExpandArrowComponent, ContextMenuComponent, ContextMenuTemplateDirective, ContextMenuTargetDirective, ContextMenuTargetContainerDirective, MenuComponent, MenuItemComponent, ItemTemplateDirective, ItemLinkTemplateDirective, ItemContentTemplateDirective, HierarchyBindingDirective, FlatBindingDirective, LinkDirective, ExpandArrowComponent],
    exports: [MenuComponent, MenuItemComponent, ItemTemplateDirective, ItemLinkTemplateDirective, ItemContentTemplateDirective, HierarchyBindingDirective, FlatBindingDirective, LinkDirective, ExpandArrowComponent, ContextMenuComponent, ContextMenuTemplateDirective, ContextMenuTargetDirective, ContextMenuTargetContainerDirective, MenuComponent, MenuItemComponent, ItemTemplateDirective, ItemLinkTemplateDirective, ItemContentTemplateDirective, HierarchyBindingDirective, FlatBindingDirective, LinkDirective, ExpandArrowComponent]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [PopupService, IconsService, ResizeBatchService],
    imports: [MenuComponent, ExpandArrowComponent, ContextMenuComponent, MenuComponent, ExpandArrowComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MenusModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_MENUS],
      imports: [...KENDO_MENUS],
      providers: [PopupService, IconsService, ResizeBatchService]
    }]
  }], null, null);
})();

// node_modules/@progress/kendo-angular-conversational-ui/fesm2022/progress-kendo-angular-conversational-ui.mjs
var _c08 = ["content"];
var _c115 = ["fabButton"];
function AIPromptComponent_For_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 11);
    ɵɵlistener("click", function AIPromptComponent_For_4_Template_button_click_0_listener() {
      const ɵ$index_7_r2 = ɵɵrestoreView(_r1).$index;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.viewChange(ɵ$index_7_r2));
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const view_r4 = ctx.$implicit;
    const ɵ$index_7_r2 = ctx.$index;
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("svgIcon", view_r4.svgIcon)("icon", view_r4.icon)("selected", ɵ$index_7_r2 === ctx_r2.activeView);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", view_r4.buttonText, " ");
  }
}
function AIPromptComponent_Conditional_5_ng_template_0_Template(rf, ctx) {
}
function AIPromptComponent_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, AIPromptComponent_Conditional_5_ng_template_0_Template, 0, 0, "ng-template", 5);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r2.toolbarActionsTemplate == null ? null : ctx_r2.toolbarActionsTemplate.templateRef);
  }
}
function AIPromptComponent_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-floatingactionbutton", 12, 0);
    ɵɵlistener("click", function AIPromptComponent_Conditional_7_Template_kendo_floatingactionbutton_click_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.promptRequestCancel.emit());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("positionMode", ctx_r2.fabPositionMode)("align", ctx_r2.fabAlignment)("svgIcon", ctx_r2.fabStopGenerationSVGIcon);
  }
}
function AIPromptComponent_ng_container_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function AIPromptComponent_Conditional_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 10)(1, "div", 13)(2, "button", 14);
    ɵɵlistener("click", function AIPromptComponent_Conditional_10_Template_button_click_2_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleGenerateOutput());
    });
    ɵɵtext(3);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵproperty("svgIcon", ctx_r2.generateButtonSVGIcon)("icon", ctx_r2.generateButtonIcon)("disabled", ctx_r2.disabledGenerateButton);
    ɵɵattribute("title", ctx_r2.messageFor("generateOutput"))("aria-label", ctx_r2.messageFor("generateOutput"))("aria-disabled", ctx_r2.disabledGenerateButton);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r2.messageFor("generateOutput"));
  }
}
function CommandViewComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-panelbar", 1);
    ɵɵlistener("itemClick", function CommandViewComponent_ng_template_0_Template_kendo_panelbar_itemClick_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.itemClickHandler($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("items", ctx_r1.panelBarItems)("animate", false)("selectable", false);
  }
}
var _c215 = ["kendoAIPromptOutputCard", ""];
var _c314 = (a0) => ({
  $implicit: a0
});
function AIPromptOutputCardComponent_Conditional_6_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function AIPromptOutputCardComponent_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, AIPromptOutputCardComponent_Conditional_6_ng_container_0_Template, 1, 0, "ng-container", 7);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.customBodyTemplate)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c314, ctx_r0.promptOutput));
  }
}
function AIPromptOutputCardComponent_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "p");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.promptOutput.output);
  }
}
function AIPromptOutputCardComponent_Conditional_13_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelement(0, "span", 8);
    ɵɵelementStart(1, "button", 9);
    ɵɵlistener("click", function AIPromptOutputCardComponent_Conditional_13_Template_button_click_1_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.handleRating("positive"));
    });
    ɵɵelementEnd();
    ɵɵelementStart(2, "button", 10);
    ɵɵlistener("click", function AIPromptOutputCardComponent_Conditional_13_Template_button_click_2_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.handleRating("negative"));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r0.positiveRatingIcon);
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r0.negativeRatingIcon);
  }
}
function OutputViewComponent_ng_template_0_For_2_Conditional_0_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function OutputViewComponent_ng_template_0_For_2_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, OutputViewComponent_ng_template_0_For_2_Conditional_0_ng_container_0_Template, 1, 0, "ng-container", 3);
  }
  if (rf & 2) {
    const output_r1 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.customTemplate)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c314, output_r1));
  }
}
function OutputViewComponent_ng_template_0_For_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 2);
  }
  if (rf & 2) {
    const output_r1 = ɵɵnextContext().$implicit;
    ɵɵproperty("promptOutput", output_r1);
  }
}
function OutputViewComponent_ng_template_0_For_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, OutputViewComponent_ng_template_0_For_2_Conditional_0_Template, 1, 4, "ng-container")(1, OutputViewComponent_ng_template_0_For_2_Conditional_1_Template, 1, 1, "div", 2);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵconditional(ctx_r1.customTemplate ? 0 : 1);
  }
}
function OutputViewComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 1);
    ɵɵrepeaterCreate(1, OutputViewComponent_ng_template_0_For_2_Template, 2, 1, null, null, ɵɵrepeaterTrackByIdentity);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵrepeater(ctx_r1.promptOutputs);
  }
}
function PromptViewComponent_ng_template_0_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-textarea-suffix")(1, "button", 3);
    ɵɵlistener("error", function PromptViewComponent_ng_template_0_Conditional_1_Template_button_error_1_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onSpeechToTextError($event));
    })("result", function PromptViewComponent_ng_template_0_Conditional_1_Template_button_result_1_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onSpeechToTextResult($event));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("continuous", ctx_r1.speechToTextButtonSettings == null ? null : ctx_r1.speechToTextButtonSettings.continuous)("disabled", ctx_r1.speechToTextButtonSettings == null ? null : ctx_r1.speechToTextButtonSettings.disabled)("fillMode", (ctx_r1.speechToTextButtonSettings == null ? null : ctx_r1.speechToTextButtonSettings.fillMode) ?? "flat")("integrationMode", (ctx_r1.speechToTextButtonSettings == null ? null : ctx_r1.speechToTextButtonSettings.integrationMode) ?? "webSpeech")("interimResults", ctx_r1.speechToTextButtonSettings == null ? null : ctx_r1.speechToTextButtonSettings.interimResults)("lang", ctx_r1.speechToTextButtonSettings == null ? null : ctx_r1.speechToTextButtonSettings.lang)("maxAlternatives", ctx_r1.speechToTextButtonSettings == null ? null : ctx_r1.speechToTextButtonSettings.maxAlternatives)("rounded", ctx_r1.speechToTextButtonSettings == null ? null : ctx_r1.speechToTextButtonSettings.rounded)("size", ctx_r1.speechToTextButtonSettings == null ? null : ctx_r1.speechToTextButtonSettings.size)("themeColor", ctx_r1.speechToTextButtonSettings == null ? null : ctx_r1.speechToTextButtonSettings.themeColor);
    ɵɵattribute("aria-label", ctx_r1.messageFor("speechToTextButton"))("title", ctx_r1.messageFor("speechToTextButton"))("aria-disabled", ctx_r1.speechToTextButtonSettings == null ? null : ctx_r1.speechToTextButtonSettings.disabled);
  }
}
function PromptViewComponent_ng_template_0_Conditional_2_Conditional_3_For_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 8);
    ɵɵlistener("click", function PromptViewComponent_ng_template_0_Conditional_2_Conditional_3_For_3_Template_div_click_0_listener() {
      const suggestion_r6 = ɵɵrestoreView(_r5).$implicit;
      const ctx_r1 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r1.suggestionClick(suggestion_r6));
    })("keydown", function PromptViewComponent_ng_template_0_Conditional_2_Conditional_3_For_3_Template_div_keydown_0_listener($event) {
      const suggestion_r6 = ɵɵrestoreView(_r5).$implicit;
      const ctx_r1 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r1.suggestionKeydown($event, suggestion_r6));
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const suggestion_r6 = ctx.$implicit;
    ɵɵattribute("tabindex", 0)("aria-label", suggestion_r6)("title", suggestion_r6);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", suggestion_r6, " ");
  }
}
function PromptViewComponent_ng_template_0_Conditional_2_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 5)(1, "div", 6);
    ɵɵrepeaterCreate(2, PromptViewComponent_ng_template_0_Conditional_2_Conditional_3_For_3_Template, 2, 4, "div", 7, ɵɵrepeaterTrackByIdentity);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵattribute("id", ctx_r1.contentId);
    ɵɵadvance(2);
    ɵɵrepeater(ctx_r1.promptSuggestions);
  }
}
function PromptViewComponent_ng_template_0_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 2)(1, "button", 4);
    ɵɵlistener("click", function PromptViewComponent_ng_template_0_Conditional_2_Template_button_click_1_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.showSuggestions = !ctx_r1.showSuggestions);
    });
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵconditionalCreate(3, PromptViewComponent_ng_template_0_Conditional_2_Conditional_3_Template, 4, 1, "div", 5);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("icon", ctx_r1.suggestionsIcons.font)("svgIcon", ctx_r1.suggestionsIcons.svg);
    ɵɵattribute("aria-controls", ctx_r1.contentId)("aria-expanded", ctx_r1.showSuggestions);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.messageFor("promptSuggestions"), " ");
    ɵɵadvance();
    ɵɵconditional(ctx_r1.showSuggestions ? 3 : -1);
  }
}
function PromptViewComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-textarea", 1);
    ɵɵtwoWayListener("valueChange", function PromptViewComponent_ng_template_0_Template_kendo_textarea_valueChange_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      ɵɵtwoWayBindingSet(ctx_r1.textAreaValue, $event) || (ctx_r1.textAreaValue = $event);
      return ɵɵresetView($event);
    });
    ɵɵconditionalCreate(1, PromptViewComponent_ng_template_0_Conditional_1_Template, 2, 13, "kendo-textarea-suffix");
    ɵɵelementEnd();
    ɵɵconditionalCreate(2, PromptViewComponent_ng_template_0_Conditional_2_Template, 4, 6, "div", 2);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("cols", ctx_r1.textareaSettings == null ? null : ctx_r1.textareaSettings.cols)("disabled", ctx_r1.textareaSettings == null ? null : ctx_r1.textareaSettings.disabled)("fillMode", ctx_r1.textareaSettings == null ? null : ctx_r1.textareaSettings.fillMode)("flow", (ctx_r1.textareaSettings == null ? null : ctx_r1.textareaSettings.flow) ?? "vertical")("inputAttributes", ctx_r1.textareaSettings == null ? null : ctx_r1.textareaSettings.inputAttributes)("maxlength", ctx_r1.textareaSettings == null ? null : ctx_r1.textareaSettings.maxlength)("placeholder", (ctx_r1.textareaSettings == null ? null : ctx_r1.textareaSettings.placeholder) ?? ctx_r1.messageFor("promptPlaceholder"))("readonly", ctx_r1.textareaSettings == null ? null : ctx_r1.textareaSettings.readonly)("resizable", (ctx_r1.textareaSettings == null ? null : ctx_r1.textareaSettings.resizable) ?? "vertical")("rounded", ctx_r1.textareaSettings == null ? null : ctx_r1.textareaSettings.rounded)("rows", (ctx_r1.textareaSettings == null ? null : ctx_r1.textareaSettings.rows) ?? 1)("selectOnFocus", ctx_r1.textareaSettings == null ? null : ctx_r1.textareaSettings.selectOnFocus)("showSuffixSeparator", (ctx_r1.textareaSettings == null ? null : ctx_r1.textareaSettings.showSuffixSeparator) ?? true)("size", ctx_r1.textareaSettings == null ? null : ctx_r1.textareaSettings.size)("tabIndex", ctx_r1.textareaSettings == null ? null : ctx_r1.textareaSettings.tabindex)("title", ctx_r1.textareaSettings == null ? null : ctx_r1.textareaSettings.title);
    ɵɵtwoWayProperty("value", ctx_r1.textAreaValue);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.speechToTextButtonSettings ? 1 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.promptSuggestions ? 2 : -1);
  }
}
var _c49 = ["kendoChatScrollableButton", ""];
var _c56 = ["suggestionsContainer"];
var _c65 = ["prevScrollButton"];
var _c74 = ["nextScrollButton"];
var _c84 = ["item"];
function SuggestedActionsComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 7, 1);
    ɵɵlistener("onClick", function SuggestedActionsComponent_Conditional_0_Template_span_onClick_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.scrollSuggestions($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("prev", true)("title", ctx_r1.getScrollButtonTitle("prev"));
  }
}
function SuggestedActionsComponent_Conditional_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function SuggestedActionsComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 8, 2);
    ɵɵlistener("scroll", function SuggestedActionsComponent_Conditional_1_Template_div_scroll_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onScroll($event));
    });
    ɵɵtemplate(2, SuggestedActionsComponent_Conditional_1_ng_container_2_Template, 1, 0, "ng-container", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    ɵɵnextContext();
    const suggestionsContent_r4 = ɵɵreference(4);
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", suggestionsContent_r4);
  }
}
function SuggestedActionsComponent_Conditional_2_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function SuggestedActionsComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, SuggestedActionsComponent_Conditional_2_ng_container_0_Template, 1, 0, "ng-container", 9);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const suggestionsContent_r4 = ɵɵreference(4);
    ɵɵproperty("ngTemplateOutlet", suggestionsContent_r4);
  }
}
function SuggestedActionsComponent_ng_template_3_Conditional_0_For_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 11, 3);
    ɵɵlistener("click", function SuggestedActionsComponent_ng_template_3_Conditional_0_For_1_Template_span_click_0_listener() {
      const ctx_r5 = ɵɵrestoreView(_r5);
      const action_r7 = ctx_r5.$implicit;
      const ɵ$index_19_r8 = ctx_r5.$index;
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.actionClick(action_r7, ɵ$index_19_r8));
    })("keydown", function SuggestedActionsComponent_ng_template_3_Conditional_0_For_1_Template_span_keydown_0_listener($event) {
      const action_r7 = ɵɵrestoreView(_r5).$implicit;
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.actionKeydown($event, action_r7));
    })("mousedown", function SuggestedActionsComponent_ng_template_3_Conditional_0_For_1_Template_span_mousedown_0_listener() {
      const ɵ$index_19_r8 = ɵɵrestoreView(_r5).$index;
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.toggleActiveState(true, ɵ$index_19_r8));
    })("mouseup", function SuggestedActionsComponent_ng_template_3_Conditional_0_For_1_Template_span_mouseup_0_listener() {
      const ɵ$index_19_r8 = ɵɵrestoreView(_r5).$index;
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.toggleActiveState(false, ɵ$index_19_r8));
    });
    ɵɵtext(2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const action_r7 = ctx.$implicit;
    const ɵ$index_19_r8 = ctx.$index;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵclassProp("k-selected", ctx_r1.isSelected(ɵ$index_19_r8))("k-focus", ctx_r1.isSelected(ɵ$index_19_r8))("k-active", ctx_r1.isActive(ɵ$index_19_r8));
    ɵɵattribute("tabindex", 0);
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", action_r7.title || action_r7.value, " ");
  }
}
function SuggestedActionsComponent_ng_template_3_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵrepeaterCreate(0, SuggestedActionsComponent_ng_template_3_Conditional_0_For_1_Template, 3, 8, "span", 10, ɵɵrepeaterTrackByIdentity);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵrepeater(ctx_r1.actions);
  }
}
function SuggestedActionsComponent_ng_template_3_Conditional_1_Conditional_0_For_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 13, 3);
    ɵɵlistener("click", function SuggestedActionsComponent_ng_template_3_Conditional_1_Conditional_0_For_1_Template_span_click_0_listener() {
      const ctx_r9 = ɵɵrestoreView(_r9);
      const suggestion_r11 = ctx_r9.$implicit;
      const ɵ$index_25_r12 = ctx_r9.$index;
      const ctx_r1 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r1.suggestionClick(suggestion_r11, ɵ$index_25_r12));
    })("keydown", function SuggestedActionsComponent_ng_template_3_Conditional_1_Conditional_0_For_1_Template_span_keydown_0_listener($event) {
      const suggestion_r11 = ɵɵrestoreView(_r9).$implicit;
      const ctx_r1 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r1.suggestionKeydown($event, suggestion_r11));
    })("mousedown", function SuggestedActionsComponent_ng_template_3_Conditional_1_Conditional_0_For_1_Template_span_mousedown_0_listener() {
      const ɵ$index_25_r12 = ɵɵrestoreView(_r9).$index;
      const ctx_r1 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r1.toggleActiveState(true, ɵ$index_25_r12));
    })("mouseup", function SuggestedActionsComponent_ng_template_3_Conditional_1_Conditional_0_For_1_Template_span_mouseup_0_listener() {
      const ɵ$index_25_r12 = ɵɵrestoreView(_r9).$index;
      const ctx_r1 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r1.toggleActiveState(false, ɵ$index_25_r12));
    });
    ɵɵtext(2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const suggestion_r11 = ctx.$implicit;
    const ɵ$index_25_r12 = ctx.$index;
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵclassProp("k-selected", ctx_r1.isSelected(ɵ$index_25_r12))("k-focus", ctx_r1.isSelected(ɵ$index_25_r12))("k-active", ctx_r1.isActive(ɵ$index_25_r12));
    ɵɵattribute("tabindex", 0);
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", suggestion_r11.text, " ");
  }
}
function SuggestedActionsComponent_ng_template_3_Conditional_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵrepeaterCreate(0, SuggestedActionsComponent_ng_template_3_Conditional_1_Conditional_0_For_1_Template, 3, 8, "span", 12, ɵɵrepeaterTrackByIdentity);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵrepeater(ctx_r1.suggestions);
  }
}
function SuggestedActionsComponent_ng_template_3_Conditional_1_Conditional_1_For_1_ng_template_0_Template(rf, ctx) {
}
function SuggestedActionsComponent_ng_template_3_Conditional_1_Conditional_1_For_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, SuggestedActionsComponent_ng_template_3_Conditional_1_Conditional_1_For_1_ng_template_0_Template, 0, 0, "ng-template", 14);
  }
  if (rf & 2) {
    const suggestion_r13 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.suggestionTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c314, suggestion_r13));
  }
}
function SuggestedActionsComponent_ng_template_3_Conditional_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵrepeaterCreate(0, SuggestedActionsComponent_ng_template_3_Conditional_1_Conditional_1_For_1_Template, 1, 4, null, 14, ɵɵrepeaterTrackByIdentity);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵrepeater(ctx_r1.suggestions);
  }
}
function SuggestedActionsComponent_ng_template_3_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, SuggestedActionsComponent_ng_template_3_Conditional_1_Conditional_0_Template, 2, 0);
    ɵɵconditionalCreate(1, SuggestedActionsComponent_ng_template_3_Conditional_1_Conditional_1_Template, 2, 0);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵconditional(!(ctx_r1.suggestionTemplate == null ? null : ctx_r1.suggestionTemplate.templateRef) ? 0 : -1);
    ɵɵadvance();
    ɵɵconditional((ctx_r1.suggestionTemplate == null ? null : ctx_r1.suggestionTemplate.templateRef) ? 1 : -1);
  }
}
function SuggestedActionsComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, SuggestedActionsComponent_ng_template_3_Conditional_0_Template, 2, 0);
    ɵɵconditionalCreate(1, SuggestedActionsComponent_ng_template_3_Conditional_1_Template, 2, 2);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵconditional(ctx_r1.actions ? 0 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.suggestions ? 1 : -1);
  }
}
function SuggestedActionsComponent_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r14 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 7, 4);
    ɵɵlistener("onClick", function SuggestedActionsComponent_Conditional_5_Template_span_onClick_0_listener($event) {
      ɵɵrestoreView(_r14);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.scrollSuggestions($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("prev", false)("title", ctx_r1.getScrollButtonTitle("next"));
  }
}
var _c94 = ["chatFile", ""];
function ChatFileComponent_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 6);
    ɵɵlistener("click", function ChatFileComponent_Conditional_6_Template_button_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.remove.emit(ctx_r1.chatFile));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("svgIcon", ctx_r1.deleteIcon);
    ɵɵattribute("title", ctx_r1.textFor("removeFileTitle"));
  }
}
function ChatFileComponent_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-dropdownbutton", 7);
    ɵɵlistener("itemClick", function ChatFileComponent_Conditional_7_Template_kendo_dropdownbutton_itemClick_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.actionClick.emit($event));
    })("click", function ChatFileComponent_Conditional_7_Template_kendo_dropdownbutton_click_0_listener($event) {
      ɵɵrestoreView(_r3);
      return ɵɵresetView($event.preventDefault());
    })("open", function ChatFileComponent_Conditional_7_Template_kendo_dropdownbutton_open_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.actionsToggle.emit(true));
    })("close", function ChatFileComponent_Conditional_7_Template_kendo_dropdownbutton_close_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.actionsToggle.emit(false));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("data", ctx_r1.fileActions)("svgIcon", ctx_r1.moreIcon);
    ɵɵattribute("title", ctx_r1.textFor("fileActionsTitle"));
  }
}
function MessageReferenceComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵtextInterpolate1(" ", ctx_r0.message.text, " ");
  }
}
function MessageReferenceComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "li", 0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("chatFile", ctx_r0.message.files[0]);
  }
}
function MessageReferenceComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵtextInterpolate1(" ", ctx_r0.textFor("deletedMessageSenderText"), " ");
  }
}
function MessageReferenceComponent_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵtextInterpolate1(" ", ctx_r0.textFor("deletedMessageReceiverText"), " ");
  }
}
var _c104 = ["messageBoxInput"];
var _c116 = ["fileSelect"];
var _c123 = (a0) => ({
  "aria-label": a0
});
function MessageBoxComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-chat-suggested-actions", 7, 1);
    ɵɵlistener("dispatchSuggestion", function MessageBoxComponent_Conditional_0_Template_kendo_chat_suggested_actions_dispatchSuggestion_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.dispatchSuggestion($event));
    })("click", function MessageBoxComponent_Conditional_0_Template_kendo_chat_suggested_actions_click_0_listener($event) {
      ɵɵrestoreView(_r2);
      const suggestedActions_r4 = ɵɵreference(1);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.select(suggestedActions_r4, $event));
    })("focus", function MessageBoxComponent_Conditional_0_Template_kendo_chat_suggested_actions_focus_0_listener($event) {
      ɵɵrestoreView(_r2);
      const suggestedActions_r4 = ɵɵreference(1);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.select(suggestedActions_r4, $event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("suggestions", ctx_r2.suggestions)("suggestionTemplate", ctx_r2.suggestionTemplate)("tabbable", true);
  }
}
function MessageBoxComponent_Conditional_1_Conditional_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 15);
    ɵɵlistener("click", function MessageBoxComponent_Conditional_1_Conditional_2_Conditional_1_Template_div_click_0_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r2 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r2.onReplyReferenceClick($event));
    });
    ɵɵelement(1, "chat-message-reference-content", 16)(2, "span", 17);
    ɵɵelementStart(3, "button", 18);
    ɵɵlistener("click", function MessageBoxComponent_Conditional_1_Conditional_2_Conditional_1_Template_button_click_3_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r2 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r2.removeReply());
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("message", ctx_r2.reply);
    ɵɵadvance(2);
    ɵɵproperty("svgIcon", ctx_r2.deleteIcon);
    ɵɵattribute("title", ctx_r2.textFor("removeReplyTitle"));
  }
}
function MessageBoxComponent_Conditional_1_Conditional_2_For_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "li", 19);
    ɵɵlistener("remove", function MessageBoxComponent_Conditional_1_Conditional_2_For_4_Template_li_remove_0_listener() {
      const ɵ$index_21_r8 = ɵɵrestoreView(_r7).$index;
      const ctx_r2 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r2.removeFile(ɵ$index_21_r8));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const file_r9 = ctx.$implicit;
    ɵɵproperty("chatFile", file_r9)("removable", true);
  }
}
function MessageBoxComponent_Conditional_1_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-textarea-prefix");
    ɵɵconditionalCreate(1, MessageBoxComponent_Conditional_1_Conditional_2_Conditional_1_Template, 4, 3, "div", 12);
    ɵɵelementStart(2, "ul", 13);
    ɵɵrepeaterCreate(3, MessageBoxComponent_Conditional_1_Conditional_2_For_4_Template, 1, 2, "li", 14, ɵɵrepeaterTrackByIdentity);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵconditional(ctx_r2.reply ? 1 : -1);
    ɵɵadvance(2);
    ɵɵrepeater(ctx_r2.files);
  }
}
function MessageBoxComponent_Conditional_1_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 20);
    ɵɵlistener("result", function MessageBoxComponent_Conditional_1_Conditional_4_Template_button_result_0_listener($event) {
      ɵɵrestoreView(_r10);
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.handleSpeechResult($event));
    })("start", function MessageBoxComponent_Conditional_1_Conditional_4_Template_button_start_0_listener() {
      ɵɵrestoreView(_r10);
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.isListening = true);
    })("end", function MessageBoxComponent_Conditional_1_Conditional_4_Template_button_end_0_listener() {
      ɵɵrestoreView(_r10);
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.isListening = false);
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("continuous", ctx_r2.speechToTextButtonSettings == null ? null : ctx_r2.speechToTextButtonSettings.continuous)("disabled", ctx_r2.speechToTextButtonSettings == null ? null : ctx_r2.speechToTextButtonSettings.disabled)("fillMode", (ctx_r2.speechToTextButtonSettings == null ? null : ctx_r2.speechToTextButtonSettings.fillMode) ?? "clear")("integrationMode", (ctx_r2.speechToTextButtonSettings == null ? null : ctx_r2.speechToTextButtonSettings.integrationMode) ?? "webSpeech")("interimResults", ctx_r2.speechToTextButtonSettings == null ? null : ctx_r2.speechToTextButtonSettings.interimResults)("lang", ctx_r2.speechToTextButtonSettings == null ? null : ctx_r2.speechToTextButtonSettings.lang)("maxAlternatives", ctx_r2.speechToTextButtonSettings == null ? null : ctx_r2.speechToTextButtonSettings.maxAlternatives)("rounded", ctx_r2.speechToTextButtonSettings == null ? null : ctx_r2.speechToTextButtonSettings.rounded)("size", ctx_r2.speechToTextButtonSettings == null ? null : ctx_r2.speechToTextButtonSettings.size)("themeColor", ctx_r2.speechToTextButtonSettings == null ? null : ctx_r2.speechToTextButtonSettings.themeColor);
    ɵɵattribute("title", ctx_r2.textFor("speechToTextButtonTitle"));
  }
}
function MessageBoxComponent_Conditional_1_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r11 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 21);
    ɵɵlistener("click", function MessageBoxComponent_Conditional_1_Conditional_5_Template_button_click_0_listener() {
      ɵɵrestoreView(_r11);
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.selectFiles());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("svgIcon", ctx_r2.attachmentIcon);
    ɵɵattribute("title", ctx_r2.textFor("fileSelectButtonTitle"));
  }
}
function MessageBoxComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-textarea", 8, 2);
    ɵɵlistener("keydown", function MessageBoxComponent_Conditional_1_Template_kendo_textarea_keydown_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.textAreaKeydown($event));
    })("valueChange", function MessageBoxComponent_Conditional_1_Template_kendo_textarea_valueChange_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onInputValueChange($event));
    });
    ɵɵconditionalCreate(2, MessageBoxComponent_Conditional_1_Conditional_2_Template, 5, 1, "kendo-textarea-prefix");
    ɵɵelementStart(3, "kendo-textarea-suffix");
    ɵɵconditionalCreate(4, MessageBoxComponent_Conditional_1_Conditional_4_Template, 1, 11, "button", 9);
    ɵɵconditionalCreate(5, MessageBoxComponent_Conditional_1_Conditional_5_Template, 1, 2, "button", 10);
    ɵɵelement(6, "kendo-input-spacer");
    ɵɵelementStart(7, "button", 11);
    ɵɵlistener("click", function MessageBoxComponent_Conditional_1_Template_button_click_7_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.sendClick());
    });
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("rows", 3)("inputAttributes", ɵɵpureFunction1(20, _c123, ctx_r2.textFor("messageBoxInputLabel")))("placeholder", ctx_r2.placeholder || ctx_r2.textFor("messagePlaceholder"))("showSuffixSeparator", false)("value", ctx_r2.inputValue);
    ɵɵadvance(2);
    ɵɵconditional(ctx_r2.reply || ctx_r2.files && ctx_r2.files.length > 0 ? 2 : -1);
    ɵɵadvance(2);
    ɵɵconditional(ctx_r2.speechToTextButtonSettings ? 4 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r2.enableFileSelect ? 5 : -1);
    ɵɵadvance(2);
    ɵɵclassMap((ctx_r2.sendButtonSettings == null ? null : ctx_r2.sendButtonSettings.buttonClass) || "k-chat-send");
    ɵɵclassProp("k-disabled", ctx_r2.isDisabledSendButton);
    ɵɵproperty("fillMode", ctx_r2.sendButtonSettings == null ? null : ctx_r2.sendButtonSettings.fillMode)("themeColor", ctx_r2.sendButtonSettings == null ? null : ctx_r2.sendButtonSettings.themeColor)("rounded", ctx_r2.sendButtonSettings == null ? null : ctx_r2.sendButtonSettings.rounded)("icon", ctx_r2.sendButtonSettings == null ? null : ctx_r2.sendButtonSettings.icon)("svgIcon", ctx_r2.sendButtonSettings == null ? null : ctx_r2.sendButtonSettings.svgIcon)("tabindex", 0);
    ɵɵattribute("title", ctx_r2.textFor("send"))("aria-disabled", ctx_r2.isDisabledSendButton);
  }
}
function MessageBoxComponent_Conditional_2_ng_template_0_Template(rf, ctx) {
}
function MessageBoxComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MessageBoxComponent_Conditional_2_ng_template_0_Template, 0, 0, "ng-template", 5);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r2.messageBoxTemplate == null ? null : ctx_r2.messageBoxTemplate.templateRef);
  }
}
var _c133 = (a0, a1, a2, a3, a4) => ({
  "k-bubble-expandable": a0,
  "k-expanded": a1,
  "k-selected": a2,
  "k-focus": a3,
  "k-active": a4
});
var _c143 = (a0, a1) => ({
  "k-chat-files-wrap": a0,
  "k-chat-files-horizontal": a1
});
var _c153 = (a0, a1) => ({
  $implicit: a0,
  message: a1
});
function MessageComponent_Conditional_0_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function MessageComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MessageComponent_Conditional_0_ng_container_0_Template, 1, 0, "ng-container", 1);
  }
  if (rf & 2) {
    let tmp_1_0;
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", (tmp_1_0 = ctx_r0.getActiveBubbleTemplate()) == null ? null : tmp_1_0.templateRef)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c314, ctx_r0.message));
  }
}
function MessageComponent_Conditional_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "time", 2);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵattribute("aria-hidden", !ctx_r0.selected);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.formatTimeStamp(ctx_r0.message.timestamp), " ");
  }
}
function MessageComponent_Conditional_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 3)(1, "div", 5);
    ɵɵelement(2, "span")(3, "span")(4, "span");
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    ɵɵadvance();
    ɵɵattribute("tabindex", "-1");
  }
}
function MessageComponent_Conditional_1_Conditional_2_Conditional_0_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function MessageComponent_Conditional_1_Conditional_2_Conditional_0_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 9);
    ɵɵlistener("mousedown", function MessageComponent_Conditional_1_Conditional_2_Conditional_0_Conditional_3_Template_span_mousedown_0_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r0.chatService.toggleMessageState = true);
    })("click", function MessageComponent_Conditional_1_Conditional_2_Conditional_0_Conditional_3_Template_span_click_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r0.toggleMessageState($event));
    });
    ɵɵelement(1, "kendo-icon-wrapper", 10);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵattribute("tabindex", "0")("role", "button")("title", ctx_r0.isMessageExpanded ? ctx_r0.textFor("collapseTitle") : ctx_r0.textFor("expandTitle"));
    ɵɵadvance();
    ɵɵproperty("name", ctx_r0.isMessageExpanded ? "chevron-up" : "chevron-down")("svgIcon", ctx_r0.isMessageExpanded ? ctx_r0.collapseIcon : ctx_r0.expandIcon);
  }
}
function MessageComponent_Conditional_1_Conditional_2_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 6)(1, "div", 7);
    ɵɵtemplate(2, MessageComponent_Conditional_1_Conditional_2_Conditional_0_ng_container_2_Template, 1, 0, "ng-container", 1);
    ɵɵelementEnd();
    ɵɵconditionalCreate(3, MessageComponent_Conditional_1_Conditional_2_Conditional_0_Conditional_3_Template, 2, 5, "span", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    let tmp_5_0;
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("ngClass", ɵɵpureFunction5(5, _c133, ctx_r0.isMessageExpandable, ctx_r0.isMessageExpanded, ctx_r0.selected, ctx_r0.selected, ctx_r0.isActiveMessage));
    ɵɵattribute("tabindex", 0);
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", (tmp_5_0 = ctx_r0.getActiveContentTemplate()) == null ? null : tmp_5_0.templateRef)("ngTemplateOutletContext", ɵɵpureFunction1(11, _c314, ctx_r0.message));
    ɵɵadvance();
    ɵɵconditional(ctx_r0.isMessageExpandable && ctx_r0.showExpandCollapseIcon ? 3 : -1);
  }
}
function MessageComponent_Conditional_1_Conditional_2_Conditional_1_Conditional_2_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 15);
    ɵɵlistener("click", function MessageComponent_Conditional_1_Conditional_2_Conditional_1_Conditional_2_Conditional_0_Template_div_click_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r0 = ɵɵnextContext(5);
      return ɵɵresetView(ctx_r0.onReplyReferenceClick($event, ctx_r0.message.replyToId));
    });
    ɵɵelement(1, "chat-message-reference-content", 16);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(5);
    ɵɵadvance();
    ɵɵproperty("message", ctx_r0.getMessageById(ctx_r0.message.replyToId));
  }
}
function MessageComponent_Conditional_1_Conditional_2_Conditional_1_Conditional_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 14);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(5);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.getDeletedMessageText(), " ");
  }
}
function MessageComponent_Conditional_1_Conditional_2_Conditional_1_Conditional_2_Conditional_2_For_2_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const part_r4 = ɵɵnextContext().$implicit;
    ɵɵtextInterpolate(part_r4.content);
  }
}
function MessageComponent_Conditional_1_Conditional_2_Conditional_1_Conditional_2_Conditional_2_For_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "a", 17);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const part_r4 = ɵɵnextContext().$implicit;
    ɵɵproperty("href", part_r4.href, ɵɵsanitizeUrl);
    ɵɵadvance();
    ɵɵtextInterpolate(part_r4.content);
  }
}
function MessageComponent_Conditional_1_Conditional_2_Conditional_1_Conditional_2_Conditional_2_For_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, MessageComponent_Conditional_1_Conditional_2_Conditional_1_Conditional_2_Conditional_2_For_2_Conditional_0_Template, 1, 1);
    ɵɵconditionalCreate(1, MessageComponent_Conditional_1_Conditional_2_Conditional_1_Conditional_2_Conditional_2_For_2_Conditional_1_Template, 2, 2, "a", 17);
  }
  if (rf & 2) {
    const part_r4 = ctx.$implicit;
    ɵɵconditional(part_r4.type === "text" ? 0 : -1);
    ɵɵadvance();
    ɵɵconditional(part_r4.type === "link" ? 1 : -1);
  }
}
function MessageComponent_Conditional_1_Conditional_2_Conditional_1_Conditional_2_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 14);
    ɵɵrepeaterCreate(1, MessageComponent_Conditional_1_Conditional_2_Conditional_1_Conditional_2_Conditional_2_For_2_Template, 2, 2, null, null, ɵɵrepeaterTrackByIdentity);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(5);
    ɵɵadvance();
    ɵɵrepeater(ctx_r0.parts);
  }
}
function MessageComponent_Conditional_1_Conditional_2_Conditional_1_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, MessageComponent_Conditional_1_Conditional_2_Conditional_1_Conditional_2_Conditional_0_Template, 2, 1, "div", 13);
    ɵɵconditionalCreate(1, MessageComponent_Conditional_1_Conditional_2_Conditional_1_Conditional_2_Conditional_1_Template, 2, 1, "span", 14);
    ɵɵconditionalCreate(2, MessageComponent_Conditional_1_Conditional_2_Conditional_1_Conditional_2_Conditional_2_Template, 3, 0, "span", 14);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵconditional(ctx_r0.message.replyToId && !ctx_r0.message.isDeleted ? 0 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r0.message.isDeleted ? 1 : -1);
    ɵɵadvance();
    ɵɵconditional(!ctx_r0.message.isDeleted && ctx_r0.parts.length > 0 ? 2 : -1);
  }
}
function MessageComponent_Conditional_1_Conditional_2_Conditional_1_Conditional_3_For_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "li", 19);
    ɵɵlistener("actionClick", function MessageComponent_Conditional_1_Conditional_2_Conditional_1_Conditional_3_For_2_Template_li_actionClick_0_listener($event) {
      const file_r6 = ɵɵrestoreView(_r5).$implicit;
      const ctx_r0 = ɵɵnextContext(5);
      return ɵɵresetView(ctx_r0.onFileAction($event, file_r6));
    })("actionsToggle", function MessageComponent_Conditional_1_Conditional_2_Conditional_1_Conditional_3_For_2_Template_li_actionsToggle_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r0 = ɵɵnextContext(5);
      return ɵɵresetView(ctx_r0.onActionPopupChange($event));
    })("actionButtonClick", function MessageComponent_Conditional_1_Conditional_2_Conditional_1_Conditional_3_For_2_Template_li_actionButtonClick_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r0 = ɵɵnextContext(5);
      return ɵɵresetView(ctx_r0.onActionButtonClick($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const file_r6 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext(5);
    ɵɵproperty("chatFile", file_r6)("fileActions", ctx_r0.fileActions);
  }
}
function MessageComponent_Conditional_1_Conditional_2_Conditional_1_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "ul", 11);
    ɵɵrepeaterCreate(1, MessageComponent_Conditional_1_Conditional_2_Conditional_1_Conditional_3_For_2_Template, 1, 2, "li", 18, ɵɵrepeaterTrackByIdentity);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵproperty("ngClass", ɵɵpureFunction2(1, _c143, ctx_r0.chatService.messageFilesLayout === "wrap", ctx_r0.chatService.messageFilesLayout === "horizontal"));
    ɵɵadvance();
    ɵɵrepeater(ctx_r0.message.files);
  }
}
function MessageComponent_Conditional_1_Conditional_2_Conditional_1_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 12)(1, "button", 20);
    ɵɵlistener("click", function MessageComponent_Conditional_1_Conditional_2_Conditional_1_Conditional_4_Template_button_click_1_listener() {
      ɵɵrestoreView(_r7);
      const ctx_r0 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r0.onDownloadAll());
    });
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r0.downloadIcon);
    ɵɵattribute("title", ctx_r0.textFor("downloadAllFilesText"));
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.textFor("downloadAllFilesText"));
  }
}
function MessageComponent_Conditional_1_Conditional_2_Conditional_1_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 9);
    ɵɵlistener("mousedown", function MessageComponent_Conditional_1_Conditional_2_Conditional_1_Conditional_5_Template_span_mousedown_0_listener() {
      ɵɵrestoreView(_r8);
      const ctx_r0 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r0.chatService.toggleMessageState = true);
    })("click", function MessageComponent_Conditional_1_Conditional_2_Conditional_1_Conditional_5_Template_span_click_0_listener($event) {
      ɵɵrestoreView(_r8);
      const ctx_r0 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r0.toggleMessageState($event));
    });
    ɵɵelement(1, "kendo-icon-wrapper", 10);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵattribute("tabindex", "0")("role", "button")("title", ctx_r0.isMessageExpanded ? ctx_r0.textFor("collapseTitle") : ctx_r0.textFor("expandTitle"));
    ɵɵadvance();
    ɵɵproperty("name", ctx_r0.isMessageExpanded ? "chevron-up" : "chevron-down")("svgIcon", ctx_r0.isMessageExpanded ? ctx_r0.collapseIcon : ctx_r0.expandIcon);
  }
}
function MessageComponent_Conditional_1_Conditional_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 6)(1, "div", 7);
    ɵɵconditionalCreate(2, MessageComponent_Conditional_1_Conditional_2_Conditional_1_Conditional_2_Template, 3, 3);
    ɵɵconditionalCreate(3, MessageComponent_Conditional_1_Conditional_2_Conditional_1_Conditional_3_Template, 3, 4, "ul", 11);
    ɵɵconditionalCreate(4, MessageComponent_Conditional_1_Conditional_2_Conditional_1_Conditional_4_Template, 3, 3, "div", 12);
    ɵɵelementEnd();
    ɵɵconditionalCreate(5, MessageComponent_Conditional_1_Conditional_2_Conditional_1_Conditional_5_Template, 2, 5, "span", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("ngClass", ɵɵpureFunction5(6, _c133, ctx_r0.isMessageExpandable, ctx_r0.isMessageExpanded, ctx_r0.selected, ctx_r0.selected, ctx_r0.isActiveMessage));
    ɵɵattribute("tabindex", 0);
    ɵɵadvance(2);
    ɵɵconditional(ctx_r0.message.text || ctx_r0.message.isDeleted ? 2 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r0.hasFiles && !ctx_r0.message.isDeleted ? 3 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r0.hasMultipleFiles && !ctx_r0.message.isDeleted ? 4 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r0.isMessageExpandable && ctx_r0.showExpandCollapseIcon ? 5 : -1);
  }
}
function MessageComponent_Conditional_1_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, MessageComponent_Conditional_1_Conditional_2_Conditional_0_Template, 4, 13, "div", 6);
    ɵɵconditionalCreate(1, MessageComponent_Conditional_1_Conditional_2_Conditional_1_Template, 6, 12, "div", 6);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵconditional(ctx_r0.useCustomContentTemplate ? 0 : -1);
    ɵɵadvance();
    ɵɵconditional(!ctx_r0.useCustomContentTemplate && ctx_r0.hasMessageContent ? 1 : -1);
  }
}
function MessageComponent_Conditional_1_Conditional_3_Conditional_1_ng_template_0_Template(rf, ctx) {
}
function MessageComponent_Conditional_1_Conditional_3_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MessageComponent_Conditional_1_Conditional_3_Conditional_1_ng_template_0_Template, 0, 0, "ng-template", 21);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.statusTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c153, ctx_r0.message.status, ctx_r0.message));
  }
}
function MessageComponent_Conditional_1_Conditional_3_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵtextInterpolate1(" ", ctx_r0.message.status, " ");
  }
}
function MessageComponent_Conditional_1_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 4);
    ɵɵconditionalCreate(1, MessageComponent_Conditional_1_Conditional_3_Conditional_1_Template, 1, 5, null, 21);
    ɵɵconditionalCreate(2, MessageComponent_Conditional_1_Conditional_3_Conditional_2_Template, 1, 1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵconditional((ctx_r0.statusTemplate == null ? null : ctx_r0.statusTemplate.templateRef) ? 1 : -1);
    ɵɵadvance();
    ɵɵconditional(!(ctx_r0.statusTemplate == null ? null : ctx_r0.statusTemplate.templateRef) ? 2 : -1);
  }
}
function MessageComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, MessageComponent_Conditional_1_Conditional_0_Template, 2, 2, "time", 2);
    ɵɵconditionalCreate(1, MessageComponent_Conditional_1_Conditional_1_Template, 5, 1, "div", 3);
    ɵɵconditionalCreate(2, MessageComponent_Conditional_1_Conditional_2_Template, 2, 2);
    ɵɵconditionalCreate(3, MessageComponent_Conditional_1_Conditional_3_Template, 3, 2, "span", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵconditional(ctx_r0.chatService.timestampVisibility === "focus" && ctx_r0.message.timestamp ? 0 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r0.message.typing ? 1 : -1);
    ɵɵadvance();
    ɵɵconditional(!ctx_r0.message.typing ? 2 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r0.message.status ? 3 : -1);
  }
}
function MessageComponent_Conditional_2_For_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-toolbar-button", 23);
    ɵɵlistener("click", function MessageComponent_Conditional_2_For_2_Template_kendo_toolbar_button_click_0_listener($event) {
      const action_r10 = ɵɵrestoreView(_r9).$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.onToolbarAction($event, action_r10, ctx_r0.message));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const action_r10 = ctx.$implicit;
    ɵɵproperty("icon", action_r10.icon)("svgIcon", action_r10.svgIcon)("disabled", action_r10.disabled)("title", action_r10.label);
  }
}
function MessageComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-toolbar", 0);
    ɵɵrepeaterCreate(1, MessageComponent_Conditional_2_For_2_Template, 1, 4, "kendo-toolbar-button", 22, ɵɵrepeaterTrackByIdentity);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵrepeater(ctx_r0.toolbarActions);
  }
}
function AttachmentComponent_Conditional_0_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function AttachmentComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, AttachmentComponent_Conditional_0_ng_container_0_Template, 1, 0, "ng-container", 1);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.template.templateRef)("ngTemplateOutletContext", ctx_r0.context);
  }
}
function AttachmentComponent_Conditional_1_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "h5", 3);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.attachment.title, " ");
  }
}
function AttachmentComponent_Conditional_1_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "h6", 4);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.attachment.subtitle, " ");
  }
}
function AttachmentComponent_Conditional_1_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "img");
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵattribute("src", ctx_r0.attachment.content, ɵɵsanitizeUrl);
  }
}
function AttachmentComponent_Conditional_1_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵtextInterpolate1(" ", ctx_r0.attachment.content, " ");
  }
}
function AttachmentComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 0)(1, "div", 2);
    ɵɵconditionalCreate(2, AttachmentComponent_Conditional_1_Conditional_2_Template, 2, 1, "h5", 3);
    ɵɵconditionalCreate(3, AttachmentComponent_Conditional_1_Conditional_3_Template, 2, 1, "h6", 4);
    ɵɵconditionalCreate(4, AttachmentComponent_Conditional_1_Conditional_4_Template, 1, 1, "img");
    ɵɵconditionalCreate(5, AttachmentComponent_Conditional_1_Conditional_5_Template, 1, 1);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵconditional(ctx_r0.attachment.title ? 2 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r0.attachment.subtitle ? 3 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r0.image ? 4 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r0.unknown ? 5 : -1);
  }
}
var _c163 = ["deck"];
function MessageAttachmentsComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 5);
    ɵɵlistener("click", function MessageAttachmentsComponent_Conditional_0_Template_button_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.scrollTo(-1));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("svgIcon", ctx_r1.chevronLeftIcon);
    ɵɵattribute("title", ctx_r1.textFor("messageAttachmentLeftArrow"));
  }
}
function MessageAttachmentsComponent_For_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-chat-attachment", 6, 1);
    ɵɵlistener("click", function MessageAttachmentsComponent_For_4_Template_kendo_chat_attachment_click_0_listener() {
      const ɵ$index_6_r4 = ɵɵrestoreView(_r3).$index;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.itemClick(ɵ$index_6_r4));
    })("keydown", function MessageAttachmentsComponent_For_4_Template_kendo_chat_attachment_keydown_0_listener($event) {
      const att_r5 = ɵɵrestoreView(_r3).$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.itemKeydown($event, att_r5));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const att_r5 = ctx.$implicit;
    const ɵ$index_6_r4 = ctx.$index;
    const ɵ$count_6_r6 = ctx.$count;
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("k-selected", ctx_r1.isSelected(ɵ$index_6_r4))("k-focus", ctx_r1.isSelected(ɵ$index_6_r4))("k-card-wrap", true)("k-first", ɵ$index_6_r4 === 0)("k-last", ɵ$index_6_r4 === ɵ$count_6_r6 - 1);
    ɵɵproperty("attachment", att_r5)("template", ctx_r1.template);
    ɵɵattribute("tabindex", ctx_r1.tabbable && ctx_r1.isSelected(ɵ$index_6_r4) ? "0" : "-1");
  }
}
function MessageAttachmentsComponent_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 7);
    ɵɵlistener("click", function MessageAttachmentsComponent_Conditional_5_Template_button_click_0_listener() {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.scrollTo(1));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("svgIcon", ctx_r1.chevronRightIcon);
    ɵɵattribute("title", ctx_r1.textFor("messageAttachmentRightArrow"));
  }
}
function MessageListComponent_For_1_Case_0_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 8);
  }
  if (rf & 2) {
    const group_r1 = ɵɵnextContext(2).$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.timestampTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c314, group_r1.timestamp));
  }
}
function MessageListComponent_For_1_Case_0_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const group_r1 = ɵɵnextContext(2).$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵtextInterpolate1(" ", ctx_r1.formatTimeStamp(group_r1.timestamp), " ");
  }
}
function MessageListComponent_For_1_Case_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 4);
    ɵɵconditionalCreate(1, MessageListComponent_For_1_Case_0_Conditional_1_Template, 1, 4, "ng-container", 8);
    ɵɵconditionalCreate(2, MessageListComponent_For_1_Case_0_Conditional_2_Template, 1, 1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵconditional((ctx_r1.timestampTemplate == null ? null : ctx_r1.timestampTemplate.templateRef) ? 1 : -1);
    ɵɵadvance();
    ɵɵconditional(!(ctx_r1.timestampTemplate == null ? null : ctx_r1.timestampTemplate.templateRef) ? 2 : -1);
  }
}
function MessageListComponent_For_1_Case_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 10)(1, "span", 14);
    ɵɵelement(2, "img", 15);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const group_r1 = ɵɵnextContext(2).$implicit;
    ɵɵadvance(2);
    ɵɵproperty("alt", group_r1.author.avatarAltText);
    ɵɵattribute("src", group_r1.author.avatarUrl, ɵɵsanitizeUrl);
  }
}
function MessageListComponent_For_1_Case_1_Conditional_2_Conditional_4_ng_template_1_Template(rf, ctx) {
}
function MessageListComponent_For_1_Case_1_Conditional_2_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 16);
    ɵɵtemplate(1, MessageListComponent_For_1_Case_1_Conditional_2_Conditional_4_ng_template_1_Template, 0, 0, "ng-template", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const group_r1 = ɵɵnextContext(3).$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.userStatusTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c314, group_r1.messages.at(-1)));
  }
}
function MessageListComponent_For_1_Case_1_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 11)(1, "div", 10)(2, "span", 14);
    ɵɵelement(3, "img", 15);
    ɵɵelementEnd()();
    ɵɵconditionalCreate(4, MessageListComponent_For_1_Case_1_Conditional_2_Conditional_4_Template, 2, 4, "div", 16);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const group_r1 = ɵɵnextContext(2).$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(3);
    ɵɵproperty("alt", group_r1.author.avatarAltText);
    ɵɵattribute("src", group_r1.author.avatarUrl, ɵɵsanitizeUrl);
    ɵɵadvance();
    ɵɵconditional((ctx_r1.userStatusTemplate == null ? null : ctx_r1.userStatusTemplate.templateRef) ? 4 : -1);
  }
}
function MessageListComponent_For_1_Case_1_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "p", 13);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const group_r1 = ɵɵnextContext(2).$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate(group_r1.author.name);
  }
}
function MessageListComponent_For_1_Case_1_For_6_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 10)(1, "span", 14);
    ɵɵelement(2, "img", 19);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const msg_r3 = ɵɵnextContext().$implicit;
    ɵɵadvance(2);
    ɵɵproperty("src", msg_r3.user == null ? null : msg_r3.user.avatarUrl, ɵɵsanitizeUrl);
  }
}
function MessageListComponent_For_1_Case_1_For_6_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-chat-attachment", 18);
  }
  if (rf & 2) {
    const msg_r3 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵproperty("attachment", msg_r3.attachments[0])("template", ctx_r1.attachmentTemplate);
  }
}
function MessageListComponent_For_1_Case_1_For_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, MessageListComponent_For_1_Case_1_For_6_Conditional_0_Template, 3, 1, "div", 10);
    ɵɵelement(1, "kendo-chat-message", 17, 0);
    ɵɵconditionalCreate(3, MessageListComponent_For_1_Case_1_For_6_Conditional_3_Template, 1, 2, "kendo-chat-attachment", 18);
  }
  if (rf & 2) {
    const msg_r3 = ctx.$implicit;
    const ɵ$index_40_r4 = ctx.$index;
    const ɵ$count_40_r5 = ctx.$count;
    const ctx_r5 = ɵɵnextContext(2);
    const ɵ$index_1_r7 = ctx_r5.$index;
    const ɵ$count_1_r8 = ctx_r5.$count;
    const ctx_r1 = ɵɵnextContext();
    ɵɵconditional((msg_r3.user == null ? null : msg_r3.user.avatarUrl) ? 0 : -1);
    ɵɵadvance();
    ɵɵproperty("message", msg_r3)("tabbable", ɵ$index_1_r7 === ɵ$count_1_r8 - 1 && ɵ$index_40_r4 === ɵ$count_40_r5 - 1)("authorMessageContentTemplate", ctx_r1.authorMessageContentTemplate)("receiverMessageContentTemplate", ctx_r1.receiverMessageContentTemplate)("messageContentTemplate", ctx_r1.messageContentTemplate)("authorMessageTemplate", ctx_r1.authorMessageTemplate)("receiverMessageTemplate", ctx_r1.receiverMessageTemplate)("messageTemplate", ctx_r1.messageTemplate)("statusTemplate", ctx_r1.statusTemplate)("authorId", ctx_r1.authorId);
    ɵɵadvance(2);
    ɵɵconditional(msg_r3.attachments && msg_r3.attachments.length === 1 ? 3 : -1);
  }
}
function MessageListComponent_For_1_Case_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 9);
    ɵɵconditionalCreate(1, MessageListComponent_For_1_Case_1_Conditional_1_Template, 3, 2, "div", 10);
    ɵɵconditionalCreate(2, MessageListComponent_For_1_Case_1_Conditional_2_Template, 5, 3, "div", 11);
    ɵɵelementStart(3, "div", 12);
    ɵɵconditionalCreate(4, MessageListComponent_For_1_Case_1_Conditional_4_Template, 2, 1, "p", 13);
    ɵɵrepeaterCreate(5, MessageListComponent_For_1_Case_1_For_6_Template, 4, 12, null, null, ɵɵrepeaterTrackByIdentity);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const group_r1 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("k-message-group-sender", ctx_r1.isOwnMessage(group_r1.messages[0]))("k-message-group-receiver", !ctx_r1.isOwnMessage(group_r1.messages[0]))("k-no-avatar", !ctx_r1.showGroupAvatar(group_r1))("k-message-group-full-width", ctx_r1.calculateMessageWidthMode(group_r1.messages[0]));
    ɵɵadvance();
    ɵɵconditional(!(ctx_r1.userStatusTemplate == null ? null : ctx_r1.userStatusTemplate.templateRef) && ctx_r1.showGroupAvatar(group_r1) ? 1 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.showGroupAvatar(group_r1) && (ctx_r1.userStatusTemplate == null ? null : ctx_r1.userStatusTemplate.templateRef) ? 2 : -1);
    ɵɵadvance(2);
    ɵɵconditional(ctx_r1.showGroupAuthor(group_r1) ? 4 : -1);
    ɵɵadvance();
    ɵɵrepeater(group_r1.messages);
  }
}
function MessageListComponent_For_1_Case_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-chat-message-attachments", 20, 1);
    ɵɵlistener("click", function MessageListComponent_For_1_Case_2_Template_kendo_chat_message_attachments_click_0_listener() {
      ɵɵrestoreView(_r9);
      const attachments_r10 = ɵɵreference(1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.select(attachments_r10));
    })("focus", function MessageListComponent_For_1_Case_2_Template_kendo_chat_message_attachments_focus_0_listener() {
      ɵɵrestoreView(_r9);
      const attachments_r10 = ɵɵreference(1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.select(attachments_r10));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    const group_r1 = ctx_r5.$implicit;
    const ɵ$index_1_r7 = ctx_r5.$index;
    const ɵ$count_1_r8 = ctx_r5.$count;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("attachments", group_r1.attachments)("layout", group_r1.attachmentLayout)("localization", ctx_r1.localization)("tabbable", ɵ$index_1_r7 === ɵ$count_1_r8 - 1)("template", ctx_r1.attachmentTemplate);
  }
}
function MessageListComponent_For_1_Case_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r11 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-chat-suggested-actions", 21, 2);
    ɵɵlistener("dispatchAction", function MessageListComponent_For_1_Case_3_Template_kendo_chat_suggested_actions_dispatchAction_0_listener($event) {
      ɵɵrestoreView(_r11);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.dispatchAction($event, ctx_r1.last(ctx_r1.view)));
    })("click", function MessageListComponent_For_1_Case_3_Template_kendo_chat_suggested_actions_click_0_listener($event) {
      ɵɵrestoreView(_r11);
      const actions_r12 = ɵɵreference(1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.select(actions_r12, $event));
    })("focus", function MessageListComponent_For_1_Case_3_Template_kendo_chat_suggested_actions_focus_0_listener($event) {
      ɵɵrestoreView(_r11);
      const actions_r12 = ɵɵreference(1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.select(actions_r12, $event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    const group_r1 = ctx_r5.$implicit;
    const ɵ$index_1_r7 = ctx_r5.$index;
    const ɵ$count_1_r8 = ctx_r5.$count;
    ɵɵproperty("actions", group_r1.actions)("tabbable", ɵ$index_1_r7 === ɵ$count_1_r8 - 1);
  }
}
function MessageListComponent_For_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, MessageListComponent_For_1_Case_0_Template, 3, 2, "div", 4)(1, MessageListComponent_For_1_Case_1_Template, 7, 11, "div", 5)(2, MessageListComponent_For_1_Case_2_Template, 2, 5, "kendo-chat-message-attachments", 6)(3, MessageListComponent_For_1_Case_3_Template, 2, 2, "kendo-chat-suggested-actions", 7);
  }
  if (rf & 2) {
    let tmp_11_0;
    const group_r1 = ctx.$implicit;
    ɵɵconditional((tmp_11_0 = group_r1.type) === "date-marker" ? 0 : tmp_11_0 === "message-group" ? 1 : tmp_11_0 === "attachment-group" ? 2 : tmp_11_0 === "action-group" ? 3 : -1);
  }
}
var _c173 = ["messagesContextMenu"];
var _c183 = ["messageBox"];
var _c193 = ["messageList"];
var _c203 = () => ({
  horizontal: "right",
  vertical: "top"
});
var _c216 = () => ({
  horizontal: "flip",
  vertical: "flip"
});
function ChatComponent_Conditional_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function ChatComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-appbar", 4);
    ɵɵtemplate(1, ChatComponent_Conditional_1_ng_container_1_Template, 1, 0, "ng-container", 11);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.chatHeaderTemplate.templateRef);
  }
}
function ChatComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 12);
    ɵɵlistener("click", function ChatComponent_Conditional_2_Template_div_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.scrollToPinnedMessage());
    });
    ɵɵelement(1, "kendo-icon-wrapper", 13)(2, "chat-message-reference-content", 14)(3, "span", 15);
    ɵɵelementStart(4, "button", 16);
    ɵɵlistener("click", function ChatComponent_Conditional_2_Template_button_click_4_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.unpin.emit(ctx_r1.pinnedMessage));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r1.pinIcon);
    ɵɵadvance();
    ɵɵproperty("message", ctx_r1.pinnedMessage);
    ɵɵadvance(2);
    ɵɵproperty("svgIcon", ctx_r1.deleteIcon);
  }
}
function ChatComponent_Conditional_6_ng_template_1_Template(rf, ctx) {
}
function ChatComponent_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 7);
    ɵɵtemplate(1, ChatComponent_Conditional_6_ng_template_1_Template, 0, 0, "ng-template", 17);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.chatNoDataTemplate == null ? null : ctx_r1.chatNoDataTemplate.templateRef);
  }
}
function ChatComponent_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-chat-message-list", 18);
    ɵɵlistener("executeAction", function ChatComponent_Conditional_7_Template_kendo_chat_message_list_executeAction_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.dispatchAction($event));
    })("resize", function ChatComponent_Conditional_7_Template_kendo_chat_message_list_resize_0_listener() {
      ɵɵrestoreView(_r4);
      ɵɵnextContext();
      const anchor_r5 = ɵɵreference(5);
      return ɵɵresetView(anchor_r5.scrollToBottom());
    })("navigate", function ChatComponent_Conditional_7_Template_kendo_chat_message_list_navigate_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.autoScroll = false);
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("messages", ctx_r1.processedMessages)("authorMessageContentTemplate", ctx_r1.authorMessageContentTemplate)("receiverMessageContentTemplate", ctx_r1.receiverMessageContentTemplate)("messageContentTemplate", ctx_r1.messageContentTemplate)("authorMessageTemplate", ctx_r1.authorMessageTemplate)("receiverMessageTemplate", ctx_r1.receiverMessageTemplate)("messageTemplate", ctx_r1.messageTemplate)("timestampTemplate", ctx_r1.timestampTemplate)("statusTemplate", ctx_r1.statusTemplate)("userStatusTemplate", ctx_r1.userStatusTemplate)("localization", ctx_r1.localizationText)("attachmentTemplate", ctx_r1.attachmentTemplate)("authorId", ctx_r1.authorId);
  }
}
function HeroCardComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "img", 0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("src", ctx_r0.imageUrl, ɵɵsanitizeUrl);
  }
}
function HeroCardComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "h5", 2);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.title, " ");
  }
}
function HeroCardComponent_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "h6", 3);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.subtitle, " ");
  }
}
function HeroCardComponent_For_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 5)(1, "button", 6);
    ɵɵlistener("click", function HeroCardComponent_For_6_Template_button_click_1_listener() {
      const act_r3 = ɵɵrestoreView(_r2).$implicit;
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.onClick(act_r3));
    });
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const act_r3 = ctx.$implicit;
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", act_r3.title, " ");
  }
}
var _c223 = ["kendoContextMenu"];
var _c233 = (a0, a1) => ({
  "k-generating": a0,
  "k-active": a1
});
function InlineAIPromptContentComponent_Conditional_3_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 11);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.outputTemplate)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c314, ctx_r1.promptOutput));
  }
}
function InlineAIPromptContentComponent_Conditional_3_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵtextInterpolate1(" ", ctx_r1.promptOutput.output, " ");
  }
}
function InlineAIPromptContentComponent_Conditional_3_Conditional_4_For_2_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 14);
    ɵɵlistener("click", function InlineAIPromptContentComponent_Conditional_3_Conditional_4_For_2_Conditional_0_Template_button_click_0_listener() {
      ɵɵrestoreView(_r3);
      const action_r4 = ɵɵnextContext().$implicit;
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.onActionClick(action_r4));
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const action_r4 = ɵɵnextContext().$implicit;
    ɵɵproperty("fillMode", action_r4 == null ? null : action_r4.fillMode)("themeColor", action_r4 == null ? null : action_r4.themeColor)("rounded", action_r4 == null ? null : action_r4.rounded)("icon", action_r4 == null ? null : action_r4.icon)("svgIcon", action_r4 == null ? null : action_r4.svgIcon);
    ɵɵattribute("title", action_r4 == null ? null : action_r4.title);
    ɵɵadvance();
    ɵɵtextInterpolate(action_r4 == null ? null : action_r4.text);
  }
}
function InlineAIPromptContentComponent_Conditional_3_Conditional_4_For_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 13);
  }
}
function InlineAIPromptContentComponent_Conditional_3_Conditional_4_For_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, InlineAIPromptContentComponent_Conditional_3_Conditional_4_For_2_Conditional_0_Template, 2, 7, "button", 12);
    ɵɵconditionalCreate(1, InlineAIPromptContentComponent_Conditional_3_Conditional_4_For_2_Conditional_1_Template, 1, 0, "div", 13);
  }
  if (rf & 2) {
    const action_r4 = ctx.$implicit;
    ɵɵconditional(action_r4.type === "button" ? 0 : -1);
    ɵɵadvance();
    ɵɵconditional(action_r4.type === "spacer" ? 1 : -1);
  }
}
function InlineAIPromptContentComponent_Conditional_3_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-card-actions");
    ɵɵrepeaterCreate(1, InlineAIPromptContentComponent_Conditional_3_Conditional_4_For_2_Template, 2, 2, null, null, ɵɵrepeaterTrackByIdentity);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵrepeater(ctx_r1.outputActions);
  }
}
function InlineAIPromptContentComponent_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-card", 5)(1, "kendo-card-body");
    ɵɵconditionalCreate(2, InlineAIPromptContentComponent_Conditional_3_Conditional_2_Template, 1, 4, "ng-container", 11);
    ɵɵconditionalCreate(3, InlineAIPromptContentComponent_Conditional_3_Conditional_3_Template, 1, 1);
    ɵɵelementEnd();
    ɵɵconditionalCreate(4, InlineAIPromptContentComponent_Conditional_3_Conditional_4_Template, 3, 0, "kendo-card-actions");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵconditional(ctx_r1.outputTemplate ? 2 : -1);
    ɵɵadvance();
    ɵɵconditional(!ctx_r1.outputTemplate ? 3 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.outputActions && ctx_r1.outputActions.length > 0 ? 4 : -1);
  }
}
function InlineAIPromptContentComponent_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 15, 1);
    ɵɵlistener("click", function InlineAIPromptContentComponent_Conditional_6_Template_button_click_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onCommandButtonClick($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("svgIcon", ctx_r1.commandMenuIcon);
    ɵɵattribute("title", ctx_r1.messageFor("commandsButtonTitle"));
  }
}
function InlineAIPromptContentComponent_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 16);
    ɵɵlistener("result", function InlineAIPromptContentComponent_Conditional_7_Template_button_result_0_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleSpeechResult($event));
    })("start", function InlineAIPromptContentComponent_Conditional_7_Template_button_start_0_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.isListening = true);
    })("end", function InlineAIPromptContentComponent_Conditional_7_Template_button_end_0_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.isListening = false);
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵattribute("title", ctx_r1.messageFor("speechToTextButtonTitle"));
  }
}
var PreventableEvent6 = class {
  prevented = false;
  /**
   * Prevents the default action for a specified event.
   * In this way, the source component suppresses
   * the built-in behavior that follows the event.
   */
  preventDefault() {
    this.prevented = true;
  }
  /**
   * Returns `true` if the event was prevented
   * by any of its subscribers.
   *
   * @returns `true` if the default action was prevented.
   * Otherwise, returns `false`.
   */
  isDefaultPrevented() {
    return this.prevented;
  }
};
var ExecuteActionEvent = class extends PreventableEvent6 {
  /**
   * Represents the action to execute.
   */
  action;
  /**
   * Represents the message that contains the action.
   */
  message;
  /**
   * @hidden
   */
  constructor(action, message) {
    super();
    this.action = action;
    this.message = message;
  }
};
var SendMessageEvent = class {
  /**
   * Represents the message that contains the metadata and user input.
   *
   * The Chat does not automatically add the message to its data. For more information, see [Data Binding](slug:databinding_chat).
   */
  message;
  /**
   * @hidden
   */
  constructor(message) {
    this.message = message;
  }
};
var MY_TOKEN = new InjectionToken("COMMAND_TOKEN");
var DEFAULT_SVG_ICONS = {
  prompt: sparklesIcon,
  output: commentIcon,
  command: moreHorizontalIcon
};
var DEFAULT_ICONS = {
  prompt: "sparkles",
  output: "comment",
  command: "more-horizontal"
};
var BaseView = class _BaseView {
  viewType;
  localization;
  hostClasses = true;
  /**
   * @hidden
   */
  template;
  constructor(viewType, localization) {
    this.viewType = viewType;
    this.localization = localization;
    if (this.viewType !== "custom") {
      this.icon = DEFAULT_ICONS[this.viewType];
      this.svgIcon = DEFAULT_SVG_ICONS[this.viewType];
    }
  }
  /**
   * Sets the text for the Toolbar button of the current view.
   */
  set buttonText(value2) {
    this._buttonText = value2;
  }
  get buttonText() {
    return isPresent(this._buttonText) ? this._buttonText : this.messageFor(`${this.viewType}View`);
  }
  /**
   * Sets the font icon for the Toolbar button of the current view.
   */
  set icon(value2) {
    if (isPresent(value2)) {
      this._icon = value2;
    } else {
      this.icon = DEFAULT_ICONS[this.viewType];
    }
  }
  get icon() {
    return this._icon;
  }
  /**
   * Sets the SVG icon for the Toolbar button of the current view.
   */
  set svgIcon(value2) {
    if (isPresent(value2)) {
      this._svgIcon = value2;
    } else {
      this.svgIcon = DEFAULT_SVG_ICONS[this.viewType];
    }
  }
  get svgIcon() {
    return this._svgIcon;
  }
  /**
   * @hidden
   */
  messageFor(text) {
    return this.localization.get(text);
  }
  _buttonText;
  _icon;
  _svgIcon;
  static ɵfac = function BaseView_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BaseView)(ɵɵdirectiveInject(MY_TOKEN), ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _BaseView,
    viewQuery: function BaseView_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c08, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.template = _t.first);
      }
    },
    hostVars: 2,
    hostBindings: function BaseView_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-prompt-view", ctx.hostClasses);
      }
    },
    inputs: {
      buttonText: "buttonText",
      icon: "icon",
      svgIcon: "svgIcon"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BaseView, [{
    type: Directive
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [MY_TOKEN]
    }]
  }, {
    type: LocalizationService
  }], {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-prompt-view"]
    }],
    template: [{
      type: ViewChild,
      args: ["content", {
        static: true
      }]
    }],
    buttonText: [{
      type: Input
    }],
    icon: [{
      type: Input
    }],
    svgIcon: [{
      type: Input
    }]
  });
})();
var packageMetadata8 = {
  name: "@progress/kendo-angular-conversational-ui",
  productName: "Kendo UI for Angular",
  productCode: "KENDOUIANGULAR",
  productCodes: ["KENDOUIANGULAR"],
  publishDate: 0,
  version: "22.0.1",
  licensingDocsUrl: "https://www.telerik.com/kendo-angular-ui/my-license/"
};
var STB_DEFAULT_SETTINGS$1 = {
  continuous: false,
  disabled: false,
  fillMode: "flat",
  integrationMode: "webSpeech",
  interimResults: false,
  lang: "en-US",
  maxAlternatives: 1,
  rounded: "medium",
  size: "medium",
  themeColor: "base"
};
var AIPromptService = class _AIPromptService {
  aiPrompt;
  promptValue = "";
  showOutputRating = false;
  requestEvent = new Subject();
  executeEvent = new Subject();
  outputCopyEvent = new Subject();
  outputRatingChangeEvent = new Subject();
  promptCommands;
  promptOutputs;
  promptSuggestions;
  textAreaSettings;
  outputTemplate;
  outputBodyTemplate;
  _speechToTextButton;
  get speechToTextButton() {
    return this._speechToTextButton;
  }
  set speechToTextButton(settings) {
    if (settings === true) {
      this._speechToTextButton = STB_DEFAULT_SETTINGS$1;
    } else if (settings === false) {
      this._speechToTextButton = null;
    } else {
      this._speechToTextButton = __spreadValues({}, settings);
    }
  }
  getFlattenPromptCommands(commands = this.promptCommands) {
    let newArr = [];
    commands.forEach((c) => {
      if (c.hasOwnProperty("children")) {
        const childrenArr = c.children;
        newArr = newArr.concat(childrenArr);
        if (childrenArr.length > 0) {
          this.getFlattenPromptCommands(childrenArr);
        }
      }
    });
    return newArr.concat(this.promptCommands);
  }
  static ɵfac = function AIPromptService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AIPromptService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _AIPromptService,
    factory: _AIPromptService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AIPromptService, [{
    type: Injectable
  }], null, null);
})();
var AIPromptToolbarActionsDirective = class _AIPromptToolbarActionsDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function AIPromptToolbarActionsDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AIPromptToolbarActionsDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _AIPromptToolbarActionsDirective,
    selectors: [["", "kendoAIPromptToolbarActionsTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AIPromptToolbarActionsDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoAIPromptToolbarActionsTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var ToolbarNavigationService = class _ToolbarNavigationService {
  localizationService;
  focusableElements = [];
  currentFocusedIndex = 0;
  constructor(localizationService) {
    this.localizationService = localizationService;
  }
  register(tool) {
    if (!this.focusableElements.some((el) => el === tool)) {
      this.focusableElements.push(tool);
    }
  }
  unregister(tool) {
    this.currentFocusedIndex = 0;
    this.focusableElements = this.focusableElements.filter((el) => el !== tool);
  }
  isActive(focusable) {
    return this.focusableElements[this.currentFocusedIndex] === focusable;
  }
  setActiveIndex(tool) {
    this.currentFocusedIndex = Math.max(this.focusableElements.indexOf(tool), 0);
  }
  move(direction) {
    let delta = direction === "right" ? 1 : -1;
    if (this.localizationService.rtl) {
      delta = -delta;
    }
    this.currentFocusedIndex += delta;
    if (this.currentFocusedIndex < 0) {
      this.currentFocusedIndex = this.focusableElements.length - 1;
    } else if (this.currentFocusedIndex >= this.focusableElements.length) {
      this.currentFocusedIndex = 0;
    }
    this.focusableElements[this.currentFocusedIndex].activate();
  }
  focusFirst() {
    this.focusableElements[this.currentFocusedIndex].activate();
  }
  static ɵfac = function ToolbarNavigationService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ToolbarNavigationService)(ɵɵinject(LocalizationService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ToolbarNavigationService,
    factory: _ToolbarNavigationService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ToolbarNavigationService, [{
    type: Injectable
  }], () => [{
    type: LocalizationService
  }], null);
})();
var AIPromptToolbarFocusableDirective = class _AIPromptToolbarFocusableDirective {
  host;
  navigationService;
  renderer;
  constructor(host, navigationService, renderer) {
    this.host = host;
    this.navigationService = navigationService;
    this.renderer = renderer;
    navigationService.register(this);
  }
  get element() {
    return this.host.nativeElement;
  }
  ngAfterViewInit() {
    this.renderer.setAttribute(this.element, "tabindex", this.navigationService.isActive(this) ? "0" : "-1");
    this.element.addEventListener("keydown", this.keyDownHandler, {
      capture: true
    });
    this.element.addEventListener("click", this.clickHandler, {
      capture: true
    });
  }
  ngOnDestroy() {
    this.navigationService.unregister(this);
    this.element.removeEventListener("keydown", this.keyDownHandler, {
      capture: true
    });
    this.element.removeEventListener("click", this.clickHandler, {
      capture: true
    });
  }
  activate() {
    this.renderer.setAttribute(this.element, "tabindex", "0");
    this.element.focus();
  }
  keyDownHandler = (e) => {
    const code = normalizeKeys(e);
    const targetsSelf = e.target === this.element;
    const isLeftArrow = code === Keys.ArrowLeft;
    const isRightArrow = code === Keys.ArrowRight;
    const isArrow = isLeftArrow || isRightArrow;
    if (!targetsSelf || !isArrow) {
      return;
    }
    this.renderer.setAttribute(this.element, "tabindex", "-1");
    this.element.querySelectorAll(focusableSelector).forEach((el) => {
      this.renderer.setAttribute(el, "tabindex", "-1");
    });
    if (isRightArrow) {
      this.navigationService.move("right");
    } else if (isLeftArrow) {
      this.navigationService.move("left");
    }
  };
  clickHandler = () => {
    this.navigationService.setActiveIndex(this);
  };
  static ɵfac = function AIPromptToolbarFocusableDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AIPromptToolbarFocusableDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ToolbarNavigationService), ɵɵdirectiveInject(Renderer2));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _AIPromptToolbarFocusableDirective,
    selectors: [["", "kendoAIPromptToolbarFocusable", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AIPromptToolbarFocusableDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoAIPromptToolbarFocusable]",
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: ToolbarNavigationService
  }, {
    type: Renderer2
  }], null);
})();
var Messages$2 = class Messages5 extends ComponentMessages {
  /**
   * Sets the Toolbar button text for the **Prompt** view.
   */
  promptView;
  /**
   * Sets the Toolbar button text for the **Output** view.
   */
  outputView;
  /**
   * Sets the text for the **Generate** button in the **Prompt** view.
   */
  generateOutput;
  /**
   * Sets the placeholder text for the **Prompt** view text area.
   */
  promptPlaceholder;
  /**
   * Sets the text for the **Copy** button text in each **Output** view card.
   */
  copyOutput;
  /**
   * Sets the **Retry** button text in each **Output** view card.
   */
  retryGeneration;
  /**
   * Sets the title of each card in the **Output** view.
   */
  outputTitle;
  /**
   * Sets the title of each retry card in the **Output** view.
   */
  outputRetryTitle;
  /**
   * Sets the title of the **Prompt suggestions** button.
   */
  promptSuggestions;
  /**
   * Sets the aria-label for the **Speech to Text** button.
   */
  speechToTextButton;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵMessages_BaseFactory;
    return function Messages_Factory(__ngFactoryType__) {
      return (ɵMessages_BaseFactory || (ɵMessages_BaseFactory = ɵɵgetInheritedFactory(Messages5)))(__ngFactoryType__ || Messages5);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: Messages5,
    inputs: {
      promptView: "promptView",
      outputView: "outputView",
      generateOutput: "generateOutput",
      promptPlaceholder: "promptPlaceholder",
      copyOutput: "copyOutput",
      retryGeneration: "retryGeneration",
      outputTitle: "outputTitle",
      outputRetryTitle: "outputRetryTitle",
      promptSuggestions: "promptSuggestions",
      speechToTextButton: "speechToTextButton"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Messages$2, [{
    type: Directive
  }], null, {
    promptView: [{
      type: Input
    }],
    outputView: [{
      type: Input
    }],
    generateOutput: [{
      type: Input
    }],
    promptPlaceholder: [{
      type: Input
    }],
    copyOutput: [{
      type: Input
    }],
    retryGeneration: [{
      type: Input
    }],
    outputTitle: [{
      type: Input
    }],
    outputRetryTitle: [{
      type: Input
    }],
    promptSuggestions: [{
      type: Input
    }],
    speechToTextButton: [{
      type: Input
    }]
  });
})();
var LocalizedMessagesDirective$2 = class LocalizedMessagesDirective4 extends Messages$2 {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function LocalizedMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || LocalizedMessagesDirective4)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: LocalizedMessagesDirective4,
    selectors: [["", "kendoAIPromptLocalizedMessages", ""]],
    features: [ɵɵProvidersFeature([{
      provide: Messages$2,
      useExisting: forwardRef(() => LocalizedMessagesDirective4)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalizedMessagesDirective$2, [{
    type: Directive,
    args: [{
      providers: [{
        provide: Messages$2,
        useExisting: forwardRef(() => LocalizedMessagesDirective$2)
      }],
      selector: "[kendoAIPromptLocalizedMessages]",
      standalone: true
    }]
  }], () => [{
    type: LocalizationService
  }], null);
})();
var AIPromptOutputTemplateDirective = class _AIPromptOutputTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function AIPromptOutputTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AIPromptOutputTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _AIPromptOutputTemplateDirective,
    selectors: [["", "kendoAIPromptOutputTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AIPromptOutputTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoAIPromptOutputTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var AIPromptOutputBodyTemplateDirective = class _AIPromptOutputBodyTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function AIPromptOutputBodyTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AIPromptOutputBodyTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _AIPromptOutputBodyTemplateDirective,
    selectors: [["", "kendoAIPromptOutputBodyTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AIPromptOutputBodyTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoAIPromptOutputBodyTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var AIPromptComponent = class _AIPromptComponent {
  localization;
  service;
  navigationService;
  ngZone;
  element;
  renderer;
  hostClasses = true;
  get dirAttr() {
    return this.direction;
  }
  constructor(localization, service, navigationService, ngZone, element, renderer) {
    this.localization = localization;
    this.service = service;
    this.navigationService = navigationService;
    this.ngZone = ngZone;
    this.element = element;
    this.renderer = renderer;
    N(packageMetadata8);
    this.direction = localization.rtl ? "rtl" : "ltr";
    this.subs.add(localization.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
    }));
  }
  /**
   * @hidden
   */
  fabButton;
  /**
   * @hidden
   */
  views;
  /**
   * @hidden
   */
  toolbarActionsTemplate;
  /**
   * @hidden
   */
  outputTemplate;
  /**
   * @hidden
   */
  outputBodyTemplate;
  /**
   * The active view index of the AIPrompt component.
   */
  set activeView(idx4) {
    if (this._activeView !== idx4) {
      this._activeView = idx4;
      if (this.service.promptValue) {
        this.service.promptValue = "";
      }
    }
  }
  get activeView() {
    return this._activeView;
  }
  /**
   * Sets the collection of commands to render in the Command view.
   */
  set promptCommands(value2) {
    this.service.promptCommands = value2;
  }
  /**
   * Sets the collection of suggestions to render in the Prompt view.
   */
  set promptSuggestions(value2) {
    this.service.promptSuggestions = value2;
  }
  /**
   * Sets the collection of generated prompt outputs to render in the Output view.
   */
  set promptOutputs(value2) {
    this.service.promptOutputs = value2;
  }
  /**
   * Specifies whether the rating buttons appear in each Output view card.
   * The rating buttons do not appear by default.
   * @default false
   */
  set showOutputRating(value2) {
    this.service.showOutputRating = value2;
  }
  /**
   * Specifies whether the Stop generation button appears in the Output view.
   * The Stop generation button does not appear by default.
   * @default false
   */
  streaming = false;
  /**
   * Sets the settings for the Speech to Text button in the Prompt view
   * ([see example](slug:configuration_aiprompt#enabling-speech-to-text)).
   */
  set speechToTextButton(settings) {
    if (settings) {
      this.service.speechToTextButton = settings;
    } else {
      this.service.speechToTextButton = false;
    }
  }
  /**
   * Sets the settings for the TextArea in the Prompt view
   * ([see example](slug:configuration_aiprompt#configuring-the-prompt-text-area)).
   */
  set textAreaSettings(settings) {
    this.service.textAreaSettings = settings;
  }
  /**
   * Sets the SVG icon for the Generate button in the Prompt view.
   */
  generateButtonSVGIcon = sparklesIcon;
  /**
   * Sets the icon for the Generate button in the Prompt view.
   * @default 'sparkles'
   */
  generateButtonIcon = "sparkles";
  /**
   * Sets the disabled state for the Generate button in the Prompt view.
   * @default false
   */
  disabledGenerateButton = false;
  /**
   * Fires when the `activeView` property is updated.
   * Use this event for two-way binding of the `activeView` property.
   */
  activeViewChange = new EventEmitter();
  /**
   * Fires when you click the Generate button in the Prompt view or the Retry button in the Output view.
   * Use the event's `isRetry` field to determine the source element.
   */
  promptRequest = new EventEmitter();
  /**
   * Fires when you click a Command view command.
   * The event data contains the selected command.
   */
  commandExecute = new EventEmitter();
  /**
   * Fires when you click a Copy button in any Output view card.
   */
  outputCopy = new EventEmitter();
  /**
   * Fires when you click a rating button in any Output view card.
   */
  outputRatingChange = new EventEmitter();
  /**
   * Fires when you click the Stop Generation button in the Output view.
   */
  promptRequestCancel = new EventEmitter();
  ngOnInit() {
    const aiPromptElement = this.element.nativeElement;
    this.subs.add(this.renderer.listen(aiPromptElement, "keydown", (event) => {
      if (event.key === "Escape") {
        this.promptRequestCancel.emit();
      }
    }));
  }
  ngOnChanges(changes) {
    if (changes["streaming"] && changes["streaming"].currentValue === true) {
      this.ngZone.onStable.pipe(take(1)).subscribe(() => {
        this.fabButton?.focus();
      });
    }
  }
  ngAfterContentChecked() {
    if (this.outputTemplate !== this.service.outputTemplate) {
      this.service.outputTemplate = this.outputTemplate;
    }
    if (this.outputBodyTemplate !== this.service.outputBodyTemplate) {
      this.service.outputBodyTemplate = this.outputBodyTemplate;
    }
  }
  ngAfterViewInit() {
    this.ngZone.runOutsideAngular(() => {
      this.service.aiPrompt = this;
      this.subs.add(this.service.requestEvent.subscribe((ev) => this.promptRequest.emit(ev)));
      this.subs.add(this.service.executeEvent.subscribe((ev) => this.commandExecute.emit(ev)));
      this.subs.add(this.service.outputCopyEvent.subscribe((ev) => this.outputCopy.emit(ev)));
      this.subs.add(this.service.outputRatingChangeEvent.subscribe((ev) => this.outputRatingChange.emit(ev)));
    });
  }
  ngOnDestroy() {
    this.subs.unsubscribe();
  }
  /**
   * Focuses the first focusable element in the AIPrompt component.
   */
  focus() {
    this.navigationService.focusFirst();
  }
  subs = new Subscription();
  /**
   * @hidden
   */
  get selectedView() {
    return this.viewsArray[this.activeView];
  }
  /**
   * @hidden
   */
  sparklesIcon = sparklesIcon;
  /**
   * @hidden
   */
  outputIcon = commentIcon;
  /**
   * @hidden
   */
  fabStopGenerationSVGIcon = stopSmIcon;
  /**
   * @hidden
   */
  get viewsArray() {
    return this.views?.toArray();
  }
  /**
   * @hidden
   */
  fabPositionMode = "absolute";
  /**
   * @hidden
   */
  fabAlignment = {
    vertical: "bottom",
    horizontal: "end"
  };
  direction;
  _activeView = 0;
  /**
   * @hidden
   */
  viewChange(idx4) {
    if (idx4 !== this.activeView) {
      this.activeView = idx4;
      this.activeViewChange.emit(idx4);
    }
  }
  /**
   * @hidden
   */
  messageFor(text) {
    return this.localization.get(text);
  }
  /**
   * @hidden
   */
  get viewTemplate() {
    return this.selectedView?.viewType === "custom" ? this.selectedView?.viewTemplate : this.selectedView?.template;
  }
  /**
   * @hidden
   */
  handleGenerateOutput() {
    const value2 = this.service.promptValue;
    const eventArgs = {
      prompt: value2,
      sender: this,
      isRetry: false
    };
    this.promptRequest.emit(eventArgs);
  }
  static ɵfac = function AIPromptComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AIPromptComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(AIPromptService), ɵɵdirectiveInject(ToolbarNavigationService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _AIPromptComponent,
    selectors: [["kendo-aiprompt"]],
    contentQueries: function AIPromptComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, AIPromptToolbarActionsDirective, 5)(dirIndex, AIPromptOutputTemplateDirective, 5)(dirIndex, AIPromptOutputBodyTemplateDirective, 5)(dirIndex, BaseView, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.toolbarActionsTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.outputTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.outputBodyTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.views = _t);
      }
    },
    viewQuery: function AIPromptComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c115, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.fabButton = _t.first);
      }
    },
    hostVars: 3,
    hostBindings: function AIPromptComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.dirAttr);
        ɵɵclassProp("k-prompt", ctx.hostClasses);
      }
    },
    inputs: {
      activeView: "activeView",
      promptCommands: "promptCommands",
      promptSuggestions: "promptSuggestions",
      promptOutputs: "promptOutputs",
      showOutputRating: "showOutputRating",
      streaming: "streaming",
      speechToTextButton: "speechToTextButton",
      textAreaSettings: "textAreaSettings",
      generateButtonSVGIcon: "generateButtonSVGIcon",
      generateButtonIcon: "generateButtonIcon",
      disabledGenerateButton: "disabledGenerateButton"
    },
    outputs: {
      activeViewChange: "activeViewChange",
      promptRequest: "promptRequest",
      commandExecute: "commandExecute",
      outputCopy: "outputCopy",
      outputRatingChange: "outputRatingChange",
      promptRequestCancel: "promptRequestCancel"
    },
    exportAs: ["kendoAIPrompt"],
    features: [ɵɵProvidersFeature([LocalizationService, AIPromptService, ToolbarNavigationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.aiprompt"
    }]), ɵɵNgOnChangesFeature],
    decls: 11,
    vars: 4,
    consts: () => {
      let i18n_0;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_0 = goog.getMsg("Ask AI");
        i18n_0 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_0;
      } else {
        i18n_0 = $localize`:kendo.aiprompt.promptView|The Toolbar button text for the Prompt view.:Ask AI`;
      }
      let i18n_1;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_1 = goog.getMsg("Output");
        i18n_1 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_1;
      } else {
        i18n_1 = $localize`:kendo.aiprompt.outputView|The Toolbar button text for the Output view.:Output`;
      }
      let i18n_2;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_2 = goog.getMsg("Generate");
        i18n_2 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_2;
      } else {
        i18n_2 = $localize`:kendo.aiprompt.generateOutput|The text for the Generate button in the Prompt view.:Generate`;
      }
      let i18n_3;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_3 = goog.getMsg("Ask or generate content with AI");
        i18n_3 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_3;
      } else {
        i18n_3 = $localize`:kendo.aiprompt.promptPlaceholder|The placeholder text for the Prompt View text area.:Ask or generate content with AI`;
      }
      let i18n_4;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_4 = goog.getMsg("Copy");
        i18n_4 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_4;
      } else {
        i18n_4 = $localize`:kendo.aiprompt.copyOutput|The Copy button text in each Output view card.:Copy`;
      }
      let i18n_5;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_5 = goog.getMsg("Retry");
        i18n_5 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_5;
      } else {
        i18n_5 = $localize`:kendo.aiprompt.retryGeneration|The Retry button text in each Output view card.:Retry`;
      }
      let i18n_6;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_6 = goog.getMsg("Generated with AI");
        i18n_6 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_6;
      } else {
        i18n_6 = $localize`:kendo.aiprompt.outputTitle|The title of each Output view card.:Generated with AI`;
      }
      let i18n_7;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_7 = goog.getMsg("Generated with AI");
        i18n_7 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_7;
      } else {
        i18n_7 = $localize`:kendo.aiprompt.outputRetryTitle|The title of each Output view retry card.:Generated with AI`;
      }
      let i18n_8;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_8 = goog.getMsg("Prompt suggestions");
        i18n_8 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_8;
      } else {
        i18n_8 = $localize`:kendo.aiprompt.promptSuggestions|The title of the Prompt suggestions button.:Prompt suggestions`;
      }
      let i18n_9;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_9 = goog.getMsg("Voice input");
        i18n_9 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_9;
      } else {
        i18n_9 = $localize`:kendo.aiprompt.speechToTextButton|The aria-label for the Speech to Text button.:Voice input`;
      }
      return [["fabButton", ""], ["kendoAIPromptLocalizedMessages", "", "promptView", i18n_0, "outputView", i18n_1, "generateOutput", i18n_2, "promptPlaceholder", i18n_3, "copyOutput", i18n_4, "retryGeneration", i18n_5, "outputTitle", i18n_6, "outputRetryTitle", i18n_7, "promptSuggestions", i18n_8, "speechToTextButton", i18n_9], [1, "k-prompt-header"], ["role", "toolbar", 1, "k-toolbar-flat", "k-toolbar", "k-toolbar-md"], ["kendoButton", "", "kendoAIPromptToolbarFocusable", "", "type", "button", "fillMode", "flat", "rounded", "full", "themeColor", "primary", 3, "svgIcon", "icon", "selected"], [3, "ngTemplateOutlet"], [1, "k-prompt-content"], ["buttonClass", "k-generating k-active", "icon", "stop", 1, "k-prompt-stop-fab", 3, "positionMode", "align", "svgIcon"], [1, "k-prompt-view"], [4, "ngTemplateOutlet"], [1, "k-prompt-footer"], ["kendoButton", "", "kendoAIPromptToolbarFocusable", "", "type", "button", "fillMode", "flat", "rounded", "full", "themeColor", "primary", 3, "click", "svgIcon", "icon", "selected"], ["buttonClass", "k-generating k-active", "icon", "stop", 1, "k-prompt-stop-fab", 3, "click", "positionMode", "align", "svgIcon"], [1, "k-actions", "k-actions-start", "k-actions-horizontal", "k-prompt-actions"], ["kendoButton", "", "type", "button", "themeColor", "primary", "rounded", "full", 3, "click", "svgIcon", "icon", "disabled"]];
    },
    template: function AIPromptComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainer(0, 1);
        ɵɵelementStart(1, "div", 2)(2, "div", 3);
        ɵɵrepeaterCreate(3, AIPromptComponent_For_4_Template, 2, 4, "button", 4, ɵɵrepeaterTrackByIdentity);
        ɵɵconditionalCreate(5, AIPromptComponent_Conditional_5_Template, 1, 1, null, 5);
        ɵɵelementEnd()();
        ɵɵelementStart(6, "div", 6);
        ɵɵconditionalCreate(7, AIPromptComponent_Conditional_7_Template, 2, 3, "kendo-floatingactionbutton", 7);
        ɵɵelementStart(8, "div", 8);
        ɵɵtemplate(9, AIPromptComponent_ng_container_9_Template, 1, 0, "ng-container", 9);
        ɵɵelementEnd()();
        ɵɵconditionalCreate(10, AIPromptComponent_Conditional_10_Template, 4, 7, "div", 10);
      }
      if (rf & 2) {
        ɵɵadvance(3);
        ɵɵrepeater(ctx.viewsArray);
        ɵɵadvance(2);
        ɵɵconditional(ctx.toolbarActionsTemplate ? 5 : -1);
        ɵɵadvance(2);
        ɵɵconditional(ctx.streaming && (ctx.selectedView == null ? null : ctx.selectedView.viewType) === "output" ? 7 : -1);
        ɵɵadvance(2);
        ɵɵproperty("ngTemplateOutlet", ctx.viewTemplate);
        ɵɵadvance();
        ɵɵconditional((ctx.selectedView == null ? null : ctx.selectedView.viewType) === "prompt" ? 10 : -1);
      }
    },
    dependencies: [LocalizedMessagesDirective$2, ButtonComponent, AIPromptToolbarFocusableDirective, NgTemplateOutlet, FloatingActionButtonComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AIPromptComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoAIPrompt",
      selector: "kendo-aiprompt",
      providers: [LocalizationService, AIPromptService, ToolbarNavigationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.aiprompt"
      }],
      template: `
        <ng-container kendoAIPromptLocalizedMessages
          i18n-promptView="kendo.aiprompt.promptView|The Toolbar button text for the Prompt view."
          promptView="Ask AI"
          i18n-outputView="kendo.aiprompt.outputView|The Toolbar button text for the Output view."
          outputView="Output"
          i18n-generateOutput="kendo.aiprompt.generateOutput|The text for the Generate button in the Prompt view."
          generateOutput="Generate"
          i18n-promptPlaceholder="kendo.aiprompt.promptPlaceholder|The placeholder text for the Prompt View text area."
          promptPlaceholder="Ask or generate content with AI"
          i18n-copyOutput="kendo.aiprompt.copyOutput|The Copy button text in each Output view card."
          copyOutput="Copy"
          i18n-retryGeneration="kendo.aiprompt.retryGeneration|The Retry button text in each Output view card."
          retryGeneration="Retry"
          i18n-outputTitle="kendo.aiprompt.outputTitle|The title of each Output view card."
          outputTitle="Generated with AI"
          i18n-outputRetryTitle="kendo.aiprompt.outputRetryTitle|The title of each Output view retry card."
          outputRetryTitle="Generated with AI"
          i18n-promptSuggestions="kendo.aiprompt.promptSuggestions|The title of the Prompt suggestions button."
          promptSuggestions="Prompt suggestions"
          i18n-speechToTextButton="kendo.aiprompt.speechToTextButton|The aria-label for the Speech to Text button."
          speechToTextButton="Voice input">
        </ng-container>
        <div class="k-prompt-header">
          <div class="k-toolbar-flat k-toolbar k-toolbar-md"
            role="toolbar">
            @for (view of viewsArray; track view; let idx = $index) {
              <button
                kendoButton
                kendoAIPromptToolbarFocusable
                type="button"
                fillMode="flat"
                rounded="full"
                themeColor="primary"
                [svgIcon]="view.svgIcon"
                [icon]="view.icon"
                [selected]="idx === activeView"
                (click)="viewChange(idx)">
                {{view.buttonText}}
              </button>
            }
        
            @if (toolbarActionsTemplate) {
              <ng-template
                [ngTemplateOutlet]="toolbarActionsTemplate?.templateRef">
              </ng-template>
            }
          </div>
        </div>
        <div class="k-prompt-content">
          @if (streaming && selectedView?.viewType === 'output') {
            <kendo-floatingactionbutton #fabButton
              class="k-prompt-stop-fab"
              buttonClass="k-generating k-active"
              [positionMode]="fabPositionMode"
              [align]="fabAlignment"
              [svgIcon]="fabStopGenerationSVGIcon"
              icon="stop"
              (click)="promptRequestCancel.emit()"
              >
            </kendo-floatingactionbutton>
          }
          <div class="k-prompt-view">
            <ng-container *ngTemplateOutlet="viewTemplate">
            </ng-container>
          </div>
        </div>
        @if (selectedView?.viewType === 'prompt') {
          <div class="k-prompt-footer">
            <div class="k-actions k-actions-start k-actions-horizontal k-prompt-actions">
              <button
                kendoButton
                type="button"
                themeColor="primary"
                rounded="full"
                [attr.title]="messageFor('generateOutput')"
                [attr.aria-label]="messageFor('generateOutput')"
                [attr.aria-disabled]="disabledGenerateButton"
                [svgIcon]="generateButtonSVGIcon"
                [icon]="generateButtonIcon"
                [disabled]="disabledGenerateButton"
              (click)="handleGenerateOutput()">{{messageFor('generateOutput')}}</button>
            </div>
          </div>
        }
        `,
      standalone: true,
      imports: [LocalizedMessagesDirective$2, ButtonComponent, AIPromptToolbarFocusableDirective, NgTemplateOutlet, FloatingActionButtonComponent]
    }]
  }], () => [{
    type: LocalizationService
  }, {
    type: AIPromptService
  }, {
    type: ToolbarNavigationService
  }, {
    type: NgZone
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }], {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-prompt"]
    }],
    dirAttr: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    fabButton: [{
      type: ViewChild,
      args: ["fabButton"]
    }],
    views: [{
      type: ContentChildren,
      args: [BaseView]
    }],
    toolbarActionsTemplate: [{
      type: ContentChild,
      args: [AIPromptToolbarActionsDirective]
    }],
    outputTemplate: [{
      type: ContentChild,
      args: [AIPromptOutputTemplateDirective]
    }],
    outputBodyTemplate: [{
      type: ContentChild,
      args: [AIPromptOutputBodyTemplateDirective]
    }],
    activeView: [{
      type: Input
    }],
    promptCommands: [{
      type: Input
    }],
    promptSuggestions: [{
      type: Input
    }],
    promptOutputs: [{
      type: Input
    }],
    showOutputRating: [{
      type: Input
    }],
    streaming: [{
      type: Input
    }],
    speechToTextButton: [{
      type: Input
    }],
    textAreaSettings: [{
      type: Input
    }],
    generateButtonSVGIcon: [{
      type: Input
    }],
    generateButtonIcon: [{
      type: Input
    }],
    disabledGenerateButton: [{
      type: Input
    }],
    activeViewChange: [{
      type: Output
    }],
    promptRequest: [{
      type: Output
    }],
    commandExecute: [{
      type: Output
    }],
    outputCopy: [{
      type: Output
    }],
    outputRatingChange: [{
      type: Output
    }],
    promptRequestCancel: [{
      type: Output
    }]
  });
})();
var CommandViewComponent = class _CommandViewComponent extends BaseView {
  service;
  constructor(localization, service) {
    super("command", localization);
    this.service = service;
  }
  /**
   * @hidden
   */
  panelBarItems = [];
  ngOnInit() {
    if (this.service.promptCommands) {
      this.panelBarItems = this.getPanelBarItems(this.service.promptCommands);
    }
  }
  /**
   * @hidden
   */
  itemClickHandler(ev) {
    if (ev.item.children) {
      return;
    }
    const selectedCommand = this.service.getFlattenPromptCommands().find((c) => c.id == ev.item.id);
    if (selectedCommand) {
      const eventArgs = {
        command: selectedCommand,
        sender: this.service.aiPrompt,
        isRetry: false
      };
      this.service.executeEvent.next(eventArgs);
    }
  }
  getPanelBarItems(commands) {
    return commands.map((c) => ({
      title: c.text,
      id: c.id,
      icon: c.icon,
      svgIcon: c.svgIcon,
      children: c.children ? this.getPanelBarItems(c.children) : null
    }));
  }
  static ɵfac = function CommandViewComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CommandViewComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(AIPromptService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _CommandViewComponent,
    selectors: [["kendo-aiprompt-command-view"]],
    features: [ɵɵProvidersFeature([{
      provide: BaseView,
      useExisting: forwardRef(() => _CommandViewComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 2,
    vars: 0,
    consts: [["content", ""], [3, "itemClick", "items", "animate", "selectable"]],
    template: function CommandViewComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, CommandViewComponent_ng_template_0_Template, 1, 3, "ng-template", null, 0, ɵɵtemplateRefExtractor);
      }
    },
    dependencies: [PanelBarComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CommandViewComponent, [{
    type: Component,
    args: [{
      selector: "kendo-aiprompt-command-view",
      providers: [{
        provide: BaseView,
        useExisting: forwardRef(() => CommandViewComponent)
      }],
      template: `
        <ng-template #content>
            <kendo-panelbar
                [items]="panelBarItems"
                [animate]="false"
                [selectable]="false"
                (itemClick)="itemClickHandler($event)"
            ></kendo-panelbar>
        </ng-template>
    `,
      standalone: true,
      imports: [PanelBarComponent]
    }]
  }], () => [{
    type: LocalizationService
  }, {
    type: AIPromptService
  }], null);
})();
var AIPromptCustomMessagesComponent = class _AIPromptCustomMessagesComponent extends Messages$2 {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function AIPromptCustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AIPromptCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _AIPromptCustomMessagesComponent,
    selectors: [["kendo-aiprompt-messages"]],
    features: [ɵɵProvidersFeature([{
      provide: Messages$2,
      useExisting: forwardRef(() => _AIPromptCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function AIPromptCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AIPromptCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: Messages$2,
        useExisting: forwardRef(() => AIPromptCustomMessagesComponent)
      }],
      selector: "kendo-aiprompt-messages",
      template: ``,
      standalone: true
    }]
  }], () => [{
    type: LocalizationService
  }], null);
})();
var CustomViewComponent = class _CustomViewComponent extends BaseView {
  constructor(localization) {
    super("custom", localization);
  }
  /**
   * Sets the content of the Custom view as a template reference.
   */
  viewTemplate;
  static ɵfac = function CustomViewComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CustomViewComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _CustomViewComponent,
    selectors: [["kendo-aiprompt-custom-view"]],
    inputs: {
      viewTemplate: "viewTemplate"
    },
    features: [ɵɵProvidersFeature([{
      provide: BaseView,
      useExisting: forwardRef(() => _CustomViewComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function CustomViewComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CustomViewComponent, [{
    type: Component,
    args: [{
      selector: "kendo-aiprompt-custom-view",
      providers: [{
        provide: BaseView,
        useExisting: forwardRef(() => CustomViewComponent)
      }],
      template: ``,
      standalone: true
    }]
  }], () => [{
    type: LocalizationService
  }], {
    viewTemplate: [{
      type: Input
    }]
  });
})();
var AIPromptOutputCardComponent = class _AIPromptOutputCardComponent {
  localization;
  service;
  hostClass = true;
  listItemRole = "listitem";
  tabIndex = 0;
  get ariaDescribedBy() {
    return this.titleId;
  }
  ariaKeyShortcuts = "Enter";
  promptOutput;
  constructor(localization, service) {
    this.localization = localization;
    this.service = service;
  }
  ngOnInit() {
    if (this.promptOutput?.rating === "positive") {
      this.positiveRatingIcon = thumbUpIcon;
      this.negativeRatingIcon = thumbDownOutlineIcon;
    } else if (this.promptOutput?.rating === "negative") {
      this.negativeRatingIcon = thumbDownIcon;
      this.positiveRatingIcon = thumbUpOutlineIcon;
    }
  }
  copyIcon = copyIcon;
  retryIcon = arrowRotateCwIcon;
  positiveRatingIcon = thumbUpOutlineIcon;
  negativeRatingIcon = thumbDownOutlineIcon;
  titleId = `k-output-card-${guid()}`;
  messageFor(text) {
    return this.localization.get(text);
  }
  get showRating() {
    return this.service.showOutputRating;
  }
  get outputTitle() {
    if (isPresent(this.promptOutput.title)) {
      return this.promptOutput.title;
    } else {
      const titleMessage = this.promptOutput.isRetry ? "outputRetryTitle" : "outputTitle";
      return this.messageFor(titleMessage);
    }
  }
  handleRetry() {
    if (this.promptOutput.commandId) {
      const eventArgs = {
        command: this.service.getFlattenPromptCommands().find((c) => c.id === this.promptOutput.commandId),
        sender: this.service.aiPrompt,
        isRetry: true
      };
      this.service.executeEvent.next(eventArgs);
    } else {
      const eventArgs = {
        prompt: this.promptOutput.prompt,
        sender: this.service.aiPrompt,
        isRetry: true
      };
      this.service.requestEvent.next(eventArgs);
    }
  }
  handleCopy() {
    navigator.clipboard.writeText(this.promptOutput.output);
    this.service.outputCopyEvent.next(this.promptOutput);
  }
  handleRating(ratingType) {
    const eventArgs = {
      promptOutput: this.promptOutput,
      rating: ratingType
    };
    this.service.outputRatingChangeEvent.next(eventArgs);
    if (ratingType === "positive") {
      this.positiveRatingIcon = thumbUpIcon;
      this.negativeRatingIcon = thumbDownOutlineIcon;
    } else {
      this.negativeRatingIcon = thumbDownIcon;
      this.positiveRatingIcon = thumbUpOutlineIcon;
    }
  }
  /**
   * @hidden
   */
  get customBodyTemplate() {
    return this.service.outputBodyTemplate?.templateRef;
  }
  static ɵfac = function AIPromptOutputCardComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AIPromptOutputCardComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(AIPromptService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _AIPromptOutputCardComponent,
    selectors: [["", "kendoAIPromptOutputCard", ""]],
    hostVars: 6,
    hostBindings: function AIPromptOutputCardComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("role", ctx.listItemRole)("tabindex", ctx.tabIndex)("aria-describedby", ctx.ariaDescribedBy)("aria-keyshortcuts", ctx.ariaKeyShortcuts);
        ɵɵclassProp("k-card", ctx.hostClass);
      }
    },
    inputs: {
      promptOutput: "promptOutput"
    },
    attrs: _c215,
    decls: 14,
    vars: 9,
    consts: [[1, "k-card-header"], [1, "k-card-title"], [1, "k-card-subtitle"], [1, "k-card-body"], [1, "k-actions", "k-actions-start", "k-actions-horizontal", "k-card-actions"], ["kendoButton", "", "fillMode", "flat", "themeColor", "primary", "rounded", "full", "icon", "copy", 3, "click", "svgIcon"], ["kendoButton", "", "fillMode", "flat", "rounded", "full", "icon", "arrow-rotate-cw", 3, "click", "svgIcon"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "k-spacer"], ["kendoButton", "", "fillMode", "flat", "icon", "thumb-up-outline", 3, "click", "svgIcon"], ["kendoButton", "", "fillMode", "flat", "icon", "thumb-down-outline", 3, "click", "svgIcon"]],
    template: function AIPromptOutputCardComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 0)(1, "div", 1);
        ɵɵtext(2);
        ɵɵelementEnd();
        ɵɵelementStart(3, "div", 2);
        ɵɵtext(4);
        ɵɵelementEnd()();
        ɵɵelementStart(5, "div", 3);
        ɵɵconditionalCreate(6, AIPromptOutputCardComponent_Conditional_6_Template, 1, 4, "ng-container")(7, AIPromptOutputCardComponent_Conditional_7_Template, 2, 1, "p");
        ɵɵelementEnd();
        ɵɵelementStart(8, "div", 4)(9, "button", 5);
        ɵɵlistener("click", function AIPromptOutputCardComponent_Template_button_click_9_listener() {
          return ctx.handleCopy();
        });
        ɵɵtext(10);
        ɵɵelementEnd();
        ɵɵelementStart(11, "button", 6);
        ɵɵlistener("click", function AIPromptOutputCardComponent_Template_button_click_11_listener() {
          return ctx.handleRetry();
        });
        ɵɵtext(12);
        ɵɵelementEnd();
        ɵɵconditionalCreate(13, AIPromptOutputCardComponent_Conditional_13_Template, 3, 2);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵattribute("id", ctx.titleId);
        ɵɵadvance();
        ɵɵtextInterpolate1("", ctx.outputTitle, " ");
        ɵɵadvance(2);
        ɵɵtextInterpolate(ctx.promptOutput.prompt);
        ɵɵadvance(2);
        ɵɵconditional(ctx.customBodyTemplate ? 6 : 7);
        ɵɵadvance(3);
        ɵɵproperty("svgIcon", ctx.copyIcon);
        ɵɵadvance();
        ɵɵtextInterpolate(ctx.messageFor("copyOutput"));
        ɵɵadvance();
        ɵɵproperty("svgIcon", ctx.retryIcon);
        ɵɵadvance();
        ɵɵtextInterpolate(ctx.messageFor("retryGeneration"));
        ɵɵadvance();
        ɵɵconditional(ctx.showRating ? 13 : -1);
      }
    },
    dependencies: [ButtonComponent, NgTemplateOutlet],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AIPromptOutputCardComponent, [{
    type: Component,
    args: [{
      selector: "[kendoAIPromptOutputCard]",
      template: `
        <div class="k-card-header">
          <div
            class="k-card-title"
            [attr.id]="titleId">{{outputTitle}}
          </div>
          <div class="k-card-subtitle">{{promptOutput.prompt}}</div>
        </div>
        <div class="k-card-body">
          @if (customBodyTemplate) {
            <ng-container *ngTemplateOutlet="customBodyTemplate; context: { $implicit: promptOutput }">
            </ng-container>
          } @else {
            <p>{{promptOutput.output}}</p>
          }
        </div>
        <div class="k-actions k-actions-start k-actions-horizontal k-card-actions">
          <button kendoButton
            fillMode="flat"
            themeColor="primary"
            rounded="full"
            icon="copy"
            [svgIcon]="copyIcon"
            (click)="handleCopy()"
          >{{messageFor('copyOutput')}}</button>
          <button kendoButton
            fillMode="flat"
            rounded="full"
            icon="arrow-rotate-cw"
            [svgIcon]="retryIcon"
            (click)="handleRetry()"
          >{{messageFor('retryGeneration')}}</button>
          @if (showRating) {
            <span class="k-spacer"></span>
            <button kendoButton
              fillMode="flat"
              icon="thumb-up-outline"
              [svgIcon]="positiveRatingIcon"
              (click)="handleRating('positive')">
            </button>
            <button kendoButton
              fillMode="flat"
              icon="thumb-down-outline"
              [svgIcon]="negativeRatingIcon"
              (click)="handleRating('negative')">
            </button>
          }
        </div>
        `,
      standalone: true,
      imports: [ButtonComponent, NgTemplateOutlet]
    }]
  }], () => [{
    type: LocalizationService
  }, {
    type: AIPromptService
  }], {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-card"]
    }],
    listItemRole: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    tabIndex: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    ariaDescribedBy: [{
      type: HostBinding,
      args: ["attr.aria-describedby"]
    }],
    ariaKeyShortcuts: [{
      type: HostBinding,
      args: ["attr.aria-keyshortcuts"]
    }],
    promptOutput: [{
      type: Input
    }]
  });
})();
var OutputViewComponent = class _OutputViewComponent extends BaseView {
  service;
  constructor(localization, service) {
    super("output", localization);
    this.service = service;
  }
  /**
   * @hidden
   */
  get promptOutputs() {
    return this.service.promptOutputs;
  }
  /**
   * @hidden
   */
  get customTemplate() {
    return this.service.outputTemplate?.templateRef;
  }
  static ɵfac = function OutputViewComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _OutputViewComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(AIPromptService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _OutputViewComponent,
    selectors: [["kendo-aiprompt-output-view"]],
    features: [ɵɵProvidersFeature([{
      provide: BaseView,
      useExisting: forwardRef(() => _OutputViewComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 2,
    vars: 0,
    consts: [["content", ""], ["role", "list", 1, "k-card-list"], ["kendoAIPromptOutputCard", "", 3, "promptOutput"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"]],
    template: function OutputViewComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, OutputViewComponent_ng_template_0_Template, 3, 0, "ng-template", null, 0, ɵɵtemplateRefExtractor);
      }
    },
    dependencies: [AIPromptOutputCardComponent, NgTemplateOutlet],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OutputViewComponent, [{
    type: Component,
    args: [{
      selector: "kendo-aiprompt-output-view",
      providers: [{
        provide: BaseView,
        useExisting: forwardRef(() => OutputViewComponent)
      }],
      template: `
        <ng-template #content>
          <div
            class="k-card-list"
            role="list">
            @for (output of promptOutputs; track output) {
              @if (customTemplate) {
                <ng-container *ngTemplateOutlet="customTemplate; context: { $implicit: output }">
                </ng-container>
              } @else {
                <div kendoAIPromptOutputCard [promptOutput]="output"></div>
              }
            }
          </div>
        </ng-template>
        `,
      standalone: true,
      imports: [AIPromptOutputCardComponent, NgTemplateOutlet]
    }]
  }], () => [{
    type: LocalizationService
  }, {
    type: AIPromptService
  }], null);
})();
var PromptViewComponent = class _PromptViewComponent extends BaseView {
  service;
  constructor(localization, service) {
    super("prompt", localization);
    this.service = service;
  }
  /**
   * @hidden
   */
  get suggestionsIcons() {
    return this.showSuggestions ? {
      font: "chevron-up",
      svg: chevronUpIcon
    } : {
      font: "chevron-down",
      svg: chevronDownIcon
    };
  }
  /**
   * @hidden
   */
  showSuggestions = true;
  /**
   * @hidden
   */
  contentId = `k-prompt-suggestions-${guid()}`;
  /**
   * @hidden
   */
  get promptSuggestions() {
    return this.service.promptSuggestions;
  }
  /**
   *
   * @hidden
   */
  set textAreaValue(value2) {
    this.service.promptValue = value2;
  }
  get textAreaValue() {
    return this.service.promptValue;
  }
  /**
   * @hidden
   */
  suggestionClick(suggestion) {
    this.textAreaValue = this.service.promptValue = suggestion;
  }
  /**
   * @hidden
   */
  suggestionKeydown(event, suggestion) {
    if (event.key === "Enter" || event.key === " ") {
      this.suggestionClick(suggestion);
    }
  }
  /**
   * @hidden
   */
  get speechToTextButtonSettings() {
    return this.service.speechToTextButton;
  }
  /**
   * @hidden
   */
  get textareaSettings() {
    return this.service.textAreaSettings;
  }
  /**
   * @hidden
   */
  onSpeechToTextResult(event) {
    if (event.alternatives && event.alternatives.length > 0) {
      this.textAreaValue += event.alternatives[0].transcript + " ";
    }
  }
  /**
   * @hidden
   */
  onSpeechToTextError(event) {
    if (isDevMode()) {
      console.error("Speech to Text error:", event.errorMessage);
    }
  }
  static ɵfac = function PromptViewComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PromptViewComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(AIPromptService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PromptViewComponent,
    selectors: [["kendo-aiprompt-prompt-view"]],
    features: [ɵɵProvidersFeature([{
      provide: BaseView,
      useExisting: forwardRef(() => _PromptViewComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 2,
    vars: 0,
    consts: [["content", ""], [3, "valueChange", "cols", "disabled", "fillMode", "flow", "inputAttributes", "maxlength", "placeholder", "readonly", "resizable", "rounded", "rows", "selectOnFocus", "showSuffixSeparator", "size", "tabIndex", "title", "value"], [1, "k-prompt-expander"], ["kendoSpeechToTextButton", "", "role", "button", 3, "error", "result", "continuous", "disabled", "fillMode", "integrationMode", "interimResults", "lang", "maxAlternatives", "rounded", "size", "themeColor"], ["kendoButton", "", "fillMode", "flat", "type", "button", 3, "click", "icon", "svgIcon"], [1, "k-prompt-expander-content"], ["role", "group", 1, "k-suggestion-group"], ["role", "button", 1, "k-suggestion"], ["role", "button", 1, "k-suggestion", 3, "click", "keydown"]],
    template: function PromptViewComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, PromptViewComponent_ng_template_0_Template, 3, 19, "ng-template", null, 0, ɵɵtemplateRefExtractor);
      }
    },
    dependencies: [TextAreaComponent, ButtonComponent, TextAreaSuffixComponent, SpeechToTextButtonComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PromptViewComponent, [{
    type: Component,
    args: [{
      selector: "kendo-aiprompt-prompt-view",
      providers: [{
        provide: BaseView,
        useExisting: forwardRef(() => PromptViewComponent)
      }],
      template: `
        <ng-template #content>
          <kendo-textarea
            [cols]="textareaSettings?.cols"
            [disabled]="textareaSettings?.disabled"
            [fillMode]="textareaSettings?.fillMode"
            [flow]="textareaSettings?.flow ?? 'vertical'"
            [inputAttributes]="textareaSettings?.inputAttributes"
            [maxlength]="textareaSettings?.maxlength"
            [placeholder]="textareaSettings?.placeholder ?? messageFor('promptPlaceholder')"
            [readonly]="textareaSettings?.readonly"
            [resizable]="textareaSettings?.resizable ?? 'vertical'"
            [rounded]="textareaSettings?.rounded"
            [rows]="textareaSettings?.rows ?? 1"
            [selectOnFocus]="textareaSettings?.selectOnFocus"
            [showSuffixSeparator]="textareaSettings?.showSuffixSeparator ?? true"
            [size]="textareaSettings?.size"
            [tabIndex]="textareaSettings?.tabindex"
            [title]="textareaSettings?.title"
            [(value)]="textAreaValue"
            >
            @if (speechToTextButtonSettings) {
              <kendo-textarea-suffix>
                <button kendoSpeechToTextButton
                  role="button"
                  [continuous]="speechToTextButtonSettings?.continuous"
                  [disabled]="speechToTextButtonSettings?.disabled"
                  [fillMode]="speechToTextButtonSettings?.fillMode ?? 'flat'"
                  [integrationMode]="speechToTextButtonSettings?.integrationMode ?? 'webSpeech'"
                  [interimResults]="speechToTextButtonSettings?.interimResults"
                  [lang]="speechToTextButtonSettings?.lang"
                  [maxAlternatives]="speechToTextButtonSettings?.maxAlternatives"
                  [rounded]="speechToTextButtonSettings?.rounded"
                  [size]="speechToTextButtonSettings?.size"
                  [themeColor]="speechToTextButtonSettings?.themeColor"
                  [attr.aria-label]="messageFor('speechToTextButton')"
                  [attr.title]="messageFor('speechToTextButton')"
                  [attr.aria-disabled]="speechToTextButtonSettings?.disabled"
                  (error)="onSpeechToTextError($event)"
                  (result)="onSpeechToTextResult($event)"
                ></button>
              </kendo-textarea-suffix>
            }
          </kendo-textarea>
          @if (promptSuggestions) {
            <div
              class="k-prompt-expander">
              <button kendoButton
                [attr.aria-controls]="contentId"
                [attr.aria-expanded]="showSuggestions"
                fillMode="flat"
                [icon]="suggestionsIcons.font"
                [svgIcon]="suggestionsIcons.svg"
                type="button"
                (click)="showSuggestions = !showSuggestions">
                {{messageFor('promptSuggestions')}}
              </button>
              @if (showSuggestions) {
                <div
                  class="k-prompt-expander-content"
                  [attr.id]="contentId">
                  <div class="k-suggestion-group" role="group">
                    @for (suggestion of promptSuggestions; track suggestion) {
                      <div
                        class="k-suggestion"
                        role="button"
                        [attr.tabindex]="0"
                        [attr.aria-label]="suggestion"
                        [attr.title]="suggestion"
                        (click)="suggestionClick(suggestion)"
                        (keydown)="suggestionKeydown($event, suggestion)">
                        {{suggestion}}
                      </div>
                    }
                  </div>
                </div>
              }
            </div>
          }
        </ng-template>
        `,
      standalone: true,
      imports: [TextAreaComponent, ButtonComponent, TextAreaSuffixComponent, SpeechToTextButtonComponent]
    }]
  }], () => [{
    type: LocalizationService
  }, {
    type: AIPromptService
  }], null);
})();
var AttachmentTemplateDirective = class _AttachmentTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function AttachmentTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AttachmentTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _AttachmentTemplateDirective,
    selectors: [["", "kendoChatAttachmentTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AttachmentTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoChatAttachmentTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var noop2 = () => {
};
var handlers3 = {
  "reply": (action, sender) => {
    sender.sendMessage.emit(new SendMessageEvent({
      id: guid(),
      author: {
        id: sender.authorId
      },
      text: action.value,
      timestamp: /* @__PURE__ */ new Date()
    }));
  },
  "call": (action) => {
    window.open("tel:" + action.value);
  },
  "openUrl": (action) => {
    window.open(action.value);
  }
};
var makeHandler = (action) => handlers3[action.type] || noop2;
var ChatMessageBoxTemplateDirective = class _ChatMessageBoxTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function ChatMessageBoxTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ChatMessageBoxTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ChatMessageBoxTemplateDirective,
    selectors: [["", "kendoChatMessageBoxTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChatMessageBoxTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoChatMessageBoxTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var defaultModelFields2 = {
  idField: "id",
  textField: "text",
  authorIdField: "authorId",
  authorNameField: "authorName",
  authorImageUrlField: "authorImageUrl",
  authorImageAltTextField: "authorImageAltText",
  timestampField: "timestamp",
  statusField: "status",
  filesField: "files",
  attachmentsField: "attachments",
  attachmentLayoutField: "attachmentLayout",
  suggestedActionsField: "suggestedActions",
  isPinnedField: "isPinned",
  replyToIdField: "replyToId",
  isDeletedField: "isDeleted",
  typingField: "typing"
};
var closest4 = (node, predicate) => {
  while (node && !predicate(node)) {
    node = node.parentNode;
  }
  return node;
};
var URL_REGEX = /(https?:\/\/[^\s]+)/g;
var DOWNLOAD_ALL_SELECTOR = ".k-chat-download-button";
var FILE_ACTION_BTN_SELECTOR = ".k-menu-button";
var MENU_ITEM_SELECTOR = ".k-menu-link";
var STB_DEFAULT_SETTINGS = {
  continuous: false,
  disabled: false,
  fillMode: "clear",
  integrationMode: "webSpeech",
  interimResults: false,
  lang: "en-US",
  maxAlternatives: 1,
  rounded: "medium",
  size: "medium",
  themeColor: "base"
};
var SEND_BTN_DEFAULT_SETTINGS = {
  fillMode: "solid",
  rounded: "full",
  size: "medium",
  themeColor: "primary",
  icon: "paper-plane",
  svgIcon: paperPlaneIcon,
  buttonClass: "k-chat-send"
};
var FILESELECT_DEFAULT_SETTINGS = {
  multiple: true,
  disabled: false
};
var SUGGESTIONS_LAYOUT_DEFAULT_SETTINGS = "scroll";
var CONTEXT_MENU_ACTIONS = [{
  id: "copy",
  label: "Copy",
  icon: "copy",
  svgIcon: copyIcon,
  disabled: false
}, {
  id: "reply",
  label: "Reply",
  icon: "undo",
  svgIcon: undoIcon,
  disabled: false
}];
var FILE_ACTIONS = [{
  id: "download",
  label: "Download",
  icon: "download",
  svgIcon: downloadIcon,
  disabled: false
}];
var processMessages = (messages, fields) => {
  const modelFields = __spreadValues(__spreadValues({}, defaultModelFields2), fields);
  return messages.map((message) => parseMessage(message, modelFields));
};
var parseMessage = (message, fields) => {
  const modelFields = __spreadValues(__spreadValues({}, defaultModelFields2), fields);
  let author;
  const authorId = getter2(modelFields.authorIdField || "authorId")(message);
  const authorName = getter2(modelFields.authorNameField || "authorName")(message);
  const authorImageUrl = getter2(modelFields.authorImageUrlField || "authorImageUrl")(message);
  const authorImageAltText = getter2(modelFields.authorImageAltTextField || "authorImageAltText")(message);
  if (authorId !== void 0) {
    author = __spreadValues(__spreadValues(__spreadValues({
      id: authorId
    }, authorName && {
      name: authorName
    }), authorImageUrl && {
      avatarUrl: authorImageUrl
    }), authorImageAltText && {
      avatarAltText: authorImageAltText
    });
  }
  const timestampValue = getter2(modelFields.timestampField)(message);
  const timestamp = timestampValue instanceof Date ? timestampValue : new Date(timestampValue);
  return {
    id: getter2(modelFields.idField)(message),
    text: getter2(modelFields.textField)(message),
    author,
    timestamp,
    status: getter2(modelFields.statusField)(message),
    files: getter2(modelFields.filesField)(message),
    attachments: getter2(modelFields.attachmentsField)(message),
    attachmentLayout: getter2(modelFields.attachmentLayoutField)(message),
    suggestedActions: getter2(modelFields.suggestedActionsField)(message),
    isPinned: getter2(modelFields.isPinnedField)(message),
    replyToId: getter2(modelFields.replyToIdField)(message),
    isDeleted: getter2(modelFields.isDeletedField)(message),
    typing: getter2(modelFields.typingField)(message),
    dataItem: message
  };
};
var transformActions = (actions) => {
  return actions.map((action) => ({
    text: action.label,
    icon: action.icon,
    svgIcon: action.svgIcon,
    disabled: action.disabled,
    originalAction: action
  }));
};
var ChatService = class _ChatService {
  authorId;
  messageWidthMode;
  messageToolbarActions = [];
  messageContextMenuActions = [];
  calculatedContextMenuActions = [];
  fileActions = [];
  toggleMessageState = false;
  reply;
  messages = [];
  chatElement;
  messageElementsMap = /* @__PURE__ */ new Map();
  messagesContextMenu;
  activeMessage;
  activeMessageElement;
  selectOnMenuClose = false;
  active = false;
  messageFilesLayout = "vertical";
  timestampVisibility = "focus";
  showUsername = true;
  showAvatar = true;
  _enableSpeechToText = STB_DEFAULT_SETTINGS;
  _enableFileSelect = FILESELECT_DEFAULT_SETTINGS;
  _sendButtonSettings = SEND_BTN_DEFAULT_SETTINGS;
  _suggestionsLayout = SUGGESTIONS_LAYOUT_DEFAULT_SETTINGS;
  _quickActionsLayout = SUGGESTIONS_LAYOUT_DEFAULT_SETTINGS;
  _authorMessageSettings;
  _receiverMessageSettings;
  _allowMessageCollapse;
  subjects = {
    toolbarAction: new Subject(),
    contextMenuAction: new Subject(),
    fileAction: new Subject(),
    fileDownload: new Subject(),
    replyReferenceClick: new Subject(),
    inputValueChange: new Subject(),
    contextMenuVisibilityChange: new Subject(),
    suggestionsLayoutChange: new Subject(),
    quickActionsLayoutChange: new Subject(),
    authorMessageSettingsChange: new Subject(),
    receiverMessageSettingsChange: new Subject(),
    allowMessageCollapseChange: new Subject()
  };
  toolbarAction$ = this.subjects.toolbarAction.asObservable();
  contextMenuAction$ = this.subjects.contextMenuAction.asObservable();
  fileAction$ = this.subjects.fileAction.asObservable();
  fileDownload$ = this.subjects.fileDownload.asObservable();
  replyReferenceClick$ = this.subjects.replyReferenceClick.asObservable();
  inputValueChange$ = this.subjects.inputValueChange.asObservable();
  contextMenuVisibilityChange$ = this.subjects.contextMenuVisibilityChange.asObservable();
  suggestionsLayoutChange$ = this.subjects.suggestionsLayoutChange.asObservable();
  quickActionsLayoutChange$ = this.subjects.quickActionsLayoutChange.asObservable();
  authorMessageSettingsChange$ = this.subjects.authorMessageSettingsChange.asObservable();
  receiverMessageSettingsChange$ = this.subjects.receiverMessageSettingsChange.asObservable();
  allowMessageCollapseChange$ = this.subjects.allowMessageCollapseChange.asObservable();
  set authorMessageSettings(settings) {
    const previousSettings = this._authorMessageSettings;
    if (JSON.stringify(previousSettings) !== JSON.stringify(settings)) {
      this.updateComponentSettings("_authorMessageSettings", settings, null);
      this.emit("authorMessageSettingsChange", this._authorMessageSettings);
    }
  }
  get authorMessageSettings() {
    return this._authorMessageSettings;
  }
  set receiverMessageSettings(settings) {
    const previousSettings = this._receiverMessageSettings;
    if (JSON.stringify(previousSettings) !== JSON.stringify(settings)) {
      this.updateComponentSettings("_receiverMessageSettings", settings, null);
      this.emit("receiverMessageSettingsChange", this._receiverMessageSettings);
    }
  }
  get receiverMessageSettings() {
    return this._receiverMessageSettings;
  }
  set enableSpeechToText(settings) {
    this.updateComponentSettings("_enableSpeechToText", settings, STB_DEFAULT_SETTINGS);
  }
  get enableSpeechToText() {
    return this._enableSpeechToText;
  }
  set enableFileSelect(settings) {
    this.updateComponentSettings("_enableFileSelect", settings, FILESELECT_DEFAULT_SETTINGS);
  }
  get enableFileSelect() {
    return this._enableFileSelect;
  }
  set sendButtonSettings(settings) {
    this.updateComponentSettings("_sendButtonSettings", settings, SEND_BTN_DEFAULT_SETTINGS);
  }
  get sendButtonSettings() {
    return this._sendButtonSettings;
  }
  set suggestionsLayout(layoutMode) {
    this._suggestionsLayout = layoutMode;
    this.emit("suggestionsLayoutChange", this._suggestionsLayout);
  }
  get suggestionsLayout() {
    return this._suggestionsLayout;
  }
  set quickActionsLayout(layoutMode) {
    this._quickActionsLayout = layoutMode;
    this.emit("quickActionsLayoutChange", this._quickActionsLayout);
  }
  get quickActionsLayout() {
    return this._quickActionsLayout;
  }
  set allowMessageCollapse(value2) {
    const previousValue = this._allowMessageCollapse;
    if (previousValue !== value2) {
      this._allowMessageCollapse = value2;
      this.emit("allowMessageCollapseChange", this._allowMessageCollapse);
    }
  }
  get allowMessageCollapse() {
    return this._allowMessageCollapse;
  }
  calculateContextMenuActions(isOwn) {
    const settings = isOwn ? this.authorMessageSettings : this.receiverMessageSettings;
    if (settings?.messageContextMenuActions) {
      this.calculatedContextMenuActions = settings.messageContextMenuActions;
      return;
    }
    this.calculatedContextMenuActions = this.messageContextMenuActions || [];
  }
  emit(subjectKey, value2) {
    this.subjects[subjectKey].next(value2);
  }
  getMessageById(id3) {
    return this.messages.find((message) => message.id === id3);
  }
  registerMessageElement(messageId, elementRef) {
    this.messageElementsMap.set(messageId, elementRef);
  }
  unregisterMessageElement(messageId) {
    this.messageElementsMap.delete(messageId);
    if (this.reply?.id === messageId) {
      this.reply = null;
    }
  }
  scrollToMessage(messageId) {
    const elementRef = this.messageElementsMap.get(messageId);
    if (elementRef?.nativeElement) {
      elementRef.nativeElement.scrollIntoView({
        behavior: "smooth",
        block: "nearest"
      });
    }
  }
  focusActiveMessageElement() {
    if (this.activeMessageElement) {
      this.activeMessageElement.element?.nativeElement?.focus();
    }
  }
  updateComponentSettings(property, settings, defaultSettings) {
    if (settings === true) {
      this[property] = defaultSettings;
    } else if (settings === false) {
      this[property] = null;
    } else {
      this[property] = __spreadValues(__spreadValues({}, defaultSettings), settings);
    }
  }
  static ɵfac = function ChatService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ChatService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ChatService,
    factory: _ChatService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChatService, [{
    type: Injectable
  }], null, null);
})();
var ChatItem = class {
  selected;
};
var ChatSuggestionTemplateDirective = class _ChatSuggestionTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function ChatSuggestionTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ChatSuggestionTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ChatSuggestionTemplateDirective,
    selectors: [["", "kendoChatSuggestionTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChatSuggestionTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoChatSuggestionTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var DIRECTION_CLASSES2 = {
  left: "chevron-left",
  right: "chevron-right"
};
var ChatScrollableButtonComponent = class _ChatScrollableButtonComponent {
  host;
  renderer;
  ngZone;
  localization;
  role = "button";
  prev = false;
  onClick = new EventEmitter();
  get scrollButtonIconClass() {
    const defaultPrevIcon = !this.localization.rtl ? DIRECTION_CLASSES2.left : DIRECTION_CLASSES2.right;
    const defaultNextIcon = !this.localization.rtl ? DIRECTION_CLASSES2.right : DIRECTION_CLASSES2.left;
    return this.prev ? defaultPrevIcon : defaultNextIcon;
  }
  get scrollButtonSVGIcon() {
    const defaultPrevSVGIcon = !this.localization.rtl ? this.chevronLeftIcon : this.chevronRightIcon;
    const defaultNextSVGIcon = !this.localization.rtl ? this.chevronRightIcon : this.chevronLeftIcon;
    return this.prev ? defaultPrevSVGIcon : defaultNextSVGIcon;
  }
  chevronLeftIcon = chevronLeftIcon;
  chevronRightIcon = chevronRightIcon;
  subs = new Subscription();
  constructor(host, renderer, ngZone, localization) {
    this.host = host;
    this.renderer = renderer;
    this.ngZone = ngZone;
    this.localization = localization;
  }
  ngAfterViewInit() {
    this.ngZone.runOutsideAngular(() => {
      this.subs.add(this.renderer.listen(this.host.nativeElement, "click", () => this.clickHandler()));
    });
  }
  ngOnDestroy() {
    this.subs.unsubscribe();
  }
  clickHandler() {
    const buttonType = this.prev ? "prev" : "next";
    this.onClick.emit(buttonType);
  }
  static ɵfac = function ChatScrollableButtonComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ChatScrollableButtonComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ChatScrollableButtonComponent,
    selectors: [["", "kendoChatScrollableButton", ""]],
    hostVars: 1,
    hostBindings: function ChatScrollableButtonComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("role", ctx.role);
      }
    },
    inputs: {
      prev: "prev"
    },
    outputs: {
      onClick: "onClick"
    },
    attrs: _c49,
    decls: 1,
    vars: 2,
    consts: [["innerCssClass", "k-button-icon", 3, "name", "svgIcon"]],
    template: function ChatScrollableButtonComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelement(0, "kendo-icon-wrapper", 0);
      }
      if (rf & 2) {
        ɵɵproperty("name", ctx.scrollButtonIconClass)("svgIcon", ctx.scrollButtonSVGIcon);
      }
    },
    dependencies: [IconWrapperComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChatScrollableButtonComponent, [{
    type: Component,
    args: [{
      template: `
        <kendo-icon-wrapper [name]="scrollButtonIconClass" [svgIcon]="scrollButtonSVGIcon" innerCssClass="k-button-icon"> </kendo-icon-wrapper>
    `,
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "[kendoChatScrollableButton]",
      standalone: true,
      imports: [IconWrapperComponent]
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: NgZone
  }, {
    type: LocalizationService
  }], {
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    prev: [{
      type: Input
    }],
    onClick: [{
      type: Output
    }]
  });
})();
var DEFAULT_SCROLL_BEHAVIOR2 = "smooth";
var DEFAULT_SCROLL_SPEED = 100;
var SuggestionsScrollService = class _SuggestionsScrollService {
  ngZone;
  localization;
  owner;
  position = 0;
  scrollButtonActiveStateChange = new Subject();
  get scrollElement() {
    return this.owner.suggestionsContainer?.nativeElement;
  }
  get scrollContainerOverflowSize() {
    if (!isDocumentAvailable()) {
      return 0;
    }
    if (!this.scrollElement) {
      return 0;
    }
    const overflowSize = Math.floor(this.scrollElement.scrollWidth - this.scrollElement.offsetWidth);
    return overflowSize < 0 ? 0 : overflowSize;
  }
  get suggestionsOverflow() {
    return this.scrollContainerOverflowSize > 0;
  }
  constructor(ngZone, localization) {
    this.ngZone = ngZone;
    this.localization = localization;
  }
  toggleScrollButtonsState() {
    const suggestedActions = this.owner;
    if (!suggestedActions?.hasScrollButtons) {
      return;
    }
    const currentPrevButtonActive = !this.isDisabled("prev");
    const currentNextButtonActive = !this.isDisabled("next");
    const defaultOffset = 1;
    const rtlDelta = this.localization.rtl ? -1 : 1;
    const calculatedPrevButtonActive = this.position * rtlDelta > 0 && this.scrollContainerOverflowSize > 0;
    const calculatedNextButtonActive = this.position * rtlDelta < this.scrollContainerOverflowSize - defaultOffset && this.scrollContainerOverflowSize > 0;
    if (calculatedPrevButtonActive !== currentPrevButtonActive) {
      this.ngZone.run(() => this.toggleButtonActiveState("prev", calculatedPrevButtonActive));
    }
    if (calculatedNextButtonActive !== currentNextButtonActive) {
      this.ngZone.run(() => this.toggleButtonActiveState("next", calculatedNextButtonActive));
    }
  }
  onScroll(e) {
    this.position = e.target.scrollLeft;
    this.toggleScrollButtonsState();
  }
  scrollSuggestions(direction) {
    this.calculateListPosition(direction, DEFAULT_SCROLL_SPEED);
    if (this.scrollElement) {
      this.scrollElement.scrollTo({
        left: this.position,
        behavior: DEFAULT_SCROLL_BEHAVIOR2
      });
    }
    this.toggleScrollButtonsState();
  }
  updateScrollPosition(element) {
    this.position = element.scrollLeft;
  }
  calculateListPosition(direction, scrollSpeed) {
    if (direction === "prev") {
      if (!this.localization.rtl) {
        this.position = this.position - scrollSpeed <= 0 ? 0 : this.position - scrollSpeed;
      } else {
        this.position = this.position + scrollSpeed >= 0 ? 0 : this.position + scrollSpeed;
      }
    } else if (direction === "next" && this.position < this.scrollContainerOverflowSize) {
      if (this.position + scrollSpeed > this.scrollContainerOverflowSize) {
        if (this.localization.rtl) {
          this.position = -this.scrollContainerOverflowSize;
        } else {
          this.position = this.scrollContainerOverflowSize;
        }
        return;
      }
      if (this.localization.rtl) {
        this.position -= scrollSpeed;
      } else {
        this.position += scrollSpeed;
      }
    }
  }
  toggleButtonActiveState(buttonType, active) {
    this.scrollButtonActiveStateChange.next({
      buttonType,
      active
    });
  }
  isDisabled = (buttonType) => this.owner[`${buttonType}ScrollButton`]?.nativeElement.classList.contains("k-disabled");
  static ɵfac = function SuggestionsScrollService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SuggestionsScrollService)(ɵɵinject(NgZone), ɵɵinject(LocalizationService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _SuggestionsScrollService,
    factory: _SuggestionsScrollService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SuggestionsScrollService, [{
    type: Injectable
  }], () => [{
    type: NgZone
  }, {
    type: LocalizationService
  }], null);
})();
var SuggestedActionsComponent = class _SuggestedActionsComponent extends ChatItem {
  chatService;
  localization;
  scrollService;
  ngZone;
  renderer;
  get defaultClass() {
    if (this.type === "suggestion") {
      return this.chatService.suggestionsLayout === "wrap" || this.chatService.suggestionsLayout === "scroll";
    } else if (this.type === "action") {
      return this.chatService.quickActionsLayout === "wrap" || this.chatService.quickActionsLayout === "scroll";
    }
  }
  get scrollableClass() {
    if (this.type === "suggestion") {
      return this.chatService.suggestionsLayout === "scroll";
    } else if (this.type === "action") {
      return this.chatService.quickActionsLayout === "scroll";
    }
  }
  get scrollButtonsClass() {
    if (this.type === "suggestion") {
      return this.chatService.suggestionsLayout === "scrollbuttons";
    } else if (this.type === "action") {
      return this.chatService.quickActionsLayout === "scrollbuttons";
    }
  }
  get role() {
    if (!this.hasScrollButtons) {
      return "group";
    }
    return null;
  }
  actions;
  suggestions;
  tabbable;
  type;
  suggestionTemplate;
  dispatchAction = new EventEmitter();
  dispatchSuggestion = new EventEmitter();
  items;
  suggestionsContainer;
  prevScrollButton;
  nextScrollButton;
  selectedIndex = 0;
  activeIndex = -1;
  active = false;
  get hasScrollButtons() {
    return this.type === "suggestion" ? this.chatService.suggestionsLayout === "scrollbuttons" : this.chatService.quickActionsLayout === "scrollbuttons";
  }
  subscriptions = new Subscription();
  resizeObserver = null;
  actionKeyHandlers = {
    [Keys.Tab]: (e) => this.changeSelectedIndex(e),
    [Keys.Enter]: (_, action) => this.actionClick(action),
    [Keys.Space]: (_, action) => this.actionClick(action)
  };
  suggestionKeyHandlers = {
    [Keys.Tab]: (e) => this.changeSelectedIndex(e),
    [Keys.Enter]: (_, suggestion) => this.suggestionClick(suggestion),
    [Keys.Space]: (_, suggestion) => this.suggestionClick(suggestion)
  };
  constructor(chatService, localization, scrollService, ngZone, renderer) {
    super();
    this.chatService = chatService;
    this.localization = localization;
    this.scrollService = scrollService;
    this.ngZone = ngZone;
    this.renderer = renderer;
    this.scrollService.owner = this;
  }
  ngAfterViewInit() {
    const layoutChangeObservable = this.type === "suggestion" ? this.chatService.suggestionsLayoutChange$ : this.chatService.quickActionsLayoutChange$;
    this.subscriptions.add(layoutChangeObservable.subscribe((layoutMode) => {
      if (layoutMode === "scrollbuttons") {
        this.ngZone.onStable.pipe(take(1)).subscribe(() => {
          if (this.suggestionsContainer) {
            this.scrollService.updateScrollPosition(this.suggestionsContainer.nativeElement);
          }
          this.scrollService.toggleScrollButtonsState();
        });
      }
    }));
    this.subscriptions.add(this.scrollService.scrollButtonActiveStateChange.subscribe((change) => {
      this.toggleScrollButtonState(change.buttonType, change.active);
    }));
    if (this.hasScrollButtons && this.suggestionsContainer) {
      this.ngZone.runOutsideAngular(() => {
        this.resizeObserver = new ResizeObserver(() => {
          this.ngZone.run(() => {
            this.scrollService.toggleScrollButtonsState();
          });
        });
        this.resizeObserver.observe(this.suggestionsContainer.nativeElement);
      });
    }
    if (this.hasScrollButtons) {
      this.ngZone.onStable.pipe(take(1)).subscribe(() => {
        this.scrollService.toggleScrollButtonsState();
      });
      if (this.suggestionsContainer) {
        this.scrollService.updateScrollPosition(this.suggestionsContainer.nativeElement);
      }
    }
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
      this.resizeObserver = null;
    }
  }
  isSelected(index) {
    return this.selected && this.selectedIndex === index;
  }
  isActive(index) {
    return this.activeIndex === index;
  }
  actionClick(action, index) {
    if (index >= 0) {
      this.selectedIndex = index;
    }
    this.dispatchAction.next(action);
  }
  suggestionClick(suggestion, index) {
    if (index >= 0) {
      this.selectedIndex = index;
    }
    this.dispatchSuggestion.next(suggestion);
  }
  toggleActiveState(apply, index) {
    this.activeIndex = apply ? index : -1;
  }
  actionKeydown(e, action) {
    const handler = this.actionKeyHandlers[normalizeKeys(e)];
    if (handler) {
      handler(e, action);
    }
  }
  suggestionKeydown(e, suggestion) {
    const handler = this.suggestionKeyHandlers[normalizeKeys(e)];
    if (handler) {
      handler(e, suggestion);
    }
  }
  getScrollButtonTitle(direction) {
    let currentButton;
    if (this.localization.rtl) {
      currentButton = direction === "prev" ? "nextSuggestionsButtonTitle" : "previousSuggestionsButtonTitle";
    } else {
      currentButton = direction === "prev" ? "previousSuggestionsButtonTitle" : "nextSuggestionsButtonTitle";
    }
    return this.localization.get(currentButton);
  }
  onScroll(event) {
    this.scrollService.onScroll(event);
  }
  scrollSuggestions(direction) {
    this.scrollService.scrollSuggestions(direction);
  }
  focus() {
  }
  toggleScrollButtonState(buttonType, active) {
    const button = this[`${buttonType}ScrollButton`];
    if (button?.nativeElement) {
      if (active) {
        this.renderer.removeClass(button.nativeElement, "k-disabled");
      } else {
        this.renderer.addClass(button.nativeElement, "k-disabled");
      }
    }
  }
  changeSelectedIndex(e) {
    const offset3 = e.shiftKey ? -1 : 1;
    const prevIndex = this.selectedIndex;
    this.selectedIndex = Math.max(0, Math.min(prevIndex + offset3, this.items.length - 1));
  }
  static ɵfac = function SuggestedActionsComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SuggestedActionsComponent)(ɵɵdirectiveInject(ChatService), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(SuggestionsScrollService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _SuggestedActionsComponent,
    selectors: [["kendo-chat-suggested-actions"]],
    viewQuery: function SuggestedActionsComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c56, 5, ElementRef)(_c65, 5, ElementRef)(_c74, 5, ElementRef)(_c84, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.suggestionsContainer = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.prevScrollButton = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.nextScrollButton = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.items = _t);
      }
    },
    hostVars: 7,
    hostBindings: function SuggestedActionsComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("role", ctx.role);
        ɵɵclassProp("k-suggestion-group", ctx.defaultClass)("k-suggestion-group-scrollable", ctx.scrollableClass)("k-suggestion-scrollwrap", ctx.scrollButtonsClass);
      }
    },
    inputs: {
      actions: "actions",
      suggestions: "suggestions",
      tabbable: "tabbable",
      type: "type",
      suggestionTemplate: "suggestionTemplate"
    },
    outputs: {
      dispatchAction: "dispatchAction",
      dispatchSuggestion: "dispatchSuggestion"
    },
    features: [ɵɵProvidersFeature([{
      provide: ChatItem,
      useExisting: forwardRef(() => _SuggestedActionsComponent)
    }, SuggestionsScrollService]), ɵɵInheritDefinitionFeature],
    decls: 6,
    vars: 3,
    consts: [["suggestionsContent", ""], ["prevScrollButton", ""], ["suggestionsContainer", ""], ["item", ""], ["nextScrollButton", ""], ["kendoChatScrollableButton", "", 1, "k-button", "k-button-md", "k-button-solid", "k-button-solid-base", "k-rounded-md", "k-icon-button", 3, "prev", "title"], ["role", "group", 1, "k-suggestion-group"], ["kendoChatScrollableButton", "", 1, "k-button", "k-button-md", "k-button-solid", "k-button-solid-base", "k-rounded-md", "k-icon-button", 3, "onClick", "prev", "title"], ["role", "group", 1, "k-suggestion-group", 3, "scroll"], [4, "ngTemplateOutlet"], ["role", "button", 1, "k-suggestion", "k-suggestion-primary", 3, "k-selected", "k-focus", "k-active"], ["role", "button", 1, "k-suggestion", "k-suggestion-primary", 3, "click", "keydown", "mousedown", "mouseup"], ["role", "button", 1, "k-suggestion", 3, "k-selected", "k-focus", "k-active"], ["role", "button", 1, "k-suggestion", 3, "click", "keydown", "mousedown", "mouseup"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
    template: function SuggestedActionsComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵconditionalCreate(0, SuggestedActionsComponent_Conditional_0_Template, 2, 2, "span", 5);
        ɵɵconditionalCreate(1, SuggestedActionsComponent_Conditional_1_Template, 3, 1, "div", 6)(2, SuggestedActionsComponent_Conditional_2_Template, 1, 1, "ng-container");
        ɵɵtemplate(3, SuggestedActionsComponent_ng_template_3_Template, 2, 2, "ng-template", null, 0, ɵɵtemplateRefExtractor);
        ɵɵconditionalCreate(5, SuggestedActionsComponent_Conditional_5_Template, 2, 2, "span", 5);
      }
      if (rf & 2) {
        ɵɵconditional(ctx.hasScrollButtons ? 0 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.hasScrollButtons ? 1 : 2);
        ɵɵadvance(4);
        ɵɵconditional(ctx.hasScrollButtons ? 5 : -1);
      }
    },
    dependencies: [NgTemplateOutlet, ChatScrollableButtonComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SuggestedActionsComponent, [{
    type: Component,
    args: [{
      selector: "kendo-chat-suggested-actions",
      providers: [{
        provide: ChatItem,
        useExisting: forwardRef(() => SuggestedActionsComponent)
      }, SuggestionsScrollService],
      template: `
        @if (hasScrollButtons) {
          <span
            #prevScrollButton
            kendoChatScrollableButton
            [prev]="true"
            [title]="getScrollButtonTitle('prev')"
            class="k-button k-button-md k-button-solid k-button-solid-base k-rounded-md k-icon-button"
            (onClick)="scrollSuggestions($event)"
            >
          </span>
        }
        @if (hasScrollButtons) {
          <div class="k-suggestion-group"
            #suggestionsContainer
            role="group"
            (scroll)="onScroll($event)">
            <ng-container *ngTemplateOutlet="suggestionsContent"></ng-container>
          </div>
        } @else {
          <ng-container *ngTemplateOutlet="suggestionsContent"></ng-container>
        }
        
        
        <ng-template #suggestionsContent>
          @if (actions) {
            @for (action of actions; track action; let index = $index; let first = $first; let last = $last) {
              <span
                #item
                class="k-suggestion k-suggestion-primary"
                role="button"
                [class.k-selected]="isSelected(index)"
                [class.k-focus]="isSelected(index)"
                [class.k-active]="isActive(index)"
                [attr.tabindex]="0"
                (click)="actionClick(action, index)"
                (keydown)="actionKeydown($event, action)"
                (mousedown)="toggleActiveState(true, index)"
                (mouseup)="toggleActiveState(false, index)"
                >
                {{ action.title || action.value }}
              </span>
            }
          }
        
          @if (suggestions) {
            @if (!suggestionTemplate?.templateRef) {
              @for (suggestion of suggestions; track suggestion; let index = $index; let first = $first; let last = $last) {
                <span
                  #item
                  class="k-suggestion"
                  role="button"
                  [class.k-selected]="isSelected(index)"
                  [class.k-focus]="isSelected(index)"
                  [class.k-active]="isActive(index)"
                  [attr.tabindex]="0"
                  (click)="suggestionClick(suggestion, index)"
                  (keydown)="suggestionKeydown($event, suggestion)"
                  (mousedown)="toggleActiveState(true, index)"
                  (mouseup)="toggleActiveState(false, index)"
                  >
                  {{ suggestion.text }}
                </span>
              }
            }
            @if (suggestionTemplate?.templateRef) {
              @for (suggestion of suggestions; track suggestion) {
                <ng-template
                  [ngTemplateOutlet]="suggestionTemplate.templateRef"
                  [ngTemplateOutletContext]="{ $implicit: suggestion }"
                  >
                </ng-template>
              }
            }
          }
        </ng-template>
        
        @if (hasScrollButtons) {
          <span
            #nextScrollButton
            kendoChatScrollableButton
            [prev]="false"
            [title]="getScrollButtonTitle('next')"
            class="k-button k-button-md k-button-solid k-button-solid-base k-rounded-md k-icon-button"
            (onClick)="scrollSuggestions($event)"
            >
          </span>
        }
        `,
      standalone: true,
      imports: [NgTemplateOutlet, ChatScrollableButtonComponent]
    }]
  }], () => [{
    type: ChatService
  }, {
    type: LocalizationService
  }, {
    type: SuggestionsScrollService
  }, {
    type: NgZone
  }, {
    type: Renderer2
  }], {
    defaultClass: [{
      type: HostBinding,
      args: ["class.k-suggestion-group"]
    }],
    scrollableClass: [{
      type: HostBinding,
      args: ["class.k-suggestion-group-scrollable"]
    }],
    scrollButtonsClass: [{
      type: HostBinding,
      args: ["class.k-suggestion-scrollwrap"]
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    actions: [{
      type: Input
    }],
    suggestions: [{
      type: Input
    }],
    tabbable: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    suggestionTemplate: [{
      type: Input
    }],
    dispatchAction: [{
      type: Output
    }],
    dispatchSuggestion: [{
      type: Output
    }],
    items: [{
      type: ViewChildren,
      args: ["item"]
    }],
    suggestionsContainer: [{
      type: ViewChild,
      args: ["suggestionsContainer", {
        read: ElementRef,
        static: false
      }]
    }],
    prevScrollButton: [{
      type: ViewChild,
      args: ["prevScrollButton", {
        read: ElementRef
      }]
    }],
    nextScrollButton: [{
      type: ViewChild,
      args: ["nextScrollButton", {
        read: ElementRef
      }]
    }]
  });
})();
var ChatFileComponent = class _ChatFileComponent extends ChatItem {
  localization;
  chatFile;
  removable = false;
  fileActions;
  remove = new EventEmitter();
  actionClick = new EventEmitter();
  actionsToggle = new EventEmitter();
  actionButtonClick = new EventEmitter();
  deleteIcon = xIcon;
  moreIcon = moreVerticalIcon;
  constructor(localization) {
    super();
    this.localization = localization;
  }
  fileThumbnail(extension) {
    return fileSVGGroupIcon(extension);
  }
  fileGroupClass(extension) {
    return fileGroupClass(extension);
  }
  getTotalFilesSizeMessage(file) {
    return getTotalFilesSizeMessage([file]);
  }
  textFor(key) {
    return this.localization.get(key);
  }
  focus() {
  }
  static ɵfac = function ChatFileComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ChatFileComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ChatFileComponent,
    selectors: [["li", "chatFile", ""]],
    inputs: {
      chatFile: "chatFile",
      removable: "removable",
      fileActions: "fileActions"
    },
    outputs: {
      remove: "remove",
      actionClick: "actionClick",
      actionsToggle: "actionsToggle",
      actionButtonClick: "actionButtonClick"
    },
    features: [ɵɵProvidersFeature([{
      provide: ChatItem,
      useExisting: forwardRef(() => _ChatFileComponent)
    }]), ɵɵInheritDefinitionFeature],
    attrs: _c94,
    decls: 8,
    vars: 6,
    consts: [["size", "xlarge", 3, "name", "svgIcon"], [1, "k-chat-file-info"], [1, "k-chat-file-name"], [1, "k-chat-file-size"], ["kendoButton", "", "fillMode", "flat", 3, "svgIcon"], ["fillMode", "flat", "icon", "more-vertical", 3, "data", "svgIcon"], ["kendoButton", "", "fillMode", "flat", 3, "click", "svgIcon"], ["fillMode", "flat", "icon", "more-vertical", 3, "itemClick", "click", "open", "close", "data", "svgIcon"]],
    template: function ChatFileComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelement(0, "kendo-icon-wrapper", 0);
        ɵɵelementStart(1, "div", 1)(2, "span", 2);
        ɵɵtext(3);
        ɵɵelementEnd();
        ɵɵelementStart(4, "span", 3);
        ɵɵtext(5);
        ɵɵelementEnd()();
        ɵɵconditionalCreate(6, ChatFileComponent_Conditional_6_Template, 1, 2, "button", 4);
        ɵɵconditionalCreate(7, ChatFileComponent_Conditional_7_Template, 1, 3, "kendo-dropdownbutton", 5);
      }
      if (rf & 2) {
        ɵɵproperty("name", ctx.fileGroupClass(ctx.chatFile.extension))("svgIcon", ctx.fileThumbnail(ctx.chatFile.extension));
        ɵɵadvance(3);
        ɵɵtextInterpolate(ctx.chatFile.name);
        ɵɵadvance(2);
        ɵɵtextInterpolate(ctx.getTotalFilesSizeMessage(ctx.chatFile));
        ɵɵadvance();
        ɵɵconditional(ctx.removable ? 6 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.fileActions && ctx.fileActions.length > 0 ? 7 : -1);
      }
    },
    dependencies: [IconWrapperComponent, ButtonComponent, DropDownButtonComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChatFileComponent, [{
    type: Component,
    args: [{
      selector: "li[chatFile]",
      providers: [{
        provide: ChatItem,
        useExisting: forwardRef(() => ChatFileComponent)
      }],
      template: `
        <kendo-icon-wrapper
          size="xlarge"
          [name]="fileGroupClass(chatFile.extension)"
          [svgIcon]="fileThumbnail(chatFile.extension)"
          >
        </kendo-icon-wrapper>
        <div class="k-chat-file-info">
          <span class="k-chat-file-name">{{chatFile.name}}</span>
          <span class="k-chat-file-size">{{getTotalFilesSizeMessage(chatFile)}}</span>
        </div>
        @if (removable) {
          <button
            kendoButton
            [attr.title]="textFor('removeFileTitle')"
            [svgIcon]="deleteIcon"
            (click)="remove.emit(chatFile)"
            fillMode="flat"
          ></button>
        }
        @if (fileActions && fileActions.length > 0) {
          <kendo-dropdownbutton
            [data]="fileActions"
            [attr.title]="textFor('fileActionsTitle')"
            fillMode="flat"
            icon="more-vertical"
            [svgIcon]="moreIcon"
            (itemClick)="actionClick.emit($event)"
            (click)="$event.preventDefault()"
            (open)="actionsToggle.emit(true)"
            (close)="actionsToggle.emit(false)"
          ></kendo-dropdownbutton>
        }
        `,
      standalone: true,
      imports: [IconWrapperComponent, ButtonComponent, DropDownButtonComponent]
    }]
  }], () => [{
    type: LocalizationService
  }], {
    chatFile: [{
      type: Input
    }],
    removable: [{
      type: Input
    }],
    fileActions: [{
      type: Input
    }],
    remove: [{
      type: Output
    }],
    actionClick: [{
      type: Output
    }],
    actionsToggle: [{
      type: Output
    }],
    actionButtonClick: [{
      type: Output
    }]
  });
})();
var isAuthor = (authorId, msg) => msg.author && authorId === msg.author.id;
var last3 = (arr) => arr[arr.length - 1];
var dateChanged = (curr, prev) => curr && prev && (prev.getDate() !== curr.getDate() || prev.getMonth() !== curr.getMonth() || prev.getFullYear() !== curr.getFullYear());
var addDateMarker = (acc, msg) => {
  const timestamp = msg.timestamp;
  const lastItem = last3(acc);
  if (!timestamp) {
    return;
  }
  if (!lastItem || dateChanged(timestamp, lastItem.timestamp)) {
    const dateMarker = {
      type: "date-marker",
      timestamp,
      trackBy: timestamp.getTime()
    };
    acc.push(dateMarker);
  }
};
var groupMessages = (acc, msg, isLastMessage) => {
  const lastItem = last3(acc);
  let messages;
  if (isDevMode() && !msg.author) {
    throw new Error("Author must be set for message: " + JSON.stringify(msg));
  }
  if (msg.typing && !isLastMessage) {
    return;
  }
  if (lastItem && lastItem.type === "message-group") {
    messages = lastItem.messages;
  }
  if (messages && isAuthor(msg.author.id, last3(messages))) {
    messages.push(msg);
  } else {
    acc.push({
      type: "message-group",
      messages: [msg],
      author: msg.author,
      timestamp: msg.timestamp,
      trackBy: msg
    });
  }
};
var groupItems = (total) => (acc, msg, index) => {
  const isLastMessage = index === total - 1;
  addDateMarker(acc, msg);
  groupMessages(acc, msg, isLastMessage);
  if (msg.attachments && msg.attachments.length > 1) {
    acc.push({
      type: "attachment-group",
      attachments: msg.attachments,
      attachmentLayout: msg.attachmentLayout,
      timestamp: msg.timestamp,
      trackBy: "attachment-group" + msg.id
    });
  }
  if (msg.suggestedActions && isLastMessage) {
    acc.push({
      type: "action-group",
      actions: msg.suggestedActions,
      timestamp: msg.timestamp,
      trackBy: "action-group" + msg.id
    });
  }
  return acc;
};
var chatView = (messages) => messages.reduce(groupItems(messages.length), []);
var MessageReferenceComponent = class _MessageReferenceComponent extends ChatItem {
  localization;
  chatService;
  hostClass = true;
  message;
  constructor(localization, chatService) {
    super();
    this.localization = localization;
    this.chatService = chatService;
  }
  isOwnMessage(msg) {
    return isAuthor(this.chatService.authorId, msg);
  }
  textFor(key) {
    return this.localization.get(key);
  }
  focus() {
  }
  static ɵfac = function MessageReferenceComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MessageReferenceComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChatService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _MessageReferenceComponent,
    selectors: [["chat-message-reference-content"]],
    hostVars: 2,
    hostBindings: function MessageReferenceComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-message-reference-content", ctx.hostClass);
      }
    },
    inputs: {
      message: "message"
    },
    features: [ɵɵProvidersFeature([{
      provide: ChatItem,
      useExisting: forwardRef(() => _MessageReferenceComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 4,
    vars: 4,
    consts: [[1, "k-chat-file", 3, "chatFile"]],
    template: function MessageReferenceComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵconditionalCreate(0, MessageReferenceComponent_Conditional_0_Template, 1, 1);
        ɵɵconditionalCreate(1, MessageReferenceComponent_Conditional_1_Template, 1, 1, "li", 0);
        ɵɵconditionalCreate(2, MessageReferenceComponent_Conditional_2_Template, 1, 1);
        ɵɵconditionalCreate(3, MessageReferenceComponent_Conditional_3_Template, 1, 1);
      }
      if (rf & 2) {
        ɵɵconditional(ctx.message.text && !ctx.message.isDeleted ? 0 : -1);
        ɵɵadvance();
        ɵɵconditional(!ctx.message.text && !ctx.message.isDeleted && ctx.message.files && ctx.message.files.length > 0 ? 1 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.message.isDeleted && ctx.isOwnMessage(ctx.message) ? 2 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.message.isDeleted && !ctx.isOwnMessage(ctx.message) ? 3 : -1);
      }
    },
    dependencies: [ChatFileComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MessageReferenceComponent, [{
    type: Component,
    args: [{
      selector: "chat-message-reference-content",
      providers: [{
        provide: ChatItem,
        useExisting: forwardRef(() => MessageReferenceComponent)
      }],
      template: `
        @if (message.text && !message.isDeleted) {
          {{message.text}}
        }
        @if (!message.text && !message.isDeleted && message.files && message.files.length > 0) {
          <li class="k-chat-file" [chatFile]="message.files[0]">
          </li>
        }
        @if (message.isDeleted && isOwnMessage(message)) {
          {{ textFor('deletedMessageSenderText') }}
        }
        @if (message.isDeleted && !isOwnMessage(message)) {
          {{ textFor('deletedMessageReceiverText') }}
        }
        `,
      standalone: true,
      imports: [ChatFileComponent]
    }]
  }], () => [{
    type: LocalizationService
  }, {
    type: ChatService
  }], {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-message-reference-content"]
    }],
    message: [{
      type: Input
    }]
  });
})();
var MessageBoxComponent = class _MessageBoxComponent {
  chatService;
  cdr;
  element;
  renderer;
  borderColor = "inherit";
  messageBoxWrapperClass = true;
  messageBoxInput;
  fileSelectComponent;
  suggestedActionsComponent;
  authorId;
  autoScroll;
  suggestions;
  placeholder;
  inputValue = "";
  localization;
  messageBoxTemplate;
  suggestionTemplate;
  sendMessage = new EventEmitter();
  executeSuggestion = new EventEmitter();
  fileSelect = new EventEmitter();
  fileRemove = new EventEmitter();
  files = [];
  sendIcon = paperPlaneIcon;
  attachmentIcon = paperclipIcon;
  deleteIcon = xIcon;
  fileIcon = fileIcon;
  isListening = false;
  get reply() {
    return this.chatService.reply;
  }
  selectedItem;
  subs = new Subscription();
  constructor(chatService, cdr, element, renderer) {
    this.chatService = chatService;
    this.cdr = cdr;
    this.element = element;
    this.renderer = renderer;
  }
  ngOnInit() {
    const elRef = this.element.nativeElement;
    this.subs.add(this.renderer.listen(elRef, "focusout", (event) => this.onBlur(event)));
    this.subs.add(this.chatService.contextMenuAction$.subscribe((action) => {
      if (action.action.id === "reply") {
        this.messageBoxInput.focus();
      }
    }));
  }
  ngOnDestroy() {
    if (this.subs) {
      this.subs.unsubscribe();
    }
  }
  sendClick() {
    const hasMessage = this.inputValue?.trim() || this.files?.length;
    const isCustomDisabled = isPresent(this.sendButtonSettings?.disabled);
    if (!hasMessage && !isCustomDisabled) {
      return;
    }
    const message = __spreadValues(__spreadValues({
      id: guid(),
      text: this.inputValue,
      timestamp: /* @__PURE__ */ new Date(),
      author: {
        id: this.authorId
      }
    }, this.files && this.files.length > 0 && {
      files: this.files
    }), this.reply && {
      replyToId: this.reply.id
    });
    this.sendMessage.emit(new SendMessageEvent(message));
    this.inputValue = "";
    this.files = [];
    this.chatService.reply = null;
    this.messageBoxInput.focus();
    this.autoScroll = true;
  }
  inputKeydown(e) {
    if (e.code === Keys.Enter || e.code === Keys.NumpadEnter) {
      this.sendClick();
    }
  }
  textAreaKeydown(e) {
    const isEnter = e.code === Keys.Enter || e.code === Keys.NumpadEnter;
    if (!isEnter) {
      return;
    }
    const newLine = e.metaKey || e.ctrlKey;
    const enterOnly = !(e.shiftKey || e.metaKey || e.ctrlKey);
    if (enterOnly) {
      e.preventDefault();
      this.sendClick();
    }
    if (newLine) {
      this.inputValue += `\r
`;
    }
  }
  handleSpeechResult(event) {
    if (event.alternatives && event.alternatives.length > 0) {
      if (!isPresent(this.inputValue)) {
        this.inputValue = "";
      }
      const appendedValue = event.alternatives[0].transcript + " ";
      if (!appendedValue.trim()) {
        return;
      }
      this.inputValue += appendedValue;
      this.chatService.emit("inputValueChange", this.inputValue);
    }
  }
  textFor(key) {
    return this.localization.get(key);
  }
  removeReply() {
    this.chatService.reply = null;
  }
  onReplyReferenceClick(event) {
    event.stopPropagation();
    this.chatService.emit("replyReferenceClick", this.chatService.reply?.id);
  }
  handleFileSelect(event) {
    const processedFiles = event.files.map((currentFile) => {
      return {
        id: currentFile.uid,
        name: currentFile.name,
        extension: currentFile.extension,
        size: currentFile.size,
        type: currentFile.rawFile.type,
        rawFile: currentFile.rawFile
      };
    });
    this.files = [...this.files, ...processedFiles];
    this.fileSelect.emit(event);
  }
  selectFiles() {
    if (this.fileSelectComponent?.fileSelectInput) {
      this.fileSelectComponent.fileSelectInput.nativeElement.click();
    }
  }
  removeFile(index) {
    this.files = this.files.filter((_, i) => i !== index);
    const removedFile = this.files[index];
    this.fileRemove.emit(removedFile);
  }
  get speechToTextButtonSettings() {
    return this.chatService.enableSpeechToText;
  }
  get sendButtonSettings() {
    return this.chatService.sendButtonSettings;
  }
  get enableFileSelect() {
    return this.chatService.enableFileSelect;
  }
  get isDisabledSendButton() {
    if (isPresent(this.sendButtonSettings?.disabled)) {
      return this.sendButtonSettings.disabled;
    }
    const isEmptyInput = !this.inputValue?.length || !this.inputValue?.trim();
    const hasFiles = this.files?.length > 0;
    return isEmptyInput && !hasFiles || this.isListening;
  }
  select(item, event) {
    if (event) {
      const target = event.target;
      if (!target.classList.contains("k-suggestion")) {
        return;
      }
    }
    if (!this.chatService.toggleMessageState) {
      const prevItem = this.selectedItem;
      if (prevItem) {
        prevItem.selected = false;
      }
      if (item) {
        item.selected = true;
        this.selectedItem = item;
      }
      this.cdr.detectChanges();
    }
    this.chatService.toggleMessageState = false;
  }
  onBlur(args) {
    const next2 = args.relatedTarget || document.activeElement;
    const outside = !closest(next2, (node) => node === this.element.nativeElement);
    if (outside) {
      this.select(null);
    }
  }
  onInputValueChange(value2) {
    this.inputValue = value2;
    this.chatService.emit("inputValueChange", value2);
  }
  dispatchSuggestion(suggestion) {
    this.executeSuggestion.emit(suggestion);
  }
  static ɵfac = function MessageBoxComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MessageBoxComponent)(ɵɵdirectiveInject(ChatService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _MessageBoxComponent,
    selectors: [["kendo-message-box"]],
    viewQuery: function MessageBoxComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c104, 5)(_c116, 5)(SuggestedActionsComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.messageBoxInput = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.fileSelectComponent = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.suggestedActionsComponent = _t.first);
      }
    },
    hostVars: 4,
    hostBindings: function MessageBoxComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵstyleProp("border-color", ctx.borderColor);
        ɵɵclassProp("k-message-box-wrapper", ctx.messageBoxWrapperClass);
      }
    },
    inputs: {
      authorId: "authorId",
      autoScroll: "autoScroll",
      suggestions: "suggestions",
      placeholder: "placeholder",
      inputValue: "inputValue",
      localization: "localization",
      messageBoxTemplate: "messageBoxTemplate",
      suggestionTemplate: "suggestionTemplate"
    },
    outputs: {
      sendMessage: "sendMessage",
      executeSuggestion: "executeSuggestion",
      fileSelect: "fileSelect",
      fileRemove: "fileRemove"
    },
    decls: 5,
    vars: 5,
    consts: [["fileSelect", ""], ["suggestedActions", ""], ["messageBoxInput", ""], ["type", "suggestion", 3, "suggestions", "suggestionTemplate", "tabbable"], ["resizable", "none", 1, "k-message-box", 3, "rows", "inputAttributes", "placeholder", "showSuffixSeparator", "value"], [3, "ngTemplateOutlet"], [1, "k-hidden", 3, "select", "multiple", "showFileList"], ["type", "suggestion", 3, "dispatchSuggestion", "click", "focus", "suggestions", "suggestionTemplate", "tabbable"], ["resizable", "none", 1, "k-message-box", 3, "keydown", "valueChange", "rows", "inputAttributes", "placeholder", "showSuffixSeparator", "value"], ["kendoSpeechToTextButton", "", 3, "continuous", "disabled", "fillMode", "integrationMode", "interimResults", "lang", "maxAlternatives", "rounded", "size", "themeColor"], ["kendoButton", "", "icon", "attachment", "fillMode", "clear", 3, "svgIcon"], ["kendoButton", "", 3, "click", "fillMode", "themeColor", "rounded", "icon", "svgIcon", "tabindex"], [1, "k-message-reference", "k-message-reference-sender"], [1, "k-chat-file-wrapper"], [1, "k-chat-file", 3, "chatFile", "removable"], [1, "k-message-reference", "k-message-reference-sender", 3, "click"], [3, "message"], [1, "k-spacer"], ["kendoButton", "", "fillMode", "flat", 3, "click", "svgIcon"], [1, "k-chat-file", 3, "remove", "chatFile", "removable"], ["kendoSpeechToTextButton", "", 3, "result", "start", "end", "continuous", "disabled", "fillMode", "integrationMode", "interimResults", "lang", "maxAlternatives", "rounded", "size", "themeColor"], ["kendoButton", "", "icon", "attachment", "fillMode", "clear", 3, "click", "svgIcon"]],
    template: function MessageBoxComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵconditionalCreate(0, MessageBoxComponent_Conditional_0_Template, 2, 3, "kendo-chat-suggested-actions", 3);
        ɵɵconditionalCreate(1, MessageBoxComponent_Conditional_1_Template, 8, 22, "kendo-textarea", 4);
        ɵɵconditionalCreate(2, MessageBoxComponent_Conditional_2_Template, 1, 1, null, 5);
        ɵɵelementStart(3, "kendo-fileselect", 6, 0);
        ɵɵlistener("select", function MessageBoxComponent_Template_kendo_fileselect_select_3_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleFileSelect($event));
        });
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵconditional((ctx.suggestions == null ? null : ctx.suggestions.length) > 0 ? 0 : -1);
        ɵɵadvance();
        ɵɵconditional(!(ctx.messageBoxTemplate == null ? null : ctx.messageBoxTemplate.templateRef) ? 1 : -1);
        ɵɵadvance();
        ɵɵconditional((ctx.messageBoxTemplate == null ? null : ctx.messageBoxTemplate.templateRef) ? 2 : -1);
        ɵɵadvance();
        ɵɵproperty("multiple", true)("showFileList", false);
      }
    },
    dependencies: [ButtonComponent, FormsModule, NgTemplateOutlet, TextAreaComponent, MessageReferenceComponent, TextAreaSuffixComponent, TextAreaPrefixComponent, SpeechToTextButtonComponent, InputSpacerComponent, FileSelectComponent, SuggestedActionsComponent, ChatFileComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MessageBoxComponent, [{
    type: Component,
    args: [{
      selector: "kendo-message-box",
      template: `
    @if (suggestions?.length > 0) {
      <kendo-chat-suggested-actions
        #suggestedActions
        [suggestions]="suggestions"
        type="suggestion"
        [suggestionTemplate]="suggestionTemplate"
        [tabbable]="true"
        (dispatchSuggestion)="dispatchSuggestion($event)"
        (click)="select(suggestedActions, $event)"
        (focus)="select(suggestedActions, $event)"
      ></kendo-chat-suggested-actions>
    }
    
    @if (!messageBoxTemplate?.templateRef) {
      <kendo-textarea
        #messageBoxInput
        class="k-message-box"
        resizable="none"
        [rows]="3"
            [inputAttributes]="{
                'aria-label': textFor('messageBoxInputLabel')
            }"
        [placeholder]="placeholder || textFor('messagePlaceholder')"
        [showSuffixSeparator]="false"
        (keydown)="textAreaKeydown($event)"
        [value]="inputValue"
        (valueChange)="onInputValueChange($event)"
        >
        @if (reply || (files && files.length > 0)) {
          <kendo-textarea-prefix>
            @if (reply) {
              <div class="k-message-reference k-message-reference-sender" (click)="onReplyReferenceClick($event)">
                <chat-message-reference-content [message]="reply"></chat-message-reference-content>
                <span class="k-spacer"></span>
                <button
                  kendoButton
                  [attr.title]="textFor('removeReplyTitle')"
                  [svgIcon]="deleteIcon"
                  (click)="removeReply()"
                  fillMode="flat"
                ></button>
              </div>
            }
            <ul class="k-chat-file-wrapper">
              @for (file of files; track file; let i = $index) {
                <li class="k-chat-file"
                  [chatFile]="file"
                  [removable]="true"
                  (remove)="removeFile(i)"
                ></li>
              }
            </ul>
          </kendo-textarea-prefix>
        }
        <kendo-textarea-suffix>
          @if (speechToTextButtonSettings) {
            <button
              kendoSpeechToTextButton
              [attr.title]="textFor('speechToTextButtonTitle')"
              [continuous]="speechToTextButtonSettings?.continuous"
              [disabled]="speechToTextButtonSettings?.disabled"
              [fillMode]="speechToTextButtonSettings?.fillMode ?? 'clear'"
              [integrationMode]="speechToTextButtonSettings?.integrationMode ?? 'webSpeech'"
              [interimResults]="speechToTextButtonSettings?.interimResults"
              [lang]="speechToTextButtonSettings?.lang"
              [maxAlternatives]="speechToTextButtonSettings?.maxAlternatives"
              [rounded]="speechToTextButtonSettings?.rounded"
              [size]="speechToTextButtonSettings?.size"
              [themeColor]="speechToTextButtonSettings?.themeColor"
              (result)="handleSpeechResult($event)"
              (start)="isListening = true"
              (end)="isListening = false"
            ></button>
          }
          @if (enableFileSelect) {
            <button
              kendoButton
              [attr.title]="textFor('fileSelectButtonTitle')"
              [svgIcon]="attachmentIcon"
              icon="attachment"
              fillMode="clear"
              (click)="selectFiles()"
            ></button>
          }
          <kendo-input-spacer></kendo-input-spacer>
          <button
            kendoButton
            [fillMode]="sendButtonSettings?.fillMode"
            [themeColor]="sendButtonSettings?.themeColor"
            [rounded]="sendButtonSettings?.rounded"
            [class]="sendButtonSettings?.buttonClass || 'k-chat-send'"
            [icon]="sendButtonSettings?.icon"
            [svgIcon]="sendButtonSettings?.svgIcon"
            [tabindex]="0"
            [attr.title]="textFor('send')"
            [class.k-disabled]="isDisabledSendButton"
            [attr.aria-disabled]="isDisabledSendButton"
            (click)="sendClick()"
            >
          </button>
        </kendo-textarea-suffix>
      </kendo-textarea>
    }
    
    @if (messageBoxTemplate?.templateRef) {
      <ng-template [ngTemplateOutlet]="messageBoxTemplate?.templateRef"></ng-template>
    }
    
    <kendo-fileselect
      #fileSelect
      class="k-hidden"
      [multiple]="true"
      [showFileList]="false"
      (select)="handleFileSelect($event)"
    ></kendo-fileselect>
    `,
      standalone: true,
      imports: [ButtonComponent, FormsModule, NgTemplateOutlet, TextAreaComponent, MessageReferenceComponent, TextAreaSuffixComponent, TextAreaPrefixComponent, SpeechToTextButtonComponent, InputSpacerComponent, FileSelectComponent, SuggestedActionsComponent, ChatFileComponent]
    }]
  }], () => [{
    type: ChatService
  }, {
    type: ChangeDetectorRef
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }], {
    borderColor: [{
      type: HostBinding,
      args: ["style.border-color"]
    }],
    messageBoxWrapperClass: [{
      type: HostBinding,
      args: ["class.k-message-box-wrapper"]
    }],
    messageBoxInput: [{
      type: ViewChild,
      args: ["messageBoxInput"]
    }],
    fileSelectComponent: [{
      type: ViewChild,
      args: ["fileSelect"]
    }],
    suggestedActionsComponent: [{
      type: ViewChild,
      args: [SuggestedActionsComponent]
    }],
    authorId: [{
      type: Input
    }],
    autoScroll: [{
      type: Input
    }],
    suggestions: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    inputValue: [{
      type: Input
    }],
    localization: [{
      type: Input
    }],
    messageBoxTemplate: [{
      type: Input
    }],
    suggestionTemplate: [{
      type: Input
    }],
    sendMessage: [{
      type: Output
    }],
    executeSuggestion: [{
      type: Output
    }],
    fileSelect: [{
      type: Output
    }],
    fileRemove: [{
      type: Output
    }]
  });
})();
var MessageContentTemplateDirective = class _MessageContentTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function MessageContentTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MessageContentTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _MessageContentTemplateDirective,
    selectors: [["", "kendoChatMessageContentTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MessageContentTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoChatMessageContentTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var ChatTimestampTemplateDirective = class _ChatTimestampTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function ChatTimestampTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ChatTimestampTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ChatTimestampTemplateDirective,
    selectors: [["", "kendoChatTimestampTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChatTimestampTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoChatTimestampTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var ChatStatusTemplateDirective = class _ChatStatusTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function ChatStatusTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ChatStatusTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ChatStatusTemplateDirective,
    selectors: [["", "kendoChatStatusTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChatStatusTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoChatStatusTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var MessageTemplateDirective = class _MessageTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function MessageTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MessageTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _MessageTemplateDirective,
    selectors: [["", "kendoChatMessageTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MessageTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoChatMessageTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var AuthorMessageContentTemplateDirective = class _AuthorMessageContentTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function AuthorMessageContentTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AuthorMessageContentTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _AuthorMessageContentTemplateDirective,
    selectors: [["", "kendoChatAuthorMessageContentTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AuthorMessageContentTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoChatAuthorMessageContentTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var ReceiverMessageContentTemplateDirective = class _ReceiverMessageContentTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function ReceiverMessageContentTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ReceiverMessageContentTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ReceiverMessageContentTemplateDirective,
    selectors: [["", "kendoChatReceiverMessageContentTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ReceiverMessageContentTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoChatReceiverMessageContentTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var ReceiverMessageTemplateDirective = class _ReceiverMessageTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function ReceiverMessageTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ReceiverMessageTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ReceiverMessageTemplateDirective,
    selectors: [["", "kendoChatReceiverMessageTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ReceiverMessageTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoChatReceiverMessageTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var AuthorMessageTemplateDirective = class _AuthorMessageTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function AuthorMessageTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AuthorMessageTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _AuthorMessageTemplateDirective,
    selectors: [["", "kendoChatAuthorMessageTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AuthorMessageTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoChatAuthorMessageTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var MessageComponent = class _MessageComponent extends ChatItem {
  element;
  intl;
  chatService;
  localization;
  cdr;
  set message(value2) {
    this._message = value2;
  }
  get message() {
    return this._message;
  }
  tabbable;
  authorMessageContentTemplate;
  receiverMessageContentTemplate;
  messageContentTemplate;
  authorMessageTemplate;
  receiverMessageTemplate;
  messageTemplate;
  statusTemplate;
  showMessageTime = true;
  authorId;
  cssClass = true;
  get removedClass() {
    return this.message.isDeleted;
  }
  onKeyDown(event) {
    if (this.message.isDeleted) {
      return;
    }
    if (!this.chatService.allowMessageCollapse) {
      return;
    }
    this.onExpandableKeydown(event);
  }
  selected;
  get tabIndex() {
    return this.tabbable ? "0" : "-1";
  }
  expandIcon = chevronDownIcon;
  collapseIcon = chevronUpIcon;
  downloadIcon = downloadIcon;
  isMessageExpanded = false;
  showExpandCollapseIcon = false;
  fileActions = [];
  toolbarActions = [];
  parts = [];
  get useCustomBubbleTemplate() {
    return !!this.getActiveBubbleTemplate();
  }
  get useCustomContentTemplate() {
    return !!this.getActiveContentTemplate();
  }
  get hasMessageContent() {
    return !!(this.message?.text || this.message?.files?.length > 0);
  }
  get hasFiles() {
    return this.message?.files?.length > 0;
  }
  get hasMultipleFiles() {
    return this.message?.files?.length > 1;
  }
  get isActiveMessage() {
    return this.chatService.active && this.message?.id === this.chatService.activeMessage?.id;
  }
  get isMessageExpandable() {
    const isOwn = this.isOwnMessage(this.message);
    const messageSettings = isOwn ? this.chatService.authorMessageSettings : this.chatService.receiverMessageSettings;
    if (isPresent(messageSettings?.allowMessageCollapse)) {
      return messageSettings.allowMessageCollapse;
    }
    return this.chatService.allowMessageCollapse || false;
  }
  get showToolbar() {
    if (this.message?.isDeleted) {
      return false;
    }
    const hasComponentActions = this.chatService.messageToolbarActions?.length > 0;
    const hasMessageActions = this.toolbarActions?.length > 0;
    return hasComponentActions || hasMessageActions;
  }
  subs = new Subscription();
  _message;
  constructor(element, intl, chatService, localization, cdr) {
    super();
    this.element = element;
    this.intl = intl;
    this.chatService = chatService;
    this.localization = localization;
    this.cdr = cdr;
  }
  ngOnInit() {
    this.fileActions = this.getFileActions();
    this.toolbarActions = this.getToolbarActions();
    const settingsChange$ = this.isOwnMessage(this.message) ? this.chatService.authorMessageSettingsChange$ : this.chatService.receiverMessageSettingsChange$;
    this.subs.add(settingsChange$.subscribe(() => {
      this.fileActions = this.getFileActions();
      this.toolbarActions = this.getToolbarActions();
      setTimeout(() => {
        this.showExpandCollapseIcon = this.calculateExpandCollapseIconVisibility();
      });
    }));
    this.subs.add(this.chatService.allowMessageCollapseChange$.subscribe(() => {
      setTimeout(() => {
        this.showExpandCollapseIcon = this.calculateExpandCollapseIconVisibility();
      });
    }));
    if (this.message.id) {
      this.chatService.registerMessageElement(this.message.id, this.element);
    }
    this.parts = this.getFormattedTextParts(this.message.text);
  }
  ngAfterViewInit() {
    this.showExpandCollapseIcon = this.calculateExpandCollapseIconVisibility();
    this.cdr.detectChanges();
  }
  ngOnDestroy() {
    if (this.message.id) {
      this.chatService.unregisterMessageElement(this.message.id);
    }
    this.subs.unsubscribe();
  }
  calculateExpandCollapseIconVisibility() {
    if (this.isMessageExpanded) {
      return true;
    }
    const bubbleContent = this.element.nativeElement.querySelector(".k-bubble-content");
    if (!bubbleContent) {
      return false;
    }
    const hasVerticalOverflow = bubbleContent.scrollHeight > bubbleContent.clientHeight;
    const hasHorizontalOverflow = bubbleContent.scrollWidth > bubbleContent.clientWidth;
    if (this.useCustomContentTemplate) {
      return hasVerticalOverflow || hasHorizontalOverflow;
    }
    const messageText = this.element.nativeElement.querySelector(".k-chat-bubble-text");
    const hasTextOverflow = messageText?.scrollWidth > messageText?.clientWidth;
    return hasTextOverflow || hasVerticalOverflow || hasHorizontalOverflow;
  }
  getActiveBubbleTemplate() {
    const isOwn = this.isOwnMessage(this.message);
    if (isOwn && this.authorMessageTemplate) {
      return this.authorMessageTemplate;
    }
    if (!isOwn && this.receiverMessageTemplate) {
      return this.receiverMessageTemplate;
    }
    if (this.messageTemplate) {
      return this.messageTemplate;
    }
    return null;
  }
  getActiveContentTemplate() {
    const isOwn = this.isOwnMessage(this.message);
    if (isOwn && this.authorMessageContentTemplate) {
      return this.authorMessageContentTemplate;
    }
    if (!isOwn && this.receiverMessageContentTemplate) {
      return this.receiverMessageContentTemplate;
    }
    if (this.messageContentTemplate) {
      return this.messageContentTemplate;
    }
    return null;
  }
  getDeletedMessageText() {
    const isOwn = this.isOwnMessage(this.message);
    return isOwn ? this.textFor("deletedMessageSenderText") : this.textFor("deletedMessageReceiverText");
  }
  textFor(key) {
    return this.localization.get(key);
  }
  formatTimeStamp(date) {
    return this.intl.formatDate(date, {
      datetime: "short"
    });
  }
  focus() {
    this.element.nativeElement.focus();
  }
  onDownloadAll() {
    this.chatService.emit("fileDownload", {
      files: this.message.files,
      message: this.message
    });
  }
  toggleMessageState(event) {
    event.stopImmediatePropagation();
    this.isMessageExpanded = !this.isMessageExpanded;
    this.chatService.toggleMessageState = false;
  }
  onExpandableKeydown(event) {
    const key = normalizeKeys(event);
    const isFileActionButton = event.target.closest(FILE_ACTION_BTN_SELECTOR) || event.target.closest(DOWNLOAD_ALL_SELECTOR);
    if (!isFileActionButton && (key === Keys.Enter || key === Keys.Space)) {
      event.preventDefault();
      this.chatService.toggleMessageState = true;
      this.toggleMessageState(event);
    }
  }
  onToolbarAction(event, action, message) {
    event.stopImmediatePropagation();
    this.chatService.emit("toolbarAction", {
      action,
      message
    });
  }
  onFileAction(action, file) {
    if (action.originalAction.id === "download") {
      this.chatService.emit("fileDownload", {
        files: [file],
        message: this.message
      });
    }
    this.chatService.emit("fileAction", {
      action: action.originalAction,
      file
    });
  }
  getMessageById(id3) {
    return this.chatService.getMessageById(id3);
  }
  onReplyReferenceClick(event, replyToId) {
    event.stopPropagation();
    this.chatService.emit("replyReferenceClick", replyToId);
  }
  handleMenuClose(event) {
    if (event) {
      const originalEvent = event.originalEvent;
      if (originalEvent) {
        this.onActionButtonClick(originalEvent);
      }
    }
    this.chatService.active = false;
    this.chatService.emit("contextMenuVisibilityChange", false);
    if (this.chatService.selectOnMenuClose) {
      this.selected = true;
      this.focus();
    }
  }
  onActionButtonClick(event) {
    const clickOutsideMessage = event instanceof MouseEvent && !event.target?.closest(".k-chat-bubble");
    const menuItemClick = event instanceof MouseEvent && event.target?.closest(MENU_ITEM_SELECTOR);
    if (clickOutsideMessage && !menuItemClick) {
      this.chatService.selectOnMenuClose = false;
    }
  }
  handleMenuOpen() {
    this.chatService.selectOnMenuClose = this.selected;
    this.chatService.emit("contextMenuVisibilityChange", true);
  }
  onActionPopupChange(expanded) {
    if (expanded) {
      this.chatService.active = true;
      this.handleMenuOpen();
    } else {
      this.handleMenuClose();
    }
  }
  isOwnMessage(msg) {
    return isAuthor(this.authorId, msg);
  }
  getFormattedTextParts(text) {
    if (!text) {
      return [];
    }
    const parts = [];
    const urlMatches = Array.from(text.matchAll(URL_REGEX));
    let lastIndex = 0;
    for (const match of urlMatches) {
      const url = match[1];
      const matchStart = match.index;
      if (!isPresent(matchStart)) {
        continue;
      }
      if (matchStart > lastIndex) {
        parts.push({
          type: "text",
          content: text.substring(lastIndex, matchStart)
        });
      }
      parts.push({
        type: "link",
        content: url,
        href: url
      });
      lastIndex = matchStart + match[0].length;
    }
    if (lastIndex < text.length) {
      parts.push({
        type: "text",
        content: text.substring(lastIndex)
      });
    }
    return parts;
  }
  getMessageSettings() {
    return this.isOwnMessage(this.message) ? this.chatService.authorMessageSettings : this.chatService.receiverMessageSettings;
  }
  getToolbarActions() {
    const messageSettings = this.getMessageSettings();
    return messageSettings?.messageToolbarActions?.length ? messageSettings.messageToolbarActions : this.chatService.messageToolbarActions || [];
  }
  getFileActions() {
    const messageSettings = this.getMessageSettings();
    const actions = messageSettings?.fileActions?.length ? messageSettings.fileActions : this.chatService.fileActions || [];
    return transformActions(actions);
  }
  static ɵfac = function MessageComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MessageComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(ChatService), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _MessageComponent,
    selectors: [["kendo-chat-message"]],
    hostVars: 5,
    hostBindings: function MessageComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("keydown", function MessageComponent_keydown_HostBindingHandler($event) {
          return ctx.onKeyDown($event);
        });
      }
      if (rf & 2) {
        ɵɵattribute("tabIndex", ctx.tabIndex);
        ɵɵclassProp("k-message", ctx.cssClass)("k-message-removed", ctx.removedClass);
      }
    },
    inputs: {
      message: "message",
      tabbable: "tabbable",
      authorMessageContentTemplate: "authorMessageContentTemplate",
      receiverMessageContentTemplate: "receiverMessageContentTemplate",
      messageContentTemplate: "messageContentTemplate",
      authorMessageTemplate: "authorMessageTemplate",
      receiverMessageTemplate: "receiverMessageTemplate",
      messageTemplate: "messageTemplate",
      statusTemplate: "statusTemplate",
      showMessageTime: "showMessageTime",
      authorId: "authorId"
    },
    features: [ɵɵProvidersFeature([{
      provide: ChatItem,
      useExisting: forwardRef(() => _MessageComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 3,
    vars: 3,
    consts: [["fillMode", "flat", 1, "k-chat-message-toolbar"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "k-message-time"], [1, "k-chat-bubble", "k-bubble"], [1, "k-message-status"], [1, "k-typing-indicator"], [1, "k-chat-bubble", "k-bubble", 3, "ngClass"], [1, "k-bubble-content"], [1, "k-bubble-expandable-indicator"], [1, "k-bubble-expandable-indicator", 3, "mousedown", "click"], [3, "name", "svgIcon"], [1, "k-chat-file-wrapper", 3, "ngClass"], [1, "k-chat-download-button-wrapper"], [1, "k-message-reference", "k-message-reference-receiver"], [1, "k-chat-bubble-text"], [1, "k-message-reference", "k-message-reference-receiver", 3, "click"], [3, "message"], ["target", "_blank", 3, "href"], [1, "k-chat-file", 3, "chatFile", "fileActions"], [1, "k-chat-file", 3, "actionClick", "actionsToggle", "actionButtonClick", "chatFile", "fileActions"], ["kendoButton", "", "fillMode", "flat", "icon", "download", 1, "k-chat-download-button", 3, "click", "svgIcon"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["fillMode", "flat", 3, "icon", "svgIcon", "disabled", "title"], ["fillMode", "flat", 3, "click", "icon", "svgIcon", "disabled", "title"]],
    template: function MessageComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵconditionalCreate(0, MessageComponent_Conditional_0_Template, 1, 4, "ng-container");
        ɵɵconditionalCreate(1, MessageComponent_Conditional_1_Template, 4, 4);
        ɵɵconditionalCreate(2, MessageComponent_Conditional_2_Template, 3, 0, "kendo-toolbar", 0);
      }
      if (rf & 2) {
        ɵɵconditional(ctx.useCustomBubbleTemplate ? 0 : -1);
        ɵɵadvance();
        ɵɵconditional(!ctx.useCustomBubbleTemplate ? 1 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.showToolbar ? 2 : -1);
      }
    },
    dependencies: [NgClass, NgTemplateOutlet, IconWrapperComponent, ButtonComponent, ChatFileComponent, ToolBarComponent, ToolBarButtonComponent, MessageReferenceComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MessageComponent, [{
    type: Component,
    args: [{
      selector: "kendo-chat-message",
      providers: [{
        provide: ChatItem,
        useExisting: forwardRef(() => MessageComponent)
      }],
      template: `
        @if (useCustomBubbleTemplate) {
          <ng-container *ngTemplateOutlet="getActiveBubbleTemplate()?.templateRef; context: { $implicit: message };"></ng-container>
        }

        @if (!useCustomBubbleTemplate) {
          @if (chatService.timestampVisibility === 'focus' && message.timestamp) {
            <time
              [attr.aria-hidden]="!selected"
              class="k-message-time"
              >
              {{ formatTimeStamp(message.timestamp) }}
            </time>
          }
          @if (message.typing) {
            <div class="k-chat-bubble k-bubble">
              <div class="k-typing-indicator" [attr.tabindex]="'-1'">
                <span></span>
                <span></span>
                <span></span>
              </div>
            </div>
          }
          @if (!message.typing) {
            @if (useCustomContentTemplate) {
              <div
                class="k-chat-bubble k-bubble"
                [attr.tabindex]="0"
                    [ngClass]="{
                        'k-bubble-expandable': isMessageExpandable,
                        'k-expanded': isMessageExpanded,
                        'k-selected': selected,
                        'k-focus': selected,
                        'k-active': isActiveMessage
                    }"
                >
                <div class="k-bubble-content">
                  <ng-container *ngTemplateOutlet="getActiveContentTemplate()?.templateRef; context: { $implicit: message };"></ng-container>
                </div>
                @if (isMessageExpandable && showExpandCollapseIcon) {
                  <span
                    class="k-bubble-expandable-indicator"
                    [attr.tabindex]="'0'"
                    [attr.role]="'button'"
                    [attr.title]="isMessageExpanded ? textFor('collapseTitle') : textFor('expandTitle')"
                    (mousedown)="chatService.toggleMessageState = true"
                    (click)="toggleMessageState($event)"
                    >
                    <kendo-icon-wrapper
                      [name]="isMessageExpanded ? 'chevron-up' : 'chevron-down'"
                      [svgIcon]="isMessageExpanded ? collapseIcon : expandIcon"
                      >
                    </kendo-icon-wrapper>
                  </span>
                }
              </div>
            }
            @if (!useCustomContentTemplate && hasMessageContent) {
              <div
                class="k-chat-bubble k-bubble"
                [attr.tabindex]="0"
                    [ngClass]="{
                        'k-bubble-expandable': isMessageExpandable,
                        'k-expanded': isMessageExpanded,
                        'k-selected': selected,
                        'k-focus': selected,
                        'k-active': isActiveMessage
                    }"
                >
                <div class="k-bubble-content">
                  @if (message.text || message.isDeleted) {
                    @if (message.replyToId && !message.isDeleted) {
                      <div
                        class="k-message-reference k-message-reference-receiver"
                        (click)="onReplyReferenceClick($event, message.replyToId)"
                        >
                        <chat-message-reference-content [message]="getMessageById(message.replyToId)"></chat-message-reference-content>
                      </div>
                    }
                    @if (message.isDeleted) {
                      <span class="k-chat-bubble-text">
                        {{ getDeletedMessageText() }}
                      </span>
                    }
                    @if (!message.isDeleted && parts.length > 0) {
                      <span class="k-chat-bubble-text">
                        @for (part of parts; track part) {
                          @if (part.type === 'text') {{{part.content}}}
                          @if (part.type === 'link') {<a [href]="part.href" target="_blank">{{part.content}}</a>}
                        }
                      </span>
                    }
                  }
                  @if (hasFiles && !message.isDeleted) {
                    <ul
                      class="k-chat-file-wrapper"
                            [ngClass]="{
                                'k-chat-files-wrap': chatService.messageFilesLayout === 'wrap',
                                'k-chat-files-horizontal': chatService.messageFilesLayout === 'horizontal'
                            }"
                      >
                      @for (file of message.files; track file) {
                        <li
                          class="k-chat-file"
                          [chatFile]="file"
                          [fileActions]="fileActions"
                          (actionClick)="onFileAction($event, file)"
                          (actionsToggle)="onActionPopupChange($event)"
                          (actionButtonClick)="onActionButtonClick($event)"
                        ></li>
                      }
                    </ul>
                  }
                  @if (hasMultipleFiles && !message.isDeleted) {
                    <div class="k-chat-download-button-wrapper">
                      <button
                        kendoButton
                        class="k-chat-download-button"
                        fillMode="flat"
                        icon="download"
                        [svgIcon]="downloadIcon"
                        [attr.title]="textFor('downloadAllFilesText')"
                        (click)="onDownloadAll()"
                      >{{ textFor('downloadAllFilesText') }}</button>
                    </div>
                  }
                </div>
                @if (isMessageExpandable && showExpandCollapseIcon) {
                  <span
                    class="k-bubble-expandable-indicator"
                    [attr.tabindex]="'0'"
                    [attr.role]="'button'"
                    [attr.title]="isMessageExpanded ? textFor('collapseTitle') : textFor('expandTitle')"
                    (mousedown)="chatService.toggleMessageState = true"
                    (click)="toggleMessageState($event)"
                    >
                    <kendo-icon-wrapper
                      [name]="isMessageExpanded ? 'chevron-up' : 'chevron-down'"
                      [svgIcon]="isMessageExpanded ? collapseIcon : expandIcon"
                      >
                    </kendo-icon-wrapper>
                  </span>
                }
              </div>
            }
          }
          @if (message.status) {
            <span class="k-message-status">
              @if (statusTemplate?.templateRef) {
                <ng-template
                  [ngTemplateOutlet]="statusTemplate.templateRef"
                  [ngTemplateOutletContext]="{ $implicit: message.status, message }"
                  >
                </ng-template>
              }
              @if (!statusTemplate?.templateRef) {
                {{ message.status }}
              }
            </span>
          }
        }
        @if (showToolbar) {
          <kendo-toolbar class="k-chat-message-toolbar" fillMode="flat">
            @for (action of toolbarActions; track action) {
              <kendo-toolbar-button
                fillMode="flat"
                [icon]="action.icon"
                [svgIcon]="action.svgIcon"
                [disabled]="action.disabled"
                [title]="action.label"
                (click)="onToolbarAction($event, action, message)"
                >
              </kendo-toolbar-button>
            }
          </kendo-toolbar>
        }
        `,
      standalone: true,
      imports: [NgClass, NgTemplateOutlet, IconWrapperComponent, KENDO_BUTTONS, ChatFileComponent, ToolBarComponent, ToolBarButtonComponent, MessageReferenceComponent]
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: IntlService
  }, {
    type: ChatService
  }, {
    type: LocalizationService
  }, {
    type: ChangeDetectorRef
  }], {
    message: [{
      type: Input
    }],
    tabbable: [{
      type: Input
    }],
    authorMessageContentTemplate: [{
      type: Input
    }],
    receiverMessageContentTemplate: [{
      type: Input
    }],
    messageContentTemplate: [{
      type: Input
    }],
    authorMessageTemplate: [{
      type: Input
    }],
    receiverMessageTemplate: [{
      type: Input
    }],
    messageTemplate: [{
      type: Input
    }],
    statusTemplate: [{
      type: Input
    }],
    showMessageTime: [{
      type: Input
    }],
    authorId: [{
      type: Input
    }],
    cssClass: [{
      type: HostBinding,
      args: ["class.k-message"]
    }],
    removedClass: [{
      type: HostBinding,
      args: ["class.k-message-removed"]
    }],
    onKeyDown: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }],
    tabIndex: [{
      type: HostBinding,
      args: ["attr.tabIndex"]
    }]
  });
})();
var AttachmentComponent = class _AttachmentComponent {
  set attachment(value2) {
    this._attachment = value2;
    this.context = {
      $implicit: this.attachment
    };
  }
  get attachment() {
    return this._attachment;
  }
  template;
  get image() {
    return this.contentType.startsWith("image/");
  }
  get unknown() {
    return !this.image;
  }
  context;
  get contentType() {
    return this.attachment.contentType || "";
  }
  _attachment;
  static ɵfac = function AttachmentComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AttachmentComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _AttachmentComponent,
    selectors: [["kendo-chat-attachment"]],
    inputs: {
      attachment: "attachment",
      template: "template"
    },
    decls: 2,
    vars: 2,
    consts: [[1, "k-card"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "k-card-body"], [1, "k-card-title"], [1, "k-card-subtitle"]],
    template: function AttachmentComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵconditionalCreate(0, AttachmentComponent_Conditional_0_Template, 1, 2, "ng-container");
        ɵɵconditionalCreate(1, AttachmentComponent_Conditional_1_Template, 6, 4, "div", 0);
      }
      if (rf & 2) {
        ɵɵconditional(ctx.template ? 0 : -1);
        ɵɵadvance();
        ɵɵconditional(!ctx.template ? 1 : -1);
      }
    },
    dependencies: [NgTemplateOutlet],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AttachmentComponent, [{
    type: Component,
    args: [{
      selector: "kendo-chat-attachment",
      template: `
        @if (template) {
          <ng-container *ngTemplateOutlet="template.templateRef; context: context;">
          </ng-container>
        }
        
        @if (!template) {
          <div class="k-card">
            <div class="k-card-body">
              @if (attachment.title) {
                <h5 class="k-card-title">
                  {{ attachment.title }}
                </h5>
              }
              @if (attachment.subtitle) {
                <h6 class="k-card-subtitle">
                  {{ attachment.subtitle }}
                </h6>
              }
              @if (image) {
                <img [attr.src]="attachment.content" />
              }
              @if (unknown) {
                {{ attachment.content }}
              }
            </div>
          </div>
        }
        `,
      standalone: true,
      imports: [NgTemplateOutlet]
    }]
  }], null, {
    attachment: [{
      type: Input
    }],
    template: [{
      type: Input
    }]
  });
})();
var MessageAttachmentsComponent = class _MessageAttachmentsComponent extends ChatItem {
  zone;
  localizationService;
  /**
   * @hidden
   */
  chevronLeftIcon = chevronLeftIcon;
  /**
   * @hidden
   */
  chevronRightIcon = chevronRightIcon;
  attachments;
  layout;
  tabbable;
  template;
  localization;
  get carousel() {
    return this.layout !== "list";
  }
  deck;
  items;
  scrollPosition = 0;
  selectedIndex = 0;
  scrollSubscription;
  direction;
  get showLeftArrow() {
    return this.carousel && (this.direction === "rtl" ? this.scrollPosition > -1 : this.scrollPosition > 0);
  }
  get showRightArrow() {
    return this.carousel && (this.direction === "rtl" ? this.scrollPosition < 0 : this.scrollPosition < 1);
  }
  carouselKeyHandlers = {
    [Keys.ArrowLeft]: (e) => this.navigateTo(e, this.direction === "rtl" ? 1 : -1),
    [Keys.ArrowRight]: (e) => this.navigateTo(e, this.direction === "rtl" ? -1 : 1)
  };
  listKeyHandlers = {
    [Keys.ArrowUp]: (e) => this.navigateTo(e, -1),
    [Keys.ArrowDown]: (e) => this.navigateTo(e, 1)
  };
  constructor(zone, localizationService) {
    super();
    this.zone = zone;
    this.localizationService = localizationService;
    this.direction = this.localizationService.rtl ? "rtl" : "ltr";
  }
  ngAfterViewInit() {
    this.zone.runOutsideAngular(() => {
      const scrollDebounceTime = 100;
      this.scrollSubscription = fromEvent(this.deck.nativeElement, "scroll").pipe(debounceTime(scrollDebounceTime)).subscribe(() => this.onScroll());
    });
  }
  ngOnDestroy() {
    this.scrollSubscription.unsubscribe();
  }
  isSelected(index) {
    return this.selectedIndex === index;
  }
  itemKeydown(e, attachment) {
    const keyHandlers = this.layout === "list" ? this.listKeyHandlers : this.carouselKeyHandlers;
    const code = normalizeKeys(e);
    const handler = keyHandlers[code];
    if (handler) {
      handler(e, attachment);
    }
  }
  itemClick(index) {
    this.select(index);
  }
  focus() {
    this.select(this.selectedIndex);
  }
  scrollTo(dir) {
    const el = this.deck.nativeElement;
    const scrollStep = el.scrollWidth / this.items.length;
    const max = el.scrollWidth - el.offsetWidth;
    const pos = el.scrollLeft + scrollStep * dir;
    el.scrollLeft = this.direction === "rtl" ? Math.min(0, max, pos) : Math.max(0, Math.min(max, pos));
  }
  select(index) {
    this.selectedIndex = index;
    const item = this.items.toArray()[index];
    if (item) {
      item.nativeElement.focus();
    }
  }
  navigateTo(e, offset3) {
    const prevIndex = this.selectedIndex;
    const nextIndex = Math.max(0, Math.min(prevIndex + offset3, this.items.length - 1));
    if (nextIndex !== prevIndex) {
      this.select(nextIndex);
      e.preventDefault();
    }
  }
  onScroll() {
    const el = this.deck.nativeElement;
    if (el.scrollWidth === 0) {
      return;
    }
    const pos = el.scrollLeft / (el.scrollWidth - el.offsetWidth);
    if (pos !== this.scrollPosition) {
      this.zone.run(() => {
        this.scrollPosition = pos;
      });
    }
  }
  textFor(key) {
    return this.localization.get(key);
  }
  static ɵfac = function MessageAttachmentsComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MessageAttachmentsComponent)(ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _MessageAttachmentsComponent,
    selectors: [["kendo-chat-message-attachments"]],
    viewQuery: function MessageAttachmentsComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c163, 7, ElementRef)(_c84, 5, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.deck = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.items = _t);
      }
    },
    hostVars: 2,
    hostBindings: function MessageAttachmentsComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-card-deck-scrollwrap", ctx.carousel);
      }
    },
    inputs: {
      attachments: "attachments",
      layout: "layout",
      tabbable: "tabbable",
      template: "template",
      localization: "localization"
    },
    features: [ɵɵProvidersFeature([{
      provide: ChatItem,
      useExisting: forwardRef(() => _MessageAttachmentsComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 6,
    vars: 6,
    consts: [["deck", ""], ["item", ""], ["kendoButton", "", "tabindex", "-1", "icon", "chevron-left", 3, "svgIcon"], [3, "attachment", "template", "k-selected", "k-focus", "k-card-wrap", "k-first", "k-last"], ["kendoButton", "", "tabindex", "-1", "icon", "chevron-right", 3, "svgIcon"], ["kendoButton", "", "tabindex", "-1", "icon", "chevron-left", 3, "click", "svgIcon"], [3, "click", "keydown", "attachment", "template"], ["kendoButton", "", "tabindex", "-1", "icon", "chevron-right", 3, "click", "svgIcon"]],
    template: function MessageAttachmentsComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵconditionalCreate(0, MessageAttachmentsComponent_Conditional_0_Template, 1, 2, "button", 2);
        ɵɵelementStart(1, "div", null, 0);
        ɵɵrepeaterCreate(3, MessageAttachmentsComponent_For_4_Template, 2, 13, "kendo-chat-attachment", 3, ɵɵrepeaterTrackByIdentity);
        ɵɵelementEnd();
        ɵɵconditionalCreate(5, MessageAttachmentsComponent_Conditional_5_Template, 1, 2, "button", 4);
      }
      if (rf & 2) {
        ɵɵconditional(ctx.showLeftArrow ? 0 : -1);
        ɵɵadvance();
        ɵɵclassProp("k-card-deck", ctx.carousel)("k-card-list", !ctx.carousel);
        ɵɵadvance(2);
        ɵɵrepeater(ctx.attachments);
        ɵɵadvance(2);
        ɵɵconditional(ctx.showRightArrow ? 5 : -1);
      }
    },
    dependencies: [ButtonComponent, AttachmentComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MessageAttachmentsComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: ChatItem,
        useExisting: forwardRef(() => MessageAttachmentsComponent)
      }],
      selector: "kendo-chat-message-attachments",
      template: `
        @if (showLeftArrow) {
          <button
            (click)="scrollTo(-1)"
            kendoButton
            tabindex="-1"
            [attr.title]="textFor('messageAttachmentLeftArrow')"
            [svgIcon]="chevronLeftIcon"
            icon="chevron-left"
            >
          </button>
        }
        <div
          #deck
          [class.k-card-deck]="carousel"
          [class.k-card-list]="!carousel"
          >
          @for (att of attachments; track att; let index = $index; let first = $first; let last = $last) {
            <kendo-chat-attachment #item
              [attachment]="att"
              [template]="template"
              [class.k-selected]="isSelected(index)"
              [class.k-focus]="isSelected(index)"
              [class.k-card-wrap]="true"
              [class.k-first]="first"
              [class.k-last]="last"
              [attr.tabindex]="tabbable && isSelected(index) ? '0' : '-1'"
              (click)="itemClick(index)"
              (keydown)="itemKeydown($event, att)"
              >
            </kendo-chat-attachment>
          }
        </div>
        @if (showRightArrow) {
          <button
            (click)="scrollTo(1)"
            kendoButton
            tabindex="-1"
            [attr.title]="textFor('messageAttachmentRightArrow')"
            [svgIcon]="chevronRightIcon"
            icon="chevron-right"
            >
          </button>
        }
        `,
      standalone: true,
      imports: [ButtonComponent, AttachmentComponent]
    }]
  }], () => [{
    type: NgZone
  }, {
    type: LocalizationService
  }], {
    attachments: [{
      type: Input
    }],
    layout: [{
      type: Input
    }],
    tabbable: [{
      type: Input
    }],
    template: [{
      type: Input
    }],
    localization: [{
      type: Input
    }],
    carousel: [{
      type: HostBinding,
      args: ["class.k-card-deck-scrollwrap"]
    }],
    deck: [{
      type: ViewChild,
      args: ["deck", {
        read: ElementRef,
        static: true
      }]
    }],
    items: [{
      type: ViewChildren,
      args: ["item", {
        read: ElementRef
      }]
    }]
  });
})();
var ChatUserStatusTemplateDirective = class _ChatUserStatusTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function ChatUserStatusTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ChatUserStatusTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ChatUserStatusTemplateDirective,
    selectors: [["", "kendoChatUserStatusTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChatUserStatusTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoChatUserStatusTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var MessageListComponent = class _MessageListComponent {
  element;
  intl;
  renderer;
  chatService;
  cdr;
  set messages(value2) {
    const data = value2 || [];
    this.view = chatView(data);
    this._messages = data;
  }
  get messages() {
    return this._messages;
  }
  attachmentTemplate;
  authorMessageContentTemplate;
  receiverMessageContentTemplate;
  messageContentTemplate;
  authorMessageTemplate;
  receiverMessageTemplate;
  messageTemplate;
  timestampTemplate;
  statusTemplate;
  userStatusTemplate;
  localization;
  authorId;
  executeAction = new EventEmitter();
  navigate = new EventEmitter();
  resize = new EventEmitter();
  items;
  cssClass = true;
  view = [];
  _messages;
  subs = new Subscription();
  selectedItem;
  keyActions = {
    [Keys.Home]: (_) => this.onHomeOrEndKeyDown("home"),
    [Keys.End]: (_) => this.onHomeOrEndKeyDown("end"),
    [Keys.ArrowUp]: (e) => this.navigateTo(e, -1),
    [Keys.ArrowDown]: (e) => this.navigateTo(e, 1),
    [Keys.Tab]: (e) => this.onTabKeyDown(e),
    [Keys.F10]: (e) => e.shiftKey && this.openContextMenu(e)
  };
  constructor(element, intl, renderer, chatService, cdr) {
    this.element = element;
    this.intl = intl;
    this.renderer = renderer;
    this.chatService = chatService;
    this.cdr = cdr;
  }
  ngOnInit() {
    const elRef = this.element.nativeElement;
    this.subs.add(this.renderer.listen(elRef, "keydown", (event) => this.onKeydown(event)));
    this.subs.add(this.renderer.listen(elRef, "focusout", (event) => this.onBlur(event)));
    this.subs.add(this.renderer.listen(elRef, "click", (event) => {
      const messageComponent = this.findMessageComponentFromEvent(event);
      if (messageComponent) {
        this.select(messageComponent, event);
      }
    }));
    this.subs.add(this.renderer.listen(elRef, "contextmenu", (event) => {
      event.preventDefault();
      const messageComponent = this.findMessageComponentFromEvent(event);
      if (messageComponent) {
        this.onContextMenuClick(messageComponent.message, event, messageComponent);
      }
    }));
    this.subs.add(this.chatService.replyReferenceClick$.subscribe((messageId) => {
      this.scrollToAndSelectMessage(messageId);
    }));
    this.subs.add(this.chatService.contextMenuVisibilityChange$.subscribe((isVisible3) => {
      this.handleMenuClose(isVisible3);
    }));
  }
  ngAfterViewInit() {
    this.selectedItem = this.items.last;
  }
  ngOnDestroy() {
    this.subs.unsubscribe();
  }
  onResize() {
    this.resize.emit();
  }
  onClick(message, event) {
    this.select(message, event);
  }
  onContextMenuClick(message, event, messageElement) {
    this.chatService.calculateContextMenuActions(this.isOwnMessage(message));
    if (this.chatService.calculatedContextMenuActions.length > 0) {
      this.chatService.messagesContextMenu.show({
        left: event.pageX,
        top: event.pageY
      });
      this.chatService.activeMessageElement = messageElement;
      this.chatService.activeMessage = message;
      this.chatService.active = true;
      this.chatService.selectOnMenuClose = this.chatService.activeMessageElement?.selected;
      this.chatService.emit("contextMenuVisibilityChange", true);
    }
  }
  formatTimeStamp(date) {
    return this.intl.formatDate(date, {
      date: "full"
    });
  }
  calculateMessageWidthMode(message) {
    const isOwn = this.isOwnMessage(message);
    const messageSettings = isOwn ? this.chatService.authorMessageSettings : this.chatService.receiverMessageSettings;
    if (messageSettings?.messageWidthMode) {
      return messageSettings.messageWidthMode === "full";
    }
    return this.chatService.messageWidthMode === "full";
  }
  onKeydown(e) {
    const code = normalizeKeys(e);
    const action = this.keyActions[code];
    if (action) {
      action(e);
    }
  }
  onBlur(args) {
    const next2 = args.relatedTarget || document.activeElement;
    const outside = !closest4(next2, (node) => node === this.element.nativeElement);
    const isActionClick = closest4(next2, (node) => node?.classList?.contains("k-context-menu-popup")) || closest4(next2, (node) => node?.classList?.contains("k-menu-popup"));
    if (outside && !isActionClick) {
      this.select(null);
    }
  }
  isOwnMessage(msg) {
    return isAuthor(this.authorId, msg);
  }
  showGroupAuthor(group2) {
    const messageSettings = this.isOwnMessage(group2.messages[0]) ? this.chatService.authorMessageSettings : this.chatService.receiverMessageSettings;
    if (isPresent(messageSettings?.showUsername)) {
      return messageSettings.showUsername && group2.author.name;
    }
    return this.chatService.showUsername && group2.author.name;
  }
  showGroupAvatar(group2) {
    const messageSettings = this.isOwnMessage(group2.messages[0]) ? this.chatService.authorMessageSettings : this.chatService.receiverMessageSettings;
    if (isPresent(messageSettings?.showAvatar)) {
      return messageSettings.showAvatar && group2.author.avatarUrl;
    }
    return this.chatService.showAvatar && group2.author.avatarUrl;
  }
  dispatchAction(action, message) {
    const args = new ExecuteActionEvent(action, message);
    this.executeAction.emit(args);
  }
  trackGroup(_index, item) {
    return item.trackBy;
  }
  select(item, event) {
    if (event) {
      const target = event.target;
      if (target.classList.contains("k-suggestion") || target.closest(DOWNLOAD_ALL_SELECTOR) || target.closest(FILE_ACTION_BTN_SELECTOR)) {
        return;
      }
    }
    if (!this.chatService.toggleMessageState) {
      const prevItem = this.selectedItem;
      if (prevItem) {
        prevItem.selected = false;
      }
      if (item) {
        item.selected = true;
        this.selectedItem = item;
      }
      this.cdr.detectChanges();
    }
    this.chatService.toggleMessageState = false;
  }
  last(items) {
    if (!items || items.length === 0) {
      return;
    }
    const messageGroups = items.filter((item) => item.type === "message-group");
    const lastMessageGroup = messageGroups[messageGroups.length - 1].messages;
    return lastMessageGroup[lastMessageGroup.length - 1];
  }
  handleMenuClose(state2) {
    if (!state2) {
      this.select(null);
    }
  }
  textFor(key) {
    return this.localization.get(key);
  }
  onHomeOrEndKeyDown(key) {
    const items = this.items.toArray();
    if (key === "home") {
      items[0].focus();
    } else {
      items[items.length - 1].focus();
    }
  }
  onTabKeyDown(event) {
    const item = this.items.toArray()[this.items.length - 1];
    const isLastItemQuickReply = item instanceof SuggestedActionsComponent;
    const isLastItemMessage = item instanceof MessageComponent;
    event.target.blur();
    if (isLastItemQuickReply || isLastItemMessage) {
      this.select(item);
      item.focus();
      this.navigate.emit();
    }
  }
  navigateTo(e, offset3) {
    const items = this.items.toArray();
    const prevItem = this.selectedItem;
    const prevIndex = items.indexOf(prevItem);
    const nextIndex = Math.max(0, Math.min(prevIndex + offset3, this.items.length - 1));
    const nextItem = items[nextIndex];
    const isNextItemQuickReply = nextItem instanceof SuggestedActionsComponent;
    if (nextItem !== prevItem) {
      if (isNextItemQuickReply) {
        nextItem.items.toArray()[0]?.nativeElement.focus();
      }
      this.select(nextItem);
      nextItem.focus();
      this.navigate.emit();
      e.preventDefault();
    }
  }
  scrollToAndSelectMessage(messageId) {
    this.chatService.scrollToMessage(messageId);
    const message = this.chatService.getMessageById(messageId);
    const chatItem = this.items.find((item) => item instanceof MessageComponent && item.message === message);
    if (chatItem) {
      this.select(chatItem);
    }
  }
  openContextMenu(event) {
    event.preventDefault();
    const messageComponent = this.findMessageComponentFromActiveElement();
    if (messageComponent) {
      const messageContentElement = messageComponent.element.nativeElement.querySelector(".k-chat-bubble");
      if (messageContentElement) {
        const rect = messageContentElement?.getBoundingClientRect();
        this.onContextMenuClick(messageComponent.message, {
          pageX: rect.left + rect.width / 2 + window.scrollX,
          pageY: rect.top + rect.height / 2 + window.scrollY
        }, messageComponent);
      } else {
        const messageElement = messageComponent.element.nativeElement;
        const rect = messageElement?.getBoundingClientRect();
        this.onContextMenuClick(messageComponent.message, {
          pageX: rect.left + rect.width / 2 + window.scrollX,
          pageY: rect.top + rect.height / 2 + window.scrollY
        }, messageComponent);
      }
    }
  }
  findMessageComponentFromActiveElement() {
    const activeElement = document.activeElement;
    const messageComponents = this.items.filter((item) => item instanceof MessageComponent);
    return messageComponents.find((component) => {
      const componentElement = component.element?.nativeElement;
      return componentElement && (componentElement === activeElement || componentElement.contains(activeElement));
    });
  }
  findMessageComponentFromEvent(event) {
    const target = event.target;
    const clickedElement = target?.closest(".k-message");
    if (!clickedElement) return void 0;
    const messageComponents = this.items.filter((item) => item instanceof MessageComponent);
    return messageComponents.find((component) => {
      const componentElement = component.element?.nativeElement;
      return componentElement && (componentElement === clickedElement || componentElement.contains(clickedElement));
    });
  }
  static ɵfac = function MessageListComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MessageListComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ChatService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _MessageListComponent,
    selectors: [["kendo-chat-message-list"]],
    viewQuery: function MessageListComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(ChatItem, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.items = _t);
      }
    },
    hostVars: 2,
    hostBindings: function MessageListComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-message-list-content", ctx.cssClass);
      }
    },
    inputs: {
      messages: "messages",
      attachmentTemplate: "attachmentTemplate",
      authorMessageContentTemplate: "authorMessageContentTemplate",
      receiverMessageContentTemplate: "receiverMessageContentTemplate",
      messageContentTemplate: "messageContentTemplate",
      authorMessageTemplate: "authorMessageTemplate",
      receiverMessageTemplate: "receiverMessageTemplate",
      messageTemplate: "messageTemplate",
      timestampTemplate: "timestampTemplate",
      statusTemplate: "statusTemplate",
      userStatusTemplate: "userStatusTemplate",
      localization: "localization",
      authorId: "authorId"
    },
    outputs: {
      executeAction: "executeAction",
      navigate: "navigate",
      resize: "resize"
    },
    decls: 3,
    vars: 0,
    consts: [["message", ""], ["attachments", ""], ["actions", ""], [3, "resize"], [1, "k-timestamp"], [1, "k-message-group", 3, "k-message-group-sender", "k-message-group-receiver", "k-no-avatar", "k-message-group-full-width"], [3, "attachments", "layout", "localization", "tabbable", "template"], ["type", "action", 3, "actions", "tabbable"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "k-message-group"], [1, "k-avatar", "k-avatar-md", "k-avatar-solid", "k-avatar-solid-primary", "k-rounded-full"], [1, "k-chat-user-status-wrapper"], [1, "k-message-group-content"], [1, "k-message-author"], [1, "k-avatar-image"], [3, "alt"], [1, "k-chat-user-status"], [3, "message", "tabbable", "authorMessageContentTemplate", "receiverMessageContentTemplate", "messageContentTemplate", "authorMessageTemplate", "receiverMessageTemplate", "messageTemplate", "statusTemplate", "authorId"], [3, "attachment", "template"], [3, "src"], [3, "click", "focus", "attachments", "layout", "localization", "tabbable", "template"], ["type", "action", 3, "dispatchAction", "click", "focus", "actions", "tabbable"]],
    template: function MessageListComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵrepeaterCreate(0, MessageListComponent_For_1_Template, 4, 1, null, null, ctx.trackGroup, true);
        ɵɵelementStart(2, "kendo-resize-sensor", 3);
        ɵɵlistener("resize", function MessageListComponent_Template_kendo_resize_sensor_resize_2_listener() {
          return ctx.onResize();
        });
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵrepeater(ctx.view);
      }
    },
    dependencies: [NgTemplateOutlet, MessageComponent, AttachmentComponent, MessageAttachmentsComponent, SuggestedActionsComponent, ResizeSensorComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MessageListComponent, [{
    type: Component,
    args: [{
      selector: "kendo-chat-message-list",
      template: `
        @for (group of view; track trackGroup($index, group); let lastGroup = $last) {
          @switch (group.type) {
            @case ('date-marker') {
              <div
                class="k-timestamp"
                >
                @if (timestampTemplate?.templateRef) {
                  <ng-container
                    [ngTemplateOutlet]="timestampTemplate.templateRef"
                    [ngTemplateOutletContext]="{ $implicit: group.timestamp }"
                    >
                  </ng-container>
                }
                @if (!timestampTemplate?.templateRef) {
                  {{ formatTimeStamp(group.timestamp) }}
                }
              </div>
            }
            @case ('message-group') {
              <div
                class="k-message-group"
                [class.k-message-group-sender]="isOwnMessage(group.messages[0])"
                [class.k-message-group-receiver]="!isOwnMessage(group.messages[0])"
                [class.k-no-avatar]="!showGroupAvatar(group)"
                [class.k-message-group-full-width]="calculateMessageWidthMode(group.messages[0])"
                >
                @if (!userStatusTemplate?.templateRef && showGroupAvatar(group)) {
                  <div
                    class="k-avatar k-avatar-md k-avatar-solid k-avatar-solid-primary k-rounded-full"
                    >
                    <span class="k-avatar-image">
                      <img
                        [attr.src]="group.author.avatarUrl"
                        [alt]="group.author.avatarAltText"
                        />
                    </span>
                  </div>
                }
                @if (showGroupAvatar(group) && userStatusTemplate?.templateRef) {
                  <div class="k-chat-user-status-wrapper">
                    <div
                      class="k-avatar k-avatar-md k-avatar-solid k-avatar-solid-primary k-rounded-full"
                      >
                      <span class="k-avatar-image">
                        <img
                          [attr.src]="group.author.avatarUrl"
                          [alt]="group.author.avatarAltText"
                          />
                      </span>
                    </div>
                    @if (userStatusTemplate?.templateRef) {
                      <div class="k-chat-user-status">
                        <ng-template
                          [ngTemplateOutlet]="userStatusTemplate.templateRef"
                          [ngTemplateOutletContext]="{ $implicit: group.messages.at(-1) }"
                          >
                        </ng-template>
                      </div>
                    }
                  </div>
                }
                <div class="k-message-group-content">
                  @if (showGroupAuthor(group)) {
                    <p class="k-message-author">{{ group.author.name }}</p>
                  }
                  @for (msg of group.messages; track msg; let firstMessage = $first; let lastMessage = $last) {
                    @if (msg.user?.avatarUrl) {
                      <div
                        class="k-avatar k-avatar-md k-avatar-solid k-avatar-solid-primary k-rounded-full"
                        >
                        <span class="k-avatar-image">
                          <img [src]="msg.user?.avatarUrl">
                        </span>
                      </div>
                    }
                    <kendo-chat-message #message
                      [message]="msg"
                      [tabbable]="lastGroup && lastMessage"
                      [authorMessageContentTemplate]="authorMessageContentTemplate"
                      [receiverMessageContentTemplate]="receiverMessageContentTemplate"
                      [messageContentTemplate]="messageContentTemplate"
                      [authorMessageTemplate]="authorMessageTemplate"
                      [receiverMessageTemplate]="receiverMessageTemplate"
                      [messageTemplate]="messageTemplate"
                      [statusTemplate]="statusTemplate"
                      [authorId]="authorId"
                      >
                    </kendo-chat-message>
                    @if (msg.attachments && msg.attachments.length === 1) {
                      <kendo-chat-attachment
                        [attachment]="msg.attachments[0]"
                        [template]="attachmentTemplate"
                        >
                      </kendo-chat-attachment>
                    }
                  }
                </div>
              </div>
            }
            @case ('attachment-group') {
              <kendo-chat-message-attachments #attachments
                [attachments]="group.attachments"
                [layout]="group.attachmentLayout"
                [localization]="localization"
                [tabbable]="lastGroup"
                [template]="attachmentTemplate"
                (click)="select(attachments)"
                (focus)="select(attachments)"
                >
              </kendo-chat-message-attachments>
            }
            @case ('action-group') {
              <kendo-chat-suggested-actions #actions
                [actions]="group.actions"
                type="action"
                [tabbable]="lastGroup"
                (dispatchAction)="dispatchAction($event, last(view))"
                (click)="select(actions, $event)"
                (focus)="select(actions, $event)"
                >
              </kendo-chat-suggested-actions>
            }
          }
        }
        <kendo-resize-sensor (resize)="onResize()">
        </kendo-resize-sensor>
        `,
      standalone: true,
      imports: [NgTemplateOutlet, MessageComponent, AttachmentComponent, MessageAttachmentsComponent, SuggestedActionsComponent, ResizeSensorComponent]
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: IntlService
  }, {
    type: Renderer2
  }, {
    type: ChatService
  }, {
    type: ChangeDetectorRef
  }], {
    messages: [{
      type: Input
    }],
    attachmentTemplate: [{
      type: Input
    }],
    authorMessageContentTemplate: [{
      type: Input
    }],
    receiverMessageContentTemplate: [{
      type: Input
    }],
    messageContentTemplate: [{
      type: Input
    }],
    authorMessageTemplate: [{
      type: Input
    }],
    receiverMessageTemplate: [{
      type: Input
    }],
    messageTemplate: [{
      type: Input
    }],
    timestampTemplate: [{
      type: Input
    }],
    statusTemplate: [{
      type: Input
    }],
    userStatusTemplate: [{
      type: Input
    }],
    localization: [{
      type: Input
    }],
    authorId: [{
      type: Input
    }],
    executeAction: [{
      type: Output
    }],
    navigate: [{
      type: Output
    }],
    resize: [{
      type: Output
    }],
    items: [{
      type: ViewChildren,
      args: [ChatItem]
    }],
    cssClass: [{
      type: HostBinding,
      args: ["class.k-message-list-content"]
    }]
  });
})();
var maxDelta = 2;
var ScrollAnchorDirective = class _ScrollAnchorDirective {
  element;
  zone;
  renderer;
  autoScroll = true;
  autoScrollChange = new EventEmitter();
  overflowAnchor = "none";
  scrolling = false;
  unsubscribe;
  constructor(element, zone, renderer) {
    this.element = element;
    this.zone = zone;
    this.renderer = renderer;
  }
  ngOnInit() {
    this.zone.runOutsideAngular(() => {
      this.unsubscribe = this.renderer.listen(this.element.nativeElement, "scroll", () => this.onScroll());
    });
  }
  ngAfterViewInit() {
    this.scrollToBottom();
  }
  ngOnDestroy() {
    if (this.unsubscribe) {
      this.unsubscribe();
    }
  }
  onScroll() {
    if (this.scrolling) {
      return;
    }
    const el = this.element.nativeElement;
    const bottom = el.scrollTop + el.offsetHeight;
    const height2 = el.scrollHeight;
    const atBottom = height2 - bottom < maxDelta;
    if (this.autoScroll !== atBottom) {
      this.zone.run(() => {
        this.autoScroll = atBottom;
        this.autoScrollChange.emit(this.autoScroll);
      });
    }
  }
  scrollToBottom() {
    if (!this.autoScroll) {
      return;
    }
    const el = this.element.nativeElement;
    el.scrollTop = el.scrollHeight - el.clientHeight;
    this.scrolling = true;
    this.zone.runOutsideAngular(() => setTimeout(() => this.scrolling = false, 1e3));
  }
  static ɵfac = function ScrollAnchorDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ScrollAnchorDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ScrollAnchorDirective,
    selectors: [["", "kendoChatScrollAnchor", ""]],
    hostVars: 2,
    hostBindings: function ScrollAnchorDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵstyleProp("overflow-anchor", ctx.overflowAnchor);
      }
    },
    inputs: {
      autoScroll: "autoScroll"
    },
    outputs: {
      autoScrollChange: "autoScrollChange"
    },
    exportAs: ["scrollAnchor"]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollAnchorDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoChatScrollAnchor]",
      exportAs: "scrollAnchor",
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NgZone
  }, {
    type: Renderer2
  }], {
    autoScroll: [{
      type: Input
    }],
    autoScrollChange: [{
      type: Output
    }],
    overflowAnchor: [{
      type: HostBinding,
      args: ["style.overflow-anchor"]
    }]
  });
})();
var Messages$1 = class Messages6 extends ComponentMessages {
  /**
   * Sets the text that displays when the sender deletes a message.
   */
  deletedMessageSenderText;
  /**
   * Sets the text that displays when the receiver deletes a message.
   */
  deletedMessageReceiverText;
  /**
   * Sets the text that displays in the download section of the message.
   * This message displays below all files in the message.
   */
  downloadAllFilesText;
  /**
   * Sets the placeholder text for the message text input.
   */
  messagePlaceholder;
  /**
   * Sets the text for the **Send** button.
   */
  send;
  /**
   * Sets the label for the message list.
   */
  messageListLabel;
  /**
   * Sets the label for the message input box.
   */
  messageBoxInputLabel;
  /**
   * Sets the text for the left arrow of the message attachments.
   */
  messageAttachmentLeftArrow;
  /**
   * Sets the text for the right arrow of the message attachments.
   */
  messageAttachmentRightArrow;
  /**
   * Sets the Speech to Text button title.
   */
  speechToTextButtonTitle;
  /**
   * Sets the File Select button title.
   */
  fileSelectButtonTitle;
  /**
   * Sets the title of the icon that removes the reply reference in the Message Box.
   */
  removeReplyTitle;
  /**
   * Sets the title of the icon that removes a selected file in the Message Box.
   */
  removeFileTitle;
  /**
   * Sets the title of the icon that shows the message can expand.
   */
  expandTitle;
  /**
   * Sets the title of the icon that shows the message can collapse.
   */
  collapseTitle;
  /**
   * Sets the title of the DropDownButton that opens the File actions.
   */
  fileActionsTitle;
  /**
   * Sets the title of the button that shows the **Scroll right** when the suggestions list is scrollable with buttons.
   */
  nextSuggestionsButtonTitle;
  /**
   * Sets the title of the button that shows the **Scroll left** when the suggestions list is scrollable with buttons.
   */
  previousSuggestionsButtonTitle;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵMessages_BaseFactory;
    return function Messages_Factory(__ngFactoryType__) {
      return (ɵMessages_BaseFactory || (ɵMessages_BaseFactory = ɵɵgetInheritedFactory(Messages6)))(__ngFactoryType__ || Messages6);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: Messages6,
    selectors: [["kendoConversationalUIMessages"]],
    inputs: {
      deletedMessageSenderText: "deletedMessageSenderText",
      deletedMessageReceiverText: "deletedMessageReceiverText",
      downloadAllFilesText: "downloadAllFilesText",
      messagePlaceholder: "messagePlaceholder",
      send: "send",
      messageListLabel: "messageListLabel",
      messageBoxInputLabel: "messageBoxInputLabel",
      messageAttachmentLeftArrow: "messageAttachmentLeftArrow",
      messageAttachmentRightArrow: "messageAttachmentRightArrow",
      speechToTextButtonTitle: "speechToTextButtonTitle",
      fileSelectButtonTitle: "fileSelectButtonTitle",
      removeReplyTitle: "removeReplyTitle",
      removeFileTitle: "removeFileTitle",
      expandTitle: "expandTitle",
      collapseTitle: "collapseTitle",
      fileActionsTitle: "fileActionsTitle",
      nextSuggestionsButtonTitle: "nextSuggestionsButtonTitle",
      previousSuggestionsButtonTitle: "previousSuggestionsButtonTitle"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Messages$1, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line @angular-eslint/directive-selector
      selector: "kendoConversationalUIMessages"
    }]
  }], null, {
    deletedMessageSenderText: [{
      type: Input
    }],
    deletedMessageReceiverText: [{
      type: Input
    }],
    downloadAllFilesText: [{
      type: Input
    }],
    messagePlaceholder: [{
      type: Input
    }],
    send: [{
      type: Input
    }],
    messageListLabel: [{
      type: Input
    }],
    messageBoxInputLabel: [{
      type: Input
    }],
    messageAttachmentLeftArrow: [{
      type: Input
    }],
    messageAttachmentRightArrow: [{
      type: Input
    }],
    speechToTextButtonTitle: [{
      type: Input
    }],
    fileSelectButtonTitle: [{
      type: Input
    }],
    removeReplyTitle: [{
      type: Input
    }],
    removeFileTitle: [{
      type: Input
    }],
    expandTitle: [{
      type: Input
    }],
    collapseTitle: [{
      type: Input
    }],
    fileActionsTitle: [{
      type: Input
    }],
    nextSuggestionsButtonTitle: [{
      type: Input
    }],
    previousSuggestionsButtonTitle: [{
      type: Input
    }]
  });
})();
var LocalizedMessagesDirective$1 = class LocalizedMessagesDirective5 extends Messages$1 {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function LocalizedMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || LocalizedMessagesDirective5)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: LocalizedMessagesDirective5,
    selectors: [["", "kendoChatLocalizedMessages", ""]],
    features: [ɵɵProvidersFeature([{
      provide: Messages$1,
      useExisting: forwardRef(() => LocalizedMessagesDirective5)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalizedMessagesDirective$1, [{
    type: Directive,
    args: [{
      providers: [{
        provide: Messages$1,
        useExisting: forwardRef(() => LocalizedMessagesDirective$1)
      }],
      selector: "[kendoChatLocalizedMessages]",
      standalone: true
    }]
  }], () => [{
    type: LocalizationService
  }], null);
})();
var ChatHeaderTemplateDirective = class _ChatHeaderTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function ChatHeaderTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ChatHeaderTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ChatHeaderTemplateDirective,
    selectors: [["", "kendoChatHeaderTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChatHeaderTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoChatHeaderTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var NoDataTemplateDirective = class _NoDataTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function NoDataTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NoDataTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _NoDataTemplateDirective,
    selectors: [["", "kendoChatNoDataTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NoDataTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoChatNoDataTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var ChatComponent = class _ChatComponent {
  localization;
  zone;
  renderer;
  element;
  chatService;
  /**
   * Sets the Chat messages.
   * Accepts an array of `Message` objects, but can also accept custom data types.
   * For more information, check [Data Binding](slug:databinding_chat) section in the documentation.
   */
  messages;
  /**
   * Sets the ID that represents the local user.
   */
  authorId;
  /**
   * Determines the type of input used in the message box.
   * ([see example](slug:message_chat)).
   * @default 'textarea'
   *
   * @hidden
   */
  messageBoxType = "textarea";
  /**
   * Sets the height of the Chat component.
   * Accepts a string with CSS units (for example, `'400px'`, `'50%'`) or a number (interpreted as pixels).
   * The minimum height is `600px`.
   */
  height;
  /**
   * Sets the width of the Chat component.
   * Accepts a string with CSS units (for example, `'400px'`, `'50%'`) or a number (interpreted as pixels).
   * The minimum width is `320px`.
   */
  width;
  /**
   * Sets the placeholder text for the message input box.
   */
  placeholder;
  /**
   * Controls the width of the message between the predefined options.
   *
   * @default 'standard'
   */
  messageWidthMode = "standard";
  /**
   * Controls the visibility of timestamps in messages.
   *
   * @default 'focus'
   */
  timestampVisibility = "focus";
  /**
   * Controls the visibility of usernames in messages.
   * When set to `true`, the username displays above each message bubble.
   *
   * @default true
   */
  showUsername = true;
  /**
   * Controls the avatar visibility for the messages.
   * When set to `true`, the user avatar displays next to each message bubble.
   *
   * @default true
   */
  showAvatar = true;
  /**
   * Enables the expand or collapse functionality for messages.
   *
   * @default false
   */
  allowMessageCollapse = false;
  /**
   * Sets the Speech to Text button settings.
   *
   * @default true
   */
  enableSpeechToText = true;
  /**
   * Sets the File Select settings.
   *
   * @default true
   */
  enableFileSelect = true;
  /**
   * Sets the actions of the message toolbar.
   * These actions display in the message toolbar and let you perform specific operations on the message.
   *
   * @default []
   */
  messageToolbarActions = [];
  /**
   * Sets the value of the Message Box.
   *
   * @default ''
   */
  inputValue = "";
  /**
   * Sets the settings for the author's messages.
   */
  authorMessageSettings;
  /**
   * Sets the settings for the receivers' messages.
   */
  receiverMessageSettings;
  /**
   * Sets the default actions that display in the message context menu.
   *
   * @default [{ id: 'copy', label: 'Copy', icon: 'copy', svgIcon: copyIcon, disabled: false }, { id: 'reply', label: 'Reply', icon: 'undo', svgIcon: undoIcon, disabled: false }]
   */
  defaultContextMenuActions = CONTEXT_MENU_ACTIONS;
  /**
   * Sets the actions that display in the message as a context menu.
   * These actions display as menu items and let you perform specific operations on the message.
   * The default actions are `copy` and `reply` and are defined by their `id`.
   */
  set messageContextMenuActions(actions) {
    this._messageContextMenuActions = this.mergeWithDefaultActions(actions, CONTEXT_MENU_ACTIONS);
  }
  get messageContextMenuActions() {
    return this._messageContextMenuActions;
  }
  /**
   * Sets the default actions that display in the file actions DropDownButton.
   *
   * @default [{ id: 'download', label: 'Download', icon: 'download', svgIcon: downloadIcon, disabled: false }]
   */
  defaultFileActions = FILE_ACTIONS;
  /**
   * Sets the actions that display in the file as items of a DropDownButton.
   * These actions display when you click the file DropDownButton and let you perform specific operations on the file.
   * The default action is `download` and is defined by its `id`.
   *
   * @default [{ id: 'download', label: 'Download', icon: 'download', svgIcon: downloadIcon, disabled: false }]
   */
  set fileActions(actions) {
    this._fileActions = this.mergeWithDefaultActions(actions, FILE_ACTIONS);
  }
  get fileActions() {
    return this._fileActions;
  }
  /**
   * Sets the layout of the files in the message bubble.
   *
   * @default 'vertical'
   */
  set messageFilesLayout(layout) {
    this.chatService.messageFilesLayout = layout;
  }
  /**
   * Sets the layout of the suggestions above the message input box.
   *
   * @default 'scroll'
   */
  set suggestionsLayout(layoutMode) {
    if (layoutMode) {
      this.chatService.suggestionsLayout = layoutMode;
    }
  }
  /**
   * Sets the layout of the quick actions suggested below the messages.
   *
   * @default 'scroll'
   */
  set quickActionsLayout(layoutMode) {
    if (layoutMode) {
      this.chatService.quickActionsLayout = layoutMode;
    }
  }
  /**
   * Sets the suggestions that display in the message input box.
   * Suggestions display as a list of clickable items that let you quickly insert predefined text into the message input.
   *
   * @default []
   */
  suggestions = [];
  /**
   * Sets the send button settings for the Chat component.
   * Allows customization of the send button appearance, icons and disabled state.
   *
   * @default { fillMode: 'solid', rounded: 'full', size: 'medium', themeColor: 'primary', icon: 'paper-plane', svgIcon: paperPlaneIcon}
   */
  sendButtonSettings = SEND_BTN_DEFAULT_SETTINGS;
  /**
   * Sets the names of the model fields from which the Chat reads its data.
   * Lets you map custom data types to the expected `Message` format.
   */
  set modelFields(value2) {
    this._modelFields = __spreadValues(__spreadValues({}, defaultModelFields2), value2);
  }
  get modelFields() {
    return this._modelFields;
  }
  /**
   * Fires when the user sends a message by clicking the **Send** button or pressing **Enter**.
   *
   * The message is not automatically added to the `messages` array.
   */
  sendMessage = new EventEmitter();
  /**
   * Fires when the user clicks a quick action button in the message toolbar.
   */
  toolbarActionClick = new EventEmitter();
  /**
   * Fires when the user clicks an action in the message context menu.
   */
  contextMenuActionClick = new EventEmitter();
  /**
   * Fires when the user clicks an action in the file context menu.
   */
  fileActionClick = new EventEmitter();
  /**
   * Fires when the user clicks an action in the file context menu.
   */
  download = new EventEmitter();
  /**
   * Fires when the user clicks a quick action button.
   * The Chat internally handles [known actions](slug:api_conversational-ui_actiontype) such as `reply`, `openUrl`, and `call`.
   *
   * The event is preventable. Calling [`preventDefault`](https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault) suppresses the built-in action.
   */
  executeAction = new EventEmitter();
  /**
   * Fires when the user clicks a suggestion in the message input box.
   */
  suggestionExecute = new EventEmitter();
  /**
   * Fires when the user selects a file in the message input box.
   */
  fileSelect = new EventEmitter();
  /**
   * Fires when the user removes a file from the message input box.
   */
  fileRemove = new EventEmitter();
  /**
   * Fires when the user unpins the pinned message.
   * This event triggers when the user clicks the delete button on the pinned message.
   */
  unpin = new EventEmitter();
  /**
   * Fires when the user types in the message input box.
   */
  inputValueChange = new EventEmitter();
  get className() {
    return "k-chat";
  }
  get dirAttr() {
    return this.direction;
  }
  set messagesContextMenu(contextMenu) {
    this.chatService.messagesContextMenu = contextMenu;
  }
  attachmentTemplate;
  chatHeaderTemplate;
  chatNoDataTemplate;
  authorMessageContentTemplate;
  receiverMessageContentTemplate;
  messageContentTemplate;
  authorMessageTemplate;
  receiverMessageTemplate;
  messageTemplate;
  timestampTemplate;
  suggestionTemplate;
  statusTemplate;
  messageBoxTemplate;
  userStatusTemplate;
  messageBox;
  /**
   * @hidden
   */
  messageList;
  /**
   * @hidden
   * Returns processed messages when model fields are used, otherwise returns original messages.
   */
  get processedMessages() {
    if (!this.messages || this.messages.length === 0) {
      return [];
    }
    if (this._modelFields && Object.keys(this._modelFields).some((key) => this._modelFields[key] !== defaultModelFields2[key])) {
      if (this.messages !== this._lastMessagesReference || this._modelFields !== this._lastModelFields) {
        this._cachedProcessedMessages = processMessages(this.messages, this._modelFields);
        this._lastMessagesReference = this.messages;
        this._lastModelFields = this._modelFields;
      }
      return this._cachedProcessedMessages;
    }
    return this.messages;
  }
  /**
   * Gets the actions available in the message context menu.
   *
   * @hidden
   */
  get contextMenuActions() {
    const currentActions = this.chatService.calculatedContextMenuActions;
    if (currentActions !== this._lastContextMenuActionsReference) {
      this._cachedContextMenuActions = transformActions(currentActions);
      this._lastContextMenuActionsReference = currentActions;
    }
    return this._cachedContextMenuActions;
  }
  /**
   * @hidden
   */
  get localizationText() {
    return this.localization;
  }
  /**
   * @hidden
   */
  autoScroll = true;
  /**
   * @hidden
   */
  pinIcon = pinIcon;
  /**
   * @hidden
   */
  deleteIcon = xIcon;
  /**
   * @hidden
   */
  pinnedMessage;
  direction;
  subs = new Subscription();
  _modelFields = defaultModelFields2;
  _messageContextMenuActions = CONTEXT_MENU_ACTIONS;
  _fileActions = FILE_ACTIONS;
  _cachedProcessedMessages = [];
  _lastMessagesReference = null;
  _lastModelFields = null;
  _cachedContextMenuActions = [];
  _lastContextMenuActionsReference = null;
  constructor(localization, zone, renderer, element, chatService) {
    this.localization = localization;
    this.zone = zone;
    this.renderer = renderer;
    this.element = element;
    this.chatService = chatService;
    N(packageMetadata8);
    this.direction = localization.rtl ? "rtl" : "ltr";
    this.subs.add(localization.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
    }));
  }
  /**
   * @hidden
   */
  ngOnInit() {
    this.chatService.messageWidthMode = this.messageWidthMode;
    this.chatService.timestampVisibility = this.timestampVisibility;
    this.chatService.showUsername = this.showUsername;
    this.chatService.showAvatar = this.showAvatar;
    this.chatService.allowMessageCollapse = this.allowMessageCollapse;
    this.chatService.enableSpeechToText = this.enableSpeechToText;
    this.chatService.sendButtonSettings = this.sendButtonSettings;
    this.chatService.enableFileSelect = this.enableFileSelect;
    this.chatService.messageToolbarActions = this.messageToolbarActions;
    this.chatService.messageContextMenuActions = this.messageContextMenuActions;
    this.chatService.fileActions = this.fileActions;
    this.chatService.authorMessageSettings = this.authorMessageSettings;
    this.chatService.receiverMessageSettings = this.receiverMessageSettings;
    this.chatService.messages = this.processedMessages || [];
    this.chatService.chatElement = this.messageList;
    this.subs.add(this.chatService.toolbarAction$.subscribe((actionEvent) => {
      this.toolbarActionClick.emit(actionEvent);
    }));
    this.subs.add(this.chatService.contextMenuAction$.subscribe((actionEvent) => {
      this.contextMenuActionClick.emit(actionEvent);
    }));
    this.subs.add(this.chatService.fileAction$.subscribe((actionEvent) => {
      this.fileActionClick.emit(actionEvent);
    }));
    this.subs.add(this.chatService.fileDownload$.subscribe((actionEvent) => {
      this.download.emit(actionEvent);
    }));
    this.subs.add(this.chatService.inputValueChange$.subscribe((value2) => {
      this.inputValueChange.emit(value2);
    }));
    this.pinnedMessage = this.findLastPinnedMessage();
    this.chatService.authorId = this.authorId;
  }
  /**
   * @hidden
   */
  ngOnChanges(changes) {
    this.zone.runOutsideAngular(() => setTimeout(() => {
      this.messageList.element.nativeElement.style.flex = "1 1 auto";
    }));
    if (isChanged("messages", changes, false)) {
      this.pinnedMessage = this.findLastPinnedMessage();
      this.chatService.messages = this.processedMessages;
    }
    if (isChanged("height", changes, false)) {
      this.renderer.setStyle(this.element.nativeElement, "height", `${processCssValue(this.height)}`);
    }
    if (isChanged("width", changes, false)) {
      this.renderer.setStyle(this.element.nativeElement, "width", `${processCssValue(this.width)}`);
    }
    this.updateChatServiceProperties(["authorId", "messageWidthMode", "timestampVisibility", "showUsername", "showAvatar", "allowMessageCollapse", "enableSpeechToText", "sendButtonSettings", "enableFileSelect", "messageToolbarActions", "messageContextMenuActions", "fileActions", "authorMessageSettings", "receiverMessageSettings"], changes);
  }
  /**
   * @hidden
   */
  ngAfterViewInit() {
    if (!isDevMode()) {
      return;
    }
    if (!isPresent(this.authorId)) {
      throw new Error("AuthorId must be set.");
    }
  }
  /**
   * @hidden
   */
  ngOnDestroy() {
    if (this.subs) {
      this.subs.unsubscribe();
    }
  }
  /**
   * @hidden
   */
  dispatchAction(e) {
    this.executeAction.emit(e);
    if (!e.isDefaultPrevented()) {
      const handler = makeHandler(e.action);
      handler(e.action, this);
      if (!this.messageBoxTemplate) {
        this.messageBox.messageBoxInput.focus();
      }
    }
  }
  /**
   * @hidden
   */
  textFor(key) {
    return this.localization.get(key);
  }
  /**
   * @hidden
   */
  scrollToPinnedMessage() {
    if (this.pinnedMessage) {
      this.chatService.scrollToMessage(this.pinnedMessage?.id);
    }
  }
  /**
   * @hidden
   */
  onContextMenuAction(action) {
    if (action.id === "reply") {
      this.chatService.reply = this.chatService.activeMessage;
    }
    if (action.id === "copy") {
      navigator.clipboard.writeText(this.chatService.activeMessage.text);
    }
    this.chatService.emit("contextMenuAction", {
      action,
      message: this.chatService.activeMessage
    });
  }
  /**
   * @hidden
   */
  handleMenuClose(event) {
    if (event) {
      const originalEvent = event.originalEvent;
      originalEvent && this.onActionButtonClick(originalEvent);
    }
    this.chatService.activeMessage = null;
    this.chatService.emit("contextMenuVisibilityChange", false);
    if (this.chatService.selectOnMenuClose) {
      this.chatService.activeMessageElement.selected = true;
      this.chatService.focusActiveMessageElement();
    }
  }
  /**
   * @hidden
   */
  onActionButtonClick(event) {
    const clickOutsideMessage = event instanceof MouseEvent && !event.target?.closest(".k-chat-bubble");
    const menuItemClick = event instanceof MouseEvent && event.target?.closest(MENU_ITEM_SELECTOR);
    if (clickOutsideMessage && !menuItemClick) {
      this.chatService.selectOnMenuClose = false;
    }
  }
  findLastPinnedMessage() {
    return [...this.processedMessages].reverse().find((message) => message.isPinned);
  }
  updateChatServiceProperties(propNames, changes) {
    propNames.forEach((propName) => {
      if (isChanged(propName, changes, false)) {
        this.chatService[propName] = this[propName];
      }
    });
  }
  mergeWithDefaultActions(actions, defaultActions) {
    if (!actions || actions.length === 0) {
      return [];
    }
    return actions.map((userAction) => {
      const defaultAction = defaultActions.find((action) => action.id === userAction?.id);
      if (defaultAction) {
        return __spreadValues(__spreadValues({}, defaultAction), userAction);
      }
      return userAction;
    });
  }
  static ɵfac = function ChatComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ChatComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChatService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ChatComponent,
    selectors: [["kendo-chat"]],
    contentQueries: function ChatComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, AttachmentTemplateDirective, 5)(dirIndex, ChatHeaderTemplateDirective, 5)(dirIndex, NoDataTemplateDirective, 5)(dirIndex, AuthorMessageContentTemplateDirective, 5)(dirIndex, ReceiverMessageContentTemplateDirective, 5)(dirIndex, MessageContentTemplateDirective, 5)(dirIndex, AuthorMessageTemplateDirective, 5)(dirIndex, ReceiverMessageTemplateDirective, 5)(dirIndex, MessageTemplateDirective, 5)(dirIndex, ChatTimestampTemplateDirective, 5)(dirIndex, ChatSuggestionTemplateDirective, 5)(dirIndex, ChatStatusTemplateDirective, 5)(dirIndex, ChatMessageBoxTemplateDirective, 5)(dirIndex, ChatUserStatusTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.attachmentTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.chatHeaderTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.chatNoDataTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.authorMessageContentTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.receiverMessageContentTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.messageContentTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.authorMessageTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.receiverMessageTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.messageTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.timestampTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.suggestionTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.statusTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.messageBoxTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.userStatusTemplate = _t.first);
      }
    },
    viewQuery: function ChatComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c173, 5)(_c183, 5)(_c193, 7, ViewContainerRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.messagesContextMenu = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.messageBox = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.messageList = _t.first);
      }
    },
    hostVars: 3,
    hostBindings: function ChatComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.dirAttr);
        ɵɵclassMap(ctx.className);
      }
    },
    inputs: {
      messages: "messages",
      authorId: "authorId",
      messageBoxType: "messageBoxType",
      height: "height",
      width: "width",
      placeholder: "placeholder",
      messageWidthMode: "messageWidthMode",
      timestampVisibility: "timestampVisibility",
      showUsername: "showUsername",
      showAvatar: "showAvatar",
      allowMessageCollapse: "allowMessageCollapse",
      enableSpeechToText: "enableSpeechToText",
      enableFileSelect: "enableFileSelect",
      messageToolbarActions: "messageToolbarActions",
      inputValue: "inputValue",
      authorMessageSettings: "authorMessageSettings",
      receiverMessageSettings: "receiverMessageSettings",
      messageContextMenuActions: "messageContextMenuActions",
      fileActions: "fileActions",
      messageFilesLayout: "messageFilesLayout",
      suggestionsLayout: "suggestionsLayout",
      quickActionsLayout: "quickActionsLayout",
      suggestions: "suggestions",
      sendButtonSettings: "sendButtonSettings",
      modelFields: "modelFields"
    },
    outputs: {
      sendMessage: "sendMessage",
      toolbarActionClick: "toolbarActionClick",
      contextMenuActionClick: "contextMenuActionClick",
      fileActionClick: "fileActionClick",
      download: "download",
      executeAction: "executeAction",
      suggestionExecute: "suggestionExecute",
      fileSelect: "fileSelect",
      fileRemove: "fileRemove",
      unpin: "unpin",
      inputValueChange: "inputValueChange"
    },
    features: [ɵɵProvidersFeature([LocalizationService, ChatService, SuggestionsScrollService, {
      provide: L10N_PREFIX,
      useValue: "kendo.chat"
    }]), ɵɵNgOnChangesFeature],
    decls: 12,
    vars: 18,
    consts: () => {
      let i18n_10;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_10 = goog.getMsg("You removed this message.");
        i18n_10 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_10;
      } else {
        i18n_10 = $localize`:kendo.chat.deletedMessageSenderText|The text that is displayed when the sender deletes a message:You removed this message.`;
      }
      let i18n_11;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_11 = goog.getMsg("This message was removed by its sender.");
        i18n_11 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_11;
      } else {
        i18n_11 = $localize`:kendo.chat.deletedMessageReceiverText|The text that is displayed when the receiver deletes a message:This message was removed by its sender.`;
      }
      let i18n_12;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_12 = goog.getMsg("Type a message...");
        i18n_12 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_12;
      } else {
        i18n_12 = $localize`:kendo.chat.messagePlaceholder|The placholder text of the message text input:Type a message...`;
      }
      let i18n_13;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_13 = goog.getMsg("Send...");
        i18n_13 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_13;
      } else {
        i18n_13 = $localize`:kendo.chat.send|The text for the Send button:Send...`;
      }
      let i18n_14;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_14 = goog.getMsg("Message list");
        i18n_14 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_14;
      } else {
        i18n_14 = $localize`:kendo.chat.messageListLabel|The label text for the Message list:Message list`;
      }
      let i18n_15;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_15 = goog.getMsg("Message");
        i18n_15 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_15;
      } else {
        i18n_15 = $localize`:kendo.chat.messageBoxInputLabel|The label text for the Message input box:Message`;
      }
      let i18n_16;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_16 = goog.getMsg("Previous item");
        i18n_16 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_16;
      } else {
        i18n_16 = $localize`:kendo.chat.messageAttachmentLeftArrow|The text for the left arrow of the message attachments:Previous item`;
      }
      let i18n_17;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_17 = goog.getMsg("Next item");
        i18n_17 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_17;
      } else {
        i18n_17 = $localize`:kendo.chat.messageAttachmentRightArrow|The text for the right arrow of the message attachments:Next item`;
      }
      let i18n_18;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_18 = goog.getMsg("Speech to Text");
        i18n_18 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_18;
      } else {
        i18n_18 = $localize`:kendo.chat.speechToTextButtonTitle|Sets the Speech to Text button title.:Speech to Text`;
      }
      let i18n_19;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_19 = goog.getMsg("Select files");
        i18n_19 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_19;
      } else {
        i18n_19 = $localize`:kendo.chat.fileSelectButtonTitle|Sets the File Select button title.:Select files`;
      }
      let i18n_20;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_20 = goog.getMsg("Remove reply");
        i18n_20 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_20;
      } else {
        i18n_20 = $localize`:kendo.chat.removeReplyTitle|Sets the title of the icon which removes the reply reference in the Message Box.:Remove reply`;
      }
      let i18n_21;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_21 = goog.getMsg("Remove file");
        i18n_21 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_21;
      } else {
        i18n_21 = $localize`:kendo.chat.removeFileTitle|Sets the title of the icon which removes a selected file in the Message Box.:Remove file`;
      }
      let i18n_22;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_22 = goog.getMsg("Expand message");
        i18n_22 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_22;
      } else {
        i18n_22 = $localize`:kendo.chat.expandTitle|Sets the title of the icon which demonstrates that the message can be expanded.:Expand message`;
      }
      let i18n_23;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_23 = goog.getMsg("Collapse message");
        i18n_23 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_23;
      } else {
        i18n_23 = $localize`:kendo.chat.collapseTitle|Sets the title of the icon which demonstrates that the message can be collapsed.:Collapse message`;
      }
      let i18n_24;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_24 = goog.getMsg("File actions");
        i18n_24 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_24;
      } else {
        i18n_24 = $localize`:kendo.chat.fileActionsTitle|Sets the title of the DropDownButton which opens the File actions.:File actions`;
      }
      let i18n_25;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_25 = goog.getMsg("Download all");
        i18n_25 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_25;
      } else {
        i18n_25 = $localize`:kendo.chat.downloadAllFilesText|Sets the text that is displayed in the download section of the message.:Download all`;
      }
      let i18n_26;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_26 = goog.getMsg("Scroll left");
        i18n_26 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_26;
      } else {
        i18n_26 = $localize`:kendo.chat.previousSuggestionsButtonTitle|The title of the button that scrolls to the previous suggestions:Scroll left`;
      }
      let i18n_27;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_27 = goog.getMsg("Scroll right");
        i18n_27 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_27;
      } else {
        i18n_27 = $localize`:kendo.chat.nextSuggestionsButtonTitle|The title of the button that scrolls to the next suggestions:Scroll right`;
      }
      return [["messageList", "", "anchor", "scrollAnchor"], ["messageBox", ""], ["messagesContextMenu", ""], ["kendoChatLocalizedMessages", "", "deletedMessageSenderText", i18n_10, "deletedMessageReceiverText", i18n_11, "messagePlaceholder", i18n_12, "send", i18n_13, "messageListLabel", i18n_14, "messageBoxInputLabel", i18n_15, "messageAttachmentLeftArrow", i18n_16, "messageAttachmentRightArrow", i18n_17, "speechToTextButtonTitle", i18n_18, "fileSelectButtonTitle", i18n_19, "removeReplyTitle", i18n_20, "removeFileTitle", i18n_21, "expandTitle", i18n_22, "collapseTitle", i18n_23, "fileActionsTitle", i18n_24, "downloadAllFilesText", i18n_25, "previousSuggestionsButtonTitle", i18n_26, "nextSuggestionsButtonTitle", i18n_27], ["positionMode", "sticky", "themeColor", "inherit", 1, "k-chat-header"], [1, "k-message-reference", "k-message-reference-receiver", "k-message-pinned"], ["aria-live", "polite", "role", "log", "kendoChatScrollAnchor", "", 1, "k-message-list", 3, "autoScrollChange", "autoScroll"], [1, "k-message-list-content", "k-message-list-content-empty"], [3, "messages", "authorMessageContentTemplate", "receiverMessageContentTemplate", "messageContentTemplate", "authorMessageTemplate", "receiverMessageTemplate", "messageTemplate", "timestampTemplate", "statusTemplate", "userStatusTemplate", "localization", "attachmentTemplate", "authorId"], [3, "sendMessage", "executeSuggestion", "fileSelect", "fileRemove", "messageBoxTemplate", "suggestionTemplate", "suggestions", "placeholder", "authorId", "autoScroll", "inputValue", "localization"], [3, "popupClose", "select", "items", "popupAlign", "collision"], [4, "ngTemplateOutlet"], [1, "k-message-reference", "k-message-reference-receiver", "k-message-pinned", 3, "click"], ["size", "xlarge", "name", "pin", 3, "svgIcon"], [3, "message"], [1, "k-spacer"], ["kendoButton", "", "fillMode", "flat", 3, "click", "svgIcon"], [3, "ngTemplateOutlet"], [3, "executeAction", "resize", "navigate", "messages", "authorMessageContentTemplate", "receiverMessageContentTemplate", "messageContentTemplate", "authorMessageTemplate", "receiverMessageTemplate", "messageTemplate", "timestampTemplate", "statusTemplate", "userStatusTemplate", "localization", "attachmentTemplate", "authorId"]];
    },
    template: function ChatComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainer(0, 3);
        ɵɵconditionalCreate(1, ChatComponent_Conditional_1_Template, 2, 1, "kendo-appbar", 4);
        ɵɵconditionalCreate(2, ChatComponent_Conditional_2_Template, 5, 3, "div", 5);
        ɵɵelementStart(3, "div", 6, 0);
        ɵɵtwoWayListener("autoScrollChange", function ChatComponent_Template_div_autoScrollChange_3_listener($event) {
          ɵɵrestoreView(_r1);
          ɵɵtwoWayBindingSet(ctx.autoScroll, $event) || (ctx.autoScroll = $event);
          return ɵɵresetView($event);
        });
        ɵɵconditionalCreate(6, ChatComponent_Conditional_6_Template, 2, 1, "div", 7)(7, ChatComponent_Conditional_7_Template, 1, 13, "kendo-chat-message-list", 8);
        ɵɵelementEnd();
        ɵɵelementStart(8, "kendo-message-box", 9, 1);
        ɵɵlistener("sendMessage", function ChatComponent_Template_kendo_message_box_sendMessage_8_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.sendMessage.emit($event));
        })("executeSuggestion", function ChatComponent_Template_kendo_message_box_executeSuggestion_8_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.suggestionExecute.emit($event));
        })("fileSelect", function ChatComponent_Template_kendo_message_box_fileSelect_8_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.fileSelect.emit($event));
        })("fileRemove", function ChatComponent_Template_kendo_message_box_fileRemove_8_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.fileRemove.emit($event));
        });
        ɵɵelementEnd();
        ɵɵelementStart(10, "kendo-contextmenu", 10, 2);
        ɵɵlistener("popupClose", function ChatComponent_Template_kendo_contextmenu_popupClose_10_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleMenuClose($event));
        })("select", function ChatComponent_Template_kendo_contextmenu_select_10_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onContextMenuAction($event.item.originalAction));
        });
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵconditional(ctx.chatHeaderTemplate ? 1 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.pinnedMessage ? 2 : -1);
        ɵɵadvance();
        ɵɵtwoWayProperty("autoScroll", ctx.autoScroll);
        ɵɵattribute("aria-label", ctx.textFor("messageListLabel"));
        ɵɵadvance(3);
        ɵɵconditional(ctx.processedMessages && ctx.processedMessages.length === 0 ? 6 : 7);
        ɵɵadvance(2);
        ɵɵproperty("messageBoxTemplate", ctx.messageBoxTemplate)("suggestionTemplate", ctx.suggestionTemplate)("suggestions", ctx.suggestions)("placeholder", ctx.placeholder)("authorId", ctx.authorId)("autoScroll", ctx.autoScroll)("inputValue", ctx.inputValue)("localization", ctx.localizationText);
        ɵɵadvance(2);
        ɵɵproperty("items", ctx.contextMenuActions)("popupAlign", ɵɵpureFunction0(16, _c203))("collision", ɵɵpureFunction0(17, _c216));
      }
    },
    dependencies: [LocalizedMessagesDirective$1, ScrollAnchorDirective, MessageListComponent, MessageBoxComponent, MessageReferenceComponent, AppBarComponent, NgTemplateOutlet, IconWrapperComponent, ButtonComponent, ContextMenuComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChatComponent, [{
    type: Component,
    args: [{
      providers: [LocalizationService, ChatService, SuggestionsScrollService, {
        provide: L10N_PREFIX,
        useValue: "kendo.chat"
      }],
      selector: "kendo-chat",
      template: `
        <ng-container kendoChatLocalizedMessages
          i18n-deletedMessageSenderText="kendo.chat.deletedMessageSenderText|The text that is displayed when the sender deletes a message"
          deletedMessageSenderText="You removed this message."
        
          i18n-deletedMessageReceiverText="kendo.chat.deletedMessageReceiverText|The text that is displayed when the receiver deletes a message"
          deletedMessageReceiverText="This message was removed by its sender."
        
          i18n-messagePlaceholder="kendo.chat.messagePlaceholder|The placholder text of the message text input"
          messagePlaceholder="Type a message..."
        
          i18n-send="kendo.chat.send|The text for the Send button"
          send="Send..."
        
          i18n-messageListLabel="kendo.chat.messageListLabel|The label text for the Message list"
          messageListLabel="Message list"
        
          i18n-messageBoxInputLabel="kendo.chat.messageBoxInputLabel|The label text for the Message input box"
          messageBoxInputLabel="Message"
        
          i18n-messageAttachmentLeftArrow="kendo.chat.messageAttachmentLeftArrow|The text for the left arrow of the message attachments"
          messageAttachmentLeftArrow="Previous item"
        
          i18n-messageAttachmentRightArrow="kendo.chat.messageAttachmentRightArrow|The text for the right arrow of the message attachments"
          messageAttachmentRightArrow="Next item"
        
          i18n-speechToTextButtonTitle="kendo.chat.speechToTextButtonTitle|Sets the Speech to Text button title."
          speechToTextButtonTitle="Speech to Text"
        
          i18n-fileSelectButtonTitle="kendo.chat.fileSelectButtonTitle|Sets the File Select button title."
          fileSelectButtonTitle="Select files"
        
          i18n-removeReplyTitle="kendo.chat.removeReplyTitle|Sets the title of the icon which removes the reply reference in the Message Box."
          removeReplyTitle="Remove reply"
        
          i18n-removeFileTitle="kendo.chat.removeFileTitle|Sets the title of the icon which removes a selected file in the Message Box."
          removeFileTitle="Remove file"
        
          i18n-expandTitle="kendo.chat.expandTitle|Sets the title of the icon which demonstrates that the message can be expanded."
          expandTitle="Expand message"
        
          i18n-collapseTitle="kendo.chat.collapseTitle|Sets the title of the icon which demonstrates that the message can be collapsed."
          collapseTitle="Collapse message"
        
          i18n-fileActionsTitle="kendo.chat.fileActionsTitle|Sets the title of the DropDownButton which opens the File actions."
          fileActionsTitle="File actions"
        
          i18n-downloadAllFilesText="kendo.chat.downloadAllFilesText|Sets the text that is displayed in the download section of the message."
          downloadAllFilesText="Download all"
        
          i18n-previousSuggestionsButtonTitle="kendo.chat.previousSuggestionsButtonTitle|The title of the button that scrolls to the previous suggestions"
          previousSuggestionsButtonTitle="Scroll left"
        
          i18n-nextSuggestionsButtonTitle="kendo.chat.nextSuggestionsButtonTitle|The title of the button that scrolls to the next suggestions"
          nextSuggestionsButtonTitle="Scroll right"
          >
        </ng-container>
        
        @if (chatHeaderTemplate) {
          <kendo-appbar class="k-chat-header" positionMode="sticky" themeColor="inherit">
            <ng-container *ngTemplateOutlet="chatHeaderTemplate.templateRef"></ng-container>
          </kendo-appbar>
        }
        @if (pinnedMessage) {
          <div class="k-message-reference k-message-reference-receiver k-message-pinned" (click)="scrollToPinnedMessage()">
            <kendo-icon-wrapper
              size="xlarge"
              name="pin"
              [svgIcon]="pinIcon"
              >
            </kendo-icon-wrapper>
            <chat-message-reference-content [message]="pinnedMessage"></chat-message-reference-content>
            <span class="k-spacer"></span>
            <button kendoButton [svgIcon]="deleteIcon" (click)="unpin.emit(pinnedMessage)" fillMode="flat"></button>
          </div>
        }
        <div
          #messageList
          class="k-message-list"
          aria-live="polite"
          role="log"
          kendoChatScrollAnchor
          [attr.aria-label]="textFor('messageListLabel')"
          #anchor="scrollAnchor"
          [(autoScroll)]="autoScroll"
          >
          @if (processedMessages && processedMessages.length === 0) {
            <div class="k-message-list-content k-message-list-content-empty">
              <ng-template
                [ngTemplateOutlet]="chatNoDataTemplate?.templateRef">
              </ng-template>
            </div>
          } @else {
            <kendo-chat-message-list
              [messages]="processedMessages"
              [authorMessageContentTemplate]="authorMessageContentTemplate"
              [receiverMessageContentTemplate]="receiverMessageContentTemplate"
              [messageContentTemplate]="messageContentTemplate"
              [authorMessageTemplate]="authorMessageTemplate"
              [receiverMessageTemplate]="receiverMessageTemplate"
              [messageTemplate]="messageTemplate"
              [timestampTemplate]="timestampTemplate"
              [statusTemplate]="statusTemplate"
              [userStatusTemplate]="userStatusTemplate"
              [localization]="localizationText"
              [attachmentTemplate]="attachmentTemplate"
              [authorId]="authorId"
              (executeAction)="dispatchAction($event)"
              (resize)="anchor.scrollToBottom()"
              (navigate)="this.autoScroll = false"
              >
            </kendo-chat-message-list>
          }
        </div>
        <kendo-message-box
          #messageBox
          [messageBoxTemplate]="messageBoxTemplate"
          [suggestionTemplate]="suggestionTemplate"
          [suggestions]="suggestions"
          [placeholder]="placeholder"
          [authorId]="authorId"
          [autoScroll]="autoScroll"
          [inputValue]="inputValue"
          [localization]="localizationText"
          (sendMessage)="sendMessage.emit($event)"
          (executeSuggestion)="suggestionExecute.emit($event)"
          (fileSelect)="fileSelect.emit($event)"
          (fileRemove)="fileRemove.emit($event)"
          >
        </kendo-message-box>
        
        <kendo-contextmenu
          #messagesContextMenu
          [items]="contextMenuActions"
          [popupAlign]="{ horizontal: 'right', vertical: 'top' }"
          [collision]="{ horizontal: 'flip', vertical: 'flip'}"
          (popupClose)="handleMenuClose($event)"
          (select)="onContextMenuAction($event.item.originalAction)"
        ></kendo-contextmenu>
        `,
      standalone: true,
      imports: [LocalizedMessagesDirective$1, ScrollAnchorDirective, MessageListComponent, MessageBoxComponent, MessageReferenceComponent, AppBarComponent, NgTemplateOutlet, IconWrapperComponent, KENDO_BUTTON, ContextMenuComponent]
    }]
  }], () => [{
    type: LocalizationService
  }, {
    type: NgZone
  }, {
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: ChatService
  }], {
    messages: [{
      type: Input
    }],
    authorId: [{
      type: Input
    }],
    messageBoxType: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    messageWidthMode: [{
      type: Input
    }],
    timestampVisibility: [{
      type: Input
    }],
    showUsername: [{
      type: Input
    }],
    showAvatar: [{
      type: Input
    }],
    allowMessageCollapse: [{
      type: Input
    }],
    enableSpeechToText: [{
      type: Input
    }],
    enableFileSelect: [{
      type: Input
    }],
    messageToolbarActions: [{
      type: Input
    }],
    inputValue: [{
      type: Input
    }],
    authorMessageSettings: [{
      type: Input
    }],
    receiverMessageSettings: [{
      type: Input
    }],
    messageContextMenuActions: [{
      type: Input
    }],
    fileActions: [{
      type: Input
    }],
    messageFilesLayout: [{
      type: Input
    }],
    suggestionsLayout: [{
      type: Input
    }],
    quickActionsLayout: [{
      type: Input
    }],
    suggestions: [{
      type: Input
    }],
    sendButtonSettings: [{
      type: Input
    }],
    modelFields: [{
      type: Input
    }],
    sendMessage: [{
      type: Output
    }],
    toolbarActionClick: [{
      type: Output
    }],
    contextMenuActionClick: [{
      type: Output
    }],
    fileActionClick: [{
      type: Output
    }],
    download: [{
      type: Output
    }],
    executeAction: [{
      type: Output
    }],
    suggestionExecute: [{
      type: Output
    }],
    fileSelect: [{
      type: Output
    }],
    fileRemove: [{
      type: Output
    }],
    unpin: [{
      type: Output
    }],
    inputValueChange: [{
      type: Output
    }],
    className: [{
      type: HostBinding,
      args: ["class"]
    }],
    dirAttr: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    messagesContextMenu: [{
      type: ViewChild,
      args: ["messagesContextMenu"]
    }],
    attachmentTemplate: [{
      type: ContentChild,
      args: [AttachmentTemplateDirective]
    }],
    chatHeaderTemplate: [{
      type: ContentChild,
      args: [ChatHeaderTemplateDirective]
    }],
    chatNoDataTemplate: [{
      type: ContentChild,
      args: [NoDataTemplateDirective]
    }],
    authorMessageContentTemplate: [{
      type: ContentChild,
      args: [AuthorMessageContentTemplateDirective]
    }],
    receiverMessageContentTemplate: [{
      type: ContentChild,
      args: [ReceiverMessageContentTemplateDirective]
    }],
    messageContentTemplate: [{
      type: ContentChild,
      args: [MessageContentTemplateDirective]
    }],
    authorMessageTemplate: [{
      type: ContentChild,
      args: [AuthorMessageTemplateDirective]
    }],
    receiverMessageTemplate: [{
      type: ContentChild,
      args: [ReceiverMessageTemplateDirective]
    }],
    messageTemplate: [{
      type: ContentChild,
      args: [MessageTemplateDirective]
    }],
    timestampTemplate: [{
      type: ContentChild,
      args: [ChatTimestampTemplateDirective]
    }],
    suggestionTemplate: [{
      type: ContentChild,
      args: [ChatSuggestionTemplateDirective]
    }],
    statusTemplate: [{
      type: ContentChild,
      args: [ChatStatusTemplateDirective]
    }],
    messageBoxTemplate: [{
      type: ContentChild,
      args: [ChatMessageBoxTemplateDirective]
    }],
    userStatusTemplate: [{
      type: ContentChild,
      args: [ChatUserStatusTemplateDirective]
    }],
    messageBox: [{
      type: ViewChild,
      args: ["messageBox"]
    }],
    messageList: [{
      type: ViewChild,
      args: ["messageList", {
        static: true,
        read: ViewContainerRef
      }]
    }]
  });
})();
var CustomMessagesComponent4 = class _CustomMessagesComponent extends Messages$1 {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function CustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _CustomMessagesComponent,
    selectors: [["kendo-chat-messages"]],
    features: [ɵɵProvidersFeature([{
      provide: Messages$1,
      useExisting: forwardRef(() => _CustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function CustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CustomMessagesComponent4, [{
    type: Component,
    args: [{
      providers: [{
        provide: Messages$1,
        useExisting: forwardRef(() => CustomMessagesComponent4)
      }],
      selector: "kendo-chat-messages",
      template: ``,
      standalone: true
    }]
  }], () => [{
    type: LocalizationService
  }], null);
})();
var HeroCardComponent = class _HeroCardComponent {
  /**
   * Sets the URL of the hero card image.
   */
  imageUrl;
  /**
   * Sets the title of the hero card.
   */
  title;
  /**
   * Sets the subtitle of the hero card.
   */
  subtitle;
  /**
   * Sets the array of quick actions for this hero card.
   */
  actions;
  cssClass = true;
  /**
   * Fires when the user clicks a button.
   */
  executeAction = new EventEmitter();
  /**
   * Emits the `executeAction` event when the user clicks an action button.
   */
  onClick(action) {
    this.executeAction.next(action);
  }
  static ɵfac = function HeroCardComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HeroCardComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _HeroCardComponent,
    selectors: [["kendo-chat-hero-card"]],
    hostVars: 2,
    hostBindings: function HeroCardComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-card", ctx.cssClass);
      }
    },
    inputs: {
      imageUrl: "imageUrl",
      title: "title",
      subtitle: "subtitle",
      actions: "actions"
    },
    outputs: {
      executeAction: "executeAction"
    },
    decls: 7,
    vars: 3,
    consts: [[1, "k-card-image", 3, "src"], [1, "k-card-body"], [1, "k-card-title"], [1, "k-card-subtitle"], [1, "k-card-actions", "k-card-actions-vertical"], [1, "k-card-action"], ["kendoButton", "", "fillMode", "flat", 3, "click"]],
    template: function HeroCardComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵconditionalCreate(0, HeroCardComponent_Conditional_0_Template, 1, 1, "img", 0);
        ɵɵelementStart(1, "div", 1);
        ɵɵconditionalCreate(2, HeroCardComponent_Conditional_2_Template, 2, 1, "h5", 2);
        ɵɵconditionalCreate(3, HeroCardComponent_Conditional_3_Template, 2, 1, "h6", 3);
        ɵɵelementEnd();
        ɵɵelementStart(4, "div", 4);
        ɵɵrepeaterCreate(5, HeroCardComponent_For_6_Template, 3, 1, "span", 5, ɵɵrepeaterTrackByIdentity);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵconditional(ctx.imageUrl ? 0 : -1);
        ɵɵadvance(2);
        ɵɵconditional(ctx.title ? 2 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.subtitle ? 3 : -1);
        ɵɵadvance(2);
        ɵɵrepeater(ctx.actions);
      }
    },
    dependencies: [ButtonComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HeroCardComponent, [{
    type: Component,
    args: [{
      selector: "kendo-chat-hero-card",
      template: `
        @if (imageUrl) {
          <img class="k-card-image" [src]="imageUrl" />
        }
        <div class="k-card-body">
          @if (title) {
            <h5 class="k-card-title">
              {{ title }}
            </h5>
          }
          @if (subtitle) {
            <h6 class="k-card-subtitle">
              {{ subtitle }}
            </h6>
          }
        </div>
        <div class="k-card-actions k-card-actions-vertical">
          @for (act of actions; track act) {
            <span class="k-card-action"
              >
              <button
                kendoButton fillMode="flat"
                (click)="onClick(act)"
                >
                {{ act.title }}
              </button>
            </span>
          }
        </div>
        `,
      standalone: true,
      imports: [ButtonComponent]
    }]
  }], null, {
    imageUrl: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    subtitle: [{
      type: Input
    }],
    actions: [{
      type: Input
    }],
    cssClass: [{
      type: HostBinding,
      args: ["class.k-card"]
    }],
    executeAction: [{
      type: Output
    }]
  });
})();
var Messages7 = class _Messages extends ComponentMessages {
  /**
   * The title for the Commands button.
   */
  commandsButtonTitle;
  /**
   * The title for the Generate button.
   */
  generateButtonTitle;
  /**
   * The title for the Speech to Text button.
   */
  speechToTextButtonTitle;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵMessages_BaseFactory;
    return function Messages_Factory(__ngFactoryType__) {
      return (ɵMessages_BaseFactory || (ɵMessages_BaseFactory = ɵɵgetInheritedFactory(_Messages)))(__ngFactoryType__ || _Messages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _Messages,
    inputs: {
      commandsButtonTitle: "commandsButtonTitle",
      generateButtonTitle: "generateButtonTitle",
      speechToTextButtonTitle: "speechToTextButtonTitle"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Messages7, [{
    type: Directive
  }], null, {
    commandsButtonTitle: [{
      type: Input
    }],
    generateButtonTitle: [{
      type: Input
    }],
    speechToTextButtonTitle: [{
      type: Input
    }]
  });
})();
var LocalizedMessagesDirective6 = class _LocalizedMessagesDirective extends Messages7 {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function LocalizedMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LocalizedMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LocalizedMessagesDirective,
    selectors: [["", "kendoInlineAIPromptLocalizedMessages", ""]],
    features: [ɵɵProvidersFeature([{
      provide: Messages7,
      useExisting: forwardRef(() => _LocalizedMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalizedMessagesDirective6, [{
    type: Directive,
    args: [{
      providers: [{
        provide: Messages7,
        useExisting: forwardRef(() => LocalizedMessagesDirective6)
      }],
      selector: "[kendoInlineAIPromptLocalizedMessages]",
      standalone: true
    }]
  }], () => [{
    type: LocalizationService
  }], null);
})();
var defaultPopupSettings = {
  popupAlign: {
    vertical: "top",
    horizontal: "left"
  },
  anchorAlign: {
    horizontal: "left",
    vertical: "bottom"
  },
  positionMode: "absolute",
  collision: {
    horizontal: "fit",
    vertical: "flip"
  },
  animate: true,
  offset: {
    top: 0,
    left: 0
  },
  margin: {
    horizontal: 0,
    vertical: 0
  }
};
var calculateMeasurement = (value2) => {
  return value2 + (typeof value2 === "number" ? "px" : "");
};
var defaultOutputActions = [{
  name: "copy",
  type: "button",
  icon: "copy",
  svgIcon: copyIcon,
  text: "Copy",
  fillMode: "flat",
  themeColor: "primary",
  rounded: "medium"
}, {
  name: "retry",
  type: "button",
  icon: "arrow-rotate-cw",
  svgIcon: arrowRotateCwIcon,
  text: "Retry",
  fillMode: "flat",
  themeColor: "primary",
  rounded: "medium"
}, {
  name: "discard",
  type: "button",
  icon: "cancel-outline",
  svgIcon: cancelOutlineIcon,
  text: "Discard",
  fillMode: "flat",
  themeColor: "base",
  rounded: "medium"
}];
var TEXTAREA_MAX_ROWS = 5;
var TEXTAREA_INITIAL_ROWS = 1;
var InlineAIPromptContentComponent = class _InlineAIPromptContentComponent {
  ngZone;
  renderer;
  element;
  localization;
  className = true;
  get dirAttr() {
    return this.direction;
  }
  get maxHeightStyle() {
    return this.calculateMeasurement(this.maxHeight);
  }
  get widthStyle() {
    return this.calculateMeasurement(this.width);
  }
  popupElement;
  promptValue = "";
  placeholder;
  promptOutput;
  enableSpeechToText = true;
  streaming = false;
  width = 550;
  maxHeight;
  appendTo;
  defaultOutputActions = defaultOutputActions;
  set outputActions(actions) {
    this._outputActions = this.mergeWithDefaultActions(actions);
  }
  get outputActions() {
    return this._outputActions;
  }
  set promptCommands(commands) {
    this._promptCommands = commands || [];
    this.commandMenuItems = this.transformCommands(commands || []);
  }
  get promptCommands() {
    return this._promptCommands;
  }
  outputTemplate;
  promptRequest = new EventEmitter();
  commandExecute = new EventEmitter();
  outputActionClick = new EventEmitter();
  promptRequestCancel = new EventEmitter();
  close = new EventEmitter();
  promptValueChange = new EventEmitter();
  onEscapeKey(event) {
    if (event.key === "Escape") {
      if (this.streaming) {
        event.stopPropagation();
        this.promptRequestCancel.emit();
      } else {
        this.close.emit();
      }
    }
  }
  textArea;
  contextMenu;
  calculateMeasurement = calculateMeasurement;
  commandMenuIcon = menuIcon;
  sendIcon = paperPlaneIcon;
  stopGenerationIcon = stopSmIcon;
  isListening = false;
  commandMenuItems = [];
  messages = {};
  maxRows = TEXTAREA_MAX_ROWS;
  initialRows = TEXTAREA_INITIAL_ROWS;
  _outputActions = this.defaultOutputActions;
  _promptCommands = [];
  direction;
  localizationSubs = new Subscription();
  subs = new Subscription();
  constructor(ngZone, renderer, element, localization) {
    this.ngZone = ngZone;
    this.renderer = renderer;
    this.element = element;
    this.localization = localization;
    N(packageMetadata8);
    if (!this.localization) {
      this.localization = inject(LocalizationService);
    }
    this.direction = this.localization?.rtl ? "rtl" : "ltr";
    this.localizationSubs.add(this.localization.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
    }));
  }
  ngAfterViewInit() {
    this.ngZone.runOutsideAngular(() => {
      if (!isDocumentAvailable()) {
        return;
      }
      setTimeout(() => {
        this.subs.add(this.renderer.listen("document", "click", (e) => {
          this.outsideClickClose(e);
        }));
      });
    });
  }
  ngOnDestroy() {
    this.subs.unsubscribe();
    this.localizationSubs.unsubscribe();
    this.contextMenu?.hide();
  }
  focus() {
    if (this.textArea) {
      this.textArea.focus();
    }
  }
  onActionClick(event) {
    const eventArgs = {
      action: event,
      output: this.promptOutput
    };
    this.outputActionClick.emit(eventArgs);
    this.handleDefaultActions(event);
  }
  handleDefaultActions(event) {
    switch (event.name) {
      case "copy":
        navigator.clipboard.writeText(this.promptOutput.output);
        break;
      case "retry":
        this.promptRequest.emit({
          prompt: this.promptOutput?.prompt,
          isRetry: true
        });
        break;
      case "discard":
        this.close.emit();
        break;
    }
  }
  handleSpeechResult(event) {
    if (event.alternatives && event.alternatives.length > 0) {
      if (!isPresent(this.promptValue)) {
        this.promptValue = "";
      }
      this.promptValue += event.alternatives[0].transcript + " ";
    }
  }
  onClick(action) {
    this.commandExecute.next(action);
  }
  handlePromptValueChange(value2) {
    this.promptValue = value2;
    this.promptValueChange.emit(value2);
  }
  handleTextAreaKeydown(event) {
    if (event.key === "Enter" && !event.shiftKey && !this.streaming) {
      event.preventDefault();
      this.handlePromptRequest();
    }
  }
  onCommandButtonClick(event) {
    event.preventDefault();
    event.stopPropagation();
    if (this.contextMenu) {
      this.contextMenu.show(this.popupElement);
    }
  }
  onCommandClick(event) {
    if (event.originalEvent) {
      event.originalEvent.stopPropagation();
      event.originalEvent.preventDefault();
    }
    const eventArgs = __spreadValues({}, event.item.originalCommand);
    this.commandExecute.emit(eventArgs);
  }
  messageFor(text) {
    if (this.messages?.[text]) {
      return this.messages[text];
    }
    return this.localization?.get(text);
  }
  handlePromptRequest() {
    if (this.streaming) {
      this.promptRequestCancel.emit();
      return;
    }
    if (!this.promptValue) {
      return;
    }
    const eventArgs = {
      prompt: this.promptValue
    };
    this.promptRequest.emit(eventArgs);
  }
  mergeWithDefaultActions(userActions) {
    if (!userActions || userActions.length === 0) {
      return [];
    }
    return userActions.map((userAction) => {
      const defaultAction = defaultOutputActions.find((action) => action.name === userAction?.name);
      if (defaultAction) {
        return __spreadValues(__spreadValues({}, defaultAction), userAction);
      }
      return userAction;
    });
  }
  transformCommands = (commands) => commands.map((command) => ({
    text: command.text,
    icon: command.icon,
    svgIcon: command.svgIcon,
    disabled: command.disabled,
    originalCommand: command,
    items: command.children ? this.transformCommands(command.children) : void 0
  }));
  outsideClickClose(e) {
    if (!this.element.nativeElement.contains(e.target)) {
      this.ngZone.run(() => {
        this.close.emit();
      });
    }
  }
  static ɵfac = function InlineAIPromptContentComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _InlineAIPromptContentComponent)(ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(LocalizationService, 12));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _InlineAIPromptContentComponent,
    selectors: [["kendo-inlineaiprompt-content"]],
    viewQuery: function InlineAIPromptContentComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(TextAreaComponent, 5)(_c223, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.textArea = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.contextMenu = _t.first);
      }
    },
    hostVars: 7,
    hostBindings: function InlineAIPromptContentComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("keydown", function InlineAIPromptContentComponent_keydown_HostBindingHandler($event) {
          return ctx.onEscapeKey($event);
        });
      }
      if (rf & 2) {
        ɵɵattribute("dir", ctx.dirAttr);
        ɵɵstyleProp("max-height", ctx.maxHeightStyle)("width", ctx.widthStyle);
        ɵɵclassProp("k-prompt", ctx.className);
      }
    },
    inputs: {
      popupElement: "popupElement",
      promptValue: "promptValue",
      placeholder: "placeholder",
      promptOutput: "promptOutput",
      enableSpeechToText: "enableSpeechToText",
      streaming: "streaming",
      width: "width",
      maxHeight: "maxHeight",
      appendTo: "appendTo",
      outputActions: "outputActions",
      promptCommands: "promptCommands",
      outputTemplate: "outputTemplate"
    },
    outputs: {
      promptRequest: "promptRequest",
      commandExecute: "commandExecute",
      outputActionClick: "outputActionClick",
      promptRequestCancel: "promptRequestCancel",
      close: "close",
      promptValueChange: "promptValueChange"
    },
    exportAs: ["kendoInlineAIPromptContent"],
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.inlineaiprompt"
    }])],
    decls: 12,
    vars: 20,
    consts: () => {
      let i18n_28;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_28 = goog.getMsg("Command Menu");
        i18n_28 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_28;
      } else {
        i18n_28 = $localize`:kendo.inlineaiprompt.commandsButtonTitle|Sets the Commands button title.:Command Menu`;
      }
      let i18n_29;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_29 = goog.getMsg("Generate");
        i18n_29 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_29;
      } else {
        i18n_29 = $localize`:kendo.inlineaiprompt.generateButtonTitle|Sets the Generate button title.:Generate`;
      }
      let i18n_30;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_30 = goog.getMsg("Speech to Text");
        i18n_30 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_30;
      } else {
        i18n_30 = $localize`:kendo.inlineaiprompt.speechToTextButtonTitle|Sets the Speech to Text button title.:Speech to Text`;
      }
      return [["kendoContextMenu", ""], ["commandMenuButton", ""], ["kendoInlineAIPromptLocalizedMessages", "", "commandsButtonTitle", i18n_28, "generateButtonTitle", i18n_29, "speechToTextButtonTitle", i18n_30], [1, "k-prompt-content"], [1, "k-prompt-view"], ["width", "100%"], ["resizable", "auto", "flow", "horizontal", 3, "valueChange", "keydown", "value", "rows", "placeholder", "showPrefixSeparator", "selectOnFocus", "maxResizableRows"], ["kendoButton", "", "fillMode", "flat", "icon", "menu", 3, "svgIcon"], ["kendoSpeechToTextButton", "", "fillMode", "flat"], ["kendoButton", "", "fillMode", "flat", 1, "k-prompt-send", 3, "click", "ngClass", "disabled", "svgIcon", "icon"], [1, "k-hidden", 3, "select", "alignToAnchor", "items", "appendTo"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["kendoButton", "", 3, "fillMode", "themeColor", "rounded", "icon", "svgIcon"], [1, "k-spacer"], ["kendoButton", "", 3, "click", "fillMode", "themeColor", "rounded", "icon", "svgIcon"], ["kendoButton", "", "fillMode", "flat", "icon", "menu", 3, "click", "svgIcon"], ["kendoSpeechToTextButton", "", "fillMode", "flat", 3, "result", "start", "end"]];
    },
    template: function InlineAIPromptContentComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainer(0, 2);
        ɵɵelementStart(1, "div", 3)(2, "div", 4);
        ɵɵconditionalCreate(3, InlineAIPromptContentComponent_Conditional_3_Template, 5, 3, "kendo-card", 5);
        ɵɵelementStart(4, "kendo-textarea", 6);
        ɵɵlistener("valueChange", function InlineAIPromptContentComponent_Template_kendo_textarea_valueChange_4_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handlePromptValueChange($event));
        })("keydown", function InlineAIPromptContentComponent_Template_kendo_textarea_keydown_4_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleTextAreaKeydown($event));
        });
        ɵɵelementStart(5, "kendo-textarea-prefix");
        ɵɵconditionalCreate(6, InlineAIPromptContentComponent_Conditional_6_Template, 2, 2, "button", 7);
        ɵɵconditionalCreate(7, InlineAIPromptContentComponent_Conditional_7_Template, 1, 1, "button", 8);
        ɵɵelementEnd();
        ɵɵelementStart(8, "kendo-textarea-suffix")(9, "button", 9);
        ɵɵlistener("click", function InlineAIPromptContentComponent_Template_button_click_9_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handlePromptRequest());
        });
        ɵɵelementEnd()()()()();
        ɵɵelementStart(10, "kendo-contextmenu", 10, 0);
        ɵɵlistener("select", function InlineAIPromptContentComponent_Template_kendo_contextmenu_select_10_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onCommandClick($event));
        });
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance(3);
        ɵɵconditional(ctx.promptOutput ? 3 : -1);
        ɵɵadvance();
        ɵɵproperty("value", ctx.promptValue ? ctx.promptValue : null)("rows", ctx.initialRows)("placeholder", ctx.placeholder)("showPrefixSeparator", true)("selectOnFocus", true)("maxResizableRows", ctx.maxRows);
        ɵɵadvance(2);
        ɵɵconditional(ctx.promptCommands && ctx.promptCommands.length > 0 ? 6 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.enableSpeechToText ? 7 : -1);
        ɵɵadvance(2);
        ɵɵproperty("ngClass", ɵɵpureFunction2(17, _c233, ctx.streaming, ctx.streaming))("disabled", !ctx.streaming && (!(ctx.promptValue == null ? null : ctx.promptValue.trim()) || ctx.isListening))("svgIcon", ctx.streaming ? ctx.stopGenerationIcon : ctx.sendIcon)("icon", ctx.streaming ? "stop-sm" : "paper-plane");
        ɵɵattribute("title", ctx.messageFor("generateButtonTitle"));
        ɵɵadvance();
        ɵɵproperty("alignToAnchor", true)("items", ctx.commandMenuItems)("appendTo", ctx.appendTo);
      }
    },
    dependencies: [NgClass, NgTemplateOutlet, LocalizedMessagesDirective6, ButtonComponent, SpeechToTextButtonComponent, TextAreaComponent, TextAreaPrefixComponent, TextAreaSuffixComponent, ContextMenuComponent, CardComponent, CardActionsComponent, CardBodyComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InlineAIPromptContentComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoInlineAIPromptContent",
      selector: "kendo-inlineaiprompt-content",
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.inlineaiprompt"
      }],
      template: `
        <ng-container kendoInlineAIPromptLocalizedMessages
          i18n-commandsButtonTitle="kendo.inlineaiprompt.commandsButtonTitle|Sets the Commands button title."
          commandsButtonTitle="Command Menu"
          i18n-generateButtonTitle="kendo.inlineaiprompt.generateButtonTitle|Sets the Generate button title."
          generateButtonTitle="Generate"
          i18n-speechToTextButtonTitle="kendo.inlineaiprompt.speechToTextButtonTitle|Sets the Speech to Text button title."
          speechToTextButtonTitle="Speech to Text"
          >
        </ng-container>
        <div class="k-prompt-content">
          <div class="k-prompt-view">
            @if (promptOutput) {
              <kendo-card width="100%">
                <kendo-card-body>
                  @if (outputTemplate) {
                    <ng-container
                      [ngTemplateOutlet]="outputTemplate"
                      [ngTemplateOutletContext]="{ $implicit: promptOutput }"
                      >
                    </ng-container>
                  }
                  @if (!outputTemplate) {
                    {{promptOutput.output}}
                  }
                </kendo-card-body>
                @if (outputActions && outputActions.length > 0) {
                  <kendo-card-actions>
                    @for (action of outputActions; track action) {
                      @if (action.type === 'button') {
                        <button kendoButton
                          [attr.title]="action?.title"
                          [fillMode]="action?.fillMode"
                          [themeColor]="action?.themeColor"
                          [rounded]="action?.rounded"
                          [icon]="action?.icon"
                          [svgIcon]="action?.svgIcon"
                          (click)="onActionClick(action)"
                        >{{action?.text}}</button>
                      }
                      @if (action.type === 'spacer') {
                        <div class="k-spacer"></div>
                      }
                    }
                  </kendo-card-actions>
                }
              </kendo-card>
            }
            <kendo-textarea
              [value]="promptValue ? promptValue : null"
              (valueChange)="handlePromptValueChange($event)"
              [rows]="initialRows"
              resizable="auto"
              flow="horizontal"
              [placeholder]="placeholder"
              [showPrefixSeparator]="true"
              [selectOnFocus]="true"
              [maxResizableRows]="maxRows"
              (keydown)="handleTextAreaKeydown($event)"
              >
              <kendo-textarea-prefix>
                @if (promptCommands && promptCommands.length > 0) {
                  <button
                    kendoButton
                    #commandMenuButton
                    [attr.title]="messageFor('commandsButtonTitle')"
                    fillMode="flat"
                    icon="menu"
                    [svgIcon]="commandMenuIcon"
                    (click)="onCommandButtonClick($event)"
                  ></button>
                }
                @if (enableSpeechToText) {
                  <button
                    kendoSpeechToTextButton
                    [attr.title]="messageFor('speechToTextButtonTitle')"
                    fillMode="flat"
                    (result)="handleSpeechResult($event)"
                    (start)="isListening = true"
                    (end)="isListening = false"
                  ></button>
                }
              </kendo-textarea-prefix>
              <kendo-textarea-suffix>
                <button
                  kendoButton
                  [attr.title]="messageFor('generateButtonTitle')"
                  fillMode="flat"
                  class="k-prompt-send"
                  [ngClass]="{ 'k-generating': streaming, 'k-active': streaming }"
                  (click)="handlePromptRequest()"
                  [disabled]="!streaming && (!promptValue?.trim() || isListening)"
                  [svgIcon]="streaming ? stopGenerationIcon : sendIcon"
                  [icon]="streaming ? 'stop-sm' : 'paper-plane'"
                ></button>
              </kendo-textarea-suffix>
            </kendo-textarea>
          </div>
        </div>
        <kendo-contextmenu
          #kendoContextMenu
          [alignToAnchor]="true"
          [items]="commandMenuItems"
          [appendTo]="appendTo"
          class="k-hidden"
          (select)="onCommandClick($event)">
        </kendo-contextmenu>
        `,
      standalone: true,
      imports: [NgClass, NgTemplateOutlet, LocalizedMessagesDirective6, KENDO_BUTTONS, KENDO_TEXTAREA, KENDO_CONTEXTMENU, KENDO_CARD]
    }]
  }], () => [{
    type: NgZone
  }, {
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: LocalizationService,
    decorators: [{
      type: Optional
    }, {
      type: SkipSelf
    }]
  }], {
    className: [{
      type: HostBinding,
      args: ["class.k-prompt"]
    }],
    dirAttr: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    maxHeightStyle: [{
      type: HostBinding,
      args: ["style.max-height"]
    }],
    widthStyle: [{
      type: HostBinding,
      args: ["style.width"]
    }],
    popupElement: [{
      type: Input
    }],
    promptValue: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    promptOutput: [{
      type: Input
    }],
    enableSpeechToText: [{
      type: Input
    }],
    streaming: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    maxHeight: [{
      type: Input
    }],
    appendTo: [{
      type: Input
    }],
    outputActions: [{
      type: Input
    }],
    promptCommands: [{
      type: Input
    }],
    outputTemplate: [{
      type: Input
    }],
    promptRequest: [{
      type: Output
    }],
    commandExecute: [{
      type: Output
    }],
    outputActionClick: [{
      type: Output
    }],
    promptRequestCancel: [{
      type: Output
    }],
    close: [{
      type: Output
    }],
    promptValueChange: [{
      type: Output
    }],
    onEscapeKey: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }],
    textArea: [{
      type: ViewChild,
      args: [TextAreaComponent]
    }],
    contextMenu: [{
      type: ViewChild,
      args: ["kendoContextMenu"]
    }]
  });
})();
var InlineAIPromptOutputTemplateDirective = class _InlineAIPromptOutputTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function InlineAIPromptOutputTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _InlineAIPromptOutputTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _InlineAIPromptOutputTemplateDirective,
    selectors: [["", "kendoInlineAIPromptOutputTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InlineAIPromptOutputTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoInlineAIPromptOutputTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var InlineAIPromptComponent = class _InlineAIPromptComponent {
  ngZone;
  element;
  /**
   * Sets the TextArea value.
   *
   * @default ""
   */
  promptValue = "";
  /**
   * Sets the placeholder text that appears in the text area when it is empty.
   */
  placeholder;
  /**
   * Sets the output data for the prompt.
   * The output displays as a card above the text area.
   */
  promptOutput;
  /**
   * Controls the visibility and settings of the Speech to Text button.
   *
   * @default true
   */
  enableSpeechToText = true;
  /**
   * When set to `true`, the **Send** button displays a generating state and the component emits a `promptRequestCancel` event when you click it.
   *
   * @default false
   */
  streaming = false;
  /**
   * Sets the width of the component.
   * Accepts a number for pixels or a string for other units.
   *
   * @default 550
   */
  width = 550;
  /**
   * Sets the maximum height of the component.
   * Accepts a number for pixels or a string for other units.
   */
  maxHeight;
  /**
   * Represents the configuration of the default output actions.
   * The default actions are `copy`, `retry`, and `discard`.
   */
  defaultOutputActions = defaultOutputActions;
  /**
   * Sets the output actions that display in the output card.
   * The default actions are `copy`, `retry`, and `discard`.
   * To customize the appearance and order of the default actions, define them with the same `name`.
   *
   * @default [{ name: 'copy', type: 'button', icon: 'copy', svgIcon: copyIcon, text: 'Copy', fillMode: 'flat', themeColor: 'primary', rounded: 'medium'}, { name: 'retry', type: 'button', icon: 'arrow-rotate-cw', svgIcon: arrowRotateCwIcon, text: 'Retry', fillMode: 'flat', themeColor: 'primary', rounded: 'medium'}, { name: 'discard', type: 'button', icon: 'cancel-outline', svgIcon: cancelOutlineIcon, text: 'Discard', fillMode: 'flat', themeColor: 'base', rounded: 'medium'}]
   */
  outputActions = defaultOutputActions;
  /**
   * Sets the available prompt commands.
   */
  promptCommands;
  /**
   * Sets the Popup settings.
   *
   */
  set popupSettings(settings) {
    this._popupSettings = __spreadValues(__spreadValues({}, defaultPopupSettings), settings);
  }
  get popupSettings() {
    return this._popupSettings;
  }
  /**
   * Fires when the send button is clicked.
   */
  promptRequest = new EventEmitter();
  /**
   * Fires when a command is executed.
   */
  commandExecute = new EventEmitter();
  /**
   * Fires when an output action button is clicked.
   */
  outputActionClick = new EventEmitter();
  /**
   * Fires when the stop button is clicked during streaming.
   */
  promptRequestCancel = new EventEmitter();
  /**
   * Fires when the component closes (Escape key, Discard action or outside click).
   */
  close = new EventEmitter();
  /**
   * Fires when the TextArea value changes.
   */
  promptValueChange = new EventEmitter();
  popupElement;
  popupViewContainer;
  contentComponent;
  outputTemplate;
  /**
   * @hidden
   */
  calculateMeasurement = calculateMeasurement;
  _popupSettings = defaultPopupSettings;
  subs = new Subscription();
  constructor(ngZone, element) {
    this.ngZone = ngZone;
    this.element = element;
    N(packageMetadata8);
  }
  ngAfterViewInit() {
    if (this.contentComponent && this.popupElement) {
      this.contentComponent.popupElement = this.popupElement;
    }
    this.ngZone.onStable.pipe(take(1)).subscribe(() => {
      if (this.contentComponent && this.popupViewContainer) {
        this.contentComponent.appendTo = this.popupViewContainer;
      }
    });
  }
  ngOnDestroy() {
    this.subs.unsubscribe();
  }
  /**
   * Focus the TextArea.
   */
  focus() {
    if (this.contentComponent?.textArea) {
      this.contentComponent.textArea.focus();
    }
  }
  /**
   * @hidden
   */
  onPromptRequest(event) {
    this.promptRequest.emit(event);
  }
  /**
   * @hidden
   */
  onCommandExecute(event) {
    this.commandExecute.emit(event);
  }
  /**
   * @hidden
   */
  onOutputActionClick(event) {
    this.outputActionClick.emit(event);
  }
  /**
   * @hidden
   */
  onPromptRequestCancel() {
    this.promptRequestCancel.emit();
  }
  /**
   * @hidden
   */
  onClose() {
    this.close.emit();
  }
  /**
   * @hidden
   */
  onPromptValueChange(value2) {
    this.promptValueChange.emit(value2);
  }
  static ɵfac = function InlineAIPromptComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _InlineAIPromptComponent)(ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _InlineAIPromptComponent,
    selectors: [["kendo-inlineaiprompt"]],
    contentQueries: function InlineAIPromptComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, InlineAIPromptOutputTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.outputTemplate = _t.first);
      }
    },
    viewQuery: function InlineAIPromptComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(PopupComponent, 5, ElementRef)(PopupComponent, 5, ViewContainerRef)(InlineAIPromptContentComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.popupElement = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.popupViewContainer = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.contentComponent = _t.first);
      }
    },
    inputs: {
      promptValue: "promptValue",
      placeholder: "placeholder",
      promptOutput: "promptOutput",
      enableSpeechToText: "enableSpeechToText",
      streaming: "streaming",
      width: "width",
      maxHeight: "maxHeight",
      outputActions: "outputActions",
      promptCommands: "promptCommands",
      popupSettings: "popupSettings"
    },
    outputs: {
      promptRequest: "promptRequest",
      commandExecute: "commandExecute",
      outputActionClick: "outputActionClick",
      promptRequestCancel: "promptRequestCancel",
      close: "close",
      promptValueChange: "promptValueChange"
    },
    exportAs: ["kendoInlineAIPrompt"],
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.inlineaiprompt"
    }])],
    decls: 3,
    vars: 22,
    consts: () => {
      let i18n_31;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_31 = goog.getMsg("Command Menu");
        i18n_31 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_31;
      } else {
        i18n_31 = $localize`:kendo.inlineaiprompt.commandsButtonTitle|Sets the Commands button title.:Command Menu`;
      }
      let i18n_32;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_32 = goog.getMsg("Generate");
        i18n_32 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_32;
      } else {
        i18n_32 = $localize`:kendo.inlineaiprompt.generateButtonTitle|Sets the Generate button title.:Generate`;
      }
      let i18n_33;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_33 = goog.getMsg("Speech to Text");
        i18n_33 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_FESM2022_PROGRESS_KENDO_ANGULAR_CONVERSATIONAL_UI_MJS_33;
      } else {
        i18n_33 = $localize`:kendo.inlineaiprompt.speechToTextButtonTitle|Sets the Speech to Text button title.:Speech to Text`;
      }
      return [["kendoInlineAIPromptLocalizedMessages", "", "commandsButtonTitle", i18n_31, "generateButtonTitle", i18n_32, "speechToTextButtonTitle", i18n_33], [3, "anchor", "anchorAlign", "offset", "popupAlign", "animate", "collision", "positionMode", "margin", "popupClass"], [3, "promptRequest", "commandExecute", "outputActionClick", "promptRequestCancel", "close", "promptValueChange", "promptValue", "placeholder", "promptOutput", "enableSpeechToText", "streaming", "maxHeight", "outputActions", "promptCommands", "outputTemplate"]];
    },
    template: function InlineAIPromptComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainer(0, 0);
        ɵɵelementStart(1, "kendo-popup", 1)(2, "kendo-inlineaiprompt-content", 2);
        ɵɵlistener("promptRequest", function InlineAIPromptComponent_Template_kendo_inlineaiprompt_content_promptRequest_2_listener($event) {
          return ctx.onPromptRequest($event);
        })("commandExecute", function InlineAIPromptComponent_Template_kendo_inlineaiprompt_content_commandExecute_2_listener($event) {
          return ctx.onCommandExecute($event);
        })("outputActionClick", function InlineAIPromptComponent_Template_kendo_inlineaiprompt_content_outputActionClick_2_listener($event) {
          return ctx.onOutputActionClick($event);
        })("promptRequestCancel", function InlineAIPromptComponent_Template_kendo_inlineaiprompt_content_promptRequestCancel_2_listener() {
          return ctx.onPromptRequestCancel();
        })("close", function InlineAIPromptComponent_Template_kendo_inlineaiprompt_content_close_2_listener() {
          return ctx.onClose();
        })("promptValueChange", function InlineAIPromptComponent_Template_kendo_inlineaiprompt_content_promptValueChange_2_listener($event) {
          return ctx.onPromptValueChange($event);
        });
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵstyleProp("width", ctx.calculateMeasurement(ctx.width));
        ɵɵproperty("anchor", ctx.popupSettings == null ? null : ctx.popupSettings.anchor)("anchorAlign", ctx.popupSettings == null ? null : ctx.popupSettings.anchorAlign)("offset", ctx.popupSettings == null ? null : ctx.popupSettings.offset)("popupAlign", ctx.popupSettings == null ? null : ctx.popupSettings.popupAlign)("animate", ctx.popupSettings == null ? null : ctx.popupSettings.animate)("collision", ctx.popupSettings == null ? null : ctx.popupSettings.collision)("positionMode", ctx.popupSettings == null ? null : ctx.popupSettings.positionMode)("margin", ctx.popupSettings == null ? null : ctx.popupSettings.margin)("popupClass", (ctx.popupSettings == null ? null : ctx.popupSettings.popupClass) || "k-prompt-popup");
        ɵɵadvance();
        ɵɵstyleProp("width", ctx.width);
        ɵɵproperty("promptValue", ctx.promptValue)("placeholder", ctx.placeholder)("promptOutput", ctx.promptOutput)("enableSpeechToText", ctx.enableSpeechToText)("streaming", ctx.streaming)("maxHeight", ctx.maxHeight)("outputActions", ctx.outputActions)("promptCommands", ctx.promptCommands)("outputTemplate", ctx.outputTemplate == null ? null : ctx.outputTemplate.templateRef);
      }
    },
    dependencies: [PopupComponent, InlineAIPromptContentComponent, LocalizedMessagesDirective6],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InlineAIPromptComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoInlineAIPrompt",
      selector: "kendo-inlineaiprompt",
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.inlineaiprompt"
      }],
      template: `
        <ng-container kendoInlineAIPromptLocalizedMessages
            i18n-commandsButtonTitle="kendo.inlineaiprompt.commandsButtonTitle|Sets the Commands button title."
            commandsButtonTitle="Command Menu"
            i18n-generateButtonTitle="kendo.inlineaiprompt.generateButtonTitle|Sets the Generate button title."
            generateButtonTitle="Generate"
            i18n-speechToTextButtonTitle="kendo.inlineaiprompt.speechToTextButtonTitle|Sets the Speech to Text button title."
            speechToTextButtonTitle="Speech to Text"
        >
        </ng-container>
        <kendo-popup
            [style.width]="calculateMeasurement(width)"
            [anchor]="popupSettings?.anchor"
            [anchorAlign]="popupSettings?.anchorAlign"
            [offset]="popupSettings?.offset"
            [popupAlign]="popupSettings?.popupAlign"
            [animate]="popupSettings?.animate"
            [collision]="popupSettings?.collision"
            [positionMode]="popupSettings?.positionMode"
            [margin]="popupSettings?.margin"
            [popupClass]="popupSettings?.popupClass || 'k-prompt-popup'"
        >
            <kendo-inlineaiprompt-content
                [style.width]="width"
                [promptValue]="promptValue"
                [placeholder]="placeholder"
                [promptOutput]="promptOutput"
                [enableSpeechToText]="enableSpeechToText"
                [streaming]="streaming"
                [maxHeight]="maxHeight"
                [outputActions]="outputActions"
                [promptCommands]="promptCommands"
                [outputTemplate]="outputTemplate?.templateRef"
                (promptRequest)="onPromptRequest($event)"
                (commandExecute)="onCommandExecute($event)"
                (outputActionClick)="onOutputActionClick($event)"
                (promptRequestCancel)="onPromptRequestCancel()"
                (close)="onClose()"
                (promptValueChange)="onPromptValueChange($event)"
            >
            </kendo-inlineaiprompt-content>
        </kendo-popup>
    `,
      standalone: true,
      imports: [KENDO_POPUP, InlineAIPromptContentComponent, LocalizedMessagesDirective6]
    }]
  }], () => [{
    type: NgZone
  }, {
    type: ElementRef
  }], {
    promptValue: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    promptOutput: [{
      type: Input
    }],
    enableSpeechToText: [{
      type: Input
    }],
    streaming: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    maxHeight: [{
      type: Input
    }],
    outputActions: [{
      type: Input
    }],
    promptCommands: [{
      type: Input
    }],
    popupSettings: [{
      type: Input
    }],
    promptRequest: [{
      type: Output
    }],
    commandExecute: [{
      type: Output
    }],
    outputActionClick: [{
      type: Output
    }],
    promptRequestCancel: [{
      type: Output
    }],
    close: [{
      type: Output
    }],
    promptValueChange: [{
      type: Output
    }],
    popupElement: [{
      type: ViewChild,
      args: [PopupComponent, {
        read: ElementRef
      }]
    }],
    popupViewContainer: [{
      type: ViewChild,
      args: [PopupComponent, {
        read: ViewContainerRef
      }]
    }],
    contentComponent: [{
      type: ViewChild,
      args: [InlineAIPromptContentComponent]
    }],
    outputTemplate: [{
      type: ContentChild,
      args: [InlineAIPromptOutputTemplateDirective]
    }]
  });
})();
var InlineAIPromptCustomMessagesComponent = class _InlineAIPromptCustomMessagesComponent extends Messages7 {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function InlineAIPromptCustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _InlineAIPromptCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _InlineAIPromptCustomMessagesComponent,
    selectors: [["kendo-inlineaiprompt-messages"]],
    features: [ɵɵProvidersFeature([{
      provide: Messages7,
      useExisting: forwardRef(() => _InlineAIPromptCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function InlineAIPromptCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InlineAIPromptCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: Messages7,
        useExisting: forwardRef(() => InlineAIPromptCustomMessagesComponent)
      }],
      selector: "kendo-inlineaiprompt-messages",
      template: ``,
      standalone: true
    }]
  }], () => [{
    type: LocalizationService
  }], null);
})();
var KENDO_AIPROMPT = [AIPromptComponent, PromptViewComponent, OutputViewComponent, CommandViewComponent, CustomViewComponent, AIPromptCustomMessagesComponent, AIPromptToolbarActionsDirective, AIPromptToolbarFocusableDirective, AIPromptOutputTemplateDirective, AIPromptOutputBodyTemplateDirective];
var KENDO_CHAT = [ChatComponent, CustomMessagesComponent4, AttachmentTemplateDirective, AuthorMessageContentTemplateDirective, ReceiverMessageContentTemplateDirective, MessageContentTemplateDirective, AuthorMessageTemplateDirective, ReceiverMessageTemplateDirective, MessageTemplateDirective, HeroCardComponent, ChatMessageBoxTemplateDirective, ChatHeaderTemplateDirective, NoDataTemplateDirective, ChatTimestampTemplateDirective, ChatStatusTemplateDirective, ChatSuggestionTemplateDirective, ChatUserStatusTemplateDirective];
var KENDO_INLINEAIPROMPT = [InlineAIPromptComponent, InlineAIPromptOutputTemplateDirective, InlineAIPromptCustomMessagesComponent];
var KENDO_CONVERSATIONALUI = [...KENDO_AIPROMPT, ...KENDO_CHAT, ...KENDO_INLINEAIPROMPT];
var AIPromptModule = class _AIPromptModule {
  static ɵfac = function AIPromptModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AIPromptModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _AIPromptModule,
    imports: [AIPromptComponent, PromptViewComponent, OutputViewComponent, CommandViewComponent, CustomViewComponent, AIPromptCustomMessagesComponent, AIPromptToolbarActionsDirective, AIPromptToolbarFocusableDirective, AIPromptOutputTemplateDirective, AIPromptOutputBodyTemplateDirective],
    exports: [AIPromptComponent, PromptViewComponent, OutputViewComponent, CommandViewComponent, CustomViewComponent, AIPromptCustomMessagesComponent, AIPromptToolbarActionsDirective, AIPromptToolbarFocusableDirective, AIPromptOutputTemplateDirective, AIPromptOutputBodyTemplateDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService, PopupService, ResizeBatchService, DialogContainerService, DialogService, WindowService, WindowContainerService],
    imports: [AIPromptComponent, PromptViewComponent, OutputViewComponent, CommandViewComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AIPromptModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_AIPROMPT],
      imports: [...KENDO_AIPROMPT],
      providers: [IconsService, PopupService, ResizeBatchService, DialogContainerService, DialogService, WindowService, WindowContainerService]
    }]
  }], null, null);
})();
var ChatModule = class _ChatModule {
  static ɵfac = function ChatModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ChatModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _ChatModule,
    imports: [ChatComponent, CustomMessagesComponent4, AttachmentTemplateDirective, AuthorMessageContentTemplateDirective, ReceiverMessageContentTemplateDirective, MessageContentTemplateDirective, AuthorMessageTemplateDirective, ReceiverMessageTemplateDirective, MessageTemplateDirective, HeroCardComponent, ChatMessageBoxTemplateDirective, ChatHeaderTemplateDirective, NoDataTemplateDirective, ChatTimestampTemplateDirective, ChatStatusTemplateDirective, ChatSuggestionTemplateDirective, ChatUserStatusTemplateDirective],
    exports: [ChatComponent, CustomMessagesComponent4, AttachmentTemplateDirective, AuthorMessageContentTemplateDirective, ReceiverMessageContentTemplateDirective, MessageContentTemplateDirective, AuthorMessageTemplateDirective, ReceiverMessageTemplateDirective, MessageTemplateDirective, HeroCardComponent, ChatMessageBoxTemplateDirective, ChatHeaderTemplateDirective, NoDataTemplateDirective, ChatTimestampTemplateDirective, ChatStatusTemplateDirective, ChatSuggestionTemplateDirective, ChatUserStatusTemplateDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService, ResizeBatchService],
    imports: [ChatComponent, HeroCardComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChatModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_CHAT],
      imports: [...KENDO_CHAT],
      providers: [IconsService, ResizeBatchService]
    }]
  }], null, null);
})();
var ConversationalUIModule = class _ConversationalUIModule {
  static ɵfac = function ConversationalUIModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ConversationalUIModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _ConversationalUIModule,
    imports: [AIPromptComponent, PromptViewComponent, OutputViewComponent, CommandViewComponent, CustomViewComponent, AIPromptCustomMessagesComponent, AIPromptToolbarActionsDirective, AIPromptToolbarFocusableDirective, AIPromptOutputTemplateDirective, AIPromptOutputBodyTemplateDirective, ChatComponent, CustomMessagesComponent4, AttachmentTemplateDirective, AuthorMessageContentTemplateDirective, ReceiverMessageContentTemplateDirective, MessageContentTemplateDirective, AuthorMessageTemplateDirective, ReceiverMessageTemplateDirective, MessageTemplateDirective, HeroCardComponent, ChatMessageBoxTemplateDirective, ChatHeaderTemplateDirective, NoDataTemplateDirective, ChatTimestampTemplateDirective, ChatStatusTemplateDirective, ChatSuggestionTemplateDirective, ChatUserStatusTemplateDirective, InlineAIPromptComponent, InlineAIPromptOutputTemplateDirective, InlineAIPromptCustomMessagesComponent],
    exports: [AIPromptComponent, PromptViewComponent, OutputViewComponent, CommandViewComponent, CustomViewComponent, AIPromptCustomMessagesComponent, AIPromptToolbarActionsDirective, AIPromptToolbarFocusableDirective, AIPromptOutputTemplateDirective, AIPromptOutputBodyTemplateDirective, ChatComponent, CustomMessagesComponent4, AttachmentTemplateDirective, AuthorMessageContentTemplateDirective, ReceiverMessageContentTemplateDirective, MessageContentTemplateDirective, AuthorMessageTemplateDirective, ReceiverMessageTemplateDirective, MessageTemplateDirective, HeroCardComponent, ChatMessageBoxTemplateDirective, ChatHeaderTemplateDirective, NoDataTemplateDirective, ChatTimestampTemplateDirective, ChatStatusTemplateDirective, ChatSuggestionTemplateDirective, ChatUserStatusTemplateDirective, InlineAIPromptComponent, InlineAIPromptOutputTemplateDirective, InlineAIPromptCustomMessagesComponent]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService, PopupService, ResizeBatchService, DialogContainerService, DialogService, WindowService, WindowContainerService],
    imports: [AIPromptComponent, PromptViewComponent, OutputViewComponent, CommandViewComponent, ChatComponent, HeroCardComponent, InlineAIPromptComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ConversationalUIModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_CONVERSATIONALUI],
      imports: [...KENDO_CONVERSATIONALUI],
      providers: [IconsService, PopupService, ResizeBatchService, DialogContainerService, DialogService, WindowService, WindowContainerService]
    }]
  }], null, null);
})();
var InlineAIPromptModule = class _InlineAIPromptModule {
  static ɵfac = function InlineAIPromptModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _InlineAIPromptModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _InlineAIPromptModule,
    imports: [InlineAIPromptComponent, InlineAIPromptOutputTemplateDirective, InlineAIPromptCustomMessagesComponent],
    exports: [InlineAIPromptComponent, InlineAIPromptOutputTemplateDirective, InlineAIPromptCustomMessagesComponent]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService, PopupService, ResizeBatchService, DialogContainerService, DialogService, WindowService, WindowContainerService],
    imports: [InlineAIPromptComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InlineAIPromptModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_INLINEAIPROMPT],
      imports: [...KENDO_INLINEAIPROMPT],
      providers: [IconsService, PopupService, ResizeBatchService, DialogContainerService, DialogService, WindowService, WindowContainerService]
    }]
  }], null, null);
})();
var InlineAIPromptService = class _InlineAIPromptService {
  popupService;
  /**
   * @hidden
   */
  constructor(popupService) {
    this.popupService = popupService;
  }
  /**
   * Opens an Inline AI Prompt component in a popup. The popup appears near the specified anchor element or at the provided offset coordinates.
   *
   * @param {InlineAIPromptSettings} options The options for the InlineAIPromptComponent.
   * @returns {PopupRef} A reference to the popup.
   */
  open(options) {
    const popupSettings = __spreadValues(__spreadValues({}, defaultPopupSettings), options?.popupSettings);
    const popupRef = this.popupService.open(__spreadProps(__spreadValues(__spreadProps(__spreadValues({}, options?.popupSettings?.anchor && {
      anchor: options.popupSettings.anchor
    }), {
      popupClass: "k-prompt-popup"
    }), popupSettings), {
      content: InlineAIPromptContentComponent
    }));
    const promptInstance = popupRef.content?.instance;
    if (promptInstance) {
      const popupViewContainer = popupRef.popup.injector.get(ViewContainerRef);
      promptInstance.appendTo = popupViewContainer;
      promptInstance.popupElement = popupRef.popupElement;
      this.projectComponentInputs(promptInstance, options);
      if (promptInstance.close) {
        promptInstance.close.subscribe(() => {
          popupRef.close();
        });
      }
      if (popupRef.content.changeDetectorRef) {
        popupRef.content.changeDetectorRef.detectChanges();
      }
    }
    return popupRef;
  }
  /**
   * Projects the input options onto the component instance.
   */
  projectComponentInputs(component, options) {
    if (!options) {
      return component;
    }
    Object.getOwnPropertyNames(options).forEach((prop2) => {
      component[prop2] = options[prop2];
    });
    return component;
  }
  static ɵfac = function InlineAIPromptService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _InlineAIPromptService)(ɵɵinject(PopupService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _InlineAIPromptService,
    factory: _InlineAIPromptService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InlineAIPromptService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: PopupService
  }], null);
})();

// node_modules/@progress/kendo-angular-grid/fesm2022/progress-kendo-angular-grid.mjs
var _c09 = ["kendoGridColGroup", ""];
function ColGroupComponent_For_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵdomElement(0, "col");
  }
  if (rf & 2) {
    ɵɵclassProp("k-group-col", true);
  }
}
function ColGroupComponent_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵdomElement(0, "col");
  }
  if (rf & 2) {
    ɵɵclassProp("k-hierarchy-col", true);
  }
}
function ColGroupComponent_For_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵdomElement(0, "col");
  }
  if (rf & 2) {
    const column_r1 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵstyleProp("width", ctx_r1.getColumnWidth(column_r1));
    ɵɵclassProp("k-sorted", ctx_r1.isSorted(ctx_r1.getColumnComponent(column_r1)));
  }
}
var _c117 = ["kendoGridLoading", ""];
function LoadingComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 1);
    ɵɵtext(1);
    ɵɵelementEnd();
    ɵɵelement(2, "div", 2)(3, "div", 3);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.loadingText);
  }
}
function LoadingComponent_Conditional_1_ng_template_0_Template(rf, ctx) {
}
function LoadingComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, LoadingComponent_Conditional_1_ng_template_0_Template, 0, 0, "ng-template", 0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.loadingTemplate == null ? null : ctx_r0.loadingTemplate.templateRef);
  }
}
var _c217 = ["kendoGridGroupHeader", ""];
var _c315 = (a0, a1, a2, a3, a4, a5, a6, a7) => ({
  templateRef: a0,
  group: a1,
  aggregates: a2,
  value: a3,
  field: a4,
  index: a5,
  expanded: a6,
  $implicit: a7
});
var _c410 = (a0, a1, a2, a3, a4, a5) => ({
  group: a0,
  aggregates: a1,
  value: a2,
  field: a3,
  index: a4,
  $implicit: a5
});
function GroupHeaderComponent_Conditional_0_For_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 1);
  }
}
function GroupHeaderComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵrepeaterCreate(0, GroupHeaderComponent_Conditional_0_For_1_Template, 1, 0, "td", 1, ɵɵrepeaterTrackByIndex);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵrepeater(ctx_r0.prefixGroupCell(ctx_r0.item));
  }
}
function GroupHeaderComponent_Conditional_1_Conditional_2_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
    ɵɵpipe(1, "valueOf");
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵtextInterpolate2(" ", ctx_r0.groupTitle(ctx_r0.item), ": ", ɵɵpipeBind3(1, 2, ctx_r0.item.data, "value", ctx_r0.formatForGroup(ctx_r0.item)), " ");
  }
}
function GroupHeaderComponent_Conditional_1_Conditional_2_ng_template_3_Template(rf, ctx) {
}
function GroupHeaderComponent_Conditional_1_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 4);
    ɵɵlistener("click", function GroupHeaderComponent_Conditional_1_Conditional_2_Template_a_click_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.toggleGroup(ctx_r0.item, $event));
    });
    ɵɵelement(1, "kendo-icon-wrapper", 5);
    ɵɵelementEnd();
    ɵɵconditionalCreate(2, GroupHeaderComponent_Conditional_1_Conditional_2_Conditional_2_Template, 2, 6);
    ɵɵtemplate(3, GroupHeaderComponent_Conditional_1_Conditional_2_ng_template_3_Template, 0, 0, "ng-template", 6);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵattribute("title", ctx_r0.groupButtonTitle)("aria-label", ctx_r0.groupButtonTitle);
    ɵɵadvance();
    ɵɵproperty("name", ctx_r0.arrowIcon)("svgIcon", ctx_r0.arrowSVGIcon);
    ɵɵadvance();
    ɵɵconditional(!ctx_r0.groupHeaderTemplate(ctx_r0.item) ? 2 : -1);
    ɵɵadvance();
    ɵɵproperty("templateContext", ɵɵpureFunction8(6, _c315, ctx_r0.groupHeaderTemplate(ctx_r0.item), ctx_r0.item.data, ctx_r0.item.data == null ? null : ctx_r0.item.data.aggregates, ctx_r0.item.data == null ? null : ctx_r0.item.data.value, ctx_r0.item.data == null ? null : ctx_r0.item.data.field, ctx_r0.item.index, ctx_r0.isExpanded, ctx_r0.item.data));
  }
}
function GroupHeaderComponent_Conditional_1_Conditional_3_For_2_Conditional_0_ng_template_1_Template(rf, ctx) {
}
function GroupHeaderComponent_Conditional_1_Conditional_3_For_2_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 7);
    ɵɵtemplate(1, GroupHeaderComponent_Conditional_1_Conditional_3_For_2_Conditional_0_ng_template_1_Template, 0, 0, "ng-template", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r3 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", column_r3.groupHeaderColumnTemplateRef)("ngTemplateOutletContext", ɵɵpureFunction6(2, _c410, ctx_r0.item.data, ctx_r0.item.data == null ? null : ctx_r0.item.data.aggregates, ctx_r0.item.data == null ? null : ctx_r0.item.data.value, ctx_r0.item.data == null ? null : ctx_r0.item.data.field, ctx_r0.item.index, ctx_r0.item.data));
  }
}
function GroupHeaderComponent_Conditional_1_Conditional_3_For_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, GroupHeaderComponent_Conditional_1_Conditional_3_For_2_Conditional_0_Template, 2, 9, "div", 7);
  }
  if (rf & 2) {
    const column_r3 = ctx.$implicit;
    ɵɵconditional(column_r3.groupHeaderColumnTemplateRef ? 0 : -1);
  }
}
function GroupHeaderComponent_Conditional_1_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 3);
    ɵɵrepeaterCreate(1, GroupHeaderComponent_Conditional_1_Conditional_3_For_2_Template, 1, 1, null, null, ɵɵrepeaterTrackByIdentity);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵrepeater(ctx_r0.groupHeaderColumns);
  }
}
function GroupHeaderComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 0)(1, "p", 2);
    ɵɵconditionalCreate(2, GroupHeaderComponent_Conditional_1_Conditional_2_Template, 4, 15);
    ɵɵelementEnd();
    ɵɵconditionalCreate(3, GroupHeaderComponent_Conditional_1_Conditional_3_Template, 3, 0, "div", 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("logicalRowIndex", ctx_r0.logicalRowIndex)("logicalColIndex", 0)("logicalSlaveCell", ctx_r0.skipGroupDecoration)("groupItem", ctx_r0.item)("colSpan", ctx_r0.logicalColSpan());
    ɵɵattribute("colspan", ctx_r0.groupSpan(ctx_r0.item))("role", ctx_r0.ariaRole())("aria-expanded", ctx_r0.isExpanded);
    ɵɵadvance(2);
    ɵɵconditional(!ctx_r0.skipGroupDecoration ? 2 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r0.isStacked ? 3 : -1);
  }
}
function GroupHeaderComponent_Conditional_2_For_1_Conditional_1_ng_template_0_Template(rf, ctx) {
}
function GroupHeaderComponent_Conditional_2_For_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, GroupHeaderComponent_Conditional_2_For_1_Conditional_1_ng_template_0_Template, 0, 0, "ng-template", 8);
  }
  if (rf & 2) {
    const column_r4 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", column_r4.groupHeaderColumnTemplateRef)("ngTemplateOutletContext", ɵɵpureFunction6(2, _c410, ctx_r0.item.data, ctx_r0.item.data == null ? null : ctx_r0.item.data.aggregates, ctx_r0.item.data == null ? null : ctx_r0.item.data.value, ctx_r0.item.data == null ? null : ctx_r0.item.data.field, ctx_r0.item.index, ctx_r0.item.data));
  }
}
function GroupHeaderComponent_Conditional_2_For_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 9);
    ɵɵconditionalCreate(1, GroupHeaderComponent_Conditional_2_For_1_Conditional_1_Template, 1, 9, null, 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r4 = ctx.$implicit;
    const ɵ$index_30_r5 = ctx.$index;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("logicalRowIndex", ctx_r0.logicalRowIndex)("logicalColIndex", ɵ$index_30_r5 + 1)("logicalSlaveCell", false)("groupItem", ctx_r0.item)("colSpan", 1);
    ɵɵadvance();
    ɵɵconditional(column_r4.groupHeaderColumnTemplateRef ? 1 : -1);
  }
}
function GroupHeaderComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵrepeaterCreate(0, GroupHeaderComponent_Conditional_2_For_1_Template, 2, 6, "td", 9, ɵɵrepeaterTrackByIdentity);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵrepeater(ctx_r0.groupHeaderColumns);
  }
}
var _c57 = ["defaultTemplate"];
var _c66 = () => ({
  lastTarget: true
});
var _c75 = (a0, a1, a2) => ({
  field: a0,
  type: "groupIndicator",
  hint: a1,
  target: a2
});
var _c85 = (a0, a1) => ({
  keydown: a0,
  click: a1
});
function GroupPanelComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 2);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("context", ɵɵpureFunction0(2, _c66));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.text, " ");
  }
}
function GroupPanelComponent_Conditional_1_For_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-chip", 5, 1);
    ɵɵlistener("contentClick", function GroupPanelComponent_Conditional_1_For_2_Template_kendo_chip_contentClick_0_listener() {
      const group_r3 = ɵɵrestoreView(_r2).$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.directionChange(group_r3));
    })("remove", function GroupPanelComponent_Conditional_1_For_2_Template_kendo_chip_remove_0_listener() {
      const group_r3 = ɵɵrestoreView(_r2).$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.remove(group_r3));
    })("menuToggle", function GroupPanelComponent_Conditional_1_For_2_Template_kendo_chip_menuToggle_0_listener() {
      const ctx_r3 = ɵɵrestoreView(_r2);
      const group_r3 = ctx_r3.$implicit;
      const ɵ$index_8_r5 = ctx_r3.$index;
      const ɵ$count_8_r6 = ctx_r3.$count;
      const chip_r7 = ɵɵreference(1);
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.toggleMenu(chip_r7, ɵ$index_8_r5 === 0, ɵ$index_8_r5 === ɵ$count_8_r6 - 1, group_r3.field));
    })("keydown.alt.arrowdown", function GroupPanelComponent_Conditional_1_For_2_Template_kendo_chip_keydown_alt_arrowdown_0_listener($event) {
      const ctx_r7 = ɵɵrestoreView(_r2);
      const group_r3 = ctx_r7.$implicit;
      const ɵ$index_8_r5 = ctx_r7.$index;
      const ɵ$count_8_r6 = ctx_r7.$count;
      const chip_r7 = ɵɵreference(1);
      const ctx_r0 = ɵɵnextContext(2);
      $event.preventDefault();
      return ɵɵresetView(ctx_r0.toggleMenu(chip_r7, ɵ$index_8_r5 === 0, ɵ$index_8_r5 === ɵ$count_8_r6 - 1, group_r3.field));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const group_r3 = ctx.$implicit;
    const ɵ$index_8_r5 = ctx.$index;
    const chip_r7 = ɵɵreference(1);
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("title", ctx_r0.getTitle(group_r3))("enableDrag", true)("context", ɵɵpureFunction3(11, _c75, group_r3.field, ctx_r0.groupTitles[ɵ$index_8_r5], chip_r7))("label", ctx_r0.groupTitles[ɵ$index_8_r5])("removable", true)("hasMenu", true)("icon", ctx_r0.getDirectionIcon(group_r3))("svgIcon", ctx_r0.getDirectionSvgIcon(group_r3));
    ɵɵattribute("aria-haspopup", "menu")("aria-expanded", ctx_r0.isChipMenuOpen)("aria-controls", ctx_r0.gridId);
  }
}
function GroupPanelComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-chiplist", 3);
    ɵɵrepeaterCreate(1, GroupPanelComponent_Conditional_1_For_2_Template, 2, 15, "kendo-chip", 4, ɵɵrepeaterTrackByIdentity);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("navigable", ctx_r0.navigable)("orientation", null);
    ɵɵadvance();
    ɵɵrepeater(ctx_r0.groups);
  }
}
function GroupPanelComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 2);
    ɵɵtext(1, " ");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    ɵɵproperty("context", ɵɵpureFunction0(1, _c66));
  }
}
function GroupPanelComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "ul", 6)(1, "li", 7)(2, "span", 8);
    ɵɵelement(3, "kendo-icon-wrapper", 9);
    ɵɵelementStart(4, "span", 10);
    ɵɵtext(5);
    ɵɵelementEnd()()();
    ɵɵelementStart(6, "li", 7)(7, "span", 8);
    ɵɵelement(8, "kendo-icon-wrapper", 9);
    ɵɵelementStart(9, "span", 10);
    ɵɵtext(10);
    ɵɵelementEnd()()()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction2(13, _c85, ctx_r0.handleKeyDown, ctx_r0.handleClick));
    ɵɵadvance();
    ɵɵattribute("aria-disabled", ctx_r0.first);
    ɵɵadvance();
    ɵɵclassProp("k-disabled", ctx_r0.first);
    ɵɵadvance();
    ɵɵproperty("name", ctx_r0.rtl ? "arrow-right" : "arrow-left")("svgIcon", ctx_r0.rtl ? ctx_r0.arrowRightIcon : ctx_r0.arrowLeftIcon);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.messageFor("groupChipMenuPrevious"));
    ɵɵadvance();
    ɵɵattribute("aria-disabled", ctx_r0.last);
    ɵɵadvance();
    ɵɵclassProp("k-disabled", ctx_r0.last);
    ɵɵadvance();
    ɵɵproperty("name", ctx_r0.rtl ? "arrow-left" : "arrow-right")("svgIcon", ctx_r0.rtl ? ctx_r0.arrowLeftIcon : ctx_r0.arrowRightIcon);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.messageFor("groupChipMenuNext"));
  }
}
var _c95 = ["dropdown"];
var _c105 = () => ({
  width: "auto"
});
function FilterCellOperatorsComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-dropdownlist", 3, 0);
    ɵɵlistener("valueChange", function FilterCellOperatorsComponent_Conditional_0_Template_kendo_dropdownlist_valueChange_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onChange($event));
    })("keydown", function FilterCellOperatorsComponent_Conditional_0_Template_kendo_dropdownlist_keydown_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.dropdownKeydown($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("data", ctx_r1.operators)("value", ctx_r1.value)("svgIcon", ctx_r1.filterSVGIcon)("valuePrimitive", true)("popupSettings", ɵɵpureFunction0(7, _c105))("size", ctx_r1.size);
    ɵɵattribute("aria-label", ctx_r1.column && ctx_r1.columnLabel);
  }
}
function FilterCellOperatorsComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 4);
    ɵɵlistener("click", function FilterCellOperatorsComponent_Conditional_1_Template_button_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clearClick());
    })("keydown", function FilterCellOperatorsComponent_Conditional_1_Template_button_keydown_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clearKeydown($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("svgIcon", ctx_r1.filterClearIcon)("title", ctx_r1.clearText)("size", ctx_r1.size);
  }
}
var _c118 = ["*"];
function StringFilterMenuComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-dropdownlist", 3);
    ɵɵlistener("valueChange", function StringFilterMenuComponent_Conditional_1_Template_kendo_dropdownlist_valueChange_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.logicChange($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("adaptiveTitle", ctx_r1.ctx.localization.get("adaptiveFilterOperatorsTitle"))("adaptiveMode", ctx_r1.ctx.grid == null ? null : ctx_r1.ctx.grid.adaptiveMode)("size", (ctx_r1.ctx.grid == null ? null : ctx_r1.ctx.grid.isActionSheetExpanded) ? "large" : null)("filterMenuDropDownLabel", ctx_r1.filterMenuDropDownLabel)("data", ctx_r1.logicOperators)("valuePrimitive", true)("value", ctx_r1.filter == null ? null : ctx_r1.filter.logic);
  }
}
function StringFilterMenuComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-string-filter-menu-input", 2);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("operators", ctx_r1.operators)("currentFilter", ctx_r1.secondFilter)("filterService", ctx_r1.filterService)("column", ctx_r1.column)("filter", ctx_r1.filter)("placeholder", ctx_r1.extraPlaceholder)("menuTabbingService", ctx_r1.menuTabbingService);
  }
}
function NumericFilterMenuComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-dropdownlist", 3);
    ɵɵlistener("valueChange", function NumericFilterMenuComponent_Conditional_1_Template_kendo_dropdownlist_valueChange_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.logicChange($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("adaptiveTitle", ctx_r1.ctx.localization.get("adaptiveFilterOperatorsTitle"))("adaptiveMode", ctx_r1.ctx.grid == null ? null : ctx_r1.ctx.grid.adaptiveMode)("size", (ctx_r1.ctx.grid == null ? null : ctx_r1.ctx.grid.isActionSheetExpanded) ? "large" : null)("filterMenuDropDownLabel", ctx_r1.filterMenuDropDownLabel)("data", ctx_r1.logicOperators)("valuePrimitive", true)("value", ctx_r1.filter == null ? null : ctx_r1.filter.logic);
  }
}
function NumericFilterMenuComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-numeric-filter-menu-input", 2);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("operators", ctx_r1.operators)("currentFilter", ctx_r1.secondFilter)("filterService", ctx_r1.filterService)("column", ctx_r1.column)("filter", ctx_r1.filter)("format", ctx_r1.format)("decimals", ctx_r1.decimals)("spinners", ctx_r1.spinners)("min", ctx_r1.min)("max", ctx_r1.max)("step", ctx_r1.step)("menuTabbingService", ctx_r1.menuTabbingService)("placeholder", ctx_r1.extraPlaceholder);
  }
}
function DateFilterMenuComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-dropdownlist", 3);
    ɵɵlistener("valueChange", function DateFilterMenuComponent_Conditional_1_Template_kendo_dropdownlist_valueChange_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.logicChange($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("adaptiveTitle", ctx_r1.ctx.localization.get("adaptiveFilterOperatorsTitle"))("adaptiveMode", ctx_r1.ctx.grid == null ? null : ctx_r1.ctx.grid.adaptiveMode)("size", (ctx_r1.ctx.grid == null ? null : ctx_r1.ctx.grid.isActionSheetExpanded) ? "large" : null)("filterMenuDropDownLabel", ctx_r1.filterMenuDropDownLabel)("data", ctx_r1.logicOperators)("valuePrimitive", true)("value", ctx_r1.filter == null ? null : ctx_r1.filter.logic);
  }
}
function DateFilterMenuComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-date-filter-menu-input", 2);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("operators", ctx_r1.operators)("currentFilter", ctx_r1.secondFilter)("filterService", ctx_r1.filterService)("column", ctx_r1.column)("filter", ctx_r1.filter)("activeView", ctx_r1.activeView)("bottomView", ctx_r1.bottomView)("topView", ctx_r1.topView)("format", ctx_r1.format)("formatPlaceholder", ctx_r1.formatPlaceholder)("placeholder", ctx_r1.placeholder)("min", ctx_r1.min)("max", ctx_r1.max)("weekNumber", ctx_r1.weekNumber)("menuTabbingService", ctx_r1.menuTabbingService);
  }
}
function BooleanFilterMenuComponent_For_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "li")(1, "kendo-radiobutton", 2, 0);
    ɵɵlistener("change", function BooleanFilterMenuComponent_For_2_Template_kendo_radiobutton_change_1_listener() {
      const item_r2 = ɵɵrestoreView(_r1).$implicit;
      const input_r3 = ɵɵreference(2);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.onChange(item_r2.value, input_r3));
    })("keydown.shift.tab", function BooleanFilterMenuComponent_For_2_Template_kendo_radiobutton_keydown_shift_tab_1_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.onShiftTab($event));
    });
    ɵɵelementEnd();
    ɵɵelementStart(3, "label", 3);
    ɵɵtext(4);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const item_r2 = ctx.$implicit;
    const input_r3 = ɵɵreference(2);
    const ctx_r3 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("columnLabel", ctx_r3.columnLabel)("size", (ctx_r3.ctx.grid == null ? null : ctx_r3.ctx.grid.isActionSheetExpanded) ? "large" : null)("name", ctx_r3.idPrefix)("checked", ctx_r3.isSelected(item_r2.value));
    ɵɵattribute("id", ctx_r3.radioId(item_r2.value));
    ɵɵadvance(2);
    ɵɵattribute("for", input_r3.focusableId);
    ɵɵadvance();
    ɵɵtextInterpolate(item_r2.text);
  }
}
function MultiCheckboxFilterComponent_Conditional_0_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 6);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("svgIcon", ctx_r0.searchIcon);
  }
}
function MultiCheckboxFilterComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-textbox", 0);
    ɵɵtemplate(1, MultiCheckboxFilterComponent_Conditional_0_ng_template_1_Template, 1, 1, "ng-template", 5);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("placeholder", ctx_r0.messageFor("multiCheckboxFilterSearchPlaceholder"));
  }
}
function MultiCheckboxFilterComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "li", 2)(1, "label", 7)(2, "kendo-checkbox", 8);
    ɵɵlistener("checkedStateChange", function MultiCheckboxFilterComponent_Conditional_2_Template_kendo_checkbox_checkedStateChange_2_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.handleCheckBoxChange($event, null, true));
    });
    ɵɵelementEnd();
    ɵɵelementStart(3, "span");
    ɵɵtext(4);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵproperty("checkedState", ctx_r0.selectAllChecked);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.messageFor("multiCheckboxFilterSelectAllLabel"));
  }
}
function MultiCheckboxFilterComponent_For_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "li", 3)(1, "label", 7)(2, "kendo-checkbox", 8);
    ɵɵlistener("checkedStateChange", function MultiCheckboxFilterComponent_For_4_Template_kendo_checkbox_checkedStateChange_2_listener($event) {
      const item_r4 = ɵɵrestoreView(_r3).$implicit;
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.handleCheckBoxChange($event, item_r4));
    });
    ɵɵelementEnd();
    ɵɵelementStart(3, "span");
    ɵɵtext(4);
    ɵɵpipe(5, "format");
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const item_r4 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵproperty("checkedState", ctx_r0.isItemSelected(item_r4));
    ɵɵadvance(2);
    ɵɵtextInterpolate(ɵɵpipeBind2(5, 2, item_r4, ctx_r0.column.format));
  }
}
var _c124 = ["resetButton"];
var _c134 = (a0) => ({
  "k-popup k-group k-reset": a0
});
var _c144 = (a0) => ({
  "k-button-rectangle": a0
});
function FilterMenuContainerComponent_Case_2_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 5);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("filterService", ctx_r0.childService)("column", ctx_r0.column)("filter", ctx_r0.childFilter)("menuTabbingService", ctx_r0.menuTabbingService);
  }
}
function FilterMenuContainerComponent_Case_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-multicheckbox-filter", 7);
    ɵɵlistener("filterChange", function FilterMenuContainerComponent_Case_2_Conditional_1_Template_kendo_grid_multicheckbox_filter_filterChange_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.onCheckboxFilterChange($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("column", ctx_r0.column);
  }
}
function FilterMenuContainerComponent_Case_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, FilterMenuContainerComponent_Case_2_Conditional_0_Template, 1, 4, "ng-container", 5)(1, FilterMenuContainerComponent_Case_2_Conditional_1_Template, 1, 1, "kendo-grid-multicheckbox-filter", 6);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵconditional(!ctx_r0.isMultiFilter ? 0 : 1);
  }
}
function FilterMenuContainerComponent_Case_3_Conditional_0_ng_template_0_Template(rf, ctx) {
}
function FilterMenuContainerComponent_Case_3_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, FilterMenuContainerComponent_Case_3_Conditional_0_ng_template_0_Template, 0, 0, "ng-template", 8);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.column.filterMenuTemplateRef)("ngTemplateOutletContext", ctx_r0.templateContext);
  }
}
function FilterMenuContainerComponent_Case_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, FilterMenuContainerComponent_Case_3_Conditional_0_Template, 1, 2, null, 8);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵconditional(ctx_r0.column.filterMenuTemplateRef ? 0 : -1);
  }
}
function FilterMenuContainerComponent_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 4)(1, "button", 9, 0);
    ɵɵlistener("keydown.tab", function FilterMenuContainerComponent_Conditional_4_Template_button_keydown_tab_1_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.onTab($event, "filter"));
    });
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵelementStart(4, "button", 10, 1);
    ɵɵlistener("keydown.tab", function FilterMenuContainerComponent_Conditional_4_Template_button_keydown_tab_4_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.onTab($event, "reset"));
    });
    ɵɵtext(6);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ctx_r0.actionsClass);
    ɵɵadvance();
    ɵɵproperty("ngClass", ɵɵpureFunction1(10, _c144, !ctx_r0.isMultiFilter))("disabled", ctx_r0.disabled)("icon", ctx_r0.getButtonIcon("filter", "icon"))("svgIcon", ctx_r0.getButtonIcon("filter", "svgIcon"));
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.filterText);
    ɵɵadvance();
    ɵɵproperty("ngClass", ɵɵpureFunction1(12, _c144, !ctx_r0.isMultiFilter))("icon", ctx_r0.getButtonIcon("reset", "icon"))("svgIcon", ctx_r0.getButtonIcon("reset", "svgIcon"));
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.clearText);
  }
}
var _c154 = ["anchor"];
var _c164 = ["template"];
function FilterMenuComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-filter-menu-container", 4);
    ɵɵlistener("close", function FilterMenuComponent_ng_template_3_Template_kendo_grid_filter_menu_container_close_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.close());
    })("keydown.escape", function FilterMenuComponent_ng_template_3_Template_kendo_grid_filter_menu_container_keydown_escape_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.close());
    })("keydown.enter", function FilterMenuComponent_ng_template_3_Template_kendo_grid_filter_menu_container_keydown_enter_0_listener($event) {
      ɵɵrestoreView(_r4);
      return ɵɵresetView($event.stopImmediatePropagation());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵproperty("column", ctx_r4.column)("filter", ctx_r4.filter);
  }
}
var _c174 = ["kendoGridFilterCell", ""];
function FilterCellComponent_Conditional_0_Case_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("column", ctx_r0.column)("filter", ctx_r0.filter);
  }
}
function FilterCellComponent_Conditional_0_Case_1_Conditional_0_ng_template_0_Template(rf, ctx) {
}
function FilterCellComponent_Conditional_0_Case_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, FilterCellComponent_Conditional_0_Case_1_Conditional_0_ng_template_0_Template, 0, 0, "ng-template", 1);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.column.filterCellTemplateRef)("ngTemplateOutletContext", ctx_r0.templateContext);
  }
}
function FilterCellComponent_Conditional_0_Case_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, FilterCellComponent_Conditional_0_Case_1_Conditional_0_Template, 1, 2, null, 1);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵconditional(ctx_r0.column.filterCellTemplateRef ? 0 : -1);
  }
}
function FilterCellComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, FilterCellComponent_Conditional_0_Case_0_Template, 1, 2, "ng-container", 0)(1, FilterCellComponent_Conditional_0_Case_1_Template, 1, 1);
  }
  if (rf & 2) {
    let tmp_1_0;
    const ctx_r0 = ɵɵnextContext();
    ɵɵconditional((tmp_1_0 = ctx_r0.hasTemplate) === false ? 0 : tmp_1_0 === true ? 1 : -1);
  }
}
var _c184 = ["kendoGridFilterRow", ""];
function FilterRowComponent_For_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 0);
  }
}
function FilterRowComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 1);
  }
}
function FilterRowComponent_For_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 3);
  }
  if (rf & 2) {
    const column_r1 = ctx.$implicit;
    const ɵ$index_7_r2 = ctx.$index;
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassProp("k-grid-header-sticky", column_r1.sticky);
    ɵɵproperty("ngStyle", ctx_r2.addStickyStyles(column_r1))("ngClass", column_r1.filterClass)("column", column_r1)("filter", ctx_r2.filter)("logicalRowIndex", ctx_r2.logicalRowIndex)("logicalColIndex", ctx_r2.getLogicalColIndex(ɵ$index_7_r2));
    ɵɵattribute("aria-label", ctx_r2.filterLabel(column_r1));
  }
}
var _c194 = () => ({
  "data-index": "0"
});
var _c204 = (a0) => ({
  "data-index": a0
});
function ColumnListComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "label", 2)(1, "kendo-checkbox", 3, 0);
    ɵɵlistener("checkedStateChange", function ColumnListComponent_Conditional_1_Template_kendo_checkbox_checkedStateChange_1_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onSelectAllCheckboxChange($event));
    });
    ɵɵelementEnd();
    ɵɵelementStart(3, "span", 4);
    ɵɵtext(4);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("inputAttributes", ɵɵpureFunction0(4, _c194))("tabindex", -1)("checkedState", ctx_r1.checkedCheckboxesLength === ctx_r1.columns.length);
    ɵɵadvance(3);
    ɵɵtextInterpolate(ctx_r1.selectAllText);
  }
}
function ColumnListComponent_For_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "label", 2)(1, "kendo-checkbox", 3, 0);
    ɵɵlistener("checkedStateChange", function ColumnListComponent_For_3_Template_kendo_checkbox_checkedStateChange_1_listener($event) {
      const ctx_r3 = ɵɵrestoreView(_r3);
      const column_r5 = ctx_r3.$implicit;
      const ɵ$index_11_r6 = ctx_r3.$index;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onCheckboxChange($event, column_r5, ɵ$index_11_r6));
    });
    ɵɵelementEnd();
    ɵɵelementStart(3, "span", 4);
    ɵɵtext(4);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const column_r5 = ctx.$implicit;
    const ɵ$index_11_r6 = ctx.$index;
    ɵɵadvance();
    ɵɵproperty("inputAttributes", ɵɵpureFunction1(4, _c204, ɵ$index_11_r6.toString()))("tabindex", -1)("checkedState", column_r5.currentlyChecked);
    ɵɵadvance(3);
    ɵɵtextInterpolate(column_r5.displayTitle);
  }
}
var _c218 = ["applyButton"];
var _c224 = ["columnList"];
var _c234 = ["filterInput"];
var _c243 = (a0) => ({
  "keydown": a0
});
function ColumnChooserContentComponent_Conditional_2_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 12);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("name", "search")("svgIcon", ctx_r2.searchIcon);
  }
}
function ColumnChooserContentComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-textbox", 10, 1);
    ɵɵlistener("valueChange", function ColumnChooserContentComponent_Conditional_2_Template_kendo_textbox_valueChange_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onFilter($event));
    });
    ɵɵtemplate(2, ColumnChooserContentComponent_Conditional_2_ng_template_2_Template, 1, 2, "ng-template", 11);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction1(2, _c243, ctx_r2.onTab))("scope", ctx_r2);
  }
}
function ColumnChooserContentComponent_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 8);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r2.selectedItemsText, " ");
  }
}
function ColumnChooserContentComponent_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 9)(1, "button", 13, 2);
    ɵɵlistener("click", function ColumnChooserContentComponent_Conditional_6_Template_button_click_1_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.applyChanges());
    })("keydown", function ColumnChooserContentComponent_Conditional_6_Template_button_keydown_1_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onApplyButtonKeydown($event));
    });
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵelementStart(4, "button", 14, 3);
    ɵɵlistener("keydown.tab", function ColumnChooserContentComponent_Conditional_6_Template_button_keydown_tab_4_listener($event) {
      ɵɵrestoreView(_r4);
      ɵɵnextContext();
      const columnList_r5 = ɵɵreference(4);
      return ɵɵresetView(columnList_r5.onTab($event));
    })("click", function ColumnChooserContentComponent_Conditional_6_Template_button_click_4_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.cancelChanges());
    });
    ɵɵtext(6);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("ngClass", ctx_r2.actionsClass);
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r2.checkIcon);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r2.applyText);
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r2.arrowRotateCcwIcon);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r2.resetText);
  }
}
function ColumnChooserComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-column-chooser-content", 3);
    ɵɵlistener("close", function ColumnChooserComponent_ng_template_2_Template_kendo_grid_column_chooser_content_close_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.close(true));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵproperty("columns", ctx_r4.columns)("autoSync", ctx_r4.autoSync)("filterable", ctx_r4.filterable)("showSelectAll", ctx_r4.showSelectAll)("closeOnReset", false)("isLast", true)("allowHideAll", ctx_r4.allowHideAll);
  }
}
function ColumnMenuItemComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 1);
    ɵɵelementContainer(1, 2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    ɵɵnextContext();
    const content_r1 = ɵɵreference(3);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", content_r1);
  }
}
function ColumnMenuItemComponent_Conditional_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 4);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("name", ctx_r2.icon)("svgIcon", ctx_r2.svgIcon);
  }
}
function ColumnMenuItemComponent_Conditional_1_Conditional_3_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 10);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r2.sortOrder(ctx_r2.column.field));
  }
}
function ColumnMenuItemComponent_Conditional_1_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 5);
    ɵɵelement(1, "kendo-icon-wrapper", 4);
    ɵɵconditionalCreate(2, ColumnMenuItemComponent_Conditional_1_Conditional_3_Conditional_2_Template, 2, 1, "span", 10);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("name", ctx_r2.sortDescriptor(ctx_r2.column.field).dir === "asc" ? "sort-asc-small" : "sort-desc-small")("svgIcon", ctx_r2.sortDescriptor(ctx_r2.column.field).dir === "asc" ? ctx_r2.sortAscSmallIcon : ctx_r2.sortDescSmallIcon);
    ɵɵadvance();
    ɵɵconditional(ctx_r2.showSortNumbering(ctx_r2.column) ? 2 : -1);
  }
}
function ColumnMenuItemComponent_Conditional_1_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 6);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("svgIcon", ctx_r2.filterIcon);
  }
}
function ColumnMenuItemComponent_Conditional_1_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 7);
  }
}
function ColumnMenuItemComponent_Conditional_1_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 8);
    ɵɵelement(1, "kendo-icon-wrapper", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("name", ctx_r2.expandedIcon)("svgIcon", ctx_r2.expandedSvgIcon);
  }
}
function ColumnMenuItemComponent_Conditional_1_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 11);
    ɵɵelementContainer(1, 2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵstyleProp("overflow", "hidden");
    ɵɵproperty("@state", ctx_r2.contentState);
    ɵɵattribute("id", ctx_r2.contentId);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r2.contentTemplate.templateRef);
  }
}
function ColumnMenuItemComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 3);
    ɵɵlistener("click", function ColumnMenuItemComponent_Conditional_1_Template_div_click_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onClick($event));
    })("keydown.enter", function ColumnMenuItemComponent_Conditional_1_Template_div_keydown_enter_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onClick($event));
    });
    ɵɵconditionalCreate(1, ColumnMenuItemComponent_Conditional_1_Conditional_1_Template, 1, 2, "kendo-icon-wrapper", 4);
    ɵɵtext(2);
    ɵɵconditionalCreate(3, ColumnMenuItemComponent_Conditional_1_Conditional_3_Template, 3, 3, "span", 5);
    ɵɵconditionalCreate(4, ColumnMenuItemComponent_Conditional_1_Conditional_4_Template, 1, 1, "kendo-icon-wrapper", 6);
    ɵɵconditionalCreate(5, ColumnMenuItemComponent_Conditional_1_Conditional_5_Template, 1, 0, "span", 7);
    ɵɵconditionalCreate(6, ColumnMenuItemComponent_Conditional_1_Conditional_6_Template, 2, 2, "span", 8);
    ɵɵelementEnd();
    ɵɵconditionalCreate(7, ColumnMenuItemComponent_Conditional_1_Conditional_7_Template, 2, 5, "div", 9);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassProp("k-selected", ctx_r2.selected)("k-disabled", ctx_r2.disabled)("k-focus", ctx_r2.focused);
    ɵɵattribute("aria-expanded", ctx_r2.expanded)("aria-controls", ctx_r2.expanded ? ctx_r2.contentId : void 0);
    ɵɵadvance();
    ɵɵconditional(ctx_r2.icon || ctx_r2.svgIcon ? 1 : -1);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r2.text, " ");
    ɵɵadvance();
    ɵɵconditional(ctx_r2.ctx.grid.isActionSheetExpanded && ctx_r2.adaptiveGridService.viewType === "sortToolbarTool" && ctx_r2.sortDescriptor(ctx_r2.column.field).dir ? 3 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r2.ctx.grid.isActionSheetExpanded && ctx_r2.adaptiveGridService.viewType === "filterToolbarTool" && ctx_r2.hasFilters || ctx_r2.indicatorIcon ? 4 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r2.contentTemplate && ctx_r2.adaptiveGridService.viewType !== "sortToolbarTool" ? 5 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r2.contentTemplate && ctx_r2.adaptiveGridService.viewType !== "sortToolbarTool" ? 6 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r2.contentTemplate ? 7 : -1);
  }
}
function ColumnMenuItemComponent_ng_template_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 4);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("name", ctx_r2.icon)("svgIcon", ctx_r2.svgIcon);
  }
}
function ColumnMenuItemComponent_ng_template_2_Conditional_3_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 10);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r2.sortOrder(ctx_r2.column.field));
  }
}
function ColumnMenuItemComponent_ng_template_2_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 5);
    ɵɵelement(1, "kendo-icon-wrapper", 4);
    ɵɵconditionalCreate(2, ColumnMenuItemComponent_ng_template_2_Conditional_3_Conditional_2_Template, 2, 1, "span", 10);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("name", ctx_r2.sortDescriptor(ctx_r2.column.field).dir === "asc" ? "sort-asc-small" : "sort-desc-small")("svgIcon", ctx_r2.sortDescriptor(ctx_r2.column.field).dir === "asc" ? ctx_r2.sortAscSmallIcon : ctx_r2.sortDescSmallIcon);
    ɵɵadvance();
    ɵɵconditional(ctx_r2.showSortNumbering(ctx_r2.column) ? 2 : -1);
  }
}
function ColumnMenuItemComponent_ng_template_2_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 6);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("svgIcon", ctx_r2.filterIcon);
  }
}
function ColumnMenuItemComponent_ng_template_2_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 7);
  }
}
function ColumnMenuItemComponent_ng_template_2_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 8);
    ɵɵelement(1, "kendo-icon-wrapper", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("name", ctx_r2.expandedIcon)("svgIcon", ctx_r2.expandedSvgIcon);
  }
}
function ColumnMenuItemComponent_ng_template_2_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 11);
    ɵɵelementContainer(1, 2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵstyleProp("overflow", "hidden");
    ɵɵproperty("@state", ctx_r2.contentState);
    ɵɵattribute("id", ctx_r2.contentId);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r2.contentTemplate.templateRef);
  }
}
function ColumnMenuItemComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 3);
    ɵɵlistener("click", function ColumnMenuItemComponent_ng_template_2_Template_div_click_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onClick($event));
    })("keydown.enter", function ColumnMenuItemComponent_ng_template_2_Template_div_keydown_enter_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onClick($event));
    });
    ɵɵconditionalCreate(1, ColumnMenuItemComponent_ng_template_2_Conditional_1_Template, 1, 2, "kendo-icon-wrapper", 4);
    ɵɵtext(2);
    ɵɵconditionalCreate(3, ColumnMenuItemComponent_ng_template_2_Conditional_3_Template, 3, 3, "span", 5);
    ɵɵconditionalCreate(4, ColumnMenuItemComponent_ng_template_2_Conditional_4_Template, 1, 1, "kendo-icon-wrapper", 6);
    ɵɵconditionalCreate(5, ColumnMenuItemComponent_ng_template_2_Conditional_5_Template, 1, 0, "span", 7);
    ɵɵconditionalCreate(6, ColumnMenuItemComponent_ng_template_2_Conditional_6_Template, 2, 2, "span", 8);
    ɵɵelementEnd();
    ɵɵconditionalCreate(7, ColumnMenuItemComponent_ng_template_2_Conditional_7_Template, 2, 5, "div", 9);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassProp("k-selected", ctx_r2.selected)("k-disabled", ctx_r2.disabled)("k-focus", ctx_r2.focused);
    ɵɵattribute("aria-expanded", ctx_r2.expanded)("aria-controls", ctx_r2.expanded ? ctx_r2.contentId : void 0);
    ɵɵadvance();
    ɵɵconditional(ctx_r2.icon || ctx_r2.svgIcon ? 1 : -1);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r2.text, " ");
    ɵɵadvance();
    ɵɵconditional(ctx_r2.ctx.grid.isActionSheetExpanded && ctx_r2.adaptiveGridService.viewType === "sortToolbarTool" && ctx_r2.sortDescriptor(ctx_r2.column.field).dir ? 3 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r2.ctx.grid.isActionSheetExpanded && ctx_r2.adaptiveGridService.viewType === "filterToolbarTool" && ctx_r2.hasFilters || ctx_r2.indicatorIcon ? 4 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r2.contentTemplate && ctx_r2.adaptiveGridService.viewType !== "sortToolbarTool" ? 5 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r2.contentTemplate && ctx_r2.adaptiveGridService.viewType !== "sortToolbarTool" ? 6 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r2.contentTemplate ? 7 : -1);
  }
}
function ColumnMenuAutoSizeAllColumnsComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-columnmenu-item", 1);
    ɵɵlistener("itemClick", function ColumnMenuAutoSizeAllColumnsComponent_Conditional_0_Template_kendo_grid_columnmenu_item_itemClick_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.autoSizeAllColumns());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("text", ctx_r1.ctx.localization.get("autosizeAllColumns"))("svgIcon", ctx_r1.displayInlineFlexIcon);
  }
}
function ColumnMenuAutoSizeColumnComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-columnmenu-item", 1);
    ɵɵlistener("itemClick", function ColumnMenuAutoSizeColumnComponent_Conditional_0_Template_kendo_grid_columnmenu_item_itemClick_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.autoSizeColumn());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("text", ctx_r1.ctx.localization.get("autosizeThisColumn"))("svgIcon", ctx_r1.maxWidthIcon);
  }
}
function ColumnMenuChooserComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-column-chooser-content", 2);
    ɵɵlistener("close", function ColumnMenuChooserComponent_ng_template_1_Template_kendo_grid_column_chooser_content_close_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.close());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("columns", ctx_r1.columns)("isLast", ctx_r1.isLast)("isExpanded", ctx_r1.expanded)("closeOnReset", false)("service", ctx_r1.service);
  }
}
function ColumnMenuPositionComponent_ng_template_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-columnmenu-lock", 3);
    ɵɵlistener("keydown.tab", function ColumnMenuPositionComponent_ng_template_1_Conditional_0_Template_kendo_grid_columnmenu_lock_keydown_tab_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onTab($event, !ctx_r1.showStick));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("service", ctx_r1.service);
  }
}
function ColumnMenuPositionComponent_ng_template_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-columnmenu-stick", 3);
    ɵɵlistener("keydown.tab", function ColumnMenuPositionComponent_ng_template_1_Conditional_1_Template_kendo_grid_columnmenu_stick_keydown_tab_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onTab($event, true));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("service", ctx_r1.service);
  }
}
function ColumnMenuPositionComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, ColumnMenuPositionComponent_ng_template_1_Conditional_0_Template, 1, 1, "kendo-grid-columnmenu-lock", 2);
    ɵɵconditionalCreate(1, ColumnMenuPositionComponent_ng_template_1_Conditional_1_Template, 1, 1, "kendo-grid-columnmenu-stick", 2);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵconditional(ctx_r1.showLock ? 0 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.showStick ? 1 : -1);
  }
}
function ColumnMenuFilterComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-filter-menu-container", 2);
    ɵɵlistener("keydown.shift.tab", function ColumnMenuFilterComponent_ng_template_1_Template_kendo_grid_filter_menu_container_keydown_shift_tab_0_listener($event) {
      ɵɵrestoreView(_r1);
      return ɵɵresetView($event.stopImmediatePropagation());
    })("close", function ColumnMenuFilterComponent_ng_template_1_Template_kendo_grid_filter_menu_container_close_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.close());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("column", ctx_r1.service.column)("menuTabbingService", ctx_r1.service.menuTabbingService)("filter", ctx_r1.service.filter)("actionsClass", ctx_r1.actionsClass)("isLast", ctx_r1.isLast)("isExpanded", ctx_r1.expanded);
  }
}
var _c253 = ["tabbedInterfaceTemplate"];
var _c263 = (a0) => ({
  "k-active": a0
});
var _c273 = (a0, a1) => ({
  service: a0,
  column: a1
});
function ColumnMenuComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-columnmenu-container", 15);
    ɵɵlistener("keydown.escape", function ColumnMenuComponent_ng_template_3_Template_kendo_grid_columnmenu_container_keydown_escape_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.close(true));
    })("keydown.enter", function ColumnMenuComponent_ng_template_3_Template_kendo_grid_columnmenu_container_keydown_enter_0_listener($event) {
      ɵɵrestoreView(_r4);
      return ɵɵresetView($event.stopImmediatePropagation());
    });
    ɵɵelementContainer(1, 16);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    const defaultTemplate_r6 = ɵɵreference(6);
    const tabbedInterfaceTemplate_r7 = ɵɵreference(8);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r4.column.columnMenuTemplateRef || ctx_r4.columnMenuTemplate || (ctx_r4.settings.view === "tabbed" ? tabbedInterfaceTemplate_r7 : defaultTemplate_r6))("ngTemplateOutletContext", ɵɵpureFunction2(2, _c273, ctx_r4.service, ctx_r4.column));
  }
}
function ColumnMenuComponent_ng_template_5_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-sort", 17, 4);
  }
  if (rf & 2) {
    const sortItem_r9 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("kendoGridColumnMenuItem", sortItem_r9)("service", ctx_r4.service);
  }
}
function ColumnMenuComponent_ng_template_5_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-lock", 17, 5);
  }
  if (rf & 2) {
    const lockItem_r10 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("kendoGridColumnMenuItem", lockItem_r10)("service", ctx_r4.service);
  }
}
function ColumnMenuComponent_ng_template_5_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-stick", 17, 6);
  }
  if (rf & 2) {
    const stickItem_r11 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("kendoGridColumnMenuItem", stickItem_r11)("service", ctx_r4.service);
  }
}
function ColumnMenuComponent_ng_template_5_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-position", 18, 7);
  }
  if (rf & 2) {
    const positionItem_r12 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("showLock", ctx_r4.hasLock)("showStick", ctx_r4.hasStick)("kendoGridColumnMenuItem", positionItem_r12)("service", ctx_r4.service)("expanded", ctx_r4.expandedPosition);
  }
}
function ColumnMenuComponent_ng_template_5_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 23);
  }
  if (rf & 2) {
    ɵɵstyleProp("border-color", "rgba(0, 0, 0, 0.08)");
  }
}
function ColumnMenuComponent_ng_template_5_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-chooser", 20, 8);
  }
  if (rf & 2) {
    const chooserItem_r13 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("kendoGridColumnMenuItem", chooserItem_r13)("service", ctx_r4.service)("expanded", ctx_r4.expandedColumns);
  }
}
function ColumnMenuComponent_ng_template_5_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-autosize-column", 21, 9);
  }
  if (rf & 2) {
    const autoSizeColumnItem_r14 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("service", ctx_r4.service)("kendoGridColumnMenuItem", autoSizeColumnItem_r14)("column", ctx_r4.column);
  }
}
function ColumnMenuComponent_ng_template_5_Conditional_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-autosize-all-columns", 22, 10);
  }
  if (rf & 2) {
    const autoSizeAllColumnsItem_r15 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("service", ctx_r4.service)("kendoGridColumnMenuItem", autoSizeAllColumnsItem_r15);
  }
}
function ColumnMenuComponent_ng_template_5_Conditional_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 23);
  }
  if (rf & 2) {
    ɵɵstyleProp("border-color", "rgba(0, 0, 0, 0.08)");
  }
}
function ColumnMenuComponent_ng_template_5_Conditional_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-filter", 20, 11);
  }
  if (rf & 2) {
    const filterItem_r16 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("kendoGridColumnMenuItem", filterItem_r16)("service", ctx_r4.service)("expanded", ctx_r4.expandedFilter);
  }
}
function ColumnMenuComponent_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-columnmenu-container", 15);
    ɵɵlistener("keydown.escape", function ColumnMenuComponent_ng_template_5_Template_kendo_grid_columnmenu_container_keydown_escape_0_listener() {
      ɵɵrestoreView(_r8);
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.close(true));
    })("keydown.enter", function ColumnMenuComponent_ng_template_5_Template_kendo_grid_columnmenu_container_keydown_enter_0_listener($event) {
      ɵɵrestoreView(_r8);
      return ɵɵresetView($event.stopImmediatePropagation());
    });
    ɵɵconditionalCreate(1, ColumnMenuComponent_ng_template_5_Conditional_1_Template, 2, 2, "kendo-grid-columnmenu-sort", 17);
    ɵɵconditionalCreate(2, ColumnMenuComponent_ng_template_5_Conditional_2_Template, 2, 2, "kendo-grid-columnmenu-lock", 17);
    ɵɵconditionalCreate(3, ColumnMenuComponent_ng_template_5_Conditional_3_Template, 2, 2, "kendo-grid-columnmenu-stick", 17);
    ɵɵconditionalCreate(4, ColumnMenuComponent_ng_template_5_Conditional_4_Template, 2, 5, "kendo-grid-columnmenu-position", 18);
    ɵɵconditionalCreate(5, ColumnMenuComponent_ng_template_5_Conditional_5_Template, 1, 2, "span", 19);
    ɵɵconditionalCreate(6, ColumnMenuComponent_ng_template_5_Conditional_6_Template, 2, 3, "kendo-grid-columnmenu-chooser", 20);
    ɵɵconditionalCreate(7, ColumnMenuComponent_ng_template_5_Conditional_7_Template, 2, 3, "kendo-grid-columnmenu-autosize-column", 21);
    ɵɵconditionalCreate(8, ColumnMenuComponent_ng_template_5_Conditional_8_Template, 2, 2, "kendo-grid-columnmenu-autosize-all-columns", 22);
    ɵɵconditionalCreate(9, ColumnMenuComponent_ng_template_5_Conditional_9_Template, 1, 2, "span", 19);
    ɵɵconditionalCreate(10, ColumnMenuComponent_ng_template_5_Conditional_10_Template, 2, 3, "kendo-grid-columnmenu-filter", 20);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵconditional(ctx_r4.hasSort ? 1 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r4.hasLock && !ctx_r4.hasPosition ? 2 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r4.hasStick && !ctx_r4.hasPosition ? 3 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r4.hasPosition ? 4 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r4.hasColumnChooser || ctx_r4.hasAutoSizeColumn || ctx_r4.hasAutoSizeAllColumns ? 5 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r4.hasColumnChooser ? 6 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r4.hasAutoSizeColumn ? 7 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r4.hasAutoSizeAllColumns ? 8 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r4.hasColumnChooser || ctx_r4.hasAutoSizeColumn || ctx_r4.hasAutoSizeAllColumns ? 9 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r4.hasFilter ? 10 : -1);
  }
}
function ColumnMenuComponent_ng_template_7_Conditional_2_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 27);
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵproperty("svgIcon", ctx_r4.filterIcon);
    ɵɵattribute("title", ctx_r4.ctx.localization.get("columnMenuFilterTabTitle"));
  }
}
function ColumnMenuComponent_ng_template_7_Conditional_2_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r18 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-filter-menu-container", 28);
    ɵɵlistener("keydown.shift.tab", function ColumnMenuComponent_ng_template_7_Conditional_2_ng_template_2_Template_kendo_grid_filter_menu_container_keydown_shift_tab_0_listener($event) {
      ɵɵrestoreView(_r18);
      return ɵɵresetView($event.stopImmediatePropagation());
    })("close", function ColumnMenuComponent_ng_template_7_Conditional_2_ng_template_2_Template_kendo_grid_filter_menu_container_close_0_listener() {
      ɵɵrestoreView(_r18);
      const ctx_r4 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r4.close());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵproperty("column", ctx_r4.service.column)("menuTabbingService", ctx_r4.service.menuTabbingService)("filter", ctx_r4.service.filter)("actionsClass", ctx_r4.actionsClass);
  }
}
function ColumnMenuComponent_ng_template_7_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-tabstrip-tab");
    ɵɵtemplate(1, ColumnMenuComponent_ng_template_7_Conditional_2_ng_template_1_Template, 1, 2, "ng-template", 25)(2, ColumnMenuComponent_ng_template_7_Conditional_2_ng_template_2_Template, 1, 4, "ng-template", 26);
    ɵɵelementEnd();
  }
}
function ColumnMenuComponent_ng_template_7_Conditional_3_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 29);
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵproperty("svgIcon", ctx_r4.slidersIcon);
    ɵɵattribute("title", ctx_r4.ctx.localization.get("columnMenuGeneralTabTitle"));
  }
}
function ColumnMenuComponent_ng_template_7_Conditional_3_ng_template_2_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-sort", 17, 4);
  }
  if (rf & 2) {
    const sortItem_r19 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(4);
    ɵɵproperty("kendoGridColumnMenuItem", sortItem_r19)("service", ctx_r4.service);
  }
}
function ColumnMenuComponent_ng_template_7_Conditional_3_ng_template_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 23);
  }
  if (rf & 2) {
    ɵɵstyleProp("border-color", "rgba(0, 0, 0, 0.08)");
  }
}
function ColumnMenuComponent_ng_template_7_Conditional_3_ng_template_2_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-lock", 17, 5);
  }
  if (rf & 2) {
    const lockItem_r20 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(4);
    ɵɵproperty("kendoGridColumnMenuItem", lockItem_r20)("service", ctx_r4.service);
  }
}
function ColumnMenuComponent_ng_template_7_Conditional_3_ng_template_2_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-stick", 17, 6);
  }
  if (rf & 2) {
    const stickItem_r21 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(4);
    ɵɵproperty("kendoGridColumnMenuItem", stickItem_r21)("service", ctx_r4.service);
  }
}
function ColumnMenuComponent_ng_template_7_Conditional_3_ng_template_2_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 23);
  }
  if (rf & 2) {
    ɵɵstyleProp("border-color", "rgba(0, 0, 0, 0.08)");
  }
}
function ColumnMenuComponent_ng_template_7_Conditional_3_ng_template_2_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-position", 18, 7);
  }
  if (rf & 2) {
    const positionItem_r22 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(4);
    ɵɵproperty("showLock", ctx_r4.hasLock)("showStick", ctx_r4.hasStick)("kendoGridColumnMenuItem", positionItem_r22)("service", ctx_r4.service)("expanded", ctx_r4.expandedPosition);
  }
}
function ColumnMenuComponent_ng_template_7_Conditional_3_ng_template_2_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 23);
  }
  if (rf & 2) {
    ɵɵstyleProp("border-color", "rgba(0, 0, 0, 0.08)");
  }
}
function ColumnMenuComponent_ng_template_7_Conditional_3_ng_template_2_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-autosize-column", 21, 9);
  }
  if (rf & 2) {
    const autoSizeColumnItem_r23 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(4);
    ɵɵproperty("service", ctx_r4.service)("kendoGridColumnMenuItem", autoSizeColumnItem_r23)("column", ctx_r4.column);
  }
}
function ColumnMenuComponent_ng_template_7_Conditional_3_ng_template_2_Conditional_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-autosize-all-columns", 22, 10);
  }
  if (rf & 2) {
    const autoSizeAllColumnsItem_r24 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(4);
    ɵɵproperty("service", ctx_r4.service)("kendoGridColumnMenuItem", autoSizeAllColumnsItem_r24);
  }
}
function ColumnMenuComponent_ng_template_7_Conditional_3_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, ColumnMenuComponent_ng_template_7_Conditional_3_ng_template_2_Conditional_0_Template, 2, 2, "kendo-grid-columnmenu-sort", 17);
    ɵɵconditionalCreate(1, ColumnMenuComponent_ng_template_7_Conditional_3_ng_template_2_Conditional_1_Template, 1, 2, "span", 19);
    ɵɵconditionalCreate(2, ColumnMenuComponent_ng_template_7_Conditional_3_ng_template_2_Conditional_2_Template, 2, 2, "kendo-grid-columnmenu-lock", 17);
    ɵɵconditionalCreate(3, ColumnMenuComponent_ng_template_7_Conditional_3_ng_template_2_Conditional_3_Template, 2, 2, "kendo-grid-columnmenu-stick", 17);
    ɵɵconditionalCreate(4, ColumnMenuComponent_ng_template_7_Conditional_3_ng_template_2_Conditional_4_Template, 1, 2, "span", 19);
    ɵɵconditionalCreate(5, ColumnMenuComponent_ng_template_7_Conditional_3_ng_template_2_Conditional_5_Template, 2, 5, "kendo-grid-columnmenu-position", 18);
    ɵɵconditionalCreate(6, ColumnMenuComponent_ng_template_7_Conditional_3_ng_template_2_Conditional_6_Template, 1, 2, "span", 19);
    ɵɵconditionalCreate(7, ColumnMenuComponent_ng_template_7_Conditional_3_ng_template_2_Conditional_7_Template, 2, 3, "kendo-grid-columnmenu-autosize-column", 21);
    ɵɵconditionalCreate(8, ColumnMenuComponent_ng_template_7_Conditional_3_ng_template_2_Conditional_8_Template, 2, 2, "kendo-grid-columnmenu-autosize-all-columns", 22);
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵconditional(ctx_r4.hasSort ? 0 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r4.hasSort && (ctx_r4.hasLock || ctx_r4.hasStick || ctx_r4.hasPosition || ctx_r4.hasAutoSizeColumn || ctx_r4.hasAutoSizeAllColumns) ? 1 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r4.hasLock && !ctx_r4.hasPosition ? 2 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r4.hasStick && !ctx_r4.hasPosition ? 3 : -1);
    ɵɵadvance();
    ɵɵconditional((ctx_r4.hasLock || ctx_r4.hasStick) && !ctx_r4.hasPosition && (ctx_r4.hasAutoSizeColumn || ctx_r4.hasAutoSizeAllColumns) ? 4 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r4.hasPosition ? 5 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r4.hasPosition && (ctx_r4.hasAutoSizeColumn || ctx_r4.hasAutoSizeAllColumns) ? 6 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r4.hasAutoSizeColumn ? 7 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r4.hasAutoSizeAllColumns ? 8 : -1);
  }
}
function ColumnMenuComponent_ng_template_7_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-tabstrip-tab");
    ɵɵtemplate(1, ColumnMenuComponent_ng_template_7_Conditional_3_ng_template_1_Template, 1, 2, "ng-template", 25)(2, ColumnMenuComponent_ng_template_7_Conditional_3_ng_template_2_Template, 9, 9, "ng-template", 26);
    ɵɵelementEnd();
  }
}
function ColumnMenuComponent_ng_template_7_Conditional_4_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 30);
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵproperty("svgIcon", ctx_r4.columnsIcon);
    ɵɵattribute("title", ctx_r4.ctx.localization.get("columnMenuColumnsTabTitle"));
  }
}
function ColumnMenuComponent_ng_template_7_Conditional_4_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r25 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-column-chooser-content", 31);
    ɵɵlistener("close", function ColumnMenuComponent_ng_template_7_Conditional_4_ng_template_2_Template_kendo_grid_column_chooser_content_close_0_listener() {
      ɵɵrestoreView(_r25);
      const ctx_r4 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r4.close());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵproperty("columns", ctx_r4.columns)("service", ctx_r4.service);
  }
}
function ColumnMenuComponent_ng_template_7_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-tabstrip-tab");
    ɵɵtemplate(1, ColumnMenuComponent_ng_template_7_Conditional_4_ng_template_1_Template, 1, 2, "ng-template", 25)(2, ColumnMenuComponent_ng_template_7_Conditional_4_ng_template_2_Template, 1, 2, "ng-template", 26);
    ɵɵelementEnd();
  }
}
function ColumnMenuComponent_ng_template_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r17 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-tabstrip", 24, 12);
    ɵɵlistener("keydown.escape", function ColumnMenuComponent_ng_template_7_Template_kendo_tabstrip_keydown_escape_0_listener() {
      ɵɵrestoreView(_r17);
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.close(true));
    });
    ɵɵconditionalCreate(2, ColumnMenuComponent_ng_template_7_Conditional_2_Template, 3, 0, "kendo-tabstrip-tab");
    ɵɵconditionalCreate(3, ColumnMenuComponent_ng_template_7_Conditional_3_Template, 3, 0, "kendo-tabstrip-tab");
    ɵɵconditionalCreate(4, ColumnMenuComponent_ng_template_7_Conditional_4_Template, 3, 0, "kendo-tabstrip-tab");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵconditional(ctx_r4.hasFilter ? 2 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r4.showGeneralTab ? 3 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r4.hasColumnChooser ? 4 : -1);
  }
}
var _c283 = ["kendoGridExcelCommand", ""];
function ExcelCommandDirective_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r0.icon)("svgIcon", ctx_r0.svgIcon);
  }
}
function ExcelCommandDirective_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 1);
    ɵɵelement(1, "img", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("src", ctx_r0.imageUrl, ɵɵsanitizeUrl);
  }
}
function ExcelCommandDirective_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 2);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ctx_r0.iconClass);
  }
}
var _c293 = ["kendoGridPDFCommand", ""];
function PDFCommandDirective_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r0.icon)("svgIcon", ctx_r0.svgIcon);
  }
}
function PDFCommandDirective_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 1);
    ɵɵelement(1, "img", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("src", ctx_r0.imageUrl, ɵɵsanitizeUrl);
  }
}
function PDFCommandDirective_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 2);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ctx_r0.iconClass);
  }
}
var _c303 = ["kendoGridHeader", ""];
var _c316 = (a0, a1, a2, a3) => ({
  field: a0,
  type: "column",
  column: a1,
  hint: a2,
  lastColumn: a3
});
var _c323 = (a0, a1, a2, a3) => ({
  templateRef: a0,
  columnIndex: a1,
  column: a2,
  $implicit: a3
});
var _c333 = (a0) => ({
  "aria-label": a0
});
var _c343 = (a0, a1, a2) => ({
  type: "columnGroup",
  column: a0,
  hint: a1,
  lastColumn: a2
});
var _forTrack0 = ($index, $item) => $item.id;
function HeaderComponent_For_1_For_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "th", 3);
  }
}
function HeaderComponent_For_1_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "th", 4);
  }
}
function HeaderComponent_For_1_For_5_Conditional_0_Conditional_1_ng_template_2_Template(rf, ctx) {
}
function HeaderComponent_For_1_For_5_Conditional_0_Conditional_1_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 13);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r2 = ɵɵnextContext(3).$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate(column_r2.displayTitle);
  }
}
function HeaderComponent_For_1_For_5_Conditional_0_Conditional_1_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-filter-menu", 14);
  }
  if (rf & 2) {
    const column_r2 = ɵɵnextContext(3).$implicit;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("column", ctx_r2.getColumnComponent(column_r2))("filter", ctx_r2.filter)("tabIndex", ctx_r2.tabIndex);
  }
}
function HeaderComponent_For_1_For_5_Conditional_0_Conditional_1_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-column-menu", 15);
  }
  if (rf & 2) {
    const column_r2 = ɵɵnextContext(3).$implicit;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("standalone", false)("settings", ctx_r2.columnMenuSettings)("column", column_r2)("columnMenuTemplate", ctx_r2.columnMenuTemplate)("sort", ctx_r2.sort)("filter", ctx_r2.filter)("sortable", ctx_r2.sortable)("tabIndex", ctx_r2.tabIndex);
  }
}
function HeaderComponent_For_1_For_5_Conditional_0_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 8)(1, "span", 11);
    ɵɵtemplate(2, HeaderComponent_For_1_For_5_Conditional_0_Conditional_1_ng_template_2_Template, 0, 0, "ng-template", 12);
    ɵɵconditionalCreate(3, HeaderComponent_For_1_For_5_Conditional_0_Conditional_1_Conditional_3_Template, 2, 1, "span", 13);
    ɵɵelementEnd();
    ɵɵconditionalCreate(4, HeaderComponent_For_1_For_5_Conditional_0_Conditional_1_Conditional_4_Template, 1, 3, "kendo-grid-filter-menu", 14);
    ɵɵconditionalCreate(5, HeaderComponent_For_1_For_5_Conditional_0_Conditional_1_Conditional_5_Template, 1, 8, "kendo-grid-column-menu", 15);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r2 = ɵɵnextContext(2).$implicit;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵclassProp("!k-cursor-default", !ctx_r2.isInteractive(ctx_r2.getColumnComponent(column_r2), "groupable") && !ctx_r2.isInteractive(ctx_r2.getColumnComponent(column_r2), "reorderable"));
    ɵɵadvance();
    ɵɵproperty("templateContext", ɵɵpureFunction4(6, _c323, column_r2.headerTemplateRef, column_r2.leafIndex, column_r2, column_r2));
    ɵɵadvance();
    ɵɵconditional(!column_r2.headerTemplateRef ? 3 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r2.showFilterMenu && ctx_r2.isFilterable(ctx_r2.getColumnComponent(column_r2)) ? 4 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r2.showColumnMenu(column_r2) ? 5 : -1);
  }
}
function HeaderComponent_For_1_For_5_Conditional_0_Conditional_2_ng_template_3_Template(rf, ctx) {
}
function HeaderComponent_For_1_For_5_Conditional_0_Conditional_2_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 13);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r2 = ɵɵnextContext(3).$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate(column_r2.displayTitle);
  }
}
function HeaderComponent_For_1_For_5_Conditional_0_Conditional_2_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 17);
  }
  if (rf & 2) {
    const column_r2 = ɵɵnextContext(3).$implicit;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("name", ɵɵinterpolate1("sort-", ctx_r2.sortDescriptor(ctx_r2.getColumnComponent(column_r2).field).dir, "-small"))("svgIcon", ctx_r2.sortDescriptor(ctx_r2.getColumnComponent(column_r2).field).dir === "asc" ? ctx_r2.sortAscSmallIcon : ctx_r2.sortDescSmallIcon);
    ɵɵattribute("aria-label", ctx_r2.sortableLabel);
  }
}
function HeaderComponent_For_1_For_5_Conditional_0_Conditional_2_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 18);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r2 = ɵɵnextContext(3).$implicit;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r2.sortOrder(ctx_r2.getColumnComponent(column_r2).field));
  }
}
function HeaderComponent_For_1_For_5_Conditional_0_Conditional_2_Conditional_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-filter-menu", 14);
  }
  if (rf & 2) {
    const column_r2 = ɵɵnextContext(3).$implicit;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("column", ctx_r2.getColumnComponent(column_r2))("filter", ctx_r2.filter)("tabIndex", ctx_r2.tabIndex);
  }
}
function HeaderComponent_For_1_For_5_Conditional_0_Conditional_2_Conditional_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-column-menu", 15);
  }
  if (rf & 2) {
    const column_r2 = ɵɵnextContext(3).$implicit;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("standalone", false)("settings", ctx_r2.columnMenuSettings)("column", column_r2)("columnMenuTemplate", ctx_r2.columnMenuTemplate)("sort", ctx_r2.sort)("filter", ctx_r2.filter)("sortable", ctx_r2.sortable)("tabIndex", ctx_r2.tabIndex);
  }
}
function HeaderComponent_For_1_For_5_Conditional_0_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 8)(1, "span", 16, 0);
    ɵɵlistener("click", function HeaderComponent_For_1_For_5_Conditional_0_Conditional_2_Template_span_click_1_listener($event) {
      ɵɵrestoreView(_r4);
      const link_r5 = ɵɵreference(2);
      const column_r2 = ɵɵnextContext(2).$implicit;
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.onSortClick(ctx_r2.getColumnComponent(column_r2), $event, link_r5));
    });
    ɵɵtemplate(3, HeaderComponent_For_1_For_5_Conditional_0_Conditional_2_ng_template_3_Template, 0, 0, "ng-template", 12);
    ɵɵconditionalCreate(4, HeaderComponent_For_1_For_5_Conditional_0_Conditional_2_Conditional_4_Template, 2, 1, "span", 13);
    ɵɵelementStart(5, "span");
    ɵɵconditionalCreate(6, HeaderComponent_For_1_For_5_Conditional_0_Conditional_2_Conditional_6_Template, 1, 4, "kendo-icon-wrapper", 17);
    ɵɵelementEnd();
    ɵɵconditionalCreate(7, HeaderComponent_For_1_For_5_Conditional_0_Conditional_2_Conditional_7_Template, 2, 1, "span", 18);
    ɵɵelementEnd();
    ɵɵconditionalCreate(8, HeaderComponent_For_1_For_5_Conditional_0_Conditional_2_Conditional_8_Template, 1, 3, "kendo-grid-filter-menu", 14);
    ɵɵconditionalCreate(9, HeaderComponent_For_1_For_5_Conditional_0_Conditional_2_Conditional_9_Template, 1, 8, "kendo-grid-column-menu", 15);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r2 = ɵɵnextContext(2).$implicit;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance(3);
    ɵɵproperty("templateContext", ɵɵpureFunction4(8, _c323, column_r2.headerTemplateRef, column_r2.leafIndex, column_r2, column_r2));
    ɵɵadvance();
    ɵɵconditional(!column_r2.headerTemplateRef ? 4 : -1);
    ɵɵadvance();
    ɵɵclassProp("k-sort-icon", ctx_r2.sortDescriptor(ctx_r2.getColumnComponent(column_r2).field).dir);
    ɵɵadvance();
    ɵɵconditional(ctx_r2.sortDescriptor(ctx_r2.getColumnComponent(column_r2).field).dir ? 6 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r2.showSortNumbering(ctx_r2.getColumnComponent(column_r2)) ? 7 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r2.showFilterMenu && ctx_r2.isFilterable(ctx_r2.getColumnComponent(column_r2)) ? 8 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r2.showColumnMenu(column_r2) ? 9 : -1);
  }
}
function HeaderComponent_For_1_For_5_Conditional_0_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-checkbox", 9);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(4);
    ɵɵproperty("inputAttributes", ɵɵpureFunction1(2, _c333, ctx_r2.selectAllCheckboxLabel));
    ɵɵattribute("id", ctx_r2.selectAllCheckboxId());
  }
}
function HeaderComponent_For_1_For_5_Conditional_0_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 10);
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext(2);
    const column_r2 = ctx_r5.$implicit;
    const ɵ$index_10_r7 = ctx_r5.$index;
    const ɵ$count_10_r8 = ctx_r5.$count;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("isLast", ɵ$index_10_r7 === ɵ$count_10_r8 - 1)("column", column_r2)("columns", ctx_r2.columns);
  }
}
function HeaderComponent_For_1_For_5_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "th", 7);
    ɵɵlistener("keydown", function HeaderComponent_For_1_For_5_Conditional_0_Template_th_keydown_0_listener($event) {
      ɵɵrestoreView(_r1);
      const column_r2 = ɵɵnextContext().$implicit;
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.onHeaderKeydown(ctx_r2.getColumnComponent(column_r2), $event));
    });
    ɵɵconditionalCreate(1, HeaderComponent_For_1_For_5_Conditional_0_Conditional_1_Template, 6, 11, "span", 8);
    ɵɵconditionalCreate(2, HeaderComponent_For_1_For_5_Conditional_0_Conditional_2_Template, 10, 13, "span", 8);
    ɵɵconditionalCreate(3, HeaderComponent_For_1_For_5_Conditional_0_Conditional_3_Template, 1, 4, "kendo-checkbox", 9);
    ɵɵconditionalCreate(4, HeaderComponent_For_1_For_5_Conditional_0_Conditional_4_Template, 1, 3, "span", 10);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    const column_r2 = ctx_r5.$implicit;
    const ɵ$index_10_r7 = ctx_r5.$index;
    const ɵ$count_10_r8 = ctx_r5.$count;
    const ɵ$index_1_r9 = ɵɵnextContext().$index;
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassProp("k-sorted", ctx_r2.sortState(ctx_r2.getColumnComponent(column_r2)))("k-filterable", ctx_r2.showFilterMenu && ctx_r2.isFilterable(ctx_r2.getColumnComponent(column_r2)) || ctx_r2.showColumnMenu(column_r2))("k-first", ctx_r2.isFirstOnRow(ctx_r2.getColumnComponent(column_r2), ɵ$index_10_r7))("k-grid-header-sticky", column_r2.sticky);
    ɵɵproperty("logicalRowIndex", ɵ$index_1_r9)("logicalColIndex", ctx_r2.logicalColumnIndex(column_r2))("headerLabelText", column_r2.title || ctx_r2.getColumnComponent(column_r2).field)("colSpan", column_r2.colspan)("rowSpan", column_r2.rowspan(ctx_r2.totalColumnLevels))("enableDrag", ctx_r2.shouldActivate(column_r2))("context", ɵɵpureFunction4(27, _c316, ctx_r2.getColumnComponent(column_r2).field, column_r2, column_r2.title || ctx_r2.getColumnComponent(column_r2).field, ɵ$index_10_r7 === ɵ$count_10_r8 - 1 && ɵ$index_10_r7 === 0))("ngClass", column_r2.headerClass)("ngStyle", column_r2.sticky ? ctx_r2.addStickyStyles(column_r2) : column_r2.headerStyle);
    ɵɵattribute("aria-sort", ctx_r2.sortState(ctx_r2.getColumnComponent(column_r2)))("rowspan", column_r2.rowspan(ctx_r2.totalColumnLevels))("colspan", column_r2.colspan)("aria-haspopup", ctx_r2.isNavigable && (ctx_r2.showFilterMenu || ctx_r2.showColumnMenu(column_r2)) ? "dialog" : void 0)("aria-expanded", ctx_r2.isNavigable && (ctx_r2.showFilterMenu || ctx_r2.showColumnMenu(column_r2)) ? false : void 0)("aria-keyshortcuts", ctx_r2.isNavigable && (ctx_r2.showFilterMenu || ctx_r2.showColumnMenu(column_r2)) ? "Alt + ArrowDown" : void 0);
    ɵɵadvance();
    ɵɵconditional(!ctx_r2.isInteractive(ctx_r2.getColumnComponent(column_r2), "sortable") ? 1 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r2.isInteractive(ctx_r2.getColumnComponent(column_r2), "sortable") ? 2 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r2.isCheckboxColumn(column_r2) && !column_r2.headerTemplateRef && column_r2.showSelectAll ? 3 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r2.resizable ? 4 : -1);
  }
}
function HeaderComponent_For_1_For_5_Conditional_1_ng_template_3_Template(rf, ctx) {
}
function HeaderComponent_For_1_For_5_Conditional_1_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 13);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r2 = ɵɵnextContext(2).$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate(column_r2.displayTitle);
  }
}
function HeaderComponent_For_1_For_5_Conditional_1_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-column-menu", 20);
  }
  if (rf & 2) {
    const column_r2 = ɵɵnextContext(2).$implicit;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("standalone", false)("settings", ctx_r2.columnMenuSettings)("column", column_r2)("columnMenuTemplate", ctx_r2.columnMenuTemplate);
  }
}
function HeaderComponent_For_1_For_5_Conditional_1_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 10);
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext(2);
    const column_r2 = ctx_r5.$implicit;
    const ɵ$index_10_r7 = ctx_r5.$index;
    const ɵ$count_10_r8 = ctx_r5.$count;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("isLast", ɵ$index_10_r7 === ɵ$count_10_r8 - 1)("column", column_r2)("columns", ctx_r2.columns);
  }
}
function HeaderComponent_For_1_For_5_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 19)(1, "span", 8)(2, "span", 11);
    ɵɵtemplate(3, HeaderComponent_For_1_For_5_Conditional_1_ng_template_3_Template, 0, 0, "ng-template", 12);
    ɵɵconditionalCreate(4, HeaderComponent_For_1_For_5_Conditional_1_Conditional_4_Template, 2, 1, "span", 13);
    ɵɵelementEnd();
    ɵɵconditionalCreate(5, HeaderComponent_For_1_For_5_Conditional_1_Conditional_5_Template, 1, 4, "kendo-grid-column-menu", 20);
    ɵɵelementEnd();
    ɵɵconditionalCreate(6, HeaderComponent_For_1_For_5_Conditional_1_Conditional_6_Template, 1, 3, "span", 10);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    const column_r2 = ctx_r5.$implicit;
    const ɵ$index_10_r7 = ctx_r5.$index;
    const ɵ$count_10_r8 = ctx_r5.$count;
    const ɵ$index_1_r9 = ɵɵnextContext().$index;
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassProp("k-first", ctx_r2.isFirstOnRow(ctx_r2.getColumnComponent(column_r2), ɵ$index_10_r7))("k-filterable", ctx_r2.showColumnMenu(column_r2))("k-grid-content-sticky", column_r2.sticky);
    ɵɵproperty("logicalRowIndex", ɵ$index_1_r9)("logicalColIndex", ctx_r2.logicalColumnIndex(column_r2))("rowSpan", column_r2.rowspan(ctx_r2.totalColumnLevels))("colSpan", column_r2.colspan)("headerLabelText", column_r2.title || ctx_r2.getColumnComponent(column_r2).field)("enableDrag", ctx_r2.shouldActivate(column_r2))("context", ɵɵpureFunction3(26, _c343, column_r2, column_r2.title, ɵ$index_10_r7 === ɵ$count_10_r8 - 1 && ɵ$index_10_r7 === 0))("ngClass", column_r2.headerClass)("ngStyle", column_r2.headerStyle);
    ɵɵattribute("aria-haspopup", ctx_r2.isNavigable && ctx_r2.showColumnMenu(column_r2) ? "dialog" : void 0)("aria-expanded", ctx_r2.isNavigable && ctx_r2.showColumnMenu(column_r2) ? false : void 0)("aria-keyshortcuts", ctx_r2.isNavigable && ctx_r2.showColumnMenu(column_r2) ? "Alt + ArrowDown" : void 0)("rowspan", column_r2.rowspan(ctx_r2.totalColumnLevels))("colspan", column_r2.colspan);
    ɵɵadvance(2);
    ɵɵclassProp("!k-cursor-default", !ctx_r2.isInteractive(ctx_r2.getColumnComponent(column_r2), "reorderable"));
    ɵɵadvance();
    ɵɵproperty("templateContext", ɵɵpureFunction4(30, _c323, column_r2.headerTemplateRef, ctx_r2.lockedColumnsCount + ɵ$index_10_r7, column_r2, column_r2));
    ɵɵadvance();
    ɵɵconditional(!column_r2.headerTemplateRef ? 4 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r2.showColumnMenu(column_r2) ? 5 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r2.resizable ? 6 : -1);
  }
}
function HeaderComponent_For_1_For_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, HeaderComponent_For_1_For_5_Conditional_0_Template, 5, 32, "th", 5);
    ɵɵconditionalCreate(1, HeaderComponent_For_1_For_5_Conditional_1_Template, 7, 35, "th", 6);
  }
  if (rf & 2) {
    const column_r2 = ctx.$implicit;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵconditional(!ctx_r2.isColumnGroupComponent(column_r2) ? 0 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r2.isColumnGroupComponent(column_r2) ? 1 : -1);
  }
}
function HeaderComponent_For_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr", 1);
    ɵɵrepeaterCreate(1, HeaderComponent_For_1_For_2_Template, 1, 0, "th", 3, ɵɵrepeaterTrackByIdentity);
    ɵɵconditionalCreate(3, HeaderComponent_For_1_Conditional_3_Template, 1, 0, "th", 4);
    ɵɵrepeaterCreate(4, HeaderComponent_For_1_For_5_Template, 2, 2, null, null, _forTrack0);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ɵ$index_1_r9 = ctx.$index;
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("logicalRowIndex", ɵ$index_1_r9)("logicalSlaveRow", ctx_r2.lockedColumnsCount > 0)("logicalCellsCount", ctx_r2.columns.length)("logicalSlaveCellsCount", ctx_r2.unlockedColumnsCount)("totalColumns", ctx_r2.totalColumns);
    ɵɵadvance();
    ɵɵrepeater(ctx_r2.groups);
    ɵɵadvance(2);
    ɵɵconditional((ctx_r2.detailTemplate == null ? null : ctx_r2.detailTemplate.templateRef) && !ctx_r2.isStacked ? 3 : -1);
    ɵɵadvance();
    ɵɵrepeater(ctx_r2.columnsForLevel(ɵ$index_1_r9));
  }
}
function HeaderComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "tr", 2);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("columns", ctx_r2.leafColumns)("filter", ctx_r2.filter)("groups", ctx_r2.groups)("detailTemplate", ctx_r2.detailTemplate)("lockedColumnsCount", ctx_r2.lockedColumnsCount)("logicalRowIndex", ctx_r2.totalColumnLevels + 1)("logicalSlaveRow", ctx_r2.lockedColumnsCount > 0)("logicalCellsCount", ctx_r2.columns.length)("logicalSlaveCellsCount", ctx_r2.unlockedColumnsCount)("totalColumns", ctx_r2.totalColumns);
  }
}
var _c353 = ["kendoGridFooter", ""];
function FooterComponent_Conditional_2_For_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 3);
  }
}
function FooterComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵrepeaterCreate(0, FooterComponent_Conditional_2_For_1_Template, 1, 0, "td", 3, ɵɵrepeaterTrackByIdentity);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵrepeater(ctx_r0.groups);
  }
}
function FooterComponent_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 1);
  }
}
function FooterComponent_Conditional_4_For_1_Conditional_0_ng_template_1_Template(rf, ctx) {
}
function FooterComponent_Conditional_4_For_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 5);
    ɵɵtemplate(1, FooterComponent_Conditional_4_For_1_Conditional_0_ng_template_1_Template, 0, 0, "ng-template", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r2 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵclassProp("k-grid-footer-sticky", column_r2.sticky);
    ɵɵproperty("logicalRowIndex", ctx_r0.logicalRowIndex)("logicalColIndex", ctx_r0.logicalColumnIndex(column_r2))("ngClass", column_r2.footerClass)("ngStyle", column_r2.sticky ? ctx_r0.addStickyStyles(column_r2) : column_r2.footerStyle);
    ɵɵadvance();
    ɵɵproperty("templateContext", ɵɵpureFunction4(7, _c323, column_r2.footerTemplateRef, column_r2.leafIndex, column_r2, column_r2));
  }
}
function FooterComponent_Conditional_4_For_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, FooterComponent_Conditional_4_For_1_Conditional_0_Template, 2, 12, "td", 4);
  }
  if (rf & 2) {
    const column_r2 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵconditional(!ctx_r0.isColumnGroupComponent(column_r2) ? 0 : -1);
  }
}
function FooterComponent_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵrepeaterCreate(0, FooterComponent_Conditional_4_For_1_Template, 1, 1, null, null, ɵɵrepeaterTrackByIndex);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵrepeater(ctx_r0.columnsToRender);
  }
}
function FooterComponent_Conditional_5_For_3_Conditional_0_ng_template_1_Template(rf, ctx) {
}
function FooterComponent_Conditional_5_For_3_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 8);
    ɵɵtemplate(1, FooterComponent_Conditional_5_For_3_Conditional_0_ng_template_1_Template, 0, 0, "ng-template", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r3 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵproperty("templateContext", ɵɵpureFunction4(1, _c323, column_r3.footerTemplateRef, column_r3.leafIndex, column_r3, column_r3));
  }
}
function FooterComponent_Conditional_5_For_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, FooterComponent_Conditional_5_For_3_Conditional_0_Template, 2, 6, "div", 8);
  }
  if (rf & 2) {
    const column_r3 = ctx.$implicit;
    ɵɵconditional(column_r3.footerTemplateRef ? 0 : -1);
  }
}
function FooterComponent_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 2)(1, "div", 7);
    ɵɵrepeaterCreate(2, FooterComponent_Conditional_5_For_3_Template, 1, 1, null, null, ɵɵrepeaterTrackByIndex);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("logicalRowIndex", ctx_r0.logicalRowIndex)("logicalColIndex", ctx_r0.detailTemplate ? 1 : 0);
    ɵɵadvance(2);
    ɵɵrepeater(ctx_r0.columnsToRender);
  }
}
var _c363 = ["kendoGridCell", ""];
var _c373 = (a0) => ({
  $implicit: a0
});
function CellComponent_Conditional_0_For_2_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const col_r1 = ɵɵnextContext().$implicit;
    ɵɵtextInterpolate1(" ", col_r1.displayTitle, " ");
  }
}
function CellComponent_Conditional_0_For_2_Conditional_3_ng_template_0_Template(rf, ctx) {
}
function CellComponent_Conditional_0_For_2_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, CellComponent_Conditional_0_For_2_Conditional_3_ng_template_0_Template, 0, 0, "ng-template", 7, 0, ɵɵtemplateRefExtractor);
  }
  if (rf & 2) {
    const col_r1 = ɵɵnextContext().$implicit;
    ɵɵproperty("templateContext", ɵɵpureFunction4(1, _c323, col_r1.headerTemplateRef, col_r1.leafIndex, col_r1, col_r1));
  }
}
function CellComponent_Conditional_0_For_2_Conditional_5_Conditional_0_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
    ɵɵpipe(1, "valueOf");
  }
  if (rf & 2) {
    const col_r1 = ɵɵnextContext(3).$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵtextInterpolate(ɵɵpipeBind3(1, 1, ctx_r1.dataItem, col_r1.field, col_r1.format));
  }
}
function CellComponent_Conditional_0_For_2_Conditional_5_Conditional_0_Conditional_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-checkbox", 10);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(6);
    ɵɵproperty("kendoGridSelectionCheckbox", ctx_r1.rowIndex)("inputAttributes", ɵɵpureFunction1(4, _c333, ctx_r1.selectionCheckboxLabel))("title", ctx_r1.selectionCheckboxLabel);
    ɵɵattribute("id", ctx_r1.selectionCheckboxId);
  }
}
function CellComponent_Conditional_0_For_2_Conditional_5_Conditional_0_Conditional_1_Conditional_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-checkbox", 11);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(7);
    ɵɵproperty("kendoGridSelectionCheckbox", ctx_r1.rowIndex)("inputAttributes", ɵɵpureFunction1(5, _c333, ctx_r1.selectionCheckboxLabel))("title", ctx_r1.selectionCheckboxLabel)("disabled", true);
    ɵɵattribute("id", ctx_r1.selectionCheckboxId);
  }
}
function CellComponent_Conditional_0_For_2_Conditional_5_Conditional_0_Conditional_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, CellComponent_Conditional_0_For_2_Conditional_5_Conditional_0_Conditional_1_Conditional_1_Conditional_0_Template, 1, 7, "kendo-checkbox", 11);
  }
  if (rf & 2) {
    const col_r1 = ɵɵnextContext(4).$implicit;
    ɵɵconditional(col_r1.showDisabledCheckbox ? 0 : -1);
  }
}
function CellComponent_Conditional_0_For_2_Conditional_5_Conditional_0_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, CellComponent_Conditional_0_For_2_Conditional_5_Conditional_0_Conditional_1_Conditional_0_Template, 1, 6, "kendo-checkbox", 10)(1, CellComponent_Conditional_0_For_2_Conditional_5_Conditional_0_Conditional_1_Conditional_1_Template, 1, 1);
  }
  if (rf & 2) {
    const col_r1 = ɵɵnextContext(3).$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵconditional(ctx_r1.isRowSelectable(col_r1) ? 0 : 1);
  }
}
function CellComponent_Conditional_0_For_2_Conditional_5_Conditional_0_Conditional_2_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 12);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(6);
    ɵɵproperty("svgIcon", ctx_r1.reorderIcon);
  }
}
function CellComponent_Conditional_0_For_2_Conditional_5_Conditional_0_Conditional_2_Conditional_1_ng_template_0_Template(rf, ctx) {
}
function CellComponent_Conditional_0_For_2_Conditional_5_Conditional_0_Conditional_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, CellComponent_Conditional_0_For_2_Conditional_5_Conditional_0_Conditional_2_Conditional_1_ng_template_0_Template, 0, 0, "ng-template", 9);
  }
  if (rf & 2) {
    const col_r1 = ɵɵnextContext(4).$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", col_r1.rowDragHandleTemplateRef)("ngTemplateOutletContext", ctx_r1.rowReorderTemplateContext);
  }
}
function CellComponent_Conditional_0_For_2_Conditional_5_Conditional_0_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, CellComponent_Conditional_0_For_2_Conditional_5_Conditional_0_Conditional_2_Conditional_0_Template, 1, 1, "kendo-icon-wrapper", 12)(1, CellComponent_Conditional_0_For_2_Conditional_5_Conditional_0_Conditional_2_Conditional_1_Template, 1, 2, null, 9);
  }
  if (rf & 2) {
    const col_r1 = ɵɵnextContext(3).$implicit;
    ɵɵconditional(!(col_r1.dragHandleTemplate == null ? null : col_r1.dragHandleTemplate.first) ? 0 : 1);
  }
}
function CellComponent_Conditional_0_For_2_Conditional_5_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, CellComponent_Conditional_0_For_2_Conditional_5_Conditional_0_Conditional_0_Template, 2, 5);
    ɵɵconditionalCreate(1, CellComponent_Conditional_0_For_2_Conditional_5_Conditional_0_Conditional_1_Template, 2, 1);
    ɵɵconditionalCreate(2, CellComponent_Conditional_0_For_2_Conditional_5_Conditional_0_Conditional_2_Template, 2, 1);
  }
  if (rf & 2) {
    const col_r1 = ɵɵnextContext(2).$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵconditional(ctx_r1.isBoundColumn(col_r1) ? 0 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.isCheckboxColumn(col_r1) && !ctx_r1.isNew ? 1 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.isRowReorderColumn(col_r1) && !ctx_r1.isNew ? 2 : -1);
  }
}
function CellComponent_Conditional_0_For_2_Conditional_5_Conditional_1_ng_template_0_Template(rf, ctx) {
}
function CellComponent_Conditional_0_For_2_Conditional_5_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, CellComponent_Conditional_0_For_2_Conditional_5_Conditional_1_ng_template_0_Template, 0, 0, "ng-template", 9, 1, ɵɵtemplateRefExtractor);
  }
  if (rf & 2) {
    const col_r1 = ɵɵnextContext(2).$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", col_r1.templateRef)("ngTemplateOutletContext", ctx_r1.getTemplateContext(col_r1));
  }
}
function CellComponent_Conditional_0_For_2_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, CellComponent_Conditional_0_For_2_Conditional_5_Conditional_0_Template, 3, 3)(1, CellComponent_Conditional_0_For_2_Conditional_5_Conditional_1_Template, 2, 2, null, 9);
  }
  if (rf & 2) {
    const col_r1 = ɵɵnextContext().$implicit;
    ɵɵconditional(!col_r1.templateRef ? 0 : 1);
  }
}
function CellComponent_Conditional_0_For_2_Conditional_6_Conditional_0_Case_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-numerictextbox", 13);
  }
  if (rf & 2) {
    const col_r1 = ɵɵnextContext(3).$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("format", ctx_r1.format)("formControl", ctx_r1.formGroup.get(col_r1.field));
  }
}
function CellComponent_Conditional_0_For_2_Conditional_6_Conditional_0_Case_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-datepicker", 13);
  }
  if (rf & 2) {
    const col_r1 = ɵɵnextContext(3).$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("format", ctx_r1.format)("formControl", ctx_r1.formGroup.get(col_r1.field));
  }
}
function CellComponent_Conditional_0_For_2_Conditional_6_Conditional_0_Case_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-checkbox", 14);
  }
  if (rf & 2) {
    const col_r1 = ɵɵnextContext(3).$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("formControl", ctx_r1.formGroup.get(col_r1.field));
  }
}
function CellComponent_Conditional_0_For_2_Conditional_6_Conditional_0_Case_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-textbox", 14);
  }
  if (rf & 2) {
    const col_r1 = ɵɵnextContext(3).$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("formControl", ctx_r1.formGroup.get(col_r1.field));
  }
}
function CellComponent_Conditional_0_For_2_Conditional_6_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, CellComponent_Conditional_0_For_2_Conditional_6_Conditional_0_Case_0_Template, 1, 2, "kendo-numerictextbox", 13)(1, CellComponent_Conditional_0_For_2_Conditional_6_Conditional_0_Case_1_Template, 1, 2, "kendo-datepicker", 13)(2, CellComponent_Conditional_0_For_2_Conditional_6_Conditional_0_Case_2_Template, 1, 1, "kendo-checkbox", 14)(3, CellComponent_Conditional_0_For_2_Conditional_6_Conditional_0_Case_3_Template, 1, 1, "kendo-textbox", 14);
  }
  if (rf & 2) {
    let tmp_13_0;
    const col_r1 = ɵɵnextContext(2).$implicit;
    ɵɵconditional((tmp_13_0 = col_r1.editor) === "numeric" ? 0 : tmp_13_0 === "date" ? 1 : tmp_13_0 === "boolean" ? 2 : 3);
  }
}
function CellComponent_Conditional_0_For_2_Conditional_6_Conditional_1_ng_template_0_Template(rf, ctx) {
}
function CellComponent_Conditional_0_For_2_Conditional_6_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, CellComponent_Conditional_0_For_2_Conditional_6_Conditional_1_ng_template_0_Template, 0, 0, "ng-template", 9);
  }
  if (rf & 2) {
    const col_r1 = ɵɵnextContext(2).$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", col_r1.editTemplateRef)("ngTemplateOutletContext", ctx_r1.getEditTemplateContext(col_r1));
  }
}
function CellComponent_Conditional_0_For_2_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, CellComponent_Conditional_0_For_2_Conditional_6_Conditional_0_Template, 4, 1)(1, CellComponent_Conditional_0_For_2_Conditional_6_Conditional_1_Template, 1, 2, null, 9);
  }
  if (rf & 2) {
    const col_r1 = ɵɵnextContext().$implicit;
    ɵɵconditional(!col_r1.editTemplateRef ? 0 : 1);
  }
}
function CellComponent_Conditional_0_For_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 5)(1, "div", 6);
    ɵɵconditionalCreate(2, CellComponent_Conditional_0_For_2_Conditional_2_Template, 1, 1)(3, CellComponent_Conditional_0_For_2_Conditional_3_Template, 2, 6, null, 7);
    ɵɵelementEnd();
    ɵɵelementStart(4, "div", 8);
    ɵɵconditionalCreate(5, CellComponent_Conditional_0_For_2_Conditional_5_Template, 2, 1);
    ɵɵconditionalCreate(6, CellComponent_Conditional_0_For_2_Conditional_6_Template, 2, 1);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const col_r1 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵclassProp("k-grid-stack-edit-cell", ctx_r1.isEdited(col_r1))("k-drag-cell", ctx_r1.isRowReorderColumn(col_r1) && !ctx_r1.isNew)("k-command-cell", ctx_r1.isCommand(col_r1));
    ɵɵproperty("kendoGridFocusable", !ctx_r1.isCommand(col_r1));
    ɵɵadvance(2);
    ɵɵconditional(!col_r1.headerTemplateRef ? 2 : 3);
    ɵɵadvance(3);
    ɵɵconditional(!ctx_r1.isEdited(col_r1) ? 5 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.isEdited(col_r1) ? 6 : -1);
  }
}
function CellComponent_Conditional_0_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 4)(1, "div", 8)(2, "button", 15);
    ɵɵlistener("click", function CellComponent_Conditional_0_Conditional_3_Template_button_click_2_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.toggleRow(ctx_r1.item.index, ctx_r1.item.data));
    });
    ɵɵtext(3);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵattribute("aria-expanded", ctx_r1.item.isExpanded);
    ɵɵadvance(2);
    ɵɵproperty("icon", ctx_r1.detailButtonIconName(ctx_r1.item))("svgIcon", ctx_r1.detailButtonSvgIcon(ctx_r1.item));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.detailButtonText(ctx_r1.item), " ");
  }
}
function CellComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 2);
    ɵɵrepeaterCreate(1, CellComponent_Conditional_0_For_2_Template, 7, 10, "div", 3, ɵɵrepeaterTrackByIndex);
    ɵɵconditionalCreate(3, CellComponent_Conditional_0_Conditional_3_Template, 4, 4, "div", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngClass", ctx_r1.stackedRowClass)("ngStyle", ctx_r1.stackedRowStyle);
    ɵɵadvance();
    ɵɵrepeater(ctx_r1.columns);
    ɵɵadvance(2);
    ɵɵconditional((ctx_r1.detailTemplate == null ? null : ctx_r1.detailTemplate.showIf(ctx_r1.item.data, ctx_r1.item.index)) ? 3 : -1);
  }
}
function CellComponent_Conditional_1_Case_0_Conditional_0_Conditional_0_ng_template_0_Template(rf, ctx) {
}
function CellComponent_Conditional_1_Case_0_Conditional_0_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, CellComponent_Conditional_1_Case_0_Conditional_0_Conditional_0_ng_template_0_Template, 0, 0, "ng-template", 9);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.column.templateRef)("ngTemplateOutletContext", ctx_r1.getTemplateContext());
  }
}
function CellComponent_Conditional_1_Case_0_Conditional_0_Conditional_1_For_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
    ɵɵpipe(1, "valueOf");
  }
  if (rf & 2) {
    const childColumn_r4 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext(5);
    ɵɵtextInterpolate1(" ", ɵɵpipeBind3(1, 1, ctx_r1.dataItem, childColumn_r4.field, childColumn_r4.format), " ");
  }
}
function CellComponent_Conditional_1_Case_0_Conditional_0_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵrepeaterCreate(0, CellComponent_Conditional_1_Case_0_Conditional_0_Conditional_1_For_1_Template, 2, 5, null, null, ɵɵrepeaterTrackByIndex);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵrepeater(ctx_r1.children);
  }
}
function CellComponent_Conditional_1_Case_0_Conditional_0_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
    ɵɵpipe(1, "valueOf");
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵtextInterpolate(ɵɵpipeBind3(1, 1, ctx_r1.dataItem, ctx_r1.column.field, ctx_r1.column.format));
  }
}
function CellComponent_Conditional_1_Case_0_Conditional_0_Conditional_3_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-checkbox", 10);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(5);
    ɵɵproperty("kendoGridSelectionCheckbox", ctx_r1.rowIndex)("inputAttributes", ɵɵpureFunction1(4, _c333, ctx_r1.selectionCheckboxLabel))("title", ctx_r1.selectionCheckboxLabel);
    ɵɵattribute("id", ctx_r1.selectionCheckboxId);
  }
}
function CellComponent_Conditional_1_Case_0_Conditional_0_Conditional_3_Conditional_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-checkbox", 11);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(6);
    ɵɵproperty("kendoGridSelectionCheckbox", ctx_r1.rowIndex)("inputAttributes", ɵɵpureFunction1(5, _c333, ctx_r1.selectionCheckboxLabel))("title", ctx_r1.selectionCheckboxLabel)("disabled", true);
    ɵɵattribute("id", ctx_r1.selectionCheckboxId);
  }
}
function CellComponent_Conditional_1_Case_0_Conditional_0_Conditional_3_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, CellComponent_Conditional_1_Case_0_Conditional_0_Conditional_3_Conditional_1_Conditional_0_Template, 1, 7, "kendo-checkbox", 11);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(5);
    ɵɵconditional(ctx_r1.column.showDisabledCheckbox ? 0 : -1);
  }
}
function CellComponent_Conditional_1_Case_0_Conditional_0_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, CellComponent_Conditional_1_Case_0_Conditional_0_Conditional_3_Conditional_0_Template, 1, 6, "kendo-checkbox", 10)(1, CellComponent_Conditional_1_Case_0_Conditional_0_Conditional_3_Conditional_1_Template, 1, 1);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵconditional(ctx_r1.isRowSelectable() ? 0 : 1);
  }
}
function CellComponent_Conditional_1_Case_0_Conditional_0_Conditional_4_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 12);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(5);
    ɵɵproperty("svgIcon", ctx_r1.reorderIcon);
  }
}
function CellComponent_Conditional_1_Case_0_Conditional_0_Conditional_4_Conditional_1_ng_template_0_Template(rf, ctx) {
}
function CellComponent_Conditional_1_Case_0_Conditional_0_Conditional_4_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, CellComponent_Conditional_1_Case_0_Conditional_0_Conditional_4_Conditional_1_ng_template_0_Template, 0, 0, "ng-template", 9);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(5);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.column.rowDragHandleTemplateRef)("ngTemplateOutletContext", ctx_r1.rowReorderTemplateContext);
  }
}
function CellComponent_Conditional_1_Case_0_Conditional_0_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, CellComponent_Conditional_1_Case_0_Conditional_0_Conditional_4_Conditional_0_Template, 1, 1, "kendo-icon-wrapper", 12)(1, CellComponent_Conditional_1_Case_0_Conditional_0_Conditional_4_Conditional_1_Template, 1, 2, null, 9);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵconditional(!(ctx_r1.column.dragHandleTemplate == null ? null : ctx_r1.column.dragHandleTemplate.first) ? 0 : 1);
  }
}
function CellComponent_Conditional_1_Case_0_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, CellComponent_Conditional_1_Case_0_Conditional_0_Conditional_0_Template, 1, 2, null, 9);
    ɵɵconditionalCreate(1, CellComponent_Conditional_1_Case_0_Conditional_0_Conditional_1_Template, 2, 0);
    ɵɵconditionalCreate(2, CellComponent_Conditional_1_Case_0_Conditional_0_Conditional_2_Template, 2, 5);
    ɵɵconditionalCreate(3, CellComponent_Conditional_1_Case_0_Conditional_0_Conditional_3_Template, 2, 1);
    ɵɵconditionalCreate(4, CellComponent_Conditional_1_Case_0_Conditional_0_Conditional_4_Template, 2, 1);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵconditional(ctx_r1.column.templateRef ? 0 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.isSpanColumn ? 1 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.isBoundColumn() ? 2 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.isCheckboxColumn() && !ctx_r1.isNew ? 3 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.isRowReorderColumn() && !ctx_r1.isNew ? 4 : -1);
  }
}
function CellComponent_Conditional_1_Case_0_Conditional_1_Conditional_0_ng_template_0_Template(rf, ctx) {
}
function CellComponent_Conditional_1_Case_0_Conditional_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, CellComponent_Conditional_1_Case_0_Conditional_1_Conditional_0_ng_template_0_Template, 0, 0, "ng-template", 9);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.loadingTemplate)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c373, ctx_r1.column));
  }
}
function CellComponent_Conditional_1_Case_0_Conditional_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 16);
  }
}
function CellComponent_Conditional_1_Case_0_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, CellComponent_Conditional_1_Case_0_Conditional_1_Conditional_0_Template, 1, 4, null, 9)(1, CellComponent_Conditional_1_Case_0_Conditional_1_Conditional_1_Template, 1, 0, "div", 16);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵconditional(ctx_r1.loadingTemplate ? 0 : 1);
  }
}
function CellComponent_Conditional_1_Case_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, CellComponent_Conditional_1_Case_0_Conditional_0_Template, 5, 5)(1, CellComponent_Conditional_1_Case_0_Conditional_1_Template, 2, 1);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵconditional(!ctx_r1.showLoading ? 0 : 1);
  }
}
function CellComponent_Conditional_1_Case_1_Conditional_0_ng_template_0_Template(rf, ctx) {
}
function CellComponent_Conditional_1_Case_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, CellComponent_Conditional_1_Case_1_Conditional_0_ng_template_0_Template, 0, 0, "ng-template", 9);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.column.editTemplateRef)("ngTemplateOutletContext", ctx_r1.getEditTemplateContext());
  }
}
function CellComponent_Conditional_1_Case_1_Conditional_1_Case_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-numerictextbox", 13);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵproperty("format", ctx_r1.format)("formControl", ctx_r1.formGroup.get(ctx_r1.column.field));
  }
}
function CellComponent_Conditional_1_Case_1_Conditional_1_Case_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-datepicker", 13);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵproperty("format", ctx_r1.format)("formControl", ctx_r1.formGroup.get(ctx_r1.column.field));
  }
}
function CellComponent_Conditional_1_Case_1_Conditional_1_Case_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-checkbox", 14);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵproperty("formControl", ctx_r1.formGroup.get(ctx_r1.column.field));
  }
}
function CellComponent_Conditional_1_Case_1_Conditional_1_Case_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-textbox", 14);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵproperty("formControl", ctx_r1.formGroup.get(ctx_r1.column.field));
  }
}
function CellComponent_Conditional_1_Case_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, CellComponent_Conditional_1_Case_1_Conditional_1_Case_0_Template, 1, 2, "kendo-numerictextbox", 13)(1, CellComponent_Conditional_1_Case_1_Conditional_1_Case_1_Template, 1, 2, "kendo-datepicker", 13)(2, CellComponent_Conditional_1_Case_1_Conditional_1_Case_2_Template, 1, 1, "kendo-checkbox", 14)(3, CellComponent_Conditional_1_Case_1_Conditional_1_Case_3_Template, 1, 1, "kendo-textbox", 14);
  }
  if (rf & 2) {
    let tmp_3_0;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵconditional((tmp_3_0 = ctx_r1.column.editor) === "numeric" ? 0 : tmp_3_0 === "date" ? 1 : tmp_3_0 === "boolean" ? 2 : 3);
  }
}
function CellComponent_Conditional_1_Case_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, CellComponent_Conditional_1_Case_1_Conditional_0_Template, 1, 2, null, 9)(1, CellComponent_Conditional_1_Case_1_Conditional_1_Template, 4, 1);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵconditional(ctx_r1.column.editTemplateRef ? 0 : 1);
  }
}
function CellComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, CellComponent_Conditional_1_Case_0_Template, 2, 1)(1, CellComponent_Conditional_1_Case_1_Template, 2, 1);
  }
  if (rf & 2) {
    let tmp_1_0;
    const ctx_r1 = ɵɵnextContext();
    ɵɵconditional((tmp_1_0 = ctx_r1.isEdited()) === false ? 0 : tmp_1_0 === true ? 1 : -1);
  }
}
var _c383 = ["kendoGridTableBody", ""];
var _c393 = (a0) => ({
  templateRef: a0
});
var _c402 = (a0, a1) => ({
  dataItem: a0,
  index: a1
});
var _c412 = (a0, a1, a2) => ({
  dataItem: a0,
  rowIndex: a1,
  $implicit: a2
});
var _c423 = (a0, a1, a2, a3, a4, a5) => ({
  templateRef: a0,
  group: a1,
  field: a2,
  column: a3,
  aggregates: a4,
  $implicit: a5
});
function _forTrack1($index, $item) {
  return this.virtualColumns ? $index : $item;
}
function TableBodyComponent_Conditional_0_Conditional_1_For_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 4);
  }
}
function TableBodyComponent_Conditional_0_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵrepeaterCreate(0, TableBodyComponent_Conditional_0_Conditional_1_For_1_Template, 1, 0, "td", 4, ɵɵrepeaterTrackByIndex);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵrepeater(ctx_r0.groups);
  }
}
function TableBodyComponent_Conditional_0_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 3);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("logicalRowIndex", ctx_r0.addRowLogicalIndex())("logicalColIndex", 0);
  }
}
function TableBodyComponent_Conditional_0_Conditional_3_For_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 5);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("rowIndex", -1)("columnIndex", 0)("isNew", true)("columns", ctx_r0.allColumns)("dataItem", ctx_r0.newDataItem)("logicalRowIndex", ctx_r0.addRowLogicalIndex())("logicalColIndex", 0);
  }
}
function TableBodyComponent_Conditional_0_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵrepeaterCreate(0, TableBodyComponent_Conditional_0_Conditional_3_For_1_Template, 1, 7, "td", 5, ɵɵcomponentInstance().trackByWrapper, true);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵrepeater(ctx_r0.rowsToRender);
  }
}
function TableBodyComponent_Conditional_0_Conditional_4_For_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 7);
  }
  if (rf & 2) {
    const column_r2 = ctx.$implicit;
    const ɵ$index_16_r3 = ctx.$index;
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵstyleProp("left", column_r2.sticky ? "0" : void 0);
    ɵɵclassProp("k-grid-content-sticky", column_r2.sticky);
    ɵɵproperty("rowIndex", -1)("columnIndex", ctx_r0.lockedColumnsCount + ɵ$index_16_r3)("isNew", true)("column", column_r2)("dataItem", ctx_r0.newDataItem)("ngClass", column_r2.cssClass)("ngStyle", column_r2.sticky ? ctx_r0.addStickyColumnStyles(column_r2) : column_r2.style)("logicalRowIndex", ctx_r0.addRowLogicalIndex())("logicalColIndex", ctx_r0.logicalColIndex(column_r2))("colSpan", column_r2.colspan);
    ɵɵattribute("colspan", column_r2.colspan)("role", column_r2.tableCellsRole);
  }
}
function TableBodyComponent_Conditional_0_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵrepeaterCreate(0, TableBodyComponent_Conditional_0_Conditional_4_For_1_Template, 1, 16, "td", 6, _forTrack1, true);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵrepeater(ctx_r0.columns);
  }
}
function TableBodyComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr", 2);
    ɵɵconditionalCreate(1, TableBodyComponent_Conditional_0_Conditional_1_Template, 2, 0);
    ɵɵconditionalCreate(2, TableBodyComponent_Conditional_0_Conditional_2_Template, 1, 2, "td", 3);
    ɵɵconditionalCreate(3, TableBodyComponent_Conditional_0_Conditional_3_Template, 2, 0)(4, TableBodyComponent_Conditional_0_Conditional_4_Template, 2, 0);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵstyleProp("height", ctx_r0.rowHeight, "px");
    ɵɵproperty("logicalRowIndex", ctx_r0.addRowLogicalIndex())("logicalSlaveRow", ctx_r0.lockedColumnsCount > 0 && !ctx_r0.isStackedMode)("logicalCellsCount", ctx_r0.columns.length)("logicalSlaveCellsCount", ctx_r0.unlockedColumnsCount())("totalColumns", ctx_r0.totalColumns);
    ɵɵadvance();
    ɵɵconditional(!ctx_r0.skipGroupDecoration ? 1 : -1);
    ɵɵadvance();
    ɵɵconditional((ctx_r0.detailTemplate == null ? null : ctx_r0.detailTemplate.templateRef) && !ctx_r0.isStackedMode ? 2 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r0.isStackedMode ? 3 : 4);
  }
}
function TableBodyComponent_Conditional_1_Conditional_2_ng_template_0_Template(rf, ctx) {
}
function TableBodyComponent_Conditional_1_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TableBodyComponent_Conditional_1_Conditional_2_ng_template_0_Template, 0, 0, "ng-template", 9);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("templateContext", ɵɵpureFunction1(1, _c393, ctx_r0.noRecordsTemplate == null ? null : ctx_r0.noRecordsTemplate.templateRef));
  }
}
function TableBodyComponent_Conditional_1_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵtextInterpolate1(" ", ctx_r0.noRecordsText, " ");
  }
}
function TableBodyComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr", 1)(1, "td", 8);
    ɵɵconditionalCreate(2, TableBodyComponent_Conditional_1_Conditional_2_Template, 1, 3, null, 9)(3, TableBodyComponent_Conditional_1_Conditional_3_Template, 1, 1);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵattribute("colspan", ctx_r0.colSpan);
    ɵɵadvance();
    ɵɵconditional((ctx_r0.noRecordsTemplate == null ? null : ctx_r0.noRecordsTemplate.templateRef) ? 2 : 3);
  }
}
function TableBodyComponent_For_3_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "tr", 14);
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    const item_r5 = ctx_r3.$implicit;
    const ɵ$index_29_r6 = ctx_r3.$index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵstyleProp("height", ctx_r0.rowHeight, "px");
    ɵɵproperty("columns", ctx_r0.columns)("groups", ctx_r0.groups)("item", item_r5)("hasDetails", !!(ctx_r0.detailTemplate == null ? null : ctx_r0.detailTemplate.templateRef))("skipGroupDecoration", ctx_r0.skipGroupDecoration)("hasGroupHeaderColumn", ctx_r0.hasGroupHeaderColumn)("groupHeaderColumns", ctx_r0.groupHeaderColumns)("rowIndex", ɵ$index_29_r6 + 1)("totalColumnsCount", ctx_r0.totalColumnsCount)("logicalRowIndex", ctx_r0.logicalRowIndex(ɵ$index_29_r6))("logicalSlaveRow", ctx_r0.lockedColumnsCount > 0 && !ctx_r0.isStackedMode)("totalColumns", ctx_r0.totalColumns)("logicalCellsCount", ctx_r0.columns.length)("logicalSlaveCellsCount", ctx_r0.groupHeaderSlaveCellsCount);
  }
}
function TableBodyComponent_For_3_Conditional_1_Conditional_1_For_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 4);
  }
}
function TableBodyComponent_For_3_Conditional_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵrepeaterCreate(0, TableBodyComponent_For_3_Conditional_1_Conditional_1_For_1_Template, 1, 0, "td", 4, ɵɵrepeaterTrackByIndex);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵrepeater(ctx_r0.groups);
  }
}
function TableBodyComponent_For_3_Conditional_1_Conditional_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 19);
    ɵɵlistener("click", function TableBodyComponent_For_3_Conditional_1_Conditional_2_Conditional_1_Template_a_click_0_listener() {
      ɵɵrestoreView(_r7);
      const item_r5 = ɵɵnextContext(3).$implicit;
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.toggleRow(item_r5.index, item_r5.data));
    });
    ɵɵelement(1, "kendo-icon-wrapper", 20);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r5 = ɵɵnextContext(3).$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵattribute("title", ctx_r0.detailButtonTitle(item_r5))("aria-label", ctx_r0.detailButtonTitle(item_r5));
    ɵɵadvance();
    ɵɵproperty("name", ctx_r0.detailButtonIconName(item_r5))("svgIcon", ctx_r0.detailButtonSvgIcon(item_r5));
  }
}
function TableBodyComponent_For_3_Conditional_1_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 16);
    ɵɵconditionalCreate(1, TableBodyComponent_For_3_Conditional_1_Conditional_2_Conditional_1_Template, 2, 4, "a", 18);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext(2);
    const item_r5 = ctx_r3.$implicit;
    const ɵ$index_29_r6 = ctx_r3.$index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("logicalRowIndex", ctx_r0.logicalRowIndex(ɵ$index_29_r6))("logicalColIndex", 0)("dataRowIndex", item_r5.index)("dataItem", item_r5.data)("detailExpandCell", true);
    ɵɵattribute("aria-expanded", item_r5.isExpanded);
    ɵɵadvance();
    ɵɵconditional(ctx_r0.detailTemplate.showIf(item_r5.data, item_r5.index) ? 1 : -1);
  }
}
function TableBodyComponent_For_3_Conditional_1_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 21);
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext(2);
    const item_r5 = ctx_r3.$implicit;
    const ɵ$index_29_r6 = ctx_r3.$index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassProp("k-touch-action-none", ctx_r0.isSelectable(ɵɵpureFunction2(17, _c402, item_r5.data, item_r5.index)) && ctx_r0.selectable.drag);
    ɵɵproperty("rowIndex", item_r5.index)("detailTemplate", ctx_r0.detailTemplate)("item", item_r5)("columnIndex", 0)("columns", ctx_r0.columns)("dataItem", item_r5.data)("isLoading", ctx_r0.isLoading)("isVirtual", ctx_r0.isVirtual)("loadingTemplate", ctx_r0.cellLoadingTemplate)("logicalRowIndex", ctx_r0.logicalRowIndex(ɵ$index_29_r6))("logicalColIndex", 0)("dataRowIndex", item_r5.index)("dataItem", item_r5.data)("colIndex", 0);
    ɵɵattribute("data-kendo-grid-column-index", 0);
  }
}
function TableBodyComponent_For_3_Conditional_1_Conditional_4_For_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 23);
  }
  if (rf & 2) {
    const ctx_r7 = ɵɵnextContext();
    const column_r9 = ctx_r7.$implicit;
    const ɵ$index_52_r10 = ctx_r7.$index;
    const ctx_r3 = ɵɵnextContext(3);
    const item_r5 = ctx_r3.$implicit;
    const ɵ$index_29_r6 = ctx_r3.$index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassProp("k-grid-content-sticky", column_r9.sticky)("k-touch-action-none", ctx_r0.isSelectable(ɵɵpureFunction2(31, _c402, item_r5.data, item_r5.index)) && ctx_r0.selectable.drag)("k-grid-edit-cell", ctx_r0.isEditingCell(item_r5.index, column_r9))("k-selected", ctx_r0.isSelectable && ctx_r0.cellSelectionService.isCellSelected(item_r5, column_r9))("k-highlighted", item_r5.cells[ctx_r0.lockedColumnsCount + ɵ$index_52_r10] == null ? null : item_r5.cells[ctx_r0.lockedColumnsCount + ɵ$index_52_r10].isHighlighted);
    ɵɵproperty("rowIndex", item_r5.index)("columnIndex", ctx_r0.lockedColumnsCount + ɵ$index_52_r10)("column", column_r9)("columns", ctx_r0.allColumns)("dataItem", item_r5.data)("isLoading", ctx_r0.isLoading)("isVirtual", ctx_r0.isVirtual)("loadingTemplate", ctx_r0.cellLoadingTemplate)("logicalRowIndex", ctx_r0.logicalRowIndex(ɵ$index_29_r6))("logicalColIndex", ctx_r0.logicalColIndex(column_r9))("dataRowIndex", item_r5.index)("dataItem", item_r5.data)("colIndex", ɵ$index_52_r10)("colSpan", column_r9.colspan)("rowSpan", item_r5.cells[ctx_r0.lockedColumnsCount + ɵ$index_52_r10] == null ? null : item_r5.cells[ctx_r0.lockedColumnsCount + ɵ$index_52_r10].rowspan)("ngClass", column_r9.cssClass)("ngStyle", column_r9.sticky ? ctx_r0.addStickyColumnStyles(column_r9) : column_r9.style);
    ɵɵattribute("data-kendo-grid-column-index", ctx_r0.lockedColumnsCount + ɵ$index_52_r10)("role", column_r9.tableCellsRole)("aria-selected", ctx_r0.lockedColumnsCount < 1 && ctx_r0.isSelectable(ɵɵpureFunction2(34, _c402, item_r5.data, item_r5.index)) ? ctx_r0.isAriaSelected(item_r5, column_r9) : void 0)("colspan", column_r9.colspan);
  }
}
function TableBodyComponent_For_3_Conditional_1_Conditional_4_For_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, TableBodyComponent_For_3_Conditional_1_Conditional_4_For_1_Conditional_0_Template, 1, 37, "td", 22);
  }
  if (rf & 2) {
    const ɵ$index_52_r10 = ctx.$index;
    const item_r5 = ɵɵnextContext(3).$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵconditional(!(item_r5.cells == null ? null : item_r5.cells[ctx_r0.lockedColumnsCount + ɵ$index_52_r10] == null ? null : item_r5.cells[ctx_r0.lockedColumnsCount + ɵ$index_52_r10].skip) ? 0 : -1);
  }
}
function TableBodyComponent_For_3_Conditional_1_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵrepeaterCreate(0, TableBodyComponent_For_3_Conditional_1_Conditional_4_For_1_Template, 1, 1, null, null, _forTrack1, true);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵrepeater(ctx_r0.columns);
  }
}
function TableBodyComponent_For_3_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr", 15);
    ɵɵconditionalCreate(1, TableBodyComponent_For_3_Conditional_1_Conditional_1_Template, 2, 0);
    ɵɵconditionalCreate(2, TableBodyComponent_For_3_Conditional_1_Conditional_2_Template, 2, 7, "td", 16);
    ɵɵconditionalCreate(3, TableBodyComponent_For_3_Conditional_1_Conditional_3_Template, 1, 20, "td", 17)(4, TableBodyComponent_For_3_Conditional_1_Conditional_4_Template, 2, 0);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    const item_r5 = ctx_r3.$implicit;
    const ɵ$index_29_r6 = ctx_r3.$index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassMap(ctx_r0.isOdd(item_r5) ? "k-table-alt-row" : "");
    ɵɵstyleProp("height", ctx_r0.rowHeight, "px");
    ɵɵclassProp("k-grid-row-sticky", ctx_r0.rowSticky ? ctx_r0.rowSticky(ɵɵpureFunction2(29, _c402, item_r5.data, item_r5.index)) : false)("k-master-row", true)("k-expanded", item_r5.isExpanded && !ctx_r0.isStackedMode)("k-grid-edit-row", ctx_r0.isEditingRow(item_r5.index))("k-selected", ctx_r0.isSelectable(ɵɵpureFunction2(32, _c402, item_r5.data, item_r5.index)) && ctx_r0.isRowSelected(item_r5))("k-highlighted", item_r5.isHighlighted);
    ɵɵproperty("dataRowIndex", item_r5.index)("dataItem", item_r5.data)("logicalRowIndex", ctx_r0.logicalRowIndex(ɵ$index_29_r6))("logicalSlaveRow", ctx_r0.lockedColumnsCount > 0 && !ctx_r0.isStackedMode)("totalColumns", ctx_r0.totalColumns)("logicalCellsCount", ctx_r0.columns.length)("logicalSlaveCellsCount", ctx_r0.unlockedColumnsCount(item_r5))("ngClass", ctx_r0.rowClass(ɵɵpureFunction2(35, _c402, item_r5.data, item_r5.index)));
    ɵɵattribute("aria-selected", ctx_r0.lockedColumnsCount < 1 || ctx_r0.isStackedMode ? ctx_r0.isSelectable(ɵɵpureFunction2(38, _c402, item_r5.data, item_r5.index)) && ctx_r0.isRowSelected(item_r5) : void 0)("data-kendo-grid-item-index", item_r5.index);
    ɵɵadvance();
    ɵɵconditional(!ctx_r0.skipGroupDecoration ? 1 : -1);
    ɵɵadvance();
    ɵɵconditional((ctx_r0.detailTemplate == null ? null : ctx_r0.detailTemplate.templateRef) && !ctx_r0.isStackedMode ? 2 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r0.isStackedMode ? 3 : 4);
  }
}
function TableBodyComponent_For_3_Conditional_2_Conditional_1_For_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 26);
  }
}
function TableBodyComponent_For_3_Conditional_2_Conditional_1_ng_template_4_Template(rf, ctx) {
}
function TableBodyComponent_For_3_Conditional_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵrepeaterCreate(0, TableBodyComponent_For_3_Conditional_2_Conditional_1_For_1_Template, 1, 0, "td", 26, ɵɵrepeaterTrackByIndex);
    ɵɵelement(2, "td", 27);
    ɵɵelementStart(3, "td", 25);
    ɵɵtemplate(4, TableBodyComponent_For_3_Conditional_2_Conditional_1_ng_template_4_Template, 0, 0, "ng-template", 28);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext(2);
    const item_r5 = ctx_r3.$implicit;
    const ɵ$index_29_r6 = ctx_r3.$index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵrepeater(ctx_r0.groups);
    ɵɵadvance(3);
    ɵɵproperty("logicalRowIndex", ctx_r0.logicalRowIndex(ɵ$index_29_r6) + 1)("logicalColIndex", 0)("dataRowIndex", item_r5.index)("dataItem", item_r5.data)("colIndex", 0)("colSpan", ctx_r0.allColumnsSpan + 1);
    ɵɵattribute("colspan", ctx_r0.columnsSpan);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.detailTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction3(9, _c412, item_r5.data, item_r5.index, item_r5.data));
  }
}
function TableBodyComponent_For_3_Conditional_2_Conditional_2_ng_template_1_Template(rf, ctx) {
}
function TableBodyComponent_For_3_Conditional_2_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 25);
    ɵɵtemplate(1, TableBodyComponent_For_3_Conditional_2_Conditional_2_ng_template_1_Template, 0, 0, "ng-template", 28);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext(2);
    const item_r5 = ctx_r3.$implicit;
    const ɵ$index_29_r6 = ctx_r3.$index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("logicalRowIndex", ctx_r0.logicalRowIndex(ɵ$index_29_r6))("logicalColIndex", 0)("dataRowIndex", item_r5.index)("dataItem", item_r5.data)("colIndex", 0)("colSpan", ctx_r0.allColumnsSpan + 1);
    ɵɵattribute("colspan", ctx_r0.columnsSpan);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.detailTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction3(9, _c412, item_r5.data, item_r5.index, item_r5.data));
  }
}
function TableBodyComponent_For_3_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr", 24);
    ɵɵconditionalCreate(1, TableBodyComponent_For_3_Conditional_2_Conditional_1_Template, 5, 13)(2, TableBodyComponent_For_3_Conditional_2_Conditional_2_Template, 2, 13, "td", 25);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    const item_r5 = ctx_r3.$implicit;
    const ɵ$index_29_r6 = ctx_r3.$index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵstyleProp("height", ctx_r0.detailRowHeight, "px");
    ɵɵproperty("dataRowIndex", item_r5.index)("dataItem", item_r5.data)("logicalRowIndex", ctx_r0.isStackedMode ? ctx_r0.logicalRowIndex(ɵ$index_29_r6) : ctx_r0.logicalRowIndex(ɵ$index_29_r6) + 1)("logicalSlaveRow", false)("logicalCellsCount", 1);
    ɵɵadvance();
    ɵɵconditional(!ctx_r0.isStackedMode ? 1 : 2);
  }
}
function TableBodyComponent_For_3_Conditional_3_Conditional_1_For_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 26);
  }
}
function TableBodyComponent_For_3_Conditional_3_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵrepeaterCreate(0, TableBodyComponent_For_3_Conditional_3_Conditional_1_For_1_Template, 1, 0, "td", 26, ɵɵrepeaterTrackByIndex);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵrepeater(ctx_r0.groups);
  }
}
function TableBodyComponent_For_3_Conditional_3_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 3);
  }
  if (rf & 2) {
    const ɵ$index_29_r6 = ɵɵnextContext(2).$index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("logicalRowIndex", ctx_r0.logicalRowIndex(ɵ$index_29_r6))("logicalColIndex", 0);
  }
}
function TableBodyComponent_For_3_Conditional_3_Conditional_3_For_1_ng_template_1_Template(rf, ctx) {
}
function TableBodyComponent_For_3_Conditional_3_Conditional_3_For_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 30);
    ɵɵtemplate(1, TableBodyComponent_For_3_Conditional_3_Conditional_3_For_1_ng_template_1_Template, 0, 0, "ng-template", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r11 = ctx.$implicit;
    const ctx_r3 = ɵɵnextContext(3);
    const item_r5 = ctx_r3.$implicit;
    const ɵ$index_29_r6 = ctx_r3.$index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("logicalRowIndex", ctx_r0.logicalRowIndex(ɵ$index_29_r6))("logicalColIndex", ctx_r0.logicalColIndex(column_r11));
    ɵɵattribute("data-skip", ctx_r0.skipGroupDecoration);
    ɵɵadvance();
    ɵɵproperty("templateContext", ɵɵpureFunction6(4, _c423, column_r11.groupFooterTemplateRef, item_r5.data, column_r11.field, column_r11, item_r5.data == null ? null : item_r5.data.aggregates, item_r5.data == null ? null : item_r5.data.aggregates));
  }
}
function TableBodyComponent_For_3_Conditional_3_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵrepeaterCreate(0, TableBodyComponent_For_3_Conditional_3_Conditional_3_For_1_Template, 2, 11, "td", 30, _forTrack1, true);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵrepeater(ctx_r0.footerColumns);
  }
}
function TableBodyComponent_For_3_Conditional_3_Conditional_4_For_3_Conditional_0_ng_template_1_Template(rf, ctx) {
}
function TableBodyComponent_For_3_Conditional_3_Conditional_4_For_3_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 32);
    ɵɵtemplate(1, TableBodyComponent_For_3_Conditional_3_Conditional_4_For_3_Conditional_0_ng_template_1_Template, 0, 0, "ng-template", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const col_r12 = ɵɵnextContext().$implicit;
    const item_r5 = ɵɵnextContext(3).$implicit;
    ɵɵadvance();
    ɵɵproperty("templateContext", ɵɵpureFunction6(1, _c423, col_r12.groupFooterTemplateRef, item_r5.data, col_r12.field, col_r12, item_r5.data == null ? null : item_r5.data.aggregates, item_r5.data == null ? null : item_r5.data.aggregates));
  }
}
function TableBodyComponent_For_3_Conditional_3_Conditional_4_For_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, TableBodyComponent_For_3_Conditional_3_Conditional_4_For_3_Conditional_0_Template, 2, 8, "div", 32);
  }
  if (rf & 2) {
    const col_r12 = ctx.$implicit;
    ɵɵconditional(col_r12.groupFooterTemplateRef ? 0 : -1);
  }
}
function TableBodyComponent_For_3_Conditional_3_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 30)(1, "div", 31);
    ɵɵrepeaterCreate(2, TableBodyComponent_For_3_Conditional_3_Conditional_4_For_3_Template, 1, 1, null, null, ɵɵrepeaterTrackByIndex);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ɵ$index_29_r6 = ɵɵnextContext(2).$index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("logicalRowIndex", ctx_r0.logicalRowIndex(ɵ$index_29_r6))("logicalColIndex", ctx_r0.hasDetailTemplate ? 1 : 0);
    ɵɵattribute("data-skip", ctx_r0.skipGroupDecoration);
    ɵɵadvance(2);
    ɵɵrepeater(ctx_r0.footerColumns);
  }
}
function TableBodyComponent_For_3_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr", 29);
    ɵɵconditionalCreate(1, TableBodyComponent_For_3_Conditional_3_Conditional_1_Template, 2, 0);
    ɵɵconditionalCreate(2, TableBodyComponent_For_3_Conditional_3_Conditional_2_Template, 1, 2, "td", 3);
    ɵɵconditionalCreate(3, TableBodyComponent_For_3_Conditional_3_Conditional_3_Template, 2, 0)(4, TableBodyComponent_For_3_Conditional_3_Conditional_4_Template, 4, 3, "td", 30);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    const item_r5 = ctx_r3.$implicit;
    const ɵ$index_29_r6 = ctx_r3.$index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵstyleProp("height", ctx_r0.rowHeight, "px");
    ɵɵproperty("logicalRowIndex", ctx_r0.logicalRowIndex(ɵ$index_29_r6))("logicalSlaveRow", ctx_r0.lockedColumnsCount > 0 && !ctx_r0.isStackedMode)("totalColumns", ctx_r0.totalColumns)("logicalCellsCount", ctx_r0.columns.length)("logicalSlaveCellsCount", ctx_r0.unlockedColumnsCount(item_r5));
    ɵɵadvance();
    ɵɵconditional(!ctx_r0.skipGroupDecoration ? 1 : -1);
    ɵɵadvance();
    ɵɵconditional((ctx_r0.detailTemplate == null ? null : ctx_r0.detailTemplate.templateRef) && !ctx_r0.isStackedMode ? 2 : -1);
    ɵɵadvance();
    ɵɵconditional(!ctx_r0.isStackedMode ? 3 : 4);
  }
}
function TableBodyComponent_For_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, TableBodyComponent_For_3_Conditional_0_Template, 1, 16, "tr", 10);
    ɵɵconditionalCreate(1, TableBodyComponent_For_3_Conditional_1_Template, 5, 41, "tr", 11);
    ɵɵconditionalCreate(2, TableBodyComponent_For_3_Conditional_2_Template, 3, 8, "tr", 12);
    ɵɵconditionalCreate(3, TableBodyComponent_For_3_Conditional_3_Template, 5, 10, "tr", 13);
  }
  if (rf & 2) {
    const item_r5 = ctx.$implicit;
    ɵɵconditional(item_r5.type === "group" ? 0 : -1);
    ɵɵadvance();
    ɵɵconditional(item_r5.showDataItem ? 1 : -1);
    ɵɵadvance();
    ɵɵconditional(item_r5.showDetailRow ? 2 : -1);
    ɵɵadvance();
    ɵɵconditional(item_r5.type === "footer" ? 3 : -1);
  }
}
function TableBodyComponent_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r13 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-resize-sensor", 33);
    ɵɵlistener("resize", function TableBodyComponent_Conditional_4_Template_kendo_resize_sensor_resize_0_listener() {
      ɵɵrestoreView(_r13);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.resizeHandler());
    });
    ɵɵelementEnd();
  }
}
var _c433 = ["kendoGridEditCommand", ""];
function EditCommandDirective_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r0.icon)("svgIcon", ctx_r0.svgIcon);
  }
}
function EditCommandDirective_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 1);
    ɵɵelement(1, "img", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("src", ctx_r0.imageUrl, ɵɵsanitizeUrl);
  }
}
function EditCommandDirective_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 2);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ctx_r0.iconClass);
  }
}
var _c442 = ["kendoGridCancelCommand", ""];
function CancelCommandDirective_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r0.icon)("svgIcon", ctx_r0.svgIcon);
  }
}
function CancelCommandDirective_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 1);
    ɵɵelement(1, "img", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("src", ctx_r0.imageUrl, ɵɵsanitizeUrl);
  }
}
function CancelCommandDirective_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 2);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ctx_r0.iconClass);
  }
}
var _c452 = ["kendoGridSaveCommand", ""];
function SaveCommandDirective_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r0.icon)("svgIcon", ctx_r0.svgIcon);
  }
}
function SaveCommandDirective_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 1);
    ɵɵelement(1, "img", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("src", ctx_r0.imageUrl, ɵɵsanitizeUrl);
  }
}
function SaveCommandDirective_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 2);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ctx_r0.iconClass);
  }
}
var _c462 = ["kendoGridRemoveCommand", ""];
function RemoveCommandDirective_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r0.icon)("svgIcon", ctx_r0.svgIcon);
  }
}
function RemoveCommandDirective_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 1);
    ɵɵelement(1, "img", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("src", ctx_r0.imageUrl, ɵɵsanitizeUrl);
  }
}
function RemoveCommandDirective_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 2);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ctx_r0.iconClass);
  }
}
var _c472 = ["kendoGridAddCommand", ""];
function AddCommandDirective_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r0.icon)("svgIcon", ctx_r0.svgIcon);
  }
}
function AddCommandDirective_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 1);
    ɵɵelement(1, "img", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("src", ctx_r0.imageUrl, ɵɵsanitizeUrl);
  }
}
function AddCommandDirective_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 2);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ctx_r0.iconClass);
  }
}
var _c482 = (a0) => ({
  aggregates: a0
});
function StatusBarComponent_Conditional_0_ng_template_0_Template(rf, ctx) {
}
function StatusBarComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, StatusBarComponent_Conditional_0_ng_template_0_Template, 0, 0, "ng-template", 0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.statusBarTemplate == null ? null : ctx_r0.statusBarTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c482, ctx_r0.aggregates));
  }
}
var _c492 = ["container"];
var _c50 = ["lockedContainer"];
var _c51 = ["lockedTable"];
var _c522 = ["table"];
var _c532 = () => [];
var _c542 = (a0, a1, a2, a3) => ({
  keydown: a0,
  scroll: a1,
  mousewheel: a2,
  DOMMouseScroll: a3
});
function ListComponent_Conditional_0_Conditional_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 10);
    ɵɵelement(1, "div");
    ɵɵelementEnd();
  }
}
function ListComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 12, 2)(2, "div", 6)(3, "table", 13, 3);
    ɵɵelement(5, "colgroup", 8)(6, "tbody", 14);
    ɵɵelementEnd();
    ɵɵelement(7, "kendo-resize-sensor");
    ɵɵelementEnd();
    ɵɵconditionalCreate(8, ListComponent_Conditional_0_Conditional_8_Template, 2, 0, "div", 10);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵstyleProp("width", ctx_r0.lockedWidth, "px");
    ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction4(31, _c542, ctx_r0.lockedKeydown, ctx_r0.lockedScroll, ctx_r0.lockedMousewheel, ctx_r0.lockedMousewheel))("scope", ctx_r0);
    ɵɵadvance(3);
    ɵɵstyleProp("width", ctx_r0.lockedWidth, "px");
    ɵɵproperty("locked", true)("size", ctx_r0.size);
    ɵɵadvance(2);
    ɵɵproperty("groups", ctx_r0.groups)("columns", ctx_r0.lockedLeafColumns)("detailTemplate", ctx_r0.detailTemplate)("sort", ctx_r0.sort);
    ɵɵadvance();
    ɵɵproperty("groups", ctx_r0.groups)("isLocked", true)("rowsToRender", ctx_r0.itemsToRender)("rowHeight", ctx_r0.rowHeight)("detailRowHeight", ctx_r0.detailRowHeight)("noRecordsText", "")("columns", ctx_r0.lockedLeafColumns)("totalColumnsCount", ctx_r0.leafColumns.length)("totalColumns", ctx_r0.columns)("detailTemplate", ctx_r0.detailTemplate)("skip", ctx_r0.skip)("selectable", ctx_r0.selectable)("trackBy", ctx_r0.trackBy)("filterable", ctx_r0.filterable)("rowClass", ctx_r0.rowClass)("isLoading", ctx_r0.loading)("isVirtual", ctx_r0.isVirtual)("cellLoadingTemplate", ctx_r0.cellLoadingTemplate);
    ɵɵadvance(2);
    ɵɵconditional(ctx_r0.isVirtual ? 8 : -1);
  }
}
function ListComponent_Conditional_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-resize-sensor");
  }
}
function ListComponent_Conditional_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-resize-sensor");
  }
}
function ListComponent_Conditional_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 10);
    ɵɵelement(1, "div");
    ɵɵelementEnd();
  }
}
function ListComponent_Conditional_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 11);
    ɵɵelement(1, "div");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵstyleProp("width", ctx_r0.totalWidth, "px");
  }
}
function ToolbarComponent_Conditional_0_ng_template_0_Template(rf, ctx) {
}
function ToolbarComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ToolbarComponent_Conditional_0_ng_template_0_Template, 0, 0, "ng-template", 0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.toolbarTemplateRef)("ngTemplateOutletContext", ctx_r0.context);
  }
}
var _c552 = ["filterItem"];
var _c562 = ["filterContainer"];
function FilterToolbarToolComponent_For_2_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-filter-menu-container", 5, 1);
    ɵɵlistener("keydown.shift.tab", function FilterToolbarToolComponent_For_2_ng_template_2_Template_kendo_grid_filter_menu_container_keydown_shift_tab_0_listener($event) {
      ɵɵrestoreView(_r6);
      return ɵɵresetView($event.stopImmediatePropagation());
    })("close", function FilterToolbarToolComponent_For_2_ng_template_2_Template_kendo_grid_filter_menu_container_close_0_listener() {
      ɵɵrestoreView(_r6);
      ɵɵnextContext();
      const filterItem_r2 = ɵɵreference(1);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleClose(filterItem_r2));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r5 = ɵɵnextContext().$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("column", ctx_r2.getColumnComponent(column_r5))("filter", ctx_r2.filter)("isExpanded", false);
  }
}
function FilterToolbarToolComponent_For_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-columnmenu-item", 3, 0);
    ɵɵlistener("focus", function FilterToolbarToolComponent_For_2_Template_kendo_grid_columnmenu_item_focus_0_listener() {
      ɵɵrestoreView(_r1);
      const filterItem_r2 = ɵɵreference(1);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onItemFocus(filterItem_r2));
    })("focusout", function FilterToolbarToolComponent_For_2_Template_kendo_grid_columnmenu_item_focusout_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onItemFocusOut());
    })("keydown.enter", function FilterToolbarToolComponent_For_2_Template_kendo_grid_columnmenu_item_keydown_enter_0_listener($event) {
      const ɵ$index_3_r4 = ɵɵrestoreView(_r1).$index;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.toggleItem($event, ɵ$index_3_r4));
    })("itemClick", function FilterToolbarToolComponent_For_2_Template_kendo_grid_columnmenu_item_itemClick_0_listener() {
      const column_r5 = ɵɵrestoreView(_r1).$implicit;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.navigateView(ctx_r2.getColumnComponent(column_r5)));
    });
    ɵɵtemplate(2, FilterToolbarToolComponent_For_2_ng_template_2_Template, 2, 3, "ng-template", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r5 = ctx.$implicit;
    const filterItem_r2 = ɵɵreference(1);
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("column", ctx_r2.getColumnComponent(column_r5))("text", column_r5.title || ctx_r2.getColumnComponent(column_r5).field)("indicatorIcon", ctx_r2.isFilterApplied(column_r5))("expanded", false)("focused", ctx_r2.isItemFocused(filterItem_r2));
  }
}
var _c572 = ["sortItem"];
function SortToolbarToolComponent_For_2_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 7);
  }
  if (rf & 2) {
    const column_r2 = ɵɵnextContext().$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("name", ɵɵinterpolate1("sort-", ctx_r2.sortDescriptor(ctx_r2.getColumnComponent(column_r2).field).dir, "-small"))("svgIcon", ctx_r2.sortDescriptor(ctx_r2.getColumnComponent(column_r2).field).dir === "asc" ? ctx_r2.sortAscSmallIcon : ctx_r2.sortDescSmallIcon);
  }
}
function SortToolbarToolComponent_For_2_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 8);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r2 = ɵɵnextContext().$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r2.sortOrder(ctx_r2.getColumnComponent(column_r2).field));
  }
}
function SortToolbarToolComponent_For_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 5, 0);
    ɵɵlistener("click", function SortToolbarToolComponent_For_2_Template_div_click_0_listener($event) {
      const column_r2 = ɵɵrestoreView(_r1).$implicit;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.toggleSort(column_r2, $event));
    })("keydown.enter", function SortToolbarToolComponent_For_2_Template_div_keydown_enter_0_listener($event) {
      const column_r2 = ɵɵrestoreView(_r1).$implicit;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.toggleSort(column_r2, $event));
    });
    ɵɵtext(2);
    ɵɵelementStart(3, "span", 6);
    ɵɵconditionalCreate(4, SortToolbarToolComponent_For_2_Conditional_4_Template, 1, 3, "kendo-icon-wrapper", 7);
    ɵɵconditionalCreate(5, SortToolbarToolComponent_For_2_Conditional_5_Template, 2, 1, "span", 8);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const column_r2 = ctx.$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("tabindex", "0");
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", column_r2.title || ctx_r2.getColumnComponent(column_r2).field, " ");
    ɵɵadvance(2);
    ɵɵconditional(ctx_r2.sortDescriptor(ctx_r2.getColumnComponent(column_r2).field).dir ? 4 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r2.showSortNumbering(ctx_r2.getColumnComponent(column_r2)) ? 5 : -1);
  }
}
var _c58 = ["input"];
function FormFormFieldComponent_Conditional_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-textbox", 5);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("formControl", ctx_r0.control.formControl);
  }
}
function FormFormFieldComponent_Conditional_1_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-numerictextbox", 5);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("formControl", ctx_r0.control.formControl);
  }
}
function FormFormFieldComponent_Conditional_1_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-datepicker", 5);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("formControl", ctx_r0.control.formControl);
  }
}
function FormFormFieldComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-floatinglabel", 3);
    ɵɵconditionalCreate(1, FormFormFieldComponent_Conditional_1_Conditional_1_Template, 1, 1, "kendo-textbox", 5);
    ɵɵconditionalCreate(2, FormFormFieldComponent_Conditional_1_Conditional_2_Template, 1, 1, "kendo-numerictextbox", 5);
    ɵɵconditionalCreate(3, FormFormFieldComponent_Conditional_1_Conditional_3_Template, 1, 1, "kendo-datepicker", 5);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("text", ctx_r0.control.label);
    ɵɵadvance();
    ɵɵconditional(ctx_r0.control.dataType === "text" ? 1 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r0.control.dataType === "numeric" ? 2 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r0.control.dataType === "date" ? 3 : -1);
  }
}
function FormFormFieldComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-label", 7);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵstyleProp("align-items", "start");
    ɵɵproperty("text", ctx_r0.control.label)("for", ctx_r0.input);
  }
}
function FormFormFieldComponent_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-textbox", 5, 0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("formControl", ctx_r0.control.formControl);
  }
}
function FormFormFieldComponent_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-numerictextbox", 5, 0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("formControl", ctx_r0.control.formControl);
  }
}
function FormFormFieldComponent_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-datepicker", 5, 0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("formControl", ctx_r0.control.formControl);
  }
}
function FormFormFieldComponent_Conditional_6_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-label", 8);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const cb_r2 = ɵɵreference(2);
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("for", cb_r2)("text", ctx_r0.control.label);
  }
}
function FormFormFieldComponent_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 6);
    ɵɵelement(1, "kendo-checkbox", 5, 1);
    ɵɵconditionalCreate(3, FormFormFieldComponent_Conditional_6_Conditional_3_Template, 1, 2, "kendo-label", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("formControl", ctx_r0.control.formControl);
    ɵɵadvance(2);
    ɵɵconditional(ctx_r0.control.label ? 3 : -1);
  }
}
function FormFormFieldComponent_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-formhint");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.control.hint);
  }
}
function FormFormFieldComponent_Conditional_8_For_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-formerror");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const err_r3 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.control.errors ? ctx_r0.control.errors[err_r3.key] : ctx_r0.messageFor("formValidationError", err_r3.key, ctx_r0.control.name));
  }
}
function FormFormFieldComponent_Conditional_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵrepeaterCreate(0, FormFormFieldComponent_Conditional_8_For_1_Template, 2, 1, "kendo-formerror", null, ɵɵrepeaterTrackByIdentity);
    ɵɵpipe(2, "keyvalue");
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵrepeater(ɵɵpipeBind1(2, 0, ctx_r0.control == null ? null : ctx_r0.control.formControl == null ? null : ctx_r0.control.formControl.errors));
  }
}
function FormComponent_For_2_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-form-formfield", 3);
  }
  if (rf & 2) {
    const control_r1 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("control", control_r1)("showError", ctx_r1.formSettings.showErrors)("floatingLabel", ctx_r1.formSettings.floatingLabels);
  }
}
function FormComponent_For_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 4);
  }
  if (rf & 2) {
    const control_r1 = ɵɵnextContext().$implicit;
    ɵɵproperty("ngTemplateOutlet", control_r1.template)("ngTemplateOutletContext", control_r1.templateContext);
  }
}
function FormComponent_For_2_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 4);
  }
  if (rf & 2) {
    const control_r1 = ɵɵnextContext().$implicit;
    ɵɵproperty("ngTemplateOutlet", control_r1.template)("ngTemplateOutletContext", control_r1.templateContext);
  }
}
function FormComponent_For_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, FormComponent_For_2_Conditional_0_Template, 1, 3, "kendo-form-formfield", 3)(1, FormComponent_For_2_Conditional_1_Template, 1, 2, "ng-container", 4);
    ɵɵtemplate(2, FormComponent_For_2_ng_template_2_Template, 1, 2, "ng-template", null, 0, ɵɵtemplateRefExtractor);
  }
  if (rf & 2) {
    const control_r1 = ctx.$implicit;
    ɵɵconditional(!control_r1.template ? 0 : 1);
  }
}
function FormComponent_Conditional_3_For_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "button", 6);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const button_r3 = ctx.$implicit;
    ɵɵclassProp("k-form-submit", button_r3.actionType === "submit");
    ɵɵproperty("size", button_r3.size)("themeColor", button_r3.themeColor || button_r3.actionType === "submit" ? "primary" : void 0)("rounded", button_r3.rounded)("svgIcon", button_r3.svgIcon)("icon", button_r3.icon);
    ɵɵattribute("type", button_r3.actionType);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", button_r3.text, " ");
  }
}
function FormComponent_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 2);
    ɵɵrepeaterCreate(1, FormComponent_Conditional_3_For_2_Template, 2, 9, "button", 5, ɵɵrepeaterTrackByIdentity);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵrepeater(ctx_r1.actionButtons);
  }
}
var _c59 = ["groupItem"];
function GroupToolbarToolComponent_Conditional_0_For_2_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 5)(1, "span", 10);
    ɵɵlistener("click", function GroupToolbarToolComponent_Conditional_0_For_2_Conditional_2_Template_span_click_1_listener($event) {
      ɵɵrestoreView(_r6);
      const column_r3 = ɵɵnextContext().$implicit;
      const ctx_r4 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r4.moveGroupUp(column_r3, $event));
    });
    ɵɵelement(2, "kendo-icon-wrapper", 11);
    ɵɵelementEnd();
    ɵɵelementStart(3, "span", 12);
    ɵɵlistener("click", function GroupToolbarToolComponent_Conditional_0_For_2_Conditional_2_Template_span_click_3_listener($event) {
      ɵɵrestoreView(_r6);
      const column_r3 = ɵɵnextContext().$implicit;
      const ctx_r4 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r4.moveGroupDown(column_r3, $event));
    });
    ɵɵelement(4, "kendo-icon-wrapper", 13);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ɵ$index_4_r4 = ɵɵnextContext().$index;
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵclassProp("k-disabled", ɵ$index_4_r4 === 0);
    ɵɵattribute("aria-disabled", ɵ$index_4_r4 === 0);
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r4.upIcon)("size", ctx_r4.iconSize);
    ɵɵadvance();
    ɵɵclassProp("k-disabled", ɵ$index_4_r4 === ctx_r4.groupedColumns.length - 1);
    ɵɵattribute("aria-disabled", ɵ$index_4_r4 === ctx_r4.groupedColumns.length - 1);
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r4.downIcon)("size", ctx_r4.iconSize);
  }
}
function GroupToolbarToolComponent_Conditional_0_For_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 4, 0);
    ɵɵlistener("keydown", function GroupToolbarToolComponent_Conditional_0_For_2_Template_div_keydown_0_listener($event) {
      const ctx_r1 = ɵɵrestoreView(_r1);
      const column_r3 = ctx_r1.$implicit;
      const ɵ$index_4_r4 = ctx_r1.$index;
      const ctx_r4 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r4.handleGroupedKeydown(column_r3, ɵ$index_4_r4, $event));
    })("focus", function GroupToolbarToolComponent_Conditional_0_For_2_Template_div_focus_0_listener() {
      const ɵ$index_4_r4 = ɵɵrestoreView(_r1).$index;
      const ctx_r4 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r4.onItemFocus(ɵ$index_4_r4, 0));
    });
    ɵɵconditionalCreate(2, GroupToolbarToolComponent_Conditional_0_For_2_Conditional_2_Template, 5, 10, "span", 5);
    ɵɵelementStart(3, "span", 6);
    ɵɵtext(4);
    ɵɵelementEnd();
    ɵɵelement(5, "span", 7);
    ɵɵelementStart(6, "span", 5)(7, "span", 8);
    ɵɵlistener("click", function GroupToolbarToolComponent_Conditional_0_For_2_Template_span_click_7_listener($event) {
      const column_r3 = ɵɵrestoreView(_r1).$implicit;
      const ctx_r4 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r4.removeGroup(column_r3, $event));
    });
    ɵɵelement(8, "kendo-icon-wrapper", 9);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const column_r3 = ctx.$implicit;
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵadvance(2);
    ɵɵconditional(ctx_r4.groupedColumns.length > 1 ? 2 : -1);
    ɵɵadvance(2);
    ɵɵtextInterpolate(column_r3.title || ctx_r4.getColumnComponent(column_r3).field);
    ɵɵadvance(4);
    ɵɵproperty("svgIcon", ctx_r4.removeIcon)("size", ctx_r4.iconSize);
  }
}
function GroupToolbarToolComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 1);
    ɵɵrepeaterCreate(1, GroupToolbarToolComponent_Conditional_0_For_2_Template, 9, 4, "div", 3, ɵɵrepeaterTrackByIdentity);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵrepeater(ctx_r4.groupedColumns);
  }
}
function GroupToolbarToolComponent_Conditional_1_For_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 4, 0);
    ɵɵlistener("keydown", function GroupToolbarToolComponent_Conditional_1_For_2_Template_div_keydown_0_listener($event) {
      const ctx_r7 = ɵɵrestoreView(_r7);
      const column_r9 = ctx_r7.$implicit;
      const ɵ$index_32_r10 = ctx_r7.$index;
      const ctx_r4 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r4.handleUngroupedKeydown(column_r9, ɵ$index_32_r10, $event));
    })("focus", function GroupToolbarToolComponent_Conditional_1_For_2_Template_div_focus_0_listener() {
      const ɵ$index_32_r10 = ɵɵrestoreView(_r7).$index;
      const ctx_r4 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r4.onItemFocus(null, ɵ$index_32_r10));
    });
    ɵɵelementStart(2, "span", 6);
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵelement(4, "span", 7);
    ɵɵelementStart(5, "span", 5)(6, "span", 14);
    ɵɵlistener("click", function GroupToolbarToolComponent_Conditional_1_For_2_Template_span_click_6_listener($event) {
      const column_r9 = ɵɵrestoreView(_r7).$implicit;
      const ctx_r4 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r4.addGroup(column_r9, $event));
    });
    ɵɵelement(7, "kendo-icon-wrapper", 15);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const column_r9 = ctx.$implicit;
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵadvance(3);
    ɵɵtextInterpolate(column_r9.title || ctx_r4.getColumnComponent(column_r9).field);
    ɵɵadvance(4);
    ɵɵproperty("svgIcon", ctx_r4.addIcon)("size", ctx_r4.iconSize);
  }
}
function GroupToolbarToolComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 1);
    ɵɵrepeaterCreate(1, GroupToolbarToolComponent_Conditional_1_For_2_Template, 8, 3, "div", 3, ɵɵrepeaterTrackByIdentity);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵrepeater(ctx_r4.ungroupedColumns);
  }
}
function GroupToolbarToolComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r11 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 2)(1, "button", 16);
    ɵɵlistener("click", function GroupToolbarToolComponent_Conditional_2_Template_button_click_1_listener() {
      ɵɵrestoreView(_r11);
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.clear());
    });
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r4.clearIcon);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r4.ctx == null ? null : ctx_r4.ctx.localization.get("groupClearButton"), " ");
  }
}
var _c60 = ["columnChooserContent"];
var _c61 = ["filterToolbarToolTemplate"];
var _c622 = ["filterMenuContainer"];
var _c632 = (a0, a1) => ({
  "k-adaptive-actionsheet": true,
  "k-actionsheet-fullscreen": a0,
  "k-actionsheet-bottom": a1
});
var _c642 = (a0) => ({
  height: a0
});
var _c652 = (a0) => ({
  transitionend: a0
});
var _c662 = (a0) => ({
  "keydown.escape": a0
});
var _c67 = (a0, a1, a2, a3) => ({
  click: a0,
  "keydown.enter": a1,
  "keydown.space": a2,
  "keydown.tab": a3
});
var _c68 = (a0, a1, a2) => ({
  click: a0,
  "keydown.enter": a1,
  "keydown.space": a2
});
function AdaptiveRendererComponent_Conditional_1_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 21);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const actionSheetHeaderTemplate_r2 = ɵɵreference(11);
    ɵɵproperty("ngTemplateOutlet", actionSheetHeaderTemplate_r2);
  }
}
function AdaptiveRendererComponent_Conditional_1_ng_template_2_For_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-columnmenu-item", 25);
    ɵɵlistener("itemClick", function AdaptiveRendererComponent_Conditional_1_ng_template_2_For_3_Template_kendo_grid_columnmenu_item_itemClick_0_listener() {
      const column_r4 = ɵɵrestoreView(_r3).$implicit;
      const ctx_r4 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r4.sortBy(column_r4));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r4 = ctx.$implicit;
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵproperty("column", ctx_r4.getColumnComponent(column_r4))("text", column_r4.title || ctx_r4.getColumnComponent(column_r4).field);
  }
}
function AdaptiveRendererComponent_Conditional_1_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 22)(1, "div", 23);
    ɵɵrepeaterCreate(2, AdaptiveRendererComponent_Conditional_1_ng_template_2_For_3_Template, 1, 2, "kendo-grid-columnmenu-item", 24, ɵɵrepeaterTrackByIdentity);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵadvance(2);
    ɵɵrepeater(ctx_r4.columns);
  }
}
function AdaptiveRendererComponent_Conditional_1_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 26);
    ɵɵlistener("click", function AdaptiveRendererComponent_Conditional_1_ng_template_3_Template_button_click_0_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r4 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r4.clearSorting());
    });
    ɵɵtext(1);
    ɵɵelementEnd();
    ɵɵelementStart(2, "button", 27);
    ɵɵlistener("click", function AdaptiveRendererComponent_Conditional_1_ng_template_3_Template_button_click_2_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r4 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r4.actionSheet.toggle(false));
    });
    ɵɵtext(3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("svgIcon", ctx_r4.xIcon);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r4.messageFor("sortClearButton"), " ");
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r4.checkIcon);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r4.messageFor("sortDoneButton"), " ");
  }
}
function AdaptiveRendererComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-actionsheet-view");
    ɵɵtemplate(1, AdaptiveRendererComponent_Conditional_1_ng_template_1_Template, 1, 1, "ng-template", 18)(2, AdaptiveRendererComponent_Conditional_1_ng_template_2_Template, 4, 0, "ng-template", 19)(3, AdaptiveRendererComponent_Conditional_1_ng_template_3_Template, 4, 4, "ng-template", 20);
    ɵɵelementEnd();
  }
}
function AdaptiveRendererComponent_Conditional_2_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 21);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const actionSheetHeaderTemplate_r2 = ɵɵreference(11);
    ɵɵproperty("ngTemplateOutlet", actionSheetHeaderTemplate_r2);
  }
}
function AdaptiveRendererComponent_Conditional_2_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-column-chooser-content", 28, 3);
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("columns", ctx_r4.columns)("isLast", true)("autoSync", false)("allowHideAll", false);
  }
}
function AdaptiveRendererComponent_Conditional_2_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 21);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const actionSheetFooterTemplate_r7 = ɵɵreference(13);
    ɵɵproperty("ngTemplateOutlet", actionSheetFooterTemplate_r7);
  }
}
function AdaptiveRendererComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-actionsheet-view");
    ɵɵtemplate(1, AdaptiveRendererComponent_Conditional_2_ng_template_1_Template, 1, 1, "ng-template", 18)(2, AdaptiveRendererComponent_Conditional_2_ng_template_2_Template, 2, 4, "ng-template", 19)(3, AdaptiveRendererComponent_Conditional_2_ng_template_3_Template, 1, 1, "ng-template", 20);
    ɵɵelementEnd();
  }
}
function AdaptiveRendererComponent_Conditional_3_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 21);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const actionSheetHeaderTemplate_r2 = ɵɵreference(11);
    ɵɵproperty("ngTemplateOutlet", actionSheetHeaderTemplate_r2);
  }
}
function AdaptiveRendererComponent_Conditional_3_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 22);
    ɵɵelement(1, "kendo-filter-toolbar-tool");
    ɵɵelementEnd();
  }
}
function AdaptiveRendererComponent_Conditional_3_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 29);
    ɵɵlistener("click", function AdaptiveRendererComponent_Conditional_3_ng_template_3_Template_button_click_0_listener() {
      ɵɵrestoreView(_r8);
      const ctx_r4 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r4.clearFilters());
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("svgIcon", ctx_r4.filterClearIcon);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r4.messageFor("filterClearAllButton"), " ");
  }
}
function AdaptiveRendererComponent_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-actionsheet-view", 17);
    ɵɵtemplate(1, AdaptiveRendererComponent_Conditional_3_ng_template_1_Template, 1, 1, "ng-template", 18)(2, AdaptiveRendererComponent_Conditional_3_ng_template_2_Template, 2, 0, "ng-template", 19)(3, AdaptiveRendererComponent_Conditional_3_ng_template_3_Template, 2, 2, "ng-template", 20);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction1(2, _c652, ctx_r4.onAnimationEnd))("scope", ctx_r4);
  }
}
function AdaptiveRendererComponent_Conditional_4_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 21);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const actionSheetHeaderTemplate_r2 = ɵɵreference(11);
    ɵɵproperty("ngTemplateOutlet", actionSheetHeaderTemplate_r2);
  }
}
function AdaptiveRendererComponent_Conditional_4_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, null, 4);
  }
}
function AdaptiveRendererComponent_Conditional_4_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 21);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const filterFooterButtons_r9 = ɵɵreference(15);
    ɵɵproperty("ngTemplateOutlet", filterFooterButtons_r9);
  }
}
function AdaptiveRendererComponent_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-actionsheet-view");
    ɵɵtemplate(1, AdaptiveRendererComponent_Conditional_4_ng_template_1_Template, 1, 1, "ng-template", 18)(2, AdaptiveRendererComponent_Conditional_4_ng_template_2_Template, 2, 0, "ng-template", 19)(3, AdaptiveRendererComponent_Conditional_4_ng_template_3_Template, 1, 1, "ng-template", 20);
    ɵɵelementEnd();
  }
}
function AdaptiveRendererComponent_Conditional_5_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 21);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const actionSheetHeaderTemplate_r2 = ɵɵreference(11);
    ɵɵproperty("ngTemplateOutlet", actionSheetHeaderTemplate_r2);
  }
}
function AdaptiveRendererComponent_Conditional_5_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-filter-menu-container", 30, 5);
    ɵɵlistener("close", function AdaptiveRendererComponent_Conditional_5_ng_template_2_Template_kendo_grid_filter_menu_container_close_0_listener() {
      ɵɵrestoreView(_r10);
      const ctx_r4 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r4.close());
    })("keydown.enter", function AdaptiveRendererComponent_Conditional_5_ng_template_2_Template_kendo_grid_filter_menu_container_keydown_enter_0_listener($event) {
      ɵɵrestoreView(_r10);
      return ɵɵresetView($event.stopImmediatePropagation());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("column", ctx_r4.adaptiveGridService.column)("filter", ctx_r4.ctx.grid.filter);
  }
}
function AdaptiveRendererComponent_Conditional_5_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 21);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const filterFooterButtons_r9 = ɵɵreference(15);
    ɵɵproperty("ngTemplateOutlet", filterFooterButtons_r9);
  }
}
function AdaptiveRendererComponent_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-actionsheet-view");
    ɵɵtemplate(1, AdaptiveRendererComponent_Conditional_5_ng_template_1_Template, 1, 1, "ng-template", 18)(2, AdaptiveRendererComponent_Conditional_5_ng_template_2_Template, 2, 2, "ng-template", 19)(3, AdaptiveRendererComponent_Conditional_5_ng_template_3_Template, 1, 1, "ng-template", 20);
    ɵɵelementEnd();
  }
}
function AdaptiveRendererComponent_Conditional_6_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 21);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const actionSheetHeaderTemplate_r2 = ɵɵreference(11);
    ɵɵproperty("ngTemplateOutlet", actionSheetHeaderTemplate_r2);
  }
}
function AdaptiveRendererComponent_Conditional_6_ng_template_2_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-sort", 31, 6);
  }
  if (rf & 2) {
    const sortItem_r11 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵproperty("kendoGridColumnMenuItem", sortItem_r11)("service", ctx_r4.adaptiveGridService.columnMenuService);
  }
}
function AdaptiveRendererComponent_Conditional_6_ng_template_2_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-lock", 31, 7);
  }
  if (rf & 2) {
    const lockItem_r12 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵproperty("kendoGridColumnMenuItem", lockItem_r12)("service", ctx_r4.adaptiveGridService.columnMenuService);
  }
}
function AdaptiveRendererComponent_Conditional_6_ng_template_2_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-stick", 31, 8);
  }
  if (rf & 2) {
    const stickItem_r13 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵproperty("kendoGridColumnMenuItem", stickItem_r13)("service", ctx_r4.adaptiveGridService.columnMenuService);
  }
}
function AdaptiveRendererComponent_Conditional_6_ng_template_2_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r14 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-columnmenu-position", 37, 9);
    ɵɵlistener("collapse", function AdaptiveRendererComponent_Conditional_6_ng_template_2_Conditional_5_Template_kendo_grid_columnmenu_position_collapse_0_listener() {
      ɵɵrestoreView(_r14);
      const ctx_r4 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r4.navigateToPositionView());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const positionItem_r15 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵproperty("showLock", ctx_r4.hasLock)("showStick", ctx_r4.hasStick)("kendoGridColumnMenuItem", positionItem_r15)("service", ctx_r4.adaptiveGridService.columnMenuService)("expanded", false);
  }
}
function AdaptiveRendererComponent_Conditional_6_ng_template_2_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 38);
  }
  if (rf & 2) {
    ɵɵstyleProp("border-color", "rgba(0, 0, 0, 0.08)");
  }
}
function AdaptiveRendererComponent_Conditional_6_ng_template_2_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r16 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-columnmenu-chooser", 39, 10);
    ɵɵlistener("collapse", function AdaptiveRendererComponent_Conditional_6_ng_template_2_Conditional_7_Template_kendo_grid_columnmenu_chooser_collapse_0_listener() {
      ɵɵrestoreView(_r16);
      const ctx_r4 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r4.navigateToColumnsView());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const chooserItem_r17 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵproperty("kendoGridColumnMenuItem", chooserItem_r17)("service", ctx_r4.adaptiveGridService.columnMenuService)("expanded", false);
  }
}
function AdaptiveRendererComponent_Conditional_6_ng_template_2_Conditional_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-autosize-column", 35, 11);
  }
  if (rf & 2) {
    const autoSizeColumnItem_r18 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵproperty("service", ctx_r4.adaptiveGridService.columnMenuService)("kendoGridColumnMenuItem", autoSizeColumnItem_r18)("column", ctx_r4.adaptiveGridService.column);
  }
}
function AdaptiveRendererComponent_Conditional_6_ng_template_2_Conditional_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-autosize-all-columns", 36, 12);
  }
  if (rf & 2) {
    const autoSizeAllColumnsItem_r19 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵproperty("service", ctx_r4.adaptiveGridService.columnMenuService)("kendoGridColumnMenuItem", autoSizeAllColumnsItem_r19);
  }
}
function AdaptiveRendererComponent_Conditional_6_ng_template_2_Conditional_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 38);
  }
  if (rf & 2) {
    ɵɵstyleProp("border-color", "rgba(0, 0, 0, 0.08)");
  }
}
function AdaptiveRendererComponent_Conditional_6_ng_template_2_Conditional_11_Template(rf, ctx) {
  if (rf & 1) {
    const _r20 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-columnmenu-filter", 39, 13);
    ɵɵlistener("collapse", function AdaptiveRendererComponent_Conditional_6_ng_template_2_Conditional_11_Template_kendo_grid_columnmenu_filter_collapse_0_listener() {
      ɵɵrestoreView(_r20);
      const ctx_r4 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r4.navigateToFilterView());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const filterItem_r21 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵproperty("kendoGridColumnMenuItem", filterItem_r21)("service", ctx_r4.adaptiveGridService.columnMenuService)("expanded", false);
  }
}
function AdaptiveRendererComponent_Conditional_6_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 22)(1, "kendo-grid-columnmenu-container");
    ɵɵconditionalCreate(2, AdaptiveRendererComponent_Conditional_6_ng_template_2_Conditional_2_Template, 2, 2, "kendo-grid-columnmenu-sort", 31);
    ɵɵconditionalCreate(3, AdaptiveRendererComponent_Conditional_6_ng_template_2_Conditional_3_Template, 2, 2, "kendo-grid-columnmenu-lock", 31);
    ɵɵconditionalCreate(4, AdaptiveRendererComponent_Conditional_6_ng_template_2_Conditional_4_Template, 2, 2, "kendo-grid-columnmenu-stick", 31);
    ɵɵconditionalCreate(5, AdaptiveRendererComponent_Conditional_6_ng_template_2_Conditional_5_Template, 2, 5, "kendo-grid-columnmenu-position", 32);
    ɵɵconditionalCreate(6, AdaptiveRendererComponent_Conditional_6_ng_template_2_Conditional_6_Template, 1, 2, "span", 33);
    ɵɵconditionalCreate(7, AdaptiveRendererComponent_Conditional_6_ng_template_2_Conditional_7_Template, 2, 3, "kendo-grid-columnmenu-chooser", 34);
    ɵɵconditionalCreate(8, AdaptiveRendererComponent_Conditional_6_ng_template_2_Conditional_8_Template, 2, 3, "kendo-grid-columnmenu-autosize-column", 35);
    ɵɵconditionalCreate(9, AdaptiveRendererComponent_Conditional_6_ng_template_2_Conditional_9_Template, 2, 2, "kendo-grid-columnmenu-autosize-all-columns", 36);
    ɵɵconditionalCreate(10, AdaptiveRendererComponent_Conditional_6_ng_template_2_Conditional_10_Template, 1, 2, "span", 33);
    ɵɵconditionalCreate(11, AdaptiveRendererComponent_Conditional_6_ng_template_2_Conditional_11_Template, 2, 3, "kendo-grid-columnmenu-filter", 34);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵadvance(2);
    ɵɵconditional(ctx_r4.hasSort ? 2 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r4.hasLock && !ctx_r4.hasPosition ? 3 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r4.hasStick && !ctx_r4.hasPosition ? 4 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r4.hasPosition ? 5 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r4.hasLock || ctx_r4.hasStick || ctx_r4.adaptiveGridService.column.sortable ? 6 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r4.hasColumnChooser ? 7 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r4.hasAutoSizeColumn ? 8 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r4.hasAutoSizeAllColumns ? 9 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r4.adaptiveGridService.column.filterable ? 10 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r4.hasFilter ? 11 : -1);
  }
}
function AdaptiveRendererComponent_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-actionsheet-view", 17);
    ɵɵtemplate(1, AdaptiveRendererComponent_Conditional_6_ng_template_1_Template, 1, 1, "ng-template", 18)(2, AdaptiveRendererComponent_Conditional_6_ng_template_2_Template, 12, 10, "ng-template", 19);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction1(2, _c652, ctx_r4.onAnimationEnd))("scope", ctx_r4);
  }
}
function AdaptiveRendererComponent_Conditional_7_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 21);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const actionSheetHeaderTemplate_r2 = ɵɵreference(11);
    ɵɵproperty("ngTemplateOutlet", actionSheetHeaderTemplate_r2);
  }
}
function AdaptiveRendererComponent_Conditional_7_ng_template_2_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-column-chooser-content", 28, 3);
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵproperty("columns", ctx_r4.adaptiveGridService.columns)("isLast", true)("autoSync", false)("allowHideAll", false);
  }
}
function AdaptiveRendererComponent_Conditional_7_ng_template_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r22 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-filter-menu-container", 42);
    ɵɵlistener("close", function AdaptiveRendererComponent_Conditional_7_ng_template_2_Conditional_1_Template_kendo_grid_filter_menu_container_close_0_listener() {
      ɵɵrestoreView(_r22);
      const ctx_r4 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r4.close());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵproperty("column", ctx_r4.adaptiveGridService.column)("filter", ctx_r4.ctx.grid.filter)("kendoEventsOutsideAngular", ɵɵpureFunction1(4, _c662, ctx_r4.close))("scope", ctx_r4);
  }
}
function AdaptiveRendererComponent_Conditional_7_ng_template_2_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-lock", 41);
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵproperty("service", ctx_r4.adaptiveGridService.columnMenuService);
  }
}
function AdaptiveRendererComponent_Conditional_7_ng_template_2_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-stick", 41);
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵproperty("service", ctx_r4.adaptiveGridService.columnMenuService);
  }
}
function AdaptiveRendererComponent_Conditional_7_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, AdaptiveRendererComponent_Conditional_7_ng_template_2_Conditional_0_Template, 2, 4, "kendo-grid-column-chooser-content", 28);
    ɵɵconditionalCreate(1, AdaptiveRendererComponent_Conditional_7_ng_template_2_Conditional_1_Template, 1, 6, "kendo-grid-filter-menu-container", 40);
    ɵɵconditionalCreate(2, AdaptiveRendererComponent_Conditional_7_ng_template_2_Conditional_2_Template, 1, 1, "kendo-grid-columnmenu-lock", 41);
    ɵɵconditionalCreate(3, AdaptiveRendererComponent_Conditional_7_ng_template_2_Conditional_3_Template, 1, 1, "kendo-grid-columnmenu-stick", 41);
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵconditional(ctx_r4.adaptiveGridService.secondaryView === "columnChooser" ? 0 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r4.adaptiveGridService.secondaryView === "columnFilter" ? 1 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r4.adaptiveGridService.secondaryView === "columnPosition" && ctx_r4.hasLock ? 2 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r4.adaptiveGridService.secondaryView === "columnPosition" && ctx_r4.hasStick ? 3 : -1);
  }
}
function AdaptiveRendererComponent_Conditional_7_Conditional_3_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 21);
  }
  if (rf & 2) {
    ɵɵnextContext(3);
    const actionSheetFooterTemplate_r7 = ɵɵreference(13);
    ɵɵproperty("ngTemplateOutlet", actionSheetFooterTemplate_r7);
  }
}
function AdaptiveRendererComponent_Conditional_7_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, AdaptiveRendererComponent_Conditional_7_Conditional_3_ng_template_0_Template, 1, 1, "ng-template", 20);
  }
}
function AdaptiveRendererComponent_Conditional_7_Conditional_4_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 21);
  }
  if (rf & 2) {
    ɵɵnextContext(3);
    const filterFooterButtons_r9 = ɵɵreference(15);
    ɵɵproperty("ngTemplateOutlet", filterFooterButtons_r9);
  }
}
function AdaptiveRendererComponent_Conditional_7_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, AdaptiveRendererComponent_Conditional_7_Conditional_4_ng_template_0_Template, 1, 1, "ng-template", 20);
  }
}
function AdaptiveRendererComponent_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-actionsheet-view");
    ɵɵtemplate(1, AdaptiveRendererComponent_Conditional_7_ng_template_1_Template, 1, 1, "ng-template", 18)(2, AdaptiveRendererComponent_Conditional_7_ng_template_2_Template, 4, 4, "ng-template", 19);
    ɵɵconditionalCreate(3, AdaptiveRendererComponent_Conditional_7_Conditional_3_Template, 1, 0, null, 20);
    ɵɵconditionalCreate(4, AdaptiveRendererComponent_Conditional_7_Conditional_4_Template, 1, 0, null, 20);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵadvance(3);
    ɵɵconditional(ctx_r4.adaptiveGridService.secondaryView === "columnChooser" ? 3 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r4.adaptiveGridService.secondaryView === "columnFilter" ? 4 : -1);
  }
}
function AdaptiveRendererComponent_Conditional_8_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 21);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const actionSheetHeaderTemplate_r2 = ɵɵreference(11);
    ɵɵproperty("ngTemplateOutlet", actionSheetHeaderTemplate_r2);
  }
}
function AdaptiveRendererComponent_Conditional_8_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-external-form", 43);
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("controls", ctx_r4.externalEditingSettings.formControls)("formGroup", ctx_r4.externalEditingSettings.formGroup)("formSettings", ctx_r4.externalEditingSettings.formSettings)("actionButtons", false);
  }
}
function AdaptiveRendererComponent_Conditional_8_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r23 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 44);
    ɵɵlistener("click", function AdaptiveRendererComponent_Conditional_8_ng_template_3_Template_button_click_0_listener() {
      ɵɵrestoreView(_r23);
      const ctx_r4 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r4.actionSheet.toggle(false));
    });
    ɵɵtext(1);
    ɵɵelementEnd();
    ɵɵelementStart(2, "button", 45);
    ɵɵlistener("click", function AdaptiveRendererComponent_Conditional_8_ng_template_3_Template_button_click_2_listener() {
      ɵɵrestoreView(_r23);
      const ctx_r4 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r4.saveEditing());
    });
    ɵɵtext(3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("svgIcon", ctx_r4.cancelIcon);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r4.messageFor("externalEditingCancelText"), " ");
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r4.saveIcon)("disabled", !ctx_r4.externalEditingSettings.formGroup.valid);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r4.messageFor("externalEditingSaveText"), " ");
  }
}
function AdaptiveRendererComponent_Conditional_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-actionsheet-view");
    ɵɵtemplate(1, AdaptiveRendererComponent_Conditional_8_ng_template_1_Template, 1, 1, "ng-template", 18)(2, AdaptiveRendererComponent_Conditional_8_ng_template_2_Template, 1, 4, "ng-template", 19)(3, AdaptiveRendererComponent_Conditional_8_ng_template_3_Template, 4, 5, "ng-template", 20);
    ɵɵelementEnd();
  }
}
function AdaptiveRendererComponent_Conditional_9_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 21);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const actionSheetHeaderTemplate_r2 = ɵɵreference(11);
    ɵɵproperty("ngTemplateOutlet", actionSheetHeaderTemplate_r2);
  }
}
function AdaptiveRendererComponent_Conditional_9_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-group-toolbar-tool", 46);
  }
  if (rf & 2) {
    ɵɵproperty("adaptive", true);
  }
}
function AdaptiveRendererComponent_Conditional_9_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r24 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 26);
    ɵɵlistener("click", function AdaptiveRendererComponent_Conditional_9_ng_template_3_Template_button_click_0_listener() {
      ɵɵrestoreView(_r24);
      const ctx_r4 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r4.clearGrouping());
    });
    ɵɵtext(1);
    ɵɵelementEnd();
    ɵɵelementStart(2, "button", 27);
    ɵɵlistener("click", function AdaptiveRendererComponent_Conditional_9_ng_template_3_Template_button_click_2_listener() {
      ɵɵrestoreView(_r24);
      const ctx_r4 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r4.actionSheet.toggle(false));
    });
    ɵɵtext(3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("svgIcon", ctx_r4.xIcon);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r4.messageFor("groupClearButton"), " ");
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r4.checkIcon);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r4.messageFor("groupDoneButton"), " ");
  }
}
function AdaptiveRendererComponent_Conditional_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-actionsheet-view");
    ɵɵtemplate(1, AdaptiveRendererComponent_Conditional_9_ng_template_1_Template, 1, 1, "ng-template", 18)(2, AdaptiveRendererComponent_Conditional_9_ng_template_2_Template, 1, 1, "ng-template", 19)(3, AdaptiveRendererComponent_Conditional_9_ng_template_3_Template, 4, 4, "ng-template", 20);
    ɵɵelementEnd();
  }
}
function AdaptiveRendererComponent_ng_template_10_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r25 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 48)(1, "button", 52);
    ɵɵlistener("click", function AdaptiveRendererComponent_ng_template_10_Conditional_1_Template_button_click_1_listener() {
      ɵɵrestoreView(_r25);
      const ctx_r4 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r4.prevView());
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r4.chevronLeft)("title", ctx_r4.messageFor("adaptiveBackButtonTitle"));
  }
}
function AdaptiveRendererComponent_ng_template_10_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 50);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r4.actionSheetTitle, " ");
  }
}
function AdaptiveRendererComponent_ng_template_10_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 51);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r4.messageFor("columnsSubtitle"), " ");
  }
}
function AdaptiveRendererComponent_ng_template_10_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r26 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 48)(1, "button", 53);
    ɵɵlistener("click", function AdaptiveRendererComponent_ng_template_10_Conditional_5_Template_button_click_1_listener() {
      ɵɵrestoreView(_r26);
      const ctx_r4 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r4.close());
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r4.xIcon)("title", ctx_r4.messageFor("adaptiveCloseButtonTitle"));
  }
}
function AdaptiveRendererComponent_ng_template_10_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r27 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 48)(1, "button", 54);
    ɵɵlistener("click", function AdaptiveRendererComponent_ng_template_10_Conditional_6_Template_button_click_1_listener() {
      ɵɵrestoreView(_r27);
      const ctx_r4 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r4.actionSheet.toggle(false));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r4.checkIcon)("title", ctx_r4.messageFor("adaptiveCloseButtonTitle"));
  }
}
function AdaptiveRendererComponent_ng_template_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 47);
    ɵɵconditionalCreate(1, AdaptiveRendererComponent_ng_template_10_Conditional_1_Template, 2, 2, "div", 48);
    ɵɵelementStart(2, "div", 49);
    ɵɵconditionalCreate(3, AdaptiveRendererComponent_ng_template_10_Conditional_3_Template, 2, 1, "div", 50);
    ɵɵconditionalCreate(4, AdaptiveRendererComponent_ng_template_10_Conditional_4_Template, 2, 1, "div", 51);
    ɵɵelementEnd();
    ɵɵconditionalCreate(5, AdaptiveRendererComponent_ng_template_10_Conditional_5_Template, 2, 2, "div", 48);
    ɵɵconditionalCreate(6, AdaptiveRendererComponent_ng_template_10_Conditional_6_Template, 2, 2, "div", 48);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵconditional(ctx_r4.adaptiveGridService.secondaryView ? 1 : -1);
    ɵɵadvance(2);
    ɵɵconditional(ctx_r4.hasTitle ? 3 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r4.hasSubtitle ? 4 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r4.hasXCloseIcon ? 5 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r4.hasCheckCloseIcon ? 6 : -1);
  }
}
function AdaptiveRendererComponent_ng_template_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "button", 55, 14);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelementStart(3, "button", 56, 15);
    ɵɵtext(5);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵproperty("svgIcon", ctx_r4.arrowRotateCcwIcon)("kendoEventsOutsideAngular", ɵɵpureFunction4(8, _c67, ctx_r4.cancelChanges, ctx_r4.cancelChanges, ctx_r4.cancelChanges, ctx_r4.onTab))("scope", ctx_r4);
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r4.messageFor("columnsReset"), " ");
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r4.checkIcon)("kendoEventsOutsideAngular", ɵɵpureFunction3(13, _c68, ctx_r4.applyChanges, ctx_r4.applyChanges, ctx_r4.applyChanges))("scope", ctx_r4);
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r4.messageFor("columnsApply"), " ");
  }
}
function AdaptiveRendererComponent_ng_template_14_Template(rf, ctx) {
  if (rf & 1) {
    const _r28 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 57);
    ɵɵlistener("click", function AdaptiveRendererComponent_ng_template_14_Template_button_click_0_listener() {
      ɵɵrestoreView(_r28);
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.adaptiveGridService.resetFilter());
    });
    ɵɵtext(1);
    ɵɵelementEnd();
    ɵɵelementStart(2, "button", 58);
    ɵɵlistener("click", function AdaptiveRendererComponent_ng_template_14_Template_button_click_2_listener() {
      ɵɵrestoreView(_r28);
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.adaptiveGridService.submitFilter());
    });
    ɵɵtext(3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r4.messageFor("filterClearButton"), " ");
    ɵɵadvance();
    ɵɵproperty("disabled", ctx_r4.adaptiveGridService.filterMenuContainer.disabled);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r4.messageFor("filterFilterButton"), " ");
  }
}
var _c69 = ["lockedHeader"];
var _c70 = ["header"];
var _c71 = ["ariaRoot"];
var _c722 = ["dialogContainer"];
var _c732 = ["windowContainer"];
var _c742 = ["footer"];
var _c752 = [[["kendo-toolbar"]]];
var _c76 = ["kendo-toolbar"];
var _c77 = (a0) => ({
  hintTemplate: a0
});
function GridComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-toolbar", 12);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("size", ctx_r1.size)("navigable", ctx_r1.navigation.toolbarEnabled);
    ɵɵattribute("aria-label", ctx_r1.messageFor("topToolbarLabel"))("aria-controls", ctx_r1.ariaRootId);
  }
}
function GridComponent_Conditional_4_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 25);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const topPager_r4 = ɵɵreference(1);
    const ctx_r1 = ɵɵnextContext();
    const defaultPager_r5 = ɵɵreference(17);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.pagerTemplate ? ctx_r1.pagerTemplate == null ? null : ctx_r1.pagerTemplate.templateRef : defaultPager_r5)("ngTemplateOutletContext", topPager_r4.templateContext);
  }
}
function GridComponent_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-pager", 22, 5);
    ɵɵlistener("pageChange", function GridComponent_Conditional_4_Template_kendo_pager_pageChange_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.notifyPageChange("pager", $event));
    })("pagerInputVisibilityChange", function GridComponent_Conditional_4_Template_kendo_pager_pagerInputVisibilityChange_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handlePagerVisibilityChange("showPagerInput", $event));
    })("pageTextVisibilityChange", function GridComponent_Conditional_4_Template_kendo_pager_pageTextVisibilityChange_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handlePagerVisibilityChange("showPagerPageText", $event));
    })("itemsTextVisibilityChange", function GridComponent_Conditional_4_Template_kendo_pager_itemsTextVisibilityChange_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handlePagerVisibilityChange("showPagerItemsText", $event));
    });
    ɵɵtemplate(2, GridComponent_Conditional_4_ng_template_2_Template, 1, 2, "ng-template", 23);
    ɵɵelement(3, "kendo-pager-messages", 24);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("navigable", ctx_r1.navigation.pagerEnabled)("pageSize", ctx_r1.pageSize)("total", ctx_r1.view.total)("skip", ctx_r1.skip)("size", ctx_r1.size)("responsive", ctx_r1.normalizedPageableSettings.responsive && !ctx_r1.pagerTemplate)("buttonCount", ctx_r1.normalizedPageableSettings.buttonCount)("info", ctx_r1.normalizedPageableSettings.info)("pageSizeValues", ctx_r1.normalizedPageableSettings.pageSizes)("previousNext", ctx_r1.normalizedPageableSettings.previousNext)("type", ctx_r1.normalizedPageableSettings.type);
    ɵɵadvance(3);
    ɵɵproperty("ariaLabel", ctx_r1.messageFor("pagerLabel"))("firstPage", ctx_r1.messageFor("pagerFirstPage"))("inputLabel", ctx_r1.messageFor("pagerInputLabel"))("previousPage", ctx_r1.messageFor("pagerPreviousPage"))("nextPage", ctx_r1.messageFor("pagerNextPage"))("lastPage", ctx_r1.messageFor("pagerLastPage"))("selectPage", ctx_r1.messageFor("pagerSelectPage"))("page", ctx_r1.messageFor("pagerPage"))("itemsPerPage", ctx_r1.messageFor("pagerItemsPerPage"))("items", ctx_r1.messageFor("pagerItems"))("of", ctx_r1.messageFor("pagerOf"))("pageNumberInputTitle", ctx_r1.messageFor("pagerPageNumberInputTitle"));
  }
}
function GridComponent_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-group-panel", 26);
    ɵɵlistener("change", function GridComponent_Conditional_5_Template_kendo_grid_group_panel_change_0_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.groupChange.emit($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("navigable", ctx_r1.navigation.toolbarEnabled)("text", ctx_r1.groupableEmptyText)("groups", ctx_r1.group);
    ɵɵattribute("aria-label", ctx_r1.messageFor("groupPanelLabel"))("aria-controls", ctx_r1.ariaRootId);
  }
}
function GridComponent_Conditional_8_Conditional_0_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 37, 7)(2, "table", 38);
    ɵɵelement(3, "colgroup", 34)(4, "thead", 39);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵstyleProp("width", ctx_r1.lockedWidth, "px");
    ɵɵadvance(2);
    ɵɵstyleProp("width", ctx_r1.lockedWidth, "px");
    ɵɵproperty("locked", true)("size", ctx_r1.size);
    ɵɵadvance();
    ɵɵproperty("columns", ctx_r1.lockedLeafColumns)("groups", ctx_r1.group)("detailTemplate", ctx_r1.detailTemplate);
    ɵɵadvance();
    ɵɵproperty("resizable", ctx_r1.resizable)("scrollable", true)("columns", ctx_r1.lockedColumns)("totalColumnLevels", ctx_r1.totalColumnLevels)("sort", ctx_r1.sort)("groups", ctx_r1.group)("filter", ctx_r1.filter)("filterable", ctx_r1.filterable)("groupable", ctx_r1.showGroupPanel)("reorderable", ctx_r1.reorderable)("sortable", ctx_r1.sortable)("columnMenu", ctx_r1.columnMenuOptions)("columnMenuTemplate", ctx_r1.columnMenuTemplate)("totalColumnsCount", ctx_r1.leafColumns.length)("totalColumns", ctx_r1.columnsContainer)("detailTemplate", ctx_r1.detailTemplate)("tabIndex", ctx_r1.navigation.tableEnabled ? "-1" : "0");
  }
}
function GridComponent_Conditional_8_Conditional_0_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 36);
    ɵɵelement(1, "div");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵstyleProp("width", ctx_r1.columnsContainer.unlockedWidth, "px");
  }
}
function GridComponent_Conditional_8_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 30);
    ɵɵconditionalCreate(1, GridComponent_Conditional_8_Conditional_0_Conditional_1_Template, 5, 26, "div", 31);
    ɵɵelementStart(2, "div", 32, 6)(4, "table", 33);
    ɵɵelement(5, "colgroup", 34)(6, "thead", 35);
    ɵɵelementEnd();
    ɵɵconditionalCreate(7, GridComponent_Conditional_8_Conditional_0_Conditional_7_Template, 2, 2, "div", 36);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵstyleProp("padding", ctx_r1.headerPadding);
    ɵɵclassProp("k-grid-draggable-header", ctx_r1.groupable || ctx_r1.reorderable);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.isLocked ? 1 : -1);
    ɵɵadvance();
    ɵɵproperty("kendoGridResizableContainer", ctx_r1.lockedLeafColumns.length > 0)("lockedWidth", ctx_r1.lockedWidth + ctx_r1.scrollbarWidth + 2);
    ɵɵadvance(2);
    ɵɵstyleProp("width", ctx_r1.nonLockedWidth, "px");
    ɵɵproperty("virtualColumns", ctx_r1.virtualColumns)("size", ctx_r1.size);
    ɵɵadvance();
    ɵɵproperty("columns", ctx_r1.headerLeafColumns)("groups", ctx_r1.isLocked ? ɵɵpureFunction0(33, _c532) : ctx_r1.group)("detailTemplate", ctx_r1.detailTemplate);
    ɵɵadvance();
    ɵɵproperty("resizable", ctx_r1.resizable)("scrollable", true)("columns", ctx_r1.headerColumns)("totalColumnLevels", ctx_r1.totalColumnLevels)("sort", ctx_r1.sort)("filter", ctx_r1.filter)("filterable", ctx_r1.filterable)("groupable", ctx_r1.showGroupPanel)("reorderable", ctx_r1.reorderable)("groups", ctx_r1.isLocked ? ɵɵpureFunction0(34, _c532) : ctx_r1.group)("sortable", ctx_r1.sortable)("columnMenu", ctx_r1.columnMenuOptions)("columnMenuTemplate", ctx_r1.columnMenuTemplate)("lockedColumnsCount", ctx_r1.lockedLeafColumns.length)("totalColumnsCount", ctx_r1.leafColumns.length)("totalColumns", ctx_r1.columnsContainer)("detailTemplate", ctx_r1.detailTemplate)("tabIndex", ctx_r1.navigation.tableEnabled ? "-1" : "0");
    ɵɵadvance();
    ɵɵconditional(ctx_r1.virtualColumns ? 7 : -1);
  }
}
function GridComponent_Conditional_8_Conditional_2_Conditional_1_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "colgroup", 34);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵproperty("columns", ctx_r1.lockedLeafColumns)("groups", ctx_r1.group)("detailTemplate", ctx_r1.detailTemplate);
  }
}
function GridComponent_Conditional_8_Conditional_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 45)(1, "table", 46);
    ɵɵconditionalCreate(2, GridComponent_Conditional_8_Conditional_2_Conditional_1_Conditional_2_Template, 1, 3, "colgroup", 34);
    ɵɵelement(3, "tfoot", 47);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵstyleProp("width", ctx_r1.lockedWidth, "px");
    ɵɵadvance();
    ɵɵstyleProp("width", ctx_r1.lockedWidth, "px");
    ɵɵproperty("locked", true)("size", ctx_r1.size);
    ɵɵadvance();
    ɵɵconditional(!ctx_r1.isStacked ? 2 : -1);
    ɵɵadvance();
    ɵɵproperty("scrollable", true)("groups", ctx_r1.group)("columns", ctx_r1.lockedLeafColumns)("detailTemplate", ctx_r1.detailTemplate)("logicalRowIndex", ctx_r1.ariaRowCount)("totalColumns", ctx_r1.columnsContainer)("totalColumnsCount", ctx_r1.leafColumns.length);
  }
}
function GridComponent_Conditional_8_Conditional_2_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "colgroup", 34);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵproperty("columns", ctx_r1.headerLeafColumns)("groups", ctx_r1.isLocked ? ɵɵpureFunction0(3, _c532) : ctx_r1.group)("detailTemplate", ctx_r1.detailTemplate);
  }
}
function GridComponent_Conditional_8_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 40);
    ɵɵconditionalCreate(1, GridComponent_Conditional_8_Conditional_2_Conditional_1_Template, 4, 14, "div", 41);
    ɵɵelementStart(2, "div", 42, 8)(4, "table", 43);
    ɵɵconditionalCreate(5, GridComponent_Conditional_8_Conditional_2_Conditional_5_Template, 1, 4, "colgroup", 34);
    ɵɵelement(6, "tfoot", 44);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵstyleProp("padding", ctx_r1.headerPadding);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.lockedLeafColumns.length && !ctx_r1.isStacked ? 1 : -1);
    ɵɵadvance();
    ɵɵproperty("kendoGridResizableContainer", ctx_r1.lockedLeafColumns.length > 0 && !ctx_r1.isStacked)("lockedWidth", ctx_r1.lockedWidth + ctx_r1.scrollbarWidth + 3);
    ɵɵadvance(2);
    ɵɵstyleProp("width", ctx_r1.nonLockedWidth, "px");
    ɵɵproperty("size", ctx_r1.size);
    ɵɵadvance();
    ɵɵconditional(!ctx_r1.isStacked ? 5 : -1);
    ɵɵadvance();
    ɵɵproperty("logicalRowIndex", ctx_r1.ariaRowCount)("scrollable", true)("groups", ctx_r1.isLocked ? ɵɵpureFunction0(17, _c532) : ctx_r1.group)("columns", ctx_r1.headerColumns)("lockedColumnsCount", ctx_r1.isStacked ? 0 : ctx_r1.lockedLeafColumns.length)("detailTemplate", ctx_r1.detailTemplate)("totalColumns", ctx_r1.columnsContainer)("totalColumnsCount", ctx_r1.leafColumns.length);
  }
}
function GridComponent_Conditional_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵconditionalCreate(0, GridComponent_Conditional_8_Conditional_0_Template, 8, 35, "div", 27);
    ɵɵelementStart(1, "kendo-grid-list", 28);
    ɵɵlistener("pageChange", function GridComponent_Conditional_8_Template_kendo_grid_list_pageChange_1_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.notifyPageChange("list", $event));
    })("scrollBottom", function GridComponent_Conditional_8_Template_kendo_grid_list_scrollBottom_1_listener() {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.notifyScrollBottom());
    })("contentScroll", function GridComponent_Conditional_8_Template_kendo_grid_list_contentScroll_1_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.contentScroll.emit($event));
    });
    ɵɵelementEnd();
    ɵɵconditionalCreate(2, GridComponent_Conditional_8_Conditional_2_Template, 7, 18, "div", 29);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵconditional(!ctx_r1.hideHeader && !ctx_r1.isStacked ? 0 : -1);
    ɵɵadvance();
    ɵɵproperty("data", ctx_r1.view)("rowHeight", ctx_r1.rowHeight)("detailRowHeight", ctx_r1.detailRowHeight)("total", ctx_r1.totalCount)("take", ctx_r1.pageSize)("groups", ctx_r1.group)("groupable", ctx_r1.groupable)("skip", ctx_r1.skip)("trackBy", ctx_r1.trackBy)("columns", ctx_r1.columnsContainer)("selectable", ctx_r1.selectable)("filterable", ctx_r1.filterable)("detailTemplate", ctx_r1.detailTemplate)("noRecordsTemplate", ctx_r1.noRecordsTemplate)("size", ctx_r1.size)("rowClass", ctx_r1.rowClass)("rowSticky", ctx_r1.rowSticky)("loading", ctx_r1.loading)("isVirtual", ctx_r1.isVirtual)("cellLoadingTemplate", ctx_r1.cellLoadingTemplate == null ? null : ctx_r1.cellLoadingTemplate.templateRef)("loadingTemplate", ctx_r1.loadingTemplate == null ? null : ctx_r1.loadingTemplate.templateRef)("virtualColumns", ctx_r1.virtualColumns)("enableDrag", ctx_r1.marqueeSelection)("sort", ctx_r1.sort);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.showFooter ? 2 : -1);
  }
}
function GridComponent_Conditional_9_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "thead", 53);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵclassProp("k-grid-draggable-header", ctx_r1.groupable || ctx_r1.reorderable);
    ɵɵproperty("resizable", ctx_r1.resizable)("scrollable", false)("columns", ctx_r1.visibleColumns)("totalColumnLevels", ctx_r1.totalColumnLevels)("totalColumns", ctx_r1.columnsContainer)("groups", ctx_r1.group)("groupable", ctx_r1.showGroupPanel)("reorderable", ctx_r1.reorderable)("sort", ctx_r1.sort)("sortable", ctx_r1.sortable)("filter", ctx_r1.filter)("filterable", ctx_r1.filterable)("columnMenu", ctx_r1.columnMenuOptions)("columnMenuTemplate", ctx_r1.columnMenuTemplate)("detailTemplate", ctx_r1.detailTemplate)("tabIndex", ctx_r1.navigation.tableEnabled ? "-1" : "0");
  }
}
function GridComponent_Conditional_9_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "tfoot", 52);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("scrollable", false)("logicalRowIndex", ctx_r1.ariaRowCount)("groups", ctx_r1.group)("columns", ctx_r1.leafColumns)("detailTemplate", ctx_r1.detailTemplate)("totalColumns", ctx_r1.columnsContainer)("totalColumnsCount", ctx_r1.leafColumns.length);
  }
}
function GridComponent_Conditional_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "table", 48);
    ɵɵelement(1, "colgroup", 49);
    ɵɵconditionalCreate(2, GridComponent_Conditional_9_Conditional_2_Template, 1, 18, "thead", 50);
    ɵɵelement(3, "tbody", 51);
    ɵɵconditionalCreate(4, GridComponent_Conditional_9_Conditional_4_Template, 1, 7, "tfoot", 52);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵstyleProp("table-layout", ctx_r1.resizable ? "fixed" : null);
    ɵɵproperty("size", ctx_r1.size);
    ɵɵadvance();
    ɵɵproperty("columns", ctx_r1.leafColumns)("groups", ctx_r1.group)("sort", ctx_r1.sort)("detailTemplate", ctx_r1.detailTemplate);
    ɵɵadvance();
    ɵɵconditional(!ctx_r1.hideHeader && !ctx_r1.isStacked ? 2 : -1);
    ɵɵadvance();
    ɵɵproperty("isLoading", ctx_r1.loading)("rowHeight", ctx_r1.rowHeight)("detailRowHeight", ctx_r1.detailRowHeight)("groups", ctx_r1.group)("rowsToRender", ctx_r1.rowsToRender)("skip", ctx_r1.skip)("columns", ctx_r1.leafColumns)("totalColumnsCount", ctx_r1.leafColumns.length)("totalColumns", ctx_r1.columnsContainer)("selectable", ctx_r1.selectable)("filterable", ctx_r1.filterable)("noRecordsTemplate", ctx_r1.noRecordsTemplate)("detailTemplate", ctx_r1.detailTemplate)("trackBy", ctx_r1.trackBy)("rowClass", ctx_r1.rowClass)("enableDrag", ctx_r1.marqueeSelection);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.showFooter ? 4 : -1);
  }
}
function GridComponent_Conditional_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 17);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("loadingTemplate", ctx_r1.loadingTemplate);
  }
}
function GridComponent_Conditional_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-status-bar", 18);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("statusBarTemplate", ctx_r1.statusBarTemplate);
  }
}
function GridComponent_Conditional_12_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 25);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const bottomPager_r9 = ɵɵreference(1);
    const ctx_r1 = ɵɵnextContext();
    const defaultPager_r5 = ɵɵreference(17);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.pagerTemplate ? ctx_r1.pagerTemplate == null ? null : ctx_r1.pagerTemplate.templateRef : defaultPager_r5)("ngTemplateOutletContext", bottomPager_r9.templateContext);
  }
}
function GridComponent_Conditional_12_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-pager", 54, 9);
    ɵɵlistener("pageChange", function GridComponent_Conditional_12_Template_kendo_pager_pageChange_0_listener($event) {
      ɵɵrestoreView(_r8);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.notifyPageChange("pager", $event));
    })("pagerInputVisibilityChange", function GridComponent_Conditional_12_Template_kendo_pager_pagerInputVisibilityChange_0_listener($event) {
      ɵɵrestoreView(_r8);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handlePagerVisibilityChange("showPagerInput", $event));
    })("pageTextVisibilityChange", function GridComponent_Conditional_12_Template_kendo_pager_pageTextVisibilityChange_0_listener($event) {
      ɵɵrestoreView(_r8);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handlePagerVisibilityChange("showPagerPageText", $event));
    })("itemsTextVisibilityChange", function GridComponent_Conditional_12_Template_kendo_pager_itemsTextVisibilityChange_0_listener($event) {
      ɵɵrestoreView(_r8);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handlePagerVisibilityChange("showPagerItemsText", $event));
    });
    ɵɵtemplate(2, GridComponent_Conditional_12_ng_template_2_Template, 1, 2, "ng-template", 23);
    ɵɵelement(3, "kendo-pager-messages", 24);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("navigable", ctx_r1.navigation.pagerEnabled)("pageSize", ctx_r1.pageSize)("total", ctx_r1.view.total)("skip", ctx_r1.skip)("size", ctx_r1.size)("responsive", ctx_r1.normalizedPageableSettings.responsive && !ctx_r1.pagerTemplate)("buttonCount", ctx_r1.normalizedPageableSettings.buttonCount)("info", ctx_r1.normalizedPageableSettings.info)("pageSizeValues", ctx_r1.normalizedPageableSettings.pageSizes)("previousNext", ctx_r1.normalizedPageableSettings.previousNext)("type", ctx_r1.normalizedPageableSettings.type);
    ɵɵadvance(3);
    ɵɵproperty("ariaLabel", ctx_r1.messageFor("pagerLabel"))("firstPage", ctx_r1.messageFor("pagerFirstPage"))("inputLabel", ctx_r1.messageFor("pagerInputLabel"))("previousPage", ctx_r1.messageFor("pagerPreviousPage"))("nextPage", ctx_r1.messageFor("pagerNextPage"))("lastPage", ctx_r1.messageFor("pagerLastPage"))("selectPage", ctx_r1.messageFor("pagerSelectPage"))("page", ctx_r1.messageFor("pagerPage"))("itemsPerPage", ctx_r1.messageFor("pagerItemsPerPage"))("items", ctx_r1.messageFor("pagerItems"))("of", ctx_r1.messageFor("pagerOf"))("pageNumberInputTitle", ctx_r1.messageFor("pagerPageNumberInputTitle"));
  }
}
function GridComponent_Conditional_13_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-toolbar", 20);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("size", ctx_r1.size)("navigable", ctx_r1.navigation.toolbarEnabled);
    ɵɵattribute("aria-label", ctx_r1.messageFor("bottomToolbarLabel"))("aria-controls", ctx_r1.ariaRootId);
  }
}
function GridComponent_ng_template_14_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 55);
    ɵɵtext(1);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r1.getHintSettings("hintIcon"))("svgIcon", ctx_r1.getHintSettings("hintSVGIcon"));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.hintText, " ");
  }
}
function GridComponent_ng_template_16_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-pager-prev-buttons", 57);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("size", ctx_r1.size);
  }
}
function GridComponent_ng_template_16_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-pager-numeric-buttons", 58);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("size", ctx_r1.size)("buttonCount", ctx_r1.normalizedPageableSettings.buttonCount);
  }
}
function GridComponent_ng_template_16_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-pager-input", 59);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("size", ctx_r1.size)("showPageText", ctx_r1.showPagerPageText);
  }
}
function GridComponent_ng_template_16_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-pager-next-buttons", 57);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("size", ctx_r1.size);
  }
}
function GridComponent_ng_template_16_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-pager-page-sizes", 60);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("size", ctx_r1.size)("pageSizes", ctx_r1.normalizedPageableSettings.pageSizes)("showItemsText", ctx_r1.showPagerItemsText);
  }
}
function GridComponent_ng_template_16_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-pager-info");
  }
}
function GridComponent_ng_template_16_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 56);
    ɵɵconditionalCreate(1, GridComponent_ng_template_16_Conditional_1_Template, 1, 1, "kendo-pager-prev-buttons", 57);
    ɵɵconditionalCreate(2, GridComponent_ng_template_16_Conditional_2_Template, 1, 2, "kendo-pager-numeric-buttons", 58);
    ɵɵconditionalCreate(3, GridComponent_ng_template_16_Conditional_3_Template, 1, 2, "kendo-pager-input", 59);
    ɵɵconditionalCreate(4, GridComponent_ng_template_16_Conditional_4_Template, 1, 1, "kendo-pager-next-buttons", 57);
    ɵɵelementEnd();
    ɵɵconditionalCreate(5, GridComponent_ng_template_16_Conditional_5_Template, 1, 3, "kendo-pager-page-sizes", 60);
    ɵɵconditionalCreate(6, GridComponent_ng_template_16_Conditional_6_Template, 1, 0, "kendo-pager-info");
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵconditional(ctx_r1.normalizedPageableSettings.previousNext ? 1 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.normalizedPageableSettings.type === "numeric" && ctx_r1.normalizedPageableSettings.buttonCount > 0 ? 2 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.normalizedPageableSettings.type === "input" || ctx_r1.showPagerInput ? 3 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.normalizedPageableSettings.previousNext ? 4 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.normalizedPageableSettings.pageSizes ? 5 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.normalizedPageableSettings.info ? 6 : -1);
  }
}
function GridComponent_Conditional_22_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-adaptive-renderer");
  }
}
function GridComponent_Conditional_23_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-resize-sensor", 61);
    ɵɵlistener("resize", function GridComponent_Conditional_23_Template_kendo_resize_sensor_resize_0_listener() {
      ɵɵrestoreView(_r10);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onResize());
    });
    ɵɵelementEnd();
  }
}
function GridComponent_Conditional_24_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 21);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("licenseMessage", ctx_r1.licenseMessage);
  }
}
function AiAssistantComponent_Conditional_5_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 6)(1, "div", 7)(2, "div", 8);
    ɵɵelement(3, "span", 9);
    ɵɵelementEnd();
    ɵɵelementStart(4, "div", 10);
    ɵɵelement(5, "span", 11);
    ɵɵelementEnd()();
    ɵɵelementStart(6, "div", 12);
    ɵɵelement(7, "span", 13);
    ɵɵelementEnd();
    ɵɵelementStart(8, "div", 14);
    ɵɵelement(9, "span", 11);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    ɵɵadvance(3);
    ɵɵstyleProp("width", 200, "px");
  }
}
function AiAssistantComponent_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, AiAssistantComponent_Conditional_5_ng_template_0_Template, 10, 2, "ng-template", 3);
  }
}
function AiAssistantComponent_Conditional_6_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "p");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const output_r2 = ctx.$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate(output_r2.output);
  }
}
function AiAssistantComponent_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, AiAssistantComponent_Conditional_6_ng_template_0_Template, 2, 1, "ng-template", 4);
  }
}
function SelectAllToolbarToolComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-checkbox", 2, 1);
    ɵɵelementStart(2, "label", 3);
    ɵɵtext(3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const checkbox_r1 = ɵɵreference(1);
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("inputAttributes", ɵɵpureFunction1(4, _c333, ctx_r1.selectAllCheckboxLabel));
    ɵɵattribute("id", ctx_r1.selectAllCheckboxId());
    ɵɵadvance(2);
    ɵɵproperty("for", checkbox_r1.focusableId);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.selectAllCheckboxLabel);
  }
}
var append = (element) => {
  if (!isDocumentAvailable()) {
    return;
  }
  let appended = false;
  return () => {
    if (!appended) {
      document.body.appendChild(element);
      appended = true;
    }
    return element;
  };
};
var getDocument$1 = (element) => element.ownerDocument.documentElement;
var getWindow$1 = (element) => element.ownerDocument.defaultView;
var offset2 = (element) => {
  const {
    clientTop,
    clientLeft
  } = getDocument$1(element);
  const {
    pageYOffset,
    pageXOffset
  } = getWindow$1(element);
  const {
    top,
    left: left2
  } = element.getBoundingClientRect();
  return {
    top: top + pageYOffset - clientTop,
    left: left2 + pageXOffset - clientLeft
  };
};
var isTargetBefore = (draggable, target) => (target.compareDocumentPosition(draggable) & 4) !== 0;
var contains$2 = (element, container) => element === container || (container.compareDocumentPosition(element) & 16) !== 0;
var position = (target, before) => {
  const targetRect = offset2(target);
  const {
    offsetWidth: offsetWidth2,
    offsetHeight
  } = target;
  const left2 = targetRect.left + (before ? 0 : offsetWidth2);
  const top = targetRect.top;
  const height2 = offsetHeight;
  return {
    left: left2,
    top,
    height: height2
  };
};
var DragAndDropService = class _DragAndDropService {
  changes = new EventEmitter();
  register = [];
  lastTarget = null;
  add(target) {
    this.register.push(target);
  }
  remove(target) {
    this.register = this.register.filter((current) => current !== target);
  }
  notifyDrag(draggable, element, mouseEvent) {
    const target = this.targetFor(element);
    if (this.lastTarget === target) {
      return;
    }
    this.changes.next({
      draggable,
      mouseEvent,
      target: this.lastTarget,
      type: "leave"
    });
    if (target) {
      this.changes.next({
        draggable,
        mouseEvent,
        target,
        type: "enter"
      });
    }
    this.lastTarget = target;
  }
  notifyDrop(draggable, mouseEvent) {
    const target = draggable && draggable.element && this.targetFor(draggable.element.nativeElement);
    if (target && this.lastTarget === target) {
      this.lastTarget = null;
      return;
    }
    this.changes.next({
      draggable,
      mouseEvent,
      target: this.lastTarget,
      type: "drop"
    });
    this.lastTarget = null;
  }
  targetFor(element) {
    const comparer = contains$2.bind(null, element);
    return this.register.find(({
      element: {
        nativeElement
      }
    }) => comparer(nativeElement));
  }
  static ɵfac = function DragAndDropService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DragAndDropService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DragAndDropService,
    factory: _DragAndDropService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragAndDropService, [{
    type: Injectable
  }], null, null);
})();
var updateClass = (element, valid, svg) => {
  const icon = element.querySelector(".k-icon");
  if (svg) {
    const svg2 = icon.firstElementChild;
    svg2.removeChild(svg2.firstElementChild);
    const path = valid ? plusIcon.content : cancelIcon.content;
    icon.firstElementChild.innerHTML = path + icon.firstElementChild.innerHTML;
  }
  icon.setAttribute("class", icon.getAttribute("class").replace(/(plus|cancel)/, valid ? "plus" : "cancel"));
};
var updateLock = (element, locked = null, svg) => {
  const icon = element.querySelectorAll(".k-icon")[1];
  const value2 = locked === null ? "" : locked ? `k${svg ? "-svg" : ""}-i-lock` : `k${svg ? "-svg" : ""}-i-unlock`;
  if (svg) {
    icon.setAttribute("class", icon.getAttribute("class").replace(/(k-svg-i-unlock|k-svg-i-lock)/, "").trim() + ` ${value2}`);
    icon.firstElementChild.innerHTML = locked ? lockIcon.content : unlockIcon.content;
  } else {
    icon.setAttribute("class", icon.getAttribute("class").replace(/(k-i-unlock|k-i-lock)/, "").trim() + ` ${value2}`);
  }
};
var decorate = (element) => {
  element.className = "k-header k-drag-clue";
  element.style.position = "absolute";
  element.style.zIndex = "20000";
};
var svgIconsMarkup = (viewBox, content2, safeTitle) => `
    <span class="k-icon k-svg-icon k-drag-status k-svg-i-cancel">
        <svg
            xmlns="http://www.w3.org/2000/svg"
            xmlns:xlink="http://www.w3.org/1999/xlink"
            viewBox="${viewBox}"
            aria-hidden="true">
            ${content2}
        </svg>
        <span class="k-icon k-svg-icon k-icon-modifier">
            <svg
                xmlns="http://www.w3.org/2000/svg"
                xmlns:xlink="http://www.w3.org/1999/xlink"
                viewBox="${viewBox}"
                aria-hidden="true">
            </svg>
        </span>
    </span>
    ${safeTitle}`;
var fontIconsMarkup = (safeTitle) => `
    <span class="k-icon k-font-icon k-drag-status k-i-cancel">
        <span class="k-icon k-font-icon k-icon-modifier"></span>
    </span>
    ${safeTitle}`;
var DragHintService = class _DragHintService {
  sanitizer;
  iconsService;
  dom;
  cancelIcon = cancelIcon;
  constructor(sanitizer, iconsService) {
    this.sanitizer = sanitizer;
    this.iconsService = iconsService;
  }
  ngOnDestroy() {
    this.remove();
  }
  create(title) {
    if (!isDocumentAvailable()) {
      return;
    }
    this.dom = document.createElement("div");
    decorate(this.dom);
    const sanitized = this.sanitizer.sanitize(SecurityContext.HTML, title);
    const safeTitle = sanitized?.replace(/<[^>]*>/g, "");
    const innerHtml = this.isSVG ? svgIconsMarkup(this.cancelIcon.viewBox, this.cancelIcon.content, safeTitle) : fontIconsMarkup(safeTitle);
    this.dom.innerHTML = innerHtml;
  }
  attach() {
    return append(this.dom);
  }
  remove() {
    if (this.dom && this.dom.parentNode) {
      (function(el) {
        setTimeout(() => {
          if (isDocumentAvailable()) {
            document.body.removeChild(el);
          }
        });
      })(this.dom);
      this.dom = null;
    }
  }
  show() {
    this.dom.style.display = "";
  }
  hide() {
    this.dom.style.display = "none";
  }
  enable() {
    updateClass(this.dom, true, this.isSVG);
  }
  disable() {
    updateClass(this.dom, false, this.isSVG);
  }
  removeLock() {
    updateLock(this.dom, false, this.isSVG);
  }
  toggleLock(locked) {
    updateLock(this.dom, locked, this.isSVG);
  }
  move(move) {
    this.dom.style.top = move.pageY + "px";
    this.dom.style.left = move.pageX + "px";
  }
  get isSVG() {
    return (this.iconsService.iconSettings?.type || this.iconsService.changes.value.type) === "svg";
  }
  static ɵfac = function DragHintService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DragHintService)(ɵɵinject(DomSanitizer), ɵɵinject(IconsService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DragHintService,
    factory: _DragHintService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragHintService, [{
    type: Injectable
  }], () => [{
    type: DomSanitizer
  }, {
    type: IconsService
  }], null);
})();
var DropCueService = class _DropCueService {
  dom;
  create() {
    if (!isDocumentAvailable()) {
      return;
    }
    this.dom = document.createElement("div");
    this.dom.className = "k-grouping-dropclue";
    this.hide();
  }
  attach() {
    return append(this.dom);
  }
  remove() {
    if (this.dom && this.dom.parentElement) {
      document.body.removeChild(this.dom);
      this.dom = null;
    }
  }
  hide() {
    this.dom.style.display = "none";
  }
  position({
    left: left2,
    top,
    height: height2
  }) {
    this.dom.style.display = "block";
    this.dom.style.height = height2 + "px";
    this.dom.style.top = top + "px";
    const width2 = this.dom.offsetWidth / 2;
    this.dom.style.left = left2 - width2 + "px";
  }
  static ɵfac = function DropCueService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DropCueService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DropCueService,
    factory: _DropCueService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DropCueService, [{
    type: Injectable
  }], null, null);
})();
var EMPTY_REGEX = /^\s*$/;
var isPresent7 = (value2) => value2 !== null && value2 !== void 0;
var isBlank2 = (value2) => value2 === null || value2 === void 0;
var isArray2 = (value2) => Array.isArray(value2);
var isTruthy = (value2) => !!value2;
var isNullOrEmptyString2 = (value2) => isBlank2(value2) || EMPTY_REGEX.test(value2);
var observe = (list2) => merge(of(list2), list2.changes);
var isUniversal = () => typeof document === "undefined";
var isString2 = (value2) => typeof value2 === "string";
var isNumber3 = (value2) => typeof value2 === "number" && !isNaN(value2);
var extractFormat = (format) => {
  if (isString2(format) && !isNullOrEmptyString2(format) && format.startsWith("{0:")) {
    return format.slice(3, format.length - 1);
  }
  return format;
};
var not = (fn) => (...args) => !fn(...args);
var or = (...conditions) => (value2) => conditions.reduce((acc, x) => acc || x(value2), false);
var and = (...conditions) => (value2) => conditions.reduce((acc, x) => acc && x(value2), true);
var Skip = new InjectionToken("Skip");
var createPromise = () => {
  let resolveFn, rejectFn;
  const promise = new Promise((resolve, reject) => {
    resolveFn = (data) => {
      resolve(data);
      return promise;
    };
    rejectFn = (data) => {
      reject(data);
      return promise;
    };
  });
  promise.resolve = resolveFn;
  promise.reject = rejectFn;
  return promise;
};
var iterator = getIterator$1();
function getIterator$1() {
  if (typeof Symbol === "function" && Symbol.iterator) {
    return Symbol.iterator;
  }
  const keys = Object.getOwnPropertyNames(Map.prototype);
  const proto = Map.prototype;
  for (let i = 0; i < keys.length; ++i) {
    const key = keys[i];
    if (key !== "entries" && key !== "size" && proto[key] === proto.entries) {
      return key;
    }
  }
}
var FRAME_DURATION2 = 1e3 / 60;
var wnd = typeof window !== "undefined" ? window : {};
var requestAnimationFrame2 = wnd.requestAnimationFrame || wnd.msRequestAnimationFrame || ((callback) => setTimeout(callback, FRAME_DURATION2));
var cancelAnimationFrame2 = wnd.cancelAnimationFrame || wnd.msCancelRequestAnimationFrame || clearTimeout;
var nodesToArray = (nodes) => [].slice.call(nodes);
var recursiveFlatMap = (item) => isGroupResult(item) ? item.items.flatMap(recursiveFlatMap) : [__spreadValues({}, item)];
var mapColumnItemState = (c) => ({
  id: c.id,
  width: c.width,
  hidden: c.hidden,
  locked: c.locked,
  sticky: c.sticky,
  orderIndex: c.orderIndex
});
var recursiveColumnsFlatMap = (item) => item.isColumnGroup || item.isSpanColumn ? [mapColumnItemState(item), ...item.children.toArray().flatMap(recursiveColumnsFlatMap)] : [mapColumnItemState(item)];
var isGroupResult = (obj) => {
  return "aggregates" in obj && "items" in obj && "field" in obj && "value" in obj;
};
var roundDown = (value2) => Math.floor(value2 * 100) / 100;
var defaultCellRowSpan = (row2, column, data) => {
  const field = column.field;
  let rowspan = 1;
  const rowIndex = row2.index;
  if (!data[0].items) {
    rowspan = findRowSpan(data, rowIndex, field);
  } else {
    const group2 = row2.dataItem.group;
    if (field === group2.data.field) {
      rowspan = group2.data.items.length;
    } else {
      const rowIndex2 = row2.dataItem.group.data.items.indexOf(row2.dataItem.data);
      const groupItems2 = row2.dataItem.group.data.items;
      rowspan = findRowSpan(groupItems2, rowIndex2, field);
    }
  }
  return rowspan;
};
var findRowSpan = (data, index, field) => {
  let rowspan = 1;
  if (typeof data[index][field]?.getTime === "function") {
    while (data[index][field].getTime() === data[index + 1]?.[field].getTime()) {
      rowspan++;
      index++;
    }
  } else {
    while (data[index][field] === data[index + 1]?.[field]) {
      rowspan++;
      index++;
    }
  }
  return rowspan;
};
var isMultipleRangesEnabled = (selectableSettings) => {
  return selectableSettings && typeof selectableSettings === "object" && selectableSettings.selectable.multipleRanges;
};
var calcRowHeight = (tableBody) => {
  let result = 0;
  if (!isDocumentAvailable()) {
    return result;
  }
  if (tableBody) {
    const row2 = tableBody.insertRow(0);
    const cell2 = row2.insertCell(0);
    cell2.textContent = "&nbsp;";
    result = row2.getBoundingClientRect().height;
    tableBody.deleteRow(0);
  }
  return result;
};
var FOCUS_ROOT_ACTIVE = new InjectionToken("focus-root-initial-active-state");
var FocusRoot = class _FocusRoot {
  active;
  groups = /* @__PURE__ */ new Set();
  constructor(active = false) {
    this.active = active;
  }
  registerGroup(group2) {
    if (this.active) {
      this.groups.add(group2);
    }
  }
  unregisterGroup(group2) {
    if (this.active) {
      this.groups.delete(group2);
    }
  }
  activate() {
    if (this.active) {
      this.groups.forEach((f) => f.activate());
    }
  }
  deactivate() {
    if (this.active) {
      this.groups.forEach((f) => f.deactivate());
    }
  }
  static ɵfac = function FocusRoot_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FocusRoot)(ɵɵinject(FOCUS_ROOT_ACTIVE, 8));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _FocusRoot,
    factory: _FocusRoot.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FocusRoot, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [FOCUS_ROOT_ACTIVE]
    }]
  }], null);
})();
var focusableRegex4 = /^(?:a|input|select|option|textarea|button|object)$/i;
var NODE_NAME_PREDICATES = {};
var toClassList4 = (classNames) => String(classNames).trim().split(" ");
var hasClasses3 = (element, classNames) => {
  const namesList = toClassList4(classNames);
  return Boolean(toClassList4(element.className).find((className) => namesList.indexOf(className) >= 0));
};
var matchesClasses2 = (classNames) => (element) => hasClasses3(element, classNames);
var matchesNodeName = (nodeName) => {
  if (!NODE_NAME_PREDICATES[nodeName]) {
    NODE_NAME_PREDICATES[nodeName] = (element) => String(element.nodeName).toLowerCase() === nodeName.toLowerCase();
  }
  return NODE_NAME_PREDICATES[nodeName];
};
var closest5 = (node, predicate) => {
  while (node && !predicate(node)) {
    node = node.parentNode;
  }
  return node;
};
var closestInScope5 = (node, predicate, scope) => {
  while (node && node !== scope && !predicate(node)) {
    node = node.parentNode;
  }
  if (node !== scope) {
    return node;
  }
};
var contains$1 = (parent, node, matchSelf = false) => {
  const outside = !closest5(node, (child) => child === parent);
  if (outside) {
    return false;
  }
  const el = closest5(node, (child) => child === node);
  return el && (matchSelf || el !== parent);
};
var isVisible2 = (element) => {
  if (!isDocumentAvailable()) {
    return;
  }
  const rect = element.getBoundingClientRect();
  const hasSize = rect.width > 0 && rect.height > 0;
  const hasPosition2 = rect.x !== 0 && rect.y !== 0;
  return (hasSize || hasPosition2) && window.getComputedStyle(element).visibility !== "hidden";
};
var isFocusable5 = (element) => {
  if (!element.tagName) {
    return false;
  }
  const tagName = element.tagName.toLowerCase();
  const hasTabIndex = Boolean(element.getAttribute("tabIndex"));
  const focusable = !element.disabled && focusableRegex4.test(tagName);
  return focusable || hasTabIndex;
};
var isFocusableWithTabKey = (element, checkVisibility = true) => {
  if (!isFocusable5(element)) {
    return false;
  }
  const visible = !checkVisibility || isVisible2(element);
  const ariaHidden = element.getAttribute("aria-hidden") === "true";
  const tabIndex = element.getAttribute("tabIndex");
  return visible && !ariaHidden && tabIndex !== "-1";
};
var findElement = (node, predicate, matchSelf = true) => {
  if (!node) {
    return;
  }
  if (matchSelf && predicate(node)) {
    return node;
  }
  node = node.firstChild;
  while (node) {
    if (node.nodeType === 1) {
      const element = findElement(node, predicate);
      if (element) {
        return element;
      }
    }
    node = node.nextSibling;
  }
};
var findFocusable = (element, checkVisibility = true) => {
  return findElement(element, (node) => isFocusableWithTabKey(node, checkVisibility));
};
var findFocusableChild = (element, checkVisibility = true) => {
  return findElement(element, (node) => isFocusableWithTabKey(node, checkVisibility), false);
};
function rtlScrollPosition(position2, element, initial2) {
  let result = position2;
  if (initial2 < 0) {
    result = -position2;
  } else if (initial2 > 0) {
    result = element.scrollWidth - element.offsetWidth - position2;
  }
  return result;
}
var isButton = matchesNodeName("button");
var isInputTag = matchesNodeName("input");
var isKendoInputTag = matchesNodeName("kendo-checkbox") || matchesNodeName("kendo-textbox");
var isAnchorTag = matchesNodeName("a");
var navigableRegex = /(button|checkbox|color|file|radio|reset|submit)/i;
var isNavigableInput = (element) => isInputTag(element) && navigableRegex.test(element.type);
var isAnchor = (element) => isAnchorTag(element) && element.hasAttribute("href");
var isNavigable = (element) => !element.disabled && (isButton(element) || isNavigableInput(element) || isKendoInputTag(element) || isAnchor(element));
var DefaultFocusableElement = class {
  renderer;
  get enabled() {
    return this.focusable && !this.focusable.disabled;
  }
  get visible() {
    return this.focusable && isVisible2(this.focusable);
  }
  element;
  focusable;
  constructor(host, renderer) {
    this.renderer = renderer;
    this.element = host.nativeElement;
    this.focusable = findFocusable(this.element, false) || this.element;
  }
  isNavigable() {
    return this.canFocus() && isNavigable(this.element);
  }
  toggle(active) {
    this.renderer.setAttribute(this.focusable, "tabIndex", active ? "0" : "-1");
  }
  focus() {
    if (this.focusable) {
      this.focusable.focus();
    }
  }
  canFocus() {
    return this.visible && this.enabled;
  }
  hasFocus() {
    return isDocumentAvailable() && document.activeElement !== this.element && closest5(document.activeElement, (e) => e === this.element);
  }
};
var CELL_CONTEXT = new InjectionToken("grid-cell-context");
var EMPTY_CELL_CONTEXT = {};
var GridToolbarNavigationService = class _GridToolbarNavigationService {
  renderer;
  toolbarElement;
  navigableElements = [];
  currentActiveIndex = 0;
  defaultFocusableSelector = `
        [kendogridtoolbarfocusable],
        [kendogridaddcommand],
        [kendogridcancelcommand],
        [kendogrideditcommand],
        [kendogridremovecommand],
        [kendogridsavecommand],
        [kendogridexcelcommand],
        [kendogridpdfcommand]
    `;
  constructor(renderer) {
    this.renderer = renderer;
  }
  notify() {
    this.navigableElements = this.findNavigableElements();
    this.currentActiveIndex = 0;
    this.updateFocus();
  }
  findNavigableElements() {
    return Array.from(this.toolbarElement.querySelectorAll(this.defaultFocusableSelector) || []);
  }
  focus() {
    this.navigableElements[this.currentActiveIndex]?.focus();
  }
  updateFocus() {
    if (!this.navigableElements.length) {
      return;
    }
    this.navigableElements.forEach((el) => {
      this.renderer.setAttribute(el, "tabindex", "-1");
    });
    this.renderer.setAttribute(this.navigableElements[this.currentActiveIndex], "tabindex", "0");
    if (isDocumentAvailable() && document.activeElement.closest(".k-toolbar")) {
      this.navigableElements[this.currentActiveIndex].focus();
    }
  }
  static ɵfac = function GridToolbarNavigationService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _GridToolbarNavigationService)(ɵɵinject(Renderer2));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _GridToolbarNavigationService,
    factory: _GridToolbarNavigationService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GridToolbarNavigationService, [{
    type: Injectable
  }], () => [{
    type: Renderer2
  }], null);
})();
var ContextService = class _ContextService {
  renderer;
  localization;
  grid;
  topToolbarNavigation;
  bottomToolbarNavigation;
  navigable;
  scroller;
  dataBindingDirective;
  highlightDirective;
  excelComponent;
  pdfComponent;
  constructor(renderer, localization) {
    this.renderer = renderer;
    this.localization = localization;
    this.topToolbarNavigation = new GridToolbarNavigationService(this.renderer);
    this.bottomToolbarNavigation = new GridToolbarNavigationService(this.renderer);
  }
  static ɵfac = function ContextService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ContextService)(ɵɵinject(Renderer2), ɵɵinject(LocalizationService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ContextService,
    factory: _ContextService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ContextService, [{
    type: Injectable
  }], () => [{
    type: Renderer2
  }, {
    type: LocalizationService
  }], null);
})();
var FocusableDirective = class _FocusableDirective {
  cellContext;
  hostElement;
  renderer;
  ctx;
  active = true;
  group;
  element;
  _enabled = true;
  /**
   * @hidden
   */
  set enabled(value2) {
    if (value2 === "") {
      value2 = true;
    } else {
      value2 = Boolean(value2);
    }
    if (value2 !== this.enabled) {
      this._enabled = value2;
      if (this.element) {
        this.element.toggle(this.active && value2);
      }
    }
  }
  get enabled() {
    return this._enabled;
  }
  constructor(cellContext, hostElement, renderer, ctx) {
    this.cellContext = cellContext;
    this.hostElement = hostElement;
    this.renderer = renderer;
    this.ctx = ctx;
    if (this.cellContext) {
      this.group = this.cellContext.focusGroup;
    }
    if (this.group) {
      this.group.registerElement(this);
    }
  }
  ngAfterViewInit() {
    if (!this.element && this.ctx.navigable) {
      this.element = new DefaultFocusableElement(this.hostElement, this.renderer);
    }
    if (this.group && this.element) {
      this.toggle(this.group.isActive);
    }
  }
  ngOnDestroy() {
    if (this.group) {
      this.group.unregisterElement(this);
    }
  }
  /**
   * @hidden
   */
  toggle(active) {
    if (this.element && active !== this.active) {
      this.element.toggle(this.enabled && active);
      this.active = active;
    }
  }
  /**
   * @hidden
   */
  canFocus() {
    return this.enabled && this.element && this.element.canFocus();
  }
  /**
   * @hidden
   */
  isNavigable() {
    return this.enabled && this.element && this.element.isNavigable();
  }
  /**
   * @hidden
   */
  focus() {
    if (this.enabled && this.element) {
      this.element.focus();
    }
  }
  /**
   * @hidden
   */
  hasFocus() {
    return this.enabled && this.element && this.element.hasFocus();
  }
  /**
   * @hidden
   */
  registerElement(element) {
    this.element = element;
  }
  static ɵfac = function FocusableDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FocusableDirective)(ɵɵdirectiveInject(CELL_CONTEXT, 12), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ContextService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FocusableDirective,
    selectors: [["", "kendoGridFocusable", ""], ["", "kendoGridEditCommand", ""], ["", "kendoGridRemoveCommand", ""], ["", "kendoGridSaveCommand", ""], ["", "kendoGridCancelCommand", ""], ["", "kendoGridSelectionCheckbox", ""]],
    inputs: {
      enabled: [0, "kendoGridFocusable", "enabled"]
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FocusableDirective, [{
    type: Directive,
    args: [{
      selector: `[kendoGridFocusable],
        [kendoGridEditCommand],
        [kendoGridRemoveCommand],
        [kendoGridSaveCommand],
        [kendoGridCancelCommand],
        [kendoGridSelectionCheckbox]
    `,
      standalone: true
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CELL_CONTEXT]
    }, {
      type: SkipSelf
    }]
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: ContextService
  }], {
    enabled: [{
      type: Input,
      args: ["kendoGridFocusable"]
    }]
  });
})();
var GridFocusableElement = class {
  navigationService;
  constructor(navigationService) {
    this.navigationService = navigationService;
  }
  focus() {
    this.navigationService.focusCell();
  }
  toggle(active) {
    this.navigationService.toggle(active);
  }
  canFocus() {
    return true;
  }
  hasFocus() {
    return this.navigationService.hasFocus();
  }
  isNavigable() {
    return false;
  }
};
var NavigationCursor = class {
  model;
  changes = new Subject();
  set metadata(value2) {
    this._metadata = value2;
    if (isPresent7(value2)) {
      const newActiveCol = value2.hasDetailTemplate && !this.metadata.isStacked ? 1 : 0;
      const shouldChange = this.activeRow < value2.headerRows && this.activeCol === 0;
      if (shouldChange && newActiveCol !== this.activeCol) {
        this.activeCol = newActiveCol;
        this.reset();
      }
    }
  }
  get metadata() {
    return this._metadata;
  }
  activeRow = 0;
  activeCol = 0;
  virtualCol = 0;
  virtualRow = 0;
  _metadata;
  get row() {
    return this.model.findRow(this.activeRow);
  }
  get cell() {
    const row2 = this.row;
    if (row2) {
      return this.model.findCell(this.activeCol, row2);
    }
  }
  get dataRowIndex() {
    const row2 = this.row;
    if (row2) {
      return row2.dataRowIndex;
    }
    return -1;
  }
  constructor(model) {
    this.model = model;
  }
  /**
   * Assumes and announces a new cursor position.
   */
  reset(rowIndex = this.activeRow, colIndex = this.activeCol, force = true) {
    if (this.activate(rowIndex, colIndex, force)) {
      this.virtualRow = rowIndex;
      this.virtualCol = colIndex;
    }
  }
  activate(rowIndex, colIndex, force) {
    if (!force && this.isActiveRange(rowIndex, colIndex)) {
      return false;
    }
    const prevColIndex = this.activeCol;
    const prevRowIndex = this.activeRow;
    this.activeCol = colIndex;
    this.activeRow = rowIndex;
    this.changes.next({
      colIndex,
      prevColIndex,
      prevRowIndex,
      rowIndex
    });
    return true;
  }
  isActiveRange(rowIndex, colIndex) {
    if (this.activeRow !== rowIndex) {
      return false;
    }
    const cell2 = this.cell;
    const {
      start,
      end
    } = this.model.cellRange(cell2);
    return !cell2 || start <= colIndex && colIndex <= end;
  }
  /**
   * Assumes a new cursor position without announcing it.
   */
  assume(rowIndex = this.activeRow, colIndex = this.activeCol) {
    this.virtualRow = rowIndex;
    this.virtualCol = colIndex;
    this.activeCol = colIndex;
    this.activeRow = rowIndex;
  }
  /**
   * Announces a current cursor position to subscribers.
   */
  announce() {
    this.changes.next({
      colIndex: this.activeCol,
      prevColIndex: this.activeCol,
      prevRowIndex: this.activeRow,
      rowIndex: this.activeRow
    });
  }
  activateVirtualCell(cell2) {
    const rowRange = this.model.rowRange(cell2);
    const cellRange = this.model.cellRange(cell2);
    const activeCol = this.activeCol;
    const activeRow = this.activeRow;
    if (rowRange.start <= activeRow && activeRow <= rowRange.end && cellRange.start <= activeCol && activeCol <= cellRange.end) {
      this.activeRow = cell2.rowIndex;
      this.activeCol = cell2.colIndex;
      return true;
    }
  }
  isActive(rowIndex, colIndex) {
    return this.activeCol === colIndex && this.activeRow === rowIndex;
  }
  moveUp(offset3 = 1) {
    return this.offsetRow(-offset3);
  }
  moveDown(offset3 = 1) {
    return this.offsetRow(offset3);
  }
  moveLeft(offset3 = 1) {
    return this.offsetCol(-offset3);
  }
  moveRight(offset3 = 1) {
    return this.offsetCol(offset3);
  }
  lastCellIndex(row2) {
    return this.metadata.columns.leafColumnsToRender.length - 1 + (this.metadata.hasDetailTemplate && (!row2 || !row2.groupItem) ? 1 : 0);
  }
  offsetCol(offset3) {
    if (this.metadata.isStacked) {
      return false;
    }
    const prevRow = this.model.findRow(this.virtualRow);
    const lastIndex = this.lastCellIndex(prevRow);
    const virtualCol = this.virtualCol;
    this.virtualCol = Math.max(0, Math.min(virtualCol + offset3, lastIndex));
    let nextColIndex = this.virtualCol;
    const nextRowIndex = this.virtualRow;
    let cell2 = this.model.findCell(this.virtualCol, prevRow);
    if (!cell2 && this.metadata.virtualColumns) {
      return this.activate(nextRowIndex, nextColIndex);
    }
    if (!cell2 && this.metadata.hasDetailTemplate) {
      this.virtualCol += 1;
      return false;
    }
    if (cell2.colSpan > 1 && cell2.colIndex <= virtualCol && virtualCol < cell2.colIndex + cell2.colSpan) {
      nextColIndex = offset3 > 0 ? Math.min(cell2.colIndex + cell2.colSpan, lastIndex) : Math.max(0, cell2.colIndex + offset3);
      const nextCell = this.model.findCell(nextColIndex, prevRow);
      if (!nextCell) {
        this.virtualCol = nextColIndex;
        return this.activate(cell2.rowIndex, nextColIndex);
      }
      if (cell2 !== nextCell) {
        cell2 = nextCell;
        this.virtualCol = cell2.colIndex;
      } else {
        this.virtualCol = virtualCol;
      }
      return this.activate(cell2.rowIndex, this.virtualCol);
    }
    this.virtualCol = cell2.colIndex;
    return this.activate(cell2.rowIndex, cell2.colIndex);
  }
  offsetRow(offset3) {
    let nextColIndex = this.virtualCol;
    if (this.metadata && this.metadata.isVirtual) {
      const maxIndex = this.metadata.maxLogicalRowIndex;
      let nextIndex = Math.max(0, Math.min(this.activeRow + offset3, maxIndex));
      if (this.metadata.hasDetailTemplate && !this.model.findRow(nextIndex)) {
        nextIndex = offset3 > 0 ? nextIndex + 1 : nextIndex - 1;
        nextIndex = Math.max(0, Math.min(nextIndex, maxIndex));
      }
      if (this.metadata.hasDetailTemplate && nextIndex === maxIndex) {
        if (this.model.lastRow.index !== maxIndex) {
          nextIndex--;
        }
      }
      const nextRow2 = this.model.findRow(nextIndex);
      if (nextRow2) {
        let cell3 = this.model.findCell(this.virtualCol, nextRow2);
        if (!cell3) {
          return;
        }
        if (cell3.rowIndex <= this.virtualRow && offset3 > 0 && cell3.rowSpan > 1) {
          cell3 = this.model.findCell(this.virtualCol, this.model.findRow(cell3.rowIndex + cell3.rowSpan - 1 + offset3));
          if (!cell3) {
            return;
          }
        }
        nextIndex = cell3.rowIndex;
        nextColIndex = cell3.colIndex;
      }
      this.virtualRow = nextIndex;
      return this.activate(nextIndex, nextColIndex);
    }
    const nextRow = this.model.findRow(this.virtualRow + offset3) || this.model.nextRow(this.virtualRow, offset3);
    if (!nextRow) {
      return false;
    }
    let cell2 = this.model.findCell(this.virtualCol, nextRow);
    if (cell2 && cell2.rowIndex <= this.virtualRow && offset3 > 0 && cell2.rowSpan > 1) {
      const nextPos = cell2.rowIndex + cell2.rowSpan - 1 + offset3;
      cell2 = this.model.findCell(this.virtualCol, this.model.findRow(nextPos));
    }
    if (!cell2 && (this.metadata.virtualColumns || this.metadata.hasDetailTemplate)) {
      return this.activate(this.virtualRow + offset3, this.virtualCol);
    }
    if (!cell2) {
      return false;
    }
    this.virtualRow = cell2.rowIndex;
    return this.activate(this.virtualRow, cell2.colIndex);
  }
};
var ItemMap = class {
  count = 0;
  items = {};
  get first() {
    if (this.count > 0) {
      let result;
      this.forEach((item) => {
        result = item;
        return true;
      });
      return result;
    }
  }
  get last() {
    if (this.count > 0) {
      const keys = Object.keys(this.items);
      return this.items[keys[keys.length - 1]];
    }
  }
  removeItem(key) {
    if (this.items[key]) {
      delete this.items[key];
      this.count--;
    }
  }
  setItem(key, item) {
    if (!this.items[key]) {
      this.count++;
    }
    this.items[key] = item;
  }
  getItem(key) {
    return this.items[key];
  }
  toArray() {
    const result = [];
    this.forEach((item) => {
      result.push(item);
    });
    return result;
  }
  forEach(callback) {
    for (const key in this.items) {
      if (this.items.hasOwnProperty(key) && callback(this.items[key])) {
        return this.items[key];
      }
    }
  }
  find(callback) {
    return this.forEach(callback);
  }
};
var NavigationModel = class {
  rows = new ItemMap();
  get firstRow() {
    return this.rows.first;
  }
  get lastRow() {
    return this.rows.last;
  }
  registerCell(cell2) {
    const row2 = this.rows.getItem(cell2.logicalRowIndex);
    if (!row2) {
      return;
    }
    const colIndex = cell2.logicalColIndex;
    const modelCell = {
      uid: cell2.uid,
      colIndex,
      rowIndex: row2.index,
      colSpan: cell2.colSpan,
      rowSpan: cell2.rowSpan,
      detailExpandCell: cell2.detailExpandCell,
      dataItem: row2.dataItem,
      dataRowIndex: row2.dataRowIndex,
      focusGroup: cell2.focusGroup
    };
    row2.cells.setItem(colIndex, modelCell);
    if (cell2.groupItem) {
      row2.groupItem = cell2.groupItem;
    }
    return modelCell;
  }
  unregisterCell(index, rowIndex, cell2) {
    const row2 = this.rows.getItem(rowIndex);
    if (row2) {
      const match = row2.cells.getItem(index);
      if (match && match.uid === cell2.uid) {
        row2.cells.removeItem(index);
      }
    }
  }
  registerRow(row2) {
    const modelRow = {
      uid: row2.uid,
      index: row2.logicalRowIndex,
      dataItem: row2.dataItem,
      dataRowIndex: row2.dataRowIndex,
      cells: new ItemMap()
    };
    this.rows.setItem(row2.logicalRowIndex, modelRow);
  }
  updateRow(row2) {
    const current = this.rows.getItem(row2.logicalRowIndex);
    if (current) {
      Object.assign(current, {
        dataItem: row2.dataItem,
        dataRowIndex: row2.dataRowIndex
      });
    }
  }
  unregisterRow(index, row2) {
    const match = this.rows.getItem(index);
    if (match && match.uid === row2.uid) {
      this.rows.removeItem(index);
    }
  }
  cellRange(cell2) {
    if (cell2) {
      const start = cell2.colIndex;
      const end = cell2.colIndex + (cell2.colSpan || 1) - 1;
      return {
        start,
        end
      };
    }
    return {};
  }
  rowRange(cell2) {
    if (cell2) {
      const start = cell2.rowIndex;
      const end = cell2.rowIndex + (cell2.rowSpan || 1) - 1;
      return {
        start,
        end
      };
    }
    return {};
  }
  nextRow(rowIndex, offset3) {
    const rows = this.rows.toArray();
    const row2 = this.rows.getItem(rowIndex);
    const position2 = rows.indexOf(row2);
    const next2 = rows[position2 + offset3];
    return next2;
  }
  findRow(index) {
    return this.rows.getItem(index);
  }
  findCell(index, row2) {
    if (!row2) {
      return;
    }
    const rowIndex = row2.index;
    let cell2 = row2.cells.getItem(index);
    let currentIndex = rowIndex;
    while (!cell2 && row2) {
      row2 = this.rows.getItem(currentIndex);
      cell2 = this.rowCell(index, row2);
      currentIndex--;
    }
    if (cell2 && rowIndex <= row2.index + (cell2.rowSpan || 1) - 1) {
      return cell2;
    }
  }
  rowCell(index, row2) {
    if (!row2 || !row2.cells.count) {
      return;
    }
    const firstCell = row2.cells.first;
    let cell2, currentIndex = index;
    while (!cell2 && currentIndex >= firstCell.colIndex) {
      cell2 = row2.cells.getItem(currentIndex);
      currentIndex--;
    }
    if (cell2 && index <= cell2.colIndex + (cell2.colSpan || 1) - 1) {
      return cell2;
    }
  }
};
var DomEventsService = class _DomEventsService {
  cellClick = new EventEmitter();
  cellMousedown = new EventEmitter();
  cellMouseup = new EventEmitter();
  click = new EventEmitter();
  keydown = new EventEmitter();
  shiftKeyup = new EventEmitter();
  focus = new EventEmitter();
  focusIn = new EventEmitter();
  focusOut = new EventEmitter();
  windowBlur = new EventEmitter();
  paste = new EventEmitter();
  static ɵfac = function DomEventsService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DomEventsService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DomEventsService,
    factory: _DomEventsService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DomEventsService, [{
    type: Injectable
  }], null, null);
})();
var PreventableEvent7 = class {
  prevented = false;
  /**
   * Prevents the default action for a specified event.
   * In this way, the source component suppresses the built-in behavior that follows the event.
   */
  preventDefault() {
    this.prevented = true;
  }
  /**
   * Returns whether the default action for a specified event was prevented.
   * @returns `true` if the default action was prevented. Otherwise, returns `false`.
   */
  isDefaultPrevented() {
    return this.prevented;
  }
};
var CellCloseEvent = class extends PreventableEvent7 {
  isNew;
  dataItem;
  rowIndex;
  sender;
  /**
   * @hidden
   */
  action = "cellClose";
  /**
   * The Grid column that will be closed.
   */
  column;
  /**
   * The [FormGroup](link:site.data.urls.angular['formgroupapi']) used to edit the cell.
   */
  formGroup;
  /**
   * The DOM event that triggered the `cellClose` event.
   * May be undefined if the event was triggered programmatically.
   */
  originalEvent;
  /**
   * @hidden
   */
  constructor(options) {
    super();
    Object.assign(this, options);
  }
};
var isEqual2 = (index) => (item) => item.index === index;
var isNotEqual = (index) => (item) => item.index !== index;
var isNewRow = (index) => index === -1 || index === void 0;
var EditService = class _EditService {
  ngZone;
  changes = new EventEmitter();
  changed;
  editedIndices = [];
  newItemGroup;
  keepEditCell = false;
  keepCellTimeout;
  column;
  closingCell = false;
  changedSource = new Subject();
  constructor(ngZone) {
    this.ngZone = ngZone;
    this.changed = this.changedSource.asObservable().pipe(switchMap(() => this.ngZone.onStable.asObservable().pipe(take(1))));
  }
  editRow(index, group2 = void 0) {
    this.editedIndices.push({
      index,
      group: group2
    });
    this.onChanged();
  }
  addRow(group2) {
    this.newItemGroup = {
      group: group2
    };
    this.onChanged();
  }
  editCell(rowIndex, column, group2) {
    if (isNewRow(rowIndex) || column.editable === false || !(column.editTemplate || column.field)) {
      return;
    }
    this.preventCellClose();
    if (!this.closeCell()) {
      this.editRow(rowIndex, group2);
      this.column = column;
      this.onChanged();
    }
  }
  isEditing() {
    return this.editedIndices.length > 0;
  }
  isEditingCell() {
    return this.isEditing() && this.column !== void 0;
  }
  get hasNewItem() {
    return isPresent7(this.newItemGroup);
  }
  get newDataItem() {
    if (this.hasNewItem) {
      return this.newItemGroup.group.value;
    }
    return {};
  }
  close(index) {
    if (isNewRow(index)) {
      this.newItemGroup = void 0;
      return;
    }
    this.editedIndices = this.editedIndices.filter(isNotEqual(index));
    delete this.column;
    this.onChanged();
  }
  closeCell(originalEvent) {
    if (this.column && !this.closingCell) {
      return this.ngZone.run(() => {
        const {
          index,
          group: group2
        } = this.editedIndices[0];
        const args = new CellCloseEvent({
          column: this.column,
          formGroup: group2,
          originalEvent,
          rowIndex: index
        });
        this.closingCell = true;
        this.changes.emit(args);
        this.closingCell = false;
        if (!args.isDefaultPrevented()) {
          this.cancelCell();
        }
        return args.isDefaultPrevented();
      });
    }
  }
  cancelCell() {
    if (this.column) {
      this.editedIndices = [];
      delete this.column;
      this.onChanged();
    }
  }
  shouldCloseCell() {
    return this.column && !this.keepEditCell;
  }
  preventCellClose() {
    this.ngZone.runOutsideAngular(() => {
      window.clearTimeout(this.keepCellTimeout);
      this.keepEditCell = true;
      this.keepCellTimeout = window.setTimeout(() => {
        this.keepEditCell = false;
      }, 0);
    });
  }
  context(index) {
    if (isNewRow(index)) {
      return this.newItemGroup;
    }
    return this.findByIndex(index);
  }
  columnContext(index, column) {
    if (isNewRow(index)) {
      return this.newItemGroup;
    }
    if (!this.column || column === this.column) {
      return this.findByIndex(index);
    }
  }
  isEdited(index) {
    if (isNewRow(index) && isPresent7(this.newItemGroup)) {
      return true;
    }
    return !this.column && isPresent7(this.findByIndex(index));
  }
  hasEdited(index) {
    return isPresent7(this.context(index));
  }
  isEditedColumn(index, column) {
    if (this.column && this.column === column) {
      return isPresent7(this.findByIndex(index));
    }
    return false;
  }
  beginEdit(rowIndex) {
    this.changes.emit({
      action: "edit",
      rowIndex
    });
  }
  beginAdd() {
    this.changes.emit({
      action: "add",
      isNew: true
    });
  }
  endEdit(rowIndex) {
    const {
      group: formGroup
    } = this.context(rowIndex);
    this.changes.emit({
      action: "cancel",
      rowIndex,
      formGroup,
      isNew: isNewRow(rowIndex)
    });
  }
  save(rowIndex) {
    const {
      group: formGroup
    } = this.context(rowIndex);
    this.changes.emit({
      action: "save",
      rowIndex,
      formGroup,
      isNew: isNewRow(rowIndex)
    });
  }
  remove(rowIndex) {
    this.changes.emit({
      action: "remove",
      rowIndex
    });
  }
  findByIndex(index) {
    return this.editedIndices.find(isEqual2(index));
  }
  onChanged() {
    this.ngZone.runOutsideAngular(() => {
      this.changedSource.next(void 0);
    });
  }
  static ɵfac = function EditService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _EditService)(ɵɵinject(NgZone));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _EditService,
    factory: _EditService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EditService, [{
    type: Injectable
  }], () => [{
    type: NgZone
  }], null);
})();
var getGroupRowArgs = (groupItem) => {
  if (!isPresent7(groupItem)) {
    return null;
  }
  return {
    group: groupItem.data,
    groupIndex: groupItem.index,
    parentGroup: getGroupRowArgs(groupItem.parentGroup)
  };
};
var isChildIndex = (targetIndex, parentIndex) => {
  const sameIndex = parentIndex === targetIndex;
  const lastSeparatorIndex = targetIndex.lastIndexOf("_");
  const sameSubGroupIndex = targetIndex.substring(0, lastSeparatorIndex) === parentIndex;
  return !sameIndex && sameSubGroupIndex;
};
var GroupsService = class _GroupsService {
  changes = new Subject();
  userCallback;
  rowState = /* @__PURE__ */ new Set();
  reset() {
    this.rowState.clear();
  }
  ngOnDestroy() {
    this.reset();
  }
  isExpanded(groupArgs) {
    if (this.userCallback) {
      return this.userCallback(groupArgs);
    }
    return !this.rowState.has(groupArgs.groupIndex);
  }
  isInExpandedGroup(groupItem) {
    let expanded = true;
    while (groupItem && expanded) {
      expanded = this.isExpanded({
        group: groupItem.data,
        groupIndex: groupItem.index,
        parentGroup: getGroupRowArgs(groupItem.parentGroup)
      });
      groupItem = groupItem.parentGroup;
    }
    return expanded;
  }
  toggleRow(groupItem, emit = true) {
    const parentGroup = getGroupRowArgs(groupItem.parentGroup);
    const expand2 = !this.isExpanded({
      group: groupItem.data,
      groupIndex: groupItem.index,
      parentGroup
    });
    this.changes.next({
      group: groupItem.data,
      expand: expand2,
      groupIndex: groupItem.index,
      parentGroup,
      emit
    });
    if (this.userCallback) {
      return;
    }
    if (expand2) {
      this.rowState.delete(groupItem.index);
    } else {
      this.rowState.add(groupItem.index);
    }
  }
  expandChildren(parentIndex) {
    this.rowState.forEach((index) => isChildIndex(index, parentIndex) && this.rowState.delete(index));
  }
  static ɵfac = function GroupsService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _GroupsService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _GroupsService,
    factory: _GroupsService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GroupsService, [{
    type: Injectable
  }], null, null);
})();
var DetailCollapseEvent = class extends PreventableEvent7 {
  /**
   * The `dataItem` for the collapsed row.
   */
  dataItem;
  /**
   * The index of the collapsed row.
   */
  index;
  /**
   * @hidden
   */
  constructor(args) {
    super();
    Object.assign(this, args);
  }
};
var DetailExpandEvent = class extends PreventableEvent7 {
  /**
   * Represents the `dataItem` for the expanded row.
   */
  dataItem;
  /**
   * Represents the index of the expanded row.
   */
  index;
  /**
   * @hidden
   */
  constructor(args) {
    super();
    Object.assign(this, args);
  }
};
var DetailsService = class _DetailsService {
  userCallback;
  changes = new Subject();
  rowState = /* @__PURE__ */ new Set();
  ngOnDestroy() {
    this.rowState.clear();
  }
  isExpanded(index, dataItem) {
    if (this.userCallback) {
      return this.userCallback({
        index,
        dataItem
      });
    }
    return this.rowState.has(index);
  }
  toggleRow(index, dataItem) {
    if (this.isExpanded(index, dataItem)) {
      this.collapseRow(index, dataItem);
    } else {
      this.expandRow(index, dataItem);
    }
  }
  expandRow(index, dataItem) {
    const prevented = this.emitEvent({
      dataItem,
      index,
      expand: true
    });
    if (!prevented && !this.userCallback) {
      this.rowState.add(index);
    }
  }
  collapseRow(index, dataItem) {
    const prevented = this.emitEvent({
      dataItem,
      index,
      expand: false
    });
    if (!prevented && !this.userCallback) {
      this.rowState.delete(index);
    }
  }
  emitEvent(args) {
    const eventArg = new (args.expand ? DetailExpandEvent : DetailCollapseEvent)(args);
    this.changes.next(eventArg);
    return eventArg.isDefaultPrevented();
  }
  static ɵfac = function DetailsService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DetailsService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DetailsService,
    factory: _DetailsService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DetailsService, [{
    type: Injectable
  }], null, null);
})();
var ScrollRequestService = class _ScrollRequestService {
  requests = new Subject();
  scrollTo(request, adjustIndex = true) {
    this.requests.next({
      request,
      adjustIndex
    });
  }
  scrollToItem(request) {
    this.requests.next({
      request
    });
  }
  static ɵfac = function ScrollRequestService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ScrollRequestService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ScrollRequestService,
    factory: _ScrollRequestService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollRequestService, [{
    type: Injectable
  }], null, null);
})();
var CellTemplateDirective2 = class _CellTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function CellTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CellTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CellTemplateDirective,
    selectors: [["", "kendoGridCellTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CellTemplateDirective2, [{
    type: Directive,
    args: [{
      selector: "[kendoGridCellTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var EditTemplateDirective = class _EditTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function EditTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _EditTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _EditTemplateDirective,
    selectors: [["", "kendoGridEditTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EditTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridEditTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var HeaderTemplateDirective2 = class _HeaderTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function HeaderTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HeaderTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _HeaderTemplateDirective,
    selectors: [["", "kendoGridHeaderTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HeaderTemplateDirective2, [{
    type: Directive,
    args: [{
      selector: "[kendoGridHeaderTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var FooterTemplateDirective3 = class _FooterTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function FooterTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FooterTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FooterTemplateDirective,
    selectors: [["", "kendoGridFooterTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FooterTemplateDirective3, [{
    type: Directive,
    args: [{
      selector: "[kendoGridFooterTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var ColumnMenuTemplateDirective = class _ColumnMenuTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function ColumnMenuTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColumnMenuTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ColumnMenuTemplateDirective,
    selectors: [["", "kendoGridColumnMenuTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridColumnMenuTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var activeGridIndices = /* @__PURE__ */ new Set();
function getNextGridIndex() {
  let index = 0;
  while (activeGridIndices.has(index)) {
    index++;
  }
  activeGridIndices.add(index);
  return index;
}
function releaseGridIndex(index) {
  activeGridIndices.delete(index);
}
var IdService = class _IdService {
  prefix;
  gridIndex;
  columnCounter = 0;
  constructor() {
    this.gridIndex = getNextGridIndex();
    this.prefix = `k-grid${this.gridIndex}`;
  }
  ngOnDestroy() {
    releaseGridIndex(this.gridIndex);
  }
  gridId() {
    return this.prefix;
  }
  cellId(rowIndex, colIndex) {
    return `${this.prefix}-r${rowIndex}c${colIndex}`;
  }
  selectionCheckboxId(itemIndex2) {
    return `${this.prefix}-checkbox${itemIndex2}`;
  }
  selectAllCheckboxId() {
    return `${this.prefix}-select-all`;
  }
  columnId(colIndex) {
    return `${this.prefix}-col${colIndex}`;
  }
  nextColumnId() {
    return `${this.prefix}-col${this.columnCounter++}`;
  }
  static ɵfac = function IdService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _IdService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _IdService,
    factory: _IdService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IdService, [{
    type: Injectable
  }], () => [], null);
})();
var ColumnMenuErrorMessages = {
  autoSizeColumn: `The auto size column does not work with enabled virtual columns.
    See https://www.telerik.com/kendo-angular-ui/components/grid/accessories/column-menu/#toc-autosize-column-item.`,
  autoSizeAllColumns: `The auto size all columns does not work with enabled virtual columns.
    See https://www.telerik.com/kendo-angular-ui/components/grid/accessories/column-menu/#toc-autosize-all-columns-item.`,
  serviceInput: `The service input of the predefined column menu components is mandatory.
    See https://www.telerik.com/kendo-angular-ui/components/grid/accessories/column-menu/#toc-customizing-the-content.`
};
var ClipboardErrorMessages = {
  activeCellNavigable: `Grid must be navigable to use "activeCell" as clipboard target type.
    See https://www.telerik.com/kendo-angular-ui/components/grid/accessories/clipboard/#toc-active-cell.`,
  selectionSelectable: `Grid must be selectable to use "selection" as clipboard target type.
    See https://www.telerik.com/kendo-angular-ui/components/grid/accessories/clipboard/#toc-current-selection.`
};
var ColumnConfigurationErrorMessages = {
  fieldName: (field) => `Grid column field name '${field}' does not look like a valid JavaScript identifier.
        Identifiers can contain only alphanumeric characters (including "$" or "_"), and may not start with a digit.
        Please use only valid identifier names to ensure error-free operation.`,
  width: (value2, parsedValue) => `Expected numeric value for column width, but got a string "${value2}". Treating as ${parsedValue}px.`,
  invalidColumn: (column) => `Invalid column ${column}.`,
  requiredWidth: (columnType) => `${columnType} columns feature requires all columns to have set width.
    See https://www.telerik.com/kendo-angular-ui/components/grid/columns/${columnType.toLowerCase()}.`,
  requiredScroll: (columnType) => `${columnType} columns are only supported when scrolling is enabled.
    See https://www.telerik.com/kendo-angular-ui/components/grid/columns/${columnType.toLowerCase()}/`,
  groupColumnContent: "ColumnGroupComponent should contain ColumnComponent or CommandColumnComponent.",
  lockedParent: "Locked child columns require their parent columns to be locked.",
  columnNested: "Columns can be nested only inside ColumnGroupComponent",
  nestedInside: (nestedColumnNameType, parentColumnType) => `${nestedColumnNameType} cannot be nested inside ${parentColumnType}.`,
  cellRowspanNonBoundColumns: "cellRowspan must be a function for non-bound columns.",
  cellRowspanSpanGroupedColumns: "cellRowspan is not supported for SpanColumn and GroupColumn.",
  cellRowspan: `cellRowspan must be a function or boolean.`
};
var GridConfigurationErrorMessages = {
  functionType: (propName, fn) => `${propName} must be a function, but received ${JSON.stringify(fn)}.`,
  incompatibleFeatures: (feat1Name, feat2Name) => `'Having both ${feat1Name} and ${feat2Name} is not supported.'`,
  nonLockedColumnPresent: "There should be at least one non-locked column. See https://www.telerik.com/kendo-angular-ui/components/grid/columns/locked/#toc-known-limitations",
  focusNavigable: "The Grid should be configured as navigable to control focus. See https://www.telerik.com/kendo-angular-ui/components/grid/keyboard-navigation/.",
  expandCollapseMethods: (expandMethodName, collapseMethodName, directiveName, callbackName) => `The ${expandMethodName} and ${collapseMethodName} methods should not be called
        when using the ${directiveName} directive or the ${callbackName} callback.
        These methods are provided only for backwards compatibility with legacy versions.`,
  requiredEditService: `The default edit service of the editing directives works only when binding to plain array.
        Please provide an editService. See https://www.telerik.com/kendo-angular-ui/components/grid/editing/editing-directives/#toc-custom-editing-service.`,
  requiredModule: (exportedType, moduleName, componentSelector) => `Creating ${exportedType} requires including the ${moduleName} and adding the ${componentSelector} component.`,
  unsupportedMethod: (methodName, suggestedMethodName) => `Using ${methodName} in this context is not supported. Use ${suggestedMethodName} instead.`,
  unsupportedToolbarConfig: `
        Defining both a toolbar template and a ToolBarComponent within the Grid is not supported.
        Please use either the ToolBarComponent or a custom template.`
};
var isSpanColumn = (column) => column?.isSpanColumn;
var isCheckboxColumn = (column) => column?.isCheckboxColumn;
var isRowReorderColumn = (column) => column?.isRowReorderColumn;
var isColumnContainer = (column) => column?.isColumnGroup || isSpanColumn(column);
var ColumnBase2 = class _ColumnBase {
  parent;
  /**
   * @hidden
   */
  isReordered;
  /**
   * @hidden
   */
  initialMaxResizableWidth;
  /**
   * @hidden
   */
  initialMinResizableWidth;
  /**
   * @hidden
   */
  initiallyChecked;
  /**
   * @hidden
   */
  currentlyChecked;
  /**
   * @hidden
   */
  matchesMedia = true;
  /**
   * Gets the column index after reordering. The `orderIndex` property is read-only. Setting this field does not change the column order.
   *
   * @default 0
   */
  orderIndex = 0;
  /**
   * @hidden
   */
  set leafIndex(value2) {
    this._leafIndex = value2;
  }
  /**
   * @hidden
   */
  get leafIndex() {
    return this._leafIndex;
  }
  _leafIndex;
  /**
   * @hidden
   */
  isColumnGroup = false;
  /**
   * @hidden
   */
  isSpanColumn = false;
  /**
   * Specifies if the column is resizable.
   * @default true
   */
  resizable = true;
  /**
   * Specifies if the column is reorderable.
   * @default true
   */
  reorderable = true;
  /**
   * Sets the minimum width (in pixels) for resizing the column by using the UI ([see example]({% slug resizing_columns_grid %}#toc-limiting-the-resizing)).
   * The `autoFitColumn` and `autoFitColumns` methods have higher priority.
   * @default 10
   */
  minResizableWidth = 10;
  /**
   * Sets the maximum width (in pixels) for resizing the column by using the UI ([see example]({% slug resizing_columns_grid %}#toc-limiting-the-resizing)).
   * By default, the maximum width is not restricted.
   * The `autoFitColumn` and `autoFitColumns` methods have higher priority.
   */
  maxResizableWidth;
  /**
   * Sets the column title.
   */
  title;
  /**
   * Sets the column width (in pixels).
   */
  set width(value2) {
    if (typeof value2 === "string") {
      const parsedValue = this._width = parseInt(value2, 10);
      if (isDevMode()) {
        console.warn(ColumnConfigurationErrorMessages.width(value2, parsedValue));
      }
    } else {
      this._width = value2;
    }
  }
  get width() {
    return this._width;
  }
  /**
   * Specifies if the column is automatically resized during initialization to fit its header and row content.
   */
  autoSize;
  /**
   * Toggles the locked (frozen) state of the column ([more information and example]({% slug locked_columns_grid %})).
   *
   * @default false
   */
  set locked(value2) {
    this._locked = value2;
  }
  get locked() {
    return this._locked;
  }
  _locked = false;
  /**
   * Specifies if the column is always visible when scrolling the Grid horizontally.
   *
   * @default false
   */
  sticky = false;
  /**
   * Sets the visibility of the column ([see example](slug:hidden_columns_grid#toc-using-the-built-in-options)).
   *
   * @default false
   */
  hidden;
  /**
   * Sets the condition for the column to remain visible ([see example]({% slug styling_responsive_grid %}#toc-columns)).
   * If you set the `hidden` property, `media` is ignored.
   *
   * Accepts device identifiers from [Bootstrap 4](https://v4-alpha.getbootstrap.com/layout/grid/#grid-options)
   * ([see example](slug:styling_responsive_grid)).
   */
  media;
  /**
   * Specifies if the column can be locked or unlocked from the column menu or by reordering.
   * @default true
   */
  lockable = true;
  /**
   * Specifies if the column can be stuck or unstuck from the column menu.
   * @default true
   */
  stickable = true;
  /**
   * Specifies if the column menu is shown for the column.
   * @default true
   */
  columnMenu = true;
  /**
   * Specifies if the column is included in the column-chooser list.
   * @default true
   */
  includeInChooser = true;
  /**
   * Sets the `role` attribute for the table cells (excluding footer and header) of the column.
   * @default "gridcell"
   */
  tableCellsRole = "gridcell";
  /**
   * Sets custom styles for the table cells (excluding footer and header) of the column.
   * Uses the [`NgStyle`](link:site.data.urls.angular['ngstyleapi']) directive. [See example](slug:styling_grid_columns#toc-customizing-column-cells).
   */
  style;
  /**
   * Sets custom styles for the header cell of the column.
   * Uses the [`NgStyle`](link:site.data.urls.angular['ngstyleapi']) directive. [See example](slug:styling_grid_columns#toc-customizing-column-header).
   */
  headerStyle;
  /**
   * Sets custom styles for the filter row cell.
   * Uses the [`NgStyle`](link:site.data.urls.angular['ngstyleapi']) directive. [See example](slug:styling_grid_columns#toc-customizing-filter-row-cells).
   */
  filterStyle;
  /**
   * Sets custom styles for the footer cell of the column.
   * Uses the [`NgStyle`](link:site.data.urls.angular['ngstyleapi']) directive. [See example](slug:styling_grid_columns#toc-customizing-column-footer).
   */
  footerStyle;
  /**
   * Sets custom CSS classes to the column cells.
   * Uses the [`NgClass`](link:site.data.urls.angular['ngclassapi']) directive. [See example](slug:styling_grid_columns#toc-customizing-column-cells).
   * To customize header and footer column cells, use the [headerClass]({% slug api_grid_columncomponent %}#toc-headerclass)
   * and [footerClass]({% slug api_grid_columncomponent %}#toc-footerclass) inputs.
   */
  cssClass;
  /**
   * Sets custom CSS classes to the column header cell.
   * Uses the [`NgClass`](link:site.data.urls.angular['ngclassapi']) directive. [See example](slug:styling_grid_columns#toc-customizing-column-header).
   */
  headerClass;
  /**
   * Sets custom CSS classes to the filter row cell.
   * Uses the [`NgClass`](link:site.data.urls.angular['ngclassapi']) directive. [See example](slug:styling_grid_columns#toc-customizing-filter-row-cells).
   */
  filterClass;
  /**
   * Sets custom CSS classes to the column footer cell.
   * Uses the [`NgClass`](link:site.data.urls.angular['ngclassapi']) directive. [See example](slug:styling_grid_columns#toc-customizing-column-footer).
   */
  footerClass;
  /**
   * Defines a function to determine the rowspan of each column cell.
   * If you set this to `true`, a default function is used that spans adjacent cells with equal values.
   * Cells have equal values when their data items' values for the respective field are equal.
   */
  set cellRowspan(cellRowspan) {
    if (isDevMode() && (this.isSpanColumn || this.isColumnGroup)) {
      throw new Error(ColumnConfigurationErrorMessages.cellRowspanSpanGroupedColumns);
    }
    if (cellRowspan) {
      const isFunction4 = typeof cellRowspan === "function";
      const isBoolean = typeof cellRowspan === "boolean";
      if (isDevMode() && !this.field && !isFunction4) {
        throw new Error(ColumnConfigurationErrorMessages.cellRowspanNonBoundColumns);
      }
      if (isDevMode() && !(isBoolean || isFunction4)) {
        throw new Error(ColumnConfigurationErrorMessages.cellRowspan);
      }
      this._cellRowspan = isBoolean ? defaultCellRowSpan : cellRowspan;
    }
  }
  get cellRowspan() {
    return this._cellRowspan;
  }
  /**
   * @hidden
   */
  headerTemplates = new QueryList();
  /**
   * @hidden
   */
  footerTemplate;
  /**
   * @hidden
   */
  columnMenuTemplates = new QueryList();
  /**
   * @hidden
   */
  resizeStartWidth;
  /**
   * @hidden
   */
  idService;
  /**
   * @hidden
   */
  _cellRowspan;
  /**
   * @hidden
   */
  implicitWidth;
  /**
   * @hidden
   */
  get level() {
    if (this.parent && isSpanColumn(this.parent)) {
      return this.parent.level;
    }
    return this.parent ? this.parent.level + 1 : 0;
  }
  /**
   * @hidden
   */
  get isLocked() {
    return this.parent ? this.parent.isLocked : this.locked;
  }
  _width;
  /**
   * @hidden
   */
  get id() {
    return this._id;
  }
  /**
   * @hidden
   */
  get colspan() {
    return 1;
  }
  /**
   * @hidden
   */
  rowspan(totalColumnLevels) {
    return this.level < totalColumnLevels ? totalColumnLevels - this.level + 1 : 1;
  }
  /**
   * @hidden
   */
  get headerTemplateRef() {
    const template = this.headerTemplates.first;
    return template ? template.templateRef : void 0;
  }
  /**
   * @hidden
   */
  get footerTemplateRef() {
    return this.footerTemplate ? this.footerTemplate.templateRef : void 0;
  }
  /**
   * @hidden
   */
  get columnMenuTemplateRef() {
    const template = this.columnMenuTemplates.first;
    return template ? template.templateRef : null;
  }
  /**
   * @hidden
   */
  get displayTitle() {
    return this.title;
  }
  /**
   * @hidden
   */
  get isVisible() {
    return !this.hidden && this.matchesMedia;
  }
  _id;
  /**
   * @hidden
   */
  constructor(parent, idService) {
    this.parent = parent;
    this.idService = idService;
    if (parent && idService && parent.idService.gridId() === idService.gridId() && !isColumnContainer(parent)) {
      throw new Error(ColumnConfigurationErrorMessages.columnNested);
    }
    this._id = this.idService?.nextColumnId();
  }
  ngAfterViewInit() {
    this.initialMinResizableWidth = this.minResizableWidth || 10;
    this.initialMaxResizableWidth = this.maxResizableWidth || Number.MAX_SAFE_INTEGER;
  }
  static ɵfac = function ColumnBase_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColumnBase)(ɵɵdirectiveInject(_ColumnBase), ɵɵdirectiveInject(IdService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColumnBase,
    selectors: [["kendo-grid-column-base"]],
    contentQueries: function ColumnBase_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, FooterTemplateDirective3, 5)(dirIndex, HeaderTemplateDirective2, 4)(dirIndex, ColumnMenuTemplateDirective, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTemplates = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columnMenuTemplates = _t);
      }
    },
    inputs: {
      resizable: "resizable",
      reorderable: "reorderable",
      minResizableWidth: "minResizableWidth",
      maxResizableWidth: "maxResizableWidth",
      title: "title",
      width: "width",
      autoSize: "autoSize",
      locked: "locked",
      sticky: "sticky",
      hidden: "hidden",
      media: "media",
      lockable: "lockable",
      stickable: "stickable",
      columnMenu: "columnMenu",
      includeInChooser: "includeInChooser",
      tableCellsRole: "tableCellsRole",
      style: "style",
      headerStyle: "headerStyle",
      filterStyle: "filterStyle",
      footerStyle: "footerStyle",
      cssClass: [0, "class", "cssClass"],
      headerClass: "headerClass",
      filterClass: "filterClass",
      footerClass: "footerClass",
      cellRowspan: "cellRowspan"
    },
    decls: 0,
    vars: 0,
    template: function ColumnBase_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnBase2, [{
    type: Component,
    args: [{
      selector: "kendo-grid-column-base",
      template: ``
    }]
  }], () => [{
    type: ColumnBase2
  }, {
    type: IdService
  }], {
    resizable: [{
      type: Input
    }],
    reorderable: [{
      type: Input
    }],
    minResizableWidth: [{
      type: Input
    }],
    maxResizableWidth: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    autoSize: [{
      type: Input
    }],
    locked: [{
      type: Input
    }],
    sticky: [{
      type: Input
    }],
    hidden: [{
      type: Input
    }],
    media: [{
      type: Input
    }],
    lockable: [{
      type: Input
    }],
    stickable: [{
      type: Input
    }],
    columnMenu: [{
      type: Input
    }],
    includeInChooser: [{
      type: Input
    }],
    tableCellsRole: [{
      type: Input
    }],
    style: [{
      type: Input
    }],
    headerStyle: [{
      type: Input
    }],
    filterStyle: [{
      type: Input
    }],
    footerStyle: [{
      type: Input
    }],
    cssClass: [{
      type: Input,
      args: ["class"]
    }],
    headerClass: [{
      type: Input
    }],
    filterClass: [{
      type: Input
    }],
    footerClass: [{
      type: Input
    }],
    cellRowspan: [{
      type: Input
    }],
    headerTemplates: [{
      type: ContentChildren,
      args: [HeaderTemplateDirective2, {
        descendants: false
      }]
    }],
    footerTemplate: [{
      type: ContentChild,
      args: [FooterTemplateDirective3, {
        static: false
      }]
    }],
    columnMenuTemplates: [{
      type: ContentChildren,
      args: [ColumnMenuTemplateDirective]
    }]
  });
})();
var GroupHeaderTemplateDirective2 = class _GroupHeaderTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function GroupHeaderTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _GroupHeaderTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _GroupHeaderTemplateDirective,
    selectors: [["", "kendoGridGroupHeaderTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GroupHeaderTemplateDirective2, [{
    type: Directive,
    args: [{
      selector: "[kendoGridGroupHeaderTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var GroupHeaderColumnTemplateDirective2 = class _GroupHeaderColumnTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function GroupHeaderColumnTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _GroupHeaderColumnTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _GroupHeaderColumnTemplateDirective,
    selectors: [["", "kendoGridGroupHeaderColumnTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GroupHeaderColumnTemplateDirective2, [{
    type: Directive,
    args: [{
      selector: "[kendoGridGroupHeaderColumnTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var GroupFooterTemplateDirective2 = class _GroupFooterTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function GroupFooterTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _GroupFooterTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _GroupFooterTemplateDirective,
    selectors: [["", "kendoGridGroupFooterTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GroupFooterTemplateDirective2, [{
    type: Directive,
    args: [{
      selector: "[kendoGridGroupFooterTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var FilterCellTemplateDirective = class _FilterCellTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function FilterCellTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FilterCellTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FilterCellTemplateDirective,
    selectors: [["", "kendoGridFilterCellTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterCellTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridFilterCellTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var FilterMenuTemplateDirective = class _FilterMenuTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function FilterMenuTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FilterMenuTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FilterMenuTemplateDirective,
    selectors: [["", "kendoGridFilterMenuTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterMenuTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridFilterMenuTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
function isColumnComponent(column) {
  return isPresent7(column?.field);
}
var ColumnComponent2 = class _ColumnComponent extends ColumnBase2 {
  /**
   * Sets the field that the column binds to.
   */
  field;
  /**
   * Sets the format for displaying the column value.
   * For supported date and number formats, see the [Column Formats](slug:formats_columns_grid) article.
   */
  format;
  /**
   * Enables sorting when the user clicks the column header. [See example](slug:sorting_grid).
   * Emits the `sortChange` event.
   *
   * @default true
   */
  sortable = true;
  /**
   * Allows dragging the column to the group panel.
   * Set to `false` to group by this column only through the Grid API.
   *
   * @default true
   */
  groupable = true;
  /**
   * Sets the editor type for the column. [See example](slug:inline_editing_grid#toc-using-reactive-forms).
   * Used when the column enters edit mode.
   *
   * @default 'text'
   */
  editor = "text";
  /**
   * Sets the filter type for the filter row UI. [See example](slug:filtering_grid#toc-filter-data-types).
   *
   * @default 'text'
   */
  filter = "text";
  /**
   * Specifies the filter type for the filter menu UI.
   *
   * @default 'default'
   */
  filterVariant = "default";
  /**
   * Shows or hides the filter UI for this column. [See example](slug:filtering_grid).
   *
   * @default true
   */
  filterable = true;
  /**
   * Sets whether the column is editable. [See example](slug:make_fields_uneditable_grid).
   *
   * @default true
   */
  editable = true;
  template;
  groupHeaderTemplate;
  groupHeaderColumnTemplate;
  groupFooterTemplate;
  editTemplate;
  filterCellTemplate;
  filterMenuTemplate;
  constructor(parent, idService) {
    super(parent, idService);
  }
  get templateRef() {
    return this.template ? this.template.templateRef : void 0;
  }
  get groupHeaderTemplateRef() {
    return this.groupHeaderTemplate ? this.groupHeaderTemplate.templateRef : void 0;
  }
  get groupHeaderColumnTemplateRef() {
    return this.groupHeaderColumnTemplate ? this.groupHeaderColumnTemplate.templateRef : void 0;
  }
  get groupFooterTemplateRef() {
    return this.groupFooterTemplate ? this.groupFooterTemplate.templateRef : void 0;
  }
  get editTemplateRef() {
    return this.editTemplate ? this.editTemplate.templateRef : void 0;
  }
  get filterCellTemplateRef() {
    return this.filterCellTemplate ? this.filterCellTemplate.templateRef : void 0;
  }
  get filterMenuTemplateRef() {
    return this.filterMenuTemplate ? this.filterMenuTemplate.templateRef : void 0;
  }
  get displayTitle() {
    return this.title === void 0 ? this.field : this.title;
  }
  static ɵfac = function ColumnComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColumnComponent)(ɵɵdirectiveInject(ColumnBase2, 13), ɵɵdirectiveInject(IdService, 8));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColumnComponent,
    selectors: [["kendo-grid-column"]],
    contentQueries: function ColumnComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, CellTemplateDirective2, 5)(dirIndex, GroupHeaderTemplateDirective2, 5)(dirIndex, GroupHeaderColumnTemplateDirective2, 5)(dirIndex, GroupFooterTemplateDirective2, 5)(dirIndex, EditTemplateDirective, 5)(dirIndex, FilterCellTemplateDirective, 5)(dirIndex, FilterMenuTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.template = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.groupHeaderTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.groupHeaderColumnTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.groupFooterTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.editTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.filterCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.filterMenuTemplate = _t.first);
      }
    },
    inputs: {
      field: "field",
      format: "format",
      sortable: "sortable",
      groupable: "groupable",
      editor: "editor",
      filter: "filter",
      filterVariant: "filterVariant",
      filterable: "filterable",
      editable: "editable"
    },
    features: [ɵɵProvidersFeature([{
      provide: ColumnBase2,
      useExisting: forwardRef(() => _ColumnComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function ColumnComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnComponent2, [{
    type: Component,
    args: [{
      providers: [{
        provide: ColumnBase2,
        useExisting: forwardRef(() => ColumnComponent2)
      }],
      selector: "kendo-grid-column",
      template: ``,
      standalone: true
    }]
  }], () => [{
    type: ColumnBase2,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }, {
      type: Optional
    }]
  }, {
    type: IdService,
    decorators: [{
      type: Optional
    }]
  }], {
    field: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    sortable: [{
      type: Input
    }],
    groupable: [{
      type: Input
    }],
    editor: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    filterVariant: [{
      type: Input
    }],
    filterable: [{
      type: Input
    }],
    editable: [{
      type: Input
    }],
    template: [{
      type: ContentChild,
      args: [CellTemplateDirective2, {
        static: false
      }]
    }],
    groupHeaderTemplate: [{
      type: ContentChild,
      args: [GroupHeaderTemplateDirective2, {
        static: false
      }]
    }],
    groupHeaderColumnTemplate: [{
      type: ContentChild,
      args: [GroupHeaderColumnTemplateDirective2, {
        static: false
      }]
    }],
    groupFooterTemplate: [{
      type: ContentChild,
      args: [GroupFooterTemplateDirective2, {
        static: false
      }]
    }],
    editTemplate: [{
      type: ContentChild,
      args: [EditTemplateDirective, {
        static: false
      }]
    }],
    filterCellTemplate: [{
      type: ContentChild,
      args: [FilterCellTemplateDirective, {
        static: false
      }]
    }],
    filterMenuTemplate: [{
      type: ContentChild,
      args: [FilterMenuTemplateDirective, {
        static: false
      }]
    }]
  });
})();
function isSpanColumnComponent(column) {
  return column.isSpanColumn;
}
var SpanColumnComponent = class _SpanColumnComponent extends ColumnBase2 {
  /*
   * @hidden
   */
  isSpanColumn = true;
  template = new QueryList();
  editTemplate = new QueryList();
  /**
   * @hidden
   */
  children = new QueryList();
  /**
   * @hidden
   */
  title;
  /**
   * @hidden
   */
  headerStyle;
  /**
   * @hidden
   */
  footerStyle;
  /**
   * @hidden
   */
  headerClass;
  /**
   * @hidden
   */
  footerClass;
  /**
   * @hidden
   */
  includeInChooser = false;
  /**
   * Sets whether the edit template of the column is rendered.
   * To enable editing for a spanned column, set an edit template for it ([see example](slug:custom_editors_grid#setting-up-custom-editors)).
   * @default false
   */
  set editable(value2) {
    this._editable = value2;
  }
  get editable() {
    return isPresent7(this.editTemplateRef) && this._editable;
  }
  /**
   * @hidden
   * added for backwards compitability
   */
  set width(_value) {
  }
  get width() {
    return this.children.reduce((total, column) => total + column.width, 0);
  }
  /**
   * @hidden
   */
  get leafIndex() {
    return this.children.first.leafIndex;
  }
  _editable = true;
  constructor(parent, idService) {
    super(parent, idService);
    if (parent && parent.isSpanColumn) {
      throw new Error(ColumnConfigurationErrorMessages.nestedInside("SpanColumnComponent", "SpanColumnComponent"));
    }
  }
  /**
   * @hidden
   */
  get templateRef() {
    const template = this.template.first;
    return template ? template.templateRef : void 0;
  }
  /**
   * @hidden
   */
  get editTemplateRef() {
    const editTemplate = this.editTemplate.first;
    return editTemplate ? editTemplate.templateRef : void 0;
  }
  /**
   * @hidden
   */
  get colspan() {
    return this.children.filter((c) => c.isVisible).length;
  }
  /**
   * Toggles the locked (frozen) state of the columns ([see example](slug:locked_columns_grid)).
   * @default false
   */
  set locked(value2) {
    this._locked = value2;
  }
  get locked() {
    return this._locked || this.children.some((c) => c.locked);
  }
  get childrenArray() {
    return this.children.toArray();
  }
  get hasChildren() {
    return this.children.length > 0;
  }
  /**
   * @hidden
   *
   * Used to hide the cellRowspan property from the public API.
   */
  set cellRowspan(cellRowSpan) {
    super.cellRowspan = cellRowSpan;
  }
  static ɵfac = function SpanColumnComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SpanColumnComponent)(ɵɵdirectiveInject(ColumnBase2, 13), ɵɵdirectiveInject(IdService, 8));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _SpanColumnComponent,
    selectors: [["kendo-grid-span-column"]],
    contentQueries: function SpanColumnComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, CellTemplateDirective2, 4)(dirIndex, EditTemplateDirective, 4)(dirIndex, ColumnComponent2, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.template = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.editTemplate = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
      }
    },
    inputs: {
      editable: "editable",
      locked: "locked"
    },
    features: [ɵɵProvidersFeature([{
      provide: ColumnBase2,
      useExisting: forwardRef(() => _SpanColumnComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function SpanColumnComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SpanColumnComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: ColumnBase2,
        useExisting: forwardRef(() => SpanColumnComponent)
      }],
      selector: "kendo-grid-span-column",
      template: ``,
      standalone: true
    }]
  }], () => [{
    type: ColumnBase2,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }, {
      type: Optional
    }]
  }, {
    type: IdService,
    decorators: [{
      type: Optional
    }]
  }], {
    template: [{
      type: ContentChildren,
      args: [CellTemplateDirective2, {
        descendants: false
      }]
    }],
    editTemplate: [{
      type: ContentChildren,
      args: [EditTemplateDirective, {
        descendants: false
      }]
    }],
    children: [{
      type: ContentChildren,
      args: [ColumnComponent2]
    }],
    editable: [{
      type: Input
    }],
    locked: [{
      type: Input
    }]
  });
})();
var expandColumns = (columns) => columns.reduce((acc, column) => acc.concat(isSpanColumnComponent(column) ? column.childrenArray : [column]), []);
var expandColumnsWithSpan = (columns) => columns.reduce((acc, column) => acc.concat(isSpanColumnComponent(column) ? [column].concat(column.childrenArray) : [column]), []);
var columnsToRender = (columns) => expandColumns(columns).filter((x) => x.isVisible);
var sumProp = (prop2) => (array) => (array || []).reduce((prev, curr) => prev + (curr[prop2] || 0), 0);
var sumColumnWidths = sumProp("width");
var columnsSpan = sumProp("colspan");
var validField = new RegExp(`^[$A-Z_a-z][$A-Z_a-z0-9\\.]*$`);
var isValidFieldName = (fieldName) => !isNullOrEmptyString2(fieldName) && validField.test(fieldName) && fieldName[0] !== "." && fieldName[fieldName.length - 1] !== ".";
var children = (column) => column.children.filter((child) => child !== column);
var leafColumns = (columns) => {
  return columns.reduce((acc, column) => {
    if (column.isColumnGroup) {
      acc = acc.concat(leafColumns(children(column)));
    } else if (column.isSpanColumn) {
      acc = acc.concat(column.childrenArray);
    } else {
      acc.push(column);
    }
    return acc;
  }, []).filter((x) => x.isVisible);
};
var someLeafColumn = (callback, ...columns) => leafColumns(columns).some(callback);
var resizableColumns = (columns) => columns.filter((column) => isTruthy(column.resizable) && column.isVisible);
var sortColumns = (columns) => orderBy(columns, [{
  field: "orderIndex",
  dir: "asc"
}]);
var isInSpanColumn$1 = (column) => isTruthy(column.parent) && isSpanColumnComponent(column.parent);
var isLocked = (column) => column.parent ? isLocked(column.parent) : !!column.locked;
var resizeArgs = (column, extra) => Object.assign({
  columns: leafColumns([column]),
  locked: isLocked(column)
}, extra);
var measure = (col, gridEl) => {
  const rowIndex = col.level + 1;
  const selector = `tr[aria-rowindex="${rowIndex}"] > th[aria-colindex="${col.leafIndex + 1}"], tr[aria-rowindex="${rowIndex}"] > th[data-kendo-grid-column-index="${col.leafIndex}"]`;
  const headerCell = gridEl.querySelector(selector);
  if (headerCell) {
    const headerCellWidth = headerCell.offsetWidth;
    if (headerCellWidth > 0) {
      return headerCellWidth;
    }
  }
  return 0;
};
var ColumnResizingService = class _ColumnResizingService {
  changes = new EventEmitter();
  adjacentColumn;
  areColumnsReordered = false;
  isShiftPressed = false;
  originalWidth;
  draggedGroupColumn;
  resizedColumns;
  autoFitResize = false;
  column;
  tables = [];
  batch = null;
  start(column) {
    this.trackColumns(column);
    const columns = (this.column.isColumnGroup ? [column] : []).concat(leafColumns([column]));
    this.changes.emit({
      columns,
      locked: isLocked(this.column),
      type: "start"
    });
  }
  resizeColumns(deltaPercent) {
    const action = resizeArgs(this.column, {
      deltaPercent,
      type: "resizeColumn"
    });
    this.changes.emit(action);
  }
  resizeTable(column, delta) {
    const action = resizeArgs(column, {
      delta,
      type: "resizeTable"
    });
    this.changes.emit(action);
  }
  resizedColumn(state2) {
    this.resizedColumns.push(state2);
  }
  end() {
    this.changes.emit({
      columns: [],
      resizedColumns: this.resizedColumns,
      type: "end"
    });
    this.restoreInitialMaxMinWidths();
    this.adjacentColumn = null;
    this.draggedGroupColumn = null;
    this.autoFitResize = false;
  }
  registerTable(tableMetadata) {
    this.tables.push(tableMetadata);
    const unregisterTable = () => {
      this.tables.splice(this.tables.indexOf(tableMetadata), 1);
    };
    return unregisterTable;
  }
  measureColumns(info) {
    if (this.batch !== null) {
      this.batch.push(...info);
    } else {
      this.autoFitBatch(info, () => this.end());
    }
  }
  autoFit(...columns) {
    const nonLockedColumns = columns.filter((column) => !column.isLocked);
    this.autoFitStart(nonLockedColumns);
    this.autoFitBatch(this.batch, () => {
      if (nonLockedColumns.length < columns.length) {
        const lockedColumns = columns.filter((column) => column.isLocked);
        this.autoFitStart(lockedColumns);
        this.autoFitBatch(this.batch, () => this.end());
      } else {
        this.end();
      }
    });
  }
  autoFitToGrid(gridEl, scrollbarWidth2, ...columns) {
    const gridWidth = gridEl.clientWidth - scrollbarWidth2 - 1;
    if (gridWidth <= 0) {
      return;
    }
    const columnsWidths = columns.map((c) => measure(c, gridEl));
    const totalColumnsWidth = columnsWidths.reduce((sum, w) => sum + w, 0);
    if (totalColumnsWidth === 0 || Math.abs(totalColumnsWidth - gridWidth) <= 1) {
      return;
    }
    this.start(columns[0]);
    const calculateNewWidths = (columnsWidths2) => {
      const totalWidth = columnsWidths2.reduce((s, w) => s + w, 0);
      const nonZeroColumns = columnsWidths2.filter((w) => w > 0).length;
      const diff = (gridWidth - totalWidth) / nonZeroColumns;
      const newWidths2 = columnsWidths2.slice();
      newWidths2.forEach((w, i) => {
        newWidths2[i] = Math.max(0, w + diff);
      });
      return newWidths2;
    };
    let newWidths = calculateNewWidths(columnsWidths);
    const newTotal = newWidths.reduce((s, w) => s + w, 0);
    if (newTotal !== gridWidth) {
      newWidths = calculateNewWidths(newWidths);
    }
    columns.forEach((col, idx4) => {
      const oldWidth = columnsWidths[idx4];
      const newWidth = newWidths[idx4];
      col.width = newWidth;
      this.resizedColumn({
        column: col,
        oldWidth,
        newWidth
      });
    });
    const totalNew = newWidths.reduce((s, w) => s + w, 0);
    const tableDelta = totalNew - totalColumnsWidth;
    if (tableDelta < 0) {
      this.resizeTable(columns[0], tableDelta);
    }
    this.end();
  }
  trackColumns(column) {
    this.resizedColumns = [];
    this.column = column;
  }
  autoFitStart(columns) {
    this.batch = [];
    this.resizedColumns = [];
    if (columns.length === 0) {
      return;
    }
    const locked = columns[0].isLocked;
    this.changes.emit({
      type: "start",
      columns,
      locked
    });
    this.changes.emit({
      type: "triggerAutoFit",
      columns,
      locked
    });
  }
  autoFitBatch(info, onComplete) {
    const locked = info.length > 0 ? info[0].column.isLocked : false;
    const observables = this.tables.filter((table2) => table2.locked === locked).map((table2) => table2.autoFit(info));
    zip(...observables).pipe(take(1)).subscribe((widths) => {
      this.changes.emit({
        columns: info.map((i) => i.column),
        type: "autoFitComplete",
        widths,
        locked
      });
      if (onComplete) {
        onComplete();
      }
    });
    this.batch = null;
  }
  restoreInitialMaxMinWidths() {
    if (this.adjacentColumn) {
      this.adjacentColumn.maxResizableWidth = this.adjacentColumn.initialMaxResizableWidth;
      this.adjacentColumn.minResizableWidth = this.adjacentColumn.initialMinResizableWidth;
    }
    if (this.column) {
      this.column.maxResizableWidth = this.column.initialMaxResizableWidth;
      this.column.minResizableWidth = this.column.initialMinResizableWidth;
    }
  }
  static ɵfac = function ColumnResizingService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColumnResizingService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ColumnResizingService,
    factory: _ColumnResizingService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnResizingService, [{
    type: Injectable
  }], null, null);
})();
var isInSameGrid = (element, gridElement) => closest5(element, matchesNodeName("kendo-grid")) === gridElement;
var matchHeaderCell = matchesNodeName("th");
var matchDataCell = matchesNodeName("td");
var matchFooterCell = matchesNodeName(".k-grid-footer td");
var matchCell = (element) => matchDataCell(element) || matchHeaderCell(element) || matchFooterCell(element);
var gridCell = (element, gridElement) => {
  let target = closest5(element, matchCell);
  while (target && !isInSameGrid(target, gridElement)) {
    target = closest5(target.parentElement, matchCell);
  }
  return target;
};
var targetCell = (target, gridElement) => {
  const cell2 = gridCell(target, gridElement);
  const row2 = closest5(cell2, matchesNodeName("tr"));
  if (cell2 && row2) {
    let rowIndex = row2.getAttribute("aria-rowindex") || row2.getAttribute("data-kendo-grid-row-index");
    rowIndex = rowIndex ? parseInt(rowIndex, 10) - 1 : null;
    let colIndex = cell2.getAttribute("aria-colindex");
    colIndex = colIndex ? parseInt(colIndex, 10) - 1 : null;
    if (rowIndex !== null && colIndex !== null) {
      return {
        colIndex,
        rowIndex,
        element: cell2
      };
    }
  }
};
var isArrowKey2 = (keyCode) => keyCode === Keys.ArrowLeft || keyCode === Keys.ArrowRight || keyCode === Keys.ArrowUp || keyCode === Keys.ArrowDown;
var isNavigationKey2 = (keyCode) => isArrowKey2(keyCode) || keyCode === Keys.PageUp || keyCode === Keys.PageDown || keyCode === Keys.Home || keyCode === Keys.End;
var isInput = matchesNodeName("input");
var isTextInput = (element) => element && isInput(element) && element.type.toLowerCase() === "text";
var isPrintableCharacter2 = (str) => str.length === 1 && str.match(/\S/);
var resizeStep = 10;
var NavigationViewport = class {
  firstItemIndex;
  lastItemIndex;
  constructor(firstItemIndex, lastItemIndex) {
    this.firstItemIndex = firstItemIndex;
    this.lastItemIndex = lastItemIndex;
  }
  containsRow(dataRowIndex) {
    const headerRow2 = dataRowIndex < 0;
    return headerRow2 || dataRowIndex >= this.firstItemIndex && dataRowIndex <= this.lastItemIndex;
  }
  intersects(start, end) {
    return start <= this.firstItemIndex && this.lastItemIndex <= end || this.firstItemIndex <= start && start <= this.lastItemIndex || this.firstItemIndex <= end && end <= this.lastItemIndex;
  }
};
var NavigationService4 = class _NavigationService {
  zone;
  domEvents;
  pagerContextService;
  scrollRequestService;
  groupsService;
  detailsService;
  focusRoot;
  editService;
  cd;
  ctx;
  resizeService;
  focusableParent;
  changes;
  cellKeydown = new EventEmitter();
  set metadata(value2) {
    this.meta = value2;
    this.cursor.metadata = value2;
  }
  get metadata() {
    return this.meta;
  }
  get enabled() {
    return this.alive;
  }
  get pagerEnabled() {
    return this.alive && this.pagerIsNavigable;
  }
  get tableEnabled() {
    return this.alive && this.tableIsNavigable;
  }
  get toolbarEnabled() {
    return this.alive && this.toolbarIsNavigable;
  }
  get activeCell() {
    if (this.mode !== 0) {
      return this.cursor.cell;
    }
  }
  get activeRow() {
    if (this.mode !== 0) {
      return Object.assign({}, this.cursor.row, {
        cells: this.cursor.row?.cells.toArray()
      });
    }
  }
  get isColumnResizable() {
    const allColumns = Array.from(this.ctx.grid.columnsContainer.allColumns);
    const column = allColumns.find((col) => col.level === this.activeCell.rowIndex && col.leafIndex === this.activeCell.colIndex);
    if (!column.parent) {
      if (column.isColumnGroup) {
        return this.activeCell.colIndex + this.activeCell.colSpan !== this.ctx.grid.columnsContainer.leafColumnsToRender.length;
      } else {
        return this.activeCell.colIndex !== this.ctx.grid.columnsContainer.leafColumnsToRender.length - 1;
      }
    } else {
      const columnGroup = column.parent;
      const columnGroupChildren = Array.from(columnGroup.children).sort((a, b) => a.orderIndex - b.orderIndex);
      const columnIndexInsideGroup = columnGroupChildren.indexOf(column);
      if (column.isReordered || column.orderIndex > 0 || column.isReordered && column.orderIndex === 0) {
        return column.orderIndex - columnGroupChildren[0]["orderIndex"] !== columnGroupChildren.length - 1;
      }
      return columnIndexInsideGroup !== columnGroupChildren.length - 1;
    }
  }
  preventScroll = false;
  viewport;
  columnViewport;
  activeRowIndex = 0;
  alive = false;
  active = true;
  mode = 0;
  model = new NavigationModel();
  cursor = new NavigationCursor(this.model);
  meta;
  subs;
  pendingRowIndex;
  virtualCell;
  pagerIsNavigable = false;
  tableIsNavigable = false;
  toolbarIsNavigable = false;
  lastCellRowIndex;
  isShiftPressed = false;
  currentSelection = [];
  get activeDataRow() {
    return Math.min(Math.max(0, this.activeRowIndex - this.meta.headerRows), this.meta.maxLogicalRowIndex);
  }
  constructor(zone, domEvents, pagerContextService, scrollRequestService, groupsService, detailsService, focusRoot, editService, cd, ctx, resizeService, focusableParent) {
    this.zone = zone;
    this.domEvents = domEvents;
    this.pagerContextService = pagerContextService;
    this.scrollRequestService = scrollRequestService;
    this.groupsService = groupsService;
    this.detailsService = detailsService;
    this.focusRoot = focusRoot;
    this.editService = editService;
    this.cd = cd;
    this.ctx = ctx;
    this.resizeService = resizeService;
    this.focusableParent = focusableParent;
    this.changes = this.cursor.changes;
  }
  init(meta, navigableOptions) {
    this.setActiveSections(navigableOptions);
    this.alive = true;
    this.focusRoot.active = true;
    this.metadata = meta;
    const onStableSubscriber = (...operators) => (args) => this.zone.isStable ? from([true]).pipe(map(() => args)) : this.zone.onStable.pipe(take(1), map(() => args), ...operators);
    const onStable = onStableSubscriber();
    this.subs = new Subscription();
    this.subs.add(this.cursor.changes.subscribe((args) => this.onCursorChanges(args)));
    this.subs.add(this.domEvents.focus.pipe(switchMap(onStable)).subscribe((args) => this.navigateTo(args.target)));
    this.subs.add(this.domEvents.focusOut.pipe(filter(
      () => this.mode !== 0
      /* NavigationMode.Standby */
    ), switchMap(onStableSubscriber(takeUntil(this.domEvents.focus)))).subscribe((args) => this.onFocusOut(args)));
    this.subs.add(this.domEvents.windowBlur.pipe(filter(
      () => this.mode !== 0
      /* NavigationMode.Standby */
    )).subscribe(() => this.onWindowBlur()));
    this.subs.add(
      // Closing the editor will not always trigger focusout in Firefox.
      // To get around this, we ensure that the cell is closed after editing.
      this.editService.changes.pipe(filter(
        (e) => e.action !== "edit" && this.mode === 2
        /* NavigationMode.Content */
      ), filter((e) => e.action === "cellClose" && !e.prevented), switchMap(onStable)).subscribe((e) => {
        const isInStackedCell = closest5(e.originalEvent?.target, (el) => hasClasses(el, "k-grid-stack-content"));
        if (!isInStackedCell) {
          this.leaveCell();
        }
      })
    );
    this.subs.add(this.pagerContextService.pageChange.subscribe(() => this.cursor.reset(0, 0)));
    this.subs.add(this.domEvents.keydown.subscribe((args) => this.onKeydown(args)));
    this.subs.add(this.domEvents.shiftKeyup.subscribe(() => {
      this.isShiftPressed = false;
    }));
    this.subs.add(this.domEvents.keydown.pipe(filter(
      (args) => args.code === Keys.Tab && this.mode === 2
      /* NavigationMode.Content */
    ), switchMapTo(this.domEvents.focusOut.pipe(takeUntil(
      // Timeout if focusOut doesn't fire very soon
      interval(0).pipe(take(1))
    )))).subscribe(() => this.onTabout()));
    this.subs.add(this.domEvents.cellClick.subscribe(() => {
      if (this.isStackedMode) {
        const stackedCells = this.activeCell?.focusGroup?.focusableChildren;
        if (!isPresent(stackedCells) || stackedCells.length === 0) {
          return;
        }
        const currFocusedIndex = stackedCells.findIndex((el) => el.hasFocus() || el.hostElement?.nativeElement === document.activeElement);
        currFocusedIndex > -1 && (this.stackedFocusedCellIndex = currFocusedIndex);
      }
    }));
    if (this.focusableParent) {
      const element = new GridFocusableElement(this);
      this.focusableParent.registerElement(element);
    }
    this.deactivateElements();
  }
  ngOnDestroy() {
    if (this.subs) {
      this.subs.unsubscribe();
    }
    this.alive = false;
  }
  registerCell(cell2) {
    if (cell2.logicalRowIndex !== this.pendingRowIndex) {
      const modelCell = this.model.registerCell(cell2);
      if (this.virtualCell && this.cursor.activateVirtualCell(modelCell)) {
        this.virtualCell = false;
      }
    }
  }
  registerCellOnCurrentRow(cell2) {
    if (cell2.logicalRowIndex === this.pendingRowIndex) {
      this.model.registerCell(cell2);
    }
  }
  unregisterCell(index, rowIndex, cell2) {
    this.model.unregisterCell(index, rowIndex, cell2);
  }
  registerRow(row2) {
    this.model.registerRow(row2);
    this.pendingRowIndex = row2.logicalRowIndex;
  }
  updateRow(row2) {
    this.model.updateRow(row2);
  }
  unregisterRow(index, row2) {
    this.model.unregisterRow(index, row2);
    const lastRow = this.model.lastRow;
    if (lastRow && this.mode === 0) {
      const maxIndex = this.needsViewport() && this.viewport ? this.viewport.lastItemIndex : lastRow.index;
      if (this.activeRowIndex > maxIndex) {
        this.cursor.reset(0, 0);
      }
    }
  }
  isCellFocusable(cell2) {
    return this.alive && this.active && this.mode !== 2 && this.cursor.isActive(cell2.logicalRowIndex, cell2.logicalColIndex);
  }
  isCellFocused(cell2) {
    return this.mode === 1 && this.isCellFocusable(cell2);
  }
  navigateTo(el) {
    if (!this.alive || !isDocumentAvailable()) {
      return;
    }
    const cell2 = targetCell(el, this.meta.gridElement.nativeElement);
    if (!cell2) {
      return;
    }
    const oldMode = this.mode;
    const focusInCell = contains$1(cell2.element, document.activeElement);
    const focusInActiveRowContent = this.mode === 2 && this.activeRowIndex === cell2.rowIndex && el !== cell2.element;
    if (focusInCell) {
      this.mode = 2;
      this.cursor.reset(cell2.rowIndex, cell2.colIndex);
      this.activateRow();
    } else if (!focusInActiveRowContent) {
      this.mode = 1;
      this.deactivateElements();
      const alreadyActive = this.cursor.isActive(cell2.rowIndex, cell2.colIndex);
      const isCursor = oldMode === 1 && alreadyActive;
      if (!isCursor) {
        this.cursor.reset(cell2.rowIndex, cell2.colIndex);
      }
    }
  }
  tryFocus(el) {
    this.activateElements();
    const focusable = findFocusableChild(el);
    if (focusable) {
      const cell2 = targetCell(focusable, this.meta.gridElement.nativeElement);
      if (cell2) {
        this.cursor.reset(cell2.rowIndex, cell2.colIndex);
        this.deactivateElements();
        this.enterCell();
      }
      this.zone.runOutsideAngular(() => {
        setTimeout(() => {
          focusable.focus();
        });
      });
    } else {
      this.deactivateElements();
    }
    return !!focusable;
  }
  needsViewport() {
    return this.meta && this.meta.isVirtual;
  }
  setViewport(firstItemIndex, lastItemIndex) {
    this.viewport = new NavigationViewport(firstItemIndex, lastItemIndex);
    if (this.meta && this.meta.isVirtual && this.activeDataRow > -1) {
      const dataRowIndex = this.activeDataRow;
      const ahead = firstItemIndex - dataRowIndex;
      const behind = dataRowIndex - lastItemIndex;
      if (ahead > 0) {
        this.cursor.reset(firstItemIndex + this.meta.headerRows);
      } else if (behind > 0) {
        this.cursor.reset(lastItemIndex - this.meta.headerRows);
      }
    }
  }
  setColumnViewport(firstItemIndex, lastItemIndex) {
    this.columnViewport = new NavigationViewport(firstItemIndex, lastItemIndex);
    if (this.meta && this.meta.isVirtual && this.activeDataRow > -1) {
      const activeColumnIndex = this.cursor.cell ? this.cursor.cell.colIndex : 0;
      const ahead = firstItemIndex - activeColumnIndex;
      const behind = activeColumnIndex - lastItemIndex;
      if (ahead > 0) {
        this.cursor.reset(void 0, firstItemIndex, false);
      } else if (behind > 0) {
        this.cursor.reset(void 0, lastItemIndex, false);
      }
    }
  }
  focusCell(rowIndex = void 0, colIndex = void 0) {
    this.mode = 1;
    this.cursor.reset(rowIndex, colIndex);
    return this.activeCell;
  }
  focusCellByElement(el) {
    const cell2 = targetCell(el, this.meta.gridElement.nativeElement);
    if (cell2) {
      return this.focusCell(cell2.rowIndex, cell2.colIndex);
    }
  }
  focusNextCell(wrap = true) {
    return this.focusAdjacentCell(true, wrap);
  }
  focusPrevCell(wrap = true) {
    return this.focusAdjacentCell(false, wrap);
  }
  toggle(active) {
    this.active = active;
    this.cursor.announce();
  }
  hasFocus() {
    return this.mode === 1 || this.mode === 2;
  }
  autoFocusCell(start, end) {
    return !this.meta.virtualColumns || end < this.meta.columns.lockedLeafColumns.length || this.columnViewport.intersects(start, end);
  }
  setActiveSections(navigableOptions) {
    this.pagerIsNavigable = navigableOptions.includes("pager");
    this.tableIsNavigable = navigableOptions.includes("table");
    this.toolbarIsNavigable = navigableOptions.includes("toolbar");
  }
  focusAdjacentCell(fwd, wrap) {
    this.focusCell();
    let success = fwd ? this.moveCursorFwd() : this.moveCursorBwd();
    if (wrap && !success) {
      success = fwd ? this.cursor.moveDown(1) : this.cursor.moveUp(1);
      if (success) {
        const row2 = this.cursor.row;
        const colIdx = fwd || this.isStackedMode ? 0 : this.cursor.lastCellIndex(row2);
        this.cursor.reset(row2.index, colIdx);
      }
    }
    if (success) {
      return this.activeCell;
    } else {
      this.mode = 0;
      this.cursor.announce();
    }
    return null;
  }
  enterCell() {
    const cell2 = this.cursor.cell;
    if (!cell2) {
      return;
    }
    if (this.tableCellEntered && this.isStackedMode) {
      this.stackedCellEntered = true;
    } else {
      this.tableCellEntered = true;
    }
    const group2 = cell2.focusGroup;
    const focusable = group2 && group2.canFocus();
    this.mode = focusable ? 2 : 1;
    this.cursor.announce();
    if (focusable) {
      this.activateRow();
      group2.focus();
      if (this.isStackedMode && this.stackedFocusedCellIndex === -1) {
        this.stackedFocusedCellIndex = 0;
      }
    }
  }
  leaveCell() {
    const cell2 = this.cursor.cell;
    if (!cell2) {
      return;
    }
    if (this.tableCellEntered) {
      if (this.stackedCellEntered) {
        this.stackedCellEntered = false;
      } else {
        this.tableCellEntered = false;
      }
    }
    const group2 = cell2.focusGroup;
    const focusable = group2 && group2.canFocus();
    if (!focusable) {
      this.deactivateElements();
    }
    if (this.isStackedMode && this.stackedFocusedCellIndex > -1) {
      this.stackedFocusedCellIndex = -1;
    }
    this.mode = 1;
    this.cursor.announce();
  }
  activateElements() {
    this.focusRoot.activate();
  }
  deactivateElements() {
    this.focusRoot.deactivate();
  }
  activateRow() {
    this.cursor.row.cells.forEach((cell2) => cell2.focusGroup && cell2.focusGroup.activate());
  }
  moveCursorFwd() {
    this.lastCellRowIndex = this.activeCell?.rowIndex;
    return this.ctx.localization.rtl ? this.cursor.moveLeft() : this.cursor.moveRight();
  }
  moveCursorBwd() {
    this.lastCellRowIndex = this.activeCell?.rowIndex;
    return this.ctx.localization.rtl ? this.cursor.moveRight() : this.cursor.moveLeft();
  }
  onCursorKeydown(args) {
    let preventDefault3 = false;
    const modifier = args.ctrlKey || args.metaKey;
    let step = modifier ? 5 : 1;
    const rowspan = +args.target?.getAttribute("rowspan");
    let rowspanOffset = 0;
    let startNewSelection = false;
    const allowMultipleRanges = this.ctx.grid.selectionService.active && this.ctx.grid.selectableSettings?.multipleRanges || this.ctx.grid.cellSelectionService.active && this.ctx.grid.cellSelectionService?.options?.multipleRanges;
    if (!allowMultipleRanges) {
      this.currentSelection = [];
    }
    if (!this.onCellKeydown(args)) {
      return;
    }
    const row2 = this.cursor.row;
    const code = normalizeKeys(args);
    if (modifier && args.shiftKey && (code === Keys.ArrowUp || code === Keys.ArrowDown)) {
      if (this.handleRowReorderKeyboard(args, code, row2)) {
        args.preventDefault();
        return;
      }
    }
    const dir = code === Keys.ArrowDown ? "Down" : "Up";
    const right2 = code === Keys.ArrowRight;
    const isArrowKey3 = code === Keys.ArrowDown || code === Keys.ArrowUp || code === Keys.ArrowLeft || code === Keys.ArrowRight;
    if (!this.isShiftPressed && args.shiftKey && isArrowKey3) {
      startNewSelection = true;
      this.isShiftPressed = true;
    }
    const cellElement = args.target;
    const isDragCell = cellElement ? closest5(cellElement, (el) => hasClasses(el, "k-drag-cell")) : false;
    const isRowReorderable = this.ctx.grid.rowReorderable;
    switch (code) {
      case Keys.ArrowDown:
      case Keys.ArrowUp:
        if (rowspan > 1) {
          rowspanOffset = this.calculateRowspanOffset(dir, rowspan);
          step += rowspanOffset;
        }
        if (args.shiftKey && !(isDragCell && isRowReorderable)) {
          if (this.ctx.grid.blockArrowSelection) {
            return;
          }
          preventDefault3 = this.cursor[`move${dir}`](step);
          const preserveCurrentSelection = startNewSelection && allowMultipleRanges;
          if (this.activeRow?.dataItem) {
            const sign = dir === "Down" ? 1 : -1;
            this.handleVerticalArrowSelection(sign * step, preserveCurrentSelection);
          }
        } else {
          preventDefault3 = this.cursor[`move${dir}`](step);
        }
        this.lastCellRowIndex = this.activeRowIndex;
        break;
      case Keys.ArrowRight:
      case Keys.ArrowLeft:
        if (args.altKey && this.ctx.grid.resizable && this.isColumnResizable) {
          this.columnResize(right2);
          break;
        }
        if (args.shiftKey) {
          if (this.ctx.grid.blockArrowSelection) {
            return;
          }
          preventDefault3 = this[`moveCursor${right2 ? "Fwd" : "Bwd"}`]();
          const preserveCurrentSelection = startNewSelection && allowMultipleRanges;
          this.handleHorizontalArrowSelection(args, preserveCurrentSelection);
        } else {
          preventDefault3 = this[`moveCursor${right2 ? "Fwd" : "Bwd"}`]();
        }
        break;
      case Keys.PageDown:
        if (this.metadata.isVirtual && this.viewport) {
          let nextItemIndex = this.meta.headerRows + this.viewport.lastItemIndex + 1;
          if (this.metadata.hasDetailTemplate) {
            nextItemIndex++;
          }
          nextItemIndex = Math.min(this.meta.maxLogicalRowIndex, nextItemIndex);
          this.cursor.reset(nextItemIndex);
          preventDefault3 = true;
        } else if (this.metadata.hasPager) {
          this.zone.run(() => this.pagerContextService.nextPage());
          preventDefault3 = true;
        }
        break;
      case Keys.PageUp:
        if (this.metadata.isVirtual && this.viewport) {
          const viewportSize = this.viewport.lastItemIndex - this.viewport.firstItemIndex;
          const firstItemIndex = this.viewport.firstItemIndex;
          const nextItemIndex = Math.max(this.meta.headerRows, firstItemIndex - viewportSize - 1);
          this.cursor.reset(nextItemIndex);
          preventDefault3 = true;
        } else if (this.metadata.hasPager) {
          this.zone.run(() => this.pagerContextService.prevPage());
          preventDefault3 = true;
        }
        break;
      case Keys.Home:
        if (modifier) {
          if (this.meta.isVirtual) {
            this.cursor.reset(this.meta.headerRows, 0, false);
          } else {
            this.cursor.reset(this.model.firstRow.index, 0, false);
          }
        } else {
          let firstColumnIndex = 0;
          if (this.meta.hasDetailTemplate && row2.index < this.meta.headerRows) {
            firstColumnIndex = 1;
          }
          this.cursor.reset(row2.index, firstColumnIndex, false);
        }
        preventDefault3 = true;
        break;
      case Keys.End:
        if (modifier) {
          if (this.meta.isVirtual) {
            let lastRowIndex = this.meta.maxLogicalRowIndex;
            if (this.meta.hasDetailTemplate) {
              lastRowIndex--;
            }
            this.cursor.reset(lastRowIndex, this.cursor.lastCellIndex(), false);
          } else {
            this.cursor.reset(this.model.lastRow.index, this.cursor.lastCellIndex(this.model.lastRow), false);
          }
        } else {
          const lastIndex = this.cursor.lastCellIndex(row2);
          const cell2 = this.model.findCell(lastIndex, row2);
          if (cell2) {
            this.cursor.reset(cell2.rowIndex, cell2.colIndex);
          } else {
            this.cursor.reset(row2.index, lastIndex);
          }
        }
        preventDefault3 = true;
        break;
      case Keys.Enter:
      case Keys.F2: {
        if (this.stackedCellEntered) {
          if (code === Keys.F2 && row2.dataRowIndex > -1) {
            this.zone.run(() => {
              this.editService.beginEdit(row2.dataRowIndex);
            });
            this.enterCell();
          }
          break;
        }
        const groupItem = row2.groupItem;
        if (groupItem) {
          this.zone.run(() => this.groupsService.toggleRow(groupItem));
        } else if (this.cursor.cell.detailExpandCell) {
          this.zone.run(() => this.detailsService.toggleRow(row2.dataRowIndex, row2.dataItem));
        } else {
          if (code === Keys.F2 && row2.dataRowIndex > -1) {
            this.zone.run(() => {
              this.editService.beginEdit(row2.dataRowIndex);
            });
          }
          this.enterCell();
          if (!this.cursor.cell.focusGroup.isNavigable()) {
            preventDefault3 = true;
          }
        }
        break;
      }
      case Keys.Backspace:
      case Keys.Delete:
        if (this.activeRow && this.activeRow.dataRowIndex >= 0 && this.activeRow.dataItem) {
          if (!row2.groupItem && !this.cursor.cell.detailExpandCell) {
            this.zone.run(() => {
              this.editService.remove(this.activeRow.dataRowIndex);
            });
            preventDefault3 = true;
          }
        }
        break;
      default:
        if (!args.ctrlKey && !args.altKey && isPrintableCharacter2(args.key)) {
          this.enterCell();
        }
    }
    if (preventDefault3) {
      args.preventDefault();
    }
  }
  columnResize(onRightArrow) {
    const column = this.ctx.grid.columnsContainer.allColumns.find((col) => col.level === this.activeCell.rowIndex && col.leafIndex === this.activeCell.colIndex);
    this.resizeService.start(column);
    this.resizeService.resizeColumns(onRightArrow ? resizeStep : -1 * resizeStep);
    if (this.resizeService.resizeColumns.length > 0) {
      this.resizeService.end();
    }
  }
  onContentKeydown(args) {
    if (!this.onCellKeydown(args)) {
      return;
    }
    const code = normalizeKeys(args);
    const confirm = !args.defaultPrevented && code === Keys.Enter && isTextInput(args.target);
    if (code === Keys.Escape || code === Keys.F2 || confirm) {
      if (this.tableCellEntered && code === Keys.F2 && this.activeRow.dataRowIndex > -1) {
        this.zone.run(() => {
          this.editService.beginEdit(this.activeRow.dataRowIndex);
        });
        this.enterCell();
        return;
      }
      this.leaveCell();
      this.cursor.reset();
      args.stopPropagation();
    } else if (isNavigationKey2(code) && this.cursor.cell.focusGroup.isNavigable()) {
      this.onCursorKeydown(args);
      if (args.defaultPrevented) {
        this.leaveCell();
      }
    }
  }
  onCellKeydown(args) {
    if (this.editService.isEditingCell()) {
      const code = normalizeKeys(args);
      const confirm = code === Keys.Enter;
      const cancel = code === Keys.Escape;
      const navigate = isNavigationKey2(code);
      if (confirm) {
        this.editService.closeCell(args);
      } else if (cancel) {
        this.editService.closeCell(args);
        this.cd.detectChanges();
      } else if (navigate) {
        return false;
      }
    }
    this.cellKeydown.emit(args);
    return true;
  }
  onCursorChanges(args) {
    this.activeRowIndex = args.rowIndex;
    const dataRowIndex = this.activeDataRow;
    if (this.meta && this.meta.isVirtual && args.rowIndex >= this.meta.headerRows && args.rowIndex <= this.meta.maxLogicalRowIndex - this.meta.footerRow && this.viewport && !this.viewport.containsRow(dataRowIndex) && dataRowIndex > -1) {
      this.scrollRequestService.scrollTo({
        row: dataRowIndex
      });
    }
    if (this.meta.virtualColumns && args.colIndex >= this.meta.columns.lockedLeafColumns.length) {
      const cell2 = this.activeCell;
      const {
        start,
        end
      } = this.model.cellRange(cell2);
      if (!cell2) {
        this.virtualCell = true;
      }
      if (!cell2 && this.mode !== 0 || cell2 && !this.columnViewport.intersects(start, end)) {
        this.scrollRequestService.scrollTo({
          column: args.colIndex - (this.metadata.hasDetailTemplate ? 1 : 0)
        });
      }
    }
  }
  onFocusOut(args) {
    if (isVisible2(args.target)) {
      this.mode = 0;
    } else {
      this.mode = 1;
    }
    this.deactivateElements();
    this.cursor.announce();
  }
  onWindowBlur() {
    this.mode = 0;
    this.deactivateElements();
    this.cursor.announce();
  }
  onKeydown(args) {
    if (this.isStackedMode) {
      this.handleStackedKeydown(args);
      if (args.defaultPrevented) {
        return;
      }
    }
    if (this.mode === 1) {
      this.onCursorKeydown(args);
    } else if (this.mode === 2) {
      this.onContentKeydown(args);
    }
  }
  onTabout() {
    if (this.cursor.cell?.focusGroup.isNavigable()) {
      return;
    }
    this.leaveCell();
    this.cursor.reset();
  }
  handleVerticalArrowSelection(args, preserveSelection) {
    const cellSelectionEnabled = this.ctx.grid.cellSelectionService.active;
    const rowSelectionEnabled = this.ctx.grid.selectionService.active && !this.ctx.grid.selectableSettings.checkboxOnly;
    if (cellSelectionEnabled || rowSelectionEnabled) {
      const selectionService = this.ctx.grid[cellSelectionEnabled ? "cellSelectionService" : "selectionService"];
      const colIdx = this.cursor.cell ? this.cursor.cell.colIndex : 0;
      const rowIdx = this.activeRow.dataRowIndex - this.ctx.grid.skip;
      const dataItem = selectionService.settings.view.at(rowIdx);
      const item = {
        index: this.activeRow.dataRowIndex,
        data: dataItem,
        column: this.ctx.grid.columnsContainer.leafColumnsToRender[colIdx]
      };
      if (selectionService.options.mode === "multiple") {
        const startRowIndex = this.activeRow.dataRowIndex - args;
        cellSelectionEnabled ? this.handleMultipleArrowCellSelection(item, preserveSelection, startRowIndex, colIdx) : this.handleMultipleArrowRowSelection(item, preserveSelection, startRowIndex);
      } else {
        selectionService.handleClick(item, args);
      }
    }
  }
  handleHorizontalArrowSelection(args, preserveSelection) {
    const cellSelectionEnabled = this.ctx.grid.cellSelectionService.active;
    if (cellSelectionEnabled) {
      const selectionService = this.ctx.grid[cellSelectionEnabled ? "cellSelectionService" : "selectionService"];
      const row2 = this.activeRow;
      const colIdx = this.cursor.cell ? this.cursor.cell.colIndex : 0;
      const dataItem = selectionService.settings.view.at(row2.dataRowIndex - this.ctx.grid.skip);
      const item = {
        index: row2.dataRowIndex,
        data: dataItem,
        column: this.ctx.grid.columnsContainer.leafColumnsToRender[colIdx]
      };
      if (!isPresent(dataItem) || !isPresent(item.column)) {
        return;
      }
      if (selectionService.options.mode === "multiple") {
        const startColumnIndex = args.key === "ArrowRight" ? colIdx - 1 : colIdx + 1;
        this.handleMultipleArrowCellSelection(item, preserveSelection, row2.dataRowIndex, startColumnIndex);
      } else {
        selectionService.handleClick(item, args);
      }
    }
  }
  handleMultipleArrowCellSelection(item, preserveSelection, startRow, startColumn) {
    const cellSelectionService = this.ctx.grid.cellSelectionService;
    const startRowIndex = preserveSelection ? startRow : Math.min(cellSelectionService.lastSelectionItemRowIndex, item.index);
    const startColIndex = preserveSelection ? startColumn : Math.min(cellSelectionService.lastSelectionItemColIndex, item.column.leafIndex);
    const endRowIndex = preserveSelection ? item.index : Math.max(cellSelectionService.lastSelectionItemRowIndex, item.index);
    const endColIndex = preserveSelection ? item.column.leafIndex : Math.max(cellSelectionService.lastSelectionItemColIndex, item.column.leafIndex);
    if (preserveSelection) {
      cellSelectionService.lastSelectionItemRowIndex = startRow;
      cellSelectionService.lastSelectionItemColIndex = startColumn;
      this.currentSelection = cellSelectionService.currentSelection;
    }
    const ev = cellSelectionService.selectRange(startRowIndex, startColIndex, endRowIndex, endColIndex, preserveSelection, this.currentSelection);
    cellSelectionService.changes.emit(ev);
  }
  handleMultipleArrowRowSelection(item, preserveSelection, startRow) {
    const rowSelectionService = this.ctx.grid.selectionService;
    const startRowIndex = preserveSelection ? startRow : Math.min(rowSelectionService.lastSelectionStartIndex, item.index);
    const endRowIndex = preserveSelection ? item.index : Math.max(rowSelectionService.lastSelectionStartIndex, item.index);
    if (preserveSelection) {
      rowSelectionService.lastSelectionStartIndex = startRow;
      this.currentSelection = rowSelectionService.currentSelection;
    }
    const ev = rowSelectionService.selectRange(startRowIndex, endRowIndex, preserveSelection, this.currentSelection);
    rowSelectionService.changes.emit(ev);
  }
  calculateRowspanOffset(direction, cellRowspan) {
    if (!isPresent(this.lastCellRowIndex)) {
      return 0;
    }
    const offset3 = direction === "Up" ? Math.abs(this.lastCellRowIndex - this.activeRowIndex) : this.activeRowIndex + cellRowspan - this.lastCellRowIndex - 1;
    return offset3;
  }
  get isStackedMode() {
    return this.ctx?.grid?.isStacked;
  }
  handleRowReorderKeyboard(args, code, row2) {
    if (!this.ctx.grid.rowReorderable || !this.activeCell) {
      return false;
    }
    const cell2 = this.activeCell;
    const cellElement = args.target;
    if (!cellElement) {
      return false;
    }
    const dragCell = closest5(cellElement, (el) => hasClasses(el, "k-drag-cell"));
    if (!dragCell || row2.dataRowIndex < 0 || !row2.dataItem) {
      return false;
    }
    const isUpArrow = code === Keys.ArrowUp;
    const currentRowIndex = row2.dataRowIndex;
    const data = this.ctx.grid.flatData;
    if (!data || data.length === 0) {
      return false;
    }
    const targetRowIndex = currentRowIndex + (isUpArrow ? -1 : 1);
    if (targetRowIndex < 0 || targetRowIndex >= data.length) {
      return false;
    }
    const dropPosition2 = isUpArrow ? "before" : "after";
    this.zone.run(() => {
      const skip4 = this.ctx.grid.skip || 0;
      this.ctx.grid.rowReorderService.reorderViaKeyboard(currentRowIndex + skip4, targetRowIndex + skip4, dropPosition2, data);
      this.zone.onStable.pipe(take(1)).subscribe(() => {
        const newRowIndex = this.meta.headerRows + targetRowIndex;
        this.cursor.reset(newRowIndex, cell2.colIndex);
      });
    });
    return true;
  }
  handleStackedKeydown(args) {
    const target = args.target;
    const stackedCell = closest5(target, (el) => hasClasses(el, "k-grid-stack-cell"));
    const tableCell = closest5(target, (el) => hasClasses(el, "k-table-td"));
    const isInStackedCell = closest5(target, (el) => hasClasses(el, "k-grid-stack-content"));
    const isInCommandCell = closest5(target, (el) => hasClasses(el, "k-command-cell"));
    if (!stackedCell || !tableCell) {
      return;
    }
    if (args.code === Keys.Tab) {
      this.handleStackedTabNavigation(args);
    } else if (args.code === Keys.Backspace || args.code === Keys.Delete) {
      if (this.stackedCellEntered || this.editService.isEditing()) {
        return;
      }
      if (this.activeRow && this.activeRow.dataRowIndex >= 0 && this.activeRow.dataItem) {
        const row2 = this.cursor.row;
        if (!row2.groupItem && !this.cursor.cell.detailExpandCell) {
          this.zone.run(() => {
            this.editService.remove(this.activeRow.dataRowIndex);
          });
          args.preventDefault();
        }
      }
    } else if (isInStackedCell && (args.code === Keys.Enter || args.code === Keys.NumpadEnter || args.code === Keys.Escape)) {
      this.editService.closeCell(args);
      this.activeCell.focusGroup.activate();
      this.activeCell.focusGroup.focusableChildren[this.stackedFocusedCellIndex]?.focus();
      if (!isInCommandCell) {
        args.preventDefault();
      }
    }
  }
  stackedFocusedCellIndex = -1;
  tableCellEntered = false;
  stackedCellEntered = false;
  handleStackedTabNavigation(args) {
    if (!isPresent(this.activeCell?.focusGroup)) {
      return;
    }
    if (this.stackedFocusedCellIndex === -1) {
      return;
    }
    const stackedCells = this.activeCell?.focusGroup?.focusableChildren;
    if (!isPresent(stackedCells) || stackedCells.length === 0) {
      return;
    }
    const currFocusedIndex = stackedCells.findIndex((el) => el.hasFocus() || el.hostElement?.nativeElement === document.activeElement);
    if (args.shiftKey) {
      if (currFocusedIndex === 0) {
        args.stopImmediatePropagation();
        args.preventDefault();
      } else {
        this.stackedFocusedCellIndex = currFocusedIndex - 1;
      }
    } else {
      if (currFocusedIndex === stackedCells.length - 1) {
        args.stopImmediatePropagation();
        args.preventDefault();
      } else {
        this.stackedFocusedCellIndex = currFocusedIndex + 1;
      }
    }
  }
  static ɵfac = function NavigationService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NavigationService)(ɵɵinject(NgZone), ɵɵinject(DomEventsService), ɵɵinject(PagerContextService), ɵɵinject(ScrollRequestService), ɵɵinject(GroupsService), ɵɵinject(DetailsService), ɵɵinject(FocusRoot), ɵɵinject(EditService), ɵɵinject(ChangeDetectorRef), ɵɵinject(ContextService), ɵɵinject(ColumnResizingService), ɵɵinject(FocusableDirective, 8));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _NavigationService,
    factory: _NavigationService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigationService4, [{
    type: Injectable
  }], () => [{
    type: NgZone
  }, {
    type: DomEventsService
  }, {
    type: PagerContextService
  }, {
    type: ScrollRequestService
  }, {
    type: GroupsService
  }, {
    type: DetailsService
  }, {
    type: FocusRoot
  }, {
    type: EditService
  }, {
    type: ChangeDetectorRef
  }, {
    type: ContextService
  }, {
    type: ColumnResizingService
  }, {
    type: FocusableDirective,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var preventOnDblClick$1 = (release) => (mouseDown) => of(mouseDown).pipe(delay(150), takeUntil(release));
var hasClass3 = (className) => (el) => new RegExp(`(^| )${className}( |$)`).test(el.className);
var isDeleteButton = or(hasClass3("k-i-x"), hasClass3("k-svg-i-x"), hasClass3("k-icon-button"));
var isSortIcon = or(hasClass3("k-i-sort-asc-small"), hasClass3("k-i-sort-desc-small"), hasClass3("k-svg-i-sort-asc-small"), hasClass3("k-svg-i-sort-desc-small"));
var skipButtons = and(not(isDeleteButton), not(isSortIcon), not(isFocusableWithTabKey), not(matchesNodeName("label")));
var elementUnderCursor = ({
  clientX,
  clientY
}) => isDocumentAvailable() && document.elementFromPoint(clientX, clientY);
var hideThenShow = (element, cont) => {
  element.style.display = "none";
  const result = cont();
  element.style.display = "block";
  return result;
};
var DraggableColumnDirective = class _DraggableColumnDirective {
  draggable;
  element;
  zone;
  service;
  hint;
  cue;
  nav;
  renderer;
  context = {};
  set enableDrag(enabled) {
    this.enabled = enabled;
    this.updateTouchAction();
  }
  drag = new EventEmitter();
  subscriptions = new Subscription();
  enabled;
  constructor(draggable, element, zone, service, hint, cue, nav, renderer) {
    this.draggable = draggable;
    this.element = element;
    this.zone = zone;
    this.service = service;
    this.hint = hint;
    this.cue = cue;
    this.nav = nav;
    this.renderer = renderer;
  }
  ngOnInit() {
    this.subscriptions.add(this.zone.runOutsideAngular(() => this.draggable.kendoPress.pipe(filter(() => this.enabled), filter(({
      originalEvent: {
        target
      }
    }) => target === this.element.nativeElement || skipButtons(target)), tap((e) => {
      const originalEvent = e.originalEvent;
      if (!e.isTouch) {
        originalEvent.preventDefault();
      }
      this.nav.navigateTo(originalEvent.target);
    }), switchMap(preventOnDblClick$1(this.draggable.kendoRelease)), tap(() => {
      this.hint.create(this.context.hint);
      this.cue.create();
    }), switchMap((down) => this.draggable.kendoDrag.pipe(tap((e) => {
      if (e.isTouch) {
        e.originalEvent.preventDefault();
      }
    }), tap(this.hint.attach()), tap(this.cue.attach()), takeUntil(this.draggable.kendoRelease), map((move) => ({
      move,
      down
    })))), tap(this.performDrag.bind(this)), switchMapTo(this.draggable.kendoRelease)).subscribe(this.drop.bind(this))));
  }
  ngOnDestroy() {
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
    }
  }
  drop(upEvent) {
    this.hint.remove();
    this.cue.remove();
    this.service.notifyDrop(this, upEvent);
  }
  performDrag({
    move
  }) {
    this.hint.move(move);
    const cursorElement = this.elementUnderCursor(move);
    if (cursorElement) {
      this.service.notifyDrag(this, cursorElement, move);
    }
    this.drag.emit({
      draggable: this,
      mouseEvent: move
    });
  }
  elementUnderCursor(mouseEvent) {
    this.hint.hide();
    let target = elementUnderCursor(mouseEvent);
    if (target && /k-grouping-dropclue/.test(target.className)) {
      target = hideThenShow(target, elementUnderCursor.bind(this, mouseEvent));
    }
    this.hint.show();
    return target;
  }
  updateTouchAction() {
    if (!this.element) {
      return;
    }
    this.enabled ? this.renderer.addClass(this.element.nativeElement, "k-touch-action-none") : this.renderer.removeClass(this.element.nativeElement, "k-touch-action-none");
  }
  static ɵfac = function DraggableColumnDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DraggableColumnDirective)(ɵɵdirectiveInject(DraggableDirective, 1), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(DragAndDropService), ɵɵdirectiveInject(DragHintService), ɵɵdirectiveInject(DropCueService), ɵɵdirectiveInject(NavigationService4), ɵɵdirectiveInject(Renderer2));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DraggableColumnDirective,
    selectors: [["", "kendoDraggableColumn", ""]],
    inputs: {
      context: "context",
      enableDrag: "enableDrag"
    },
    outputs: {
      drag: "drag"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DraggableColumnDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDraggableColumn]",
      standalone: true
    }]
  }], () => [{
    type: DraggableDirective,
    decorators: [{
      type: Host
    }]
  }, {
    type: ElementRef
  }, {
    type: NgZone
  }, {
    type: DragAndDropService
  }, {
    type: DragHintService
  }, {
    type: DropCueService
  }, {
    type: NavigationService4
  }, {
    type: Renderer2
  }], {
    context: [{
      type: Input
    }],
    enableDrag: [{
      type: Input
    }],
    drag: [{
      type: Output
    }]
  });
})();
var DropTargetDirective = class _DropTargetDirective {
  element;
  service;
  context = {};
  enter = new EventEmitter();
  leave = new EventEmitter();
  drop = new EventEmitter();
  subscriptions = new Subscription();
  constructor(element, service) {
    this.element = element;
    this.service = service;
  }
  ngOnInit() {
    this.service.add(this);
    const changes = this.service.changes.pipe(filter(({
      target
    }) => target === this));
    this.subscriptions.add(changes.pipe(filter(({
      type
    }) => type === "leave")).subscribe((e) => {
      this.leave.next(this.eventArgs(e));
    }));
    this.subscriptions.add(changes.pipe(filter(({
      type
    }) => type === "enter")).subscribe((e) => {
      this.enter.next(this.eventArgs(e));
    }));
    this.subscriptions.add(changes.pipe(filter(({
      type
    }) => type === "drop")).subscribe((e) => {
      this.drop.next(this.eventArgs(e));
    }));
  }
  ngOnDestroy() {
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
    }
  }
  eventArgs(e) {
    return {
      target: this,
      mouseEvent: e.mouseEvent,
      draggable: e.draggable
    };
  }
  static ɵfac = function DropTargetDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DropTargetDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(DragAndDropService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DropTargetDirective,
    selectors: [["", "kendoDropTarget", ""]],
    inputs: {
      context: "context"
    },
    outputs: {
      enter: "enter",
      leave: "leave",
      drop: "drop"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DropTargetDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDropTarget]",
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: DragAndDropService
  }], {
    context: [{
      type: Input
    }],
    enter: [{
      type: Output
    }],
    leave: [{
      type: Output
    }],
    drop: [{
      type: Output
    }]
  });
})();
function isColumnGroupComponent(column) {
  return column.isColumnGroup;
}
var ColumnGroupComponent2 = class _ColumnGroupComponent extends ColumnBase2 {
  parent;
  /**
   * @hidden
   */
  includeInChooser = false;
  /**
   * @hidden
   */
  isColumnGroup = true;
  /**
   * @hidden
   */
  minResizableWidth = 10;
  /**
   * @hidden
   */
  maxResizableWidth;
  /**
   * @hidden
   */
  children;
  constructor(parent, idService) {
    super(parent, idService);
    this.parent = parent;
    if (parent && parent.isSpanColumn) {
      throw new Error(ColumnConfigurationErrorMessages.nestedInside("ColumnGroupComponent", "SpanColumnComponent"));
    }
  }
  /**
   * @hidden
   */
  rowspan() {
    return 1;
  }
  /**
   * @hidden
   *
   * Used to hide the cellRowspan property from the public API.
   */
  set cellRowspan(cellRowSpan) {
    super.cellRowspan = cellRowSpan;
  }
  /**
   * @hidden
   */
  get colspan() {
    if (!this.children) {
      return 1;
    }
    return columnsSpan(this.children.filter((child) => child !== this && child.isVisible));
  }
  /**
   * @hidden
   */
  get leafIndex() {
    return this.children ? (this.firstChild || {}).leafIndex : -1;
  }
  get childrenArray() {
    return this.children.filter((c) => c !== this);
  }
  get hasChildren() {
    return Boolean(this.firstChild);
  }
  get firstChild() {
    return this.children.find((column) => column !== this);
  }
  static ɵfac = function ColumnGroupComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColumnGroupComponent)(ɵɵdirectiveInject(ColumnBase2, 13), ɵɵdirectiveInject(IdService, 8));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColumnGroupComponent,
    selectors: [["kendo-grid-column-group"]],
    contentQueries: function ColumnGroupComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, ColumnBase2, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
      }
    },
    features: [ɵɵProvidersFeature([{
      provide: ColumnBase2,
      useExisting: forwardRef(() => _ColumnGroupComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function ColumnGroupComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnGroupComponent2, [{
    type: Component,
    args: [{
      providers: [{
        provide: ColumnBase2,
        useExisting: forwardRef(() => ColumnGroupComponent2)
      }],
      selector: "kendo-grid-column-group",
      template: ``,
      standalone: true
    }]
  }], () => [{
    type: ColumnBase2,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }, {
      type: Optional
    }]
  }, {
    type: IdService,
    decorators: [{
      type: Optional
    }]
  }], {
    children: [{
      type: ContentChildren,
      args: [ColumnBase2]
    }]
  });
})();
var DetailTemplateDirective = class _DetailTemplateDirective {
  templateRef;
  /**
   * Sets a function to decide if the detail row and the **Expand** or **Collapse** button display for a data item.
   * The function receives the data item and its index.
   */
  set showIf(fn) {
    if (typeof fn !== "function") {
      throw new Error(GridConfigurationErrorMessages.functionType("showIf", fn));
    }
    this._condition = fn;
  }
  get showIf() {
    return this._condition;
  }
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  _condition = () => true;
  static ɵfac = function DetailTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DetailTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DetailTemplateDirective,
    selectors: [["", "kendoGridDetailTemplate", ""]],
    inputs: {
      showIf: [0, "kendoGridDetailTemplateShowIf", "showIf"]
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DetailTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridDetailTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], {
    showIf: [{
      type: Input,
      args: ["kendoGridDetailTemplateShowIf"]
    }]
  });
})();
var ColGroupComponent = class _ColGroupComponent {
  ctx;
  columns = [];
  groups = [];
  detailTemplate;
  sort = new Array();
  constructor(ctx) {
    this.ctx = ctx;
  }
  getColumnWidth(column) {
    const columnWidth = isPresent(column.width) ? `${column.width}px` : void 0;
    return this.isStacked ? "100%" : columnWidth;
  }
  get columnsToRender() {
    return this.isStacked ? [new ColumnBase2()] : columnsToRender(this.columns);
  }
  get isStacked() {
    return this.ctx.grid?.isStacked;
  }
  trackBy(index) {
    return index;
  }
  isSorted(column) {
    const state2 = this.sortDescriptor(column.field);
    return this.isSortable(column) && (state2.dir === "asc" || state2.dir === "desc");
  }
  getColumnComponent(column) {
    return column;
  }
  isSortable(column) {
    return !isNullOrEmptyString2(column.field) && isTruthy(column.sortable);
  }
  sortDescriptor(field) {
    return this.sort.find((item) => item.field === field) || {
      field
    };
  }
  static ɵfac = function ColGroupComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColGroupComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColGroupComponent,
    selectors: [["", "kendoGridColGroup", ""]],
    inputs: {
      columns: "columns",
      groups: "groups",
      detailTemplate: "detailTemplate",
      sort: "sort"
    },
    attrs: _c09,
    decls: 6,
    vars: 1,
    consts: [[3, "k-group-col"], [3, "k-hierarchy-col"], [3, "width", "k-sorted"]],
    template: function ColGroupComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵdomElementContainerStart(0);
        ɵɵrepeaterCreate(1, ColGroupComponent_For_2_Template, 1, 2, "col", 0, ɵɵrepeaterTrackByIdentity);
        ɵɵconditionalCreate(3, ColGroupComponent_Conditional_3_Template, 1, 2, "col", 1);
        ɵɵrepeaterCreate(4, ColGroupComponent_For_5_Template, 1, 4, "col", 2, ɵɵrepeaterTrackByIndex);
        ɵɵdomElementContainerEnd();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵrepeater(ctx.groups);
        ɵɵadvance(2);
        ɵɵconditional((ctx.detailTemplate == null ? null : ctx.detailTemplate.templateRef) && !ctx.isStacked ? 3 : -1);
        ɵɵadvance();
        ɵɵrepeater(ctx.columnsToRender);
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColGroupComponent, [{
    type: Component,
    args: [{
      selector: "[kendoGridColGroup]",
      template: `
    <ng-container>
      @for (g of groups; track g) {
        <col [class.k-group-col]="true" />
      }
      @if (detailTemplate?.templateRef && !isStacked) {
        <col [class.k-hierarchy-col]="true"/>
      }
      @for (column of columnsToRender; track $index) {
        <col
          [style.width]="getColumnWidth(column)"
          [class.k-sorted]="isSorted(getColumnComponent(column))"/>
      }
    </ng-container>
    `,
      standalone: true
    }]
  }], () => [{
    type: ContextService
  }], {
    columns: [{
      type: Input
    }],
    groups: [{
      type: Input
    }],
    detailTemplate: [{
      type: Input
    }],
    sort: [{
      type: Input
    }]
  });
})();
var LoadingTemplateDirective = class _LoadingTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function LoadingTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LoadingTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LoadingTemplateDirective,
    selectors: [["", "kendoGridLoadingTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LoadingTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridLoadingTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var LoadingComponent = class _LoadingComponent {
  ctx;
  hostClass = true;
  loadingTemplate;
  get loadingText() {
    return this.ctx.localization.get("loading");
  }
  constructor(ctx) {
    this.ctx = ctx;
  }
  static ɵfac = function LoadingComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LoadingComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _LoadingComponent,
    selectors: [["", "kendoGridLoading", ""]],
    hostVars: 2,
    hostBindings: function LoadingComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-loading-mask", ctx.hostClass);
      }
    },
    inputs: {
      loadingTemplate: "loadingTemplate"
    },
    attrs: _c117,
    decls: 2,
    vars: 2,
    consts: [[3, "ngTemplateOutlet"], [1, "k-loading-text"], [1, "k-loading-image"], [1, "k-loading-color"]],
    template: function LoadingComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵconditionalCreate(0, LoadingComponent_Conditional_0_Template, 4, 1);
        ɵɵconditionalCreate(1, LoadingComponent_Conditional_1_Template, 1, 1, null, 0);
      }
      if (rf & 2) {
        ɵɵconditional(!ctx.loadingTemplate ? 0 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.loadingTemplate ? 1 : -1);
      }
    },
    dependencies: [NgTemplateOutlet],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LoadingComponent, [{
    type: Component,
    args: [{
      selector: "[kendoGridLoading]",
      template: `
        @if (!loadingTemplate) {
          <span class="k-loading-text">{{ loadingText }}</span>
          <div class="k-loading-image"></div>
          <div class="k-loading-color"></div>
        }
        @if (loadingTemplate) {
          <ng-template [ngTemplateOutlet]="loadingTemplate?.templateRef">
          </ng-template>
        }
        `,
      standalone: true,
      imports: [NgTemplateOutlet]
    }]
  }], () => [{
    type: ContextService
  }], {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-loading-mask"]
    }],
    loadingTemplate: [{
      type: Input
    }]
  });
})();
var ResizeService = class _ResizeService {
  resizeSubscription = new Subscription(() => {
  });
  dispatcher = new Subject();
  changes = this.dispatcher.asObservable().pipe(throttleTime(100));
  connect(resizes) {
    this.resizeSubscription.add(resizes.subscribe(this.dispatcher));
  }
  destroy() {
    if (this.resizeSubscription) {
      this.resizeSubscription.unsubscribe();
    }
  }
  static ɵfac = function ResizeService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ResizeService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ResizeService,
    factory: _ResizeService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ResizeService, [{
    type: Injectable
  }], null, null);
})();
var ResizableContainerDirective = class _ResizableContainerDirective {
  el;
  renderer;
  resizeService;
  ctx;
  _lockedWidth;
  set lockedWidth(value2) {
    this._lockedWidth = value2;
    if (this.enabled) {
      this.attachResize();
      this.resize();
    }
  }
  set kendoGridResizableContainer(enabled) {
    const refresh = enabled !== this.enabled;
    this.enabled = enabled;
    if (refresh) {
      this.attachResize();
      this.resize();
    }
  }
  enabled = false;
  resizeSubscription;
  constructor(el, renderer, resizeService, ctx) {
    this.el = el;
    this.renderer = renderer;
    this.resizeService = resizeService;
    this.ctx = ctx;
  }
  ngOnDestroy() {
    if (this.resizeSubscription) {
      this.resizeSubscription.unsubscribe();
    }
  }
  attachResize() {
    if (this.resizeSubscription && !this.enabled) {
      this.resizeSubscription.unsubscribe();
      this.resizeSubscription = null;
    }
    if (!this.resizeSubscription && this.enabled) {
      this.resizeSubscription = this.resizeService.changes.subscribe(this.resize.bind(this));
    }
  }
  resize() {
    if (this.ctx.grid && this.ctx.grid.wrapper) {
      const containerElement = this.ctx.grid.wrapper.nativeElement;
      const width2 = Math.max(containerElement.clientWidth - this._lockedWidth, 0);
      if (this.enabled && width2 > 0) {
        this.renderer.setStyle(this.el.nativeElement, "width", width2 + "px");
      } else {
        this.renderer.setStyle(this.el.nativeElement, "width", "");
      }
    }
  }
  static ɵfac = function ResizableContainerDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ResizableContainerDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ResizeService), ɵɵdirectiveInject(ContextService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ResizableContainerDirective,
    selectors: [["", "kendoGridResizableContainer", ""]],
    inputs: {
      lockedWidth: "lockedWidth",
      kendoGridResizableContainer: "kendoGridResizableContainer"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ResizableContainerDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridResizableContainer]",
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: ResizeService
  }, {
    type: ContextService
  }], {
    lockedWidth: [{
      type: Input,
      args: ["lockedWidth"]
    }],
    kendoGridResizableContainer: [{
      type: Input
    }]
  });
})();
var FocusGroup = class _FocusGroup {
  root;
  active = true;
  children = [];
  get focusableChildren() {
    return this.children.filter((el) => el.canFocus());
  }
  get isActive() {
    return this.active;
  }
  constructor(root) {
    this.root = root;
    this.root.registerGroup(this);
  }
  ngOnDestroy() {
    this.root.unregisterGroup(this);
    this.active = true;
  }
  registerElement(element) {
    this.unregisterElement(element);
    this.children.push(element);
  }
  unregisterElement(element) {
    this.children = this.children.filter((f) => f !== element);
  }
  /**
   * Returns `true` if the group receives focus when the cell is focused.
   * The group must have a single simple focusable element, like a button or checkbox.
   */
  isNavigable() {
    const focusable = this.focusableChildren;
    return focusable.length === 1 && focusable[0].isNavigable();
  }
  canFocus() {
    return this.focusableChildren.length > 0;
  }
  focus() {
    if (this.canFocus() && !this.hasFocus()) {
      this.focusableChildren[0].focus();
    }
  }
  activate() {
    this.toggleState(true);
  }
  deactivate() {
    this.toggleState(false);
  }
  hasFocus() {
    return this.children.reduce((focused, element) => focused || element.hasFocus(), false);
  }
  toggleState(active) {
    if (this.active !== active) {
      this.active = active;
      this.children.forEach((f) => f.toggle(active));
    }
  }
  static ɵfac = function FocusGroup_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FocusGroup)(ɵɵinject(FocusRoot));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _FocusGroup,
    factory: _FocusGroup.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FocusGroup, [{
    type: Injectable
  }], () => [{
    type: FocusRoot
  }], null);
})();
var reset = (...lists) => {
  let diff = false;
  for (let idx4 = 0; idx4 < lists.length; idx4++) {
    const [list2, columns] = lists[idx4];
    diff = diff || list2.length !== columns.length;
    list2.reset(columns);
  }
  return diff;
};
var ColumnsContainer = class {
  columns;
  allColumns = new QueryList();
  leafColumns = new QueryList();
  lockedColumns = new QueryList();
  nonLockedColumns = new QueryList();
  lockedLeafColumns = new QueryList();
  nonLockedLeafColumns = new QueryList();
  totalLevels = 0;
  isStacked = false;
  changes = new EventEmitter();
  leafColumnsToRender = [];
  lockedColumnsToRender = [];
  nonLockedColumnsToRender = [];
  hasGroupHeaderColumn = false;
  hasGroupFooter = false;
  hasFooter = false;
  unlockedWidth = 0;
  totalColumnsWidth = 0;
  constructor(columns) {
    this.columns = columns;
  }
  refresh() {
    const currentLevels = this.totalLevels;
    const leafColumns2 = new Array();
    const lockedLeafColumns = new Array();
    const nonLockedLeafColumns = new Array();
    const lockedColumns = new Array();
    const nonLockedColumns = new Array();
    const allColumns = new Array();
    const leafColumnsToRender = new Array();
    const lockedColumnsToRender = new Array();
    const nonLockedColumnsToRender = new Array();
    let hasGroupHeaderColumn = false;
    let hasGroupFooter = false;
    let hasFooter = false;
    let unlockedWidth = 0;
    let leafIndex = 0;
    this.totalLevels = 0;
    this.columns().forEach((column) => {
      const containerLeafColumns = column.isLocked === true ? lockedLeafColumns : nonLockedLeafColumns;
      const containerColumns = column.isLocked === true ? lockedColumns : nonLockedColumns;
      const toRenderContainer = column.isLocked === true ? lockedColumnsToRender : nonLockedColumnsToRender;
      if (!isColumnGroupComponent(column)) {
        containerLeafColumns.push(column);
        leafColumns2.push(column);
        leafColumnsToRender.push(...columnsToRender([column]));
        toRenderContainer.push(...columnsToRender([column]));
        hasGroupHeaderColumn = hasGroupHeaderColumn || someLeafColumn((leaf) => Boolean(leaf.groupHeaderColumnTemplateRef), column);
        hasGroupFooter = hasGroupFooter || someLeafColumn((leaf) => Boolean(leaf.groupFooterTemplateRef), column);
        hasFooter = hasFooter || someLeafColumn((leaf) => Boolean(leaf.footerTemplateRef), column);
        if (!column.isLocked) {
          unlockedWidth += column.width || 0;
        }
        if (column.isSpanColumn) {
          column.children.forEach((c) => {
            c.leafIndex = leafIndex++;
          });
        } else {
          column.leafIndex = leafIndex++;
        }
        this.totalColumnsWidth += column.width || 0;
      }
      containerColumns.push(column);
      allColumns.push(column);
      this.totalLevels = column.level > this.totalLevels ? column.level : this.totalLevels;
    });
    this.hasGroupHeaderColumn = hasGroupHeaderColumn;
    this.hasGroupFooter = hasGroupFooter;
    this.hasFooter = hasFooter;
    this.leafColumnsToRender = leafColumnsToRender;
    this.lockedColumnsToRender = lockedColumnsToRender;
    this.nonLockedColumnsToRender = nonLockedColumnsToRender;
    this.unlockedWidth = unlockedWidth;
    const changes = reset([this.leafColumns, leafColumns2], [this.lockedLeafColumns, lockedLeafColumns], [this.nonLockedLeafColumns, nonLockedLeafColumns], [this.lockedColumns, lockedColumns], [this.allColumns, allColumns], [this.nonLockedColumns, nonLockedColumns]) || currentLevels !== this.totalLevels;
    if (changes) {
      this.changes.emit();
    }
    return changes;
  }
};
var NO_STICKY = {
  left: "0px",
  right: "0px"
};
var ColumnInfoService = class _ColumnInfoService {
  visibilityChange = new EventEmitter();
  lockedChange = new EventEmitter();
  stickyChange = new EventEmitter();
  columnRangeChange = new EventEmitter();
  columnsContainer = new ColumnsContainer(() => []);
  list;
  stickyColumns;
  get lockedLeafColumns() {
    return this.columnsContainer.lockedLeafColumns;
  }
  get nonLockedLeafColumns() {
    return this.columnsContainer.nonLockedLeafColumns;
  }
  get isLocked() {
    return this.lockedLeafColumns.length > 0 && !this.columnsContainer.isStacked;
  }
  get totalLevels() {
    return this.columnsContainer.totalLevels;
  }
  get hiddenColumns() {
    if (!this.list) {
      return [];
    }
    return this.list().filter((column) => !column.isVisible);
  }
  get leafNamedColumns() {
    if (!this.list) {
      return [];
    }
    const columns = expandColumns(this.list().filterSort((column) => !column.isColumnGroup)).filter((column) => column.matchesMedia && column.displayTitle);
    return orderBy(columns, [{
      field: "locked",
      dir: "desc"
    }]);
  }
  get unlockedRootCount() {
    return this.list().rootColumns().filter((column) => !column.locked && column.isVisible).length;
  }
  stickyColumnsStyles(column) {
    this.stickyColumns = this.list().rootColumns().filter((column2) => column2.sticky && !column2.locked && column2.isVisible);
    if (this.stickyColumns.length === 0) {
      return NO_STICKY;
    }
    const result = this.stickyColumns.reduce((acc, curr) => {
      if (curr.leafIndex < column.leafIndex) {
        acc.left += curr.width;
      } else if (curr.leafIndex > column.leafIndex) {
        acc.right += curr.width;
      }
      return acc;
    }, {
      left: 0,
      right: 0
    });
    return {
      left: `${result.left}px`,
      right: `${result.right}px`
    };
  }
  init(columns, list2) {
    this.columnsContainer = columns;
    this.list = list2;
    this.stickyColumns = null;
  }
  changeVisibility(columns) {
    this.stickyColumns = null;
    this.visibilityChange.emit(columns);
  }
  changeLocked(columns) {
    this.stickyColumns = null;
    this.lockedChange.emit(columns);
  }
  changeStuck(columns) {
    this.stickyColumns = null;
    this.stickyChange.emit(columns);
  }
  static ɵfac = function ColumnInfoService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColumnInfoService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ColumnInfoService,
    factory: _ColumnInfoService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnInfoService, [{
    type: Injectable
  }], null, null);
})();
var id$3 = 0;
function nextId$12() {
  return id$3++;
}
var LogicalCellDirective = class _LogicalCellDirective {
  focusGroup;
  element;
  columnInfoService;
  idService;
  navigationService;
  renderer;
  zone;
  cellContext;
  logicalColIndex;
  logicalRowIndex;
  logicalSlaveCell = false;
  colIndex;
  colSpan = 1;
  rowSpan = 1;
  groupItem;
  dataRowIndex = -1;
  dataItem;
  detailExpandCell = false;
  headerLabelText;
  uid = nextId$12();
  get id() {
    if (!this.logicalSlaveCell && this.columnInfoService.isLocked) {
      return this.idService.cellId(this.logicalRowIndex, this.logicalColIndex);
    }
  }
  get cellRowspan() {
    return String(this.rowSpan);
  }
  get rowspanClass() {
    return this.dataRowIndex > -1 && this.rowSpan > 1;
  }
  get ariaColIndex() {
    if (this.logicalSlaveCell || this.logicalColIndex === -1) {
      return void 0;
    }
    return this.logicalColIndex + 1;
  }
  navigationChange;
  constructor(focusGroup, element, columnInfoService, idService, navigationService, renderer, zone, cellContext) {
    this.focusGroup = focusGroup;
    this.element = element;
    this.columnInfoService = columnInfoService;
    this.idService = idService;
    this.navigationService = navigationService;
    this.renderer = renderer;
    this.zone = zone;
    this.cellContext = cellContext;
  }
  ngOnInit() {
    if (!this.navigationService.tableEnabled) {
      return;
    }
    this.navigationChange = this.navigationService.changes.subscribe((e) => this.onNavigationChange(e));
  }
  ngDoCheck() {
    if (!this.navigationService.tableEnabled || this.logicalColIndex === -1) {
      return;
    }
    if (this.cellContext) {
      this.cellContext.focusGroup = this.focusGroup;
    }
    this.registerNoChanges();
  }
  ngOnChanges(changes) {
    if (!this.navigationService.tableEnabled) {
      return;
    }
    const keys = Object.keys(changes);
    if (keys.length === 1 && keys[0] === "groupItem" || this.logicalColIndex === -1) {
      return;
    }
    const indexChange = changes["logicalColIndex"];
    const rowIndexChange = changes["logicalRowIndex"];
    const index = indexChange && !indexChange.isFirstChange() ? indexChange.previousValue : this.logicalColIndex;
    const rowIndex = rowIndexChange && !rowIndexChange.isFirstChange() ? rowIndexChange.previousValue : this.logicalRowIndex;
    this.navigationService.unregisterCell(index, rowIndex, this);
    this.registerChanges();
    this.updateElement();
  }
  ngOnDestroy() {
    if (this.navigationChange) {
      this.navigationChange.unsubscribe();
    }
    this.navigationService.unregisterCell(this.logicalColIndex, this.logicalRowIndex, this);
  }
  onNavigationChange(e) {
    const active = this.logicalColIndex === e.colIndex && this.logicalRowIndex === e.rowIndex;
    const wasActive = this.logicalColIndex === e.prevColIndex && this.logicalRowIndex === e.prevRowIndex;
    if (active || wasActive) {
      this.updateElement();
    }
  }
  updateElement() {
    const el = this.element.nativeElement;
    this.renderer.setAttribute(el, "tabIndex", this.isFocusable() && !this.logicalSlaveCell ? "0" : "-1");
    if (this.isFocused()) {
      if (this.focusGroup.isNavigable()) {
        this.focusGroup.focus();
      } else {
        if (!this.logicalSlaveCell && this.navigationService.autoFocusCell(this.logicalColIndex, this.logicalColIndex + this.colSpan - 1)) {
          this.microtask(() => {
            if (this.isFocused()) {
              el.focus({
                preventScroll: this.navigationService.preventScroll
              });
              this.navigationService.preventScroll = false;
            }
          });
        }
        this.renderer.addClass(el, "k-focus");
      }
      if (this.headerLabelText) {
        el.removeAttribute("aria-label");
      }
    } else {
      this.renderer.removeClass(el, "k-focus");
      if (this.headerLabelText) {
        el.setAttribute("aria-label", this.headerLabelText);
      }
    }
  }
  microtask(callback) {
    this.zone.runOutsideAngular(() => Promise.resolve(null).then(callback));
  }
  registerChanges() {
    if (!this.logicalSlaveCell) {
      this.navigationService.registerCell(this);
    }
  }
  registerNoChanges() {
    if (!this.logicalSlaveCell) {
      this.navigationService.registerCellOnCurrentRow(this);
    }
  }
  isFocusable() {
    return this.navigationService.isCellFocusable(this);
  }
  isFocused() {
    return this.navigationService.isCellFocused(this);
  }
  static ɵfac = function LogicalCellDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LogicalCellDirective)(ɵɵdirectiveInject(FocusGroup), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ColumnInfoService), ɵɵdirectiveInject(IdService), ɵɵdirectiveInject(NavigationService4), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(CELL_CONTEXT, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LogicalCellDirective,
    selectors: [["", "kendoGridLogicalCell", ""]],
    hostVars: 5,
    hostBindings: function LogicalCellDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("id", ctx.id)("rowspan", ctx.cellRowspan)("aria-colindex", ctx.ariaColIndex);
        ɵɵclassProp("k-table-td-row-span", ctx.rowspanClass);
      }
    },
    inputs: {
      logicalColIndex: "logicalColIndex",
      logicalRowIndex: "logicalRowIndex",
      logicalSlaveCell: "logicalSlaveCell",
      colIndex: "colIndex",
      colSpan: "colSpan",
      rowSpan: "rowSpan",
      groupItem: "groupItem",
      dataRowIndex: "dataRowIndex",
      dataItem: "dataItem",
      detailExpandCell: "detailExpandCell",
      headerLabelText: "headerLabelText"
    },
    features: [ɵɵProvidersFeature([{
      provide: FocusGroup,
      deps: [FocusRoot],
      useClass: FocusGroup
    }]), ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LogicalCellDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: FocusGroup,
        deps: [FocusRoot],
        useClass: FocusGroup
      }],
      selector: "[kendoGridLogicalCell]",
      standalone: true
    }]
  }], () => [{
    type: FocusGroup
  }, {
    type: ElementRef
  }, {
    type: ColumnInfoService
  }, {
    type: IdService
  }, {
    type: NavigationService4
  }, {
    type: Renderer2
  }, {
    type: NgZone
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CELL_CONTEXT]
    }]
  }], {
    logicalColIndex: [{
      type: Input
    }],
    logicalRowIndex: [{
      type: Input
    }],
    logicalSlaveCell: [{
      type: Input
    }],
    colIndex: [{
      type: Input
    }],
    colSpan: [{
      type: Input
    }],
    rowSpan: [{
      type: Input
    }],
    groupItem: [{
      type: Input
    }],
    dataRowIndex: [{
      type: Input
    }],
    dataItem: [{
      type: Input
    }],
    detailExpandCell: [{
      type: Input
    }],
    headerLabelText: [{
      type: Input
    }],
    id: [{
      type: HostBinding,
      args: ["attr.id"]
    }],
    cellRowspan: [{
      type: HostBinding,
      args: ["attr.rowspan"]
    }],
    rowspanClass: [{
      type: HostBinding,
      args: ["class.k-table-td-row-span"]
    }],
    ariaColIndex: [{
      type: HostBinding,
      args: ["attr.aria-colindex"]
    }]
  });
})();
var id$2 = 0;
function nextId3() {
  return id$2++;
}
var LogicalRowDirective = class _LogicalRowDirective {
  idService;
  navigation;
  logicalRowIndex;
  logicalSlaveRow = false;
  logicalCellsCount;
  logicalSlaveCellsCount = 0;
  dataRowIndex = -1;
  dataItem;
  totalColumns;
  uid = nextId3();
  get hostRole() {
    return this.logicalSlaveRow ? "presentation" : "row";
  }
  get ariaRowIndex() {
    return this.logicalSlaveRow ? null : this.logicalRowIndex + 1;
  }
  get rowIndex() {
    return this.logicalSlaveRow ? this.logicalRowIndex + 1 : null;
  }
  tableRowClass = true;
  get ariaOwns() {
    if (this.logicalSlaveRow || this.logicalSlaveCellsCount === 0) {
      return void 0;
    }
    const ids = [];
    if (this.dataRowIndex < 0) {
      let total = this.logicalCellsCount + this.logicalSlaveCellsCount;
      this.columnsArray.forEach((column) => {
        if (column.isSpanColumn) {
          total += column.colspan - 1;
        }
      });
      for (let cellIndex = this.logicalCellsCount; cellIndex < total; cellIndex++) {
        ids.push(this.idService.cellId(this.logicalRowIndex, cellIndex));
      }
    } else {
      let columnIndex = 0;
      this.columnsArray.forEach((column) => {
        if (!column.isLocked) {
          ids.push(this.idService.cellId(this.logicalRowIndex, columnIndex));
        }
        columnIndex += column.isSpanColumn ? column.colspan : 1;
      });
    }
    return ids.join(" ");
  }
  constructor(idService, navigation) {
    this.idService = idService;
    this.navigation = navigation;
  }
  ngOnChanges(changes) {
    if (!this.navigation.enabled || this.logicalSlaveRow) {
      return;
    }
    const indexChange = changes.logicalRowIndex;
    const logicalSlaveRowChange = changes.logicalSlaveRow;
    if (indexChange || logicalSlaveRowChange) {
      const index = indexChange && !indexChange.isFirstChange() ? indexChange.previousValue : this.logicalRowIndex;
      this.navigation.unregisterRow(index, this);
      this.navigation.registerRow(this);
    } else if (anyChanged(["dataRowIndex", "dataItem"], changes)) {
      this.navigation.updateRow(this);
    }
  }
  ngOnDestroy() {
    this.navigation.unregisterRow(this.logicalRowIndex, this);
  }
  get columnsArray() {
    return this.totalColumns?.allColumns.toArray() || [];
  }
  static ɵfac = function LogicalRowDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LogicalRowDirective)(ɵɵdirectiveInject(IdService), ɵɵdirectiveInject(NavigationService4));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LogicalRowDirective,
    selectors: [["", "kendoGridLogicalRow", ""]],
    hostVars: 6,
    hostBindings: function LogicalRowDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("role", ctx.hostRole)("aria-rowindex", ctx.ariaRowIndex)("data-kendo-grid-row-index", ctx.rowIndex)("aria-owns", ctx.ariaOwns);
        ɵɵclassProp("k-table-row", ctx.tableRowClass);
      }
    },
    inputs: {
      logicalRowIndex: "logicalRowIndex",
      logicalSlaveRow: "logicalSlaveRow",
      logicalCellsCount: "logicalCellsCount",
      logicalSlaveCellsCount: "logicalSlaveCellsCount",
      dataRowIndex: "dataRowIndex",
      dataItem: "dataItem",
      totalColumns: "totalColumns"
    },
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LogicalRowDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridLogicalRow]",
      standalone: true
    }]
  }], () => [{
    type: IdService
  }, {
    type: NavigationService4
  }], {
    logicalRowIndex: [{
      type: Input
    }],
    logicalSlaveRow: [{
      type: Input
    }],
    logicalCellsCount: [{
      type: Input
    }],
    logicalSlaveCellsCount: [{
      type: Input
    }],
    dataRowIndex: [{
      type: Input
    }],
    dataItem: [{
      type: Input
    }],
    totalColumns: [{
      type: Input
    }],
    hostRole: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    ariaRowIndex: [{
      type: HostBinding,
      args: ["attr.aria-rowindex"]
    }],
    rowIndex: [{
      type: HostBinding,
      args: ["attr.data-kendo-grid-row-index"]
    }],
    tableRowClass: [{
      type: HostBinding,
      args: ["class.k-table-row"]
    }],
    ariaOwns: [{
      type: HostBinding,
      args: ["attr.aria-owns"]
    }]
  });
})();
var FORMAT_REGEX$1 = /\{\d+:?/;
var FieldAccessorPipe = class _FieldAccessorPipe {
  intlService;
  constructor(intlService) {
    this.intlService = intlService;
  }
  transform(dataItem, fieldName, format) {
    if (!isNullOrEmptyString2(fieldName)) {
      const value2 = getter(fieldName)(dataItem);
      if (!isNullOrEmptyString2(format)) {
        return this.formatValue(format, value2);
      }
      return value2;
    }
    return dataItem;
  }
  formatValue(format, value2) {
    const intl = this.intlService;
    if (isString2(format) && FORMAT_REGEX$1.exec(format)) {
      return intl.format(format, value2);
    }
    return intl.toString(value2, format);
  }
  static ɵfac = function FieldAccessorPipe_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FieldAccessorPipe)(ɵɵdirectiveInject(IntlService, 16));
  };
  static ɵpipe = ɵɵdefinePipe({
    name: "valueOf",
    type: _FieldAccessorPipe,
    pure: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FieldAccessorPipe, [{
    type: Pipe,
    args: [{
      // eslint-disable-next-line @angular-eslint/pipe-prefix
      name: "valueOf",
      pure: false,
      standalone: true
    }]
  }], () => [{
    type: IntlService
  }], null);
})();
var GridTableDirective = class _GridTableDirective {
  wrapper;
  hostClass = true;
  get sizeSmallClass() {
    return this.size === "small";
  }
  get sizeMediumClass() {
    return this.size === "medium" || !this.size;
  }
  set size(size) {
    this._size = size;
    if (size === "none") {
      this.wrapper.nativeElement.classList.remove("k-table-sm", "k-table-md");
    }
  }
  get size() {
    return this._size;
  }
  _size = "medium";
  constructor(wrapper) {
    this.wrapper = wrapper;
  }
  static ɵfac = function GridTableDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _GridTableDirective)(ɵɵdirectiveInject(ElementRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _GridTableDirective,
    selectors: [["", "kendoGridTable", ""]],
    hostVars: 6,
    hostBindings: function GridTableDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-table", ctx.hostClass)("k-table-sm", ctx.sizeSmallClass)("k-table-md", ctx.sizeMediumClass);
      }
    },
    inputs: {
      size: "size"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GridTableDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridTable]",
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }], {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-table"]
    }],
    sizeSmallClass: [{
      type: HostBinding,
      args: ["class.k-table-sm"]
    }],
    sizeMediumClass: [{
      type: HostBinding,
      args: ["class.k-table-md"]
    }],
    size: [{
      type: Input
    }]
  });
})();
var forEachColumn = (list2, callback) => {
  list2.forEach((column) => {
    callback(column);
    if (column.isColumnGroup && column.hasChildren) {
      forEachColumn(column.childrenArray, callback);
    }
  });
};
var forEachLevel = (list2, callback) => {
  sortColumns(list2).forEach((column) => {
    callback(column);
    if (column.isColumnGroup && column.hasChildren) {
      forEachLevel(column.childrenArray, callback);
    }
  });
};
var filterHierarchy = (list2, predicate) => {
  const result = [];
  sortColumns(list2).forEach((column) => {
    if (predicate(column)) {
      if (column.isColumnGroup) {
        const children2 = filterHierarchy(column.childrenArray, predicate);
        if (children2.length) {
          result.push(column, ...children2);
        }
      } else if (!column.isSpanColumn || filterHierarchy(column.childrenArray, predicate).length) {
        result.push(column);
      }
    }
  });
  return result.sort((a, b) => Number(b.locked) - Number(a.locked));
};
var ColumnList = class _ColumnList {
  columns;
  static empty() {
    return new _ColumnList(new QueryList());
  }
  constructor(columns) {
    this.columns = columns;
  }
  forEach(callback) {
    forEachColumn(this.columns, callback);
  }
  filter(callback) {
    const result = [];
    forEachColumn(this.columns, (column) => {
      if (callback(column)) {
        result.push(column);
      }
    });
    return result;
  }
  filterHierarchy(predicate) {
    return filterHierarchy(this.columns.toArray(), predicate);
  }
  filterSort(callback) {
    const result = [];
    forEachLevel(this.columns.toArray(), (column) => {
      if (callback(column)) {
        result.push(column);
      }
    });
    return result;
  }
  toArray() {
    const result = [];
    forEachColumn(this.columns, (column) => {
      result.push(column);
    });
    return result;
  }
  rootColumns() {
    return this.columns.toArray();
  }
  totalColumnLevels() {
    let totalLevels = 0;
    this.forEach((column) => {
      totalLevels = Math.max(column.level, totalLevels);
    });
    return totalLevels;
  }
};
var GroupInfoService = class {
  _columnList = ColumnList.empty;
  get columns() {
    return expandColumns(this._columnList().toArray()).filter(isColumnComponent);
  }
  registerColumnsContainer(columns) {
    this._columnList = columns;
  }
  formatForGroup(item) {
    const column = this.columnForGroup(item);
    return column ? column.format : "";
  }
  isGroupable(groupField) {
    const [column] = this.columns.filter((x) => x.field === groupField);
    return column ? column.groupable : true;
  }
  groupTitle(item) {
    const column = this.columnForGroup(item);
    return column ? column.title || column.field : this.groupField(item);
  }
  groupHeaderTemplate(item) {
    const column = this.columnForGroup(item);
    return column ? column.groupHeaderTemplateRef || column.groupHeaderColumnTemplateRef : void 0;
  }
  groupField(group2) {
    return group2.data ? group2.data.field : group2.field;
  }
  columnForGroup(group2) {
    const field = this.groupField(group2);
    const [column] = this.columns.filter((x) => x.field === field);
    return column;
  }
};
var GroupHeaderComponent = class _GroupHeaderComponent {
  groupsService;
  groupInfoService;
  ctx;
  rowIndex;
  logicalRowIndex;
  item;
  skipGroupDecoration = false;
  hasDetails = false;
  totalColumnsCount = 0;
  hasGroupHeaderColumn;
  groupHeaderColumns;
  columns;
  groups = [];
  groupItemClass = true;
  tableGroupRowClass = true;
  isExpanded = false;
  caretAltDownIcon = caretAltDownIcon;
  caretAltRightIcon = caretAltRightIcon;
  caretAltLeftIcon = caretAltLeftIcon;
  constructor(groupsService, groupInfoService, ctx) {
    this.groupsService = groupsService;
    this.groupInfoService = groupInfoService;
    this.ctx = ctx;
  }
  ngDoCheck() {
    const groupArgs = {
      group: this.item.data,
      groupIndex: this.item.index,
      parentGroup: getGroupRowArgs(this.item.parentGroup)
    };
    this.isExpanded = this.groupsService.isExpanded(groupArgs);
  }
  prefixGroupCell(item) {
    return new Array(item.level);
  }
  toggleGroup(item, event) {
    this.groupsService.toggleRow(item);
    if (this.ctx.navigable) {
      this.ctx.grid.navigationService.focusCellByElement(event.target.closest("td"));
    }
    return false;
  }
  groupSpan(item) {
    const groupCount = (this.groups || []).length;
    const detailOffset = this.hasDetails ? 1 : 0;
    if (this.hasGroupHeaderColumn) {
      return groupCount + 1 + detailOffset - item.level;
    }
    const columnCount = columnsSpan(this.columns);
    if (this.skipGroupDecoration) {
      return columnCount;
    }
    return groupCount + columnCount + detailOffset - item.level;
  }
  logicalColSpan() {
    return this.skipGroupDecoration ? 1 : this.totalColumnsCount;
  }
  ariaRole() {
    if (this.skipGroupDecoration) {
      return "presentation";
    }
    return "gridcell";
  }
  formatForGroup(item) {
    return this.groupInfoService.formatForGroup(item);
  }
  groupTitle(item) {
    return this.groupInfoService.groupTitle(item);
  }
  groupHeaderTemplate(item) {
    return this.groupInfoService.groupHeaderTemplate(item);
  }
  get groupButtonTitle() {
    const messageKey = this.isExpanded ? "groupCollapse" : "groupExpand";
    return this.ctx.localization.get(messageKey);
  }
  get arrowIcon() {
    const icon = !this.isExpanded ? !this.ctx.localization.rtl ? "caret-alt-right" : "caret-alt-left" : "caret-alt-down";
    return icon;
  }
  get arrowSVGIcon() {
    const icon = !this.isExpanded ? !this.ctx.localization.rtl ? this.caretAltRightIcon : this.caretAltLeftIcon : this.caretAltDownIcon;
    return icon;
  }
  get isStacked() {
    return this.ctx.grid?.isStacked;
  }
  static ɵfac = function GroupHeaderComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _GroupHeaderComponent)(ɵɵdirectiveInject(GroupsService), ɵɵdirectiveInject(GroupInfoService), ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _GroupHeaderComponent,
    selectors: [["", "kendoGridGroupHeader", ""]],
    hostVars: 4,
    hostBindings: function GroupHeaderComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-grouping-row", ctx.groupItemClass)("k-table-group-row", ctx.tableGroupRowClass);
      }
    },
    inputs: {
      rowIndex: "rowIndex",
      logicalRowIndex: "logicalRowIndex",
      item: "item",
      skipGroupDecoration: "skipGroupDecoration",
      hasDetails: "hasDetails",
      totalColumnsCount: "totalColumnsCount",
      hasGroupHeaderColumn: "hasGroupHeaderColumn",
      groupHeaderColumns: "groupHeaderColumns",
      columns: "columns",
      groups: "groups"
    },
    attrs: _c217,
    decls: 3,
    vars: 3,
    consts: [["aria-selected", "false", "kendoGridLogicalCell", "", 1, "k-table-td", 3, "logicalRowIndex", "logicalColIndex", "logicalSlaveCell", "groupItem", "colSpan"], ["role", "presentation", 1, "k-group-cell", "k-table-td", "k-table-group-td"], [1, "k-reset"], [1, "k-grid-column-template"], ["href", "#", "tabindex", "-1", "role", "presentation", 3, "click"], [3, "name", "svgIcon"], [3, "templateContext"], [1, "k-column-template-item"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["role", "gridcell", "aria-selected", "false", "kendoGridLogicalCell", "", 1, "k-table-td", 3, "logicalRowIndex", "logicalColIndex", "logicalSlaveCell", "groupItem", "colSpan"]],
    template: function GroupHeaderComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵconditionalCreate(0, GroupHeaderComponent_Conditional_0_Template, 2, 0);
        ɵɵconditionalCreate(1, GroupHeaderComponent_Conditional_1_Template, 4, 10, "td", 0);
        ɵɵconditionalCreate(2, GroupHeaderComponent_Conditional_2_Template, 2, 0);
      }
      if (rf & 2) {
        ɵɵconditional(!ctx.skipGroupDecoration ? 0 : -1);
        ɵɵadvance();
        ɵɵconditional(!(ctx.skipGroupDecoration && ctx.hasGroupHeaderColumn) ? 1 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.hasGroupHeaderColumn && !ctx.isStacked ? 2 : -1);
      }
    },
    dependencies: [LogicalCellDirective, IconWrapperComponent, TemplateContextDirective, NgTemplateOutlet, FieldAccessorPipe],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GroupHeaderComponent, [{
    type: Component,
    args: [{
      selector: "[kendoGridGroupHeader]",
      template: `
        @if (!skipGroupDecoration) {
          @for (g of prefixGroupCell(item); track $index) {
            <td class="k-group-cell k-table-td k-table-group-td"
              role="presentation"
            ></td>
          }
        }
        @if (!(skipGroupDecoration && hasGroupHeaderColumn)) {
          <td [attr.colspan]="groupSpan(item)"
            [attr.role]="ariaRole()"
            aria-selected="false"
            class="k-table-td"
            [attr.aria-expanded]="isExpanded"
            kendoGridLogicalCell
            [logicalRowIndex]="logicalRowIndex"
            [logicalColIndex]="0"
            [logicalSlaveCell]="skipGroupDecoration"
            [groupItem]="item"
            [colSpan]="logicalColSpan()">
            <p class="k-reset">
              @if (!skipGroupDecoration) {
                <a href="#" tabindex="-1" (click)="toggleGroup(item, $event)"
                  role="presentation"
                  [attr.title]="groupButtonTitle"
                  [attr.aria-label]="groupButtonTitle">
                  <kendo-icon-wrapper
                    [name]="arrowIcon"
                  [svgIcon]="arrowSVGIcon"></kendo-icon-wrapper>
                </a>
                @if (!groupHeaderTemplate(item)) {
                  {{groupTitle(item)}}: {{item.data | valueOf:"value": formatForGroup(item)}}
                }
                <ng-template
                        [templateContext]="{
                            templateRef: groupHeaderTemplate(item),
                            group: item.data,
                            aggregates: item.data?.aggregates,
                            value: item.data?.value,
                            field: item.data?.field,
                            index: item.index,
                            expanded: isExpanded,
                            $implicit: item.data
                            }">
                </ng-template>
              }
            </p>
            @if (isStacked) {
              <div class="k-grid-column-template">
                @for (column of groupHeaderColumns; track column; let index = $index) {
                  @if (column.groupHeaderColumnTemplateRef) {
                    <div class="k-column-template-item">
                      <ng-template [ngTemplateOutlet]="column.groupHeaderColumnTemplateRef"
                            [ngTemplateOutletContext]="{
                                group: item.data,
                                aggregates: item.data?.aggregates,
                                value: item.data?.value,
                                field: item.data?.field,
                                index: item.index,
                                $implicit: item.data
                                }">
                      </ng-template>
                    </div>
                  }
                }
              </div>
            }
          </td>
        }
        @if (hasGroupHeaderColumn && !isStacked) {
          @for (column of groupHeaderColumns; track column; let index = $index) {
            <td
              role="gridcell"
              class="k-table-td"
              aria-selected="false"
              kendoGridLogicalCell
              [logicalRowIndex]="logicalRowIndex"
              [logicalColIndex]="index + 1"
              [logicalSlaveCell]="false"
              [groupItem]="item"
              [colSpan]="1"
              >
              @if (column.groupHeaderColumnTemplateRef) {
                <ng-template [ngTemplateOutlet]="column.groupHeaderColumnTemplateRef"
                    [ngTemplateOutletContext]="{
                        group: item.data,
                        aggregates: item.data?.aggregates,
                        value: item.data?.value,
                        field: item.data?.field,
                        index: item.index,
                        $implicit: item.data
                        }">
                </ng-template>
              }
            </td>
          }
        }
        `,
      standalone: true,
      imports: [LogicalCellDirective, IconWrapperComponent, TemplateContextDirective, NgTemplateOutlet, FieldAccessorPipe]
    }]
  }], () => [{
    type: GroupsService
  }, {
    type: GroupInfoService
  }, {
    type: ContextService
  }], {
    rowIndex: [{
      type: Input
    }],
    logicalRowIndex: [{
      type: Input
    }],
    item: [{
      type: Input
    }],
    skipGroupDecoration: [{
      type: Input
    }],
    hasDetails: [{
      type: Input
    }],
    totalColumnsCount: [{
      type: Input
    }],
    hasGroupHeaderColumn: [{
      type: Input
    }],
    groupHeaderColumns: [{
      type: Input
    }],
    columns: [{
      type: Input
    }],
    groups: [{
      type: Input
    }],
    groupItemClass: [{
      type: HostBinding,
      args: ["class.k-grouping-row"]
    }],
    tableGroupRowClass: [{
      type: HostBinding,
      args: ["class.k-table-group-row"]
    }]
  });
})();
var withoutField = ({
  field
}) => isNullOrEmptyString2(field);
var alreadyGrouped = ({
  groups,
  field
}) => groups.some((group2) => group2.field === field);
var overSameTarget = ({
  target,
  field
}) => target.field === field;
var overLastTarget = ({
  target
}) => target.lastTarget;
var isLastGroup = ({
  groups,
  field
}) => groups.map((group2) => group2.field).indexOf(field) === groups.length - 1;
var isNotGroupable = (groupsService) => ({
  field
}) => !groupsService.isGroupable(field);
var columnRules = (groupService) => or(withoutField, alreadyGrouped, isNotGroupable(groupService));
var indicatorRules = or(overSameTarget, and(overLastTarget, isLastGroup));
var GroupPanelComponent = class _GroupPanelComponent {
  hint;
  cue;
  groupInfoService;
  ctx;
  cd;
  popupService;
  ngZone;
  renderer;
  change = new EventEmitter();
  get groupHeaderClass() {
    return true;
  }
  set text(value2) {
    this.emptyText = value2;
  }
  get text() {
    return this.emptyText ? this.emptyText : this.ctx.localization.get("groupPanelEmpty");
  }
  navigable;
  groups = [];
  dropTargets = new QueryList();
  defaultTemplate;
  groupTitles = [];
  isChipMenuOpen = false;
  get gridId() {
    return this.ctx.grid?.ariaRootId;
  }
  rtl = false;
  first;
  last;
  arrowLeftIcon = arrowLeftIcon;
  arrowRightIcon = arrowRightIcon;
  emptyText;
  subscription;
  targetSubscription;
  popupSubs;
  popupRef;
  activeItem;
  constructor(hint, cue, groupInfoService, ctx, cd, popupService, ngZone, renderer) {
    this.hint = hint;
    this.cue = cue;
    this.groupInfoService = groupInfoService;
    this.ctx = ctx;
    this.cd = cd;
    this.popupService = popupService;
    this.ngZone = ngZone;
    this.renderer = renderer;
  }
  ngAfterViewInit() {
    this.subscription = this.ctx.localization.changes.subscribe(({
      rtl
    }) => {
      this.rtl = rtl;
      this.cd.markForCheck();
    });
    this.subscription.add(observe(this.dropTargets).subscribe(this.attachTargets.bind(this)));
  }
  ngDoCheck() {
    const currentTitles = this.groups.map((group2) => this.groupInfoService.groupTitle(group2));
    if (currentTitles.length !== this.groupTitles.length || currentTitles.some((current, idx4) => current !== this.groupTitles[idx4])) {
      this.groupTitles = currentTitles;
      this.cd.markForCheck();
    }
  }
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
    if (this.targetSubscription) {
      this.targetSubscription.unsubscribe();
    }
    this.destroyMenu();
  }
  messageFor(token) {
    return this.ctx.localization.get(token);
  }
  getTitle(group2) {
    return this.messageFor(group2.dir === "desc" ? "sortedDescending" : "sortedAscending");
  }
  getDirectionIcon(group2) {
    return group2.dir === "desc" ? "sort-desc-sm" : "sort-asc-sm";
  }
  getDirectionSvgIcon(group2) {
    return group2.dir === "desc" ? sortDescSmallIcon : sortAscSmallIcon;
  }
  directionChange(group2) {
    group2.dir = group2.dir ? group2.dir : "asc";
    group2.dir = group2.dir === "asc" ? "desc" : "asc";
    const index = this.groups.findIndex((x) => x.field === group2.field);
    const groups = [...this.groups.slice(0, index), group2, ...this.groups.slice(index + 1)];
    this.change.emit(groups);
  }
  insert(field, index) {
    const groups = this.groups.filter((x) => x.field !== field);
    if (groups.length || this.groups.length === 0) {
      this.change.emit([...groups.slice(0, index), {
        field
      }, ...groups.slice(index)]);
    }
  }
  remove(group2) {
    this.destroyMenu();
    this.change.emit(this.groups.filter((x) => x.field !== group2.field));
  }
  toggleMenu(chip, first, last4, field) {
    const anchor = chip.element.nativeElement.querySelector(".k-chip-action");
    if (this.popupRef) {
      const popupAnchor = this.popupRef.popup.instance.anchor;
      this.destroyMenu();
      if (anchor === popupAnchor) {
        return;
      }
    }
    this.first = first;
    this.last = last4;
    const direction = this.ctx.localization.rtl ? "right" : "left";
    this.popupRef = this.popupService.open({
      anchor,
      content: this.defaultTemplate,
      anchorAlign: {
        vertical: "bottom",
        horizontal: direction
      },
      popupAlign: {
        vertical: "top",
        horizontal: direction
      },
      positionMode: "absolute"
    });
    this.activeItem = this.dropTargets.find((dt) => dt.context.field === field);
    this.renderer.setAttribute(this.popupRef.popupElement, "dir", this.ctx.localization.rtl ? "rtl" : "ltr");
    const menuItems = Array.from(this.popupRef.popupElement.querySelectorAll(".k-menu-item"));
    this.activateMenuItem(menuItems[1], "previous");
    this.popupSubs = this.popupRef.popupAnchorViewportLeave.subscribe(() => {
      this.destroyMenu(true);
    });
    if (isUniversal()) {
      return;
    }
    this.ngZone.runOutsideAngular(() => {
      this.popupSubs.add(fromEvent(document, "click").pipe(filter((event) => !closest5(event.target, (node) => node === this.popupRef.popupElement || node.matches && node.matches(".k-chip-action")))).subscribe(() => {
        this.destroyMenu();
      }));
    });
  }
  handleKeyDown = (e) => {
    const code = normalizeKeys(e);
    if (code === Keys.ArrowDown || code === Keys.ArrowUp) {
      e.preventDefault();
      const relatedItemType = e.target.matches(":first-child") ? "next" : "previous";
      this.activateMenuItem(e.target, relatedItemType);
    } else if (code === Keys.Escape) {
      this.destroyMenu(true);
    } else if (code === Keys.Tab) {
      this.destroyMenu(true);
    } else if (code === Keys.Space || code === Keys.Enter) {
      this.handleMenuClick(e);
    }
  };
  handleClick = (e) => {
    e.preventDefault();
    const menuItemEl = e.target.closest(".k-menu-item");
    if (!menuItemEl.matches('[aria-disabled="true"]')) {
      this.handleMenuClick(e);
      return;
    }
    if (menuItemEl.getAttribute("tabindex") === "0") {
      return;
    }
    const activeMenuItem = menuItemEl.closest(".k-menu-group").querySelector('[tabindex="0"]');
    const relatedItemType = activeMenuItem.matches(":first-child") ? "next" : "previous";
    this.activateMenuItem(activeMenuItem, relatedItemType);
  };
  canDrop(draggable, target) {
    const isIndicator = draggable.type === "groupIndicator";
    const rules2 = isIndicator ? indicatorRules : columnRules(this.groupInfoService);
    return !rules2({
      field: draggable.field,
      groups: this.groups,
      target
    });
  }
  attachTargets() {
    if (this.targetSubscription) {
      this.targetSubscription.unsubscribe();
    }
    this.targetSubscription = new Subscription();
    const enterStream = this.dropTargets.reduce((acc, target) => merge(acc, target.enter), from([]));
    const leaveStream = this.dropTargets.reduce((acc, target) => merge(acc, target.leave), from([]));
    const dropStream = this.dropTargets.reduce((acc, target) => merge(acc, target.drop), from([]));
    this.targetSubscription.add(enterStream.pipe(tap(() => {
      this.hint.removeLock();
      this.destroyMenu();
    }), filter(({
      draggable,
      target
    }) => this.canDrop(draggable.context, target.context)), tap(this.enter.bind(this)), switchMapTo(dropStream.pipe(takeUntil(leaveStream.pipe(tap(this.leave.bind(this))))))).subscribe(this.drop.bind(this)));
  }
  enter({
    draggable,
    target
  }) {
    this.hint.enable();
    let before = target.context.lastTarget || isTargetBefore(draggable.element.nativeElement, target.element.nativeElement);
    if (this.ctx.localization.rtl) {
      before = !before;
    }
    this.cue.position(position(target.element.nativeElement, before));
  }
  leave() {
    this.hint.disable();
    this.cue.hide();
  }
  drop({
    target,
    draggable
  }) {
    const field = draggable.context.field;
    const index = this.dropTargets.toArray().indexOf(target);
    this.insert(field, index);
  }
  destroyMenu(focusAnchor) {
    if (this.popupRef) {
      this.popupRef.close();
      this.popupRef = null;
      this.popupSubs && this.popupSubs.unsubscribe();
      focusAnchor && this.activeItem.context.target.focus();
    }
  }
  activateMenuItem(item, relatedItemType) {
    this.renderer.setAttribute(item, "tabindex", "-1");
    this.renderer.removeClass(item, "k-focus");
    const relatedItem = item[`${relatedItemType}ElementSibling`];
    this.renderer.setAttribute(relatedItem, "tabindex", "0");
    this.renderer.addClass(relatedItem, "k-focus");
    this.ngZone.runOutsideAngular(() => setTimeout(() => relatedItem.focus()));
  }
  handleMenuClick(e) {
    e.preventDefault();
    if (e.target.getAttribute("aria-disabled") !== "true") {
      const chips = this.dropTargets.toArray().slice(0, this.dropTargets.length - 1);
      let groupChip, groupChipIndex;
      for (let i = 0; i < chips.length; i++) {
        if (chips[i].element.nativeElement === this.popupRef.popup.instance.anchor.closest(".k-chip")) {
          groupChip = chips[i];
          groupChipIndex = i;
          break;
        }
      }
      const isPrev = e.target.closest(".k-menu-item").matches(":first-child");
      if (isPrev && groupChipIndex > 0) {
        this.insert(groupChip.context.field, groupChipIndex - 1);
      } else if (!isPrev && groupChipIndex < chips.length - 1) {
        this.insert(groupChip.context.field, groupChipIndex + 1);
      }
      this.destroyMenu(true);
    }
  }
  static ɵfac = function GroupPanelComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _GroupPanelComponent)(ɵɵdirectiveInject(DragHintService), ɵɵdirectiveInject(DropCueService), ɵɵdirectiveInject(GroupInfoService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _GroupPanelComponent,
    selectors: [["kendo-grid-group-panel"]],
    viewQuery: function GroupPanelComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c57, 7, TemplateRef)(DropTargetDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.defaultTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dropTargets = _t);
      }
    },
    hostVars: 2,
    hostBindings: function GroupPanelComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-grouping-header", ctx.groupHeaderClass);
      }
    },
    inputs: {
      text: "text",
      navigable: "navigable",
      groups: "groups"
    },
    outputs: {
      change: "change"
    },
    decls: 5,
    vars: 3,
    consts: [["defaultTemplate", ""], ["chip", ""], ["kendoDropTarget", "", 1, "k-grouping-drop-container", 3, "context"], ["role", "none", 3, "navigable", "orientation"], ["kendoDropTarget", "", "kendoDraggableColumn", "", "kendoDraggable", "", 3, "title", "enableDrag", "context", "label", "removable", "hasMenu", "icon", "svgIcon"], ["kendoDropTarget", "", "kendoDraggableColumn", "", "kendoDraggable", "", 3, "contentClick", "remove", "menuToggle", "keydown.alt.arrowdown", "title", "enableDrag", "context", "label", "removable", "hasMenu", "icon", "svgIcon"], ["unselectable", "on", "role", "menu", 1, "k-group", "k-menu-group", "k-reset", "k-menu-group-md", 3, "kendoEventsOutsideAngular"], ["role", "menuitem", "unselectable", "on", 1, "k-item", "k-menu-item"], [1, "k-link", "k-menu-link"], [3, "name", "svgIcon"], [1, "k-menu-link-text"]],
    template: function GroupPanelComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵconditionalCreate(0, GroupPanelComponent_Conditional_0_Template, 2, 3, "div", 2);
        ɵɵconditionalCreate(1, GroupPanelComponent_Conditional_1_Template, 3, 2, "kendo-chiplist", 3);
        ɵɵconditionalCreate(2, GroupPanelComponent_Conditional_2_Template, 2, 2, "div", 2);
        ɵɵtemplate(3, GroupPanelComponent_ng_template_3_Template, 11, 16, "ng-template", null, 0, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        ɵɵconditional(ctx.groups.length === 0 ? 0 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.groups.length !== 0 ? 1 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.groups.length !== 0 ? 2 : -1);
      }
    },
    dependencies: [DropTargetDirective, ChipListComponent, ChipComponent, DraggableColumnDirective, DraggableDirective, EventsOutsideAngularDirective, IconWrapperComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GroupPanelComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-grid-group-panel",
      template: `
        @if (groups.length === 0) {
          <div
            class="k-grouping-drop-container"
            [context]="{
                lastTarget: true
            }"
            kendoDropTarget
            >
            {{ text }}
          </div>
        }
        
        @if (groups.length !== 0) {
          <kendo-chiplist
            [navigable]="navigable"
            role="none"
            [orientation]="null"
            >
            @for (group of groups; track group; let index = $index; let first = $first; let last = $last) {
              <kendo-chip
                #chip
                kendoDropTarget
                kendoDraggableColumn
                kendoDraggable
                [title]="getTitle(group)"
                [enableDrag]="true"
                [context]="{
                    field: group.field,
                    type: 'groupIndicator',
                    hint:  groupTitles[index],
                    target: chip
                }"
                [label]="groupTitles[index]"
                [removable]="true"
                [hasMenu]="true"
                [icon]="getDirectionIcon(group)"
                [svgIcon]="getDirectionSvgIcon(group)"
                [attr.aria-haspopup]="'menu'"
                [attr.aria-expanded]="isChipMenuOpen"
                [attr.aria-controls]="gridId"
                (contentClick)="directionChange(group)"
                (remove)="remove(group)"
                (menuToggle)="toggleMenu(chip, first, last, group.field)"
                (keydown.alt.arrowdown)="$event.preventDefault(); toggleMenu(chip, first, last, group.field)"
                >
              </kendo-chip>
            }
          </kendo-chiplist>
        }
        
        @if (groups.length !== 0) {
          <div
            class="k-grouping-drop-container"
            [context]="{
                lastTarget: true
            }"
            kendoDropTarget
          >&nbsp;</div>
        }
        
        <ng-template #defaultTemplate>
            <ul unselectable="on" role="menu" class="k-group k-menu-group k-reset k-menu-group-md" [kendoEventsOutsideAngular]="{
                keydown: handleKeyDown,
                click: handleClick
            }">
            <li role="menuitem" unselectable="on" class="k-item k-menu-item" [attr.aria-disabled]="first">
              <span class="k-link k-menu-link" [class.k-disabled]="first">
                <kendo-icon-wrapper
                  [name]="rtl ? 'arrow-right' : 'arrow-left'"
                [svgIcon]="rtl ? arrowRightIcon : arrowLeftIcon"></kendo-icon-wrapper>
                <span class="k-menu-link-text">{{messageFor('groupChipMenuPrevious')}}</span>
              </span>
            </li>
            <li role="menuitem" unselectable="on" class="k-item k-menu-item" [attr.aria-disabled]="last">
              <span class="k-link k-menu-link" [class.k-disabled]="last">
                <kendo-icon-wrapper
                  [name]="rtl ? 'arrow-left' : 'arrow-right'"
                [svgIcon]="rtl ? arrowLeftIcon : arrowRightIcon"></kendo-icon-wrapper>
                <span class="k-menu-link-text">{{messageFor('groupChipMenuNext')}}</span>
              </span>
            </li>
          </ul>
        </ng-template>
        `,
      standalone: true,
      imports: [DropTargetDirective, ChipListComponent, ChipComponent, DraggableColumnDirective, DraggableDirective, EventsOutsideAngularDirective, IconWrapperComponent]
    }]
  }], () => [{
    type: DragHintService
  }, {
    type: DropCueService
  }, {
    type: GroupInfoService
  }, {
    type: ContextService
  }, {
    type: ChangeDetectorRef
  }, {
    type: PopupService
  }, {
    type: NgZone
  }, {
    type: Renderer2
  }], {
    change: [{
      type: Output
    }],
    groupHeaderClass: [{
      type: HostBinding,
      args: ["class.k-grouping-header"]
    }],
    text: [{
      type: Input
    }],
    navigable: [{
      type: Input
    }],
    groups: [{
      type: Input
    }],
    dropTargets: [{
      type: ViewChildren,
      args: [DropTargetDirective]
    }],
    defaultTemplate: [{
      type: ViewChild,
      args: ["defaultTemplate", {
        static: true,
        read: TemplateRef
      }]
    }]
  });
})();
var localizeOperators$1 = (operators) => (localization) => Object.keys(operators).reduce((acc, key) => {
  acc[operators[key]] = localization.get(key);
  return acc;
}, {});
var operatorTexts = localizeOperators$1({
  "filterEqOperator": "eq",
  "filterNotEqOperator": "neq",
  "filterGteOperator": "gte",
  "filterGtOperator": "gt",
  "filterLteOperator": "lte",
  "filterLtOperator": "lt",
  "filterIsNullOperator": "isnull",
  "filterIsNotNullOperator": "isnotnull",
  "filterIsEmptyOperator": "isempty",
  "filterIsNotEmptyOperator": "isnotempty",
  "filterContainsOperator": "contains",
  "filterNotContainsOperator": "doesnotcontain",
  "filterStartsWithOperator": "startswith",
  "filterEndsWithOperator": "endswith",
  "filterAfterOrEqualOperator": "after-eq",
  "filterAfterOperator": "after",
  "filterBeforeOrEqualOperator": "before-eq",
  "filterBeforeOperator": "before"
});
var toJSON = (xs) => xs.map((x) => x.toJSON());
var FilterOperatorBase = class _FilterOperatorBase {
  operator;
  ctx;
  /**
   * The text that will be displayed in the drop-down list.
   * @readonly
   * @type {string}
   * @memberOf FilterOperatorBase
   */
  get text() {
    return this._text;
  }
  set text(value2) {
    this._text = isNullOrEmptyString2(value2) ? this.messages[this.operator] : value2;
  }
  subscription;
  messages;
  _text;
  constructor(operator, ctx) {
    this.operator = operator;
    this.ctx = ctx;
    this.messages = operatorTexts(this.ctx.localization);
    this._text = this.messages[this.operator];
    this.subscription = this.ctx.localization.changes.subscribe(this.refreshText.bind(this));
  }
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
  }
  /**
   * @hidden
   */
  toJSON() {
    return {
      text: this.text,
      value: this.operator
    };
  }
  refreshText() {
    const update2 = this._text === this.messages[this.operator];
    this.messages = operatorTexts(this.ctx.localization);
    if (update2) {
      this._text = this.messages[this.operator];
    }
  }
  static ɵfac = function FilterOperatorBase_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FilterOperatorBase)(ɵɵdirectiveInject("filterOperator"), ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _FilterOperatorBase,
    selectors: [["kendo-grid-filter-operator-base"]],
    inputs: {
      text: "text"
    },
    decls: 0,
    vars: 0,
    template: function FilterOperatorBase_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterOperatorBase, [{
    type: Component,
    args: [{
      selector: "kendo-grid-filter-operator-base",
      template: ``
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: ["filterOperator"]
    }]
  }, {
    type: ContextService
  }], {
    text: [{
      type: Input
    }]
  });
})();
var ContainsFilterOperatorComponent = class _ContainsFilterOperatorComponent extends FilterOperatorBase {
  constructor(ctx) {
    super("contains", ctx);
  }
  static ɵfac = function ContainsFilterOperatorComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ContainsFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ContainsFilterOperatorComponent,
    selectors: [["kendo-filter-contains-operator"]],
    features: [ɵɵProvidersFeature([{
      provide: FilterOperatorBase,
      useExisting: forwardRef(() => _ContainsFilterOperatorComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function ContainsFilterOperatorComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ContainsFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => ContainsFilterOperatorComponent)
      }],
      selector: "kendo-filter-contains-operator",
      template: ``,
      standalone: true
    }]
  }], () => [{
    type: ContextService
  }], null);
})();
var DoesNotContainFilterOperatorComponent = class _DoesNotContainFilterOperatorComponent extends FilterOperatorBase {
  constructor(ctx) {
    super("doesnotcontain", ctx);
  }
  static ɵfac = function DoesNotContainFilterOperatorComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DoesNotContainFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DoesNotContainFilterOperatorComponent,
    selectors: [["kendo-filter-not-contains-operator"]],
    features: [ɵɵProvidersFeature([{
      provide: FilterOperatorBase,
      useExisting: forwardRef(() => _DoesNotContainFilterOperatorComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DoesNotContainFilterOperatorComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DoesNotContainFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => DoesNotContainFilterOperatorComponent)
      }],
      selector: "kendo-filter-not-contains-operator",
      template: ``,
      standalone: true
    }]
  }], () => [{
    type: ContextService
  }], null);
})();
var EndsWithFilterOperatorComponent = class _EndsWithFilterOperatorComponent extends FilterOperatorBase {
  constructor(ctx) {
    super("endswith", ctx);
  }
  static ɵfac = function EndsWithFilterOperatorComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _EndsWithFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _EndsWithFilterOperatorComponent,
    selectors: [["kendo-filter-endswith-operator"]],
    features: [ɵɵProvidersFeature([{
      provide: FilterOperatorBase,
      useExisting: forwardRef(() => _EndsWithFilterOperatorComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function EndsWithFilterOperatorComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EndsWithFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => EndsWithFilterOperatorComponent)
      }],
      selector: "kendo-filter-endswith-operator",
      template: ``,
      standalone: true
    }]
  }], () => [{
    type: ContextService
  }], null);
})();
var EqualFilterOperatorComponent = class _EqualFilterOperatorComponent extends FilterOperatorBase {
  constructor(ctx) {
    super("eq", ctx);
  }
  static ɵfac = function EqualFilterOperatorComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _EqualFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _EqualFilterOperatorComponent,
    selectors: [["kendo-filter-eq-operator"]],
    features: [ɵɵProvidersFeature([{
      provide: FilterOperatorBase,
      useExisting: forwardRef(() => _EqualFilterOperatorComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function EqualFilterOperatorComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EqualFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => EqualFilterOperatorComponent)
      }],
      selector: "kendo-filter-eq-operator",
      template: ``,
      standalone: true
    }]
  }], () => [{
    type: ContextService
  }], null);
})();
var IsEmptyFilterOperatorComponent = class _IsEmptyFilterOperatorComponent extends FilterOperatorBase {
  constructor(ctx) {
    super("isempty", ctx);
  }
  static ɵfac = function IsEmptyFilterOperatorComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _IsEmptyFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _IsEmptyFilterOperatorComponent,
    selectors: [["kendo-filter-isempty-operator"]],
    features: [ɵɵProvidersFeature([{
      provide: FilterOperatorBase,
      useExisting: forwardRef(() => _IsEmptyFilterOperatorComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function IsEmptyFilterOperatorComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IsEmptyFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => IsEmptyFilterOperatorComponent)
      }],
      selector: "kendo-filter-isempty-operator",
      template: ``,
      standalone: true
    }]
  }], () => [{
    type: ContextService
  }], null);
})();
var IsNotEmptyFilterOperatorComponent = class _IsNotEmptyFilterOperatorComponent extends FilterOperatorBase {
  constructor(ctx) {
    super("isnotempty", ctx);
  }
  static ɵfac = function IsNotEmptyFilterOperatorComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _IsNotEmptyFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _IsNotEmptyFilterOperatorComponent,
    selectors: [["kendo-filter-isnotempty-operator"]],
    features: [ɵɵProvidersFeature([{
      provide: FilterOperatorBase,
      useExisting: forwardRef(() => _IsNotEmptyFilterOperatorComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function IsNotEmptyFilterOperatorComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IsNotEmptyFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => IsNotEmptyFilterOperatorComponent)
      }],
      selector: "kendo-filter-isnotempty-operator",
      template: ``,
      standalone: true
    }]
  }], () => [{
    type: ContextService
  }], null);
})();
var IsNotNullFilterOperatorComponent = class _IsNotNullFilterOperatorComponent extends FilterOperatorBase {
  constructor(ctx) {
    super("isnotnull", ctx);
  }
  static ɵfac = function IsNotNullFilterOperatorComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _IsNotNullFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _IsNotNullFilterOperatorComponent,
    selectors: [["kendo-filter-isnotnull-operator"]],
    features: [ɵɵProvidersFeature([{
      provide: FilterOperatorBase,
      useExisting: forwardRef(() => _IsNotNullFilterOperatorComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function IsNotNullFilterOperatorComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IsNotNullFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => IsNotNullFilterOperatorComponent)
      }],
      selector: "kendo-filter-isnotnull-operator",
      template: ``,
      standalone: true
    }]
  }], () => [{
    type: ContextService
  }], null);
})();
var IsNullFilterOperatorComponent = class _IsNullFilterOperatorComponent extends FilterOperatorBase {
  constructor(ctx) {
    super("isnull", ctx);
  }
  static ɵfac = function IsNullFilterOperatorComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _IsNullFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _IsNullFilterOperatorComponent,
    selectors: [["kendo-filter-isnull-operator"]],
    features: [ɵɵProvidersFeature([{
      provide: FilterOperatorBase,
      useExisting: forwardRef(() => _IsNullFilterOperatorComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function IsNullFilterOperatorComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IsNullFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => IsNullFilterOperatorComponent)
      }],
      selector: "kendo-filter-isnull-operator",
      template: ``,
      standalone: true
    }]
  }], () => [{
    type: ContextService
  }], null);
})();
var NotEqualFilterOperatorComponent = class _NotEqualFilterOperatorComponent extends FilterOperatorBase {
  constructor(ctx) {
    super("neq", ctx);
  }
  static ɵfac = function NotEqualFilterOperatorComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NotEqualFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _NotEqualFilterOperatorComponent,
    selectors: [["kendo-filter-neq-operator"]],
    features: [ɵɵProvidersFeature([{
      provide: FilterOperatorBase,
      useExisting: forwardRef(() => _NotEqualFilterOperatorComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function NotEqualFilterOperatorComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NotEqualFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => NotEqualFilterOperatorComponent)
      }],
      selector: "kendo-filter-neq-operator",
      template: ``,
      standalone: true
    }]
  }], () => [{
    type: ContextService
  }], null);
})();
var StartsWithFilterOperatorComponent = class _StartsWithFilterOperatorComponent extends FilterOperatorBase {
  constructor(ctx) {
    super("startswith", ctx);
  }
  static ɵfac = function StartsWithFilterOperatorComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _StartsWithFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _StartsWithFilterOperatorComponent,
    selectors: [["kendo-filter-startswith-operator"]],
    features: [ɵɵProvidersFeature([{
      provide: FilterOperatorBase,
      useExisting: forwardRef(() => _StartsWithFilterOperatorComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function StartsWithFilterOperatorComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StartsWithFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => StartsWithFilterOperatorComponent)
      }],
      selector: "kendo-filter-startswith-operator",
      template: ``,
      standalone: true
    }]
  }], () => [{
    type: ContextService
  }], null);
})();
var GreaterFilterOperatorComponent = class _GreaterFilterOperatorComponent extends FilterOperatorBase {
  constructor(ctx) {
    super("gt", ctx);
  }
  static ɵfac = function GreaterFilterOperatorComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _GreaterFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _GreaterFilterOperatorComponent,
    selectors: [["kendo-filter-gt-operator"]],
    features: [ɵɵProvidersFeature([{
      provide: FilterOperatorBase,
      useExisting: forwardRef(() => _GreaterFilterOperatorComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function GreaterFilterOperatorComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GreaterFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => GreaterFilterOperatorComponent)
      }],
      selector: "kendo-filter-gt-operator",
      template: ``,
      standalone: true
    }]
  }], () => [{
    type: ContextService
  }], null);
})();
var GreaterOrEqualToFilterOperatorComponent = class _GreaterOrEqualToFilterOperatorComponent extends FilterOperatorBase {
  constructor(ctx) {
    super("gte", ctx);
  }
  static ɵfac = function GreaterOrEqualToFilterOperatorComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _GreaterOrEqualToFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _GreaterOrEqualToFilterOperatorComponent,
    selectors: [["kendo-filter-gte-operator"]],
    features: [ɵɵProvidersFeature([{
      provide: FilterOperatorBase,
      useExisting: forwardRef(() => _GreaterOrEqualToFilterOperatorComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function GreaterOrEqualToFilterOperatorComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GreaterOrEqualToFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => GreaterOrEqualToFilterOperatorComponent)
      }],
      selector: "kendo-filter-gte-operator",
      template: ``,
      standalone: true
    }]
  }], () => [{
    type: ContextService
  }], null);
})();
var LessFilterOperatorComponent = class _LessFilterOperatorComponent extends FilterOperatorBase {
  constructor(ctx) {
    super("lt", ctx);
  }
  static ɵfac = function LessFilterOperatorComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LessFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _LessFilterOperatorComponent,
    selectors: [["kendo-filter-lt-operator"]],
    features: [ɵɵProvidersFeature([{
      provide: FilterOperatorBase,
      useExisting: forwardRef(() => _LessFilterOperatorComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function LessFilterOperatorComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LessFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => LessFilterOperatorComponent)
      }],
      selector: "kendo-filter-lt-operator",
      template: ``,
      standalone: true
    }]
  }], () => [{
    type: ContextService
  }], null);
})();
var LessOrEqualToFilterOperatorComponent = class _LessOrEqualToFilterOperatorComponent extends FilterOperatorBase {
  constructor(ctx) {
    super("lte", ctx);
  }
  static ɵfac = function LessOrEqualToFilterOperatorComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LessOrEqualToFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _LessOrEqualToFilterOperatorComponent,
    selectors: [["kendo-filter-lte-operator"]],
    features: [ɵɵProvidersFeature([{
      provide: FilterOperatorBase,
      useExisting: forwardRef(() => _LessOrEqualToFilterOperatorComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function LessOrEqualToFilterOperatorComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LessOrEqualToFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => LessOrEqualToFilterOperatorComponent)
      }],
      selector: "kendo-filter-lte-operator",
      template: ``,
      standalone: true
    }]
  }], () => [{
    type: ContextService
  }], null);
})();
var AfterFilterOperatorComponent = class _AfterFilterOperatorComponent extends FilterOperatorBase {
  constructor(ctx) {
    super("after", ctx);
  }
  /**
   * @hidden
   */
  toJSON() {
    return {
      text: this.text,
      value: "gt"
    };
  }
  static ɵfac = function AfterFilterOperatorComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AfterFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _AfterFilterOperatorComponent,
    selectors: [["kendo-filter-after-operator"]],
    features: [ɵɵProvidersFeature([{
      provide: FilterOperatorBase,
      useExisting: forwardRef(() => _AfterFilterOperatorComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function AfterFilterOperatorComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AfterFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => AfterFilterOperatorComponent)
      }],
      selector: "kendo-filter-after-operator",
      template: ``,
      standalone: true
    }]
  }], () => [{
    type: ContextService
  }], null);
})();
var AfterEqFilterOperatorComponent = class _AfterEqFilterOperatorComponent extends FilterOperatorBase {
  constructor(ctx) {
    super("after-eq", ctx);
  }
  /**
   * @hidden
   */
  toJSON() {
    return {
      text: this.text,
      value: "gte"
    };
  }
  static ɵfac = function AfterEqFilterOperatorComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AfterEqFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _AfterEqFilterOperatorComponent,
    selectors: [["kendo-filter-after-eq-operator"]],
    features: [ɵɵProvidersFeature([{
      provide: FilterOperatorBase,
      useExisting: forwardRef(() => _AfterEqFilterOperatorComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function AfterEqFilterOperatorComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AfterEqFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => AfterEqFilterOperatorComponent)
      }],
      selector: "kendo-filter-after-eq-operator",
      template: ``,
      standalone: true
    }]
  }], () => [{
    type: ContextService
  }], null);
})();
var BeforeEqFilterOperatorComponent = class _BeforeEqFilterOperatorComponent extends FilterOperatorBase {
  constructor(ctx) {
    super("before-eq", ctx);
  }
  /**
   * @hidden
   */
  toJSON() {
    return {
      text: this.text,
      value: "lte"
    };
  }
  static ɵfac = function BeforeEqFilterOperatorComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BeforeEqFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _BeforeEqFilterOperatorComponent,
    selectors: [["kendo-filter-before-eq-operator"]],
    features: [ɵɵProvidersFeature([{
      provide: FilterOperatorBase,
      useExisting: forwardRef(() => _BeforeEqFilterOperatorComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function BeforeEqFilterOperatorComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BeforeEqFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => BeforeEqFilterOperatorComponent)
      }],
      selector: "kendo-filter-before-eq-operator",
      template: ``,
      standalone: true
    }]
  }], () => [{
    type: ContextService
  }], null);
})();
var BeforeFilterOperatorComponent = class _BeforeFilterOperatorComponent extends FilterOperatorBase {
  constructor(ctx) {
    super("before", ctx);
  }
  /**
   * @hidden
   */
  toJSON() {
    return {
      text: this.text,
      value: "lt"
    };
  }
  static ɵfac = function BeforeFilterOperatorComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BeforeFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _BeforeFilterOperatorComponent,
    selectors: [["kendo-filter-before-operator"]],
    features: [ɵɵProvidersFeature([{
      provide: FilterOperatorBase,
      useExisting: forwardRef(() => _BeforeFilterOperatorComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function BeforeFilterOperatorComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BeforeFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => BeforeFilterOperatorComponent)
      }],
      selector: "kendo-filter-before-operator",
      template: ``,
      standalone: true
    }]
  }], () => [{
    type: ContextService
  }], null);
})();
var SizingOptionsService = class _SizingOptionsService {
  changes = new Subject();
  static ɵfac = function SizingOptionsService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SizingOptionsService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _SizingOptionsService,
    factory: _SizingOptionsService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SizingOptionsService, [{
    type: Injectable
  }], null, null);
})();
var FilterCellOperatorsComponent = class _FilterCellOperatorsComponent {
  ctx;
  sizing;
  clearText = "Clear";
  filterClearIcon = filterClearIcon;
  /**
   * @hidden
   */
  filterSVGIcon = filterIcon;
  /**
   * @hidden
   */
  size = "medium";
  /**
   * @hidden
   */
  get hostClasses() {
    return true;
  }
  /**
   * @hidden
   */
  dropdown;
  /**
   * Specifies the filter operators to display.
   * @type {Array<{ text: string, value: string }>}
   */
  operators = [];
  /**
   * Determines if the **Clear** button is displayed.
   * @type {boolean}
   */
  showButton;
  /**
   * Determines if the list of operators is displayed.
   * @type {boolean}
   * @default true
   */
  showOperators = true;
  /**
   * Represents the selected operator value.
   * @type {string}
   */
  value;
  /**
   * Sets the column instance for which the filter operators are displayed.
   * @type {ColumnComponent}
   */
  column;
  /**
   * Fires when the operator value changes.
   * @type {EventEmitter<string>}
   */
  valueChange = new EventEmitter();
  /**
   * Fires when the **Clear** button is clicked.
   * @type {EventEmitter<undefined>}
   */
  clear = new EventEmitter();
  subs;
  constructor(ctx, sizing) {
    this.ctx = ctx;
    this.sizing = sizing;
  }
  /**
   * @hidden
   */
  onChange(dataItem) {
    this.valueChange.emit(dataItem);
  }
  /**
   * @hidden
   */
  clearClick() {
    this.clear.emit();
    return false;
  }
  /**
   * @hidden
   */
  clearKeydown(args) {
    if (args.code === Keys.Enter || args.code === Keys.NumpadEnter || args.code === Keys.Space) {
      this.clear.emit();
    }
  }
  /**
   * @hidden
   */
  dropdownKeydown(args) {
    if (args.defaultPrevented) {
      return;
    }
    if ((args.code === Keys.Enter || args.code === Keys.NumpadEnter) && !this.dropdown.isOpen) {
      this.dropdown.toggle(true);
      args.preventDefault();
    }
  }
  ngOnInit() {
    this.subs = this.ctx.localization.changes.subscribe(() => this.clearText = this.ctx.localization.get("filterClearButton"));
    this.subs.add(this.sizing.changes.subscribe((size) => this.size = size));
  }
  ngOnDestroy() {
    if (this.subs) {
      this.subs.unsubscribe();
    }
  }
  /**
   * @hidden
   */
  get columnLabel() {
    const localizationMsg = this.ctx.localization.get("filterCellOperatorLabel") || "";
    const columnName = this.column.title || this.column.field;
    return replaceMessagePlaceholder(localizationMsg, "columnName", columnName);
  }
  static ɵfac = function FilterCellOperatorsComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FilterCellOperatorsComponent)(ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(SizingOptionsService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _FilterCellOperatorsComponent,
    selectors: [["kendo-grid-filter-cell-operators"]],
    viewQuery: function FilterCellOperatorsComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c95, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dropdown = _t.first);
      }
    },
    hostVars: 2,
    hostBindings: function FilterCellOperatorsComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-filtercell-operator", ctx.hostClasses);
      }
    },
    inputs: {
      operators: "operators",
      showButton: "showButton",
      showOperators: "showOperators",
      value: "value",
      column: "column"
    },
    outputs: {
      valueChange: "valueChange",
      clear: "clear"
    },
    decls: 2,
    vars: 2,
    consts: [["dropdown", ""], ["kendoGridFocusable", "", "icon", "filter", "textField", "text", "valueField", "value", 1, "k-dropdown-operator", 3, "data", "value", "svgIcon", "valuePrimitive", "popupSettings", "size"], ["type", "button", "kendoButton", "", "kendoGridFocusable", "", "icon", "filter-clear", 3, "svgIcon", "title", "size"], ["kendoGridFocusable", "", "icon", "filter", "textField", "text", "valueField", "value", 1, "k-dropdown-operator", 3, "valueChange", "keydown", "data", "value", "svgIcon", "valuePrimitive", "popupSettings", "size"], ["type", "button", "kendoButton", "", "kendoGridFocusable", "", "icon", "filter-clear", 3, "click", "keydown", "svgIcon", "title", "size"]],
    template: function FilterCellOperatorsComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵconditionalCreate(0, FilterCellOperatorsComponent_Conditional_0_Template, 2, 8, "kendo-dropdownlist", 1);
        ɵɵconditionalCreate(1, FilterCellOperatorsComponent_Conditional_1_Template, 1, 3, "button", 2);
      }
      if (rf & 2) {
        ɵɵconditional(ctx.showOperators ? 0 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.showButton ? 1 : -1);
      }
    },
    dependencies: [DropDownListComponent, FocusableDirective, ButtonComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterCellOperatorsComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-filter-cell-operators",
      template: `
        @if (showOperators) {
          <kendo-dropdownlist
            #dropdown
            kendoGridFocusable
            [attr.aria-label]="column && columnLabel"
            [data]="operators"
            class="k-dropdown-operator"
            (valueChange)="onChange($event)"
            [value]="value"
            icon="filter"
            [svgIcon]="filterSVGIcon"
            [valuePrimitive]="true"
            textField="text"
            [popupSettings]="{ width: 'auto' }"
            valueField="value"
            [size]="size"
            (keydown)="dropdownKeydown($event)">
          </kendo-dropdownlist>
        }
        @if (showButton) {
          <button type="button"
            kendoButton
            kendoGridFocusable
            icon="filter-clear"
            [svgIcon]="filterClearIcon"
            [title]="clearText"
            [size]="size"
            (click)="clearClick()"
          (keydown)="clearKeydown($event)"></button>
        }
        `,
      standalone: true,
      imports: [DropDownListComponent, FocusableDirective, ButtonComponent]
    }]
  }], () => [{
    type: ContextService
  }, {
    type: SizingOptionsService
  }], {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-filtercell-operator"]
    }],
    dropdown: [{
      type: ViewChild,
      args: ["dropdown", {
        static: false
      }]
    }],
    operators: [{
      type: Input
    }],
    showButton: [{
      type: Input
    }],
    showOperators: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    column: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    clear: [{
      type: Output
    }]
  });
})();
var FilterInputDirective = class _FilterInputDirective {
  ngZone;
  element;
  renderer;
  change = new EventEmitter();
  composing = false;
  kendoInput;
  filterDelay = 500;
  columnLabel;
  set value(value2) {
    this.accessor.writeValue(value2);
  }
  set disabled(value2) {
    this.accessor.setDisabledState(value2);
  }
  accessor;
  changeRequests = new Subject();
  changeRequestsSubscription;
  unsubscribeEvents;
  constructor(valueAccessors, ngZone, element, renderer) {
    this.ngZone = ngZone;
    this.element = element;
    this.renderer = renderer;
    this.accessor = valueAccessors[0];
    ngZone.runOutsideAngular(() => {
      const unsubscribeStart = renderer.listen(element.nativeElement, "compositionstart", () => this.composing = true);
      const unsubscribeEnd = renderer.listen(element.nativeElement, "compositionend", (event) => {
        this.composing = false;
        const value2 = event.target?.value;
        this.filterDelay > 0 ? this.changeRequests.next(value2) : this.change.emit(value2);
      });
      this.unsubscribeEvents = () => {
        unsubscribeStart();
        unsubscribeEnd();
      };
    });
  }
  ngAfterViewInit() {
    this.addAriaAttributes();
    this.accessor.registerOnChange((x) => this.filterDelay > 0 ? this.changeRequests.next(x) : this.change.emit(x));
    this.subscribeChanges();
  }
  ngOnChanges(changes) {
    if (isChanged("filterDelay", changes)) {
      this.unsubscribeChanges();
      this.subscribeChanges();
    }
  }
  ngOnDestroy() {
    this.unsubscribeChanges();
    this.unsubscribeEvents();
  }
  subscribeChanges() {
    this.changeRequestsSubscription = this.changeRequests.pipe(debounceTime(this.filterDelay), filter(() => !this.composing)).subscribe((x) => {
      this.ngZone.run(() => {
        this.change.emit(x);
      });
    });
  }
  unsubscribeChanges() {
    if (this.changeRequestsSubscription) {
      this.changeRequestsSubscription.unsubscribe();
    }
  }
  addAriaAttributes() {
    const ariaValue = this.columnLabel;
    if (this.kendoInput && this.kendoInput.focusableId && isDocumentAvailable()) {
      const focusableElement = this.element.nativeElement.querySelector(`#${this.kendoInput.focusableId}`) || this.element.nativeElement;
      this.renderer.setAttribute(focusableElement, "aria-label", ariaValue);
    } else {
      const inputElement = this.element.nativeElement.querySelector(".k-input-inner");
      const elementToSetLabel = inputElement ? inputElement : this.element.nativeElement;
      if (ariaValue) {
        this.renderer.setAttribute(elementToSetLabel, "aria-label", ariaValue);
      }
    }
  }
  static ɵfac = function FilterInputDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FilterInputDirective)(ɵɵdirectiveInject(NG_VALUE_ACCESSOR, 2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FilterInputDirective,
    selectors: [["", "kendoFilterInput", ""]],
    contentQueries: function FilterInputDirective_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, KendoInput, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.kendoInput = _t.first);
      }
    },
    inputs: {
      filterDelay: "filterDelay",
      columnLabel: "columnLabel",
      value: "value"
    },
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterInputDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoFilterInput]",
      standalone: true
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Self
    }, {
      type: Inject,
      args: [NG_VALUE_ACCESSOR]
    }]
  }, {
    type: NgZone
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }], {
    kendoInput: [{
      type: ContentChild,
      args: [KendoInput, {
        static: true
      }]
    }],
    filterDelay: [{
      type: Input
    }],
    columnLabel: [{
      type: Input
    }],
    value: [{
      type: Input
    }]
  });
})();
var MenuTabbingService = class _MenuTabbingService {
  firstFocusable;
  lastFocusable;
  isColumnMenu = false;
  isPopupOpen = false;
  lastMenuItem;
  isTabbedInterface = false;
  static ɵfac = function MenuTabbingService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MenuTabbingService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _MenuTabbingService,
    factory: _MenuTabbingService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MenuTabbingService, [{
    type: Injectable
  }], null, null);
})();
var FilterService = class _FilterService {
  /**
   * @hidden
   */
  menuTabbingService;
  /**
   * Fires when the filter descriptor is set.
   */
  changes = new Subject();
  /**
   * Sets the filter descriptor.
   *
   * @param {CompositeFilterDescriptor} value - The filter descriptor to set.
   */
  filter(value2) {
    this.changes.next(value2);
  }
  /**
   * @hidden
   */
  constructor(menuTabbingService) {
    this.menuTabbingService = menuTabbingService;
  }
  static ɵfac = function FilterService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FilterService)(ɵɵinject(MenuTabbingService, 8));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _FilterService,
    factory: _FilterService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterService, [{
    type: Injectable
  }], () => [{
    type: MenuTabbingService,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var ScrollSyncService2 = class _ScrollSyncService {
  ngZone;
  changes = new Subject();
  elements = [];
  source;
  subscriptions = new Subscription();
  headerSubscription = new Subscription();
  bodySubscription = new Subscription();
  constructor(ngZone) {
    this.ngZone = ngZone;
    this.subscriptions.add(this.changes.subscribe((args) => this.scrollLeft(args)));
  }
  registerEmitter(el, sourceType) {
    this.unregister(sourceType);
    this.elements.push({
      element: el,
      sourceType
    });
    if (sourceType === "body" || sourceType === "header") {
      this.ngZone.runOutsideAngular(() => {
        const obs = fromEvent(el, "scroll").pipe(map(({
          target: {
            scrollLeft
          }
        }) => ({
          scrollLeft,
          sourceType
        })));
        const subscription = obs.pipe(distinctUntilChanged((x, y) => x.scrollLeft === y.scrollLeft), filter((x) => !this.source || this.source === x.sourceType), tap((x) => this.source = x.sourceType)).subscribe((x) => this.changes.next(x));
        subscription.add(obs.pipe(filter((x) => this.source && this.source !== x.sourceType)).subscribe(() => this.source = void 0));
        if (sourceType === "body") {
          this.bodySubscription.add(subscription);
        } else {
          this.headerSubscription.add(subscription);
        }
      });
    }
  }
  /**
   * destroy
   */
  destroy() {
    this.subscriptions.unsubscribe();
    this.headerSubscription.unsubscribe();
    this.bodySubscription.unsubscribe();
  }
  scrollLeft({
    scrollLeft,
    sourceType
  }) {
    this.ngZone.runOutsideAngular(() => {
      this.elements.filter((x) => sourceType !== x.sourceType).forEach(({
        element
      }) => element.scrollLeft = scrollLeft);
    });
  }
  unregister(sourceType) {
    const index = this.elements.findIndex((x) => x.sourceType === sourceType);
    if (index > -1) {
      if (sourceType === "header") {
        this.headerSubscription.unsubscribe();
        this.headerSubscription = new Subscription();
      } else if (sourceType === "body") {
        this.bodySubscription.unsubscribe();
        this.bodySubscription = new Subscription();
      }
      this.elements.splice(index, 1);
    }
  }
  static ɵfac = function ScrollSyncService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ScrollSyncService)(ɵɵinject(NgZone));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ScrollSyncService,
    factory: _ScrollSyncService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollSyncService2, [{
    type: Injectable
  }], () => [{
    type: NgZone
  }], null);
})();
var AdaptiveGridService = class _AdaptiveGridService {
  ctx;
  adaptiveService;
  /**
   * Emits when the ActionSheet view animation ends.
   */
  get animationEnd() {
    return this.animationEndSubject.asObservable();
  }
  columnMenuService;
  columns = [];
  secondaryView;
  viewType;
  popupRef;
  column;
  filterMenuContainer;
  filterMenuContainerComponentRef;
  animationEndSubject = new Subject();
  constructor(ctx, adaptiveService) {
    this.ctx = ctx;
    this.adaptiveService = adaptiveService;
  }
  submitFilter() {
    this.filterMenuContainer.submit();
    this.ctx.grid.adaptiveRenderer.actionSheet.toggle(false);
    this.reset();
  }
  resetFilter() {
    this.filterMenuContainer.reset();
    this.ctx.grid.adaptiveRenderer.actionSheet.toggle(false);
    this.reset();
  }
  reset() {
    this.ctx.grid.adaptiveRenderer.actionSheet.currentView = 1;
    this.filterMenuContainerComponentRef?.destroy();
    this.column = null;
    this.popupRef = null;
    this.filterMenuContainer = null;
    this.viewType = null;
    this.secondaryView = null;
  }
  /**
   * Notifies that the ActionSheet animation has ended.
   */
  notifyAnimationEnd() {
    this.animationEndSubject.next();
  }
  get windowSize() {
    return this.adaptiveService.size;
  }
  static ɵfac = function AdaptiveGridService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AdaptiveGridService)(ɵɵinject(ContextService), ɵɵinject(AdaptiveService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _AdaptiveGridService,
    factory: _AdaptiveGridService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AdaptiveGridService, [{
    type: Injectable
  }], () => [{
    type: ContextService
  }, {
    type: AdaptiveService
  }], null);
})();
var contains = (node, predicate) => {
  while (node) {
    if (predicate(node)) {
      return true;
    }
    node = node.parentNode;
  }
  return false;
};
var PopupCloseEvent = class extends PreventableEvent7 {
  /**
   * The original DOM event that causes the popup to close.
   */
  originalEvent;
  /**
   * @hidden
   */
  constructor(e) {
    super();
    this.originalEvent = e;
  }
};
var DEFAULT_POPUP_CLASS = "k-grid-filter-popup";
var SinglePopupService = class _SinglePopupService {
  popupService;
  renderer;
  ngZone;
  ctx;
  adaptiveGridService;
  /**
   * Emits when the filter or column menu popup is about to close because the user clicked outside.
   * Use this event to prevent the popup from closing.
   */
  onClose = new Subject();
  removeClick;
  pointerEventsSub = new Subscription();
  popupRef;
  scrollSubscription;
  canClosePopup = true;
  /**
   * @hidden
   */
  constructor(popupService, renderer, ngZone, scrollSyncService, ctx, adaptiveGridService) {
    this.popupService = popupService;
    this.renderer = renderer;
    this.ngZone = ngZone;
    this.ctx = ctx;
    this.adaptiveGridService = adaptiveGridService;
    this.scrollSubscription = scrollSyncService.changes.pipe(skip(1)).subscribe(() => this.destroy());
  }
  /**
   * @hidden
   */
  open(anchor, template, popupRef, popupClass = DEFAULT_POPUP_CLASS) {
    const toggle = isPresent7(popupRef) && this.popupRef === popupRef;
    this.destroy();
    if (!toggle) {
      const direction = this.ctx.localization.rtl ? "right" : "left";
      this.popupRef = this.popupService.open({
        anchorAlign: {
          vertical: "bottom",
          horizontal: direction
        },
        popupAlign: {
          vertical: "top",
          horizontal: direction
        },
        anchor,
        popupClass,
        content: template,
        positionMode: "absolute"
      });
      this.adaptiveGridService.popupRef = this.popupRef;
      this.renderer.setAttribute(this.popupRef.popupElement, "dir", this.ctx.localization.rtl ? "rtl" : "ltr");
      this.attachClose(anchor);
    }
    const popupEl = this.popupRef?.popupElement;
    if (popupEl) {
      this.attachMouseListeners(popupEl);
    }
    return this.popupRef;
  }
  /**
   * @hidden
   */
  destroy() {
    if (this.popupRef) {
      this.detachClose();
      this.pointerEventsSub.unsubscribe();
      this.pointerEventsSub = null;
      this.popupRef.close();
      this.popupRef = null;
      this.adaptiveGridService.popupRef = null;
    }
  }
  ngOnDestroy() {
    this.destroy();
    this.scrollSubscription.unsubscribe();
  }
  detachClose() {
    if (this.removeClick) {
      this.removeClick();
    }
  }
  attachClose(skipElement) {
    if (!isDocumentAvailable()) {
      return;
    }
    this.detachClose();
    this.ngZone.runOutsideAngular(() => this.removeClick = this.renderer.listen("document", "click", (e) => {
      if (!contains(e.target, (x) => this.popupRef.popupElement === x || x === skipElement)) {
        const args = new PopupCloseEvent(e);
        this.onClose.next(args);
        if (!args.isDefaultPrevented() && this.canClosePopup) {
          this.destroy();
        }
        this.canClosePopup = true;
      }
    }));
  }
  attachMouseListeners(el) {
    this.pointerEventsSub = new Subscription();
    this.ngZone.runOutsideAngular(() => {
      this.pointerEventsSub.add(this.renderer.listen(el, "pointerdown", (e) => {
        e.stopImmediatePropagation();
        this.canClosePopup = false;
      }));
      this.pointerEventsSub.add(this.renderer.listen(el, "pointerup", () => {
        this.canClosePopup = true;
      }));
    });
  }
  static ɵfac = function SinglePopupService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SinglePopupService)(ɵɵinject(PopupService), ɵɵinject(Renderer2), ɵɵinject(NgZone), ɵɵinject(ScrollSyncService2), ɵɵinject(ContextService), ɵɵinject(AdaptiveGridService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _SinglePopupService,
    factory: _SinglePopupService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SinglePopupService, [{
    type: Injectable
  }], () => [{
    type: PopupService
  }, {
    type: Renderer2
  }, {
    type: NgZone
  }, {
    type: ScrollSyncService2
  }, {
    type: ContextService
  }, {
    type: AdaptiveGridService
  }], null);
})();
var insertDefaultFilter = (index, rootFilter, filter3) => {
  rootFilter = rootFilter || {
    filters: [],
    logic: "and"
  };
  rootFilter.filters[index] = filter3;
  return filter3;
};
var setFilter = (index, filter3, field, defaultOperator) => {
  if (isPresent7(filter3) && isPresent7(filter3.filters) && filter3.filters.length > index) {
    return filter3.filters[index];
  } else {
    return insertDefaultFilter(index, filter3, {
      field,
      operator: defaultOperator
    });
  }
};
var logicOperators = (localization) => [{
  text: localization.get("filterAndLogic"),
  value: "and"
}, {
  text: localization.get("filterOrLogic"),
  value: "or"
}];
var flatten2 = (filter3) => {
  if (isPresent7(filter3.filters)) {
    return filter3.filters.reduce((acc, curr) => acc.concat(isCompositeFilterDescriptor(curr) ? flatten2(curr) : [curr]), []);
  }
  return [];
};
var trimFilterByField = (filter3, field) => {
  if (isPresent7(filter3) && isPresent7(filter3.filters)) {
    filter3.filters = filter3.filters.filter((x) => {
      if (isCompositeFilterDescriptor(x)) {
        trimFilterByField(x, field);
        return x.filters.length;
      } else {
        return x.field !== field;
      }
    });
  }
};
var filtersByField = (filter3, field) => flatten2(filter3 || {}).filter((x) => x.field === field);
var filterByField = (filter3, field) => {
  const [currentFilter] = filtersByField(filter3, field);
  return currentFilter;
};
var removeFilter = (filter3, field) => {
  trimFilterByField(filter3, field);
  return filter3;
};
var localizeOperators = (operators) => (localization) => Object.keys(operators).map((key) => ({
  text: localization.get(key),
  value: operators[key]
}));
var BaseFilterCellComponent = class _BaseFilterCellComponent {
  filterService;
  get hostClasses() {
    return true;
  }
  operatorList = new QueryList();
  get operators() {
    return this._operators?.length ? this._operators : this.defaultOperators;
  }
  set operators(values) {
    this._operators = values;
  }
  /**
   * @hidden
   */
  size = "medium";
  /**
   * The current root filter.
   * @type {CompositeFilterDescriptor}
   */
  filter;
  defaultOperators;
  _operators;
  operationListSubscription;
  constructor(filterService) {
    this.filterService = filterService;
  }
  /**
   * @hidden
   */
  ngAfterContentInit() {
    this.operationListSubscription = observe(this.operatorList).pipe(map((q) => q.toArray()), map(toJSON)).subscribe((x) => {
      this.operators = x;
    });
  }
  ngOnDestroy() {
    if (this.operationListSubscription) {
      this.operationListSubscription.unsubscribe();
    }
  }
  filterByField(field) {
    return filterByField(this.filter, field);
  }
  filtersByField(field) {
    return filtersByField(this.filter, field);
  }
  removeFilter(field) {
    return removeFilter(this.filter, field);
  }
  updateFilter(filter3) {
    const root = this.filter || {
      filters: [],
      logic: "and"
    };
    const [currentFilter] = flatten2(root).filter((x) => x.field === filter3.field);
    if (!isPresent7(currentFilter)) {
      root.filters.push(filter3);
    } else {
      Object.assign(currentFilter, filter3);
    }
    return root;
  }
  applyFilter(filter3) {
    this.filterService.filter(filter3);
  }
  static ɵfac = function BaseFilterCellComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BaseFilterCellComponent)(ɵɵdirectiveInject(FilterService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _BaseFilterCellComponent,
    contentQueries: function BaseFilterCellComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, FilterOperatorBase, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.operatorList = _t);
      }
    },
    hostVars: 2,
    hostBindings: function BaseFilterCellComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-filtercell", ctx.hostClasses);
      }
    },
    inputs: {
      operators: "operators",
      filter: "filter"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BaseFilterCellComponent, [{
    type: Directive,
    args: [{}]
  }], () => [{
    type: FilterService
  }], {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-filtercell"]
    }],
    operatorList: [{
      type: ContentChildren,
      args: [FilterOperatorBase]
    }],
    operators: [{
      type: Input
    }],
    filter: [{
      type: Input
    }]
  });
})();
var copyObject = (obj) => {
  const result = {};
  Object.assign(result, obj);
  if (obj.constructor !== Object) {
    const proto = obj.constructor.prototype;
    Object.getOwnPropertyNames(proto).forEach((property) => {
      if (property !== "constructor" && property !== "__proto__" && property !== "prototype" && proto.hasOwnProperty(property)) {
        result[property] = obj[property];
      }
    });
  }
  return result;
};
var cloneFilter = (filter3) => copyObject(filter3);
var cloneFilters = (filter3) => {
  if (!filter3) {
    return;
  }
  if (isCompositeFilterDescriptor(filter3)) {
    return {
      filters: cloneFilters(filter3.filters),
      logic: filter3.logic
    };
  } else if (Array.isArray(filter3)) {
    return filter3.map(cloneFilters);
  }
  return cloneFilter(filter3);
};
var FilterHostDirective = class _FilterHostDirective {
  host;
  column;
  filter;
  component;
  constructor(host) {
    this.host = host;
  }
  ngOnInit() {
    this.component = this.host.createComponent(this.componentType());
    this.initComponent({
      column: this.column,
      filter: this.filter
    });
  }
  ngOnDestroy() {
    if (this.component) {
      this.component.destroy();
      this.component = null;
    }
  }
  ngOnChanges(changes) {
    if (anyChanged(["column", "filter"], changes)) {
      this.initComponent({
        column: this.column,
        filter: this.filter
      });
    }
  }
  initComponent({
    column,
    filter: filter3
  }) {
    const instance = this.component.instance;
    instance.column = column;
    instance.filter = filter3;
  }
  static ɵfac = function FilterHostDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FilterHostDirective)(ɵɵdirectiveInject(ViewContainerRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FilterHostDirective,
    selectors: [["", "kendoGridFilterHostBase", ""]],
    inputs: {
      column: "column",
      filter: "filter"
    },
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterHostDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridFilterHostBase]"
    }]
  }], () => [{
    type: ViewContainerRef
  }], {
    column: [{
      type: Input
    }],
    filter: [{
      type: Input
    }]
  });
})();
var stringOperators$1 = localizeOperators({
  "filterEqOperator": "eq",
  "filterNotEqOperator": "neq",
  "filterContainsOperator": "contains",
  "filterNotContainsOperator": "doesnotcontain",
  "filterStartsWithOperator": "startswith",
  "filterEndsWithOperator": "endswith",
  "filterIsNullOperator": "isnull",
  "filterIsNotNullOperator": "isnotnull",
  "filterIsEmptyOperator": "isempty",
  "filterIsNotEmptyOperator": "isnotempty"
});
var StringFilterComponent = class _StringFilterComponent extends BaseFilterCellComponent {
  ctx;
  /**
   * Sets the column for this filter.
   * @type {ColumnComponent}
   */
  column;
  /**
   * Sets the default filter operator.
   * @type {string}
   * @default 'contains'
   */
  operator = "contains";
  /**
   * Gets the current filter for the column field.
   * @readonly
   * @type {FilterDescriptor}
   */
  get currentFilter() {
    return this.filterByField((this.column || {}).field);
  }
  /**
   * Gets the current filter operator for the column field.
   * @readonly
   * @type {string}
   */
  get currentOperator() {
    return this.currentFilter ? this.currentFilter.operator : this.operator;
  }
  subscription;
  constructor(filterService, ctx) {
    super(filterService);
    this.ctx = ctx;
  }
  ngOnInit() {
    this.subscription = this.ctx.localization.changes.subscribe(this.localizationChange.bind(this));
  }
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
    super.ngOnDestroy();
  }
  localizationChange() {
    this.defaultOperators = stringOperators$1(this.ctx.localization);
    if (this.operatorList.length) {
      this.operators = toJSON(this.operatorList.toArray());
    }
  }
  static ɵfac = function StringFilterComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _StringFilterComponent)(ɵɵdirectiveInject(FilterService), ɵɵdirectiveInject(ContextService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _StringFilterComponent,
    inputs: {
      column: "column",
      operator: "operator"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StringFilterComponent, [{
    type: Directive,
    args: [{}]
  }], () => [{
    type: FilterService
  }, {
    type: ContextService
  }], {
    column: [{
      type: Input
    }],
    operator: [{
      type: Input
    }]
  });
})();
var FilterMenuDropDownListDirective = class _FilterMenuDropDownListDirective {
  host;
  filterMenuDropDownLabel;
  constructor(host) {
    this.host = host;
  }
  ngAfterViewInit() {
    const wrapperElement = this.host.wrapper.nativeElement;
    wrapperElement.setAttribute("aria-label", this.filterMenuDropDownLabel);
    wrapperElement.addEventListener("keydown", this.keydownHandler, true);
  }
  ngOnDestroy() {
    this.host.wrapper.nativeElement.removeEventListener("keydown", this.keydownHandler);
  }
  keydownHandler = (e) => {
    if (e.code === Keys.Escape && this.host.isOpen) {
      e.stopPropagation();
      this.host.toggle(false);
    }
  };
  static ɵfac = function FilterMenuDropDownListDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FilterMenuDropDownListDirective)(ɵɵdirectiveInject(DropDownListComponent));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FilterMenuDropDownListDirective,
    selectors: [["", "kendoFilterMenuDropDown", ""]],
    inputs: {
      filterMenuDropDownLabel: "filterMenuDropDownLabel"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterMenuDropDownListDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoFilterMenuDropDown]",
      standalone: true
    }]
  }], () => [{
    type: DropDownListComponent
  }], {
    filterMenuDropDownLabel: [{
      type: Input
    }]
  });
})();
var EMPTY_VALUE_OPERATORS = /* @__PURE__ */ new Set(["isnull", "isnotnull", "isempty", "isnotempty"]);
var isEmptyValueOperator = (operator) => EMPTY_VALUE_OPERATORS.has(operator);
var FilterInputWrapperComponent = class _FilterInputWrapperComponent extends BaseFilterCellComponent {
  column;
  input;
  get currentFilter() {
    return this.filterByField(this.column.field);
  }
  get currentOperator() {
    const filter3 = this.currentFilter;
    if (!this._operator) {
      this._operator = filter3 ? filter3.operator : this.defaultOperator;
    }
    return this._operator;
  }
  set currentOperator(value2) {
    this._operator = value2;
    const emptyValueOperator = isEmptyValueOperator(value2);
    this.filterInputDisabled = emptyValueOperator;
    if (emptyValueOperator) {
      this.applyNoValueFilter(value2);
    } else if (!isBlank2(value2) && isPresent7(this.currentFilter)) {
      this.onChange(this.currentFilter.value);
    }
  }
  get defaultOperator() {
    if (!isNullOrEmptyString2(this._defaultOperator)) {
      return this._defaultOperator;
    } else if (this.operators && this.operators.length) {
      return this.operators[0].value;
    }
    return "eq";
  }
  set defaultOperator(value2) {
    this._defaultOperator = value2;
  }
  set filterInputDisabled(disabled) {
    if (!this.input) {
      return;
    }
    this.input.disabled = disabled;
  }
  _defaultOperator;
  _operator;
  changeSubscription;
  constructor(filterService) {
    super(filterService);
  }
  ngAfterContentInit() {
    if (isPresent7(this.input)) {
      this.changeSubscription = this.input.change.subscribe(this.onChange.bind(this));
      this.filterInputDisabled = isEmptyValueOperator(this.currentOperator);
    }
  }
  ngOnDestroy() {
    super.ngOnDestroy();
    if (this.changeSubscription) {
      this.changeSubscription.unsubscribe();
    }
  }
  onChange(value2) {
    if (!isNullOrEmptyString2(value2) || this.filterByField(this.column.field)) {
      this.filterChange(isNullOrEmptyString2(value2) ? this.removeFilter(this.column.field) : this.updateFilter({
        field: this.column.field,
        operator: this.currentOperator,
        value: value2
      }));
    }
  }
  onClear() {
    this.onChange(null);
    this.filterInputDisabled = isEmptyValueOperator(this.defaultOperator);
  }
  applyNoValueFilter(operator) {
    this.filterChange(this.updateFilter({
      field: this.column.field,
      operator,
      value: null
    }));
  }
  ngOnChanges(changes) {
    if (isChanged("filter", changes, false)) {
      this._operator = null;
      this.filterInputDisabled = isEmptyValueOperator(this.currentOperator);
    }
  }
  static ɵfac = function FilterInputWrapperComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FilterInputWrapperComponent)(ɵɵdirectiveInject(FilterService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FilterInputWrapperComponent,
    contentQueries: function FilterInputWrapperComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, FilterInputDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.input = _t.first);
      }
    },
    inputs: {
      column: "column",
      defaultOperator: "defaultOperator"
    },
    features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterInputWrapperComponent, [{
    type: Directive,
    args: [{}]
  }], () => [{
    type: FilterService
  }], {
    column: [{
      type: Input
    }],
    input: [{
      type: ContentChild,
      args: [FilterInputDirective, {
        static: false
      }]
    }],
    defaultOperator: [{
      type: Input
    }]
  });
})();
var FilterMenuInputWrapperComponent = class _FilterMenuInputWrapperComponent extends FilterInputWrapperComponent {
  ctx;
  adaptiveGridService;
  filterService;
  isFirstDropDown;
  menuTabbingService;
  firstOperatorDropDown;
  _currentFilter;
  subs = new Subscription();
  /**
   * @hidden
   */
  get hostClasses() {
    return false;
  }
  constructor(ctx, adaptiveGridService) {
    super(null);
    this.ctx = ctx;
    this.adaptiveGridService = adaptiveGridService;
  }
  ngAfterViewInit() {
    const shouldFocusFirstFocusable = this.isFirstDropDown && this.filterService?.menuTabbingService;
    const isTabbedInterface = this.menuTabbingService?.isTabbedInterface;
    if (shouldFocusFirstFocusable && !isTabbedInterface) {
      this.filterService.menuTabbingService.firstFocusable = this.firstOperatorDropDown;
      if (this.ctx.grid?.isActionSheetExpanded) {
        this.subs.add(this.adaptiveGridService.animationEnd.subscribe(() => {
          this.firstOperatorDropDown.wrapper.nativeElement.focus({
            preventScroll: true
          });
        }));
      } else {
        this.firstOperatorDropDown.wrapper.nativeElement.focus({
          preventScroll: true
        });
      }
    }
  }
  ngOnDestroy() {
    this.subs?.unsubscribe();
  }
  operatorChange(dataItem) {
    this.currentOperator = dataItem;
  }
  filterChange(filter3) {
    this.applyFilter(filter3);
  }
  /**
   * The current filter for the associated column field.
   * @readonly
   * @type {FilterDescriptor}
   */
  get currentFilter() {
    return this._currentFilter;
  }
  /**
   * The current filter for the associated column field.
   * @readonly
   * @type {FilterDescriptor}
   */
  set currentFilter(value2) {
    this._currentFilter = value2;
  }
  updateFilter(filter3) {
    Object.assign(this.currentFilter, filter3);
    return this.filter;
  }
  onChange(value2) {
    this.filterChange(this.updateFilter({
      field: this.column.field,
      operator: this.currentOperator,
      value: value2
    }));
  }
  onShiftTab(e) {
    e.stopImmediatePropagation();
    if (!this.menuTabbingService?.isColumnMenu && this.isFirstDropDown && this.filterService.menuTabbingService.lastFocusable) {
      e.preventDefault();
      this.filterService.menuTabbingService.lastFocusable.focus();
    }
  }
  get filterMenuDropDownLabel() {
    const localizationMsg = this.ctx.localization.get("filterMenuOperatorsDropDownLabel") || "";
    const columnName = this.column ? this.column.title || this.column.field : "";
    return replaceMessagePlaceholder(localizationMsg, "columnName", columnName);
  }
  static ɵfac = function FilterMenuInputWrapperComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FilterMenuInputWrapperComponent)(ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(AdaptiveGridService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _FilterMenuInputWrapperComponent,
    selectors: [["kendo-grid-filter-menu-input-wrapper"]],
    viewQuery: function FilterMenuInputWrapperComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(DropDownListComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.firstOperatorDropDown = _t.first);
      }
    },
    inputs: {
      filterService: "filterService",
      isFirstDropDown: "isFirstDropDown",
      menuTabbingService: "menuTabbingService",
      currentFilter: "currentFilter"
    },
    features: [ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c118,
    decls: 2,
    vars: 7,
    consts: [["kendoFilterMenuDropDown", "", "textField", "text", "valueField", "value", 3, "valueChange", "keydown.shift.tab", "adaptiveTitle", "adaptiveMode", "size", "filterMenuDropDownLabel", "data", "value", "valuePrimitive"]],
    template: function FilterMenuInputWrapperComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵelementStart(0, "kendo-dropdownlist", 0);
        ɵɵlistener("valueChange", function FilterMenuInputWrapperComponent_Template_kendo_dropdownlist_valueChange_0_listener($event) {
          return ctx.operatorChange($event);
        })("keydown.shift.tab", function FilterMenuInputWrapperComponent_Template_kendo_dropdownlist_keydown_shift_tab_0_listener($event) {
          return ctx.onShiftTab($event);
        });
        ɵɵelementEnd();
        ɵɵprojection(1);
      }
      if (rf & 2) {
        ɵɵproperty("adaptiveTitle", ctx.ctx.localization.get("adaptiveFilterOperatorsTitle"))("adaptiveMode", ctx.ctx.grid == null ? null : ctx.ctx.grid.adaptiveMode)("size", (ctx.ctx.grid == null ? null : ctx.ctx.grid.isActionSheetExpanded) ? "large" : null)("filterMenuDropDownLabel", ctx.filterMenuDropDownLabel)("data", ctx.operators)("value", ctx.currentOperator)("valuePrimitive", true);
      }
    },
    dependencies: [DropDownListComponent, FilterMenuDropDownListDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterMenuInputWrapperComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-filter-menu-input-wrapper",
      template: `
        <kendo-dropdownlist
            kendoFilterMenuDropDown
            [adaptiveTitle]="ctx.localization.get('adaptiveFilterOperatorsTitle')"
            [adaptiveMode]="ctx.grid?.adaptiveMode"
            [size]="ctx.grid?.isActionSheetExpanded ? 'large' : null"
            [filterMenuDropDownLabel]="filterMenuDropDownLabel"
            [data]="operators"
            (valueChange)="operatorChange($event)"
            [value]="currentOperator"
            [valuePrimitive]="true"
            textField="text"
            valueField="value"
            (keydown.shift.tab)="onShiftTab($event)">
        </kendo-dropdownlist>
        <ng-content></ng-content>
    `,
      standalone: true,
      imports: [DropDownListComponent, FilterMenuDropDownListDirective]
    }]
  }], () => [{
    type: ContextService
  }, {
    type: AdaptiveGridService
  }], {
    filterService: [{
      type: Input
    }],
    isFirstDropDown: [{
      type: Input
    }],
    menuTabbingService: [{
      type: Input
    }],
    firstOperatorDropDown: [{
      type: ViewChild,
      args: [DropDownListComponent, {
        static: false
      }]
    }],
    currentFilter: [{
      type: Input
    }]
  });
})();
var StringFilterMenuInputComponent = class _StringFilterMenuInputComponent {
  ctx;
  operators = [];
  column;
  filter;
  operator;
  currentFilter;
  filterService;
  isFirstDropDown;
  menuTabbingService;
  placeholder;
  constructor(ctx) {
    this.ctx = ctx;
  }
  get columnLabel() {
    const localizationMsg = this.ctx.localization.get("filterInputLabel") || "";
    const columnName = this.column ? this.column.title || this.column.field : "";
    return replaceMessagePlaceholder(localizationMsg, "columnName", columnName);
  }
  static ɵfac = function StringFilterMenuInputComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _StringFilterMenuInputComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _StringFilterMenuInputComponent,
    selectors: [["kendo-grid-string-filter-menu-input"]],
    inputs: {
      operators: "operators",
      column: "column",
      filter: "filter",
      operator: "operator",
      currentFilter: "currentFilter",
      filterService: "filterService",
      isFirstDropDown: "isFirstDropDown",
      menuTabbingService: "menuTabbingService",
      placeholder: "placeholder"
    },
    decls: 2,
    vars: 13,
    consts: [[3, "column", "filter", "operators", "defaultOperator", "currentFilter", "filterService", "isFirstDropDown", "menuTabbingService"], ["kendoFilterInput", "", 3, "columnLabel", "size", "filterDelay", "placeholder", "ngModel"]],
    template: function StringFilterMenuInputComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "kendo-grid-filter-menu-input-wrapper", 0);
        ɵɵelement(1, "kendo-textbox", 1);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("column", ctx.column)("filter", ctx.filter)("operators", ctx.operators)("defaultOperator", ctx.operator)("currentFilter", ctx.currentFilter)("filterService", ctx.filterService)("isFirstDropDown", ctx.isFirstDropDown)("menuTabbingService", ctx.menuTabbingService);
        ɵɵadvance();
        ɵɵproperty("columnLabel", ctx.columnLabel)("size", (ctx.ctx.grid == null ? null : ctx.ctx.grid.isActionSheetExpanded) ? "large" : null)("filterDelay", 0)("placeholder", ctx.placeholder)("ngModel", (ctx.currentFilter == null ? null : ctx.currentFilter.value) ?? null);
      }
    },
    dependencies: [FilterMenuInputWrapperComponent, TextBoxComponent, FilterInputDirective, FormsModule, NgControlStatus, NgModel],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StringFilterMenuInputComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-string-filter-menu-input",
      template: `
        <kendo-grid-filter-menu-input-wrapper
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [currentFilter]="currentFilter"
            [filterService]="filterService"
            [isFirstDropDown]="isFirstDropDown"
            [menuTabbingService]="menuTabbingService">
            <kendo-textbox
                kendoFilterInput
                [columnLabel]="columnLabel"
                [size]="ctx.grid?.isActionSheetExpanded ? 'large' : null"
                [filterDelay]="0"
                [placeholder]="placeholder"
                [ngModel]="currentFilter?.value ?? null">
            </kendo-textbox>
        </kendo-grid-filter-menu-input-wrapper>
    `,
      standalone: true,
      imports: [FilterMenuInputWrapperComponent, TextBoxComponent, FilterInputDirective, FormsModule]
    }]
  }], () => [{
    type: ContextService
  }], {
    operators: [{
      type: Input
    }],
    column: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    operator: [{
      type: Input
    }],
    currentFilter: [{
      type: Input
    }],
    filterService: [{
      type: Input
    }],
    isFirstDropDown: [{
      type: Input
    }],
    menuTabbingService: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }]
  });
})();
var StringFilterMenuComponent = class _StringFilterMenuComponent extends StringFilterComponent {
  ctx;
  logicOperators = [];
  /**
   * @hidden
   */
  get hostClasses() {
    return false;
  }
  /**
   * The current menu filter.
   * @type {CompositeFilterDescriptor}
   */
  filter = {
    filters: [],
    logic: "and"
  };
  /**
   * Determines if the inputs for the second criteria are displayed.
   * @default true
   */
  extra = true;
  /**
   * Sets to `FilterService` instance that handles changes in the filter descriptor.
   */
  filterService;
  /**
   * The placeholder text for the filter input.
   * @type {string}
   */
  placeholder;
  /**
   * Sets the placeholder text for the second filter input.
   * Applies when `extra` is set to `true`.
   * @type {string}
   */
  extraPlaceholder;
  /**
   * @hidden
   */
  menuTabbingService;
  constructor(ctx) {
    super(null, ctx);
    this.ctx = ctx;
    this.logicOperators = logicOperators(this.ctx.localization);
  }
  get firstFilter() {
    return setFilter(0, this.filter, (this.column || {}).field, this.operator);
  }
  get secondFilter() {
    return setFilter(1, this.filter, (this.column || {}).field, this.operator);
  }
  logicChange(value2) {
    this.filter.logic = value2;
  }
  get filterMenuDropDownLabel() {
    const localizationMsg = this.ctx.localization.get("filterMenuLogicDropDownLabel") || "";
    const columnName = this.column ? this.column.title || this.column.field : "";
    return replaceMessagePlaceholder(localizationMsg, "columnName", columnName);
  }
  localizationChange() {
    this.logicOperators = logicOperators(this.ctx.localization);
    super.localizationChange();
  }
  static ɵfac = function StringFilterMenuComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _StringFilterMenuComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _StringFilterMenuComponent,
    selectors: [["kendo-grid-string-filter-menu"]],
    hostVars: 2,
    hostBindings: function StringFilterMenuComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-filtercell", ctx.hostClasses);
      }
    },
    inputs: {
      filter: "filter",
      extra: "extra",
      filterService: "filterService",
      placeholder: "placeholder",
      extraPlaceholder: "extraPlaceholder",
      menuTabbingService: "menuTabbingService"
    },
    features: [ɵɵInheritDefinitionFeature],
    decls: 3,
    vars: 10,
    consts: [[3, "currentFilter", "operators", "filterService", "column", "filter", "isFirstDropDown", "placeholder", "menuTabbingService"], ["kendoFilterMenuDropDown", "", "textField", "text", "valueField", "value", 1, "k-filter-and", 3, "adaptiveTitle", "adaptiveMode", "size", "filterMenuDropDownLabel", "data", "valuePrimitive", "value"], [3, "operators", "currentFilter", "filterService", "column", "filter", "placeholder", "menuTabbingService"], ["kendoFilterMenuDropDown", "", "textField", "text", "valueField", "value", 1, "k-filter-and", 3, "valueChange", "adaptiveTitle", "adaptiveMode", "size", "filterMenuDropDownLabel", "data", "valuePrimitive", "value"]],
    template: function StringFilterMenuComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelement(0, "kendo-grid-string-filter-menu-input", 0);
        ɵɵconditionalCreate(1, StringFilterMenuComponent_Conditional_1_Template, 1, 7, "kendo-dropdownlist", 1);
        ɵɵconditionalCreate(2, StringFilterMenuComponent_Conditional_2_Template, 1, 7, "kendo-grid-string-filter-menu-input", 2);
      }
      if (rf & 2) {
        ɵɵproperty("currentFilter", ctx.firstFilter)("operators", ctx.operators)("filterService", ctx.filterService)("column", ctx.column)("filter", ctx.filter)("isFirstDropDown", true)("placeholder", ctx.placeholder)("menuTabbingService", ctx.menuTabbingService);
        ɵɵadvance();
        ɵɵconditional(ctx.extra ? 1 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.extra ? 2 : -1);
      }
    },
    dependencies: [StringFilterMenuInputComponent, DropDownListComponent, FilterMenuDropDownListDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StringFilterMenuComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-string-filter-menu",
      template: `
        <kendo-grid-string-filter-menu-input
          [currentFilter]="firstFilter"
          [operators]="operators"
          [filterService]="filterService"
          [column]="column"
          [filter]="filter"
          [isFirstDropDown]="true"
          [placeholder]="placeholder"
          [menuTabbingService]="menuTabbingService">
        </kendo-grid-string-filter-menu-input>
        @if (extra) {
          <kendo-dropdownlist
            kendoFilterMenuDropDown
            [adaptiveTitle]="ctx.localization.get('adaptiveFilterOperatorsTitle')"
            [adaptiveMode]="ctx.grid?.adaptiveMode"
            [size]="ctx.grid?.isActionSheetExpanded ? 'large' : null"
            [filterMenuDropDownLabel]="filterMenuDropDownLabel"
            class="k-filter-and"
            [data]="logicOperators"
            [valuePrimitive]="true" (valueChange)="logicChange($event)"
            [value]="filter?.logic"
            textField="text"
            valueField="value">
          </kendo-dropdownlist>
        }
        @if (extra) {
          <kendo-grid-string-filter-menu-input
            [operators]="operators"
            [currentFilter]="secondFilter"
            [filterService]="filterService"
            [column]="column"
            [filter]="filter"
            [placeholder]="extraPlaceholder"
            [menuTabbingService]="menuTabbingService">
          </kendo-grid-string-filter-menu-input>
        }
        `,
      standalone: true,
      imports: [StringFilterMenuInputComponent, DropDownListComponent, FilterMenuDropDownListDirective]
    }]
  }], () => [{
    type: ContextService
  }], {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-filtercell"]
    }],
    filter: [{
      type: Input
    }],
    extra: [{
      type: Input
    }],
    filterService: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    extraPlaceholder: [{
      type: Input
    }],
    menuTabbingService: [{
      type: Input
    }]
  });
})();
var numericOperators = localizeOperators({
  "filterEqOperator": "eq",
  "filterNotEqOperator": "neq",
  "filterGteOperator": "gte",
  "filterGtOperator": "gt",
  "filterLteOperator": "lte",
  "filterLtOperator": "lt",
  "filterIsNullOperator": "isnull",
  "filterIsNotNullOperator": "isnotnull"
});
var NumericFilterComponent = class _NumericFilterComponent extends BaseFilterCellComponent {
  ctx;
  /**
   * Specifies the column for this filter.
   * @type {ColumnComponent}
   */
  column;
  /**
   * Sets the default filter operator.
   * @type {string}
   * @default 'eq'
   */
  operator = "eq";
  /**
   * Sets the value used to increment or decrement the component value.
   * @type {numeric}
   * @default 1
   */
  step = 1;
  /**
   * Sets the smallest valid value.
   * @type {number}
   */
  min;
  /**
   * Sets the greatest valid value.
   * @type {number}
   */
  max;
  /**
   * When `true`, shows the **Up** and **Down** spin buttons.
   * @type {boolean}
   * @default true
   */
  spinners = true;
  /**
   * Sets the number precision for the value when focused.
   * If the user enters a number with greater precision, the value is rounded.
   * @type {number}
   */
  decimals;
  /**
   * Gets the number format used when the component is not focused.
   * Uses `column.format` if set.
   */
  get format() {
    return !isNullOrEmptyString2(this._format) ? this._format : this.columnFormat;
  }
  set format(value2) {
    this._format = value2;
  }
  /**
   * Gets the current filter for the column field.
   * @readonly
   * @type {FilterDescriptor}
   */
  get currentFilter() {
    return this.filterByField(this.column.field);
  }
  /**
   * Gets the current filter operator for the column field.
   * @readonly
   * @type {string}
   */
  get currentOperator() {
    return this.currentFilter ? this.currentFilter.operator : this.operator;
  }
  get columnFormat() {
    return this.column && !isNullOrEmptyString2(this.column.format) ? extractFormat(this.column.format) : "n2";
  }
  _format;
  subscription;
  constructor(filterService, ctx) {
    super(filterService);
    this.ctx = ctx;
    this.defaultOperators = numericOperators(this.ctx.localization);
  }
  ngOnInit() {
    this.subscription = this.ctx.localization.changes.subscribe(this.localizationChange.bind(this));
  }
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
    super.ngOnDestroy();
  }
  localizationChange() {
    this.defaultOperators = numericOperators(this.ctx.localization);
    if (this.operatorList.length) {
      this.operators = toJSON(this.operatorList.toArray());
    }
  }
  static ɵfac = function NumericFilterComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NumericFilterComponent)(ɵɵdirectiveInject(FilterService), ɵɵdirectiveInject(ContextService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _NumericFilterComponent,
    inputs: {
      column: "column",
      operator: "operator",
      step: "step",
      min: "min",
      max: "max",
      spinners: "spinners",
      decimals: "decimals",
      format: "format"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NumericFilterComponent, [{
    type: Directive,
    args: [{}]
  }], () => [{
    type: FilterService
  }, {
    type: ContextService
  }], {
    column: [{
      type: Input
    }],
    operator: [{
      type: Input
    }],
    step: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    spinners: [{
      type: Input
    }],
    decimals: [{
      type: Input
    }],
    format: [{
      type: Input
    }]
  });
})();
var NumericFilterMenuInputComponent = class _NumericFilterMenuInputComponent {
  ctx;
  operators = [];
  column;
  filter;
  operator;
  currentFilter;
  filterService;
  filterDelay;
  isFirstDropDown;
  menuTabbingService;
  /**
   * Specifies the value used to increment or decrement the component value.
   * @type {number}
   */
  step = 1;
  /**
   * Specifies the smallest value that is valid.
   * @type {number}
   */
  min;
  /**
   * Specifies the greatest value that is valid.
   * @type {number}
   */
  max;
  /**
   * Specifies whether the **Up** and **Down** spin buttons are rendered.
   * @type {boolean}
   */
  spinners = true;
  /**
   * Specifies the number precision applied to the component value when focused.
   * If the user enters a number with greater precision than configured, the component value is rounded.
   * @type {number}
   */
  decimals;
  /**
   * Specifies the number format used when the component is not focused.
   * By default, the `column.format` value is used if set.
   * @type {string}
   */
  format;
  /**
   * The placeholder text for the filter input.
   * @type {string}
   */
  placeholder;
  constructor(ctx) {
    this.ctx = ctx;
  }
  messageFor(key) {
    return this.ctx.localization.get(key);
  }
  /**
   * @hidden
   */
  get columnLabel() {
    const localizationMsg = this.ctx.localization.get("filterInputLabel") || "";
    const columnName = this.column ? this.column.title || this.column.field : "";
    return replaceMessagePlaceholder(localizationMsg, "columnName", columnName);
  }
  static ɵfac = function NumericFilterMenuInputComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NumericFilterMenuInputComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _NumericFilterMenuInputComponent,
    selectors: [["kendo-grid-numeric-filter-menu-input"]],
    inputs: {
      operators: "operators",
      column: "column",
      filter: "filter",
      operator: "operator",
      currentFilter: "currentFilter",
      filterService: "filterService",
      filterDelay: "filterDelay",
      isFirstDropDown: "isFirstDropDown",
      menuTabbingService: "menuTabbingService",
      step: "step",
      min: "min",
      max: "max",
      spinners: "spinners",
      decimals: "decimals",
      format: "format",
      placeholder: "placeholder"
    },
    decls: 3,
    vars: 22,
    consts: [[3, "column", "filter", "operators", "defaultOperator", "currentFilter", "filterService", "isFirstDropDown", "menuTabbingService"], ["kendoFilterInput", "", 3, "columnLabel", "filterDelay", "autoCorrect", "size", "value", "format", "decimals", "spinners", "min", "max", "step", "placeholder"], [3, "increment", "decrement"]],
    template: function NumericFilterMenuInputComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "kendo-grid-filter-menu-input-wrapper", 0)(1, "kendo-numerictextbox", 1);
        ɵɵelement(2, "kendo-numerictextbox-messages", 2);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵproperty("column", ctx.column)("filter", ctx.filter)("operators", ctx.operators)("defaultOperator", ctx.operator)("currentFilter", ctx.currentFilter)("filterService", ctx.filterService)("isFirstDropDown", ctx.isFirstDropDown)("menuTabbingService", ctx.menuTabbingService);
        ɵɵadvance();
        ɵɵproperty("columnLabel", ctx.columnLabel)("filterDelay", ctx.filterDelay)("autoCorrect", true)("size", (ctx.ctx.grid == null ? null : ctx.ctx.grid.isActionSheetExpanded) ? "large" : null)("value", ctx.currentFilter == null ? null : ctx.currentFilter.value)("format", ctx.format)("decimals", ctx.decimals)("spinners", ctx.spinners)("min", ctx.min)("max", ctx.max)("step", ctx.step)("placeholder", ctx.placeholder);
        ɵɵadvance();
        ɵɵproperty("increment", ctx.messageFor("filterNumericIncrement"))("decrement", ctx.messageFor("filterNumericDecrement"));
      }
    },
    dependencies: [FilterMenuInputWrapperComponent, NumericTextBoxComponent, FilterInputDirective, NumericTextBoxCustomMessagesComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NumericFilterMenuInputComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-numeric-filter-menu-input",
      template: `
        <kendo-grid-filter-menu-input-wrapper
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [currentFilter]="currentFilter"
            [filterService]="filterService"
            [isFirstDropDown]="isFirstDropDown"
            [menuTabbingService]="menuTabbingService">
            <kendo-numerictextbox
                kendoFilterInput
                [columnLabel]="columnLabel"
                [filterDelay]="filterDelay"
                [autoCorrect]="true"
                [size]="ctx.grid?.isActionSheetExpanded ? 'large' : null"
                [value]="currentFilter?.value"
                [format]="format"
                [decimals]="decimals"
                [spinners]="spinners"
                [min]="min"
                [max]="max"
                [step]="step"
                [placeholder]="placeholder">
                <kendo-numerictextbox-messages
                    [increment]="messageFor('filterNumericIncrement')"
                    [decrement]="messageFor('filterNumericDecrement')"
                ></kendo-numerictextbox-messages>
            </kendo-numerictextbox>
        </kendo-grid-filter-menu-input-wrapper>
    `,
      standalone: true,
      imports: [FilterMenuInputWrapperComponent, NumericTextBoxComponent, FilterInputDirective, NumericTextBoxCustomMessagesComponent]
    }]
  }], () => [{
    type: ContextService
  }], {
    operators: [{
      type: Input
    }],
    column: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    operator: [{
      type: Input
    }],
    currentFilter: [{
      type: Input
    }],
    filterService: [{
      type: Input
    }],
    filterDelay: [{
      type: Input
    }],
    isFirstDropDown: [{
      type: Input
    }],
    menuTabbingService: [{
      type: Input
    }],
    step: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    spinners: [{
      type: Input
    }],
    decimals: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }]
  });
})();
var NumericFilterMenuComponent = class _NumericFilterMenuComponent extends NumericFilterComponent {
  logicOperators = logicOperators(this.ctx.localization);
  /**
   * @hidden
   */
  get hostClasses() {
    return false;
  }
  /**
   * Represents the current filter descriptor for the menu.
   * @type {CompositeFilterDescriptor}
   */
  filter = {
    filters: [],
    logic: "and"
  };
  /**
   * Determines if the inputs for the second criteria are displayed.
   * @default true
   */
  extra = true;
  /**
   * Represents the `FilterService` instance that handles changes in the filter descriptor.
   */
  filterService;
  /**
   * Determines the delay in milliseconds before creating a filter descriptor based on the value.
   * A value of `0` means no delay.
   * @default 500
   */
  filterDelay = 500;
  /**
   * The placeholder text for the filter input.
   * @type {string}
   */
  placeholder = "";
  /**
   * Sets the placeholder text for the extra filter input.
   * Applies when `extra` is set to `true`.
   * @type {string}
   */
  extraPlaceholder = "";
  /**
   * @hidden
   */
  menuTabbingService;
  constructor(ctx) {
    super(null, ctx);
  }
  get firstFilter() {
    return setFilter(0, this.filter, (this.column || {}).field, this.operator);
  }
  get secondFilter() {
    return setFilter(1, this.filter, (this.column || {}).field, this.operator);
  }
  logicChange(value2) {
    this.filter.logic = value2;
  }
  get filterMenuDropDownLabel() {
    const localizationMsg = this.ctx.localization.get("filterMenuLogicDropDownLabel") || "";
    const columnName = this.column ? this.column.title || this.column.field : "";
    return replaceMessagePlaceholder(localizationMsg, "columnName", columnName);
  }
  localizationChange() {
    this.logicOperators = logicOperators(this.ctx.localization);
    super.localizationChange();
  }
  static ɵfac = function NumericFilterMenuComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NumericFilterMenuComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _NumericFilterMenuComponent,
    selectors: [["kendo-grid-numeric-filter-menu"]],
    hostVars: 2,
    hostBindings: function NumericFilterMenuComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-filtercell", ctx.hostClasses);
      }
    },
    inputs: {
      filter: "filter",
      extra: "extra",
      filterService: "filterService",
      filterDelay: "filterDelay",
      placeholder: "placeholder",
      extraPlaceholder: "extraPlaceholder",
      menuTabbingService: "menuTabbingService"
    },
    features: [ɵɵInheritDefinitionFeature],
    decls: 3,
    vars: 17,
    consts: [[3, "currentFilter", "operators", "filterService", "column", "filter", "filterDelay", "format", "decimals", "spinners", "min", "max", "step", "menuTabbingService", "isFirstDropDown", "placeholder"], ["kendoFilterMenuDropDown", "", "textField", "text", "valueField", "value", 1, "k-filter-and", 3, "adaptiveTitle", "adaptiveMode", "size", "filterMenuDropDownLabel", "data", "valuePrimitive", "value"], [3, "operators", "currentFilter", "filterService", "column", "filter", "format", "decimals", "spinners", "min", "max", "step", "menuTabbingService", "placeholder"], ["kendoFilterMenuDropDown", "", "textField", "text", "valueField", "value", 1, "k-filter-and", 3, "valueChange", "adaptiveTitle", "adaptiveMode", "size", "filterMenuDropDownLabel", "data", "valuePrimitive", "value"]],
    template: function NumericFilterMenuComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelement(0, "kendo-grid-numeric-filter-menu-input", 0);
        ɵɵconditionalCreate(1, NumericFilterMenuComponent_Conditional_1_Template, 1, 7, "kendo-dropdownlist", 1);
        ɵɵconditionalCreate(2, NumericFilterMenuComponent_Conditional_2_Template, 1, 13, "kendo-grid-numeric-filter-menu-input", 2);
      }
      if (rf & 2) {
        ɵɵproperty("currentFilter", ctx.firstFilter)("operators", ctx.operators)("filterService", ctx.filterService)("column", ctx.column)("filter", ctx.filter)("filterDelay", ctx.filterDelay)("format", ctx.format)("decimals", ctx.decimals)("spinners", ctx.spinners)("min", ctx.min)("max", ctx.max)("step", ctx.step)("menuTabbingService", ctx.menuTabbingService)("isFirstDropDown", true)("placeholder", ctx.placeholder);
        ɵɵadvance();
        ɵɵconditional(ctx.extra ? 1 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.extra ? 2 : -1);
      }
    },
    dependencies: [NumericFilterMenuInputComponent, DropDownListComponent, FilterMenuDropDownListDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NumericFilterMenuComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-numeric-filter-menu",
      template: `
        <kendo-grid-numeric-filter-menu-input
          [currentFilter]="firstFilter"
          [operators]="operators"
          [filterService]="filterService"
          [column]="column"
          [filter]="filter"
          [filterDelay]="filterDelay"
          [format]="format"
          [decimals]="decimals"
          [spinners]="spinners"
          [min]="min"
          [max]="max"
          [step]="step"
          [menuTabbingService]="menuTabbingService"
          [isFirstDropDown]="true"
          [placeholder]="placeholder">
        </kendo-grid-numeric-filter-menu-input>
        @if (extra) {
          <kendo-dropdownlist
            kendoFilterMenuDropDown
            [adaptiveTitle]="ctx.localization.get('adaptiveFilterOperatorsTitle')"
            [adaptiveMode]="ctx.grid?.adaptiveMode"
            [size]="ctx.grid?.isActionSheetExpanded ? 'large' : null"
            [filterMenuDropDownLabel]="filterMenuDropDownLabel"
            class="k-filter-and"
            [data]="logicOperators"
            [valuePrimitive]="true"
            (valueChange)="logicChange($event)"
            [value]="filter?.logic"
            textField="text"
            valueField="value">
          </kendo-dropdownlist>
        }
        @if (extra) {
          <kendo-grid-numeric-filter-menu-input
            [operators]="operators"
            [currentFilter]="secondFilter"
            [filterService]="filterService"
            [column]="column"
            [filter]="filter"
            [format]="format"
            [decimals]="decimals"
            [spinners]="spinners"
            [min]="min"
            [max]="max"
            [step]="step"
            [menuTabbingService]="menuTabbingService"
            [placeholder]="extraPlaceholder">
          </kendo-grid-numeric-filter-menu-input>
        }
        `,
      standalone: true,
      imports: [NumericFilterMenuInputComponent, DropDownListComponent, FilterMenuDropDownListDirective]
    }]
  }], () => [{
    type: ContextService
  }], {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-filtercell"]
    }],
    filter: [{
      type: Input
    }],
    extra: [{
      type: Input
    }],
    filterService: [{
      type: Input
    }],
    filterDelay: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    extraPlaceholder: [{
      type: Input
    }],
    menuTabbingService: [{
      type: Input
    }]
  });
})();
var dateOperators = localizeOperators({
  "filterEqOperator": "eq",
  "filterNotEqOperator": "neq",
  "filterAfterOrEqualOperator": "gte",
  "filterAfterOperator": "gt",
  "filterBeforeOrEqualOperator": "lte",
  "filterBeforeOperator": "lt",
  "filterIsNullOperator": "isnull",
  "filterIsNotNullOperator": "isnotnull"
});
var DateFilterComponent = class _DateFilterComponent extends BaseFilterCellComponent {
  ctx;
  /**
   * Sets the column for this filter.
   * @type {ColumnComponent}
   */
  column;
  /**
   * Sets the default filter operator.
   * @type {string}
   * @default 'gte'
   */
  operator = "gte";
  /**
   * Gets the current filter for the column field.
   * @readonly
   * @type {FilterDescriptor}
   */
  get currentFilter() {
    return this.filterByField(this.column.field);
  }
  /**
   * Sets the date format used when the component is not focused.
   * Uses `column.format` if set.
   */
  set format(value2) {
    this._format = value2;
  }
  /**
   * Gets the date format used when the component is not focused.
   * Uses `column.format` if set.
   * @readonly
   * @type {string}
   */
  get format() {
    return !isNullOrEmptyString2(this._format) ? this._format : this.columnFormat;
  }
  /**
   * Sets the smallest valid date value.
   * @type {Date}
   */
  min;
  /**
   * Sets the largest valid date value.
   * @type {Date}
   */
  max;
  /**
   * Sets the descriptions for the format sections in the input field.
   * [See example](slug:placeholders_datepicker#toc-format-sections-description).
   */
  formatPlaceholder;
  /**
   * Sets the hint shown when the value is `null`.
   * [See example](slug:placeholders_datepicker#toc-text-hints).
   */
  placeholder;
  /**
   * Sets the active calendar view when the calendar opens.
   * Set `activeView` within the `topView`-`bottomView` range.
   * @default 'month'
   */
  activeView = "month";
  /**
   * Defines the lowest calendar view level the user can navigate to.
   * @default 'month'
   */
  bottomView = "month";
  /**
   * Defines the highest calendar view level the user can navigate to.
   * @default 'century'
   */
  topView = "century";
  /**
   * When `true`, shows a week number column in the `month` view.
   * @default false
   */
  weekNumber = false;
  /**
   * Gets the current filter operator for the column field.
   * @readonly
   * @type {string}
   */
  get currentOperator() {
    return this.currentFilter ? this.currentFilter.operator : this.operator;
  }
  get columnFormat() {
    return this.column && !isNullOrEmptyString2(this.column.format) ? extractFormat(this.column.format) : "d";
  }
  _format;
  subscription;
  constructor(filterService, ctx) {
    super(filterService);
    this.ctx = ctx;
    this.defaultOperators = dateOperators(this.ctx.localization);
  }
  ngOnInit() {
    this.subscription = this.ctx.localization.changes.subscribe(this.localizationChange.bind(this));
  }
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
    super.ngOnDestroy();
  }
  localizationChange() {
    this.defaultOperators = dateOperators(this.ctx.localization);
    if (this.operatorList.length) {
      this.operators = toJSON(this.operatorList.toArray());
    }
  }
  static ɵfac = function DateFilterComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DateFilterComponent)(ɵɵdirectiveInject(FilterService), ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DateFilterComponent,
    selectors: [["kendo-grid-date-filter-base"]],
    inputs: {
      column: "column",
      operator: "operator",
      format: "format",
      min: "min",
      max: "max",
      formatPlaceholder: "formatPlaceholder",
      placeholder: "placeholder",
      activeView: "activeView",
      bottomView: "bottomView",
      topView: "topView",
      weekNumber: "weekNumber"
    },
    features: [ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DateFilterComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateFilterComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-date-filter-base",
      template: ``
    }]
  }], () => [{
    type: FilterService
  }, {
    type: ContextService
  }], {
    column: [{
      type: Input
    }],
    operator: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    formatPlaceholder: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    activeView: [{
      type: Input
    }],
    bottomView: [{
      type: Input
    }],
    topView: [{
      type: Input
    }],
    weekNumber: [{
      type: Input
    }]
  });
})();
var DateFilterMenuInputComponent = class _DateFilterMenuInputComponent {
  popupService;
  ctx;
  operators = [];
  column;
  filter;
  operator;
  currentFilter;
  filterService;
  menuTabbingService;
  format;
  formatPlaceholder;
  placeholder;
  min;
  max;
  activeView;
  bottomView;
  topView;
  weekNumber;
  isFirstDropDown;
  subscription;
  constructor(popupService, ctx) {
    this.popupService = popupService;
    this.ctx = ctx;
  }
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
  }
  open(picker) {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
    this.subscription = this.popupService.onClose.pipe(filter(() => picker.isActive)).subscribe((e) => e.preventDefault());
  }
  messageFor(key) {
    return this.ctx.localization.get(key);
  }
  get columnLabel() {
    const localizationMsg = this.ctx.localization.get("filterInputLabel") || "";
    const columnName = this.column ? this.column.title || this.column.field : "";
    return replaceMessagePlaceholder(localizationMsg, "columnName", columnName);
  }
  static ɵfac = function DateFilterMenuInputComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DateFilterMenuInputComponent)(ɵɵdirectiveInject(SinglePopupService), ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DateFilterMenuInputComponent,
    selectors: [["kendo-grid-date-filter-menu-input"]],
    inputs: {
      operators: "operators",
      column: "column",
      filter: "filter",
      operator: "operator",
      currentFilter: "currentFilter",
      filterService: "filterService",
      menuTabbingService: "menuTabbingService",
      format: "format",
      formatPlaceholder: "formatPlaceholder",
      placeholder: "placeholder",
      min: "min",
      max: "max",
      activeView: "activeView",
      bottomView: "bottomView",
      topView: "topView",
      weekNumber: "weekNumber",
      isFirstDropDown: "isFirstDropDown"
    },
    decls: 4,
    vars: 24,
    consts: [["picker", ""], [3, "column", "filter", "operators", "defaultOperator", "currentFilter", "filterService", "isFirstDropDown", "menuTabbingService"], ["kendoFilterInput", "", 3, "open", "adaptiveMode", "size", "columnLabel", "filterDelay", "value", "placeholder", "formatPlaceholder", "format", "min", "max", "activeView", "bottomView", "topView", "weekNumber"], [3, "toggle", "today"]],
    template: function DateFilterMenuInputComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "kendo-grid-filter-menu-input-wrapper", 1)(1, "kendo-datepicker", 2, 0);
        ɵɵlistener("open", function DateFilterMenuInputComponent_Template_kendo_datepicker_open_1_listener() {
          ɵɵrestoreView(_r1);
          const picker_r2 = ɵɵreference(2);
          return ɵɵresetView(ctx.open(picker_r2));
        });
        ɵɵelement(3, "kendo-datepicker-messages", 3);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵproperty("column", ctx.column)("filter", ctx.filter)("operators", ctx.operators)("defaultOperator", ctx.operator)("currentFilter", ctx.currentFilter)("filterService", ctx.filterService)("isFirstDropDown", ctx.isFirstDropDown)("menuTabbingService", ctx.menuTabbingService);
        ɵɵadvance();
        ɵɵproperty("adaptiveMode", ctx.ctx.grid == null ? null : ctx.ctx.grid.adaptiveMode)("size", (ctx.ctx.grid == null ? null : ctx.ctx.grid.isActionSheetExpanded) ? "large" : null)("columnLabel", ctx.columnLabel)("filterDelay", 0)("value", ctx.currentFilter == null ? null : ctx.currentFilter.value)("placeholder", ctx.placeholder)("formatPlaceholder", ctx.formatPlaceholder)("format", ctx.format)("min", ctx.min)("max", ctx.max)("activeView", ctx.activeView)("bottomView", ctx.bottomView)("topView", ctx.topView)("weekNumber", ctx.weekNumber);
        ɵɵadvance(2);
        ɵɵproperty("toggle", ctx.messageFor("filterDateToggle"))("today", ctx.messageFor("filterDateToday"));
      }
    },
    dependencies: [FilterMenuInputWrapperComponent, DatePickerComponent, FilterInputDirective, DatePickerCustomMessagesComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateFilterMenuInputComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-date-filter-menu-input",
      template: `
        <kendo-grid-filter-menu-input-wrapper
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [currentFilter]="currentFilter"
            [filterService]="filterService"
            [isFirstDropDown]="isFirstDropDown"
            [menuTabbingService]="menuTabbingService">
            <kendo-datepicker #picker
                kendoFilterInput
                [adaptiveMode]="ctx.grid?.adaptiveMode"
                [size]="ctx.grid?.isActionSheetExpanded ? 'large' : null"
                [columnLabel]="columnLabel"
                [filterDelay]="0"
                (open)="open(picker)"
                [value]="currentFilter?.value"
                [placeholder]="placeholder"
                [formatPlaceholder]="formatPlaceholder"
                [format]="format"
                [min]="min"
                [max]="max"
                [activeView]="activeView"
                [bottomView]="bottomView"
                [topView]="topView"
                [weekNumber]="weekNumber">
                <kendo-datepicker-messages
                    [toggle]="messageFor('filterDateToggle')"
                    [today]="messageFor('filterDateToday')"
                ></kendo-datepicker-messages>
            </kendo-datepicker>
        </kendo-grid-filter-menu-input-wrapper>
    `,
      standalone: true,
      imports: [FilterMenuInputWrapperComponent, DatePickerComponent, FilterInputDirective, DatePickerCustomMessagesComponent]
    }]
  }], () => [{
    type: SinglePopupService
  }, {
    type: ContextService
  }], {
    operators: [{
      type: Input
    }],
    column: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    operator: [{
      type: Input
    }],
    currentFilter: [{
      type: Input
    }],
    filterService: [{
      type: Input
    }],
    menuTabbingService: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    formatPlaceholder: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    activeView: [{
      type: Input
    }],
    bottomView: [{
      type: Input
    }],
    topView: [{
      type: Input
    }],
    weekNumber: [{
      type: Input
    }],
    isFirstDropDown: [{
      type: Input
    }]
  });
})();
var DateFilterMenuComponent = class _DateFilterMenuComponent extends DateFilterComponent {
  logicOperators = logicOperators(this.ctx.localization);
  /**
   * @hidden
   */
  get hostClasses() {
    return false;
  }
  /**
   * The current menu filter.
   * @type {CompositeFilterDescriptor}
   */
  filter = {
    filters: [],
    logic: "and"
  };
  /**
   * Determines if the inputs for the second criteria are displayed.
   * @default true
   */
  extra = true;
  /**
   * Represents the `FilterService` instance that handles changes in the filter descriptor.
   */
  filterService;
  /**
   * @hidden
   */
  menuTabbingService;
  constructor(ctx) {
    super(null, ctx);
  }
  get firstFilter() {
    return setFilter(0, this.filter, (this.column || {}).field, this.operator);
  }
  get secondFilter() {
    return setFilter(1, this.filter, (this.column || {}).field, this.operator);
  }
  logicChange(value2) {
    this.filter.logic = value2;
  }
  get filterMenuDropDownLabel() {
    const localizationMsg = this.ctx.localization.get("filterMenuLogicDropDownLabel") || "";
    const columnName = this.column ? this.column.title || this.column.field : "";
    return replaceMessagePlaceholder(localizationMsg, "columnName", columnName);
  }
  localizationChange() {
    this.logicOperators = logicOperators(this.ctx.localization);
    super.localizationChange();
  }
  static ɵfac = function DateFilterMenuComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DateFilterMenuComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DateFilterMenuComponent,
    selectors: [["kendo-grid-date-filter-menu"]],
    hostVars: 2,
    hostBindings: function DateFilterMenuComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-filtercell", ctx.hostClasses);
      }
    },
    inputs: {
      filter: "filter",
      extra: "extra",
      filterService: "filterService",
      menuTabbingService: "menuTabbingService"
    },
    features: [ɵɵInheritDefinitionFeature],
    decls: 3,
    vars: 18,
    consts: [[3, "currentFilter", "operators", "filterService", "column", "filter", "activeView", "bottomView", "topView", "format", "formatPlaceholder", "placeholder", "min", "max", "weekNumber", "isFirstDropDown", "menuTabbingService"], ["kendoFilterMenuDropDown", "", "textField", "text", "valueField", "value", 1, "k-filter-and", 3, "adaptiveTitle", "adaptiveMode", "size", "filterMenuDropDownLabel", "data", "valuePrimitive", "value"], [3, "operators", "currentFilter", "filterService", "column", "filter", "activeView", "bottomView", "topView", "format", "formatPlaceholder", "placeholder", "min", "max", "weekNumber", "menuTabbingService"], ["kendoFilterMenuDropDown", "", "textField", "text", "valueField", "value", 1, "k-filter-and", 3, "valueChange", "adaptiveTitle", "adaptiveMode", "size", "filterMenuDropDownLabel", "data", "valuePrimitive", "value"]],
    template: function DateFilterMenuComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelement(0, "kendo-grid-date-filter-menu-input", 0);
        ɵɵconditionalCreate(1, DateFilterMenuComponent_Conditional_1_Template, 1, 7, "kendo-dropdownlist", 1);
        ɵɵconditionalCreate(2, DateFilterMenuComponent_Conditional_2_Template, 1, 15, "kendo-grid-date-filter-menu-input", 2);
      }
      if (rf & 2) {
        ɵɵproperty("currentFilter", ctx.firstFilter)("operators", ctx.operators)("filterService", ctx.filterService)("column", ctx.column)("filter", ctx.filter)("activeView", ctx.activeView)("bottomView", ctx.bottomView)("topView", ctx.topView)("format", ctx.format)("formatPlaceholder", ctx.formatPlaceholder)("placeholder", ctx.placeholder)("min", ctx.min)("max", ctx.max)("weekNumber", ctx.weekNumber)("isFirstDropDown", true)("menuTabbingService", ctx.menuTabbingService);
        ɵɵadvance();
        ɵɵconditional(ctx.extra ? 1 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.extra ? 2 : -1);
      }
    },
    dependencies: [DateFilterMenuInputComponent, DropDownListComponent, FilterMenuDropDownListDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateFilterMenuComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-date-filter-menu",
      template: `
        <kendo-grid-date-filter-menu-input
          [currentFilter]="firstFilter"
          [operators]="operators"
          [filterService]="filterService"
          [column]="column"
          [filter]="filter"
          [activeView]="activeView"
          [bottomView]="bottomView"
          [topView]="topView"
          [format]="format"
          [formatPlaceholder]="formatPlaceholder"
          [placeholder]="placeholder"
          [min]="min"
          [max]="max"
          [weekNumber]="weekNumber"
          [isFirstDropDown]="true"
          [menuTabbingService]="menuTabbingService">
        </kendo-grid-date-filter-menu-input>
        @if (extra) {
          <kendo-dropdownlist
            kendoFilterMenuDropDown
            [adaptiveTitle]="ctx.localization.get('adaptiveFilterOperatorsTitle')"
            [adaptiveMode]="ctx.grid?.adaptiveMode"
            [size]="ctx.grid?.isActionSheetExpanded ? 'large' : null"
            [filterMenuDropDownLabel]="filterMenuDropDownLabel"
            class="k-filter-and"
            [data]="logicOperators"
            [valuePrimitive]="true"
            (valueChange)="logicChange($event)"
            [value]="filter?.logic"
            textField="text"
            valueField="value">
          </kendo-dropdownlist>
        }
        @if (extra) {
          <kendo-grid-date-filter-menu-input
            [operators]="operators"
            [currentFilter]="secondFilter"
            [filterService]="filterService"
            [column]="column"
            [filter]="filter"
            [activeView]="activeView"
            [bottomView]="bottomView"
            [topView]="topView"
            [format]="format"
            [formatPlaceholder]="formatPlaceholder"
            [placeholder]="placeholder"
            [min]="min"
            [max]="max"
            [weekNumber]="weekNumber"
            [menuTabbingService]="menuTabbingService">
          </kendo-grid-date-filter-menu-input>
        }
        `,
      standalone: true,
      imports: [DateFilterMenuInputComponent, DropDownListComponent, FilterMenuDropDownListDirective]
    }]
  }], () => [{
    type: ContextService
  }], {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-filtercell"]
    }],
    filter: [{
      type: Input
    }],
    extra: [{
      type: Input
    }],
    filterService: [{
      type: Input
    }],
    menuTabbingService: [{
      type: Input
    }]
  });
})();
var BooleanFilterComponent = class _BooleanFilterComponent extends BaseFilterCellComponent {
  ctx;
  /**
   * Sets the column for this filter.
   * @type {ColumnComponent}
   */
  column;
  /**
   * @hidden
   */
  operator = "eq";
  /**
   * Gets the current filter for the column field.
   * @readonly
   * @type {FilterDescriptor}
   */
  get currentFilter() {
    return this.filterByField(this.column.field);
  }
  /**
   * Gets the current filter operator for the column field.
   * @readonly
   * @type {string}
   */
  get currentOperator() {
    return this.currentFilter ? this.currentFilter.operator : this.operator;
  }
  items;
  defaultItem;
  subscription;
  constructor(filterService, ctx) {
    super(filterService);
    this.ctx = ctx;
    this.items = [{
      text: this.ctx.localization.get("filterIsTrue"),
      value: true
    }, {
      text: this.ctx.localization.get("filterIsFalse"),
      value: false
    }];
    this.defaultItem = {
      text: this.ctx.localization.get("filterBooleanAll"),
      value: null
    };
  }
  ngOnInit() {
    this.subscription = this.ctx.localization.changes.subscribe(this.localizationChange.bind(this));
  }
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
    super.ngOnDestroy();
  }
  localizationChange() {
    this.items = [{
      text: this.ctx.localization.get("filterIsTrue"),
      value: true
    }, {
      text: this.ctx.localization.get("filterIsFalse"),
      value: false
    }];
    this.defaultItem = {
      text: this.ctx.localization.get("filterBooleanAll"),
      value: null
    };
  }
  static ɵfac = function BooleanFilterComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BooleanFilterComponent)(ɵɵdirectiveInject(FilterService), ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _BooleanFilterComponent,
    selectors: [["kendo-grid-boolean-filter-base"]],
    inputs: {
      column: "column"
    },
    features: [ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function BooleanFilterComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BooleanFilterComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-boolean-filter-base",
      template: ``
    }]
  }], () => [{
    type: FilterService
  }, {
    type: ContextService
  }], {
    column: [{
      type: Input
    }]
  });
})();
var BooleanFilterRadioButtonDirective = class _BooleanFilterRadioButtonDirective {
  hostElement;
  renderer;
  columnLabel;
  radioButtonEl;
  constructor(hostElement, renderer) {
    this.hostElement = hostElement;
    this.renderer = renderer;
  }
  ngAfterViewInit() {
    this.radioButtonEl = this.hostElement.nativeElement;
    this.renderer.setAttribute(this.hostElement.nativeElement, "aria-label", this.columnLabel);
  }
  static ɵfac = function BooleanFilterRadioButtonDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BooleanFilterRadioButtonDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _BooleanFilterRadioButtonDirective,
    selectors: [["", "kendoFilterMenuRadioButton", ""]],
    inputs: {
      columnLabel: "columnLabel"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BooleanFilterRadioButtonDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoFilterMenuRadioButton]",
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }], {
    columnLabel: [{
      type: Input
    }]
  });
})();
var BooleanFilterMenuComponent = class _BooleanFilterMenuComponent extends BooleanFilterComponent {
  /**
   * @hidden
   */
  get hostClasses() {
    return false;
  }
  /**
   * The current menu filter.
   * @type {CompositeFilterDescriptor}
   */
  filter = {
    filters: [],
    logic: "and"
  };
  /**
   * Represents the `FilterService` instance that handles changes in the filter descriptor.
   */
  filterService;
  /**
   * @hidden
   */
  menuTabbingService;
  idPrefix = guid();
  /**
   * @hidden
   */
  radioButtons;
  constructor(ctx) {
    super(null, ctx);
  }
  ngAfterViewInit() {
    this.filterService.menuTabbingService.firstFocusable = this.radioButtons.first.radioButtonEl;
    if (!this.menuTabbingService?.isTabbedInterface) {
      this.radioButtons.first.radioButtonEl.focus();
    }
  }
  /**
   * @hidden
   */
  radioId(value2) {
    return `${this.idPrefix}_${value2}`;
  }
  /**
   * @hidden
   */
  onChange(value2, input) {
    this.applyFilter(this.updateFilter({
      field: this.column.field,
      operator: "eq",
      value: value2
    }));
    this.filterService.menuTabbingService.firstFocusable = input.hostElement.nativeElement;
  }
  /**
   * @hidden
   */
  isSelected(radioValue) {
    return this.filtersByField(this.column.field).some(({
      value: value2
    }) => value2 === radioValue);
  }
  /**
   * @hidden
   */
  onShiftTab(e) {
    if (!this.menuTabbingService?.isColumnMenu && this.filterService.menuTabbingService.lastFocusable) {
      e.preventDefault();
      this.filterService.menuTabbingService.lastFocusable.focus();
    }
  }
  /**
   * @hidden
   */
  get columnLabel() {
    const localizationMsg = this.ctx.localization.get("filterInputLabel") || "";
    const columnName = this.column.title || this.column.field;
    return replaceMessagePlaceholder(localizationMsg, "columnName", columnName);
  }
  static ɵfac = function BooleanFilterMenuComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BooleanFilterMenuComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _BooleanFilterMenuComponent,
    selectors: [["kendo-grid-boolean-filter-menu"]],
    viewQuery: function BooleanFilterMenuComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(BooleanFilterRadioButtonDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.radioButtons = _t);
      }
    },
    hostVars: 2,
    hostBindings: function BooleanFilterMenuComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-filtercell", ctx.hostClasses);
      }
    },
    inputs: {
      filter: "filter",
      filterService: "filterService",
      menuTabbingService: "menuTabbingService"
    },
    features: [ɵɵInheritDefinitionFeature],
    decls: 3,
    vars: 0,
    consts: [["input", ""], [1, "k-radio-list", "k-reset"], ["kendoFilterMenuRadioButton", "", 3, "change", "keydown.shift.tab", "columnLabel", "size", "name", "checked"], [1, "k-radio-label"]],
    template: function BooleanFilterMenuComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "ul", 1);
        ɵɵrepeaterCreate(1, BooleanFilterMenuComponent_For_2_Template, 5, 7, "li", null, ɵɵrepeaterTrackByIdentity);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵrepeater(ctx.items);
      }
    },
    dependencies: [RadioButtonComponent, BooleanFilterRadioButtonDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BooleanFilterMenuComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-boolean-filter-menu",
      template: `
        <ul class="k-radio-list k-reset">
          @for (item of items; track item) {
            <li>
              <kendo-radiobutton
                kendoFilterMenuRadioButton
                [columnLabel]="columnLabel"
                #input
                [size]="ctx.grid?.isActionSheetExpanded ? 'large' : null"
                [name]="idPrefix"
                [checked]="isSelected(item.value)"
                [attr.id]="radioId(item.value)"
                (change)="onChange(item.value, input)"
                (keydown.shift.tab)="onShiftTab($event)"
              ></kendo-radiobutton>
              <label class="k-radio-label" [attr.for]="input.focusableId">{{item.text}}</label>
            </li>
          }
        </ul>
        `,
      standalone: true,
      imports: [RadioButtonComponent, BooleanFilterRadioButtonDirective]
    }]
  }], () => [{
    type: ContextService
  }], {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-filtercell"]
    }],
    filter: [{
      type: Input
    }],
    filterService: [{
      type: Input
    }],
    menuTabbingService: [{
      type: Input
    }],
    radioButtons: [{
      type: ViewChildren,
      args: [BooleanFilterRadioButtonDirective]
    }]
  });
})();
var filterMenuComponentFactory = (type) => ({
  "boolean": BooleanFilterMenuComponent,
  "date": DateFilterMenuComponent,
  "numeric": NumericFilterMenuComponent,
  "text": StringFilterMenuComponent
})[type];
var FilterMenuHostDirective = class _FilterMenuHostDirective extends FilterHostDirective {
  filterService;
  menuTabbingService;
  constructor(host) {
    super(host);
  }
  componentType() {
    if (isPresent7(this.column) && !isNullOrEmptyString2(this.column.filter)) {
      return filterMenuComponentFactory(this.column.filter);
    }
    return StringFilterMenuComponent;
  }
  initComponent(ctx) {
    super.initComponent(ctx);
    this.component.instance.filterService = this.filterService;
    this.component.instance.menuTabbingService = this.menuTabbingService;
  }
  static ɵfac = function FilterMenuHostDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FilterMenuHostDirective)(ɵɵdirectiveInject(ViewContainerRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FilterMenuHostDirective,
    selectors: [["", "kendoFilterMenuHost", ""]],
    inputs: {
      filterService: "filterService",
      menuTabbingService: "menuTabbingService"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterMenuHostDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoFilterMenuHost]",
      standalone: true
    }]
  }], () => [{
    type: ViewContainerRef
  }], {
    filterService: [{
      type: Input
    }],
    menuTabbingService: [{
      type: Input
    }]
  });
})();
var LocalDataChangesService = class _LocalDataChangesService {
  changes = new EventEmitter();
  data;
  static ɵfac = function LocalDataChangesService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LocalDataChangesService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _LocalDataChangesService,
    factory: _LocalDataChangesService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalDataChangesService, [{
    type: Injectable
  }], null, null);
})();
var FORMAT_REGEX = /\{\d+:?/;
var FormatPipe = class _FormatPipe {
  intlService;
  constructor(intlService) {
    this.intlService = intlService;
  }
  transform(value2, format) {
    const intl = this.intlService;
    if (isString2(format) && FORMAT_REGEX.exec(format)) {
      return intl.format(format, value2);
    }
    return intl.toString(value2, format);
  }
  static ɵfac = function FormatPipe_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormatPipe)(ɵɵdirectiveInject(IntlService, 16));
  };
  static ɵpipe = ɵɵdefinePipe({
    name: "format",
    type: _FormatPipe,
    pure: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormatPipe, [{
    type: Pipe,
    args: [{
      // eslint-disable-next-line @angular-eslint/pipe-prefix
      name: "format",
      pure: false,
      standalone: true
    }]
  }], () => [{
    type: IntlService
  }], null);
})();
var MultiCheckboxFilterComponent = class _MultiCheckboxFilterComponent {
  ctx;
  dataChangesService;
  column;
  filterChange = new EventEmitter();
  filterInput;
  constructor(ctx, dataChangesService) {
    this.ctx = ctx;
    this.dataChangesService = dataChangesService;
  }
  listData = [];
  searchIcon = searchIcon;
  showSelectAll = true;
  currentlySelected = /* @__PURE__ */ new Set();
  isSearched = false;
  currentFilter;
  filterChangeSub;
  baseListData = [];
  ngOnInit() {
    this.initializeData();
    this.currentFilter = this.ctx.grid?.filter ?? this.emptyFilter();
    this.updateSelectionFromFilter();
    if (this.currentFilter) {
      this.filterChange.emit(this.currentFilter);
    }
  }
  ngAfterViewInit() {
    if (this.filterInput) {
      this.filterChangeSub = this.filterInput.change.subscribe(this.onSearch.bind(this));
    }
  }
  ngOnDestroy() {
    if (this.filterChangeSub) {
      this.filterChangeSub.unsubscribe();
      this.filterChangeSub = null;
    }
  }
  isItemSelected(item) {
    return this.currentlySelected.has(item);
  }
  onSearch(value2) {
    const searchValue = value2;
    this.isSearched = searchValue.length > 0;
    this.showSelectAll = !this.isSearched;
    if (!searchValue) {
      this.listData = [...this.baseListData];
    } else {
      this.listData = filterBy(this.baseListData, {
        operator: "contains",
        value: searchValue
      });
    }
  }
  handleCheckBoxChange(checkedState, value2, selectAllChecked) {
    const field = this.column?.field;
    if (!field) {
      return;
    }
    if (!this.currentFilter) {
      this.currentFilter = this.emptyFilter();
    }
    const newFilter = this.currentFilter;
    const filters = [...newFilter.filters];
    const compositeIndex = this.getCompositeFilterIndex(newFilter);
    let fieldFilters = [];
    if (compositeIndex !== -1 && filters[compositeIndex].filters && !selectAllChecked) {
      fieldFilters = [...filters[compositeIndex].filters];
    }
    if (checkedState && selectAllChecked) {
      this.listData.forEach((item) => {
        if (!fieldFilters.some((f) => f.value === item)) {
          fieldFilters.push({
            field,
            operator: "eq",
            value: item
          });
        }
      });
    } else if (!checkedState && selectAllChecked) {
      fieldFilters = [];
    } else if (checkedState) {
      if (!fieldFilters.some((f) => f.value === value2)) {
        fieldFilters.push({
          field,
          operator: "eq",
          value: value2
        });
      }
    } else {
      const idx4 = fieldFilters.findIndex((f) => f.value === value2);
      if (idx4 > -1) {
        fieldFilters.splice(idx4, 1);
      }
    }
    if (fieldFilters.length === 0) {
      if (compositeIndex !== -1) {
        filters.splice(compositeIndex, 1);
      }
    } else {
      const block = {
        logic: "or",
        filters: fieldFilters
      };
      if (compositeIndex !== -1) {
        filters[compositeIndex] = block;
      } else {
        filters.push(block);
      }
    }
    newFilter.logic = "and";
    newFilter.filters = filters;
    this.currentFilter = newFilter;
    this.updateSelectionFromFilter();
    this.filterChange.emit(this.currentFilter);
  }
  get filteredGridData() {
    return filterBy(this.gridData, this.ctx.grid?.filter);
  }
  get selectAllChecked() {
    if (!this.listData || this.listData.length === 0) {
      return false;
    }
    const total = this.listData.length;
    const selectedInView = this.listData.filter((i) => this.currentlySelected.has(i)).length;
    if (selectedInView === 0) {
      return false;
    }
    if (selectedInView === total) {
      return true;
    }
    return "indeterminate";
  }
  get gridData() {
    let data = [];
    const isLocalData = isPresent(this.ctx?.dataBindingDirective);
    if (isPresent(this.normalizedFilterVariant.data)) {
      data = this.normalizedFilterVariant.data;
    } else if (isLocalData) {
      data = this.dataChangesService.data;
    } else {
      data = this.ctx.grid?.flatData;
    }
    return data || [];
  }
  get normalizedFilterVariant() {
    const defaultMultiCheckboxSettings = {
      variant: "multiCheckbox",
      search: true
    };
    if (typeof this.column?.filterVariant === "string") {
      return {
        variant: this.column.filterVariant,
        search: true
      };
    }
    return Object.assign(defaultMultiCheckboxSettings, this.column?.filterVariant);
  }
  get selectedItemsMessage() {
    const localizationMsg = this.messageFor("multiCheckboxFilterSelectedItemsCount") || "";
    return replaceMessagePlaceholder(localizationMsg, "selectedItemsCount", this.currentlySelected.size.toString());
  }
  messageFor(key) {
    return this.ctx.localization.get(key);
  }
  getUniqueDateValues(data) {
    return data.reduce((acc, current) => {
      const value2 = current[this.column.field];
      if (value2 instanceof Date && acc.findIndex((d) => d.getTime() === value2.getTime()) === -1) {
        acc.push(value2);
      }
      return acc;
    }, []);
  }
  initializeData() {
    if (!this.column) {
      this.baseListData = [];
      return;
    }
    const isDate2 = this.column.filter === "date";
    if (isDate2) {
      const dates = this.getUniqueDateValues(this.gridData);
      const sortedDates = [...dates].sort((a, b) => a - b);
      this.baseListData = sortedDates;
    } else {
      const field = this.column.field;
      const mapped = this.gridData.map((item) => item?.[field]);
      this.baseListData = [...new Set(mapped)].sort((a, b) => {
        if (a > b) {
          return 1;
        }
        if (a < b) {
          return -1;
        }
        return 0;
      });
    }
    this.listData = [...this.baseListData];
  }
  emptyFilter() {
    return {
      filters: [],
      logic: "and"
    };
  }
  getCompositeFilterIndex(filter3) {
    const field = this.column?.field;
    return filter3.filters.findIndex((f) => f.filters?.length && f.filters[0].field === field);
  }
  updateSelectionFromFilter() {
    this.currentlySelected.clear();
    if (!this.currentFilter || !this.column?.field) {
      return;
    }
    const idx4 = this.getCompositeFilterIndex(this.currentFilter);
    if (idx4 === -1) {
      return;
    }
    const block = this.currentFilter.filters[idx4];
    if (block && Array.isArray(block.filters)) {
      block.filters.forEach((f) => {
        if (f.field === this.column.field && f.operator === "eq") {
          this.currentlySelected.add(f.value);
        }
      });
    }
  }
  static ɵfac = function MultiCheckboxFilterComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MultiCheckboxFilterComponent)(ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(LocalDataChangesService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _MultiCheckboxFilterComponent,
    selectors: [["kendo-grid-multicheckbox-filter"]],
    viewQuery: function MultiCheckboxFilterComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(FilterInputDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.filterInput = _t.first);
      }
    },
    inputs: {
      column: "column"
    },
    outputs: {
      filterChange: "filterChange"
    },
    decls: 7,
    vars: 3,
    consts: [["kendoFilterInput", "", 1, "k-searchbox", 3, "placeholder"], [1, "k-reset", "k-multicheck-wrap"], [1, "k-item", "k-check-all-wrap"], [1, "k-item"], [1, "k-filter-selected-items"], ["kendoTextBoxPrefixTemplate", ""], ["innerCssClass", "k-input-icon", "name", "search", 3, "svgIcon"], ["role", "option", 1, "k-label", "k-checkbox-label"], [3, "checkedStateChange", "checkedState"]],
    template: function MultiCheckboxFilterComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵconditionalCreate(0, MultiCheckboxFilterComponent_Conditional_0_Template, 2, 1, "kendo-textbox", 0);
        ɵɵelementStart(1, "ul", 1);
        ɵɵconditionalCreate(2, MultiCheckboxFilterComponent_Conditional_2_Template, 5, 2, "li", 2);
        ɵɵrepeaterCreate(3, MultiCheckboxFilterComponent_For_4_Template, 6, 5, "li", 3, ɵɵrepeaterTrackByIdentity);
        ɵɵelementEnd();
        ɵɵelementStart(5, "div", 4);
        ɵɵtext(6);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵconditional(ctx.normalizedFilterVariant.search ? 0 : -1);
        ɵɵadvance(2);
        ɵɵconditional(ctx.showSelectAll ? 2 : -1);
        ɵɵadvance();
        ɵɵrepeater(ctx.listData);
        ɵɵadvance(3);
        ɵɵtextInterpolate(ctx.selectedItemsMessage);
      }
    },
    dependencies: [CheckBoxComponent, TextBoxComponent, TextBoxPrefixTemplateDirective, IconWrapperComponent, FormatPipe, FilterInputDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MultiCheckboxFilterComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-multicheckbox-filter",
      template: `
        @if (normalizedFilterVariant.search) {
          <kendo-textbox
            kendoFilterInput
            class="k-searchbox"
            [placeholder]="messageFor('multiCheckboxFilterSearchPlaceholder')">
            <ng-template kendoTextBoxPrefixTemplate>
              <kendo-icon-wrapper innerCssClass="k-input-icon" name="search" [svgIcon]="searchIcon"></kendo-icon-wrapper>
            </ng-template>
          </kendo-textbox>
        }
        <ul class="k-reset k-multicheck-wrap">
          @if (showSelectAll) {
            <li class="k-item k-check-all-wrap">
              <label class="k-label k-checkbox-label" role="option">
                <kendo-checkbox
                  [checkedState]="selectAllChecked"
                  (checkedStateChange)="handleCheckBoxChange($event, null, true)">
                </kendo-checkbox>
                <span>{{ messageFor('multiCheckboxFilterSelectAllLabel') }}</span>
              </label>
            </li>
          }
          @for (item of listData; track item) {
            <li class="k-item">
              <label class="k-label k-checkbox-label" role="option">
                <kendo-checkbox
                  [checkedState]="isItemSelected(item)"
                  (checkedStateChange)="handleCheckBoxChange($event, item)">
                </kendo-checkbox>
                <span>{{ item | format: column.format }}</span>
              </label>
            </li>
          }
        </ul>
        <div class="k-filter-selected-items">{{selectedItemsMessage}}</div>
        `,
      standalone: true,
      imports: [CheckBoxComponent, TextBoxComponent, TextBoxPrefixTemplateDirective, IconWrapperComponent, FormatPipe, FilterInputDirective]
    }]
  }], () => [{
    type: ContextService
  }, {
    type: LocalDataChangesService
  }], {
    column: [{
      type: Input
    }],
    filterChange: [{
      type: Output
    }],
    filterInput: [{
      type: ViewChild,
      args: [FilterInputDirective]
    }]
  });
})();
var isNoValueOperator = (operator) => operator === "isnull" || operator === "isnotnull" || operator === "isempty" || operator === "isnotempty";
var validFilters = ({
  value: value2,
  operator
}) => !isNullOrEmptyString2(value2) || isNoValueOperator(operator);
var trimFilters = (filter3) => {
  const trimComposite = (node) => {
    const trimmed = [];
    for (const f of node.filters || []) {
      if (isCompositeFilterDescriptor(f)) {
        const child = trimComposite(f);
        if (child.filters.length) {
          trimmed.push(child);
        }
      } else if (validFilters(f)) {
        trimmed.push(f);
      }
    }
    return {
      logic: node.logic || "and",
      filters: trimmed
    };
  };
  return trimComposite(filter3);
};
var findParent = (filters, field, parent) => {
  return filters.reduce((acc, filter3) => {
    if (acc) {
      return acc;
    }
    if (filter3.filters) {
      return findParent(filter3.filters, field, filter3);
    } else if (filter3.field === field) {
      return parent;
    }
    return acc;
  }, void 0);
};
var parentLogicOfDefault = (filter3, field, def = "and") => {
  const parent = findParent((filter3 || {}).filters || [], field);
  return isPresent7(parent) ? parent.logic : def;
};
var FilterMenuContainerComponent = class _FilterMenuContainerComponent {
  parentService;
  childService;
  ctx;
  cd;
  adaptiveGridService;
  close = new EventEmitter();
  /**
   * The column with which the filter is associated.
   * @type {ColumnComponent}
   */
  column;
  /**
   * @hidden
   */
  isLast;
  /**
   * @hidden
   */
  isExpanded;
  /**
   * @hidden
   */
  menuTabbingService;
  /**
   * The current root filter.
   * @type {CompositeFilterDescriptor}
   */
  set filter(value2) {
    this._filter = cloneFilters(value2);
  }
  get filter() {
    return this._filter;
  }
  /**
   * @hidden
   */
  actionsClass = "k-actions k-actions-stretched k-actions-horizontal";
  get childFilter() {
    if (!isPresent7(this._childFilter)) {
      this._childFilter = {
        filters: filtersByField(this.filter, (this.column || {}).field),
        logic: parentLogicOfDefault(this.filter, (this.column || {}).field)
      };
    }
    return this._childFilter;
  }
  resetButton;
  _childFilter;
  subscription;
  _templateContext = {};
  _filter;
  checkboxFilter;
  constructor(parentService, childService, ctx, cd, menuTabbingService, adaptiveGridService) {
    this.parentService = parentService;
    this.childService = childService;
    this.ctx = ctx;
    this.cd = cd;
    this.adaptiveGridService = adaptiveGridService;
    this.menuTabbingService = menuTabbingService;
    this.adaptiveGridService.filterMenuContainer = this;
  }
  ngOnInit() {
    this.subscription = this.childService.changes.subscribe((filter3) => this._childFilter = filter3);
    this.subscription.add(this.ctx.localization.changes.subscribe(() => this.cd.markForCheck()));
  }
  ngAfterViewChecked() {
    if (!this.menuTabbingService.isColumnMenu || this.isLast && this.isExpanded) {
      this.menuTabbingService.lastFocusable = this.resetButton?.nativeElement;
    }
  }
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
    this.menuTabbingService.lastFocusable = void 0;
  }
  get disabled() {
    return this.isMultiFilter ? this.areFiltersEqual : !this.childFilter.filters.some(validFilters);
  }
  get templateContext() {
    this._templateContext.column = this.column;
    this._templateContext.filter = this.childFilter;
    this._templateContext.filterService = this.childService;
    this._templateContext["$implicit"] = this.childFilter;
    return this._templateContext;
  }
  get hasTemplate() {
    return isPresent7(this.column) && isPresent7(this.column.filterMenuTemplateRef);
  }
  submit() {
    if (this.isMultiFilter) {
      this.parentService.filter(this.checkboxFilter);
    } else {
      const filter3 = trimFilters(this.childFilter);
      if (filter3.filters.length) {
        const root = this.filter || {
          filters: [],
          logic: "and"
        };
        removeFilter(root, this.column.field);
        root.filters.push(filter3);
        this.parentService.filter(root);
      }
    }
    this.close.emit();
    return false;
  }
  reset() {
    const root = this.filter || {
      filters: [],
      logic: "and"
    };
    removeFilter(root, this.column.field);
    this.parentService.filter(root);
    this.close.emit();
  }
  resetChildFilters() {
    this._childFilter = null;
  }
  onTab(e, buttonType) {
    if (this.menuTabbingService.firstFocusable && (!this.menuTabbingService.isColumnMenu || this.isLast)) {
      e.preventDefault();
      if (buttonType === "reset") {
        this.menuTabbingService.firstFocusable.focus();
      } else {
        this.disabled ? this.menuTabbingService.firstFocusable.focus() : this.resetButton.nativeElement.focus();
      }
    }
  }
  onCheckboxFilterChange(filter3) {
    this.checkboxFilter = filter3;
  }
  getButtonIcon(buttonType, iconType) {
    if (!this.isMultiFilter) {
      return;
    }
    const icons = {
      filter: {
        icon: "filter",
        svgIcon: filterIcon
      },
      reset: {
        icon: "filter-clear",
        svgIcon: filterClearIcon
      }
    };
    return icons[buttonType]?.[iconType];
  }
  get clearText() {
    return this.ctx.localization.get("filterClearButton");
  }
  get filterText() {
    return this.ctx.localization.get("filterFilterButton");
  }
  get isMultiFilter() {
    if (!isPresent7(this.column?.filterVariant)) {
      return false;
    }
    const filterVariant = this.column?.filterVariant;
    return isPresent7(filterVariant) && (filterVariant === "multiCheckbox" || typeof filterVariant === "object" && filterVariant.variant === "multiCheckbox");
  }
  get areFiltersEqual() {
    const checkboxFilter = this.checkboxFilter;
    const gridFilter = this.filter;
    const isComposite = (f) => !!f && Array.isArray(f.filters);
    const isEmptyComposite = (f) => isComposite(f) && f.filters.length === 0;
    if (!checkboxFilter && !gridFilter) {
      return true;
    }
    if (!checkboxFilter && isEmptyComposite(gridFilter) || !gridFilter && isEmptyComposite(checkboxFilter)) {
      return true;
    }
    if (!checkboxFilter || !gridFilter) {
      return false;
    }
    const eq = (x, y) => {
      const xIsComp = isComposite(x);
      const yIsComp = isComposite(y);
      if (xIsComp !== yIsComp) {
        return false;
      }
      if (xIsComp) {
        const xLogic = x.logic || "and";
        const yLogic = y.logic || "and";
        if (xLogic !== yLogic) {
          return false;
        }
        if (x.filters.length !== y.filters.length) {
          return false;
        }
        for (let i = 0; i < x.filters.length; i++) {
          if (!eq(x.filters[i], y.filters[i])) {
            return false;
          }
        }
        return true;
      }
      return areObjectsEqual(x, y);
    };
    return eq(checkboxFilter, gridFilter);
  }
  static ɵfac = function FilterMenuContainerComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FilterMenuContainerComponent)(ɵɵdirectiveInject(FilterService, 4), ɵɵdirectiveInject(FilterService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(MenuTabbingService), ɵɵdirectiveInject(AdaptiveGridService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _FilterMenuContainerComponent,
    selectors: [["kendo-grid-filter-menu-container"]],
    viewQuery: function FilterMenuContainerComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c124, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.resetButton = _t.first);
      }
    },
    inputs: {
      column: "column",
      isLast: "isLast",
      isExpanded: "isExpanded",
      menuTabbingService: "menuTabbingService",
      filter: "filter",
      actionsClass: "actionsClass"
    },
    outputs: {
      close: "close"
    },
    features: [ɵɵProvidersFeature([FilterService, MenuTabbingService])],
    decls: 5,
    vars: 5,
    consts: [["filterButton", ""], ["resetButton", ""], [1, "k-filter-menu", 3, "submit", "reset", "ngClass"], [1, "k-filter-menu-container"], [3, "ngClass"], ["kendoFilterMenuHost", "", 3, "filterService", "column", "filter", "menuTabbingService"], [2, "display", "contents", 3, "column"], [2, "display", "contents", 3, "filterChange", "column"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["kendoButton", "", "themeColor", "primary", "type", "submit", 3, "keydown.tab", "ngClass", "disabled", "icon", "svgIcon"], ["kendoButton", "", "type", "reset", 3, "keydown.tab", "ngClass", "icon", "svgIcon"]],
    template: function FilterMenuContainerComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "form", 2);
        ɵɵlistener("submit", function FilterMenuContainerComponent_Template_form_submit_0_listener() {
          return ctx.submit();
        })("reset", function FilterMenuContainerComponent_Template_form_reset_0_listener() {
          return ctx.reset();
        });
        ɵɵelementStart(1, "div", 3);
        ɵɵconditionalCreate(2, FilterMenuContainerComponent_Case_2_Template, 2, 1)(3, FilterMenuContainerComponent_Case_3_Template, 1, 1);
        ɵɵconditionalCreate(4, FilterMenuContainerComponent_Conditional_4_Template, 7, 14, "div", 4);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        let tmp_1_0;
        ɵɵproperty("ngClass", ɵɵpureFunction1(3, _c134, ctx.isMultiFilter && !(ctx.ctx.grid == null ? null : ctx.ctx.grid.isActionSheetExpanded)));
        ɵɵadvance(2);
        ɵɵconditional((tmp_1_0 = ctx.hasTemplate) === false ? 2 : tmp_1_0 === true ? 3 : -1);
        ɵɵadvance(2);
        ɵɵconditional(!(ctx.ctx.grid == null ? null : ctx.ctx.grid.isActionSheetExpanded) ? 4 : -1);
      }
    },
    dependencies: [FormsModule, ɵNgNoValidate, NgControlStatusGroup, NgForm, FilterMenuHostDirective, NgTemplateOutlet, NgClass, MultiCheckboxFilterComponent, ButtonComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterMenuContainerComponent, [{
    type: Component,
    args: [{
      providers: [FilterService, MenuTabbingService],
      selector: "kendo-grid-filter-menu-container",
      template: `
        <form (submit)="submit()" (reset)="reset()"
          class="k-filter-menu"
          [ngClass]="{'k-popup k-group k-reset': isMultiFilter && !ctx.grid?.isActionSheetExpanded}">
          <div class="k-filter-menu-container">
            @switch (hasTemplate) {
              @case (false) {
                @if (!isMultiFilter) {
                  <ng-container
                    kendoFilterMenuHost
                    [filterService]="childService"
                    [column]="column"
                    [filter]="childFilter"
                    [menuTabbingService]="menuTabbingService">
                  </ng-container>
                } @else {
                  <kendo-grid-multicheckbox-filter style="display: contents;" [column]="column" (filterChange)="onCheckboxFilterChange($event)"></kendo-grid-multicheckbox-filter>
                }
              }
              @case (true) {
                @if (column.filterMenuTemplateRef) {
                  <ng-template
                    [ngTemplateOutlet]="column.filterMenuTemplateRef"
                    [ngTemplateOutletContext]="templateContext"
                    >
                  </ng-template>
                }
              }
            }
            @if (!ctx.grid?.isActionSheetExpanded) {
              <div [ngClass]="actionsClass">
                <button #filterButton kendoButton
                  themeColor="primary"
                  type="submit"
                  [ngClass]="{'k-button-rectangle': !isMultiFilter}"
                  [disabled]="disabled"
                  [icon]="getButtonIcon('filter', 'icon')"
                  [svgIcon]="getButtonIcon('filter', 'svgIcon')"
                (keydown.tab)="onTab($event, 'filter')">{{filterText}}</button>
                <button #resetButton kendoButton
                  type="reset"
                  [ngClass]="{'k-button-rectangle': !isMultiFilter}"
                  [icon]="getButtonIcon('reset', 'icon')"
                  [svgIcon]="getButtonIcon('reset', 'svgIcon')"
                (keydown.tab)="onTab($event, 'reset')">{{clearText}}</button>
              </div>
            }
          </div>
        </form>
        `,
      standalone: true,
      imports: [FormsModule, FilterMenuHostDirective, NgTemplateOutlet, NgClass, MultiCheckboxFilterComponent, ButtonComponent]
    }]
  }], () => [{
    type: FilterService,
    decorators: [{
      type: SkipSelf
    }]
  }, {
    type: FilterService
  }, {
    type: ContextService
  }, {
    type: ChangeDetectorRef
  }, {
    type: MenuTabbingService
  }, {
    type: AdaptiveGridService
  }], {
    close: [{
      type: Output
    }],
    column: [{
      type: Input
    }],
    isLast: [{
      type: Input
    }],
    isExpanded: [{
      type: Input
    }],
    menuTabbingService: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    actionsClass: [{
      type: Input
    }],
    resetButton: [{
      type: ViewChild,
      args: ["resetButton", {
        static: false
      }]
    }]
  });
})();
var id$1 = 0;
var getId$12 = (gridId) => `${gridId}-filter-menu-${id$1++}`;
var FilterMenuComponent = class _FilterMenuComponent {
  filterService;
  popupService;
  ctx;
  navigationService;
  renderer;
  cdr;
  adaptiveGridService;
  idService;
  filterIcon = filterIcon;
  /**
   * The column with which the filter is associated.
   * @type {ColumnComponent}
   */
  column;
  /**
   * The current root filter.
   * @type {CompositeFilterDescriptor}
   */
  filter;
  anchor;
  template;
  tabIndex = "-1";
  popupRef;
  popupSubs;
  constructor(filterService, popupService, ctx, navigationService, renderer, cdr, adaptiveGridService, idService) {
    this.filterService = filterService;
    this.popupService = popupService;
    this.ctx = ctx;
    this.navigationService = navigationService;
    this.renderer = renderer;
    this.cdr = cdr;
    this.adaptiveGridService = adaptiveGridService;
    this.idService = idService;
  }
  ngOnDestroy() {
    this.cleanUp();
  }
  get hasFilters() {
    return filtersByField(this.filter, (this.column || {}).field).length > 0;
  }
  /**
   * @hidden
   */
  get filterLabel() {
    const localizationMsg = this.ctx.localization.get("filterMenuTitle") || "";
    const columnName = this.column.title || this.column.field;
    return replaceMessagePlaceholder(localizationMsg, "columnName", columnName);
  }
  /**
   * @hidden
   */
  get isNavigable() {
    return this.navigationService.tableEnabled;
  }
  toggle(anchor, template) {
    if (this.ctx.grid?.adaptiveMode === "auto" && this.adaptiveGridService.windowSize !== "large") {
      if (!this.ctx.grid.isActionSheetExpanded) {
        this.adaptiveGridService.viewType = "filterMenu";
        this.adaptiveGridService.column = this.column;
        this.ctx.grid.adaptiveRenderer.actionSheet.toggle(true);
      }
    } else {
      this.popupRef = this.popupService.open(anchor, template, this.popupRef);
      const ariaRoot = this.isNavigable ? anchor.closest(".k-table-th") : anchor;
      if (this.popupRef) {
        this.popupSubs?.unsubscribe();
        this.popupSubs = this.popupRef.popup.instance.anchorViewportLeave.subscribe(() => {
          this.close();
          this.updateAria(ariaRoot);
        });
        this.popupSubs.add(() => this.popupRef.popup.instance.close.subscribe(() => {
          this.popupRef = null;
          this.updateAria(ariaRoot);
        }));
        const popupAriaElement = this.popupRef.popupElement.querySelector(".k-grid-filter-popup");
        if (popupAriaElement) {
          const popupId = getId$12(this.idService?.gridId());
          this.renderer.setAttribute(popupAriaElement, "id", popupId);
          this.renderer.setAttribute(popupAriaElement, "role", "dialog");
          this.renderer.setAttribute(popupAriaElement, "aria-label", this.filterLabel);
          ariaRoot && this.renderer.setAttribute(ariaRoot, "aria-controls", popupId);
          ariaRoot && this.renderer.setAttribute(ariaRoot, "aria-expanded", "true");
        }
      } else {
        this.focusRoot();
      }
    }
    return false;
  }
  close() {
    this.cleanUp();
    this.focusRoot();
  }
  updateAria(ariaRoot) {
    ariaRoot && this.renderer.removeAttribute(ariaRoot, "aria-controls");
    ariaRoot && this.renderer.setAttribute(ariaRoot, "aria-expanded", "false");
  }
  cleanUp() {
    this.popupService.destroy();
    this.popupRef = null;
    this.popupSubs?.unsubscribe();
    this.popupSubs = null;
    this.cdr.markForCheck();
  }
  focusRoot() {
    if (this.isNavigable) {
      this.navigationService.preventScroll = true;
      this.navigationService.focusCell(0, this.column.leafIndex);
    } else {
      this.anchor.nativeElement.focus({
        preventScroll: true
      });
    }
  }
  static ɵfac = function FilterMenuComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FilterMenuComponent)(ɵɵdirectiveInject(FilterService), ɵɵdirectiveInject(SinglePopupService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NavigationService4), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(AdaptiveGridService), ɵɵdirectiveInject(IdService, 8));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _FilterMenuComponent,
    selectors: [["kendo-grid-filter-menu"]],
    viewQuery: function FilterMenuComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c154, 7)(_c164, 7, TemplateRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.anchor = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.template = _t.first);
      }
    },
    inputs: {
      column: "column",
      filter: "filter",
      tabIndex: "tabIndex"
    },
    decls: 5,
    vars: 7,
    consts: [["anchor", ""], ["template", ""], ["href", "#", 1, "k-grid-filter-menu", "k-grid-header-menu", 3, "click", "keydown.enter", "tabindex"], ["name", "filter", 3, "svgIcon"], [3, "close", "keydown.escape", "keydown.enter", "column", "filter"]],
    template: function FilterMenuComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "a", 2, 0);
        ɵɵlistener("click", function FilterMenuComponent_Template_a_click_0_listener() {
          ɵɵrestoreView(_r1);
          const anchor_r2 = ɵɵreference(1);
          const template_r3 = ɵɵreference(4);
          return ɵɵresetView(ctx.toggle(anchor_r2, template_r3));
        })("keydown.enter", function FilterMenuComponent_Template_a_keydown_enter_0_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView($event.stopImmediatePropagation());
        });
        ɵɵelement(2, "kendo-icon-wrapper", 3);
        ɵɵelementEnd();
        ɵɵtemplate(3, FilterMenuComponent_ng_template_3_Template, 1, 2, "ng-template", null, 1, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        ɵɵclassProp("k-active", ctx.hasFilters);
        ɵɵproperty("tabindex", ctx.tabIndex);
        ɵɵattribute("title", ctx.filterLabel)("aria-haspopup", ctx.isNavigable ? void 0 : "dialog")("aria-expanded", ctx.isNavigable ? void 0 : false);
        ɵɵadvance(2);
        ɵɵproperty("svgIcon", ctx.filterIcon);
      }
    },
    dependencies: [IconWrapperComponent, FilterMenuContainerComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterMenuComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-filter-menu",
      template: `
        <a #anchor
            class="k-grid-filter-menu k-grid-header-menu"
            [class.k-active]="hasFilters"
            [tabindex]="tabIndex"
            (click)="toggle(anchor, template)"
            (keydown.enter)="$event.stopImmediatePropagation()"
            href="#"
            [attr.title]="filterLabel"
            [attr.aria-haspopup]="isNavigable ? undefined : 'dialog'"
            [attr.aria-expanded]="isNavigable ? undefined : false">
            <kendo-icon-wrapper
                name="filter"
                [svgIcon]="filterIcon"></kendo-icon-wrapper>
        </a>
        <ng-template #template>
            <kendo-grid-filter-menu-container
                [column]="column"
                [filter]="filter"
                (close)="close()"
                (keydown.escape)="close()"
                (keydown.enter)="$event.stopImmediatePropagation()">
            </kendo-grid-filter-menu-container>
        </ng-template>
    `,
      standalone: true,
      imports: [IconWrapperComponent, FilterMenuContainerComponent]
    }]
  }], () => [{
    type: FilterService
  }, {
    type: SinglePopupService
  }, {
    type: ContextService
  }, {
    type: NavigationService4
  }, {
    type: Renderer2
  }, {
    type: ChangeDetectorRef
  }, {
    type: AdaptiveGridService
  }, {
    type: IdService,
    decorators: [{
      type: Optional
    }]
  }], {
    column: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    anchor: [{
      type: ViewChild,
      args: ["anchor", {
        static: true
      }]
    }],
    template: [{
      type: ViewChild,
      args: ["template", {
        static: true,
        read: TemplateRef
      }]
    }],
    tabIndex: [{
      type: Input
    }]
  });
})();
var EMPTY_FILTER_OPERATORS = ["isnull", "isnotnull", "isempty", "isnotempty"];
var FilterCellWrapperComponent = class _FilterCellWrapperComponent extends FilterInputWrapperComponent {
  get hostClasses() {
    return true;
  }
  get overrideBaseClasses() {
    return false;
  }
  showOperators = true;
  get showButton() {
    const filter3 = this.currentFilter;
    return isPresent7(filter3) && (!isNullOrEmptyString2(filter3.value) || EMPTY_FILTER_OPERATORS.indexOf(String(filter3.operator)) >= 0);
  }
  constructor(filterService) {
    super(filterService);
  }
  filterChange(filter3) {
    this.applyFilter(filter3);
  }
  static ɵfac = function FilterCellWrapperComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FilterCellWrapperComponent)(ɵɵdirectiveInject(FilterService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _FilterCellWrapperComponent,
    selectors: [["kendo-grid-filter-wrapper-cell"]],
    hostVars: 4,
    hostBindings: function FilterCellWrapperComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-filtercell-wrapper", ctx.hostClasses)("k-filtercell", ctx.overrideBaseClasses);
      }
    },
    inputs: {
      showOperators: "showOperators"
    },
    features: [ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c118,
    decls: 2,
    vars: 5,
    consts: [[3, "clear", "valueChange", "showOperators", "column", "operators", "showButton", "value"]],
    template: function FilterCellWrapperComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
        ɵɵelementStart(1, "kendo-grid-filter-cell-operators", 0);
        ɵɵlistener("clear", function FilterCellWrapperComponent_Template_kendo_grid_filter_cell_operators_clear_1_listener() {
          return ctx.onClear();
        });
        ɵɵtwoWayListener("valueChange", function FilterCellWrapperComponent_Template_kendo_grid_filter_cell_operators_valueChange_1_listener($event) {
          ɵɵtwoWayBindingSet(ctx.currentOperator, $event) || (ctx.currentOperator = $event);
          return $event;
        });
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("showOperators", ctx.showOperators)("column", ctx.column)("operators", ctx.operators)("showButton", ctx.showButton);
        ɵɵtwoWayProperty("value", ctx.currentOperator);
      }
    },
    dependencies: [FilterCellOperatorsComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterCellWrapperComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-filter-wrapper-cell",
      template: `
        <ng-content></ng-content>
        <kendo-grid-filter-cell-operators
            [showOperators]="showOperators"
            [column]="column"
            [operators]="operators"
            (clear)="onClear()"
            [showButton]="showButton"
            [(value)]="currentOperator">
        </kendo-grid-filter-cell-operators>
    `,
      standalone: true,
      imports: [FilterCellOperatorsComponent]
    }]
  }], () => [{
    type: FilterService
  }], {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-filtercell-wrapper"]
    }],
    overrideBaseClasses: [{
      type: HostBinding,
      args: ["class.k-filtercell"]
    }],
    showOperators: [{
      type: Input
    }]
  });
})();
var stringOperators = localizeOperators({
  "filterContainsOperator": "contains",
  "filterNotContainsOperator": "doesnotcontain",
  "filterEqOperator": "eq",
  "filterNotEqOperator": "neq",
  "filterStartsWithOperator": "startswith",
  "filterEndsWithOperator": "endswith",
  "filterIsNullOperator": "isnull",
  "filterIsNotNullOperator": "isnotnull",
  "filterIsEmptyOperator": "isempty",
  "filterIsNotEmptyOperator": "isnotempty"
});
var AutoCompleteFilterCellComponent = class _AutoCompleteFilterCellComponent extends BaseFilterCellComponent {
  ctx;
  showOperators = true;
  column;
  data;
  set valueField(value2) {
    this._valueField = value2;
  }
  get valueField() {
    return this._valueField ? this._valueField : this.column.field;
  }
  get currentFilter() {
    return this.filterByField(this.column.field);
  }
  get currentOperator() {
    return this.currentFilter ? this.currentFilter.operator : "contains";
  }
  size = "medium";
  _valueField;
  subs;
  constructor(filterService, column, ctx, sizingOptionsService) {
    super(filterService);
    this.ctx = ctx;
    this.defaultOperators = stringOperators(this.ctx.localization);
    this.column = column;
    this.subs = sizingOptionsService.changes.subscribe((size) => this.size = size);
  }
  ngOnDestroy() {
    if (this.subs) {
      this.subs.unsubscribe();
    }
  }
  static ɵfac = function AutoCompleteFilterCellComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AutoCompleteFilterCellComponent)(ɵɵdirectiveInject(FilterService), ɵɵdirectiveInject(ColumnComponent2), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(SizingOptionsService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _AutoCompleteFilterCellComponent,
    selectors: [["kendo-grid-autocomplete-filter-cell"]],
    inputs: {
      showOperators: "showOperators",
      column: "column",
      data: "data",
      valueField: "valueField"
    },
    features: [ɵɵInheritDefinitionFeature],
    decls: 2,
    vars: 8,
    consts: [[3, "column", "filter", "operators", "showOperators"], ["kendoFilterInput", "", 3, "data", "size", "valueField", "value"]],
    template: function AutoCompleteFilterCellComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "kendo-grid-filter-wrapper-cell", 0);
        ɵɵelement(1, "kendo-autocomplete", 1);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("column", ctx.column)("filter", ctx.filter)("operators", ctx.operators)("showOperators", ctx.showOperators);
        ɵɵadvance();
        ɵɵproperty("data", ctx.data)("size", ctx.size)("valueField", ctx.valueField)("value", ctx.currentFilter == null ? null : ctx.currentFilter.value);
      }
    },
    dependencies: [FilterCellWrapperComponent, AutoCompleteComponent, FilterInputDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AutoCompleteFilterCellComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-autocomplete-filter-cell",
      template: `
        <kendo-grid-filter-wrapper-cell
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [showOperators]="showOperators">
            <kendo-autocomplete
                kendoFilterInput
                [data]="data"
                [size]="size"
                [valueField]="valueField"
                [value]="currentFilter?.value">
            </kendo-autocomplete>
        </kendo-grid-filter-wrapper-cell>
    `,
      standalone: true,
      imports: [FilterCellWrapperComponent, AutoCompleteComponent, FilterInputDirective]
    }]
  }], () => [{
    type: FilterService
  }, {
    type: ColumnComponent2
  }, {
    type: ContextService
  }, {
    type: SizingOptionsService
  }], {
    showOperators: [{
      type: Input
    }],
    column: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    valueField: [{
      type: Input
    }]
  });
})();
var BooleanFilterCellComponent = class _BooleanFilterCellComponent extends BooleanFilterComponent {
  cd;
  /**
   * @hidden
   */
  size = "medium";
  subs;
  constructor(filterService, ctx, cd, sizingService) {
    super(filterService, ctx);
    this.cd = cd;
    this.subs = sizingService.changes.subscribe((size) => this.size = size);
  }
  ngOnDestroy() {
    this.subs && this.subs.unsubscribe();
  }
  localizationChange() {
    super.localizationChange();
    this.cd.markForCheck();
  }
  /**
   * @hidden
   */
  get columnLabel() {
    const localizationMsg = this.ctx.localization.get("booleanFilterCellLabel") || "";
    const columnName = this.column.title || this.column.field;
    return replaceMessagePlaceholder(localizationMsg, "columnName", columnName);
  }
  static ɵfac = function BooleanFilterCellComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BooleanFilterCellComponent)(ɵɵdirectiveInject(FilterService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(SizingOptionsService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _BooleanFilterCellComponent,
    selectors: [["kendo-grid-boolean-filter-cell"]],
    features: [ɵɵInheritDefinitionFeature],
    decls: 2,
    vars: 12,
    consts: [[3, "column", "filter", "showOperators", "defaultOperator"], ["kendoFilterInput", "", "kendoGridFocusable", "", "textField", "text", "valueField", "value", 3, "size", "columnLabel", "defaultItem", "data", "popupSettings", "valuePrimitive", "value"]],
    template: function BooleanFilterCellComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "kendo-grid-filter-wrapper-cell", 0);
        ɵɵelement(1, "kendo-dropdownlist", 1);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("column", ctx.column)("filter", ctx.filter)("showOperators", false)("defaultOperator", ctx.operator);
        ɵɵadvance();
        ɵɵproperty("size", ctx.size)("columnLabel", ctx.columnLabel)("defaultItem", ctx.defaultItem)("data", ctx.items)("popupSettings", ɵɵpureFunction0(11, _c105))("valuePrimitive", true)("value", ctx.currentFilter == null ? null : ctx.currentFilter.value);
      }
    },
    dependencies: [FilterCellWrapperComponent, DropDownListComponent, FilterInputDirective, FocusableDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BooleanFilterCellComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-boolean-filter-cell",
      template: `
        <kendo-grid-filter-wrapper-cell
            [column]="column"
            [filter]="filter"
            [showOperators]="false"
            [defaultOperator]="operator">
            <kendo-dropdownlist
                kendoFilterInput
                kendoGridFocusable
                [size]="size"
                [columnLabel]="columnLabel"
                [defaultItem]="defaultItem"
                [data]="items"
                textField="text"
                valueField="value"
                [popupSettings]="{ width: 'auto' }"
                [valuePrimitive]="true"
                [value]="currentFilter?.value">
            </kendo-dropdownlist>
        </kendo-grid-filter-wrapper-cell>
    `,
      standalone: true,
      imports: [FilterCellWrapperComponent, DropDownListComponent, FilterInputDirective, FocusableDirective]
    }]
  }], () => [{
    type: FilterService
  }, {
    type: ContextService
  }, {
    type: ChangeDetectorRef
  }, {
    type: SizingOptionsService
  }], null);
})();
var DateFilterCellComponent = class _DateFilterCellComponent extends DateFilterComponent {
  ctx;
  /**
   * Determines if the drop-down filter operators are displayed.
   * @type {boolean}
   * @default true
   */
  showOperators = true;
  subs;
  constructor(filterService, ctx, sizingService) {
    super(filterService, ctx);
    this.ctx = ctx;
    this.subs = sizingService.changes.subscribe((size) => this.size = size);
  }
  ngOnDestroy() {
    this.subs && this.subs.unsubscribe();
  }
  /**
   * @hidden
   */
  messageFor(key) {
    return this.ctx.localization.get(key);
  }
  /**
   * @hidden
   */
  get columnLabel() {
    const localizationMsg = this.ctx.localization.get("filterInputLabel") || "";
    const columnName = this.column.title || this.column.field;
    return replaceMessagePlaceholder(localizationMsg, "columnName", columnName);
  }
  static ɵfac = function DateFilterCellComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DateFilterCellComponent)(ɵɵdirectiveInject(FilterService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(SizingOptionsService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DateFilterCellComponent,
    selectors: [["kendo-grid-date-filter-cell"]],
    inputs: {
      showOperators: "showOperators"
    },
    features: [ɵɵInheritDefinitionFeature],
    decls: 3,
    vars: 19,
    consts: [[3, "column", "filter", "operators", "defaultOperator", "showOperators"], ["kendoFilterInput", "", "kendoGridFocusable", "", 3, "columnLabel", "value", "format", "size", "formatPlaceholder", "placeholder", "activeView", "bottomView", "topView", "min", "max", "weekNumber"], [3, "toggle", "today"]],
    template: function DateFilterCellComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "kendo-grid-filter-wrapper-cell", 0)(1, "kendo-datepicker", 1);
        ɵɵelement(2, "kendo-datepicker-messages", 2);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵproperty("column", ctx.column)("filter", ctx.filter)("operators", ctx.operators)("defaultOperator", ctx.operator)("showOperators", ctx.showOperators);
        ɵɵadvance();
        ɵɵproperty("columnLabel", ctx.columnLabel)("value", ctx.currentFilter == null ? null : ctx.currentFilter.value)("format", ctx.format)("size", ctx.size)("formatPlaceholder", ctx.formatPlaceholder)("placeholder", ctx.placeholder)("activeView", ctx.activeView)("bottomView", ctx.bottomView)("topView", ctx.topView)("min", ctx.min)("max", ctx.max)("weekNumber", ctx.weekNumber);
        ɵɵadvance();
        ɵɵproperty("toggle", ctx.messageFor("filterDateToggle"))("today", ctx.messageFor("filterDateToday"));
      }
    },
    dependencies: [FilterCellWrapperComponent, DatePickerComponent, FilterInputDirective, FocusableDirective, DatePickerCustomMessagesComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateFilterCellComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-date-filter-cell",
      template: `
        <kendo-grid-filter-wrapper-cell
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [showOperators]="showOperators"
        >
            <kendo-datepicker
                kendoFilterInput
                kendoGridFocusable
                [columnLabel]="columnLabel"
                [value]="currentFilter?.value"
                [format]="format"
                [size]="size"
                [formatPlaceholder]="formatPlaceholder"
                [placeholder]="placeholder"
                [activeView]="activeView"
                [bottomView]="bottomView"
                [topView]="topView"
                [min]="min"
                [max]="max"
                [weekNumber]="weekNumber">
                <kendo-datepicker-messages
                    [toggle]="messageFor('filterDateToggle')"
                    [today]="messageFor('filterDateToday')"
                ></kendo-datepicker-messages>
            </kendo-datepicker>
        </kendo-grid-filter-wrapper-cell>
    `,
      standalone: true,
      imports: [FilterCellWrapperComponent, DatePickerComponent, FilterInputDirective, FocusableDirective, DatePickerCustomMessagesComponent]
    }]
  }], () => [{
    type: FilterService
  }, {
    type: ContextService
  }, {
    type: SizingOptionsService
  }], {
    showOperators: [{
      type: Input
    }]
  });
})();
var StringFilterCellComponent = class _StringFilterCellComponent extends StringFilterComponent {
  /**
   * Sets the delay time in milliseconds before the filter value is submitted.
   * A value of `0` means no delay.
   * @type {number}
   * @default 500
   */
  filterDelay = 500;
  /**
   * Determines if the drop-down filter operators are displayed.
   * @type {boolean}
   * @default true
   */
  showOperators = true;
  /**
   * The placeholder text for the filter input.
   * @type {string}
   */
  placeholder;
  subs;
  constructor(filterService, ctx, sizingService) {
    super(filterService, ctx);
    this.subs = sizingService.changes.subscribe((size) => this.size = size);
  }
  ngOnDestroy() {
    if (this.subs) {
      this.subs.unsubscribe();
    }
  }
  /**
   * @hidden
   */
  get columnLabel() {
    const localizationMsg = this.ctx.localization.get("filterInputLabel") || "";
    const columnName = this.column.title || this.column.field;
    return replaceMessagePlaceholder(localizationMsg, "columnName", columnName);
  }
  static ɵfac = function StringFilterCellComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _StringFilterCellComponent)(ɵɵdirectiveInject(FilterService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(SizingOptionsService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _StringFilterCellComponent,
    selectors: [["kendo-grid-string-filter-cell"]],
    inputs: {
      filterDelay: "filterDelay",
      showOperators: "showOperators",
      placeholder: "placeholder"
    },
    features: [ɵɵInheritDefinitionFeature],
    decls: 2,
    vars: 10,
    consts: [[3, "column", "filter", "operators", "defaultOperator", "showOperators"], ["kendoGridFocusable", "", "kendoFilterInput", "", 3, "size", "columnLabel", "filterDelay", "placeholder", "ngModel"]],
    template: function StringFilterCellComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "kendo-grid-filter-wrapper-cell", 0);
        ɵɵelement(1, "kendo-textbox", 1);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("column", ctx.column)("filter", ctx.filter)("operators", ctx.operators)("defaultOperator", ctx.operator)("showOperators", ctx.showOperators);
        ɵɵadvance();
        ɵɵproperty("size", ctx.size)("columnLabel", ctx.columnLabel)("filterDelay", ctx.filterDelay)("placeholder", ctx.placeholder)("ngModel", (ctx.currentFilter == null ? null : ctx.currentFilter.value) ?? null);
      }
    },
    dependencies: [FilterCellWrapperComponent, TextBoxComponent, FocusableDirective, FilterInputDirective, FormsModule, NgControlStatus, NgModel],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StringFilterCellComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-string-filter-cell",
      template: `
        <kendo-grid-filter-wrapper-cell
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [showOperators]="showOperators">
            <kendo-textbox
                [size]="size"
                kendoGridFocusable
                kendoFilterInput
                [columnLabel]="columnLabel"
                [filterDelay]="filterDelay"
                [placeholder]="placeholder"
                [ngModel]="currentFilter?.value ?? null"
            ></kendo-textbox>
        </kendo-grid-filter-wrapper-cell>
    `,
      standalone: true,
      imports: [FilterCellWrapperComponent, TextBoxComponent, FocusableDirective, FilterInputDirective, FormsModule]
    }]
  }], () => [{
    type: FilterService
  }, {
    type: ContextService
  }, {
    type: SizingOptionsService
  }], {
    filterDelay: [{
      type: Input
    }],
    showOperators: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }]
  });
})();
var NumericFilterCellComponent = class _NumericFilterCellComponent extends NumericFilterComponent {
  ctx;
  /**
   * Sets the delay time in milliseconds before the filter value is submitted.
   * A value of `0` means no delay.
   * @type {number}
   * @default 500
   */
  filterDelay = 500;
  /**
   * Determines if the drop-down filter operators are displayed.
   * @type {boolean}
   * @default true
   */
  showOperators = true;
  /**
   * The placeholder text for the filter input.
   * @type {string}
   */
  placeholder;
  subs;
  constructor(filterService, ctx, sizingService) {
    super(filterService, ctx);
    this.ctx = ctx;
    this.subs = sizingService.changes.subscribe((size) => this.size = size);
  }
  ngOnDestroy() {
    this.subs && this.subs.unsubscribe();
  }
  /**
   * @hidden
   */
  messageFor(key) {
    return this.ctx.localization.get(key);
  }
  /**
   * @hidden
   */
  get columnLabel() {
    const localizationMsg = this.ctx.localization.get("filterInputLabel") || "";
    const columnName = this.column.title || this.column.field;
    return replaceMessagePlaceholder(localizationMsg, "columnName", columnName);
  }
  static ɵfac = function NumericFilterCellComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NumericFilterCellComponent)(ɵɵdirectiveInject(FilterService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(SizingOptionsService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _NumericFilterCellComponent,
    selectors: [["kendo-grid-numeric-filter-cell"]],
    inputs: {
      filterDelay: "filterDelay",
      showOperators: "showOperators",
      placeholder: "placeholder"
    },
    features: [ɵɵInheritDefinitionFeature],
    decls: 3,
    vars: 19,
    consts: [[3, "column", "filter", "operators", "defaultOperator", "showOperators"], ["kendoGridFocusable", "", "kendoFilterInput", "", 3, "columnLabel", "filterDelay", "autoCorrect", "value", "format", "decimals", "spinners", "min", "max", "size", "step", "placeholder"], [3, "increment", "decrement"]],
    template: function NumericFilterCellComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "kendo-grid-filter-wrapper-cell", 0)(1, "kendo-numerictextbox", 1);
        ɵɵelement(2, "kendo-numerictextbox-messages", 2);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵproperty("column", ctx.column)("filter", ctx.filter)("operators", ctx.operators)("defaultOperator", ctx.operator)("showOperators", ctx.showOperators);
        ɵɵadvance();
        ɵɵproperty("columnLabel", ctx.columnLabel)("filterDelay", ctx.filterDelay)("autoCorrect", true)("value", ctx.currentFilter == null ? null : ctx.currentFilter.value)("format", ctx.format)("decimals", ctx.decimals)("spinners", ctx.spinners)("min", ctx.min)("max", ctx.max)("size", ctx.size)("step", ctx.step)("placeholder", ctx.placeholder);
        ɵɵadvance();
        ɵɵproperty("increment", ctx.messageFor("filterNumericIncrement"))("decrement", ctx.messageFor("filterNumericDecrement"));
      }
    },
    dependencies: [FilterCellWrapperComponent, NumericTextBoxComponent, FocusableDirective, FilterInputDirective, NumericTextBoxCustomMessagesComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NumericFilterCellComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-numeric-filter-cell",
      template: `
        <kendo-grid-filter-wrapper-cell
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [showOperators]="showOperators"
        >
            <kendo-numerictextbox
                kendoGridFocusable
                kendoFilterInput
                [columnLabel]="columnLabel"
                [filterDelay]="filterDelay"
                [autoCorrect]="true"
                [value]="currentFilter?.value"
                [format]="format"
                [decimals]="decimals"
                [spinners]="spinners"
                [min]="min"
                [max]="max"
                [size]="size"
                [step]="step"
                [placeholder]="placeholder">
                <kendo-numerictextbox-messages
                    [increment]="messageFor('filterNumericIncrement')"
                    [decrement]="messageFor('filterNumericDecrement')"
                ></kendo-numerictextbox-messages>
            </kendo-numerictextbox>
        </kendo-grid-filter-wrapper-cell>
    `,
      standalone: true,
      imports: [FilterCellWrapperComponent, NumericTextBoxComponent, FocusableDirective, FilterInputDirective, NumericTextBoxCustomMessagesComponent]
    }]
  }], () => [{
    type: FilterService
  }, {
    type: ContextService
  }, {
    type: SizingOptionsService
  }], {
    filterDelay: [{
      type: Input
    }],
    showOperators: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }]
  });
})();
var filterComponentFactory = (type) => ({
  "boolean": BooleanFilterCellComponent,
  "date": DateFilterCellComponent,
  "numeric": NumericFilterCellComponent,
  "text": StringFilterCellComponent
})[type];
var FilterCellHostDirective = class _FilterCellHostDirective extends FilterHostDirective {
  constructor(host) {
    super(host);
  }
  componentType() {
    if (!isNullOrEmptyString2(this.column.filter)) {
      return filterComponentFactory(this.column.filter);
    }
    return StringFilterCellComponent;
  }
  static ɵfac = function FilterCellHostDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FilterCellHostDirective)(ɵɵdirectiveInject(ViewContainerRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FilterCellHostDirective,
    selectors: [["", "kendoFilterCellHost", ""]],
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterCellHostDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoFilterCellHost]",
      standalone: true
    }]
  }], () => [{
    type: ViewContainerRef
  }], null);
})();
var FilterCellComponent = class _FilterCellComponent {
  hostRole = "gridcell";
  column;
  get filter() {
    return this._filter;
  }
  set filter(value2) {
    this._filter = cloneFilters(value2);
  }
  size = "medium";
  _templateContext = {};
  _filter;
  get templateContext() {
    this._templateContext.column = this.column;
    this._templateContext.filter = this.filter;
    this._templateContext["$implicit"] = this.filter;
    return this._templateContext;
  }
  get hasTemplate() {
    return isPresent7(this.column.filterCellTemplateRef);
  }
  get isFilterable() {
    return isPresent7(this.column) && !isNullOrEmptyString2(this.column.field) && this.column.filterable;
  }
  static ɵfac = function FilterCellComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FilterCellComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _FilterCellComponent,
    selectors: [["", "kendoGridFilterCell", ""]],
    hostVars: 1,
    hostBindings: function FilterCellComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("role", ctx.hostRole);
      }
    },
    inputs: {
      column: "column",
      filter: "filter",
      size: "size"
    },
    attrs: _c174,
    decls: 1,
    vars: 1,
    consts: [["kendoFilterCellHost", "", 3, "column", "filter"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
    template: function FilterCellComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵconditionalCreate(0, FilterCellComponent_Conditional_0_Template, 2, 1);
      }
      if (rf & 2) {
        ɵɵconditional(ctx.isFilterable ? 0 : -1);
      }
    },
    dependencies: [FilterCellHostDirective, NgTemplateOutlet],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterCellComponent, [{
    type: Component,
    args: [{
      selector: "[kendoGridFilterCell]",
      template: `
        @if (isFilterable) {
          @switch (hasTemplate) {
            @case (false) {
              <ng-container kendoFilterCellHost [column]="column" [filter]="filter"></ng-container>
            }
            @case (true) {
              @if (column.filterCellTemplateRef) {
                <ng-template
                  [ngTemplateOutlet]="column.filterCellTemplateRef"
                  [ngTemplateOutletContext]="templateContext">
                </ng-template>
              }
            }
          }
        }
        `,
      standalone: true,
      imports: [FilterCellHostDirective, NgTemplateOutlet]
    }]
  }], null, {
    hostRole: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    column: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    size: [{
      type: Input
    }]
  });
})();
var FilterRowComponent = class _FilterRowComponent {
  ctx;
  columnInfoService;
  columns = [];
  filter;
  groups = [];
  detailTemplate;
  logicalRowIndex;
  lockedColumnsCount;
  filterRowClass = true;
  constructor(ctx, columnInfoService) {
    this.ctx = ctx;
    this.columnInfoService = columnInfoService;
  }
  addStickyStyles(column) {
    const sticky = column.sticky ? this.columnInfoService.stickyColumnsStyles(column) : null;
    return __spreadValues(__spreadValues({}, sticky), column.filterStyle);
  }
  filterLabel(column) {
    const localizationMsg = this.ctx.localization.get("filterInputLabel") || "";
    const columnName = column.title || column.field;
    return replaceMessagePlaceholder(localizationMsg, "columnName", columnName);
  }
  getLogicalColIndex(columnIndex) {
    const colIndex = this.lockedColumnsCount + columnIndex;
    return this.detailTemplate?.templateRef ? colIndex + 1 : colIndex;
  }
  get isStacked() {
    return this.ctx.grid?.isStacked;
  }
  static ɵfac = function FilterRowComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FilterRowComponent)(ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ColumnInfoService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _FilterRowComponent,
    selectors: [["", "kendoGridFilterRow", ""]],
    hostVars: 2,
    hostBindings: function FilterRowComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-filter-row", ctx.filterRowClass);
      }
    },
    inputs: {
      columns: "columns",
      filter: "filter",
      groups: "groups",
      detailTemplate: "detailTemplate",
      logicalRowIndex: "logicalRowIndex",
      lockedColumnsCount: "lockedColumnsCount"
    },
    attrs: _c184,
    decls: 5,
    vars: 1,
    consts: [["role", "presentation", 1, "k-table-td", "k-group-cell", "k-table-group-td"], ["role", "presentation", 1, "k-table-td", "k-hierarchy-cell"], ["kendoGridFilterCell", "", "kendoGridLogicalCell", "", 1, "k-table-td", 3, "k-grid-header-sticky", "ngStyle", "ngClass", "column", "filter", "logicalRowIndex", "logicalColIndex"], ["kendoGridFilterCell", "", "kendoGridLogicalCell", "", 1, "k-table-td", 3, "ngStyle", "ngClass", "column", "filter", "logicalRowIndex", "logicalColIndex"]],
    template: function FilterRowComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵrepeaterCreate(0, FilterRowComponent_For_1_Template, 1, 0, "td", 0, ɵɵrepeaterTrackByIdentity);
        ɵɵconditionalCreate(2, FilterRowComponent_Conditional_2_Template, 1, 0, "td", 1);
        ɵɵrepeaterCreate(3, FilterRowComponent_For_4_Template, 1, 9, "td", 2, ɵɵrepeaterTrackByIdentity);
      }
      if (rf & 2) {
        ɵɵrepeater(ctx.groups);
        ɵɵadvance(2);
        ɵɵconditional((ctx.detailTemplate == null ? null : ctx.detailTemplate.templateRef) && !ctx.isStacked ? 2 : -1);
        ɵɵadvance();
        ɵɵrepeater(ctx.columns);
      }
    },
    dependencies: [FilterCellComponent, LogicalCellDirective, NgStyle, NgClass],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterRowComponent, [{
    type: Component,
    args: [{
      selector: "[kendoGridFilterRow]",
      template: `
        @for (g of groups; track g) {
          <td
            class="k-table-td k-group-cell k-table-group-td"
            role="presentation">
          </td>
        }
        @if (detailTemplate?.templateRef && !isStacked) {
          <td
            class="k-table-td k-hierarchy-cell"
            role="presentation">
          </td>
        }
        @for (column of columns; track column; let columnIndex = $index) {
          <td
            class="k-table-td"
            [class.k-grid-header-sticky]="column.sticky"
            [ngStyle]="addStickyStyles(column)"
            [ngClass]="column.filterClass"
            [attr.aria-label]="filterLabel($any(column))"
            kendoGridFilterCell
            [column]="$any(column)"
            [filter]="filter"
            kendoGridLogicalCell
            [logicalRowIndex]="logicalRowIndex"
            [logicalColIndex]="getLogicalColIndex(columnIndex)"
          ></td>
        }
        `,
      standalone: true,
      imports: [FilterCellComponent, LogicalCellDirective, NgStyle, NgClass]
    }]
  }], () => [{
    type: ContextService
  }, {
    type: ColumnInfoService
  }], {
    columns: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    groups: [{
      type: Input
    }],
    detailTemplate: [{
      type: Input
    }],
    logicalRowIndex: [{
      type: Input
    }],
    lockedColumnsCount: [{
      type: Input
    }],
    filterRowClass: [{
      type: HostBinding,
      args: ["class.k-filter-row"]
    }]
  });
})();
var ColumnMenuService = class _ColumnMenuService {
  /**
   * @hidden
   */
  menuTabbingService;
  /**
   * @hidden
   */
  closeMenu = new EventEmitter();
  /**
   * @hidden
   */
  column;
  /**
   * @hidden
   */
  sort;
  /**
   * @hidden
   */
  filter;
  /**
   * @hidden
   */
  sortable;
  /**
   * @hidden
   */
  columnMenuContainer;
  /**
   * @hidden
   */
  constructor(menuTabbingService) {
    this.menuTabbingService = menuTabbingService;
  }
  /**
   * Closes the column menu.
   */
  close() {
    this.closeMenu.emit();
  }
  static ɵfac = function ColumnMenuService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColumnMenuService)(ɵɵinject(MenuTabbingService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ColumnMenuService,
    factory: _ColumnMenuService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuService, [{
    type: Injectable
  }], () => [{
    type: MenuTabbingService
  }], null);
})();
var ColumnListKeyboardNavigation = class _ColumnListKeyboardNavigation {
  renderer;
  items;
  activeIndex = 0;
  constructor(renderer) {
    this.renderer = renderer;
  }
  next() {
    this.toggle(this.activeIndex, false);
    this.activeIndex = Math.min(this.activeIndex + 1, this.items.length - 1);
    this.toggle(this.activeIndex, true);
  }
  prev() {
    this.toggle(this.activeIndex, false);
    this.activeIndex = Math.max(this.activeIndex - 1, 0);
    this.toggle(this.activeIndex, true);
  }
  toggle(index, active) {
    const element = this.items[index]?.hostElement.nativeElement.closest(".k-column-list-item");
    element && this.renderer.setAttribute(element, "tabindex", active ? "0" : "-1");
    active && element?.focus({
      preventScroll: true
    });
  }
  toggleCheckedState() {
    this.items[this.activeIndex].hostElement.nativeElement.closest(".k-column-list-item").firstElementChild.click();
  }
  static ɵfac = function ColumnListKeyboardNavigation_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColumnListKeyboardNavigation)(ɵɵinject(Renderer2));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ColumnListKeyboardNavigation,
    factory: _ColumnListKeyboardNavigation.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnListKeyboardNavigation, [{
    type: Injectable
  }], () => [{
    type: Renderer2
  }], null);
})();
var ColumnListComponent = class _ColumnListComponent {
  element;
  ngZone;
  renderer;
  listNavigationService;
  cdr;
  columnInfoService;
  adaptiveGridService;
  ctx;
  className = true;
  get listSizeMd() {
    return !this.ctx?.grid?.isActionSheetExpanded;
  }
  get listSizeLg() {
    return this.ctx?.grid?.isActionSheetExpanded;
  }
  reset = new EventEmitter();
  apply = new EventEmitter();
  columnChange = new EventEmitter();
  set columns(value2) {
    this.listNavigationService.items = this.checkboxes?.toArray();
    this._columns = value2.filter((column) => column.includeInChooser !== false);
  }
  get columns() {
    return this._columns;
  }
  get checkedCheckboxesLength() {
    return this.columns?.filter((column) => column.currentlyChecked).length;
  }
  filteredColumns = [];
  autoSync = true;
  showSelectAll = false;
  isFiltered = false;
  ariaLabel;
  allowHideAll = false;
  applyText;
  resetText;
  selectAllText;
  isLast;
  isExpanded;
  service;
  filterable = false;
  checkboxes;
  get columnCheckboxes() {
    if (this.showSelectAll) {
      return this.checkboxes?.toArray().slice(1);
    }
    return this.checkboxes?.toArray();
  }
  get lockedColumnCheckboxes() {
    return this.columnCheckboxes?.filter((checkbox, index) => this.filteredColumns[index]?.locked);
  }
  get unlockedColumnCheckboxes() {
    return this.columnCheckboxes?.filter((checkbox, index) => !this.filteredColumns[index]?.locked);
  }
  get checkedCheckboxes() {
    if (this.showSelectAll && !this.isFiltered) {
      return this.checkboxes?.toArray().slice(1).filter((checkbox) => checkbox.checkedState).length;
    }
    return this.checkboxes?.filter((checkbox) => checkbox.checkedState).length;
  }
  resetButton;
  applyButton;
  filterInput;
  _columns;
  domSubscriptions = new Subscription();
  lastDisabledCheckbox;
  handledKeys = [Keys.ArrowDown, Keys.ArrowUp, Keys.Space];
  constructor(element, ngZone, renderer, listNavigationService, cdr, columnInfoService, adaptiveGridService, ctx) {
    this.element = element;
    this.ngZone = ngZone;
    this.renderer = renderer;
    this.listNavigationService = listNavigationService;
    this.cdr = cdr;
    this.columnInfoService = columnInfoService;
    this.adaptiveGridService = adaptiveGridService;
    this.ctx = ctx;
  }
  ngOnInit() {
    if (!this.element) {
      return;
    }
    this.ngZone.runOutsideAngular(() => {
      this.domSubscriptions.add(this.renderer.listen(this.element.nativeElement, "click", (e) => {
        if (e.target.classList.contains("k-checkbox")) {
          const label = e.target.closest(".k-column-list-item");
          this.setTabindex(label);
        }
      }));
      this.domSubscriptions.add(this.renderer.listen(this.element.nativeElement, "keydown", this.onKeydown));
    });
  }
  ngAfterViewInit() {
    this.ngZone.onStable.pipe(take(1)).subscribe(() => {
      this.listNavigationService.items = this.checkboxes.toArray();
      if (this.adaptiveGridService?.viewType !== "columnMenu") {
        this.listNavigationService.toggle(0, true);
      }
      this.updateDisabled();
    });
    if (this.ctx?.grid?.isActionSheetExpanded) {
      this.domSubscriptions.add(this.adaptiveGridService.animationEnd.subscribe(() => {
        this.listNavigationService.toggle(0, true);
      }));
    }
  }
  ngOnChanges(changes) {
    if (!this.service) {
      return;
    }
    if (changes["isLast"] && this.isLast) {
      this.service.menuTabbingService.lastFocusable = this.applyButton?.nativeElement;
    }
    if (changes["isExpanded"] && this.isExpanded && this.isLast && this.applyButton) {
      this.service.menuTabbingService.lastFocusable = this.applyButton.nativeElement;
    }
  }
  onSelectAllCheckboxChange(checkedState) {
    if (!checkedState && !this.allowHideAll) {
      const columnsToKeep = [];
      if (!columnsToKeep.length) {
        const unlockedColumns = this.filteredColumns.filter((c) => !c.locked);
        if (unlockedColumns.length > 0) {
          columnsToKeep.push(unlockedColumns[0]);
        }
      }
      if (this.lockedColumnCheckboxes.length > 0) {
        const lockedColumns = this.filteredColumns.filter((c) => c.locked);
        if (lockedColumns.length > 0) {
          columnsToKeep.unshift(lockedColumns[0]);
        }
      }
      this.filteredColumns.forEach((column) => {
        const isChecked = columnsToKeep.indexOf(column) >= 0;
        column.currentlyChecked = isChecked;
      });
    } else {
      this.filteredColumns.forEach((column) => {
        column.currentlyChecked = checkedState;
      });
    }
    if (this.autoSync) {
      const changedColumns = this.filteredColumns.filter((column) => column.initiallyChecked !== column.currentlyChecked);
      if (changedColumns.length > 0) {
        changedColumns.forEach((column) => {
          column.hidden = !column.currentlyChecked;
          column.initiallyChecked = column.currentlyChecked;
        });
        this.ngZone.run(() => {
          this.columnChange.emit(changedColumns);
        });
      }
    }
    this.filteredColumns = [...this.filteredColumns];
    this.updateDisabled();
  }
  ngOnDestroy() {
    this.domSubscriptions.unsubscribe();
  }
  cancelChanges() {
    this.columns.forEach((column) => {
      column.currentlyChecked = !column.hidden;
      column.initiallyChecked = !column.hidden;
    });
    this.filteredColumns.forEach((column) => {
      column.currentlyChecked = !column.hidden;
      column.initiallyChecked = !column.hidden;
    });
    this.updateDisabled();
    this.reset.emit();
  }
  applyChanges() {
    const changed = [];
    this.columns.forEach((column) => {
      if (column.initiallyChecked !== column.currentlyChecked) {
        column.hidden = !column.currentlyChecked;
        changed.push(column);
      }
    });
    this.updateDisabled();
    this.apply.emit(changed);
    if (changed.length) {
      this.cdr.markForCheck();
      this.columnInfoService?.changeVisibility(changed);
    }
  }
  focusActiveColumn(e) {
    const keyboardEvent = e;
    if (keyboardEvent.shiftKey) {
      this.listNavigationService.toggle(this.listNavigationService.activeIndex, true);
      e.preventDefault();
    }
  }
  onTab(e) {
    if (this.isLast) {
      e.preventDefault();
      if (this.service) {
        this.service.menuTabbingService.firstFocusable.focus();
      } else if (this.filterable) {
        this.filterInput?.input.nativeElement.focus();
      } else {
        this.listNavigationService.toggle(this.listNavigationService.activeIndex, true);
      }
    }
  }
  onKeydown = (e) => {
    const code = normalizeKeys(e);
    if (this.handledKeys.includes(code)) {
      e.preventDefault();
    }
    if (code === "Tab" && e.shiftKey) {
      this.resetButton?.nativeElement.focus();
      e.preventDefault();
    }
    if (code === "Tab" && !e.shiftKey && this.autoSync) {
      if (this.filterable) {
        this.filterInput?.input.nativeElement.focus();
      }
      e.preventDefault();
    }
    if (code === "Tab" && e.shiftKey && this.autoSync && this.filterable) {
      this.filterInput?.input.nativeElement.focus();
      e.preventDefault();
    }
    if (code === "Tab" && !e.shiftKey && !this.autoSync) {
      this.applyButton?.nativeElement.focus();
      e.preventDefault();
    }
    if (code === "Tab" && e.shiftKey) {
      if (!this.autoSync && this.filterable && e.target.matches(".k-column-list-item")) {
        this.filterInput?.input.nativeElement.focus();
        e.preventDefault();
        return;
      }
      this.ngZone.run(() => {
        if (e.target.matches(".k-column-list-item")) {
          e.preventDefault();
          this.resetButton?.nativeElement.focus();
        }
      });
    }
    if (code === Keys.ArrowDown) {
      this.listNavigationService.next();
    } else if (code === Keys.ArrowUp) {
      this.listNavigationService.prev();
    } else if (code === Keys.Space && e.target.classList.contains("k-column-list-item")) {
      this.listNavigationService.toggleCheckedState();
    }
  };
  updateDisabled() {
    const hasLockedColumns = this.columns.filter((c) => c.locked).length > 0;
    if (this.allowHideAll && !hasLockedColumns) {
      return;
    }
    const currentlyCheckedUnlockedColumns = this.columns.filter((column) => !column.locked && column.currentlyChecked).length;
    const shouldEnforceMinimumColumns = hasLockedColumns || !this.allowHideAll;
    if (shouldEnforceMinimumColumns && currentlyCheckedUnlockedColumns === 1) {
      this.disableFirstUnlockedCheckedCheckbox();
    } else {
      this.enableLastDisabledColumn();
    }
  }
  disableFirstUnlockedCheckedCheckbox() {
    const index = this.filteredColumns.filter((c) => !c.locked).findIndex((column) => column.currentlyChecked);
    const firstUnlockedCheckedCheckbox = this.unlockedColumnCheckboxes[index];
    this.setDisabledState(firstUnlockedCheckedCheckbox, true);
    this.lastDisabledCheckbox = firstUnlockedCheckedCheckbox;
  }
  enableLastDisabledColumn() {
    this.setDisabledState(this.lastDisabledCheckbox, false);
    this.lastDisabledCheckbox = null;
  }
  setDisabledState(checkbox, disabled) {
    if (!checkbox) {
      return;
    }
    if (checkbox.disabled !== disabled) {
      this.ngZone.runOutsideAngular(() => {
        checkbox.disabled = disabled;
        const checkboxElement = checkbox.hostElement.nativeElement;
        const parentElement = checkboxElement.parentElement;
        if (disabled) {
          this.renderer.addClass(parentElement, "k-disabled");
          this.renderer.setAttribute(parentElement, "aria-disabled", "true");
        } else {
          this.renderer.removeClass(parentElement, "k-disabled");
          this.renderer.removeAttribute(parentElement, "aria-disabled");
        }
      });
    }
  }
  onCheckboxChange(checkedState, column, _index) {
    column.currentlyChecked = checkedState;
    if (this.autoSync) {
      column.hidden = !checkedState;
      column.initiallyChecked = checkedState;
      this.columnChange.emit([column]);
    }
    this.updateDisabled();
  }
  setTabindex(labelElement) {
    if (!labelElement) {
      return;
    }
    const allLabels = this.checkboxes.map((checkbox) => checkbox.hostElement.nativeElement.parentElement);
    allLabels.forEach((label) => {
      const input = label.querySelector("input");
      input.classList.remove("k-focus");
      this.renderer.removeAttribute(label, "tabindex");
    });
    this.renderer.setAttribute(labelElement, "tabindex", "0");
    labelElement.focus();
    this.listNavigationService.activeIndex = allLabels.indexOf(labelElement);
  }
  static ɵfac = function ColumnListComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColumnListComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ColumnListKeyboardNavigation), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ColumnInfoService, 8), ɵɵdirectiveInject(AdaptiveGridService, 8), ɵɵdirectiveInject(ContextService, 8));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColumnListComponent,
    selectors: [["kendo-grid-columnlist"]],
    viewQuery: function ColumnListComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(CheckBoxComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.checkboxes = _t);
      }
    },
    hostVars: 6,
    hostBindings: function ColumnListComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-column-list-wrapper", ctx.className)("k-column-list-md", ctx.listSizeMd)("k-column-list-lg", ctx.listSizeLg);
      }
    },
    inputs: {
      columns: "columns",
      filteredColumns: "filteredColumns",
      autoSync: "autoSync",
      showSelectAll: "showSelectAll",
      isFiltered: "isFiltered",
      ariaLabel: "ariaLabel",
      allowHideAll: "allowHideAll",
      applyText: "applyText",
      resetText: "resetText",
      selectAllText: "selectAllText",
      isLast: "isLast",
      isExpanded: "isExpanded",
      service: "service",
      filterable: "filterable"
    },
    outputs: {
      reset: "reset",
      apply: "apply",
      columnChange: "columnChange"
    },
    features: [ɵɵProvidersFeature([ColumnListKeyboardNavigation]), ɵɵNgOnChangesFeature],
    decls: 4,
    vars: 2,
    consts: [["checkbox", ""], ["role", "listbox", "aria-multiselectable", "true", 1, "k-column-list"], ["role", "option", 1, "k-column-list-item"], [3, "checkedStateChange", "inputAttributes", "tabindex", "checkedState"], [1, "k-checkbox-label"]],
    template: function ColumnListComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 1);
        ɵɵconditionalCreate(1, ColumnListComponent_Conditional_1_Template, 5, 5, "label", 2);
        ɵɵrepeaterCreate(2, ColumnListComponent_For_3_Template, 5, 6, "label", 2, ɵɵrepeaterTrackByIdentity);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵattribute("aria-label", ctx.ariaLabel);
        ɵɵadvance();
        ɵɵconditional(ctx.showSelectAll ? 1 : -1);
        ɵɵadvance();
        ɵɵrepeater(ctx.filteredColumns);
      }
    },
    dependencies: [CheckBoxComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnListComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-columnlist",
      providers: [ColumnListKeyboardNavigation],
      template: `
        <div
          class="k-column-list"
          role="listbox"
          aria-multiselectable="true"
          [attr.aria-label]="ariaLabel">
          @if (showSelectAll) {
            <label
              class='k-column-list-item'
              role="option">
              <kendo-checkbox
                #checkbox
                [inputAttributes]="{'data-index': '0'}"
                [tabindex]="-1"
                [checkedState]="checkedCheckboxesLength === columns.length"
                (checkedStateChange)="onSelectAllCheckboxChange($event)"
              ></kendo-checkbox>
              <span class="k-checkbox-label">{{ selectAllText }}</span>
            </label>
          }
          @for (column of filteredColumns; track column; let index = $index) {
            <label
              class='k-column-list-item'
              role="option">
              <kendo-checkbox
                #checkbox
                [inputAttributes]="{'data-index': index.toString()}"
                [tabindex]="-1"
                [checkedState]="column.currentlyChecked"
                (checkedStateChange)="onCheckboxChange($event, column, index)"
              ></kendo-checkbox>
              <span class="k-checkbox-label">{{ column.displayTitle }}</span>
            </label>
          }
        </div>
        `,
      standalone: true,
      imports: [CheckBoxComponent]
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NgZone
  }, {
    type: Renderer2
  }, {
    type: ColumnListKeyboardNavigation
  }, {
    type: ChangeDetectorRef
  }, {
    type: ColumnInfoService,
    decorators: [{
      type: Optional
    }]
  }, {
    type: AdaptiveGridService,
    decorators: [{
      type: Optional
    }]
  }, {
    type: ContextService,
    decorators: [{
      type: Optional
    }]
  }], {
    className: [{
      type: HostBinding,
      args: ["class.k-column-list-wrapper"]
    }],
    listSizeMd: [{
      type: HostBinding,
      args: ["class.k-column-list-md"]
    }],
    listSizeLg: [{
      type: HostBinding,
      args: ["class.k-column-list-lg"]
    }],
    reset: [{
      type: Output
    }],
    apply: [{
      type: Output
    }],
    columnChange: [{
      type: Output
    }],
    columns: [{
      type: Input
    }],
    filteredColumns: [{
      type: Input
    }],
    autoSync: [{
      type: Input
    }],
    showSelectAll: [{
      type: Input
    }],
    isFiltered: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input
    }],
    allowHideAll: [{
      type: Input
    }],
    applyText: [{
      type: Input
    }],
    resetText: [{
      type: Input
    }],
    selectAllText: [{
      type: Input
    }],
    isLast: [{
      type: Input
    }],
    isExpanded: [{
      type: Input
    }],
    service: [{
      type: Input
    }],
    filterable: [{
      type: Input
    }],
    checkboxes: [{
      type: ViewChildren,
      args: [CheckBoxComponent]
    }]
  });
})();
var ColumnChooserContentComponent = class _ColumnChooserContentComponent {
  cdr;
  columnInfoService;
  ctx;
  resetButton;
  applyButton;
  columnList;
  filterInput;
  filterable = true;
  showSelectAll = true;
  showCheckedCount = true;
  allowHideAll = false;
  autoSync = false;
  actionsClass = "k-actions k-actions-stretched k-actions-horizontal";
  closeOnReset = true;
  set columns(value2) {
    this._columns = value2;
  }
  get columns() {
    return this._columns;
  }
  isLast;
  isExpanded;
  service;
  close = new EventEmitter();
  get selectedItemsText() {
    const count2 = this.columnList?.checkedCheckboxesLength || 0;
    const localizedMessage = this.messageFor("columnChooserSelectedColumnsCount");
    return replaceMessagePlaceholder(localizedMessage, "selectedColumnsCount", count2.toString());
  }
  get actionSheetOpened() {
    return this.ctx?.grid?.isActionSheetExpanded;
  }
  searchIcon = searchIcon;
  checkIcon = checkIcon;
  arrowRotateCcwIcon = arrowRotateCcwIcon;
  applyText;
  resetText;
  filteredColumns = [];
  isFiltered = false;
  _columns = [];
  constructor(cdr, columnInfoService, ctx) {
    this.cdr = cdr;
    this.columnInfoService = columnInfoService;
    this.ctx = ctx;
  }
  ngOnInit() {
    this.applyText = this.ctx?.localization.get("columnsApply");
    this.resetText = this.ctx?.localization.get("columnsReset");
  }
  ngAfterViewInit() {
    this.filteredColumns = this.columnInfoService?.leafNamedColumns.filter((column) => {
      if (column.includeInChooser !== false) {
        column.initiallyChecked = column.currentlyChecked = !column.hidden;
        return true;
      }
      return false;
    });
    this.cdr.detectChanges();
  }
  ngAfterViewChecked() {
    this.columnList.resetButton = this.resetButton;
    this.columnList.applyButton = this.applyButton;
    this.columnList.filterInput = this.filterInput;
  }
  onFilter(value2) {
    this.isFiltered = value2.length > 0;
    this.showSelectAll = !this.isFiltered;
    const filterDescriptor = {
      field: "displayTitle",
      operator: "contains",
      value: value2
    };
    this.filteredColumns = filterBy(this.columnInfoService?.leafNamedColumns, filterDescriptor);
    this.cdr.detectChanges();
    this.columnList.listNavigationService.activeIndex = 0;
    this.columnList.listNavigationService.items = this.columnList.checkboxes?.toArray();
  }
  messageFor = (token) => this.ctx?.localization.get(token);
  onChange(changed) {
    this.cdr.markForCheck();
    this.columnInfoService?.changeVisibility(changed);
  }
  applyChanges() {
    this.columnList.applyChanges();
    this.close.emit();
  }
  cancelChanges() {
    this.columnList.cancelChanges();
    if (this.closeOnReset) {
      this.close.emit();
    }
  }
  onTab(e) {
    if (e.key === "Tab" && !e.shiftKey) {
      this.columnList.listNavigationService.toggle(this.columnList.listNavigationService.activeIndex, true);
      e.preventDefault();
    }
    if (e.key === "Tab" && e.shiftKey && !this.service) {
      this.columnList.resetButton?.nativeElement.focus();
      e.preventDefault();
    }
  }
  onApplyButtonKeydown(e) {
    if (e.key === "Tab") {
      this.columnList.focusActiveColumn(e);
    }
  }
  static ɵfac = function ColumnChooserContentComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColumnChooserContentComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ColumnInfoService, 8), ɵɵdirectiveInject(ContextService, 8));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColumnChooserContentComponent,
    selectors: [["kendo-grid-column-chooser-content"]],
    viewQuery: function ColumnChooserContentComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c124, 5)(_c218, 5)(_c224, 5)(_c234, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.resetButton = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.applyButton = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columnList = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.filterInput = _t.first);
      }
    },
    inputs: {
      filterable: "filterable",
      showSelectAll: "showSelectAll",
      showCheckedCount: "showCheckedCount",
      allowHideAll: "allowHideAll",
      autoSync: "autoSync",
      actionsClass: "actionsClass",
      closeOnReset: "closeOnReset",
      columns: "columns",
      isLast: "isLast",
      isExpanded: "isExpanded",
      service: "service"
    },
    outputs: {
      close: "close"
    },
    decls: 7,
    vars: 17,
    consts: [["columnList", ""], ["filterInput", ""], ["applyButton", ""], ["resetButton", ""], [1, "k-filter-menu"], [1, "k-filter-menu-container"], [1, "k-searchbox", 3, "kendoEventsOutsideAngular", "scope"], [3, "columnChange", "columns", "filteredColumns", "ariaLabel", "showSelectAll", "isLast", "isFiltered", "filterable", "isExpanded", "service", "applyText", "resetText", "selectAllText", "autoSync", "allowHideAll"], [1, "k-filter-selected-items"], [3, "ngClass"], [1, "k-searchbox", 3, "valueChange", "kendoEventsOutsideAngular", "scope"], ["kendoPrefixTemplate", ""], [3, "name", "svgIcon"], ["kendoButton", "", "type", "button", "icon", "check", "themeColor", "primary", 3, "click", "keydown", "svgIcon"], ["kendoButton", "", "type", "button", "icon", "reset", 3, "keydown.tab", "click", "svgIcon"]],
    template: function ColumnChooserContentComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "form", 4)(1, "div", 5);
        ɵɵconditionalCreate(2, ColumnChooserContentComponent_Conditional_2_Template, 3, 4, "kendo-textbox", 6);
        ɵɵelementStart(3, "kendo-grid-columnlist", 7, 0);
        ɵɵlistener("columnChange", function ColumnChooserContentComponent_Template_kendo_grid_columnlist_columnChange_3_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onChange($event));
        });
        ɵɵelementEnd();
        ɵɵconditionalCreate(5, ColumnChooserContentComponent_Conditional_5_Template, 2, 1, "div", 8);
        ɵɵconditionalCreate(6, ColumnChooserContentComponent_Conditional_6_Template, 7, 5, "div", 9);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵadvance(2);
        ɵɵconditional(ctx.filterable ? 2 : -1);
        ɵɵadvance();
        ɵɵproperty("columns", ctx.columns)("filteredColumns", ctx.filteredColumns)("ariaLabel", ctx.messageFor("columns"))("showSelectAll", ctx.showSelectAll)("isLast", ctx.isLast)("isFiltered", ctx.isFiltered)("filterable", ctx.filterable)("isExpanded", ctx.isExpanded)("service", ctx.service)("applyText", ctx.messageFor("columnsApply"))("resetText", ctx.messageFor("columnsReset"))("selectAllText", ctx.messageFor("columnChooserSelectAll"))("autoSync", ctx.autoSync)("allowHideAll", ctx.allowHideAll);
        ɵɵadvance(2);
        ɵɵconditional(ctx.showCheckedCount ? 5 : -1);
        ɵɵadvance();
        ɵɵconditional(!ctx.autoSync && !ctx.actionSheetOpened ? 6 : -1);
      }
    },
    dependencies: [NgClass, ButtonComponent, ColumnListComponent, TextBoxComponent, PrefixTemplateDirective, IconWrapperComponent, EventsOutsideAngularDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnChooserContentComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-column-chooser-content",
      template: `
            <form class="k-filter-menu">
              <div class="k-filter-menu-container">
                @if (filterable) {
                  <kendo-textbox
                    #filterInput
                    class="k-searchbox"
                    (valueChange)="onFilter($event)"
                    [kendoEventsOutsideAngular]="{'keydown': onTab}"
                    [scope]="this"
                    >
                    <ng-template kendoPrefixTemplate>
                      <kendo-icon-wrapper
                        [name]="'search'"
                        [svgIcon]="searchIcon">
                      </kendo-icon-wrapper>
                    </ng-template>
                  </kendo-textbox>
                }
                <kendo-grid-columnlist
                  #columnList
                  [columns]="columns"
                  [filteredColumns]="filteredColumns"
                  [ariaLabel]="messageFor('columns')"
                  [showSelectAll]="showSelectAll"
                  [isLast]="isLast"
                  [isFiltered]="isFiltered"
                  [filterable]="filterable"
                  [isExpanded]="isExpanded"
                  [service]="service"
                  [applyText]="messageFor('columnsApply')"
                  [resetText]="messageFor('columnsReset')"
                  [selectAllText]="messageFor('columnChooserSelectAll')"
                  [autoSync]="autoSync"
                  [allowHideAll]="allowHideAll"
                  (columnChange)="onChange($event)"
                  >
                </kendo-grid-columnlist>
                @if (showCheckedCount) {
                  <div class="k-filter-selected-items">
                    {{selectedItemsText}}
                  </div>
                }
                @if (!autoSync && !actionSheetOpened) {
                  <div [ngClass]="actionsClass">
                    <button
                      #applyButton
                      kendoButton
                      type="button"
                      icon="check"
                      [svgIcon]="checkIcon"
                      themeColor="primary"
                      (click)="applyChanges()"
                      (keydown)="onApplyButtonKeydown($event)"
                    >{{ applyText }}</button>
                    <button
                      #resetButton
                      kendoButton
                      type="button"
                      icon="reset"
                      (keydown.tab)="columnList.onTab($event)"
                      [svgIcon]="arrowRotateCcwIcon"
                      (click)="cancelChanges()"
                    >{{ resetText }}</button>
                  </div>
                }
              </div>
            </form>
            `,
      standalone: true,
      imports: [NgClass, ButtonComponent, ColumnListComponent, TextBoxComponent, PrefixTemplateDirective, IconWrapperComponent, EventsOutsideAngularDirective]
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: ColumnInfoService,
    decorators: [{
      type: Optional
    }]
  }, {
    type: ContextService,
    decorators: [{
      type: Optional
    }]
  }], {
    resetButton: [{
      type: ViewChild,
      args: ["resetButton"]
    }],
    applyButton: [{
      type: ViewChild,
      args: ["applyButton"]
    }],
    columnList: [{
      type: ViewChild,
      args: ["columnList"]
    }],
    filterInput: [{
      type: ViewChild,
      args: ["filterInput"]
    }],
    filterable: [{
      type: Input
    }],
    showSelectAll: [{
      type: Input
    }],
    showCheckedCount: [{
      type: Input
    }],
    allowHideAll: [{
      type: Input
    }],
    autoSync: [{
      type: Input
    }],
    actionsClass: [{
      type: Input
    }],
    closeOnReset: [{
      type: Input
    }],
    columns: [{
      type: Input
    }],
    isLast: [{
      type: Input
    }],
    isExpanded: [{
      type: Input
    }],
    service: [{
      type: Input
    }],
    close: [{
      type: Output
    }]
  });
})();
var ColumnChooserComponent = class _ColumnChooserComponent {
  ctx;
  columnInfoService;
  popupService;
  ngZone;
  renderer;
  changeDetector;
  /**
   * Specifies if the changes in the visibility of the column will be immediately applied.
   *
   * @default false
   */
  autoSync = false;
  /**
   * Specifies if the column chooser displays a search box.
   *
   * @default true
   */
  filterable = true;
  /**
   * Specifies if the column chooser displays a select all checkbox.
   *
   * @default true
   */
  showSelectAll = true;
  /**
   * Specifies if all columns can be hidden.
   *
   * @default true
   */
  allowHideAll = true;
  anchor;
  get columns() {
    return this.columnInfoService.leafNamedColumns;
  }
  columnsIcon = columnsIcon;
  popupRef;
  popupId;
  closeClick;
  escapeListener;
  constructor(ctx, columnInfoService, popupService, ngZone, renderer, changeDetector) {
    this.ctx = ctx;
    this.columnInfoService = columnInfoService;
    this.popupService = popupService;
    this.ngZone = ngZone;
    this.renderer = renderer;
    this.changeDetector = changeDetector;
  }
  ngOnDestroy() {
    this.close();
  }
  /**
   * @hidden
   */
  messageFor = (token) => this.ctx.localization.get(token);
  /**
   * @hidden
   */
  toggle(anchor, template) {
    if (!this.popupRef) {
      const direction = this.ctx.localization.rtl ? "right" : "left";
      this.popupRef = this.popupService.open({
        anchor: anchor.element,
        content: template,
        positionMode: "absolute",
        anchorAlign: {
          vertical: "bottom",
          horizontal: direction
        },
        popupAlign: {
          vertical: "top",
          horizontal: direction
        }
      });
      const popupElement = this.popupRef?.popupElement;
      if (popupElement) {
        const popupId = `k-${guid()}`;
        const popupAriaElement = popupElement.querySelector(".k-popup");
        this.ngZone.runOutsideAngular(() => {
          this.escapeListener = this.renderer.listen(popupAriaElement, "keydown", (e) => {
            if (e.code === Keys.Escape) {
              this.close(true);
            }
          });
        });
        this.renderer.setAttribute(popupElement, "dir", this.ctx.localization.rtl ? "rtl" : "ltr");
        this.renderer.setAttribute(popupAriaElement, "id", popupId);
        this.renderer.setAttribute(popupAriaElement, "role", "dialog");
        this.popupId = popupId;
      }
      if (!isDocumentAvailable()) {
        return;
      }
      this.ngZone.runOutsideAngular(() => this.closeClick = this.renderer.listen("document", "click", ({
        target
      }) => {
        if (!closest5(target, (node) => node === this.popupRef.popupElement || node === anchor.element)) {
          this.ngZone.run(() => {
            this.close();
          });
        }
      }));
    } else {
      this.close();
    }
  }
  /**
   * @hidden
   */
  onChange(changed) {
    this.changeDetector.markForCheck();
    this.columnInfoService.changeVisibility(changed);
  }
  /**
   * @hidden
   */
  close(focusAnchor = false) {
    if (this.popupRef) {
      this.popupRef.close();
      this.popupRef = null;
      this.changeDetector.markForCheck();
      this.escapeListener?.();
    }
    this.detachClose();
    focusAnchor && this.anchor.element.focus();
  }
  detachClose() {
    if (this.closeClick) {
      this.closeClick();
      this.closeClick = null;
    }
  }
  static ɵfac = function ColumnChooserComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColumnChooserComponent)(ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ColumnInfoService), ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColumnChooserComponent,
    selectors: [["kendo-grid-column-chooser"]],
    viewQuery: function ColumnChooserComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c154, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.anchor = _t.first);
      }
    },
    inputs: {
      autoSync: "autoSync",
      filterable: "filterable",
      showSelectAll: "showSelectAll",
      allowHideAll: "allowHideAll"
    },
    decls: 4,
    vars: 5,
    consts: [["anchor", ""], ["template", ""], ["kendoButton", "", "type", "button", "fillMode", "flat", "icon", "columns", 3, "click", "svgIcon"], [3, "close", "columns", "autoSync", "filterable", "showSelectAll", "closeOnReset", "isLast", "allowHideAll"]],
    template: function ColumnChooserComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "button", 2, 0);
        ɵɵlistener("click", function ColumnChooserComponent_Template_button_click_0_listener() {
          ɵɵrestoreView(_r1);
          const anchor_r2 = ɵɵreference(1);
          const template_r3 = ɵɵreference(3);
          return ɵɵresetView(ctx.toggle(anchor_r2, template_r3));
        });
        ɵɵelementEnd();
        ɵɵtemplate(2, ColumnChooserComponent_ng_template_2_Template, 1, 7, "ng-template", null, 1, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        ɵɵproperty("svgIcon", ctx.columnsIcon);
        ɵɵattribute("title", ctx.messageFor("columns"))("aria-haspopup", "dialog")("aria-expanded", !!ctx.popupRef)("aria-controls", !!ctx.popupRef ? ctx.popupId : void 0);
      }
    },
    dependencies: [ButtonComponent, ColumnChooserContentComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnChooserComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-column-chooser",
      template: `
        <button #anchor
            kendoButton
            type="button"
            (click)="toggle(anchor, template)"
            fillMode="flat"
            [attr.title]="messageFor('columns')"
            icon="columns"
            [svgIcon]="columnsIcon"
            [attr.aria-haspopup]="'dialog'"
            [attr.aria-expanded]="!!(popupRef)"
            [attr.aria-controls]="!!(popupRef) ? popupId : undefined"></button>
        <ng-template #template>
            <kendo-grid-column-chooser-content
                [columns]="columns"
                [autoSync]="autoSync"
                [filterable]="filterable"
                [showSelectAll]="showSelectAll"
                [closeOnReset]="false"
                [isLast]="true"
                [allowHideAll]="allowHideAll"
                (close)="close(true)"
            >
            </kendo-grid-column-chooser-content>
        </ng-template>
    `,
      standalone: true,
      imports: [ButtonComponent, ColumnChooserContentComponent]
    }]
  }], () => [{
    type: ContextService
  }, {
    type: ColumnInfoService
  }, {
    type: PopupService
  }, {
    type: NgZone
  }, {
    type: Renderer2
  }, {
    type: ChangeDetectorRef
  }], {
    autoSync: [{
      type: Input
    }],
    filterable: [{
      type: Input
    }],
    showSelectAll: [{
      type: Input
    }],
    allowHideAll: [{
      type: Input
    }],
    anchor: [{
      type: ViewChild,
      args: ["anchor"]
    }]
  });
})();
var ToolbarToolName = {
  edit: "edit",
  save: "save",
  remove: "remove",
  cancel: "cancel",
  add: "add",
  columns: "columns",
  excelExport: "excelExport",
  pdfExport: "pdfExport",
  aiAssistant: "aiAssistant"
};
var ICONS_MAP = {
  edit: {
    svgIcon: pencilIcon,
    icon: "pencil"
  },
  save: {
    svgIcon: saveIcon,
    icon: "save"
  },
  cancel: {
    svgIcon: cancelIcon,
    icon: "cancel"
  },
  remove: {
    svgIcon: trashIcon,
    icon: "trash"
  },
  add: {
    svgIcon: plusIcon,
    icon: "plus"
  },
  excelExport: {
    svgIcon: fileExcelIcon,
    icon: "file-excel"
  },
  pdfExport: {
    svgIcon: filePdfIcon,
    icon: "file-pdf"
  },
  columns: {
    svgIcon: columnsIcon,
    icon: "columns"
  },
  aiAssistant: {
    svgIcon: sparklesIcon,
    icon: "sparkles"
  }
};
var ToolbarToolBase = class _ToolbarToolBase {
  host;
  commandName;
  ctx;
  zone;
  cdr;
  clickSub = new Subscription();
  constructor(host, commandName, ctx, zone, cdr) {
    this.host = host;
    this.commandName = commandName;
    this.ctx = ctx;
    this.zone = zone;
    this.cdr = cdr;
  }
  ngOnInit() {
    this.clickSub = this.host.click.subscribe((e) => this.onClick(e));
    const hasIcon = isPresent(this.host.toolbarOptions.icon) && this.host.toolbarOptions.icon !== "" && isPresent(this.host.overflowOptions.icon) && this.host.overflowOptions.icon !== "";
    const hasSvgIcon = isPresent(this.host.toolbarOptions.svgIcon) && isPresent(this.host.overflowOptions.svgIcon);
    if (!hasIcon) {
      this.host.icon = ICONS_MAP[this.commandName].icon;
    }
    if (!hasSvgIcon) {
      this.host.svgIcon = ICONS_MAP[this.commandName].svgIcon;
    }
  }
  ngAfterViewInit() {
    const hasText = isPresent(this.host.text);
    if (!hasText) {
      this.zone.runOutsideAngular(() => {
        setTimeout(() => {
          const messageKey = this.commandName === ToolbarToolName.columns ? "columns" : `${this.commandName}ToolbarToolText`;
          this.host.text = this.ctx.localization.get(messageKey);
          this.zone.run(() => {
            this.cdr.markForCheck();
          });
        });
      });
    }
  }
  ngOnDestroy() {
    this.clickSub.unsubscribe();
  }
  onClick(_e) {
  }
  get buttonElement() {
    return this.host.getButton();
  }
  static ɵfac = function ToolbarToolBase_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ToolbarToolBase)(ɵɵdirectiveInject(ToolBarButtonComponent), ɵɵdirectiveInject("command"), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ToolbarToolBase
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ToolbarToolBase, [{
    type: Directive,
    args: [{}]
  }], () => [{
    type: ToolBarButtonComponent
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: ["command"]
    }]
  }, {
    type: ContextService
  }, {
    type: NgZone
  }, {
    type: ChangeDetectorRef
  }], null);
})();
var incrementingId$3 = 0;
var ColumnChooserToolbarDirective = class _ColumnChooserToolbarDirective extends ToolbarToolBase {
  renderer;
  popupSerivce;
  host;
  ctx;
  zone;
  refresh;
  adaptiveGridService;
  columnInfoService;
  /**
   * When `true`, changes to column visibility apply immediately.
   *
   * @default false
   */
  autoSync = false;
  /**
   * When `true`, enables the hiding of all columns.
   *
   * @default true
   */
  allowHideAll = true;
  /**
   * When `true`, enables the columns' filtering.
   *
   * @default true
   */
  filterable = true;
  /**
   * When `true`, displays a select all checkbox.
   *
   * @default true
   */
  showSelectAll = true;
  /**
   * @hidden
   */
  get columns() {
    return this.columnInfoService.leafNamedColumns;
  }
  popupRef;
  subs = new Subscription();
  actionSheetCloseSub;
  nextId = incrementingId$3++;
  constructor(renderer, popupSerivce, host, ctx, zone, refresh, adaptiveGridService, columnInfoService, cdr) {
    super(host, ToolbarToolName.columns, ctx, zone, cdr);
    this.renderer = renderer;
    this.popupSerivce = popupSerivce;
    this.host = host;
    this.ctx = ctx;
    this.zone = zone;
    this.refresh = refresh;
    this.adaptiveGridService = adaptiveGridService;
    this.columnInfoService = columnInfoService;
  }
  ngOnInit() {
    this.subs.add(this.host.click.subscribe((e) => this.onClick(e)));
    const hasToolbarIcon = isPresent(this.host.toolbarOptions.icon) && this.host.toolbarOptions.icon !== "";
    const hasOverflowIcon = isPresent(this.host.overflowOptions.icon) && this.host.overflowOptions.icon !== "";
    const hasIcon = hasToolbarIcon && hasOverflowIcon;
    const hasSvgIcon = isPresent(this.host.toolbarOptions.svgIcon) && isPresent(this.host.overflowOptions.svgIcon);
    if (!hasIcon) {
      this.host.icon = "columns";
    }
    if (!hasSvgIcon) {
      this.host.svgIcon = columnsIcon;
    }
  }
  ngAfterViewInit() {
    super.ngAfterViewInit();
    this.zone.onStable.pipe(take(1)).subscribe(() => {
      this.buttonElement?.setAttribute("aria-haspopup", "dialog");
      this.buttonElement?.setAttribute("aria-expanded", "false");
      this.buttonElement?.setAttribute("title", this.ctx.localization.get("columns"));
    });
    this.subs.add(this.refresh.onRefresh.pipe(filter((tool) => tool === this.host)).subscribe((tool) => {
      if (tool.overflows && this.popupRef) {
        this.popupRef.close();
      }
    }));
  }
  ngOnDestroy() {
    super.ngOnDestroy();
    this.subs.unsubscribe();
    if (this.actionSheetCloseSub) {
      this.actionSheetCloseSub.unsubscribe();
      this.actionSheetCloseSub = null;
    }
  }
  /**
   * @hidden
   */
  onClick(e) {
    e.preventDefault();
    if (this.ctx.grid.adaptiveMode === "auto" && this.adaptiveGridService.windowSize !== "large") {
      if (!this.ctx.grid.isActionSheetExpanded) {
        this.adaptiveGridService.viewType = "columnChooserToolbarTool";
        this.adaptiveGridService.columns = this.columns;
        this.ctx.grid.adaptiveRenderer.actionSheet.toggle(true);
        this.host.selected = true;
        this.actionSheetCloseSub = this.ctx.grid.adaptiveRenderer.actionSheet.collapse.subscribe(() => this.host.selected = false);
      }
    } else {
      this.togglePopup();
    }
  }
  togglePopup() {
    if (!this.popupRef) {
      const direction = this.ctx.localization.rtl ? "right" : "left";
      this.popupRef = this.popupSerivce.open({
        anchor: this.buttonElement,
        content: ColumnChooserContentComponent,
        positionMode: "absolute",
        anchorAlign: {
          vertical: "bottom",
          horizontal: direction
        },
        popupAlign: {
          vertical: "top",
          horizontal: direction
        }
      });
      this.adaptiveGridService.popupRef = this.popupRef;
      const popupElement = this.popupRef.popupElement;
      const popupId = `k-column-chooser-tool-${this.nextId}-popup`;
      const popupAriaElement = popupElement.querySelector(".k-popup");
      this.zone.runOutsideAngular(() => {
        this.renderer.listen(popupAriaElement, "keydown", (e) => {
          if (e.key === "Escape") {
            this.closePopup(true);
          }
        });
      });
      this.renderer.setAttribute(popupElement, "dir", this.ctx.localization.rtl ? "rtl" : "ltr");
      this.renderer.setAttribute(popupAriaElement, "id", popupId);
      this.renderer.setAttribute(popupAriaElement, "role", "dialog");
      this.buttonElement?.setAttribute("aria-expanded", "true");
      this.buttonElement?.setAttribute("aria-controls", popupId);
      this.host.selected = true;
      const columnChooserContent = this.popupRef.content.instance;
      columnChooserContent.columnInfoService = this.columnInfoService;
      columnChooserContent.ctx = this.ctx;
      columnChooserContent.showSelectAll = this.showSelectAll;
      columnChooserContent.filterable = this.filterable;
      columnChooserContent.isLast = true;
      columnChooserContent.autoSync = this.autoSync;
      columnChooserContent.allowHideAll = this.allowHideAll;
      columnChooserContent.applyText = this.ctx.localization.get("columnsApply");
      columnChooserContent.resetText = this.ctx.localization.get("columnsReset");
      columnChooserContent.columns = this.columns;
      columnChooserContent.filteredColumns = this.columnInfoService?.leafNamedColumns.filter((column) => {
        if (column.includeInChooser !== false) {
          column.initiallyChecked = column.currentlyChecked = !column.hidden;
          return true;
        }
        return false;
      });
      this.subs.add(this.popupRef.popup.instance.anchorViewportLeave.subscribe(() => {
        this.closePopup(true);
      }));
      this.subs.add(columnChooserContent.columnList.apply.subscribe((changed) => {
        if (changed.length) {
          this.cdr.markForCheck();
          this.columnInfoService.changeVisibility(changed);
        }
        this.closePopup();
      }));
      this.zone.runOutsideAngular(() => this.renderer.listen("document", "click", ({
        target
      }) => {
        if (this.popupRef && !closest(target, (node) => node === this.popupRef.popupElement || node === this.buttonElement)) {
          this.zone.run(() => {
            this.closePopup();
          });
        }
      }));
    } else {
      this.closePopup();
    }
  }
  closePopup(focusAnchor = false) {
    this.popupRef.close();
    this.popupRef = null;
    this.buttonElement?.setAttribute("aria-expanded", "false");
    this.buttonElement?.removeAttribute("aria-controls");
    this.host.selected = false;
    focusAnchor && this.buttonElement?.focus({
      preventScroll: true
    });
  }
  static ɵfac = function ColumnChooserToolbarDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColumnChooserToolbarDirective)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(ToolBarButtonComponent), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(RefreshService), ɵɵdirectiveInject(AdaptiveGridService), ɵɵdirectiveInject(ColumnInfoService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ColumnChooserToolbarDirective,
    selectors: [["", "kendoGridColumnChooserTool", ""]],
    inputs: {
      autoSync: "autoSync",
      allowHideAll: "allowHideAll",
      filterable: "filterable",
      showSelectAll: "showSelectAll"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnChooserToolbarDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridColumnChooserTool]",
      standalone: true
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: PopupService
  }, {
    type: ToolBarButtonComponent
  }, {
    type: ContextService
  }, {
    type: NgZone
  }, {
    type: RefreshService
  }, {
    type: AdaptiveGridService
  }, {
    type: ColumnInfoService
  }, {
    type: ChangeDetectorRef
  }], {
    autoSync: [{
      type: Input
    }],
    allowHideAll: [{
      type: Input
    }],
    filterable: [{
      type: Input
    }],
    showSelectAll: [{
      type: Input
    }]
  });
})();
var ColumnMenuItemBase = class _ColumnMenuItemBase {
  /**
   * Represents the [`ColumnMenuService`]({% slug api_grid_columnmenuservice %}) class.
   * This input is required.
   */
  service;
  hostClass = true;
  ngOnInit() {
    if (isDevMode() && !this.service) {
      throw new Error(ColumnMenuErrorMessages.serviceInput);
    }
  }
  /**
   * @hidden
   */
  close() {
    this.service.close();
  }
  static ɵfac = function ColumnMenuItemBase_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColumnMenuItemBase)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColumnMenuItemBase,
    selectors: [["kendo-grid-column-menu-item-base"]],
    hostVars: 2,
    hostBindings: function ColumnMenuItemBase_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-columnmenu-item-wrapper", ctx.hostClass);
      }
    },
    inputs: {
      service: "service"
    },
    decls: 0,
    vars: 0,
    template: function ColumnMenuItemBase_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuItemBase, [{
    type: Component,
    args: [{
      selector: "kendo-grid-column-menu-item-base",
      template: ``
    }]
  }], null, {
    service: [{
      type: Input
    }],
    hostClass: [{
      type: HostBinding,
      args: ["class.k-columnmenu-item-wrapper"]
    }]
  });
})();
var hasFilter = (settings, column) => settings.filter !== false && column.field && column.filterable;
var hasSort = (settings, column) => settings.sort !== false && column.field && column.sortable;
var hasLock = (settings, column) => settings.lock && column.lockable && !(column.parent && !column.parent.isSpanColumn);
var hasStick = (settings, column) => settings.stick && column.stickable && !(column.parent && !column.parent.isSpanColumn);
var hasPosition = (settings, column) => settings.setColumnPosition && (column.stickable || column.lockable) && !(column.parent && !column.parent.isSpanColumn);
var hasColumnChooser = (settings) => settings.columnChooser !== false;
var hasAutoSizeColumn = (settings) => settings.autoSizeColumn;
var hasAutoSizeAllColumns = (settings) => settings.autoSizeAllColumns;
var autoSizeColumn = (grid, service, column) => {
  column ? grid.autoFitColumn(column) : grid.autoFitColumns();
  service.close();
};
var hasItems = (settings, column) => hasAutoSizeAllColumns(settings) || hasColumnChooser(settings) || hasFilter(settings, column) || hasAutoSizeColumn(settings) || hasLock(settings, column) || hasSort(settings, column);
var ColumnMenuItemContentTemplateDirective = class _ColumnMenuItemContentTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function ColumnMenuItemContentTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColumnMenuItemContentTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ColumnMenuItemContentTemplateDirective,
    selectors: [["", "kendoGridColumnMenuItemContentTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuItemContentTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridColumnMenuItemContentTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var DEFAULTS = {
  allowUnsort: true,
  mode: "single",
  showIndexes: true,
  initialDirection: "asc",
  multiSortKey: "none"
};
var normalize$1 = (...settings) => Object.assign({}, DEFAULTS, ...settings);
var ColumnMenuItemComponent = class _ColumnMenuItemComponent {
  ngZone;
  ctx;
  adaptiveGridService;
  element;
  /**
   * @hidden
   */
  sortAscSmallIcon = sortAscSmallIcon;
  /**
   * @hidden
   */
  sortDescSmallIcon = sortDescSmallIcon;
  /**
   * Fires when the item is clicked.
   */
  itemClick = new EventEmitter();
  /**
   * Fires when the content expands.
   */
  expand = new EventEmitter();
  /**
   * Fires when the content collapses.
   */
  collapse = new EventEmitter();
  /**
   * Specifies the name of the font icon to render within the item.
   */
  icon;
  /**
   * Specifies the SVG icon to render within the item.
   */
  svgIcon;
  /**
   * @hidden
   */
  indicatorIcon;
  /**
   * Specifies the item text.
   */
  text;
  /**
   * Specifies if the item is selected.
   */
  selected;
  /**
   * Specifies if the item is disabled.
   */
  disabled;
  /**
   * Specifies if the item is expanded.
   */
  expanded;
  /**
   * @hidden
   */
  focused;
  /**
   * Represents the [ColumnMenuService]({% slug api_grid_columnmenuservice %}) class.
   * Required to include the item in the column menu keyboard navigation sequence.
   */
  service;
  /**
   * @hidden
   */
  column;
  contentTemplate;
  contentState = "collapsed";
  contentId;
  chevronUpIcon = chevronUpIcon;
  chevronDownIcon = chevronDownIcon;
  chevronRightIcon = chevronRightIcon;
  filterIcon = filterIcon;
  /**
   * @hidden
   */
  get hasFilters() {
    return filtersByField(this.ctx.grid.filter, this.column.field).length > 0;
  }
  get expandedIcon() {
    if (this.ctx.grid.isActionSheetExpanded) {
      return "arrow-chevron-right";
    }
    return this.expanded ? "arrow-chevron-up" : "arrow-chevron-down";
  }
  get expandedSvgIcon() {
    if (this.ctx.grid.isActionSheetExpanded) {
      return this.chevronRightIcon;
    }
    return this.expanded ? this.chevronUpIcon : this.chevronDownIcon;
  }
  constructor(ngZone, ctx, adaptiveGridService, element) {
    this.ngZone = ngZone;
    this.ctx = ctx;
    this.adaptiveGridService = adaptiveGridService;
    this.element = element;
  }
  ngAfterViewInit() {
    this.ngZone.onStable.pipe(take(1)).subscribe(() => {
      this.contentTemplate && (this.contentId = `k-${guid()}`);
    });
  }
  ngOnChanges(changes) {
    if (changes.expanded) {
      this.updateContentState();
    }
  }
  /**
   * @hidden
   */
  sortDescriptor(field) {
    return this.ctx.grid.sort.find((item) => item.field === field) || {
      field
    };
  }
  /**
   * @hidden
   */
  showSortNumbering(column) {
    const {
      showIndexes
    } = normalize$1(this.ctx.grid.sortable);
    return showIndexes && this.ctx.grid.sort && this.ctx.grid.sort.filter(({
      dir
    }) => isPresent7(dir)).length > 1 && this.sortOrder(column.field) > 0;
  }
  /**
   * @hidden
   */
  sortOrder(field) {
    return this.ctx.grid.sort.filter(({
      dir
    }) => isPresent7(dir)).findIndex((x) => x.field === field) + 1;
  }
  /**
   * @hidden
   */
  onClick(e) {
    this.itemClick.emit(e);
    if (this.contentTemplate) {
      if (!this.ctx.grid.isActionSheetExpanded) {
        this.expanded = !this.expanded;
        this.updateContentState();
      }
      if (this.expanded) {
        this.expand.emit();
      } else {
        this.collapse.emit();
      }
    }
  }
  updateContentState() {
    this.contentState = this.expanded ? "expanded" : "collapsed";
  }
  static ɵfac = function ColumnMenuItemComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColumnMenuItemComponent)(ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(AdaptiveGridService), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColumnMenuItemComponent,
    selectors: [["kendo-grid-columnmenu-item"]],
    contentQueries: function ColumnMenuItemComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, ColumnMenuItemContentTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.contentTemplate = _t.first);
      }
    },
    inputs: {
      icon: "icon",
      svgIcon: "svgIcon",
      indicatorIcon: "indicatorIcon",
      text: "text",
      selected: "selected",
      disabled: "disabled",
      expanded: "expanded",
      focused: "focused",
      service: "service",
      column: "column"
    },
    outputs: {
      itemClick: "itemClick",
      expand: "expand",
      collapse: "collapse"
    },
    features: [ɵɵNgOnChangesFeature],
    decls: 4,
    vars: 1,
    consts: [["content", ""], [1, "k-expander"], [3, "ngTemplateOutlet"], ["role", "button", 1, "k-columnmenu-item", 3, "click", "keydown.enter"], [3, "name", "svgIcon"], [1, "k-columnmenu-indicators"], ["name", "filter", 1, "k-columnmenu-indicators", 3, "svgIcon"], [1, "k-spacer"], [1, "k-expander-indicator"], [1, "k-columnmenu-item-content", 3, "overflow"], [1, "k-sort-index"], [1, "k-columnmenu-item-content"]],
    template: function ColumnMenuItemComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵconditionalCreate(0, ColumnMenuItemComponent_Conditional_0_Template, 2, 1, "div", 1)(1, ColumnMenuItemComponent_Conditional_1_Template, 8, 15);
        ɵɵtemplate(2, ColumnMenuItemComponent_ng_template_2_Template, 8, 15, "ng-template", null, 0, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        ɵɵconditional(ctx.contentTemplate ? 0 : 1);
      }
    },
    dependencies: [IconWrapperComponent, NgTemplateOutlet],
    encapsulation: 2,
    data: {
      animation: [trigger("state", [state("collapsed", style({
        display: "none"
      })), state("expanded", style({
        display: "block"
      })), transition("collapsed => expanded", [style({
        height: "0px",
        display: "block"
      }), animate("100ms ease-in", style({
        height: "*"
      }))]), transition("expanded => collapsed", [style({
        height: "*"
      }), animate("100ms ease-in", style({
        height: "0px"
      }))])])]
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuItemComponent, [{
    type: Component,
    args: [{
      animations: [trigger("state", [state("collapsed", style({
        display: "none"
      })), state("expanded", style({
        display: "block"
      })), transition("collapsed => expanded", [style({
        height: "0px",
        display: "block"
      }), animate("100ms ease-in", style({
        height: "*"
      }))]), transition("expanded => collapsed", [style({
        height: "*"
      }), animate("100ms ease-in", style({
        height: "0px"
      }))])])],
      selector: "kendo-grid-columnmenu-item",
      template: `
        @if (contentTemplate) {
          <div class="k-expander">
            <ng-container [ngTemplateOutlet]="content"></ng-container>
          </div>
        } @else {
          <div
            class="k-columnmenu-item"
            (click)="onClick($event)"
            (keydown.enter)="onClick($event)"
            [class.k-selected]="selected"
            [class.k-disabled]="disabled"
            [class.k-focus]="focused"
            role="button"
            [attr.aria-expanded]="expanded"
            [attr.aria-controls]="expanded ? contentId : undefined">
            @if (icon || svgIcon) {
              <kendo-icon-wrapper
                [name]="icon"
              [svgIcon]="svgIcon"></kendo-icon-wrapper>
            }
            {{ text }}
            @if ((ctx.grid.isActionSheetExpanded && adaptiveGridService.viewType === 'sortToolbarTool' && sortDescriptor(column.field).dir)) {
              <span
                class="k-columnmenu-indicators">
                <kendo-icon-wrapper
                  [name]="sortDescriptor(column.field).dir === 'asc' ? 'sort-asc-small' : 'sort-desc-small'"
                  [svgIcon]="sortDescriptor(column.field).dir === 'asc' ? sortAscSmallIcon : sortDescSmallIcon">
                </kendo-icon-wrapper>
                @if (showSortNumbering(column)) {
                  <span class="k-sort-index">{{sortOrder(column.field)}}</span>
                }
              </span>
            }
            @if ((ctx.grid.isActionSheetExpanded && adaptiveGridService.viewType === 'filterToolbarTool' && hasFilters) || indicatorIcon) {
              <kendo-icon-wrapper
                class="k-columnmenu-indicators"
                name="filter"
                [svgIcon]="filterIcon">
              </kendo-icon-wrapper>
            }
            @if (contentTemplate && adaptiveGridService.viewType !== 'sortToolbarTool') {
              <span class="k-spacer"></span>
            }
            @if (contentTemplate && adaptiveGridService.viewType !== 'sortToolbarTool') {
              <span class="k-expander-indicator">
                <kendo-icon-wrapper
                  [name]="expandedIcon"
                  [svgIcon]="expandedSvgIcon">
                </kendo-icon-wrapper>
              </span>
            }
          </div>
          @if (contentTemplate) {
            <div [attr.id]="contentId" [@state]="contentState" [style.overflow]="'hidden'" class="k-columnmenu-item-content">
              <ng-container [ngTemplateOutlet]="contentTemplate.templateRef">
              </ng-container>
            </div>
          }
        }
        
        <ng-template #content>
          <div
            class="k-columnmenu-item"
            (click)="onClick($event)"
            (keydown.enter)="onClick($event)"
            [class.k-selected]="selected"
            [class.k-disabled]="disabled"
            [class.k-focus]="focused"
            role="button"
            [attr.aria-expanded]="expanded"
            [attr.aria-controls]="expanded ? contentId : undefined">
            @if (icon || svgIcon) {
              <kendo-icon-wrapper
                [name]="icon"
              [svgIcon]="svgIcon"></kendo-icon-wrapper>
            }
            {{ text }}
            @if ((ctx.grid.isActionSheetExpanded && adaptiveGridService.viewType === 'sortToolbarTool' && sortDescriptor(column.field).dir)) {
              <span
                class="k-columnmenu-indicators">
                <kendo-icon-wrapper
                  [name]="sortDescriptor(column.field).dir === 'asc' ? 'sort-asc-small' : 'sort-desc-small'"
                  [svgIcon]="sortDescriptor(column.field).dir === 'asc' ? sortAscSmallIcon : sortDescSmallIcon">
                </kendo-icon-wrapper>
                @if (showSortNumbering(column)) {
                  <span class="k-sort-index">{{sortOrder(column.field)}}</span>
                }
              </span>
            }
            @if ((ctx.grid.isActionSheetExpanded && adaptiveGridService.viewType === 'filterToolbarTool' && hasFilters) || indicatorIcon) {
              <kendo-icon-wrapper
                class="k-columnmenu-indicators"
                name="filter"
                [svgIcon]="filterIcon">
              </kendo-icon-wrapper>
            }
            @if (contentTemplate && adaptiveGridService.viewType !== 'sortToolbarTool') {
              <span class="k-spacer"></span>
            }
            @if (contentTemplate && adaptiveGridService.viewType !== 'sortToolbarTool') {
              <span class="k-expander-indicator">
                <kendo-icon-wrapper
                  [name]="expandedIcon"
                  [svgIcon]="expandedSvgIcon">
                </kendo-icon-wrapper>
              </span>
            }
          </div>
          @if (contentTemplate) {
            <div [attr.id]="contentId" [@state]="contentState" [style.overflow]="'hidden'" class="k-columnmenu-item-content">
              <ng-container [ngTemplateOutlet]="contentTemplate.templateRef">
              </ng-container>
            </div>
          }
        </ng-template>
        `,
      standalone: true,
      imports: [IconWrapperComponent, NgTemplateOutlet]
    }]
  }], () => [{
    type: NgZone
  }, {
    type: ContextService
  }, {
    type: AdaptiveGridService
  }, {
    type: ElementRef
  }], {
    itemClick: [{
      type: Output
    }],
    expand: [{
      type: Output
    }],
    collapse: [{
      type: Output
    }],
    icon: [{
      type: Input
    }],
    svgIcon: [{
      type: Input
    }],
    indicatorIcon: [{
      type: Input
    }],
    text: [{
      type: Input
    }],
    selected: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    expanded: [{
      type: Input
    }],
    focused: [{
      type: Input
    }],
    service: [{
      type: Input
    }],
    column: [{
      type: Input
    }],
    contentTemplate: [{
      type: ContentChild,
      args: [ColumnMenuItemContentTemplateDirective]
    }]
  });
})();
var ColumnMenuAutoSizeAllColumnsComponent = class _ColumnMenuAutoSizeAllColumnsComponent extends ColumnMenuItemBase {
  ctx;
  displayInlineFlexIcon = displayInlineFlexIcon;
  constructor(ctx) {
    super();
    this.ctx = ctx;
  }
  ngOnInit() {
    const isVirtualColumns = this.ctx.grid.columnMenuTemplate && this.ctx.grid.virtualColumns;
    if (isVirtualColumns && isDevMode()) {
      console.warn(ColumnMenuErrorMessages.autoSizeAllColumns);
    }
  }
  /**
   * Resizes all columns to the minimum possible width so that they fit the widest header or cell content without wrapping.
   */
  autoSizeAllColumns() {
    autoSizeColumn(this.ctx.grid, this.service);
  }
  static ɵfac = function ColumnMenuAutoSizeAllColumnsComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColumnMenuAutoSizeAllColumnsComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColumnMenuAutoSizeAllColumnsComponent,
    selectors: [["kendo-grid-columnmenu-autosize-all-columns"]],
    features: [ɵɵInheritDefinitionFeature],
    decls: 1,
    vars: 1,
    consts: [["icon", "display-inline-flex", 3, "text", "svgIcon"], ["icon", "display-inline-flex", 3, "itemClick", "text", "svgIcon"]],
    template: function ColumnMenuAutoSizeAllColumnsComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵconditionalCreate(0, ColumnMenuAutoSizeAllColumnsComponent_Conditional_0_Template, 1, 2, "kendo-grid-columnmenu-item", 0);
      }
      if (rf & 2) {
        ɵɵconditional(!ctx.ctx.grid.virtualColumns ? 0 : -1);
      }
    },
    dependencies: [ColumnMenuItemComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuAutoSizeAllColumnsComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-columnmenu-autosize-all-columns",
      template: `
        @if (!this.ctx.grid.virtualColumns) {
          <kendo-grid-columnmenu-item
            [text]="ctx.localization.get('autosizeAllColumns')"
            icon="display-inline-flex"
            [svgIcon]="displayInlineFlexIcon"
            (itemClick)="autoSizeAllColumns()"
          ></kendo-grid-columnmenu-item>
        }
        `,
      standalone: true,
      imports: [ColumnMenuItemComponent]
    }]
  }], () => [{
    type: ContextService
  }], null);
})();
var ColumnMenuAutoSizeColumnComponent = class _ColumnMenuAutoSizeColumnComponent extends ColumnMenuItemBase {
  ctx;
  /**
   * Specifies the Grid column instance to resize with the auto size column option.
   */
  column;
  maxWidthIcon = maxWidthIcon;
  constructor(ctx) {
    super();
    this.ctx = ctx;
  }
  ngOnInit() {
    const isVirtualColumns = this.ctx.grid.columnMenuTemplate && this.ctx.grid.virtualColumns;
    if (isVirtualColumns && isDevMode()) {
      console.warn(ColumnMenuErrorMessages.autoSizeColumn);
    }
  }
  /**
   * Resizes the specified column to the minimum possible width so that it fits the widest header or cell content without wrapping.
   */
  autoSizeColumn() {
    autoSizeColumn(this.ctx.grid, this.service, this.column);
  }
  static ɵfac = function ColumnMenuAutoSizeColumnComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColumnMenuAutoSizeColumnComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColumnMenuAutoSizeColumnComponent,
    selectors: [["kendo-grid-columnmenu-autosize-column"]],
    inputs: {
      column: "column"
    },
    features: [ɵɵInheritDefinitionFeature],
    decls: 1,
    vars: 1,
    consts: [["icon", "max-width", 1, "k-grid-columnmenu-autosize-column", 3, "text", "svgIcon"], ["icon", "max-width", 1, "k-grid-columnmenu-autosize-column", 3, "itemClick", "text", "svgIcon"]],
    template: function ColumnMenuAutoSizeColumnComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵconditionalCreate(0, ColumnMenuAutoSizeColumnComponent_Conditional_0_Template, 1, 2, "kendo-grid-columnmenu-item", 0);
      }
      if (rf & 2) {
        ɵɵconditional(!ctx.ctx.grid.virtualColumns ? 0 : -1);
      }
    },
    dependencies: [ColumnMenuItemComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuAutoSizeColumnComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-columnmenu-autosize-column",
      template: `
        @if (!this.ctx.grid.virtualColumns) {
          <kendo-grid-columnmenu-item
            class="k-grid-columnmenu-autosize-column"
            [text]="ctx.localization.get('autosizeThisColumn')"
            icon="max-width"
            [svgIcon]="maxWidthIcon"
            (itemClick)="autoSizeColumn()"
          ></kendo-grid-columnmenu-item>
        }
        `,
      standalone: true,
      imports: [ColumnMenuItemComponent]
    }]
  }], () => [{
    type: ContextService
  }], {
    column: [{
      type: Input
    }]
  });
})();
var ColumnMenuChooserComponent = class _ColumnMenuChooserComponent extends ColumnMenuItemBase {
  ctx;
  columnInfoService;
  hostElement;
  /**
   * Fires when the content expands.
   */
  expand = new EventEmitter();
  /**
   * Fires when the content collapses.
   */
  collapse = new EventEmitter();
  /**
   * Specifies if the content is expanded.
   * @default false
   */
  expanded = false;
  /**
   * @hidden
   */
  isLast = false;
  /**
   * @hidden
   */
  actionsClass = "k-actions k-actions-stretched k-actions-horizontal";
  get columns() {
    return this.columnInfoService.leafNamedColumns;
  }
  columnsIcon = columnsIcon;
  constructor(ctx, columnInfoService, hostElement) {
    super();
    this.ctx = ctx;
    this.columnInfoService = columnInfoService;
    this.hostElement = hostElement;
  }
  /**
   * @hidden
   */
  onCollapse() {
    this.expanded = false;
    if (this.isLast) {
      this.service.menuTabbingService.lastFocusable = this.hostElement.nativeElement.querySelector(".k-columnmenu-item");
    }
    this.collapse.emit();
  }
  /**
   * @hidden
   */
  onExpand() {
    this.expanded = true;
    this.expand.emit();
  }
  static ɵfac = function ColumnMenuChooserComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColumnMenuChooserComponent)(ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ColumnInfoService), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColumnMenuChooserComponent,
    selectors: [["kendo-grid-columnmenu-chooser"]],
    inputs: {
      expanded: "expanded",
      isLast: "isLast"
    },
    outputs: {
      expand: "expand",
      collapse: "collapse"
    },
    features: [ɵɵInheritDefinitionFeature],
    decls: 2,
    vars: 3,
    consts: [["icon", "columns", 3, "collapse", "expand", "text", "svgIcon", "expanded"], ["kendoGridColumnMenuItemContentTemplate", ""], [3, "close", "columns", "isLast", "isExpanded", "closeOnReset", "service"]],
    template: function ColumnMenuChooserComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "kendo-grid-columnmenu-item", 0);
        ɵɵlistener("collapse", function ColumnMenuChooserComponent_Template_kendo_grid_columnmenu_item_collapse_0_listener() {
          return ctx.onCollapse();
        })("expand", function ColumnMenuChooserComponent_Template_kendo_grid_columnmenu_item_expand_0_listener() {
          return ctx.onExpand();
        });
        ɵɵtemplate(1, ColumnMenuChooserComponent_ng_template_1_Template, 1, 5, "ng-template", 1);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("text", ctx.ctx.localization.get("columns"))("svgIcon", ctx.columnsIcon)("expanded", ctx.expanded);
      }
    },
    dependencies: [ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, ColumnChooserContentComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuChooserComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-columnmenu-chooser",
      template: `
        <kendo-grid-columnmenu-item
            [text]="ctx.localization.get('columns')"
            icon="columns"
            [svgIcon]="columnsIcon"
            [expanded]="expanded"
            (collapse)="onCollapse()"
            (expand)="onExpand()">
            <ng-template kendoGridColumnMenuItemContentTemplate>
                <kendo-grid-column-chooser-content
                    [columns]="columns"
                    [isLast]="isLast"
                    [isExpanded]="expanded"
                    [closeOnReset]="false"
                    [service]="service"
                    (close)="close()"
                >
                </kendo-grid-column-chooser-content>
            </ng-template>
        </kendo-grid-columnmenu-item>
    `,
      standalone: true,
      imports: [ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, ColumnChooserContentComponent]
    }]
  }], () => [{
    type: ContextService
  }, {
    type: ColumnInfoService
  }, {
    type: ElementRef
  }], {
    expand: [{
      type: Output
    }],
    collapse: [{
      type: Output
    }],
    expanded: [{
      type: Input
    }],
    isLast: [{
      type: Input
    }]
  });
})();
var ColumnMenuStickComponent = class _ColumnMenuStickComponent extends ColumnMenuItemBase {
  ctx;
  columnInfoService;
  changeDetector;
  stickIcon = stickIcon;
  unstickIcon = unstickIcon;
  constructor(ctx, columnInfoService, changeDetector) {
    super();
    this.ctx = ctx;
    this.columnInfoService = columnInfoService;
    this.changeDetector = changeDetector;
  }
  get text() {
    return this.ctx.localization.get(this.sticky ? "unstick" : "stick");
  }
  get icon() {
    return this.sticky ? "unstick" : "stick";
  }
  get svgIcon() {
    return this.sticky ? this.unstickIcon : this.stickIcon;
  }
  get disabled() {
    return !this.sticky && this.columnInfoService.unlockedRootCount < 2;
  }
  /**
   * @hidden
   */
  toggleColumn() {
    this.toggleHierarchy(!this.sticky);
    this.close();
    this.changeDetector.markForCheck();
  }
  toggleHierarchy(sticky) {
    let root = this.service.column;
    while (root.parent) {
      root = root.parent;
    }
    const columns = [root];
    const allChanged = [];
    while (columns.length) {
      const column = columns.shift();
      column.sticky = sticky;
      allChanged.push(column);
      if (column.hasChildren) {
        columns.push(...column.childrenArray);
      }
    }
    this.columnInfoService.changeStuck(allChanged);
  }
  get sticky() {
    return this.service.column.sticky;
  }
  static ɵfac = function ColumnMenuStickComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColumnMenuStickComponent)(ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ColumnInfoService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColumnMenuStickComponent,
    selectors: [["kendo-grid-columnmenu-stick"]],
    features: [ɵɵInheritDefinitionFeature],
    decls: 1,
    vars: 4,
    consts: [[3, "itemClick", "text", "icon", "svgIcon", "disabled"]],
    template: function ColumnMenuStickComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "kendo-grid-columnmenu-item", 0);
        ɵɵlistener("itemClick", function ColumnMenuStickComponent_Template_kendo_grid_columnmenu_item_itemClick_0_listener() {
          return ctx.toggleColumn();
        });
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("text", ctx.text)("icon", ctx.icon)("svgIcon", ctx.svgIcon)("disabled", ctx.disabled);
      }
    },
    dependencies: [ColumnMenuItemComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuStickComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-columnmenu-stick",
      template: `
        <kendo-grid-columnmenu-item
           [text]="text"
           [icon]="icon"
           [svgIcon]="svgIcon"
           (itemClick)="toggleColumn()"
           [disabled]="disabled">
        </kendo-grid-columnmenu-item>
    `,
      standalone: true,
      imports: [ColumnMenuItemComponent]
    }]
  }], () => [{
    type: ContextService
  }, {
    type: ColumnInfoService
  }, {
    type: ChangeDetectorRef
  }], null);
})();
var ColumnMenuLockComponent = class _ColumnMenuLockComponent extends ColumnMenuItemBase {
  ctx;
  columnInfoService;
  changeDetector;
  constructor(ctx, columnInfoService, changeDetector) {
    super();
    this.ctx = ctx;
    this.columnInfoService = columnInfoService;
    this.changeDetector = changeDetector;
  }
  get text() {
    return this.ctx.localization.get(this.locked ? "unlock" : "lock");
  }
  get icon() {
    return this.locked ? "unlock" : "lock";
  }
  unlockIcon = unlockIcon;
  lockIcon = lockIcon;
  get svgIcon() {
    return this.locked ? this.unlockIcon : this.lockIcon;
  }
  get disabled() {
    return !this.locked && this.columnInfoService.unlockedRootCount < 2;
  }
  /**
   * @hidden
   */
  toggleColumn() {
    this.toggleHierarchy(!this.locked);
    this.close();
    this.changeDetector.markForCheck();
  }
  toggleHierarchy(locked) {
    let root = this.service.column;
    while (root.parent) {
      root = root.parent;
    }
    const columns = [root];
    const allChanged = [];
    while (columns.length) {
      const column = columns.shift();
      column.locked = locked;
      allChanged.push(column);
      if (column.hasChildren) {
        columns.push(...column.childrenArray);
      }
    }
    this.columnInfoService.changeLocked(allChanged);
  }
  get locked() {
    return this.service.column.locked;
  }
  static ɵfac = function ColumnMenuLockComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColumnMenuLockComponent)(ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ColumnInfoService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColumnMenuLockComponent,
    selectors: [["kendo-grid-columnmenu-lock"]],
    features: [ɵɵInheritDefinitionFeature],
    decls: 1,
    vars: 4,
    consts: [[3, "itemClick", "text", "icon", "svgIcon", "disabled"]],
    template: function ColumnMenuLockComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "kendo-grid-columnmenu-item", 0);
        ɵɵlistener("itemClick", function ColumnMenuLockComponent_Template_kendo_grid_columnmenu_item_itemClick_0_listener() {
          return ctx.toggleColumn();
        });
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("text", ctx.text)("icon", ctx.icon)("svgIcon", ctx.svgIcon)("disabled", ctx.disabled);
      }
    },
    dependencies: [ColumnMenuItemComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuLockComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-columnmenu-lock",
      template: `
       <kendo-grid-columnmenu-item
            [text]="text"
            [icon]="icon"
            [svgIcon]="svgIcon"
            (itemClick)="toggleColumn()"
            [disabled]="disabled">
       </kendo-grid-columnmenu-item>
    `,
      standalone: true,
      imports: [ColumnMenuItemComponent]
    }]
  }], () => [{
    type: ContextService
  }, {
    type: ColumnInfoService
  }, {
    type: ChangeDetectorRef
  }], null);
})();
var ColumnMenuPositionComponent = class _ColumnMenuPositionComponent extends ColumnMenuItemBase {
  ctx;
  hostElement;
  /**
   * Emits when the content expands.
   */
  expand = new EventEmitter();
  /**
   * Emits when the content collapses.
   */
  collapse = new EventEmitter();
  /**
   * Specifies if the content is expanded.
   * @default false
   */
  expanded = false;
  /**
   * Specifies if the lock column item is shown.
   */
  showLock;
  /**
   * Specifies if the stick column item is shown.
   */
  showStick;
  /**
   * @hidden
   */
  actionsClass = "k-actions";
  /**
   * @hidden
   */
  set isLast(value2) {
    this.service.menuTabbingService.lastFocusable = this.getLastFocusableItem();
    this._isLast = value2;
  }
  /**
   * @hidden
   */
  get isLast() {
    return this._isLast;
  }
  setColumnPositionIcon = setColumnPositionIcon;
  _isLast = false;
  constructor(ctx, hostElement) {
    super();
    this.ctx = ctx;
    this.hostElement = hostElement;
  }
  /**
   * @hidden
   */
  onTab(e, isLastItem) {
    if (this.isLast && isLastItem) {
      e.preventDefault();
      e.stopImmediatePropagation();
      if (this.service) {
        this.service.menuTabbingService.firstFocusable.focus();
      }
    }
  }
  /**
   * @hidden
   */
  onCollapse() {
    this.expanded = false;
    if (this.isLast) {
      this.service.menuTabbingService.lastFocusable = this.getLastFocusableItem();
    }
    this.collapse.emit();
  }
  /**
   * @hidden
   */
  onExpand() {
    this.expanded = true;
    if (this.isLast) {
      this.service.menuTabbingService.lastFocusable = this.getLastFocusableItem();
    }
    this.expand.emit();
  }
  getLastFocusableItem() {
    const menuItems = this.hostElement.nativeElement.querySelectorAll(".k-columnmenu-item");
    const lastFocusableIndex = this.expanded ? menuItems.length - 1 : 0;
    return menuItems[lastFocusableIndex];
  }
  static ɵfac = function ColumnMenuPositionComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColumnMenuPositionComponent)(ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColumnMenuPositionComponent,
    selectors: [["kendo-grid-columnmenu-position"]],
    inputs: {
      expanded: "expanded",
      showLock: "showLock",
      showStick: "showStick",
      isLast: "isLast"
    },
    outputs: {
      expand: "expand",
      collapse: "collapse"
    },
    features: [ɵɵInheritDefinitionFeature],
    decls: 2,
    vars: 3,
    consts: [["icon", "set-column-position", 3, "keydown.tab", "collapse", "expand", "text", "svgIcon", "expanded"], ["kendoGridColumnMenuItemContentTemplate", ""], [3, "service"], [3, "keydown.tab", "service"]],
    template: function ColumnMenuPositionComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "kendo-grid-columnmenu-item", 0);
        ɵɵlistener("keydown.tab", function ColumnMenuPositionComponent_Template_kendo_grid_columnmenu_item_keydown_tab_0_listener($event) {
          return ctx.onTab($event, !ctx.expanded);
        })("collapse", function ColumnMenuPositionComponent_Template_kendo_grid_columnmenu_item_collapse_0_listener() {
          return ctx.onCollapse();
        })("expand", function ColumnMenuPositionComponent_Template_kendo_grid_columnmenu_item_expand_0_listener() {
          return ctx.onExpand();
        });
        ɵɵtemplate(1, ColumnMenuPositionComponent_ng_template_1_Template, 2, 2, "ng-template", 1);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("text", ctx.ctx.localization.get("setColumnPosition"))("svgIcon", ctx.setColumnPositionIcon)("expanded", ctx.expanded);
      }
    },
    dependencies: [ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, ColumnMenuLockComponent, ColumnMenuStickComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuPositionComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-columnmenu-position",
      template: `
        <kendo-grid-columnmenu-item
          [text]="ctx.localization.get('setColumnPosition')"
          icon="set-column-position"
          [svgIcon]="setColumnPositionIcon"
          [expanded]="expanded"
          (keydown.tab)="onTab($event, !expanded)"
          (collapse)="onCollapse()"
          (expand)="onExpand()">
          <ng-template kendoGridColumnMenuItemContentTemplate>
            @if (showLock) {
              <kendo-grid-columnmenu-lock
                (keydown.tab)="onTab($event, !showStick)"
                [service]="service">
              </kendo-grid-columnmenu-lock>
            }
            @if (showStick) {
              <kendo-grid-columnmenu-stick
                (keydown.tab)="onTab($event, true)"
                [service]="service">
              </kendo-grid-columnmenu-stick>
            }
          </ng-template>
        </kendo-grid-columnmenu-item>
        `,
      standalone: true,
      imports: [ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, ColumnMenuLockComponent, ColumnMenuStickComponent]
    }]
  }], () => [{
    type: ContextService
  }, {
    type: ElementRef
  }], {
    expand: [{
      type: Output
    }],
    collapse: [{
      type: Output
    }],
    expanded: [{
      type: Input
    }],
    showLock: [{
      type: Input
    }],
    showStick: [{
      type: Input
    }],
    isLast: [{
      type: Input
    }]
  });
})();
var ColumnMenuFilterComponent = class _ColumnMenuFilterComponent extends ColumnMenuItemBase {
  ctx;
  hostElement;
  /**
   * Emits when the content expands.
   */
  expand = new EventEmitter();
  /**
   * Emits when the content collapses.
   */
  collapse = new EventEmitter();
  /**
   * Specifies if the content is expanded.
   * @default false
   */
  expanded = false;
  /**
   * Specifies if this is the last item in the menu.
   * @hidden
   */
  isLast = false;
  /**
   * Sets the CSS class for the actions container.
   * @hidden
   */
  actionsClass = "k-actions k-actions-stretched k-actions-horizontal";
  /**
   * Defines the SVG icon for the filter.
   */
  filterIcon = filterIcon;
  constructor(ctx, hostElement) {
    super();
    this.ctx = ctx;
    this.hostElement = hostElement;
  }
  /**
   * @hidden
   */
  onCollapse() {
    this.expanded = false;
    if (this.isLast) {
      this.service.menuTabbingService.lastFocusable = this.hostElement.nativeElement.querySelector(".k-columnmenu-item");
    }
    this.collapse.emit();
  }
  /**
   * @hidden
   */
  onExpand() {
    this.expanded = true;
    this.expand.emit();
  }
  static ɵfac = function ColumnMenuFilterComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColumnMenuFilterComponent)(ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColumnMenuFilterComponent,
    selectors: [["kendo-grid-columnmenu-filter"]],
    inputs: {
      expanded: "expanded",
      isLast: "isLast"
    },
    outputs: {
      expand: "expand",
      collapse: "collapse"
    },
    features: [ɵɵInheritDefinitionFeature],
    decls: 2,
    vars: 3,
    consts: [["icon", "filter", 3, "collapse", "expand", "text", "svgIcon", "expanded"], ["kendoGridColumnMenuItemContentTemplate", ""], [3, "keydown.shift.tab", "close", "column", "menuTabbingService", "filter", "actionsClass", "isLast", "isExpanded"]],
    template: function ColumnMenuFilterComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "kendo-grid-columnmenu-item", 0);
        ɵɵlistener("collapse", function ColumnMenuFilterComponent_Template_kendo_grid_columnmenu_item_collapse_0_listener() {
          return ctx.onCollapse();
        })("expand", function ColumnMenuFilterComponent_Template_kendo_grid_columnmenu_item_expand_0_listener() {
          return ctx.onExpand();
        });
        ɵɵtemplate(1, ColumnMenuFilterComponent_ng_template_1_Template, 1, 6, "ng-template", 1);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("text", ctx.ctx.localization.get("filter"))("svgIcon", ctx.filterIcon)("expanded", ctx.expanded);
      }
    },
    dependencies: [ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, FilterMenuContainerComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuFilterComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-columnmenu-filter",
      template: `
        <kendo-grid-columnmenu-item
            [text]="ctx.localization.get('filter')"
            icon="filter"
            [svgIcon]="filterIcon"
            [expanded]="expanded"
            (collapse)="onCollapse()"
            (expand)="onExpand()">
            <ng-template kendoGridColumnMenuItemContentTemplate>
                <kendo-grid-filter-menu-container
                    [column]="service.column"
                    [menuTabbingService]="service.menuTabbingService"
                    [filter]="service.filter"
                    [actionsClass]="actionsClass"
                    [isLast]="isLast"
                    [isExpanded]="expanded"
                    (keydown.shift.tab)="$event.stopImmediatePropagation()"
                    (close)="close()">
                </kendo-grid-filter-menu-container>
            </ng-template>
        </kendo-grid-columnmenu-item>
    `,
      standalone: true,
      imports: [ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, FilterMenuContainerComponent]
    }]
  }], () => [{
    type: ContextService
  }, {
    type: ElementRef
  }], {
    expand: [{
      type: Output
    }],
    collapse: [{
      type: Output
    }],
    expanded: [{
      type: Input
    }],
    isLast: [{
      type: Input
    }]
  });
})();
var ColumnMenuItemDirective = class _ColumnMenuItemDirective {
  hostElement;
  renderer;
  ngZone;
  cdr;
  ctx;
  /**
   * Reference to the Grid column menu item. Required when you want to include the item in the built-in keyboard navigation.
   */
  menuItemComponent;
  /**
   * Holds the first focusable element.
   */
  firstFocusableElement;
  /**
   * Holds the last focusable element.
   */
  lastFocusableElement;
  /**
   * @hidden
   */
  set isFirst(value2) {
    if (value2) {
      const focusableElement = this.columnMenuItems[0];
      this.menuItemComponent.service.menuTabbingService.firstFocusable = focusableElement;
      this.ngZone.runOutsideAngular(() => {
        const firstItemKeydownSub = this.renderer.listen(focusableElement, "keydown", this.onTab);
        this.subs.add(firstItemKeydownSub);
      });
    }
    this._isFirst = value2;
  }
  /**
   * @hidden
   */
  get isFirst() {
    return this._isFirst;
  }
  /**
   * @hidden
   */
  set isLast(value2) {
    if (!this.columnMenuItems) {
      return;
    }
    if (value2) {
      const lastFocusableElement = this.getLastColumnMenuItem();
      this.menuItemComponent.service.menuTabbingService.lastFocusable = lastFocusableElement;
      this.ngZone.runOutsideAngular(() => {
        const lastItemKeydownSub = this.renderer.listen(lastFocusableElement, "keydown", this.onTab);
        this.subs.add(lastItemKeydownSub);
      });
      if (this.isExpandableItem()) {
        this.menuItemComponent.isLast = true;
        if (this.ctx.grid.isActionSheetExpanded) {
          this.cdr.detectChanges();
        }
      }
    }
    this._isLast = value2;
  }
  /**
   * @hidden
   */
  get isLast() {
    return this._isLast;
  }
  _isFirst = false;
  _isLast = false;
  columnMenuItems;
  subs = new Subscription();
  constructor(hostElement, renderer, ngZone, cdr, ctx) {
    this.hostElement = hostElement;
    this.renderer = renderer;
    this.ngZone = ngZone;
    this.cdr = cdr;
    this.ctx = ctx;
  }
  ngAfterViewInit() {
    this.columnMenuItems = this.hostElement.nativeElement.querySelectorAll(".k-columnmenu-item");
    [].slice.apply(this.columnMenuItems).forEach((el) => this.renderer.setAttribute(el, "tabindex", "0"));
    if (this.menuItemComponent instanceof ColumnMenuFilterComponent) {
      this.menuItemComponent.service.menuTabbingService.isColumnMenu = true;
    }
    this.menuItemComponent.service?.columnMenuContainer?.templateMenuItems.push(this);
  }
  ngOnDestroy() {
    if (this.subs) {
      this.subs.unsubscribe();
    }
  }
  onTab = (e) => {
    if (e.code !== Keys.Tab) {
      return;
    }
    if (this.isFirst && e.shiftKey && e.target === this.columnMenuItems[0]) {
      e.preventDefault();
      this.menuItemComponent.service.menuTabbingService.lastFocusable.focus();
    }
    if (this.isLast && !e.shiftKey) {
      const lastColumnMenuItem = this.getLastColumnMenuItem();
      const isExpanded = this.menuItemComponent.expanded;
      if (lastColumnMenuItem === e.target && !isExpanded) {
        e.preventDefault();
        this.menuItemComponent.service.menuTabbingService.firstFocusable.focus();
      }
    }
  };
  getLastColumnMenuItem() {
    return this.columnMenuItems.length === 1 ? this.columnMenuItems[0] : this.columnMenuItems[1];
  }
  isExpandableItem() {
    return this.menuItemComponent instanceof ColumnMenuFilterComponent || this.menuItemComponent instanceof ColumnMenuChooserComponent || this.menuItemComponent instanceof ColumnMenuPositionComponent;
  }
  static ɵfac = function ColumnMenuItemDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColumnMenuItemDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ContextService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ColumnMenuItemDirective,
    selectors: [["", "kendoGridColumnMenuItem", ""]],
    inputs: {
      menuItemComponent: [0, "kendoGridColumnMenuItem", "menuItemComponent"]
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuItemDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridColumnMenuItem]",
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: NgZone
  }, {
    type: ChangeDetectorRef
  }, {
    type: ContextService
  }], {
    menuItemComponent: [{
      type: Input,
      args: ["kendoGridColumnMenuItem"]
    }]
  });
})();
var ColumnMenuContainerComponent = class _ColumnMenuContainerComponent {
  service;
  ngZone;
  columnMenuItems;
  templateMenuItems = [];
  constructor(service, ngZone) {
    this.service = service;
    this.ngZone = ngZone;
    service.columnMenuContainer = this;
  }
  ngAfterViewInit() {
    if (this.columnMenuItems.length) {
      this.columnMenuItems.first.isFirst = true;
      this.columnMenuItems.last.isLast = true;
    } else if (this.templateMenuItems.length) {
      this.templateMenuItems[0].isFirst = true;
      this.templateMenuItems[this.templateMenuItems.length - 1].isLast = true;
    } else {
      return;
    }
    this.ngZone.onStable.pipe(take(1)).subscribe(() => {
      const firstFocusable = this.service.menuTabbingService.firstFocusable;
      if (firstFocusable instanceof DropDownListComponent) {
        firstFocusable.wrapper.nativeElement.focus({
          preventScroll: true
        });
      } else {
        firstFocusable?.focus({
          preventScroll: true
        });
      }
    });
  }
  static ɵfac = function ColumnMenuContainerComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColumnMenuContainerComponent)(ɵɵdirectiveInject(ColumnMenuService), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColumnMenuContainerComponent,
    selectors: [["kendo-grid-columnmenu-container"]],
    contentQueries: function ColumnMenuContainerComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, ColumnMenuItemDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columnMenuItems = _t);
      }
    },
    ngContentSelectors: _c118,
    decls: 1,
    vars: 0,
    template: function ColumnMenuContainerComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuContainerComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-columnmenu-container",
      template: `
        <ng-content></ng-content>
    `,
      standalone: true
    }]
  }], () => [{
    type: ColumnMenuService
  }, {
    type: NgZone,
    decorators: [{
      type: Inject,
      args: [NgZone]
    }]
  }], {
    columnMenuItems: [{
      type: ContentChildren,
      args: [ColumnMenuItemDirective, {
        descendants: true
      }]
    }]
  });
})();
var SortService = class {
  changes = new Subject();
  sort(value2) {
    this.changes.next(value2);
  }
};
var ColumnMenuSortComponent = class _ColumnMenuSortComponent extends ColumnMenuItemBase {
  ctx;
  sortService;
  renderer;
  sortAscSmallIcon = sortAscSmallIcon;
  sortDescSmallIcon = sortDescSmallIcon;
  constructor(ctx, sortService, renderer) {
    super();
    this.ctx = ctx;
    this.sortService = sortService;
    this.renderer = renderer;
  }
  get sortedAsc() {
    return this.descriptor?.dir === "asc";
  }
  get sortedDesc() {
    return this.descriptor?.dir === "desc";
  }
  /**
   * @hidden
   */
  toggleSort(dir) {
    const field = this.service.column.field;
    const {
      mode,
      allowUnsort
    } = normalize$1(this.service.sortable);
    const descriptor = this.descriptor;
    const sort2 = mode === "multiple" ? this.service.sort.filter((s) => s.field !== field) : [];
    if (descriptor && descriptor.dir === dir) {
      if (!allowUnsort) {
        return;
      }
    } else {
      sort2.push({
        field,
        dir
      });
    }
    this.sortService.sort(sort2);
    this.close();
  }
  get descriptor() {
    return [].concat(this.service.sort || []).find((s) => s.field === this.service.column.field);
  }
  static ɵfac = function ColumnMenuSortComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColumnMenuSortComponent)(ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(SortService), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColumnMenuSortComponent,
    selectors: [["kendo-grid-columnmenu-sort"]],
    features: [ɵɵInheritDefinitionFeature],
    decls: 2,
    vars: 6,
    consts: [["icon", "sort-asc-small", 3, "itemClick", "text", "svgIcon", "selected"], ["icon", "sort-desc-small", 3, "itemClick", "text", "svgIcon", "selected"]],
    template: function ColumnMenuSortComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "kendo-grid-columnmenu-item", 0);
        ɵɵlistener("itemClick", function ColumnMenuSortComponent_Template_kendo_grid_columnmenu_item_itemClick_0_listener() {
          return ctx.toggleSort("asc");
        });
        ɵɵelementEnd();
        ɵɵelementStart(1, "kendo-grid-columnmenu-item", 1);
        ɵɵlistener("itemClick", function ColumnMenuSortComponent_Template_kendo_grid_columnmenu_item_itemClick_1_listener() {
          return ctx.toggleSort("desc");
        });
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("text", ctx.ctx.localization.get("sortAscending"))("svgIcon", ctx.sortAscSmallIcon)("selected", ctx.sortedAsc);
        ɵɵadvance();
        ɵɵproperty("text", ctx.ctx.localization.get("sortDescending"))("svgIcon", ctx.sortDescSmallIcon)("selected", ctx.sortedDesc);
      }
    },
    dependencies: [ColumnMenuItemComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuSortComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-columnmenu-sort",
      template: `
        <kendo-grid-columnmenu-item
            [text]="ctx.localization.get('sortAscending')"
            icon="sort-asc-small"
            [svgIcon]="sortAscSmallIcon"
            (itemClick)="toggleSort('asc')"
            [selected]="sortedAsc">
        </kendo-grid-columnmenu-item>
        <kendo-grid-columnmenu-item
            [text]="ctx.localization.get('sortDescending')"
            icon="sort-desc-small"
            [svgIcon]="sortDescSmallIcon"
            (itemClick)="toggleSort('desc')"
            [selected]="sortedDesc">
        </kendo-grid-columnmenu-item>
    `,
      standalone: true,
      imports: [ColumnMenuItemComponent]
    }]
  }], () => [{
    type: ContextService
  }, {
    type: SortService
  }, {
    type: Renderer2
  }], null);
})();
var POPUP_CLASSES = "k-grid-columnmenu-popup k-column-menu";
var id2 = 0;
var getId2 = (gridId) => `${gridId}-column-menu-${id2++}`;
var ColumnMenuComponent = class _ColumnMenuComponent {
  navigationService;
  popupService;
  service;
  ctx;
  renderer;
  cdr;
  columnInfoService;
  idService;
  adaptiveGridService;
  /**
   * @hidden
   */
  standalone = true;
  /**
   * The Grid column instance controlled by the menu.
   */
  column;
  /**
   * The settings for the column menu.
   */
  settings = {};
  /**
   * The sort descriptors for the Grid data.
   * Typically bound to [`GridComponent.sort`]({% slug api_grid_gridcomponent %}#toc-sort).
   */
  sort;
  /**
   * The filter descriptor for the Grid data.
   * Typically bound to [`GridComponent.filter`]({% slug api_grid_gridcomponent %}#toc-filter).
   */
  filter;
  /**
   * @hidden
   */
  sortable = true;
  /**
   * @hidden
   */
  columnMenuTemplate;
  /**
   * @hidden
   */
  tabIndex = "-1";
  anchor;
  template;
  defaultTemplate;
  tabbedInterfaceTemplate;
  tabStrip;
  /**
   * @hidden
   */
  columnsIcon = columnsIcon;
  /**
   * @hidden
   */
  actionsClass = "k-actions";
  /**
   * @hidden
   */
  slidersIcon = slidersIcon;
  /**
   * @hidden
   */
  filterIcon = filterIcon;
  /**
   * @hidden
   */
  expandedFilter = false;
  /**
   * @hidden
   */
  expandedColumns = false;
  /**
   * @hidden
   */
  expandedPosition = false;
  /**
   * @hidden
   */
  get showGeneralTab() {
    return this.hasSort || this.hasLock || this.hasStick || this.hasPosition || this.hasAutoSizeColumn || this.hasAutoSizeAllColumns;
  }
  moreVerticalIcon = moreVerticalIcon;
  popupRef;
  closeSubscription;
  popupSubs;
  constructor(navigationService, popupService, service, ctx, renderer, cdr, columnInfoService, idService, adaptiveGridService) {
    this.navigationService = navigationService;
    this.popupService = popupService;
    this.service = service;
    this.ctx = ctx;
    this.renderer = renderer;
    this.cdr = cdr;
    this.columnInfoService = columnInfoService;
    this.idService = idService;
    this.adaptiveGridService = adaptiveGridService;
    this.closeSubscription = service.closeMenu.subscribe(this.close.bind(this, true));
  }
  /**
   * @hidden
   */
  get isActive() {
    return this.hasFilter && filtersByField(this.filter, this.column.field).length > 0 || !this.sortable && this.hasSort && this.sort.find((descriptor) => descriptor.field === this.column.field);
  }
  /**
   * @hidden
   */
  get hasFilter() {
    return hasFilter(this.settings, this.column);
  }
  /**
   * @hidden
   */
  get isNavigable() {
    return this.navigationService.tableEnabled;
  }
  /**
   * @hidden
   */
  get hasSort() {
    return hasSort(this.settings, this.column);
  }
  /**
   * @hidden
   */
  get hasColumnChooser() {
    return hasColumnChooser(this.settings);
  }
  /**
   * @hidden
   */
  get hasAutoSizeColumn() {
    return hasAutoSizeColumn(this.settings);
  }
  /**
   * @hidden
   */
  get hasAutoSizeAllColumns() {
    return hasAutoSizeAllColumns(this.settings);
  }
  /**
   * @hidden
   */
  get hasLock() {
    return hasLock(this.settings, this.column);
  }
  /**
   * @hidden
   */
  get hasStick() {
    return hasStick(this.settings, this.column);
  }
  /**
   * @hidden
   */
  get hasPosition() {
    return hasPosition(this.settings, this.column);
  }
  /**
   * @hidden
   */
  get columns() {
    return this.columnInfoService.leafNamedColumns;
  }
  ngAfterViewInit() {
    if (this.ctx.grid.virtualColumns && isDevMode()) {
      if (this.settings.autoSizeAllColumns) {
        this.settings.autoSizeAllColumns = false;
        console.warn(ColumnMenuErrorMessages.autoSizeAllColumns);
      }
      if (this.settings.autoSizeColumn) {
        this.settings.autoSizeColumn = false;
        console.warn(ColumnMenuErrorMessages.autoSizeColumn);
      }
    }
    this.service.menuTabbingService.isTabbedInterface = this.settings.view === "tabbed" ? true : false;
  }
  ngOnChanges() {
    this.service.column = this.column;
    this.service.sort = this.sort;
    this.service.filter = this.filter;
    this.service.sortable = this.sortable;
  }
  ngOnDestroy() {
    this.close();
    this.closeSubscription.unsubscribe();
    this.popupSubs?.unsubscribe();
    this.closeSubscription = this.popupSubs = null;
  }
  /**
   * @hidden
   */
  toggle(e, anchor, template) {
    if (e) {
      e.preventDefault();
      e instanceof KeyboardEvent && e.stopImmediatePropagation();
    }
    if (this.ctx.grid.adaptiveMode === "auto" && this.adaptiveGridService.windowSize !== "large") {
      if (!this.ctx.grid.isActionSheetExpanded) {
        this.adaptiveGridService.viewType = "columnMenu";
        this.adaptiveGridService.columns = this.columns;
        this.adaptiveGridService.columnMenuService = this.service;
        this.adaptiveGridService.column = this.column;
        this.ctx.grid.adaptiveRenderer.actionSheet.toggle(true);
      }
    } else {
      this.expandedFilter = this.getExpandedState(this.settings.filter);
      this.expandedColumns = this.getExpandedState(this.settings.columnChooser);
      this.expandedPosition = this.getExpandedState(this.settings.setColumnPosition);
      this.popupRef = this.popupService.open(anchor, template, this.popupRef, POPUP_CLASSES);
      const ariaRoot = this.isNavigable ? anchor.closest(".k-table-th") : anchor;
      if (this.popupRef) {
        this.popupSubs?.unsubscribe();
        this.popupSubs = this.popupRef.popup.instance.anchorViewportLeave.subscribe(() => {
          this.popupSubs?.unsubscribe();
          this.popupSubs = null;
          this.close(true);
          this.updateAria(ariaRoot);
        });
        this.popupSubs.add(() => this.popupRef.popup.instance.close.subscribe(() => {
          this.popupSubs?.unsubscribe();
          this.popupSubs = this.popupRef = null;
          this.updateAria(ariaRoot);
        }));
        const popupAriaElement = this.popupRef.popupElement.querySelector(".k-grid-columnmenu-popup");
        if (popupAriaElement) {
          const popupId = getId2(this.idService?.gridId());
          this.renderer.setAttribute(popupAriaElement, "id", popupId);
          this.renderer.setAttribute(popupAriaElement, "role", "dialog");
          this.renderer.setAttribute(popupAriaElement, "aria-label", this.columnMenuTitle);
          ariaRoot && this.renderer.setAttribute(ariaRoot, "aria-controls", popupId);
          ariaRoot && this.renderer.setAttribute(ariaRoot, "aria-expanded", "true");
        }
        if (this.settings.view === "tabbed") {
          this.renderer.addClass(popupAriaElement, "k-column-menu-tabbed");
          this.renderer.addClass(popupAriaElement, "k-column-menu");
          this.cdr.detectChanges();
          this.tabStrip?.selectTab(0);
        }
      } else {
        this.focusRoot();
      }
    }
  }
  /**
   * @hidden
   */
  close(triggerFocus = false) {
    if (this.ctx.grid.adaptiveMode === "auto" && this.adaptiveGridService.windowSize !== "large") {
      this.ctx.grid.adaptiveRenderer.actionSheet.toggle(false);
    } else {
      this.popupService.destroy();
      this.popupRef = null;
      this.cdr.markForCheck();
    }
    if (!triggerFocus) {
      return;
    }
    this.focusRoot();
  }
  /**
   * @hidden
   */
  get columnMenuTitle() {
    const localizationMsg = this.ctx.localization.get("columnMenu") || "";
    const columnName = this.column.title || this.column.field;
    return replaceMessagePlaceholder(localizationMsg, "columnName", columnName);
  }
  getExpandedState(menuItemSettings) {
    return typeof menuItemSettings === "object" ? menuItemSettings.expanded : false;
  }
  updateAria(ariaRoot) {
    ariaRoot && this.renderer.removeAttribute(ariaRoot, "aria-controls");
    ariaRoot && this.renderer.setAttribute(ariaRoot, "aria-expanded", "false");
  }
  focusRoot() {
    if (this.isNavigable) {
      this.navigationService.preventScroll = true;
      this.navigationService.focusCell(0, this.column.leafIndex);
    } else {
      this.anchor.nativeElement.focus({
        preventScroll: true
      });
    }
  }
  static ɵfac = function ColumnMenuComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColumnMenuComponent)(ɵɵdirectiveInject(NavigationService4), ɵɵdirectiveInject(SinglePopupService), ɵɵdirectiveInject(ColumnMenuService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ColumnInfoService), ɵɵdirectiveInject(IdService, 8), ɵɵdirectiveInject(AdaptiveGridService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColumnMenuComponent,
    selectors: [["kendo-grid-column-menu"]],
    viewQuery: function ColumnMenuComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c154, 7)(_c164, 7, TemplateRef)(_c57, 7, TemplateRef)(_c253, 7, TemplateRef)(TabStripComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.anchor = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.template = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.defaultTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tabbedInterfaceTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tabStrip = _t.first);
      }
    },
    hostVars: 2,
    hostBindings: function ColumnMenuComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-grid-column-menu-standalone", ctx.standalone);
      }
    },
    inputs: {
      standalone: "standalone",
      column: "column",
      settings: "settings",
      sort: "sort",
      filter: "filter",
      sortable: "sortable",
      columnMenuTemplate: "columnMenuTemplate",
      tabIndex: "tabIndex"
    },
    features: [ɵɵProvidersFeature([ColumnMenuService, MenuTabbingService]), ɵɵNgOnChangesFeature],
    decls: 9,
    vars: 8,
    consts: [["anchor", ""], ["template", ""], ["defaultTemplate", ""], ["tabbedInterfaceTemplate", ""], ["sortItem", ""], ["lockItem", ""], ["stickItem", ""], ["positionItem", ""], ["chooserItem", ""], ["autoSizeColumnItem", ""], ["autoSizeAllColumnsItem", ""], ["filterItem", ""], ["tabstrip", ""], ["href", "#", 1, "k-grid-header-menu", "k-grid-column-menu", 3, "click", "keydown.enter", "ngClass", "tabindex"], ["name", "more-vertical", 3, "svgIcon"], [3, "keydown.escape", "keydown.enter"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "kendoGridColumnMenuItem", "service"], [3, "showLock", "showStick", "kendoGridColumnMenuItem", "service", "expanded"], [1, "k-separator", 3, "borderColor"], [3, "kendoGridColumnMenuItem", "service", "expanded"], [3, "service", "kendoGridColumnMenuItem", "column"], [3, "service", "kendoGridColumnMenuItem"], [1, "k-separator"], [3, "keydown.escape"], ["kendoTabTitle", ""], ["kendoTabContent", ""], ["name", "filter", 3, "svgIcon"], [3, "keydown.shift.tab", "close", "column", "menuTabbingService", "filter", "actionsClass"], ["name", "sliders", 3, "svgIcon"], ["name", "columns", 3, "svgIcon"], [3, "close", "columns", "service"]],
    template: function ColumnMenuComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "a", 13, 0);
        ɵɵlistener("click", function ColumnMenuComponent_Template_a_click_0_listener($event) {
          ɵɵrestoreView(_r1);
          const anchor_r2 = ɵɵreference(1);
          const template_r3 = ɵɵreference(4);
          return ɵɵresetView(ctx.toggle($event, anchor_r2, template_r3));
        })("keydown.enter", function ColumnMenuComponent_Template_a_keydown_enter_0_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView($event.stopImmediatePropagation());
        });
        ɵɵelement(2, "kendo-icon-wrapper", 14);
        ɵɵelementEnd();
        ɵɵtemplate(3, ColumnMenuComponent_ng_template_3_Template, 2, 5, "ng-template", null, 1, ɵɵtemplateRefExtractor)(5, ColumnMenuComponent_ng_template_5_Template, 11, 10, "ng-template", null, 2, ɵɵtemplateRefExtractor)(7, ColumnMenuComponent_ng_template_7_Template, 5, 3, "ng-template", null, 3, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        ɵɵproperty("ngClass", ɵɵpureFunction1(6, _c263, ctx.isActive))("tabindex", ctx.tabIndex);
        ɵɵattribute("title", ctx.columnMenuTitle)("aria-expanded", ctx.isNavigable ? void 0 : false)("aria-haspopup", ctx.isNavigable ? void 0 : "dialog");
        ɵɵadvance(2);
        ɵɵproperty("svgIcon", ctx.moreVerticalIcon);
      }
    },
    dependencies: [NgClass, IconWrapperComponent, ColumnMenuContainerComponent, NgTemplateOutlet, ColumnMenuSortComponent, ColumnMenuItemDirective, ColumnMenuLockComponent, ColumnMenuStickComponent, ColumnMenuPositionComponent, ColumnMenuChooserComponent, ColumnMenuAutoSizeColumnComponent, ColumnMenuAutoSizeAllColumnsComponent, ColumnMenuFilterComponent, TabStripComponent, TabStripTabComponent, TabTitleDirective, TabContentDirective, FilterMenuContainerComponent, ColumnChooserContentComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuComponent, [{
    type: Component,
    args: [{
      providers: [ColumnMenuService, MenuTabbingService],
      selector: "kendo-grid-column-menu",
      template: `
        <a #anchor
          class="k-grid-header-menu k-grid-column-menu"
          [ngClass]="{ 'k-active': isActive }"
          (click)="toggle($event, anchor, template)"
          (keydown.enter)="$event.stopImmediatePropagation()"
          href="#"
          [tabindex]="tabIndex"
          [attr.title]="columnMenuTitle"
          [attr.aria-expanded]="isNavigable ? undefined : false"
          [attr.aria-haspopup]="isNavigable ? undefined : 'dialog'">
          <kendo-icon-wrapper
            name="more-vertical"
          [svgIcon]="moreVerticalIcon"></kendo-icon-wrapper>
        </a>
        <ng-template #template>
          <kendo-grid-columnmenu-container
            (keydown.escape)="close(true)"
            (keydown.enter)="$event.stopImmediatePropagation()">
            <ng-container
              [ngTemplateOutlet]="column.columnMenuTemplateRef || columnMenuTemplate || (settings.view === 'tabbed' ? tabbedInterfaceTemplate : defaultTemplate)"
              [ngTemplateOutletContext]="{ service: service, column: column }">
            </ng-container>
          </kendo-grid-columnmenu-container>
        </ng-template>
        <ng-template #defaultTemplate>
          <kendo-grid-columnmenu-container
            (keydown.escape)="close(true)"
            (keydown.enter)="$event.stopImmediatePropagation()">
            @if (hasSort) {
              <kendo-grid-columnmenu-sort #sortItem [kendoGridColumnMenuItem]="sortItem" [service]="service">
              </kendo-grid-columnmenu-sort>
            }
            @if (hasLock && !hasPosition) {
              <kendo-grid-columnmenu-lock #lockItem [kendoGridColumnMenuItem]="lockItem" [service]="service">
              </kendo-grid-columnmenu-lock>
            }
            @if (hasStick && !hasPosition) {
              <kendo-grid-columnmenu-stick #stickItem [kendoGridColumnMenuItem]="stickItem" [service]="service">
              </kendo-grid-columnmenu-stick>
            }
            @if (hasPosition) {
              <kendo-grid-columnmenu-position
                #positionItem
                [showLock]="hasLock"
                [showStick]="hasStick"
                [kendoGridColumnMenuItem]="positionItem"
                [service]="service"
                [expanded]="expandedPosition"
                >
              </kendo-grid-columnmenu-position>
            }
            @if (hasColumnChooser || hasAutoSizeColumn || hasAutoSizeAllColumns) {
              <span [style.borderColor]="'rgba(0, 0, 0, 0.08)'" class="k-separator"></span>
            }
            @if (hasColumnChooser) {
              <kendo-grid-columnmenu-chooser
                #chooserItem
                [kendoGridColumnMenuItem]="chooserItem"
                [service]="service"
                [expanded]="expandedColumns">
              </kendo-grid-columnmenu-chooser>
            }
            @if (hasAutoSizeColumn) {
              <kendo-grid-columnmenu-autosize-column
                #autoSizeColumnItem
                [service]="service"
                [kendoGridColumnMenuItem]="autoSizeColumnItem"
                [column]="column"
                >
              </kendo-grid-columnmenu-autosize-column>
            }

            @if (hasAutoSizeAllColumns) {
              <kendo-grid-columnmenu-autosize-all-columns
                #autoSizeAllColumnsItem
                [service]="service"
                [kendoGridColumnMenuItem]="autoSizeAllColumnsItem"
                >
              </kendo-grid-columnmenu-autosize-all-columns>
            }
            @if (hasColumnChooser || hasAutoSizeColumn || hasAutoSizeAllColumns) {
              <span [style.borderColor]="'rgba(0, 0, 0, 0.08)'" class="k-separator"></span>
            }
            @if (hasFilter) {
              <kendo-grid-columnmenu-filter
                #filterItem
                [kendoGridColumnMenuItem]="filterItem"
                [service]="service"
                [expanded]="expandedFilter">
              </kendo-grid-columnmenu-filter>
            }
          </kendo-grid-columnmenu-container>
        </ng-template>
        <ng-template #tabbedInterfaceTemplate>
          <kendo-tabstrip #tabstrip
            (keydown.escape)="close(true)">
            @if (hasFilter) {
              <kendo-tabstrip-tab>
                <ng-template kendoTabTitle>
                  <kendo-icon-wrapper
                    [attr.title]="ctx.localization.get('columnMenuFilterTabTitle')"
                    name="filter"
                    [svgIcon]="filterIcon">
                  </kendo-icon-wrapper>
                </ng-template>
                <ng-template kendoTabContent>
                  <kendo-grid-filter-menu-container
                    [column]="service.column"
                    [menuTabbingService]="service.menuTabbingService"
                    [filter]="service.filter"
                    [actionsClass]="actionsClass"
                    (keydown.shift.tab)="$event.stopImmediatePropagation()"
                    (close)="close()">
                  </kendo-grid-filter-menu-container>
                </ng-template>
              </kendo-tabstrip-tab>
            }
            @if (showGeneralTab) {
              <kendo-tabstrip-tab>
                <ng-template kendoTabTitle>
                  <kendo-icon-wrapper
                    [attr.title]="ctx.localization.get('columnMenuGeneralTabTitle')"
                    name="sliders"
                    [svgIcon]="slidersIcon">
                  </kendo-icon-wrapper>
                </ng-template>
                <ng-template kendoTabContent>
                  @if (hasSort) {
                    <kendo-grid-columnmenu-sort #sortItem [kendoGridColumnMenuItem]="sortItem" [service]="service">
                    </kendo-grid-columnmenu-sort>
                  }
                  @if (hasSort && (hasLock || hasStick || hasPosition || hasAutoSizeColumn || hasAutoSizeAllColumns)) {
                    <span [style.borderColor]="'rgba(0, 0, 0, 0.08)'" class="k-separator"></span>
                  }
                  @if (hasLock && !hasPosition) {
                    <kendo-grid-columnmenu-lock #lockItem [kendoGridColumnMenuItem]="lockItem" [service]="service">
                    </kendo-grid-columnmenu-lock>
                  }
                  @if (hasStick && !hasPosition) {
                    <kendo-grid-columnmenu-stick #stickItem [kendoGridColumnMenuItem]="stickItem" [service]="service">
                    </kendo-grid-columnmenu-stick>
                  }
                  @if ((hasLock || hasStick) && !hasPosition && (hasAutoSizeColumn || hasAutoSizeAllColumns)) {
                    <span [style.borderColor]="'rgba(0, 0, 0, 0.08)'" class="k-separator"></span>
                  }
                  @if (hasPosition) {
                    <kendo-grid-columnmenu-position
                      #positionItem
                      [showLock]="hasLock"
                      [showStick]="hasStick"
                      [kendoGridColumnMenuItem]="positionItem"
                      [service]="service"
                      [expanded]="expandedPosition">
                    </kendo-grid-columnmenu-position>
                  }
                  @if (hasPosition && (hasAutoSizeColumn || hasAutoSizeAllColumns)) {
                    <span [style.borderColor]="'rgba(0, 0, 0, 0.08)'" class="k-separator"></span>
                  }
                  @if (hasAutoSizeColumn) {
                    <kendo-grid-columnmenu-autosize-column
                      #autoSizeColumnItem
                      [service]="service"
                      [kendoGridColumnMenuItem]="autoSizeColumnItem"
                      [column]="column"
                      >
                    </kendo-grid-columnmenu-autosize-column>
                  }
                  @if (hasAutoSizeAllColumns) {
                    <kendo-grid-columnmenu-autosize-all-columns
                      #autoSizeAllColumnsItem
                      [service]="service"
                      [kendoGridColumnMenuItem]="autoSizeAllColumnsItem"
                      >
                    </kendo-grid-columnmenu-autosize-all-columns>
                  }
                </ng-template>
              </kendo-tabstrip-tab>
            }
            @if (hasColumnChooser) {
              <kendo-tabstrip-tab>
                <ng-template kendoTabTitle>
                  <kendo-icon-wrapper
                    [attr.title]="ctx.localization.get('columnMenuColumnsTabTitle')"
                    name="columns"
                    [svgIcon]="columnsIcon">
                  </kendo-icon-wrapper>
                </ng-template>
                <ng-template kendoTabContent>
                  <kendo-grid-column-chooser-content
                    [columns]="columns"
                    [service]="service"
                    (close)="close()"
                    >
                  </kendo-grid-column-chooser-content>
                </ng-template>
              </kendo-tabstrip-tab>
            }
          </kendo-tabstrip>
        </ng-template>

        `,
      standalone: true,
      imports: [NgClass, IconWrapperComponent, ColumnMenuContainerComponent, NgTemplateOutlet, ColumnMenuSortComponent, ColumnMenuItemDirective, ColumnMenuLockComponent, ColumnMenuStickComponent, ColumnMenuPositionComponent, ColumnMenuChooserComponent, ColumnMenuAutoSizeColumnComponent, ColumnMenuAutoSizeAllColumnsComponent, ColumnMenuFilterComponent, TabStripComponent, TabStripTabComponent, TabTitleDirective, TabContentDirective, FilterMenuContainerComponent, ColumnChooserContentComponent]
    }]
  }], () => [{
    type: NavigationService4
  }, {
    type: SinglePopupService
  }, {
    type: ColumnMenuService
  }, {
    type: ContextService
  }, {
    type: Renderer2
  }, {
    type: ChangeDetectorRef
  }, {
    type: ColumnInfoService
  }, {
    type: IdService,
    decorators: [{
      type: Optional
    }]
  }, {
    type: AdaptiveGridService
  }], {
    standalone: [{
      type: HostBinding,
      args: ["class.k-grid-column-menu-standalone"]
    }, {
      type: Input
    }],
    column: [{
      type: Input
    }],
    settings: [{
      type: Input
    }],
    sort: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    sortable: [{
      type: Input
    }],
    columnMenuTemplate: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    anchor: [{
      type: ViewChild,
      args: ["anchor", {
        static: true
      }]
    }],
    template: [{
      type: ViewChild,
      args: ["template", {
        static: true,
        read: TemplateRef
      }]
    }],
    defaultTemplate: [{
      type: ViewChild,
      args: ["defaultTemplate", {
        static: true,
        read: TemplateRef
      }]
    }],
    tabbedInterfaceTemplate: [{
      type: ViewChild,
      args: ["tabbedInterfaceTemplate", {
        static: true,
        read: TemplateRef
      }]
    }],
    tabStrip: [{
      type: ViewChild,
      args: [TabStripComponent]
    }]
  });
})();
var ExcelService = class _ExcelService {
  saveToExcel = new EventEmitter();
  exportClick = new EventEmitter();
  save(component) {
    if (this.saveToExcel.observers.length === 0) {
      if (isDevMode()) {
        throw new Error(GridConfigurationErrorMessages.requiredModule("excel", "ExcelModule", "<kendo-grid-excel>"));
      }
    } else {
      this.saveToExcel.emit(component);
    }
  }
  static ɵfac = function ExcelService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ExcelService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ExcelService,
    factory: _ExcelService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExcelService, [{
    type: Injectable
  }], null, null);
})();
var ExcelExportEvent = class extends PreventableEvent7 {
  workbook;
  /**
   * @hidden
   */
  constructor(workbook) {
    super();
    this.workbook = workbook;
  }
};
var fetchComponentData = (component) => {
  return {
    data: component.view.map((item) => item),
    group: component.group
  };
};
var toExcelColumn = (column) => {
  return {
    title: column.title,
    field: column.field,
    locked: Boolean(column.locked),
    width: column.width,
    level: column.level,
    hidden: !column.isVisible,
    groupHeaderTemplate: column.groupHeaderTemplate,
    groupHeaderColumnTemplate: column.groupHeaderColumnTemplate,
    groupFooterTemplate: column.groupFooterTemplate,
    footerTemplate: column.footerTemplate
  };
};
var toExcelColumns = (columns) => {
  const result = [];
  sortColumns(columns).forEach((column) => {
    if (column.isSpanColumn) {
      result.push(...toExcelColumns(column.childrenArray));
    } else {
      const excelColumn = toExcelColumn(column);
      if (column.isColumnGroup) {
        excelColumn.children = [excelColumn].concat(toExcelColumns(column.childrenArray));
      }
      result.push(excelColumn);
    }
  });
  return result;
};
var componentColumns = (component) => {
  const columns = toExcelColumns(component.columns.toArray());
  return orderBy(columns, [{
    field: "locked",
    dir: "desc"
  }]);
};
var ExcelComponent = class _ExcelComponent {
  ctx;
  zone;
  /**
   * Sets the file name for the exported Excel file.
   * @default "Export.xlsx"
   */
  fileName = "Export.xlsx";
  /**
   * Enables or disables column filtering in the Excel file. This option is different from the Grid's filtering feature.
   */
  filterable;
  /**
   * Sets the author of the workbook.
   */
  creator;
  /**
   * Sets the creation date of the workbook.
   */
  date;
  /**
   * Forwards the content to [`proxyURL`](#toc-proxyurl) even if the browser supports local file saving when set to `true`.
   */
  forceProxy;
  /**
   * Sets the URL of the server-side proxy that streams the file to the user. Use a proxy if the browser cannot save files locally.
   * You can also use a proxy to reduce memory usage by transmitting the file over the network.
   * Set [`forceProxy`](#toc-forceproxy) to `true` to skip client-side saving.
   * The proxy receives a POST request with specific parameters and returns the decoded file with the `"Content-Disposition"` header set to `attachment; filename="<fileName.xslx>"`.
   * For more details, see the [File Saver]({% slug overview_filesaver %}) documentation.
   */
  proxyURL;
  /**
   * Provides a function to get the exported data options. By default, uses the current Grid data and group.
   * Supply a custom function to export different data. Typically used to export all data, not just the current page [see example](slug:excelexport_grid#controlling-the-exported-data).
   */
  fetchData;
  /**
   * Sets options for cells inserted before the data, group, and footer cells to indicate the group hierarchy if the data is grouped.
   *
   */
  paddingCellOptions;
  /**
   * Sets the options for cells inserted before the header cells to align the headers and the column values when the data is grouped.
   */
  headerPaddingCellOptions;
  /**
   * Specifies if groups in the Excel file are collapsible.
   */
  collapsible;
  /**
   * @hidden
   */
  fileCreated = new EventEmitter();
  /**
   * @hidden
   */
  columns = new QueryList();
  saveSubscription;
  dataSubscription;
  constructor(excelService, ctx, zone) {
    this.ctx = ctx;
    this.zone = zone;
    this.saveSubscription = excelService.saveToExcel.subscribe(this.save.bind(this));
    this.ctx.excelComponent = this;
  }
  ngOnDestroy() {
    this.saveSubscription.unsubscribe();
    if (this.dataSubscription) {
      this.dataSubscription.unsubscribe();
    }
    if (this.ctx.excelComponent === this) {
      this.ctx.excelComponent = void 0;
    }
  }
  save(component) {
    const data = (this.fetchData || fetchComponentData)(component);
    const exportData = (result) => {
      delete this.dataSubscription;
      this.exportData(component, result);
    };
    if (data instanceof Promise) {
      data.then(exportData);
    } else if (data instanceof Observable) {
      this.dataSubscription = data.pipe(take(1)).subscribe(exportData);
    } else {
      exportData(data);
    }
  }
  exportData(component, result) {
    const options = workbookOptions({
      columns: this.columns.length ? this.columns : componentColumns(component),
      data: result.data,
      group: result.group,
      filterable: this.filterable,
      creator: this.creator,
      date: this.date,
      paddingCellOptions: this.paddingCellOptions,
      headerPaddingCellOptions: this.headerPaddingCellOptions,
      rtl: this.ctx.localization.rtl,
      collapsible: this.collapsible
    });
    const args = new ExcelExportEvent(options);
    component.excelExport.emit(args);
    if (!args.isDefaultPrevented()) {
      this.zone.runOutsideAngular(() => this.saveFile(options));
    }
  }
  saveFile(options) {
    toDataURL(options).then((dataURL) => {
      saveAs(dataURL, this.fileName, {
        forceProxy: this.forceProxy,
        proxyURL: this.proxyURL
      });
      this.fileCreated.emit();
    });
  }
  static ɵfac = function ExcelComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ExcelComponent)(ɵɵdirectiveInject(ExcelService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ExcelComponent,
    selectors: [["kendo-grid-excel"]],
    contentQueries: function ExcelComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, ColumnBase, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columns = _t);
      }
    },
    inputs: {
      fileName: "fileName",
      filterable: "filterable",
      creator: "creator",
      date: "date",
      forceProxy: "forceProxy",
      proxyURL: "proxyURL",
      fetchData: "fetchData",
      paddingCellOptions: "paddingCellOptions",
      headerPaddingCellOptions: "headerPaddingCellOptions",
      collapsible: "collapsible"
    },
    outputs: {
      fileCreated: "fileCreated"
    },
    decls: 0,
    vars: 0,
    template: function ExcelComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExcelComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-excel",
      template: ``,
      standalone: true
    }]
  }], () => [{
    type: ExcelService
  }, {
    type: ContextService
  }, {
    type: NgZone
  }], {
    fileName: [{
      type: Input
    }],
    filterable: [{
      type: Input
    }],
    creator: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    forceProxy: [{
      type: Input
    }],
    proxyURL: [{
      type: Input
    }],
    fetchData: [{
      type: Input
    }],
    paddingCellOptions: [{
      type: Input
    }],
    headerPaddingCellOptions: [{
      type: Input
    }],
    collapsible: [{
      type: Input
    }],
    fileCreated: [{
      type: Output
    }],
    columns: [{
      type: ContentChildren,
      args: [ColumnBase, {
        descendants: true
      }]
    }]
  });
})();
var ExcelCommandDirective = class _ExcelCommandDirective extends ButtonComponent {
  excelService;
  /**
   * @hidden
   */
  onClick(e) {
    e.preventDefault();
    this.excelService.exportClick.emit();
  }
  /**
   * @hidden
   */
  get excelClass() {
    return true;
  }
  constructor(excelService, element, renderer, ctx, ngZone) {
    super(element, renderer, null, ctx.localization, ngZone);
    this.excelService = excelService;
    this.ngZone = ngZone;
  }
  static ɵfac = function ExcelCommandDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ExcelCommandDirective)(ɵɵdirectiveInject(ExcelService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ExcelCommandDirective,
    selectors: [["", "kendoGridExcelCommand", ""]],
    hostVars: 2,
    hostBindings: function ExcelCommandDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("click", function ExcelCommandDirective_click_HostBindingHandler($event) {
          return ctx.onClick($event);
        });
      }
      if (rf & 2) {
        ɵɵclassProp("k-grid-excel", ctx.excelClass);
      }
    },
    features: [ɵɵInheritDefinitionFeature],
    attrs: _c283,
    ngContentSelectors: _c118,
    decls: 5,
    vars: 3,
    consts: [["innerCssClass", "k-button-icon", 3, "name", "svgIcon"], [1, "k-button-icon", "k-icon"], [1, "k-button-icon", 3, "ngClass"], [1, "k-button-text"], ["role", "presentation", 1, "k-image", 3, "src"]],
    template: function ExcelCommandDirective_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵconditionalCreate(0, ExcelCommandDirective_Conditional_0_Template, 1, 2, "kendo-icon-wrapper", 0);
        ɵɵconditionalCreate(1, ExcelCommandDirective_Conditional_1_Template, 2, 1, "span", 1);
        ɵɵconditionalCreate(2, ExcelCommandDirective_Conditional_2_Template, 1, 1, "span", 2);
        ɵɵelementStart(3, "span", 3);
        ɵɵprojection(4);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵconditional(ctx.icon || ctx.svgIcon ? 0 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.imageUrl ? 1 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.iconClass ? 2 : -1);
      }
    },
    dependencies: [IconWrapperComponent, NgClass],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExcelCommandDirective, [{
    type: Component,
    args: [{
      selector: "[kendoGridExcelCommand]",
      template: `
        @if (icon || svgIcon) {
          <kendo-icon-wrapper
            innerCssClass="k-button-icon"
            [name]="icon"
          [svgIcon]="svgIcon"></kendo-icon-wrapper>
        }
        @if (imageUrl) {
          <span class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
          </span>
        }
        @if (iconClass) {
          <span class="k-button-icon" [ngClass]="iconClass"></span>
        }
        <span class="k-button-text"><ng-content></ng-content></span>
        `,
      standalone: true,
      imports: [IconWrapperComponent, NgClass]
    }]
  }], () => [{
    type: ExcelService
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: ContextService
  }, {
    type: NgZone
  }], {
    onClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }],
    excelClass: [{
      type: HostBinding,
      args: ["class.k-grid-excel"]
    }]
  });
})();
var SuspendService = class _SuspendService {
  scroll = false;
  static ɵfac = function SuspendService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SuspendService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _SuspendService,
    factory: _SuspendService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SuspendService, [{
    type: Injectable
  }], null, null);
})();
var PDFService = class _PDFService {
  savePDF = new EventEmitter();
  drawPDF = new EventEmitter();
  exportClick = new EventEmitter();
  dataChanged = new EventEmitter();
  exporting;
  restoreDOMVirtualization = new EventEmitter();
  save(component) {
    this.emitEvent(this.savePDF, component);
  }
  draw(component, promise) {
    this.emitEvent(this.drawPDF, {
      component,
      promise
    });
  }
  /**
   * @hidden
   */
  emitEvent(emitter, args) {
    if (emitter.observers.length === 0) {
      if (isDevMode()) {
        throw new Error(GridConfigurationErrorMessages.requiredModule("PDF", "PDFModule", "<kendo-grid-pdf>"));
      }
    } else {
      emitter.emit(args);
    }
  }
  static ɵfac = function PDFService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PDFService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _PDFService,
    factory: _PDFService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PDFService, [{
    type: Injectable
  }], null, null);
})();
var PDFMarginComponent = class _PDFMarginComponent extends PDFExportMarginComponent {
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPDFMarginComponent_BaseFactory;
    return function PDFMarginComponent_Factory(__ngFactoryType__) {
      return (ɵPDFMarginComponent_BaseFactory || (ɵPDFMarginComponent_BaseFactory = ɵɵgetInheritedFactory(_PDFMarginComponent)))(__ngFactoryType__ || _PDFMarginComponent);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({
    type: _PDFMarginComponent,
    selectors: [["kendo-grid-pdf-margin"]],
    features: [ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function PDFMarginComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PDFMarginComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-pdf-margin",
      template: "",
      standalone: true
    }]
  }], null, null);
})();
var PDFTemplateDirective = class _PDFTemplateDirective extends PDFExportTemplateDirective {
  constructor(templateRef) {
    super(templateRef);
  }
  static ɵfac = function PDFTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PDFTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PDFTemplateDirective,
    selectors: [["", "kendoGridPDFTemplate", ""]],
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PDFTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridPDFTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var HEADER_CLASS = "k-grid-header";
var FOOTER_CLASS = "k-grid-footer";
var GRID_LIST = "KENDO-GRID-LIST";
var TABLE = "TABLE";
var matchesList = matchesNodeName(GRID_LIST);
var matchesTable = matchesNodeName(TABLE);
var suffix = (locked) => locked ? "locked" : "wrap";
var GridQuery = class {
  element;
  headerWrap;
  list;
  footerWrap;
  constructor(element) {
    this.element = element;
    this.list = findElement(element, matchesList);
  }
  content(locked) {
    return findElement(this.list, matchesClasses2(`k-grid-content${locked ? "-locked" : ""}`));
  }
  header(locked) {
    this.headerWrap = this.headerWrap || findElement(this.element, matchesClasses2(HEADER_CLASS));
    return findElement(this.headerWrap, matchesClasses2(`${HEADER_CLASS}-${suffix(locked)}`));
  }
  footer(locked) {
    this.footerWrap = this.footerWrap || findElement(this.element, matchesClasses2(FOOTER_CLASS));
    return findElement(this.footerWrap, matchesClasses2(`${FOOTER_CLASS}-${suffix(locked)}`));
  }
  table() {
    return findElement(this.element, matchesTable);
  }
};
var FIRST_CLASS = "k-first";
var INPUTS = ["input", "select", "textarea", "option"];
var cloneNode = (node) => {
  const clone = node.cloneNode(false);
  if (node._kendoExportVisual) {
    clone._kendoExportVisual = node._kendoExportVisual;
  }
  if (INPUTS.indexOf(String(node.nodeName).toLowerCase()) >= 0) {
    clone.removeAttribute("id");
    clone.removeAttribute("name");
    clone.value = node.value;
    clone.checked = node.checked;
    clone.selected = node.selected;
  }
  let child = node.firstChild;
  while (child) {
    clone.appendChild(cloneNode(child));
    child = child.nextSibling;
  }
  return clone;
};
var appendNodes = (element, nodes) => {
  const length2 = nodes.length;
  for (let idx4 = 0; idx4 < length2; idx4++) {
    element.appendChild(cloneNode(nodes[idx4]));
  }
};
var wrapTable = (table2, size) => {
  if (!isDocumentAvailable()) {
    return;
  }
  const wrapper = document.createElement("div");
  const classes = ["k-grid"];
  if (size && size !== "none") {
    classes.push(`k-grid-${size === "medium" ? "md" : "sm"}`);
  }
  wrapper.classList.add(...classes);
  wrapper.appendChild(table2);
  return wrapper;
};
var createTableElement = (sources) => {
  const sourceCount = sources.length;
  const element = cloneNode(sources[0]);
  const rowsCount = element.rows.length;
  if (sourceCount > 1) {
    for (let rowIdx = 0; rowIdx < rowsCount; rowIdx++) {
      for (let sourceIdx = 1; sourceIdx < sourceCount; sourceIdx++) {
        appendNodes(element.rows[rowIdx], sources[sourceIdx].rows[rowIdx].cells);
      }
    }
  }
  return element;
};
var setFirstCellClass = (header, headers) => {
  if (headers.length > 1 && header.rows.length > 1) {
    for (let idx4 = 1; idx4 < header.rows.length; idx4++) {
      const firstCellIndex = headers[0].rows[idx4].cells.length;
      const cell2 = header.rows[idx4].cells[firstCellIndex];
      if (String(cell2.className).indexOf(FIRST_CLASS) === -1) {
        cell2.className += ` ${FIRST_CLASS}`;
      }
    }
  }
};
var createTable = (colGroups, headers, bodies, footers, size) => {
  const table2 = document.createElement("table");
  const classes = ["k-table"];
  if (size && size !== "none") {
    classes.push(`k-table-${size === "medium" ? "md" : "sm"}`);
  }
  table2.classList.add(...classes);
  const colGroup = colGroups[0].cloneNode(true);
  for (let idx4 = 1; idx4 < colGroups.length; idx4++) {
    appendNodes(colGroup, colGroups[idx4].querySelectorAll("col"));
  }
  const body = createTableElement(bodies);
  let header;
  if (headers.length > 0) {
    header = createTableElement(headers);
    setFirstCellClass(header, headers);
  }
  table2.appendChild(colGroup);
  header && table2.appendChild(header);
  table2.appendChild(body);
  if (footers.length) {
    const footer = createTableElement(footers);
    table2.appendChild(footer);
  }
  return wrapTable(table2, size);
};
var exportElement = (wrapper, size) => {
  const query = new GridQuery(wrapper);
  const content2 = query.content();
  let result;
  if (content2) {
    const colGroups = [content2.querySelector("colgroup")];
    const bodies = [content2.querySelector("tbody")];
    const header = query.header();
    const footer = query.footer();
    const headers = [];
    const footers = [];
    if (header) {
      headers.push(header.querySelector("thead"));
    }
    if (footer) {
      footers.push(footer.querySelector("tfoot"));
    }
    const lockedContent = query.content(true);
    if (lockedContent) {
      if (headers.length > 0) {
        headers.unshift(query.header(true).querySelector("thead"));
      }
      colGroups.unshift(lockedContent.querySelector("colgroup"));
      bodies.unshift(lockedContent.querySelector("tbody"));
      if (footer) {
        footers.unshift(query.footer(true).querySelector("tfoot"));
      }
    }
    result = createTable(colGroups, headers, bodies, footers, size);
  } else {
    result = wrapTable(query.table().cloneNode(true), size);
  }
  return result;
};
var createElement$1 = (tagName, className) => {
  const element = document.createElement(tagName);
  if (className) {
    element.className = className;
  }
  return element;
};
var createDiv = (className) => {
  return createElement$1("div", className);
};
var PDFComponent = class _PDFComponent extends PDFExportComponent {
  pdfService;
  suspendService;
  ngZone;
  ctx;
  /**
   * Exports all Grid pages, starting from the first page.
   */
  allPages;
  /**
   * Sets the delay in milliseconds before exporting the Grid content.
   * Use this property when exporting complex components in Grid templates, such as charts or data-bound components with asynchronous data retrieval. ([See example]({% slug pdfexport_grid %}#toc-exporting-all-pages)).
   *
   * @default 0
   */
  delay = 0;
  columns = new QueryList();
  /**
   * @hidden
   */
  marginComponent;
  /**
   * @hidden
   */
  pageTemplateDirective;
  progress;
  component;
  container;
  skip;
  pageSize;
  originalHeight;
  originalOverflow;
  saveSubscription;
  drawSubscription;
  renderAllPages;
  originalColumns;
  restoreDOMVirtualization;
  constructor(pdfService, suspendService, ngZone, element, ctx) {
    super(element);
    this.pdfService = pdfService;
    this.suspendService = suspendService;
    this.ngZone = ngZone;
    this.ctx = ctx;
    this.saveSubscription = pdfService.savePDF.subscribe(this.savePDF.bind(this));
    this.drawSubscription = pdfService.drawPDF.subscribe(this.drawPDF.bind(this));
    this.reset = this.reset.bind(this);
    this.draw = this.draw.bind(this);
    if (this.ctx) {
      this.ctx.pdfComponent = this;
    }
  }
  ngOnDestroy() {
    this.saveSubscription.unsubscribe();
    this.drawSubscription.unsubscribe();
    this.reset();
    if (this.ctx?.pdfComponent === this) {
      this.ctx.pdfComponent = void 0;
    }
  }
  /**
   * @hidden
   */
  saveAs() {
    throw new Error(GridConfigurationErrorMessages.unsupportedMethod("saveAs", "GridComponent.saveAsPDF"));
  }
  /**
   * @hidden
   */
  export() {
    throw new Error(GridConfigurationErrorMessages.unsupportedMethod("export", "GridComponent.drawPDF"));
  }
  savePDF(component) {
    this.createPDF(component, this.draw);
  }
  drawPDF({
    component,
    promise
  }) {
    this.createPDF(component, () => {
      this.createExportGroup(promise);
    });
  }
  createPDF(component, callback) {
    const pageSize = component.pageSize;
    const total = component.view.total;
    const columns = this.columns.toArray();
    if (columns.length) {
      this.originalColumns = component.columns.toArray();
    }
    this.component = component;
    this.suspendService.scroll = true;
    this.pdfService.exporting = true;
    this.initProgress();
    this.renderAllPages = this.allPages && pageSize < total;
    if (component.isVirtual && component.pageable) {
      component.scrollable = "scrollable";
      this.restoreDOMVirtualization = true;
      if (!this.renderAllPages) {
        this.changePage(component.skip, pageSize, callback, columns);
        if (!(columns.length || component.virtualColumns)) {
          return;
        }
      }
    }
    if (this.renderAllPages) {
      this.skip = component.skip;
      this.pageSize = pageSize;
      this.changePage(0, total, callback, columns);
    } else if (columns.length || component.virtualColumns) {
      this.changeColumns(columns, callback);
    } else {
      callback();
    }
  }
  initProgress() {
    if (!isDocumentAvailable()) {
      return;
    }
    const wrapperElement = this.component.wrapper.nativeElement;
    const progress = this.progress = createDiv("k-loading-pdf-mask");
    const overlay = cloneNode(wrapperElement);
    progress.appendChild(overlay);
    progress.appendChild(createDiv("k-loading-color"));
    progress.appendChild(createElement$1("span", "k-i-loading k-icon"));
    this.originalHeight = wrapperElement.style.height;
    this.originalOverflow = wrapperElement.style.overflow;
    wrapperElement.style.height = wrapperElement.offsetHeight + "px";
    wrapperElement.style.overflow = "hidden";
    wrapperElement.appendChild(progress);
    this.applyScroll(overlay);
  }
  applyScroll(overlay) {
    const query = new GridQuery(this.component.wrapper.nativeElement);
    const content2 = query.content();
    if (content2) {
      const overlayQuery = new GridQuery(overlay);
      const overlayContent = overlayQuery.content();
      overlayContent.scrollTop = content2.scrollTop;
      overlayContent.scrollLeft = content2.scrollLeft;
      if (!this.ctx?.grid?.isStacked) {
        const header = query.header();
        const overlayHeader = overlayQuery.header();
        if (header && overlayHeader) {
          overlayHeader.scrollLeft = header.scrollLeft;
        }
      }
      const footer = query.footer();
      const overlayFooter = overlayQuery.footer();
      if (footer && overlayFooter) {
        overlayFooter.scrollLeft = footer.scrollLeft;
      }
      const lockedContent = query.content(true);
      if (lockedContent) {
        const overlayLockedContent = overlayQuery.content(true);
        overlayLockedContent.scrollTop = lockedContent.scrollTop;
        overlayLockedContent.scrollLeft = lockedContent.scrollLeft;
      }
    }
  }
  draw() {
    this.createExportElement((element) => {
      this.save(element, this.fileName);
    });
  }
  createExportGroup(promise) {
    this.createExportElement((element) => {
      this.exportElement(element).then((group2) => promise.resolve(group2));
    });
  }
  createExportElement(callback) {
    this.ngZone.runOutsideAngular(() => {
      const container = this.container = createDiv("k-grid-pdf-export-element");
      const element = exportElement(this.component.wrapper.nativeElement, this.ctx?.grid.size || "medium");
      container.appendChild(element);
      document.body.appendChild(container);
      callback(element);
    });
  }
  drawOptions() {
    const options = super.drawOptions();
    options._destructive = true;
    return options;
  }
  cleanup() {
    super.cleanup();
    this.pdfService.exporting = false;
    if (this.component) {
      const originalColumns = this.originalColumns;
      delete this.originalColumns;
      if (this.restoreDOMVirtualization) {
        this.component.scrollable = "virtual";
        this.pdfService.restoreDOMVirtualization.emit();
        this.restoreDOMVirtualization = false;
      }
      if (this.renderAllPages) {
        this.changePage(this.skip, this.pageSize, this.reset, originalColumns);
      } else if (originalColumns || this.component.virtualColumns) {
        this.changeColumns(originalColumns, this.reset);
      } else {
        this.reset();
      }
    } else {
      this.reset();
    }
    this.removeContainer();
  }
  removeContainer() {
    if (this.container) {
      document.body.removeChild(this.container);
      delete this.container;
    }
  }
  changePage(skip4, _take, callback, columns) {
    this.ngZone.run(() => {
      this.pdfService.dataChanged.pipe(take(1)).subscribe(() => {
        if (columns && columns.length || this.component.virtualColumns) {
          this.changeColumns(columns, callback);
        } else {
          this.onStable(callback);
        }
      });
      this.component.notifyPageChange("pdf", {
        skip: skip4,
        take: _take
      });
    });
  }
  changeColumns(columns, callback) {
    this.ngZone.run(() => {
      this.onStable(callback);
      if (columns && columns.length) {
        this.component.columns.reset(columns);
      }
    });
  }
  reset() {
    this.suspendService.scroll = false;
    this.renderAllPages = false;
    if (!this.component) {
      return;
    }
    const wrapperElement = this.component.wrapper.nativeElement;
    wrapperElement.removeChild(this.progress);
    wrapperElement.style.height = this.originalHeight;
    wrapperElement.style.overflow = this.originalOverflow;
    delete this.progress;
    delete this.component;
  }
  onStable(callback) {
    setTimeout(() => {
      let onStable = this.ngZone.onStable.asObservable().pipe(take(1));
      if (this.delay > 0) {
        onStable = onStable.pipe(delay(this.delay));
      }
      onStable.subscribe(callback);
    }, 0);
  }
  static ɵfac = function PDFComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PDFComponent)(ɵɵdirectiveInject(PDFService), ɵɵdirectiveInject(SuspendService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ContextService, 8));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PDFComponent,
    selectors: [["kendo-grid-pdf"]],
    contentQueries: function PDFComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, PDFMarginComponent, 5)(dirIndex, PDFTemplateDirective, 5)(dirIndex, ColumnBase2, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.marginComponent = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.pageTemplateDirective = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columns = _t);
      }
    },
    inputs: {
      allPages: "allPages",
      delay: "delay"
    },
    features: [ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function PDFComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PDFComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-pdf",
      template: "",
      standalone: true
    }]
  }], () => [{
    type: PDFService
  }, {
    type: SuspendService
  }, {
    type: NgZone
  }, {
    type: ElementRef
  }, {
    type: ContextService,
    decorators: [{
      type: Optional
    }]
  }], {
    allPages: [{
      type: Input
    }],
    delay: [{
      type: Input
    }],
    columns: [{
      type: ContentChildren,
      args: [ColumnBase2]
    }],
    marginComponent: [{
      type: ContentChild,
      args: [PDFMarginComponent, {
        static: false
      }]
    }],
    pageTemplateDirective: [{
      type: ContentChild,
      args: [PDFTemplateDirective, {
        static: false
      }]
    }]
  });
})();
var PDFCommandDirective = class _PDFCommandDirective extends ButtonComponent {
  pdfService;
  /**
   * @hidden
   */
  onClick(e) {
    e.preventDefault();
    this.pdfService.exportClick.emit();
  }
  /**
   * @hidden
   */
  get pdfClass() {
    return true;
  }
  constructor(pdfService, element, renderer, ctx, ngZone) {
    super(element, renderer, null, ctx.localization, ngZone);
    this.pdfService = pdfService;
    this.ngZone = ngZone;
  }
  static ɵfac = function PDFCommandDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PDFCommandDirective)(ɵɵdirectiveInject(PDFService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PDFCommandDirective,
    selectors: [["", "kendoGridPDFCommand", ""]],
    hostVars: 2,
    hostBindings: function PDFCommandDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("click", function PDFCommandDirective_click_HostBindingHandler($event) {
          return ctx.onClick($event);
        });
      }
      if (rf & 2) {
        ɵɵclassProp("k-grid-pdf", ctx.pdfClass);
      }
    },
    features: [ɵɵInheritDefinitionFeature],
    attrs: _c293,
    ngContentSelectors: _c118,
    decls: 5,
    vars: 3,
    consts: [["innerCssClass", "k-button-icon", 3, "name", "svgIcon"], [1, "k-button-icon", "k-icon"], [1, "k-button-icon", 3, "ngClass"], [1, "k-button-text"], ["role", "presentation", 1, "k-image", 3, "src"]],
    template: function PDFCommandDirective_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵconditionalCreate(0, PDFCommandDirective_Conditional_0_Template, 1, 2, "kendo-icon-wrapper", 0);
        ɵɵconditionalCreate(1, PDFCommandDirective_Conditional_1_Template, 2, 1, "span", 1);
        ɵɵconditionalCreate(2, PDFCommandDirective_Conditional_2_Template, 1, 1, "span", 2);
        ɵɵelementStart(3, "span", 3);
        ɵɵprojection(4);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵconditional(ctx.icon || ctx.svgIcon ? 0 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.imageUrl ? 1 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.iconClass ? 2 : -1);
      }
    },
    dependencies: [IconWrapperComponent, NgClass],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PDFCommandDirective, [{
    type: Component,
    args: [{
      selector: "[kendoGridPDFCommand]",
      template: `
        @if (icon || svgIcon) {
          <kendo-icon-wrapper
            innerCssClass="k-button-icon"
            [name]="icon"
          [svgIcon]="svgIcon"></kendo-icon-wrapper>
        }
        @if (imageUrl) {
          <span class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
          </span>
        }
        @if (iconClass) {
          <span class="k-button-icon" [ngClass]="iconClass"></span>
        }
        <span class="k-button-text"><ng-content></ng-content></span>
        `,
      standalone: true,
      imports: [IconWrapperComponent, NgClass]
    }]
  }], () => [{
    type: PDFService
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: ContextService
  }, {
    type: NgZone
  }], {
    onClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }],
    pdfClass: [{
      type: HostBinding,
      args: ["class.k-grid-pdf"]
    }]
  });
})();
var isFilterable = (settings) => settings !== false;
var hasFilterMenu = (settings) => typeof settings === "string" && settings.indexOf("menu") > -1;
var hasFilterRow = (settings) => settings === true || typeof settings === "string" && settings.indexOf("row") > -1;
var ColumnReorderService = class _ColumnReorderService {
  changes = new EventEmitter();
  reorder(e) {
    this.changes.emit(e);
  }
  static ɵfac = function ColumnReorderService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColumnReorderService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ColumnReorderService,
    factory: _ColumnReorderService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnReorderService, [{
    type: Injectable
  }], null, null);
})();
var ColumnReorderEvent = class extends PreventableEvent7 {
  /**
   * Represents the reordered column.
   */
  column;
  /**
   * Represents the new index of the column. This index is relative to the collection of columns.
   */
  newIndex;
  /**
   * Represents the original index of the column before reordering. This index is relative to the collection of columns.
   */
  oldIndex;
  /**
   * @hidden
   */
  constructor({
    column,
    newIndex,
    oldIndex
  }) {
    super();
    this.column = column;
    this.newIndex = newIndex;
    this.oldIndex = oldIndex;
  }
};
var fromPercentage = (value2, percent) => {
  const sign = percent < 0 ? -1 : 1;
  return Math.ceil(Math.abs(percent) / 100 * value2) * sign;
};
var toPercentage = (value2, whole) => value2 / whole * 100;
var headerWidth = (handle) => handle.nativeElement.parentElement.getBoundingClientRect().width;
var adjacentColumnWidth = (handle) => handle.nativeElement.parentElement.nextElementSibling?.getBoundingClientRect().width;
var adjacentColumnInGroupWidth = (handle, rowIndex, colIndex) => {
  const tableElement = handle.nativeElement.closest(".k-grid-header-table");
  const selector = (rowAttribute) => `tr[${rowAttribute}="${rowIndex}"] th[aria-colindex="${colIndex}"]`;
  const thElement = tableElement.querySelector([selector("aria-rowindex"), selector("data-kendo-grid-row-index")]);
  return thElement.getBoundingClientRect().width;
};
var allLeafColumns = (columns) => expandColumns(columns).filter((c) => !c.isColumnGroup);
var createMoveStream2 = (service, draggable) => (mouseDown) => draggable.kendoDrag.pipe(takeUntil(draggable.kendoRelease.pipe(tap(() => service.end()))), map(({
  pageX
}) => ({
  originalX: mouseDown.pageX,
  pageX
})));
var preventOnDblClick2 = (release) => (mouseDown) => of(mouseDown).pipe(delay(150), takeUntil(release));
var isInSpanColumn = (column) => !!(column.parent && column.parent.isSpanColumn);
var indexOf = (target, list2) => {
  let index = 0;
  let ignore = 0;
  let skip4 = 0;
  while (index < list2.length) {
    const current = list2[index];
    const isParentSpanColumn = isInSpanColumn(current);
    if (current === target) {
      break;
    }
    if (ignore-- <= 0 && isParentSpanColumn) {
      ignore = current.parent.children.length - 1;
      skip4 += ignore;
    }
    index++;
  }
  return index - skip4;
};
var ColumnHandleDirective = class _ColumnHandleDirective {
  draggable;
  element;
  service;
  zone;
  cdr;
  ctx;
  columnInfoService;
  isLast;
  columns = [];
  column;
  get visible() {
    if (this.isConstrainedMode && (this.isLast || this.isLastInGroup(this.column))) {
      return "none";
    }
    return this.column.resizable ? "block" : "none";
  }
  get leftStyle() {
    return isTruthy(this.rtl) ? 0 : null;
  }
  get rightStyle() {
    return isTruthy(this.rtl) ? null : 0;
  }
  get isConstrainedMode() {
    const isConstrainedMode = this.ctx.grid?.resizable === "constrained";
    const isUnconstrainedMode = this.ctx.grid?.resizable === true || this.ctx.grid?.resizable === "unconstrained";
    const constrainedNoShift = isConstrainedMode && !this.service.isShiftPressed;
    const unconstrainedWithShift = isUnconstrainedMode && this.service.isShiftPressed;
    return constrainedNoShift || unconstrainedWithShift;
  }
  subscriptions = new Subscription();
  rtl = false;
  totalChildrenSum = 0;
  childrenColumns = [];
  minWidthTotal = 0;
  foundColumn;
  autoFit() {
    this.service.autoFitResize = true;
    const allLeafs = allLeafColumns(this.columns);
    const currentLeafs = leafColumns([this.column]).filter((column) => isTruthy(column.resizable));
    const columnInfo = currentLeafs.map((column) => {
      const isParentSpan = isInSpanColumn(column);
      const isLastInSpan = isParentSpan ? column.parent.children.last === column : false;
      const index = indexOf(column, allLeafs);
      return {
        column,
        headerIndex: this.columnsForLevel(column.level).indexOf(column),
        index,
        isLastInSpan,
        isParentSpan,
        level: column.level
      };
    });
    currentLeafs.forEach((column) => column.width = 0);
    this.service.measureColumns(columnInfo);
  }
  constructor(draggable, element, service, zone, cdr, ctx, columnInfoService) {
    this.draggable = draggable;
    this.element = element;
    this.service = service;
    this.zone = zone;
    this.cdr = cdr;
    this.ctx = ctx;
    this.columnInfoService = columnInfoService;
  }
  ngOnInit() {
    if (isDocumentAvailable() && isBlank2(this.column.width)) {
      this.column.implicitWidth = headerWidth(this.element);
    }
    const service = this.service.changes.pipe(filter(() => this.column.resizable), filter((e) => isPresent7(e.columns.find((column) => column === this.column))));
    this.subscriptions.add(service.pipe(filter((e) => e.type === "start")).subscribe(this.initState.bind(this)));
    this.subscriptions.add(service.pipe(filter((e) => e.type === "resizeColumn")).subscribe(this.resize.bind(this)));
    this.subscriptions.add(this.service.changes.pipe(
      filter((e) => e.type === "start"),
      filter(this.shouldUpdate.bind(this)),
      take(1)
      //on first resize only
    ).subscribe(this.initColumnWidth.bind(this)));
    this.subscriptions.add(this.zone.runOutsideAngular(() => this.draggable.kendoPress.pipe(tap(this.stopPropagation), tap(() => this.service.start(this.column)), switchMap(preventOnDblClick2(this.draggable.kendoRelease)), switchMap(createMoveStream2(this.service, this.draggable))).subscribe(({
      pageX,
      originalX
    }) => {
      const delta = pageX - originalX;
      const percent = toPercentage(delta, this.column.resizeStartWidth || this.column.width);
      this.service.resizeColumns(percent);
    })));
    this.subscriptions.add(service.pipe(filter((e) => e.type === "autoFitComplete")).subscribe(this.sizeToFit.bind(this)));
    this.subscriptions.add(service.pipe(filter((e) => e.type === "triggerAutoFit")).subscribe(this.autoFit.bind(this)));
    this.subscriptions.add(this.ctx.localization.changes.subscribe(({
      rtl
    }) => this.rtl = rtl));
  }
  ngOnDestroy() {
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
    }
  }
  shouldUpdate() {
    return !allLeafColumns(this.columns).map((column) => column.width || this.isConstrainedMode && !column.width && column.implicitWidth).some(isBlank2);
  }
  initColumnWidth() {
    if (!isDocumentAvailable()) {
      return;
    }
    this.column.width = headerWidth(this.element);
    if (this.isConstrainedMode) {
      this.column.resizeStartWidth = this.column.width;
    }
  }
  initState() {
    if (!isDocumentAvailable()) {
      return;
    }
    this.column.resizeStartWidth = headerWidth(this.element);
    if (this.isConstrainedMode && !this.service.adjacentColumn) {
      this.setAdjacentColumn();
    }
    this.service.resizedColumn({
      column: this.column,
      oldWidth: this.column.resizeStartWidth
    });
  }
  resize({
    deltaPercent
  }) {
    let delta = fromPercentage(this.column.resizeStartWidth, deltaPercent);
    if (isTruthy(this.rtl)) {
      delta *= -1;
    }
    let newWidth = Math.max(this.column.resizeStartWidth + delta, this.column.minResizableWidth);
    if (isPresent7(this.column.maxResizableWidth)) {
      newWidth = Math.min(newWidth, this.column.maxResizableWidth);
    }
    if (this.isConstrainedMode) {
      newWidth = this.calcNewColumnWidth(newWidth);
    }
    const tableDelta = this.getTableDelta(newWidth, delta);
    this.updateWidth(this.column, newWidth);
    this.service.resizeTable(this.column, tableDelta);
  }
  sizeToFit({
    columns,
    widths
  }) {
    const index = columns.indexOf(this.column);
    const width2 = Math.max(...widths.map((w) => w[index])) + 1;
    const tableDelta = width2 - this.column.resizeStartWidth;
    this.updateWidth(this.column, width2);
    this.service.resizeTable(this.column, tableDelta);
  }
  updateWidth(column, width2) {
    if (this.isConstrainedMode && this.service.adjacentColumn && !this.service.autoFitResize) {
      this.updateWidthsOfResizedColumns(column, width2);
    }
    column.width = width2;
    this.columnInfoService.hiddenColumns.forEach((col) => {
      if (isBlank2(col.width) && isPresent7(col.implicitWidth)) {
        col.width = col.implicitWidth;
      }
    });
    this.cdr.markForCheck();
  }
  updateWidthsOfResizedColumns(column, width2) {
    let adjacentColumnNewWidth = column.resizeStartWidth + this.service.adjacentColumn.resizeStartWidth - width2;
    if (this.service.draggedGroupColumn && column.parent) {
      this.updateWidthOfDraggedColumn(column, width2);
      this.setGroupWidths(this.service.draggedGroupColumn);
    } else if (!this.service.draggedGroupColumn && !column.parent && this.service.adjacentColumn.parent) {
      this.service.adjacentColumn.parent.width = column.width + this.service.adjacentColumn.parent.width - width2;
      this.service.adjacentColumn.width = adjacentColumnNewWidth;
    } else if (!this.service.draggedGroupColumn && column.parent && this.service.adjacentColumn.parent) {
      adjacentColumnNewWidth = column.width + this.service.adjacentColumn.width - width2;
      this.service.adjacentColumn.width = adjacentColumnNewWidth;
      const filteredColumns = this.service.adjacentColumn.parent.children.filter((c) => c !== this.service.adjacentColumn);
      const filteredColumnsWidth = filteredColumns.reduce((acc, c) => acc + c.width, 0);
      this.service.adjacentColumn.parent.width = adjacentColumnNewWidth + filteredColumnsWidth;
      this.setGroupWidths(this.service.adjacentColumn.parent);
    } else if (adjacentColumnNewWidth > this.service.adjacentColumn.minResizableWidth) {
      this.service.adjacentColumn.width = adjacentColumnNewWidth;
    }
  }
  calcNewColumnWidth(newWidth) {
    let maxAllowedResizableWidth;
    if (!this.service.adjacentColumn.parent) {
      maxAllowedResizableWidth = this.column.width + this.service.adjacentColumn.width - this.service.adjacentColumn.minResizableWidth;
      if (!this.column.parent) {
        maxAllowedResizableWidth = this.column.resizeStartWidth + this.service.adjacentColumn.resizeStartWidth - this.service.adjacentColumn.minResizableWidth;
        if (this.service.adjacentColumn.maxResizableWidth) {
          const minResizableWidth = this.column.resizeStartWidth + this.service.adjacentColumn.resizeStartWidth - this.service.adjacentColumn.maxResizableWidth;
          maxAllowedResizableWidth = this.column.resizeStartWidth + this.service.adjacentColumn.resizeStartWidth - this.service.adjacentColumn.minResizableWidth;
          this.column.minResizableWidth = minResizableWidth;
          this.column.maxResizableWidth = maxAllowedResizableWidth;
        }
      }
    } else {
      maxAllowedResizableWidth = this.column.width + this.service.adjacentColumn.width;
      newWidth = Math.min(newWidth, maxAllowedResizableWidth);
      this.minWidthTotal = 0;
      const minResizableWidth = this.minAdjacentColumnWidth(this.service.adjacentColumn);
      maxAllowedResizableWidth -= minResizableWidth;
    }
    return Math.min(newWidth, maxAllowedResizableWidth - 1);
  }
  setAdjacentColumn() {
    const columnsForLevel = this.columnsForLevel(this.column.level);
    if (this.column.parent) {
      if (this.column.isReordered) {
        this.service.adjacentColumn = columnsForLevel.find((c) => c.orderIndex === this.column.orderIndex + 1);
        this.service.adjacentColumn.resizeStartWidth = this.service.adjacentColumn.width;
      } else {
        const columnIndex = columnsForLevel.indexOf(this.column);
        this.service.adjacentColumn = columnsForLevel[columnIndex + 1];
        this.service.adjacentColumn.resizeStartWidth = adjacentColumnWidth(this.element);
        const parentColumnChildren = Array.from(this.column.parent.children);
        const indexOfCurrentColumn = parentColumnChildren.indexOf(this.column);
        let adjacentColumn;
        if (indexOfCurrentColumn + 1 <= parentColumnChildren.length - 1) {
          adjacentColumn = parentColumnChildren[indexOfCurrentColumn + 1];
          if (adjacentColumn?.isColumnGroup) {
            this.service.adjacentColumn = adjacentColumn;
          }
        }
      }
      if (this.service.adjacentColumn.isColumnGroup) {
        this.foundColumn = null;
        this.service.adjacentColumn = this.firstGroupChild(this.service.adjacentColumn);
      }
      if (this.column.isColumnGroup) {
        this.service.draggedGroupColumn = this.column;
      }
    } else if (this.column.isColumnGroup) {
      if (this.column.isReordered) {
        this.service.adjacentColumn = columnsForLevel.find((c) => c.orderIndex === this.column.orderIndex + 1);
      } else {
        this.service.adjacentColumn = columnsForLevel[columnsForLevel.indexOf(this.column) + 1];
      }
      this.service.adjacentColumn.resizeStartWidth = adjacentColumnWidth(this.element);
      if (this.service.adjacentColumn.isColumnGroup) {
        this.foundColumn = null;
        this.service.adjacentColumn = this.firstGroupChild(this.service.adjacentColumn);
      }
      this.service.adjacentColumn.resizeStartWidth = this.service.adjacentColumn.width;
      this.service.draggedGroupColumn = this.column;
    } else {
      if (this.column.isReordered) {
        this.service.adjacentColumn = columnsForLevel.find((col) => col.orderIndex === this.column.orderIndex + 1);
      } else {
        let adjacentColumn = columnsForLevel.find((c) => c.leafIndex === this.column.leafIndex + 1);
        if (!adjacentColumn) {
          const indexOfCurrentColumn = columnsForLevel.indexOf(this.column);
          adjacentColumn = columnsForLevel[indexOfCurrentColumn + 1];
        }
        this.service.adjacentColumn = adjacentColumn;
      }
      if (!this.service.adjacentColumn.parent) {
        this.service.adjacentColumn.resizeStartWidth = adjacentColumnWidth(this.element);
      }
      if (this.service.adjacentColumn.isColumnGroup) {
        this.foundColumn = null;
        this.service.adjacentColumn = this.firstGroupChild(this.service.adjacentColumn);
        const rowIndex = this.service.adjacentColumn.level + 1;
        const colIndex = this.service.adjacentColumn.leafIndex + 1;
        this.service.adjacentColumn.resizeStartWidth = adjacentColumnInGroupWidth(this.element, rowIndex, colIndex);
      }
    }
    this.service.resizedColumn({
      column: this.service.adjacentColumn,
      oldWidth: this.service.adjacentColumn.resizeStartWidth
    });
  }
  firstGroupChild(column) {
    Array.from(column.children).sort((a, b) => a.orderIndex - b.orderIndex).forEach((c, idx4) => {
      if (idx4 === 0 && !c.isColumnGroup) {
        if (!this.foundColumn) {
          this.foundColumn = c;
        }
      } else if (c.isColumnGroup) {
        this.firstGroupChild(c);
      }
    });
    return this.foundColumn;
  }
  setGroupWidths(column) {
    const childrenWidths = column.children.reduce((acc, c) => acc + c.width, 0);
    column.width = childrenWidths;
    column.children.forEach((c) => {
      if (c.isColumnGroup) {
        this.setGroupWidths(c);
      }
    });
  }
  updateWidthOfDraggedColumn(column, width2) {
    this.totalChildrenSum = 0;
    this.childrenColumns = [];
    this.calcChildrenWidth(this.service.draggedGroupColumn);
    const childrenWidthNotIncludingColumn = this.childrenColumns.reduce((acc, col) => {
      return col !== column ? acc + col.width : acc;
    }, 0);
    this.service.draggedGroupColumn.width = childrenWidthNotIncludingColumn + width2;
    if (this.service.adjacentColumn.minResizableWidth <= this.totalChildrenSum + this.service.adjacentColumn.resizeStartWidth - width2 - childrenWidthNotIncludingColumn) {
      this.service.adjacentColumn.width = this.totalChildrenSum + this.service.adjacentColumn.resizeStartWidth - width2 - childrenWidthNotIncludingColumn;
    }
  }
  calcChildrenWidth(column) {
    const columnChildren = Array.from(column.children);
    const childrenNoGroups = columnChildren.filter((c) => !c.isColumnGroup);
    const childrenGroups = columnChildren.filter((c) => c.isColumnGroup);
    childrenNoGroups.forEach((col) => {
      if (this.childrenColumns.indexOf(col) === -1) {
        this.childrenColumns.push(col);
      }
    });
    this.totalChildrenSum += childrenNoGroups.reduce((acc, col) => acc + col.resizeStartWidth, 0);
    childrenGroups.forEach((col) => {
      this.calcChildrenWidth(col);
    });
  }
  columnsForLevel(level) {
    return columnsToRender(this.columns ? this.columns.filter((column) => column.level === level) : []);
  }
  minAdjacentColumnWidth(column) {
    if (column.isColumnGroup) {
      Array.from(column.children).forEach((c) => {
        this.minAdjacentColumnWidth(c);
      });
    } else {
      this.minWidthTotal += column.minResizableWidth;
      if (column.width < column.minResizableWidth) {
        column.width = column.minResizableWidth;
      }
    }
    return this.minWidthTotal;
  }
  getTableDelta(newWidth, delta) {
    const minWidth = this.column.minResizableWidth;
    const maxWidth = this.column.maxResizableWidth;
    const startWidth = this.column.resizeStartWidth;
    const isAboveMin = newWidth > minWidth;
    const isBelowMax = newWidth < maxWidth;
    const isInBoundaries = isPresent7(maxWidth) ? isAboveMin && isBelowMax : isAboveMin;
    if (isInBoundaries) {
      return delta;
    } else if (newWidth <= minWidth) {
      return minWidth - startWidth;
    } else {
      return startWidth - maxWidth;
    }
  }
  stopPropagation = ({
    originalEvent: event
  }) => {
    this.service.isShiftPressed = event.shiftKey;
    event.stopPropagation();
    event.preventDefault();
  };
  isLastInGroup(column) {
    if (column.parent) {
      const groupChildren = Array.from(column.parent.children);
      const indexOfCurrentColumn = groupChildren.indexOf(column);
      if (column.isReordered || column.orderIndex > 0 || column.isReordered && column.orderIndex === 0) {
        return column.orderIndex - groupChildren[0].orderIndex === groupChildren.length - 1;
      } else {
        return indexOfCurrentColumn === groupChildren.length - 1;
      }
    }
  }
  static ɵfac = function ColumnHandleDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColumnHandleDirective)(ɵɵdirectiveInject(DraggableDirective, 1), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ColumnResizingService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ColumnInfoService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ColumnHandleDirective,
    selectors: [["", "kendoGridColumnHandle", ""]],
    hostVars: 6,
    hostBindings: function ColumnHandleDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("dblclick", function ColumnHandleDirective_dblclick_HostBindingHandler() {
          return ctx.autoFit();
        });
      }
      if (rf & 2) {
        ɵɵstyleProp("display", ctx.visible)("left", ctx.leftStyle)("right", ctx.rightStyle);
      }
    },
    inputs: {
      isLast: "isLast",
      columns: "columns",
      column: "column"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnHandleDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridColumnHandle]",
      standalone: true
    }]
  }], () => [{
    type: DraggableDirective,
    decorators: [{
      type: Host
    }]
  }, {
    type: ElementRef
  }, {
    type: ColumnResizingService
  }, {
    type: NgZone
  }, {
    type: ChangeDetectorRef
  }, {
    type: ContextService
  }, {
    type: ColumnInfoService
  }], {
    isLast: [{
      type: Input
    }],
    columns: [{
      type: Input
    }],
    column: [{
      type: Input
    }],
    visible: [{
      type: HostBinding,
      args: ["style.display"]
    }],
    leftStyle: [{
      type: HostBinding,
      args: ["style.left"]
    }],
    rightStyle: [{
      type: HostBinding,
      args: ["style.right"]
    }],
    autoFit: [{
      type: HostListener,
      args: ["dblclick"]
    }]
  });
})();
var CellSelectionAggregateService = class _CellSelectionAggregateService {
  ctx;
  columnInfoService;
  selectedItems = [];
  groupedAggregates = {
    dates: [],
    numbers: [],
    booleans: []
  };
  aggregates = {
    sum: null,
    average: null,
    min: null,
    max: null,
    count: null,
    isTrue: null,
    isFalse: null,
    earliest: null,
    latest: null
  };
  sub = new Subscription();
  constructor(ctx, columnInfoService) {
    this.ctx = ctx;
    this.columnInfoService = columnInfoService;
  }
  ngOnDestroy() {
    this.sub.unsubscribe();
  }
  isAggregateIncluded(aggregate) {
    const {
      cellAggregates
    } = this.ctx.grid.selectable;
    if (typeof cellAggregates !== "boolean") {
      return cellAggregates?.includes(aggregate);
    }
    return true;
  }
  init() {
    this.sub.add(this.ctx.grid.dataStateChange.subscribe(() => {
      this.nullifyAggregates();
      if (this.isAggregateIncluded("count")) {
        this.aggregates["count"] = 0;
      }
    }));
    if (this.ctx.grid.selectable.cellAggregates) {
      if (this.isAggregateIncluded("count")) {
        this.aggregates["count"] = 0;
      }
      const selectionDirective = this.ctx.grid.selectionDirective;
      if (selectionDirective && !this.isRowSelection) {
        this.selectedItems = selectionDirective.selectedKeys;
      }
    }
  }
  onSelectionChange(selectionArgs) {
    this.handleSelectedItems(selectionArgs);
    this.nullifyAggregates();
    this.handleAggregateChanges();
    return this.aggregates;
  }
  get isRowSelection() {
    return typeof this.ctx.grid.selectable === "boolean" || !this.ctx.grid.selectable.cell;
  }
  handleAggregateChanges() {
    const lockedColumns = this.columnInfoService.lockedLeafColumns.toArray();
    const nonLockedColumns = this.columnInfoService.nonLockedLeafColumns.toArray();
    const selectedItemsLength = this.selectedItems.length;
    const columns = [...lockedColumns, ...nonLockedColumns];
    const fields = columns.map((col) => col.field);
    if (this.isAggregateIncluded("count")) {
      this.aggregates["count"] = this.isRowSelection ? selectedItemsLength * columns.length : selectedItemsLength;
    }
    this.selectedItems.forEach((item) => {
      if (this.isRowSelection) {
        fields.forEach((field) => {
          const cellValue = item.dataItem;
          if (cellValue && cellValue.hasOwnProperty(field)) {
            const cellValue2 = item.dataItem[field];
            this.groupAggregates(cellValue2);
          }
        });
      } else if (!this.isRowSelection) {
        const selectedItem = this.ctx.grid.flatData.flatMap(recursiveFlatMap)[item.itemKey];
        const field = fields[item.columnKey];
        if (selectedItem && selectedItem.hasOwnProperty(field)) {
          const cellValue = selectedItem[fields[item.columnKey]];
          this.groupAggregates(cellValue);
        }
      }
    });
    this.calculateAggregates();
  }
  groupAggregates(aggregate) {
    if (typeof aggregate === "number") {
      this.groupedAggregates.numbers.push(aggregate);
    } else if (typeof aggregate === "boolean") {
      this.groupedAggregates.booleans.push(aggregate);
    } else if (aggregate instanceof Date) {
      this.groupedAggregates.dates.push(aggregate);
    }
  }
  calculateAggregates() {
    if (this.groupedAggregates.numbers.length > 0) {
      if (this.isAggregateIncluded("min")) {
        this.aggregates["min"] = Math.min(...this.groupedAggregates.numbers);
      }
      if (this.isAggregateIncluded("max")) {
        this.aggregates["max"] = Math.max(...this.groupedAggregates.numbers);
      }
      if (this.isAggregateIncluded("sum")) {
        this.aggregates["sum"] = this.groupedAggregates.numbers.reduce((acc, curr) => acc += curr, 0);
      }
      if (this.isAggregateIncluded("average")) {
        this.aggregates["average"] = this.aggregates["sum"] / this.groupedAggregates.numbers.length;
      }
    }
    if (this.groupedAggregates.booleans.length > 0) {
      if (this.isAggregateIncluded("isTrue")) {
        const isTrueCount = this.groupedAggregates.booleans.filter((bool) => bool).length;
        this.aggregates["isTrue"] = isTrueCount > 0 ? isTrueCount : null;
      }
      if (this.isAggregateIncluded("isFalse")) {
        const isFalseCount = this.groupedAggregates.booleans.length - this.aggregates["isTrue"];
        this.aggregates["isFalse"] = isFalseCount > 0 ? isFalseCount : null;
      }
    }
    if (this.groupedAggregates.dates.length > 0) {
      if (this.isAggregateIncluded("earliest")) {
        this.aggregates["earliest"] = new Date(Math.min(...this.groupedAggregates.dates));
      }
      if (this.isAggregateIncluded("latest")) {
        this.aggregates["latest"] = new Date(Math.max(...this.groupedAggregates.dates));
      }
    }
  }
  handleSelectedItems(selectionArgs) {
    const rowOrCellSelect = `${this.isRowSelection ? "selectedRows" : "selectedCells"}`;
    const rowOrCellDeselect = `${this.isRowSelection ? "deselectedRows" : "deselectedCells"}`;
    const selectedItems = selectionArgs[rowOrCellSelect];
    const deselectedItems = selectionArgs[rowOrCellDeselect];
    if (!this.isRowSelection) {
      deselectedItems.forEach((item, index) => {
        if (index + 1 < deselectedItems.length) {
          if (item.itemKey === deselectedItems[index + 1].itemKey && item.columnKey === deselectedItems[index + 1].columnKey) {
            deselectedItems.splice(index, 1);
          }
        }
      });
    }
    if (selectedItems.length > 0) {
      selectedItems.forEach((item) => {
        this.selectedItems = [...this.selectedItems, item];
      });
    }
    if (deselectedItems.length > 0) {
      if (this.isRowSelection) {
        deselectedItems.forEach((row2) => {
          this.selectedItems = this.selectedItems.filter((elem) => elem.dataItem !== row2.dataItem);
        });
      } else {
        deselectedItems.forEach((cell2) => {
          const index = this.selectedItems.findIndex((elem) => elem.itemKey === cell2.itemKey && elem.columnKey === cell2.columnKey);
          this.selectedItems.splice(index, 1);
        });
      }
    }
  }
  nullifyAggregates() {
    this.groupedAggregates = {
      dates: [],
      numbers: [],
      booleans: []
    };
    this.aggregates["count"] = null;
    this.aggregates["sum"] = this.aggregates["average"] = null;
    this.aggregates["max"] = this.aggregates["min"] = null;
    this.aggregates["isFalse"] = this.aggregates["isTrue"] = null;
    this.aggregates["earliest"] = this.aggregates["latest"] = null;
  }
  static ɵfac = function CellSelectionAggregateService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CellSelectionAggregateService)(ɵɵinject(ContextService), ɵɵinject(ColumnInfoService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _CellSelectionAggregateService,
    factory: _CellSelectionAggregateService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CellSelectionAggregateService, [{
    type: Injectable
  }], () => [{
    type: ContextService
  }, {
    type: ColumnInfoService
  }], null);
})();
var SelectionService2 = class _SelectionService {
  domEvents;
  aggregateService;
  localDataChangesService;
  navigationService;
  ctxService;
  changes = new EventEmitter();
  lastSelectionStartIndex;
  currentSelection = [];
  nonSelectableRows = /* @__PURE__ */ new Map();
  selectAllChecked = false;
  settings;
  active = false;
  aggregates;
  get enableMarquee() {
    const checkboxOnly = this.settings && typeof this.settings === "object" && this.settings.checkboxOnly;
    if (!this.settings || checkboxOnly) {
      return false;
    }
    const selectableSettings = this.settings.selectable;
    const dragAndMultiple = typeof selectableSettings === "object" && isPresent7(selectableSettings) && selectableSettings.mode === "multiple" && selectableSettings.enabled !== false && !selectableSettings.checkboxOnly && selectableSettings.drag;
    return this.active && dragAndMultiple;
  }
  mouseDownEventArgs;
  dragging = false;
  get hasNonSelectable() {
    return this.nonSelectableRows.size > 0;
  }
  cellClickSubscription;
  mousedownSubscription;
  dataChangedSubscription;
  lastSelectionData = {};
  _selectAllState;
  constructor(domEvents, aggregateService, localDataChangesService, navigationService, ctxService) {
    this.domEvents = domEvents;
    this.aggregateService = aggregateService;
    this.localDataChangesService = localDataChangesService;
    this.navigationService = navigationService;
    this.ctxService = ctxService;
    this.addSubscriptions();
  }
  init(settings) {
    this.settings = settings;
    if (!isPresent7(this.lastSelectionStartIndex)) {
      this.lastSelectionStartIndex = this.ctxService?.grid.selectionDirective?.rangeSelectionStartRow?.index || 0;
      this.lastSelectionData = this.ctxService?.grid.selectionDirective?.rangeSelectionStartRow?.dataItem || {};
    }
    this.currentSelection = [];
    this.nonSelectableRows = /* @__PURE__ */ new Map();
    if (settings.selectable && settings.selectable.enabled !== false) {
      const iterator2 = this.getIterator();
      this._selectAllState = true;
      let item = iterator2.next();
      while (!item.done) {
        if (item.value && item.value.type === "data") {
          const rowArgs = {
            dataItem: item.value.data,
            index: item.value.index
          };
          if (settings.rowSelected(rowArgs)) {
            this.currentSelection[item.value.index] = rowArgs;
          } else {
            this._selectAllState = void 0;
          }
          if (!settings.isRowSelectable(rowArgs)) {
            this.nonSelectableRows.set(rowArgs.index, rowArgs.dataItem);
            this._selectAllState = void 0;
          }
        }
        item = iterator2.next();
      }
      if (this.currentSelection.length === 0) {
        this._selectAllState = false;
      }
    }
  }
  isSelected(index) {
    if (this.settings && this.active) {
      return this.options.enabled && isPresent7(this.currentSelection[index]) && !this.nonSelectableRows.has(index);
    }
  }
  handleClick(item, event) {
    if (this.dragging) {
      this.dragging = false;
      return;
    }
    let ev;
    const ctrlKey = event.ctrlKey || event.metaKey;
    if (this.options.mode === "single" && ctrlKey && this.isSelected(item.index)) {
      ev = this.toggle(item);
    } else if (this.options.mode === "multiple") {
      if ((ctrlKey || !this.options.metaKeyMultiSelect) && !event.shiftKey) {
        ev = this.toggle(item);
      } else if (event.shiftKey) {
        const preserveCurrentSelection = isMultipleRangesEnabled(this.settings);
        ev = this.addAllTo(item, ctrlKey, preserveCurrentSelection);
      }
    }
    if (!isPresent7(ev)) {
      ev = this.select(item);
      this.currentSelection[item.index] = {
        dataItem: item.data,
        index: item.index
      };
    }
    if (!ev.selectedRows.length && !ev.deselectedRows.length) {
      return;
    }
    ev.ctrlKey = ctrlKey;
    ev.shiftKey = event.shiftKey;
    if (this.options.cellAggregates) {
      ev.cellAggregates = this.aggregateService.onSelectionChange(ev);
    }
    if (ev.shiftKey) {
      ev.rangeStartRow = {
        dataItem: this.lastSelectionData,
        index: this.lastSelectionStartIndex
      };
      ev.rangeEndRow = {
        dataItem: item.data,
        index: item.index
      };
      this.lastSelectionData = item.data;
      this.lastSelectionStartIndex = item.index;
    }
    this.syncCurrentSelection(ev);
    this.changes.emit(ev);
  }
  toggle(item) {
    const selectedRows = [];
    const deselectedRows = [];
    this.lastSelectionStartIndex = item.index;
    this.lastSelectionData = item.data;
    const rowArgs = {
      dataItem: item.data,
      index: item.index
    };
    if (this.isSelected(item.index)) {
      deselectedRows.push(rowArgs);
    } else if (!this.nonSelectableRows.has(item.index)) {
      selectedRows.push(rowArgs);
    }
    if (this.hasNonSelectable) {
      const nonSelectableRows = this.currentSelection.filter((i) => this.nonSelectableRows.has(i.index));
      deselectedRows.push(...nonSelectableRows);
    }
    return {
      deselectedRows,
      selectedRows
    };
  }
  toggleByIndex(index) {
    const iterator2 = this.getIterator();
    if (this.selectAllChecked && this.isSelected(index)) {
      this.selectAllChecked = false;
    }
    let item = iterator2.next();
    while (!item.done) {
      if (item.value && item.value.type === "data" && item.value.index === index) {
        const itemToToggle = {
          data: item.value.data,
          index: item.value.index
        };
        if (this.isSelected(index) || this.options.mode === "multiple") {
          return this.toggle(itemToToggle);
        } else {
          return this.select(itemToToggle);
        }
      }
      item = iterator2.next();
    }
  }
  select(item) {
    const deselectedRows = [];
    const selectedRows = [];
    this.lastSelectionStartIndex = item.index;
    this.lastSelectionData = item.data;
    if (!this.isSelected(item.index) && !this.nonSelectableRows.has(item.index)) {
      selectedRows.push({
        dataItem: item.data,
        index: item.index
      });
    }
    this.currentSelection.forEach((row2) => {
      if (row2.index !== item.index) {
        deselectedRows.push(row2);
      }
    });
    return {
      deselectedRows,
      selectedRows
    };
  }
  //Used to manually deselect removed items
  deselect(removedItem) {
    const iterator2 = this.getIterator();
    let item = iterator2.next();
    while (!item.done) {
      if (item.value && item.value.type === "data" && item.value.data === removedItem) {
        const rowArgs = {
          dataItem: item.value.data,
          index: item.value.index
        };
        if (this.isSelected(rowArgs.index) || this.nonSelectableRows.has(rowArgs.index)) {
          const ev = {
            ctrlKey: false,
            deselectedRows: [rowArgs],
            selectedRows: []
          };
          this.syncCurrentSelection(ev);
          this.changes.emit(ev);
        }
      }
      item = iterator2.next();
    }
  }
  addAllTo(item, ctrlKey, preserveSelection = false, shiftKey = false) {
    const selectedRows = [];
    const deselectedRows = [];
    const start = Math.min(this.lastSelectionStartIndex, item.index);
    const end = Math.max(this.lastSelectionStartIndex, item.index);
    const iterator2 = this.getIterator();
    let next2 = iterator2.next();
    let selectedItem;
    while (!next2.done) {
      if (next2.value && next2.value.type === "data") {
        const idx4 = next2.value.index;
        const rowArgs = {
          dataItem: next2.value.data,
          index: idx4
        };
        if ((idx4 < start || idx4 > end) && this.isSelected(idx4) && !ctrlKey && !preserveSelection) {
          deselectedRows.push(rowArgs);
        }
        if (idx4 >= start && idx4 <= end && !this.isSelected(idx4) && !this.nonSelectableRows.has(idx4)) {
          selectedRows.push(rowArgs);
        }
        if (idx4 === item.index && !this.nonSelectableRows.has(idx4)) {
          selectedItem = rowArgs;
        }
      }
      next2 = iterator2.next();
    }
    if (this.hasNonSelectable) {
      const nonSelectableRows = this.currentSelection.filter((i) => this.nonSelectableRows.has(i.index));
      deselectedRows.push(...nonSelectableRows);
    }
    const selectionEvent = {
      deselectedRows,
      selectedRows
    };
    if (shiftKey && selectedItem) {
      selectionEvent.rangeStartRow = {
        dataItem: this.lastSelectionData,
        index: this.lastSelectionStartIndex
      };
      selectionEvent.rangeEndRow = {
        dataItem: selectedItem.dataItem,
        index: selectedItem.index
      };
      this.lastSelectionData = selectedItem.dataItem;
      this.lastSelectionStartIndex = selectedItem.index;
    }
    return selectionEvent;
  }
  updateAll(selectAllChecked) {
    this.selectAllChecked = selectAllChecked;
    const selectedRows = [];
    const deselectedRows = [];
    const iterator2 = this.getIterator();
    let next2 = iterator2.next();
    while (!next2.done) {
      if (next2.value && next2.value.type === "data") {
        const idx4 = next2.value.index;
        const rowArgs = {
          dataItem: next2.value.data,
          index: idx4
        };
        if (!this.nonSelectableRows.has(idx4)) {
          if (this.isSelected(idx4) && !selectAllChecked) {
            deselectedRows.push(rowArgs);
          }
          if (!this.isSelected(idx4) && selectAllChecked) {
            selectedRows.push(rowArgs);
          }
        }
      }
      next2 = iterator2.next();
    }
    if (!selectedRows.length && !deselectedRows.length) {
      return;
    }
    if (this.hasNonSelectable) {
      const nonSelectableRows = this.currentSelection.filter((i) => this.nonSelectableRows.has(i.index));
      deselectedRows.push(...nonSelectableRows);
    }
    const ev = {
      ctrlKey: true,
      deselectedRows,
      selectedRows,
      shiftKey: true
    };
    if (this.options.cellAggregates) {
      ev.cellAggregates = this.aggregateService.onSelectionChange(ev);
    }
    this.syncCurrentSelection(ev);
    this.changes.emit(ev);
  }
  selectRange(startIndex, endIndex, preserveSelection, existingSelections = []) {
    const selectedRows = [];
    const deselectedRows = [];
    const start = Math.min(startIndex, endIndex);
    const end = Math.max(startIndex, endIndex);
    const iterator2 = this.getIterator();
    let next2 = iterator2.next();
    while (!next2.done) {
      if (next2.value && next2.value.type === "data") {
        const idx4 = next2.value.index;
        const rowArgs = {
          dataItem: next2.value.data,
          index: idx4
        };
        if ((idx4 < start || idx4 > end) && this.isSelected(idx4)) {
          const deselectRow = !(preserveSelection || existingSelections.find((value2) => value2 && value2.dataItem === rowArgs.dataItem && value2.index === rowArgs.index));
          if (deselectRow) {
            deselectedRows.push(rowArgs);
          }
        }
        if (idx4 >= start && idx4 <= end && !this.isSelected(idx4) && !this.nonSelectableRows.has(idx4)) {
          selectedRows.push(rowArgs);
        }
      }
      next2 = iterator2.next();
    }
    let cellAggregates;
    if (this.options.cellAggregates) {
      cellAggregates = this.aggregateService.onSelectionChange({
        selectedRows,
        deselectedRows
      });
    }
    if (this.hasNonSelectable) {
      const nonSelectableRows = this.currentSelection.filter((i) => this.nonSelectableRows.has(i.index));
      deselectedRows.push(...nonSelectableRows);
    }
    return {
      deselectedRows,
      selectedRows,
      cellAggregates
    };
  }
  get selectAllState() {
    return this._selectAllState;
  }
  get selected() {
    return this.currentSelection.map((item) => {
      return item.index;
    }).filter((n) => typeof n === "number");
  }
  get options() {
    const defaultOptions2 = {
      cellAggregates: false,
      checkboxOnly: false,
      enabled: true,
      mode: "multiple",
      metaKeyMultiSelect: true
    };
    if (!isPresent7(this.settings)) {
      return defaultOptions2;
    }
    if (typeof this.settings.selectable === "boolean") {
      return {
        cellAggregates: false,
        checkboxOnly: false,
        enabled: this.settings.selectable,
        mode: "multiple",
        metaKeyMultiSelect: true
      };
    } else {
      return Object.assign(defaultOptions2, this.settings.selectable);
    }
  }
  ngOnDestroy() {
    this.removeSubscriptions();
  }
  targetArgs() {
    return {
      index: this.mouseDownEventArgs.rowIndex,
      dataItem: this.mouseDownEventArgs.dataItem
    };
  }
  addSubscriptions() {
    if (!this.cellClickSubscription) {
      this.cellClickSubscription = this.domEvents.cellClick.subscribe((args) => {
        if (this.options.enabled && !this.options.checkboxOnly && args.type !== "contextmenu") {
          if (this.active) {
            this.handleClick({
              index: args.rowIndex,
              data: args.dataItem
            }, args.originalEvent);
          }
        }
      });
    }
    if (!this.mousedownSubscription) {
      this.mousedownSubscription = this.domEvents.cellMousedown.subscribe((args) => {
        this.mouseDownEventArgs = args;
        if (this.options.enabled && (!this.options.mode || this.options.mode === "multiple") && !this.options.checkboxOnly && args.originalEvent.shiftKey) {
          if (this.active) {
            args.originalEvent.preventDefault();
            this.navigationService.focusCellByElement(args.originalEvent.target);
          }
        }
      });
    }
    if (this.localDataChangesService && !this.dataChangedSubscription) {
      this.dataChangedSubscription = this.localDataChangesService.changes.subscribe((args) => {
        if (this.active) {
          if (isPresent7(args.action) && args.action === "remove") {
            this.deselect(args.item);
          }
        }
      });
    }
  }
  getIterator() {
    const accessor = this.settings.view.accessor();
    if (!accessor) {
      return;
    }
    return accessor[iterator]();
  }
  removeSubscriptions() {
    if (this.cellClickSubscription) {
      this.cellClickSubscription.unsubscribe();
      this.cellClickSubscription = null;
    }
    if (this.mousedownSubscription) {
      this.mousedownSubscription.unsubscribe();
      this.mousedownSubscription = null;
    }
    if (this.dataChangedSubscription) {
      this.dataChangedSubscription.unsubscribe();
      this.dataChangedSubscription = null;
    }
  }
  syncCurrentSelection(ev) {
    for (const row2 of ev.deselectedRows) {
      this.currentSelection.splice(row2.index, 1);
    }
    for (const row2 of ev.selectedRows) {
      this.currentSelection[row2.index] = row2;
    }
  }
  static ɵfac = function SelectionService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SelectionService)(ɵɵinject(DomEventsService), ɵɵinject(CellSelectionAggregateService), ɵɵinject(LocalDataChangesService), ɵɵinject(NavigationService4), ɵɵinject(ContextService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _SelectionService,
    factory: _SelectionService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectionService2, [{
    type: Injectable
  }], () => [{
    type: DomEventsService
  }, {
    type: CellSelectionAggregateService
  }, {
    type: LocalDataChangesService
  }, {
    type: NavigationService4
  }, {
    type: ContextService
  }], null);
})();
var CellSelectionService = class _CellSelectionService {
  domEvents;
  aggregateService;
  localDataChangesService;
  navigationService;
  changes = new EventEmitter();
  mouseUpEvent = new EventEmitter();
  currentSelection = [];
  settings;
  active = false;
  aggregates;
  nonSelectableRows = /* @__PURE__ */ new Map();
  get enableMarquee() {
    const checkboxOnly = this.settings && typeof this.settings === "object" && this.settings.checkboxOnly;
    if (!this.settings || checkboxOnly || this.settings.isStacked) {
      return false;
    }
    const selectableSettings = this.settings.selectable;
    const dragAndMultiple = typeof selectableSettings === "object" && isPresent7(selectableSettings) && selectableSettings.mode === "multiple" && selectableSettings.cell && selectableSettings.enabled !== false && selectableSettings.drag;
    return this.active && dragAndMultiple;
  }
  get hasNonSelectable() {
    return this.nonSelectableRows.size > 0;
  }
  mouseDownEventArgs;
  mouseUpEventArgs;
  dragging = false;
  dragSelectDeselect = false;
  lastSelectionItem = {
    itemKey: 0,
    columnKey: 0
  };
  lastSelectionItemRowIndex = 0;
  lastSelectionItemColIndex = 0;
  cellClickSubscription;
  dataChangedSubscription;
  mousedownSubscription;
  constructor(domEvents, aggregateService, localDataChangesService, navigationService) {
    this.domEvents = domEvents;
    this.aggregateService = aggregateService;
    this.localDataChangesService = localDataChangesService;
    this.navigationService = navigationService;
    this.addSubscriptions();
  }
  init(settings) {
    this.settings = settings;
    this.currentSelection = [];
    this.nonSelectableRows = /* @__PURE__ */ new Map();
    if (settings.selectable && settings.selectable.enabled !== false && !settings.isStacked) {
      const iterator2 = this.getIterator();
      let item = iterator2.next();
      while (!item.done) {
        if (item.value && item.value.type === "data") {
          const rowArgs = {
            dataItem: item.value.data,
            index: item.value.index
          };
          settings.columns.forEach((col) => {
            const selectedCellArgs = settings.cellSelected(rowArgs, col, col.leafIndex);
            if (selectedCellArgs.selected) {
              this.currentSelection.push(selectedCellArgs.item);
            }
            if (!settings.isRowSelectable(rowArgs)) {
              this.nonSelectableRows.set(rowArgs.index, rowArgs.dataItem);
            }
          });
        }
        item = iterator2.next();
      }
    }
  }
  isCellSelected(item, col) {
    if (this.settings && this.active && !this.settings.isStacked) {
      const selectedCellArgs = this.settings.cellSelected({
        dataItem: item.data,
        index: item.index
      }, col, col.leafIndex);
      return this.options.enabled && selectedCellArgs.selected && !this.nonSelectableRows.has(item.index);
    }
    return false;
  }
  handleClick(item, event) {
    if (this.dragging) {
      this.dragging = false;
      return;
    }
    if (this.settings.isStacked) {
      return;
    }
    let ev;
    const ctrlKey = event.ctrlKey || event.metaKey;
    if (this.options.mode === "single" && ctrlKey && this.isCellSelected(item, item.column)) {
      ev = this.toggle(item);
    } else if (this.options.mode === "multiple") {
      if ((ctrlKey || !this.options.metaKeyMultiSelect) && !event.shiftKey) {
        ev = this.toggle(item);
      } else if (event.shiftKey) {
        const startRowIndex = Math.min(this.lastSelectionItemRowIndex, item.index);
        const startColIndex = Math.min(this.lastSelectionItemColIndex, item.column.leafIndex);
        const endRowIndex = Math.max(this.lastSelectionItemRowIndex, item.index);
        const endColIndex = Math.max(this.lastSelectionItemColIndex, item.column.leafIndex);
        const preserveCurrentSelection = isMultipleRangesEnabled(this.settings);
        ev = this.selectRange(startRowIndex, startColIndex, endRowIndex, endColIndex, preserveCurrentSelection);
        if (preserveCurrentSelection) {
          this.lastSelectionItemRowIndex = item.index;
          this.lastSelectionItemColIndex = item.column.leafIndex;
        }
      }
    }
    if (!isPresent7(ev)) {
      ev = this.select(item);
      this.currentSelection = [this.lastSelectionItem];
    }
    if (!ev.selectedCells.length && !ev.deselectedCells.length) {
      return;
    }
    ev.ctrlKey = ctrlKey;
    ev.shiftKey = event.shiftKey;
    if (this.options.cellAggregates && !event.shiftKey) {
      ev.cellAggregates = this.aggregateService.onSelectionChange(ev);
    }
    if (ev.shiftKey) {
      ev.rangeStartCell = this.lastSelectionItem;
      ev.rangeEndCell = __spreadValues({}, this.settings.cellSelected({
        dataItem: item.data,
        index: item.index
      }, item.column, item.column.leafIndex).item);
    }
    this.changes.emit(ev);
  }
  toggle(item) {
    const selectedCells = [];
    const deselectedCells = [];
    this.lastSelectionItem = this.settings.cellSelected({
      dataItem: item.data,
      index: item.index
    }, item.column, item.column.leafIndex).item;
    this.lastSelectionItemRowIndex = item.index;
    this.lastSelectionItemColIndex = item.column.leafIndex;
    if (this.isCellSelected(item, item.column)) {
      deselectedCells.push(this.lastSelectionItem);
    } else if (!this.nonSelectableRows.has(item.index)) {
      selectedCells.push(this.lastSelectionItem);
    }
    return {
      deselectedCells,
      selectedCells
    };
  }
  select(item) {
    const selectedCells = [];
    const deselectedCells = [];
    this.lastSelectionItem = this.settings.cellSelected({
      dataItem: item.data,
      index: item.index
    }, item.column, item.column.leafIndex).item;
    this.lastSelectionItemRowIndex = item.index;
    this.lastSelectionItemColIndex = item.column.leafIndex;
    if (!this.isCellSelected(item, item.column) && !this.nonSelectableRows.has(item.index)) {
      selectedCells.push(this.lastSelectionItem);
    }
    this.currentSelection.forEach((selectedItem) => {
      if (selectedItem.itemKey !== this.lastSelectionItem.itemKey || selectedItem.columnKey !== this.lastSelectionItem.columnKey) {
        deselectedCells.push(selectedItem);
      }
    });
    return {
      deselectedCells,
      selectedCells
    };
  }
  //Used to manually deselect removed items
  deselect(removedItem) {
    const iterator2 = this.getIterator();
    let item = iterator2.next();
    let rowArgs;
    while (!item.done) {
      if (item.value && item.value.type === "data" && item.value.data === removedItem) {
        rowArgs = {
          dataItem: item.value.data,
          index: item.value.index
        };
        break;
      }
      item = iterator2.next();
    }
    if (rowArgs) {
      const cellsToRemove = this.currentSelection.filter((selectedItem) => {
        const contender = this.settings.cellSelected(rowArgs, null, null).item;
        return selectedItem.itemKey === contender.itemKey || this.nonSelectableRows.has(rowArgs.index);
      });
      if (cellsToRemove.length) {
        const ev = {
          ctrlKey: false,
          deselectedCells: cellsToRemove,
          selectedCells: []
        };
        this.changes.emit(ev);
      }
    }
  }
  selectRange(startRowIndex, startColIndex, endRowIndex, endColIndex, preserveSelection = false, existingSelections = []) {
    const selectedCells = [];
    const deselectedCells = [];
    const selectionStartRow = Math.min(startRowIndex, endRowIndex);
    const selectionStartCol = Math.min(startColIndex, endColIndex);
    const selectionEndRow = Math.max(startRowIndex, endRowIndex);
    const selectionEndCol = Math.max(startColIndex, endColIndex);
    const iterator2 = this.getIterator();
    let next2 = iterator2.next();
    while (!next2.done) {
      if (next2.value && next2.value.type === "data") {
        const idx4 = next2.value.index;
        const data = next2.value.data;
        const rowArgs = {
          dataItem: data,
          index: idx4
        };
        this.settings.columns.forEach((col) => {
          const {
            item
          } = this.settings.cellSelected(rowArgs, col, col.leafIndex);
          const selected = this.isCellSelected(next2.value, col);
          const isInRowRange = selectionStartRow <= idx4 && idx4 <= selectionEndRow;
          const isInColRange = selectionStartCol <= col.leafIndex && col.leafIndex <= selectionEndCol;
          const isInSelectionRect = isInRowRange && isInColRange;
          if (!isInSelectionRect && selected) {
            const deselectCell = !(preserveSelection || existingSelections.find((value2) => value2 && value2.itemKey === item.itemKey && value2.columnKey === item.columnKey));
            if (deselectCell) {
              deselectedCells.push(item);
            }
          }
          if (isInSelectionRect && !selected && !this.nonSelectableRows.has(idx4)) {
            selectedCells.push(item);
          }
        });
      }
      next2 = iterator2.next();
    }
    let cellAggregates;
    if (this.options.cellAggregates) {
      cellAggregates = this.aggregateService.onSelectionChange({
        selectedCells,
        deselectedCells
      });
    }
    return {
      deselectedCells,
      selectedCells,
      cellAggregates
    };
  }
  get options() {
    const defaultOptions2 = {
      cellAggregates: false,
      checkboxOnly: false,
      enabled: true,
      mode: "multiple",
      metaKeyMultiSelect: true
    };
    if (!isPresent7(this.settings)) {
      return defaultOptions2;
    }
    if (typeof this.settings.selectable === "boolean") {
      return {
        cellAggregates: false,
        checkboxOnly: false,
        enabled: this.settings.selectable,
        mode: "multiple",
        metaKeyMultiSelect: true
      };
    } else {
      return Object.assign(defaultOptions2, this.settings.selectable);
    }
  }
  ngOnDestroy() {
    this.removeSubscriptions();
  }
  addSubscriptions() {
    if (!this.cellClickSubscription) {
      this.cellClickSubscription = this.domEvents.cellClick.subscribe((args) => {
        if (this.options.enabled && !this.options.checkboxOnly && args.type !== "contextmenu") {
          if (this.active) {
            this.handleClick({
              index: args.rowIndex,
              data: args.dataItem,
              column: args.column
            }, args.originalEvent);
          }
        }
      });
    }
    if (!this.mousedownSubscription) {
      this.mousedownSubscription = this.domEvents.cellMousedown.subscribe((args) => {
        this.mouseDownEventArgs = args;
        if (this.options.enabled && (!this.options.mode || this.options.mode === "multiple") && !this.options.checkboxOnly && args.originalEvent.shiftKey) {
          if (this.active) {
            args.originalEvent.preventDefault();
            this.navigationService.focusCellByElement(args.originalEvent.target);
          }
        }
      });
    }
    if (this.localDataChangesService && !this.dataChangedSubscription) {
      this.dataChangedSubscription = this.localDataChangesService.changes.subscribe((args) => {
        if (this.active) {
          if (isPresent7(args.action) && args.action === "remove") {
            this.deselect(args.item);
          }
        }
      });
    }
  }
  getIterator() {
    const accessor = this.settings.view.accessor();
    if (!accessor) {
      return;
    }
    return accessor[iterator]();
  }
  removeSubscriptions() {
    if (this.cellClickSubscription) {
      this.cellClickSubscription.unsubscribe();
      this.cellClickSubscription = null;
    }
    if (this.mousedownSubscription) {
      this.mousedownSubscription.unsubscribe();
      this.mousedownSubscription = null;
    }
    if (this.dataChangedSubscription) {
      this.dataChangedSubscription.unsubscribe();
      this.dataChangedSubscription = null;
    }
  }
  static ɵfac = function CellSelectionService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CellSelectionService)(ɵɵinject(DomEventsService), ɵɵinject(CellSelectionAggregateService), ɵɵinject(LocalDataChangesService), ɵɵinject(NavigationService4));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _CellSelectionService,
    factory: _CellSelectionService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CellSelectionService, [{
    type: Injectable
  }], () => [{
    type: DomEventsService
  }, {
    type: CellSelectionAggregateService
  }, {
    type: LocalDataChangesService
  }, {
    type: NavigationService4
  }], null);
})();
var SelectAllCheckboxDirective = class _SelectAllCheckboxDirective {
  selectionService;
  cellSelectionService;
  ngZone;
  element;
  renderer;
  checkbox;
  /**
   * Explicitly overrides the state of the select-all checkbox.
   */
  state;
  /**
   * Emits when the user clicks the select-all checkbox.
   * ([see example](slug:grid_row_selection#toc-select-all-checkbox)).
   */
  selectAllChange = new EventEmitter();
  destroyClick;
  checkboxChange;
  stateSet = false;
  ngAfterContentChecked() {
    this.setState();
  }
  ngOnChanges() {
    this.stateSet = true;
  }
  constructor(selectionService, cellSelectionService, ngZone, element, renderer, checkbox) {
    this.selectionService = selectionService;
    this.cellSelectionService = cellSelectionService;
    this.ngZone = ngZone;
    this.element = element;
    this.renderer = renderer;
    this.checkbox = checkbox;
    this.ngZone.runOutsideAngular(() => {
      if (this.checkbox) {
        this.checkboxChange = this.checkbox.checkedStateChange.subscribe(this.onClick.bind(this));
      } else {
        this.destroyClick = this.renderer.listen(this.element.nativeElement, "click", this.onClick.bind(this));
      }
    });
  }
  ngOnDestroy() {
    if (this.checkboxChange) {
      this.checkboxChange.unsubscribe();
    }
    if (this.destroyClick) {
      this.destroyClick();
    }
  }
  /**
   * @hidden
   */
  onClick() {
    const isIndeterminateState = this.checkbox?.checkedState === "indeterminate" || this.element.nativeElement.indeterminate;
    const isCheckedState = this.checkbox?.checkedState === true || this.element.nativeElement.checked;
    const uncheckedState = isIndeterminateState ? "indeterminate" : "unchecked";
    const checkboxState = isCheckedState ? "checked" : uncheckedState;
    const isChecked = this.selectionService.hasNonSelectable ? !this.selectionService.selectAllChecked : isCheckedState;
    const options = this.selectionService.options;
    const enabledAndMultiple = options.enabled && options.mode === "multiple" && !this.cellSelectionService.active;
    const shouldEmitSelectAll = hasObservers(this.selectAllChange);
    if (enabledAndMultiple || shouldEmitSelectAll) {
      this.ngZone.run(() => {
        if (enabledAndMultiple) {
          this.selectionService.updateAll(isChecked);
        }
        if (shouldEmitSelectAll) {
          this.selectAllChange.emit(checkboxState);
        }
      });
    }
  }
  /**
   * @hidden
   */
  setState() {
    const state2 = this.stateSet ? this.stateToBool() : this.selectionService.selectAllState;
    if (this.checkbox) {
      this.checkbox.checkedState = isPresent7(state2) ? state2 : "indeterminate";
    } else {
      const elem = this.element.nativeElement;
      this.renderer.setProperty(elem, "indeterminate", !isPresent7(state2));
      this.renderer.setProperty(elem, "checked", isPresent7(state2) ? state2 : false);
    }
  }
  /**
   * @hidden
   */
  stateToBool() {
    switch (this.state) {
      case "checked":
        return true;
      case "unchecked":
        return false;
      default:
        return void 0;
    }
  }
  static ɵfac = function SelectAllCheckboxDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SelectAllCheckboxDirective)(ɵɵdirectiveInject(SelectionService2), ɵɵdirectiveInject(CellSelectionService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(CheckBoxComponent, 9));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _SelectAllCheckboxDirective,
    selectors: [["", "kendoGridSelectAllCheckbox", ""]],
    inputs: {
      state: "state"
    },
    outputs: {
      selectAllChange: "selectAllChange"
    },
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectAllCheckboxDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridSelectAllCheckbox]",
      standalone: true
    }]
  }], () => [{
    type: SelectionService2
  }, {
    type: CellSelectionService
  }, {
    type: NgZone
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: CheckBoxComponent,
    decorators: [{
      type: Host
    }, {
      type: Optional
    }]
  }], {
    state: [{
      type: Input
    }],
    selectAllChange: [{
      type: Output
    }]
  });
})();
var mergeObjects = (...args) => Object.assign.apply(null, [{}].concat(args));
var directions$1 = (initialDirection) => initialDirection === "asc" ? ["asc", "desc"] : ["desc", "asc"];
var isRootLevel = ({
  parent
}) => !isTruthy(parent);
var ofColumnType = ({
  draggable
}) => ["column", "columnGroup"].indexOf(draggable.context.type) >= 0;
var notSameElement = ({
  draggable,
  target
}) => draggable.element.nativeElement !== target.element.nativeElement;
var inSameParent = (x, y) => x.parent === y.parent || isInSpanColumn$1(y) && inSameParent(x, y.parent);
var sameParent = ({
  draggable,
  target
}) => inSameParent(draggable.context.column, target.context.column);
var lastNonLocked = ({
  draggable
}) => !isTruthy(draggable.context.column.locked) && isRootLevel(draggable.context.column) && draggable.context.lastColumn;
var notInSpanColumn = ({
  draggable
}) => !isInSpanColumn$1(draggable.context.column);
var reorderable = ({
  draggable
}) => draggable.context.column.reorderable;
var lockable = ({
  draggable,
  target
}) => draggable.context.column.lockable !== false || draggable.context.column.isLocked === target.context.column.isLocked;
var rules = and(ofColumnType, reorderable, notInSpanColumn, notSameElement, sameParent, not(lastNonLocked), lockable);
var modifierKeys = ["alt", "ctrl", "shift", "meta"];
var HeaderComponent2 = class _HeaderComponent {
  popupService;
  hint;
  cue;
  reorderService;
  idService;
  sortService;
  columnInfoService;
  cd;
  contextService;
  navigationService;
  zone;
  /**
   * @hidden
   */
  totalColumnLevels;
  columns = [];
  groups = [];
  detailTemplate;
  scrollable;
  filterable;
  sort = new Array();
  filter;
  sortable = false;
  groupable = false;
  lockedColumnsCount = 0;
  resizable = false;
  reorderable = false;
  columnMenu = false;
  columnMenuTemplate;
  totalColumnsCount = 0;
  totalColumns;
  tabIndex;
  size = "medium";
  sortedFields = {};
  hostClass = true;
  get sortableLabel() {
    return this.contextService.localization.get("sortable");
  }
  get columnMenuSettings() {
    return this.columnMenu;
  }
  dropTargets = new QueryList();
  filterMenus;
  columnMenus;
  // Number of unlocked columns in the next table, if any
  get unlockedColumnsCount() {
    return this.totalColumnsCount - this.lockedColumnsCount - this.columns.length;
  }
  sortAscSmallIcon = sortAscSmallIcon;
  sortDescSmallIcon = sortDescSmallIcon;
  subscription = new Subscription();
  targetSubscription;
  stopSorting = false;
  _leafColumns;
  constructor(popupService, hint, cue, reorderService, idService, sortService, columnInfoService, cd, contextService, navigationService, zone) {
    this.popupService = popupService;
    this.hint = hint;
    this.cue = cue;
    this.reorderService = reorderService;
    this.idService = idService;
    this.sortService = sortService;
    this.columnInfoService = columnInfoService;
    this.cd = cd;
    this.contextService = contextService;
    this.navigationService = navigationService;
    this.zone = zone;
  }
  sortColumn(descriptor) {
    this.sortService.sort(descriptor);
  }
  getColumnComponent(column) {
    return column;
  }
  onSortClick(column, event, link) {
    if (this.stopSorting) {
      this.stopSorting = false;
      return;
    }
    const target = event.target;
    if (column.headerTemplateRef && target !== link) {
      const hasFocusableParent = Boolean(closestInScope5(target, isFocusable5, link));
      if (hasFocusableParent) {
        return;
      }
    }
    const modifier = this.matchModifier(event);
    const toggledColumn = this.toggleSort(column, modifier);
    this.sortColumn(toggledColumn);
  }
  onHeaderKeydown(column, args) {
    const code = normalizeKeys(args);
    if (code === Keys.ArrowDown && args.altKey && this.showFilterMenu && this.isFilterable(column)) {
      args.preventDefault();
      args.stopImmediatePropagation();
      const filterMenu = this.filterMenus.find((fm) => fm.column === column);
      filterMenu.toggle(filterMenu.anchor.nativeElement, filterMenu.template);
      return;
    }
    if (code === Keys.ArrowDown && args.altKey && this.showColumnMenu(column)) {
      args.preventDefault();
      args.stopImmediatePropagation();
      const columnMenu = this.columnMenus.find((cm) => cm.column === column);
      columnMenu.toggle(null, columnMenu.anchor.nativeElement, columnMenu.template);
      return;
    }
    const isCtrlOrMeta = args.ctrlKey || args.metaKey;
    const isGroupingKeyShortcut = (code === Keys.Enter || code === Keys.Space) && isCtrlOrMeta;
    if (isGroupingKeyShortcut && this.isGroupable(column)) {
      args.preventDefault();
      args.stopImmediatePropagation();
      const isGroupedByField = this.groups.some((gr) => gr.field === column.field);
      if (isGroupedByField) {
        this.groups = this.groups.filter((gr) => gr.field !== column.field);
      } else {
        this.groups.push({
          field: column.field
        });
      }
      this.contextService.grid.groupChange.emit(this.groups);
      return;
    }
    const isLeftOrRightArrow = code === Keys.ArrowLeft || code === Keys.ArrowRight;
    const isReorderingKeyShortcut = isLeftOrRightArrow && isCtrlOrMeta;
    if (isReorderingKeyShortcut && this.isReorderable(column)) {
      args.preventDefault();
      const columnsCount = this.columnInfoService.leafNamedColumns.length;
      const reorderDirection = code === Keys.ArrowLeft ? -1 : 1;
      const rtlMultiplier = this.contextService.localization.rtl ? -1 : 1;
      const reorderDirectionOffset = reorderDirection * rtlMultiplier;
      const newIndex = column.leafIndex + reorderDirectionOffset;
      const normalizedNewIndex = Math.min(Math.max(0, newIndex), columnsCount - 1);
      const gridInstance = this.contextService.grid;
      gridInstance.reorderColumn(column, normalizedNewIndex, {
        before: reorderDirectionOffset < 0
      });
      gridInstance.columnReorder.emit(new ColumnReorderEvent({
        column,
        newIndex: normalizedNewIndex,
        oldIndex: column.leafIndex
      }));
      return;
    }
    if (!this.sortable || args.defaultPrevented || column.sortable === false) {
      return;
    }
    if (code === Keys.Enter && isPresent7(column.field)) {
      const modifier = this.matchModifier(args);
      this.sortService.sort(this.toggleSort(column, modifier));
    }
  }
  showSortNumbering(column) {
    const {
      showIndexes
    } = normalize$1(this.sortable);
    return showIndexes && this.sort && this.sort.filter(({
      dir
    }) => isPresent7(dir)).length > 1 && this.sortOrder(column.field) > 0;
  }
  sortOrder(field) {
    return this.sort.filter(({
      dir
    }) => isPresent7(dir)).findIndex((x) => x.field === field) + 1;
  }
  sortState(column) {
    if (!this.isInteractive(column, "sortable")) {
      return;
    }
    const state2 = this.sortDescriptor(column.field);
    if (state2.dir === "asc") {
      return "ascending";
    }
    if (state2.dir === "desc") {
      return "descending";
    }
  }
  get isNavigable() {
    return this.navigationService.tableEnabled;
  }
  /**
   *
   * @param column
   * @param modifier - Indicates whether the client-defined `multiSortKey` modifier is met. Defaults to `true`.
   * @returns - SortDescriptor[]
   */
  toggleSort(column, modifier = true) {
    const {
      allowUnsort,
      mode,
      initialDirection
    } = normalize$1(this.sortable, column.sortable);
    const descriptor = this.toggleDirection(column.field, allowUnsort, initialDirection);
    if (mode === "single" || !modifier) {
      return [descriptor];
    }
    return [...this.sort.filter((desc) => desc.field !== column.field), descriptor];
  }
  /**
   *
   * Determines whether the modifier key (if any) passed
   * with a click/keyboard event matches the user-defined multiSortKey.
   */
  matchModifier(event) {
    const {
      multiSortKey
    } = normalize$1(this.sortable);
    if (multiSortKey === "none") {
      return modifierKeys.every((key) => !event[`${key}Key`]);
    }
    return multiSortKey === "ctrl" ? event.ctrlKey || event.metaKey : event[`${multiSortKey}Key`];
  }
  ngAfterViewInit() {
    this.subscription.add(observe(this.dropTargets).subscribe(this.attachTargets.bind(this)));
  }
  ngDoCheck() {
    this._leafColumns = columnsToRender(this.columns || []).filter((x) => !isColumnGroupComponent(x));
  }
  ngOnChanges(changes) {
    const sortChange = changes.sort;
    if (sortChange && !sortChange.isFirstChange()) {
      sortChange.currentValue.forEach((change) => {
        this.sortedFields[change.field] = true;
      });
    }
  }
  ngOnInit() {
    this.subscription.add(this.contextService.localization.changes.subscribe(() => this.cd.markForCheck()));
  }
  ngOnDestroy() {
    if (this.targetSubscription) {
      this.targetSubscription.unsubscribe();
    }
    if (this.popupService) {
      this.popupService.destroy();
    }
    this.subscription.unsubscribe();
  }
  selectAllCheckboxId() {
    return this.idService.selectAllCheckboxId();
  }
  get selectAllCheckboxLabel() {
    return this.contextService.localization.get("selectAllCheckboxLabel");
  }
  isFirstOnRow(column, index) {
    const isTailing = (c) => c && (this.columnsForLevel(c.level).indexOf(c) > 0 || isTailing(c.parent));
    return index === 0 && !this.groups.length && !this.detailTemplate && isTailing(column.parent);
  }
  logicalColumnIndex(column) {
    const index = column.leafIndex;
    if (isPresent7(index)) {
      return index + (isPresent7(this.detailTemplate) ? 1 : 0);
    }
    return -1;
  }
  get showFilterMenu() {
    return !this.columnMenu && hasFilterMenu(this.filterable);
  }
  get showFilterRow() {
    return hasFilterRow(this.filterable);
  }
  showColumnMenu(column) {
    return this.columnMenu && column.columnMenu && (this.columnMenuTemplate || column.columnMenuTemplates.length || hasItems(this.columnMenu, column));
  }
  isFilterable(column) {
    return !isNullOrEmptyString2(column.field) && column.filterable === true;
  }
  canDrop(draggable, target) {
    isDocumentAvailable() && this.zone.runOutsideAngular(() => {
      document.addEventListener("pointerup", () => {
        this.stopSorting = true;
        setTimeout(() => this.stopSorting = false);
      }, {
        once: true,
        capture: true
      });
    });
    return this.reorderable && rules({
      draggable,
      target
    });
  }
  shouldActivate(column) {
    const canReorder = this.isReorderable(column);
    if (!canReorder && !isColumnComponent(column)) {
      return false;
    }
    const groupable = this.isGroupable(column);
    return groupable || canReorder;
  }
  isInteractive(column, prop2) {
    return !isNullOrEmptyString2(column.field) && isTruthy(this[prop2]) && isTruthy(column[prop2]);
  }
  isCheckboxColumn(column) {
    return isCheckboxColumn(column) && !column.templateRef;
  }
  addStickyStyles(column) {
    const stickyStyles = this.columnInfoService.stickyColumnsStyles(column);
    return __spreadValues(__spreadValues({}, column.headerStyle), stickyStyles);
  }
  toggleDirection(field, allowUnsort, initialDirection) {
    const descriptor = this.sortDescriptor(field);
    const [first, second] = directions$1(initialDirection);
    let dir = first;
    if (descriptor.dir === first) {
      dir = second;
    } else if (descriptor.dir === second && allowUnsort) {
      dir = void 0;
    }
    return {
      dir,
      field
    };
  }
  columnsForLevel(level) {
    const columns = this.columns ? this.columns.filter((column) => column.level === level) : [];
    return sortColumns(columnsToRender(columns));
  }
  isColumnGroupComponent(column) {
    return isColumnGroupComponent(column);
  }
  sortDescriptor(field) {
    return this.sort.find((item) => item.field === field) || {
      field
    };
  }
  get columnLevels() {
    return new Array((this.totalColumnLevels || 0) + 1);
  }
  get leafColumns() {
    return this._leafColumns;
  }
  get isStacked() {
    return this.contextService.grid?.isStacked;
  }
  isReorderable(column) {
    return this.reorderable && column.reorderable;
  }
  isGroupable(column) {
    return this.groupable && isColumnComponent(column) && column.groupable !== false;
  }
  attachTargets() {
    if (this.targetSubscription) {
      this.targetSubscription.unsubscribe();
    }
    this.targetSubscription = new Subscription();
    const enterStream = merge(...this.dropTargets.map((target) => target.enter));
    const leaveStream = merge(...this.dropTargets.map((target) => target.leave));
    const dropStream = merge(...this.dropTargets.map((target) => target.drop));
    this.targetSubscription.add(enterStream.pipe(tap(({
      target,
      draggable
    }) => {
      if (draggable.context.type === "groupIndicator") {
        return;
      }
      const targetLocked = isTruthy(target.context.column.isLocked);
      const draggableLocked = isTruthy(draggable.context.column.isLocked);
      if (this.lockedColumnsCount > 0 || targetLocked || draggableLocked) {
        this.hint.toggleLock(targetLocked);
      }
    }), filter(({
      draggable,
      target
    }) => this.canDrop(draggable, target)), switchMap(this.trackMove.bind(this, leaveStream, dropStream)), map((e) => mergeObjects(e, {
      before: this.calculateBefore(e),
      changeContainer: e.changeContainer
    })), map(this.normalizeTarget.bind(this)), tap(this.enter.bind(this)), switchMap((args) => dropStream.pipe(map(() => args), takeUntil(leaveStream.pipe(tap(this.leave.bind(this))))))).subscribe(this.drop.bind(this)));
  }
  normalizeTarget(e) {
    let target = e.target;
    const parent = target.context.column.parent;
    if (parent && parent.isSpanColumn) {
      const arr = this.dropTargets.toArray();
      const firstSpan = arr.find((t) => t.context.column.parent === parent);
      const index = arr.indexOf(firstSpan);
      const adjust = e.before ? 0 : parent.children.length - 1;
      target = arr[index + adjust];
    }
    return mergeObjects(e, {
      target
    });
  }
  trackMove(leaveStream, dropStream, e) {
    const column = e.target.context.column;
    const levelColumns = this.columnsForLevel(column.level);
    const index = levelColumns.indexOf(column);
    const isFirst = column.locked ? index === levelColumns.length - 1 : index === 0;
    const changed = e.draggable.context.column.isLocked !== column.isLocked;
    if (changed && isFirst) {
      return e.draggable.drag.pipe(takeUntil(leaveStream), takeUntil(dropStream), map(({
        mouseEvent
      }) => mergeObjects({
        changeContainer: true
      }, e, {
        mouseEvent
      })));
    }
    return of(mergeObjects({
      changeContainer: changed
    }, e));
  }
  calculateBefore({
    draggable,
    target,
    mouseEvent,
    changeContainer = false
  }) {
    const targetElement = target.element.nativeElement;
    let before = false;
    if (changeContainer) {
      const {
        left: left2
      } = offset2(targetElement);
      const halfWidth = targetElement.offsetWidth / 2;
      const middle = left2 + halfWidth;
      before = middle > mouseEvent.pageX;
      if (this.contextService.localization.rtl) {
        before = !before;
      }
    } else {
      before = isTargetBefore(draggable.element.nativeElement, targetElement);
    }
    return before;
  }
  enter({
    target,
    before
  }) {
    this.hint.enable();
    if (this.contextService.localization.rtl) {
      before = !before;
    }
    this.cue.position(position(target.element.nativeElement, before));
  }
  leave() {
    this.hint.disable();
    this.cue.hide();
  }
  drop({
    draggable,
    target,
    before,
    changeContainer
  }) {
    this.reorderService.reorder({
      before,
      changeContainer,
      source: draggable.context.column,
      target: target.context.column
    });
  }
  static ɵfac = function HeaderComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HeaderComponent)(ɵɵdirectiveInject(SinglePopupService), ɵɵdirectiveInject(DragHintService), ɵɵdirectiveInject(DropCueService), ɵɵdirectiveInject(ColumnReorderService), ɵɵdirectiveInject(IdService), ɵɵdirectiveInject(SortService), ɵɵdirectiveInject(ColumnInfoService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NavigationService4), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _HeaderComponent,
    selectors: [["", "kendoGridHeader", ""]],
    viewQuery: function HeaderComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(DropTargetDirective, 5)(FilterMenuComponent, 5)(ColumnMenuComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dropTargets = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.filterMenus = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columnMenus = _t);
      }
    },
    hostVars: 2,
    hostBindings: function HeaderComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-table-thead", ctx.hostClass);
      }
    },
    inputs: {
      totalColumnLevels: "totalColumnLevels",
      columns: "columns",
      groups: "groups",
      detailTemplate: "detailTemplate",
      scrollable: "scrollable",
      filterable: "filterable",
      sort: "sort",
      filter: "filter",
      sortable: "sortable",
      groupable: "groupable",
      lockedColumnsCount: "lockedColumnsCount",
      resizable: "resizable",
      reorderable: "reorderable",
      columnMenu: "columnMenu",
      columnMenuTemplate: "columnMenuTemplate",
      totalColumnsCount: "totalColumnsCount",
      totalColumns: "totalColumns",
      tabIndex: "tabIndex",
      size: "size"
    },
    features: [ɵɵNgOnChangesFeature],
    attrs: _c303,
    decls: 3,
    vars: 1,
    consts: [["link", ""], ["kendoGridLogicalRow", "", 3, "logicalRowIndex", "logicalSlaveRow", "logicalCellsCount", "logicalSlaveCellsCount", "totalColumns"], ["kendoGridFilterRow", "", "kendoGridLogicalRow", "", 3, "columns", "filter", "groups", "detailTemplate", "lockedColumnsCount", "logicalRowIndex", "logicalSlaveRow", "logicalCellsCount", "logicalSlaveCellsCount", "totalColumns"], ["role", "presentation", 1, "k-group-cell", "k-header", "k-table-th"], ["role", "presentation", 1, "k-hierarchy-cell", "k-header", "k-table-th"], ["kendoGridLogicalCell", "", "role", "columnheader", "aria-selected", "false", "kendoDropTarget", "", "kendoDraggable", "", "kendoDraggableColumn", "", 1, "k-header", "k-table-th", 3, "logicalRowIndex", "logicalColIndex", "headerLabelText", "colSpan", "rowSpan", "k-sorted", "enableDrag", "context", "k-filterable", "k-first", "k-grid-header-sticky", "ngClass", "ngStyle"], ["kendoGridLogicalCell", "", "kendoDropTarget", "", "kendoDraggable", "", "kendoDraggableColumn", "", 1, "k-header", "k-table-th", 3, "logicalRowIndex", "logicalColIndex", "rowSpan", "colSpan", "headerLabelText", "enableDrag", "context", "k-first", "k-filterable", "k-grid-content-sticky", "ngClass", "ngStyle"], ["kendoGridLogicalCell", "", "role", "columnheader", "aria-selected", "false", "kendoDropTarget", "", "kendoDraggable", "", "kendoDraggableColumn", "", 1, "k-header", "k-table-th", 3, "keydown", "logicalRowIndex", "logicalColIndex", "headerLabelText", "colSpan", "rowSpan", "enableDrag", "context", "ngClass", "ngStyle"], [1, "k-cell-inner"], ["kendoGridSelectAllCheckbox", "", "kendoGridFocusable", "", 3, "inputAttributes"], ["kendoGridColumnHandle", "", "kendoDraggable", "", 1, "k-column-resizer", 3, "isLast", "column", "columns"], [1, "k-link"], [3, "templateContext"], [1, "k-column-title"], [3, "column", "filter", "tabIndex"], [3, "standalone", "settings", "column", "columnMenuTemplate", "sort", "filter", "sortable", "tabIndex"], [1, "k-link", 3, "click"], ["role", "note", 3, "name", "svgIcon"], [1, "k-sort-order"], ["kendoGridLogicalCell", "", "kendoDropTarget", "", "kendoDraggable", "", "kendoDraggableColumn", "", 1, "k-header", "k-table-th", 3, "logicalRowIndex", "logicalColIndex", "rowSpan", "colSpan", "headerLabelText", "enableDrag", "context", "ngClass", "ngStyle"], [3, "standalone", "settings", "column", "columnMenuTemplate"]],
    template: function HeaderComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵrepeaterCreate(0, HeaderComponent_For_1_Template, 6, 6, "tr", 1, ɵɵrepeaterTrackByIndex);
        ɵɵconditionalCreate(2, HeaderComponent_Conditional_2_Template, 1, 10, "tr", 2);
      }
      if (rf & 2) {
        ɵɵrepeater(ctx.columnLevels);
        ɵɵadvance(2);
        ɵɵconditional(ctx.showFilterRow ? 2 : -1);
      }
    },
    dependencies: [LogicalRowDirective, LogicalCellDirective, DropTargetDirective, DraggableDirective, DraggableColumnDirective, NgClass, NgStyle, TemplateContextDirective, FilterMenuComponent, ColumnMenuComponent, IconWrapperComponent, SelectAllCheckboxDirective, FocusableDirective, ColumnHandleDirective, FilterRowComponent, CheckBoxComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HeaderComponent2, [{
    type: Component,
    args: [{
      selector: "[kendoGridHeader]",
      template: `
        @for (i of columnLevels; track $index; let levelIndex = $index) {
          <tr
            kendoGridLogicalRow
            [logicalRowIndex]="levelIndex"
            [logicalSlaveRow]="lockedColumnsCount > 0"
            [logicalCellsCount]="columns.length"
            [logicalSlaveCellsCount]="unlockedColumnsCount"
            [totalColumns]="totalColumns">
            @for (g of groups; track g) {
              <th
                class="k-group-cell k-header k-table-th"
                role="presentation"
                >
              </th>
            }
            @if (detailTemplate?.templateRef && !isStacked) {
              <th class="k-hierarchy-cell k-header k-table-th"
                role="presentation"
                >
              </th>
            }
            @for (column of columnsForLevel(levelIndex); track column.id; let columnIndex = $index; let last = $last) {
              @if (!isColumnGroupComponent(column)) {
                <th
                  kendoGridLogicalCell
                  [logicalRowIndex]="levelIndex"
                  [logicalColIndex]="logicalColumnIndex(column)"
                  [headerLabelText]="column.title || getColumnComponent(column).field"
                  [colSpan]="column.colspan"
                  [rowSpan]="column.rowspan(totalColumnLevels)"
                  role="columnheader"
                  aria-selected="false"
                  [attr.aria-sort]="sortState(getColumnComponent(column))"
                  [class.k-sorted]="sortState(getColumnComponent(column))"
                  (keydown)="onHeaderKeydown(getColumnComponent(column), $event)"
                  kendoDropTarget
                  kendoDraggable
                  kendoDraggableColumn
                  [enableDrag]="shouldActivate(column)"
                    [context]="{
                        field: getColumnComponent(column).field,
                        type: 'column',
                        column: column,
                        hint: column.title || getColumnComponent(column).field,
                        lastColumn: last && columnIndex === 0
                    }"
                  class="k-header k-table-th"
                  [class.k-filterable]="(showFilterMenu && isFilterable(getColumnComponent(column))) || showColumnMenu(column)"
                  [class.k-first]="isFirstOnRow(getColumnComponent(column), columnIndex)"
                  [class.k-grid-header-sticky]="column.sticky"
                  [ngClass]="column.headerClass"
                  [ngStyle]="column.sticky ? addStickyStyles(column) : column.headerStyle"
                  [attr.rowspan]="column.rowspan(totalColumnLevels)"
                  [attr.colspan]="column.colspan"
                  [attr.aria-haspopup]="isNavigable && (showFilterMenu || showColumnMenu(column)) ? 'dialog' : undefined"
                  [attr.aria-expanded]="isNavigable && (showFilterMenu || showColumnMenu(column)) ? false : undefined"
                  [attr.aria-keyshortcuts]="isNavigable && (showFilterMenu || showColumnMenu(column)) ? 'Alt + ArrowDown' : undefined">
                  @if (!isInteractive(getColumnComponent(column), 'sortable')) {
                    <span class="k-cell-inner">
                      <span class="k-link" [class.!k-cursor-default]="!isInteractive(getColumnComponent(column), 'groupable') && !isInteractive(getColumnComponent(column), 'reorderable')">
                        <ng-template
                                    [templateContext]="{
                                        templateRef: column.headerTemplateRef,
                                        columnIndex: column.leafIndex,
                                        column: column,
                                        $implicit: column
                                    }">
                        </ng-template>
                        @if (!column.headerTemplateRef) {
                          <span class="k-column-title">{{column.displayTitle}}</span>
                        }
                      </span>
                      @if (showFilterMenu && isFilterable(getColumnComponent(column))) {
                        <kendo-grid-filter-menu
                          [column]="getColumnComponent(column)"
                          [filter]="filter"
                          [tabIndex]="tabIndex">
                        </kendo-grid-filter-menu>
                      }
                      @if (showColumnMenu(column)) {
                        <kendo-grid-column-menu
                          [standalone]="false"
                          [settings]="columnMenuSettings"
                          [column]="column"
                          [columnMenuTemplate]="columnMenuTemplate"
                          [sort]="sort"
                          [filter]="filter"
                          [sortable]="sortable"
                          [tabIndex]="tabIndex">
                        </kendo-grid-column-menu>
                      }
                    </span>
                  }
                  @if (isInteractive(getColumnComponent(column), 'sortable')) {
                    <span class="k-cell-inner">
                      <span #link class="k-link" (click)="onSortClick(getColumnComponent(column), $event, link)">
                        <ng-template
                                    [templateContext]="{
                                        templateRef: column.headerTemplateRef,
                                        columnIndex: column.leafIndex,
                                        column: column,
                                        $implicit: column
                                    }">
                        </ng-template>
                        @if (!column.headerTemplateRef) {
                          <span class="k-column-title">{{column.displayTitle}}</span>
                        }
                        <span [class.k-sort-icon]="sortDescriptor(getColumnComponent(column).field).dir">
                          @if (sortDescriptor(getColumnComponent(column).field).dir) {
                            <kendo-icon-wrapper
                              role="note" [attr.aria-label]="sortableLabel"
                              name="sort-{{sortDescriptor(getColumnComponent(column).field).dir}}-small"
                              [svgIcon]="sortDescriptor(getColumnComponent(column).field).dir === 'asc' ? sortAscSmallIcon : sortDescSmallIcon"
                            ></kendo-icon-wrapper>
                          }
                        </span>
                        @if (showSortNumbering(getColumnComponent(column))) {
                          <span class="k-sort-order">{{sortOrder(getColumnComponent(column).field)}}</span>
                        }
                      </span>
                      @if (showFilterMenu && isFilterable(getColumnComponent(column))) {
                        <kendo-grid-filter-menu
                          [column]="getColumnComponent(column)"
                          [filter]="filter"
                          [tabIndex]="tabIndex">
                        </kendo-grid-filter-menu>
                      }
                      @if (showColumnMenu(column)) {
                        <kendo-grid-column-menu
                          [standalone]="false"
                          [settings]="columnMenuSettings"
                          [column]="column"
                          [columnMenuTemplate]="columnMenuTemplate"
                          [sort]="sort"
                          [filter]="filter"
                          [sortable]="sortable"
                          [tabIndex]="tabIndex">
                        </kendo-grid-column-menu>
                      }
                    </span>
                  }
                  @if (isCheckboxColumn(column) && !column.headerTemplateRef && $any(column).showSelectAll) {
                    <kendo-checkbox
                      [attr.id]="selectAllCheckboxId()"
                      [inputAttributes]="{'aria-label': selectAllCheckboxLabel}"
                      kendoGridSelectAllCheckbox
                      kendoGridFocusable
                    ></kendo-checkbox>
                  }
                  @if (resizable) {
                    <span kendoGridColumnHandle
                      kendoDraggable
                      class="k-column-resizer"
                      [isLast]="last"
                      [column]="column"
                      [columns]="columns">
                    </span>
                  }
                </th>
              }
              @if (isColumnGroupComponent(column)) {
                <th
                  kendoGridLogicalCell
                  [logicalRowIndex]="levelIndex"
                  [logicalColIndex]="logicalColumnIndex(column)"
                  [rowSpan]="column.rowspan(totalColumnLevels)"
                  [colSpan]="column.colspan"
                  [headerLabelText]="column.title || getColumnComponent(column).field"
                  kendoDropTarget
                  kendoDraggable
                  kendoDraggableColumn
                  [enableDrag]="shouldActivate(column)"
                    [context]="{
                        type: 'columnGroup',
                        column: column,
                        hint: column.title,
                        lastColumn: last && columnIndex === 0
                    }"
                  class="k-header k-table-th"
                  [class.k-first]="isFirstOnRow(getColumnComponent(column), columnIndex)"
                  [class.k-filterable]="showColumnMenu(column)"
                  [class.k-grid-content-sticky]="column.sticky"
                  [ngClass]="column.headerClass"
                  [ngStyle]="column.headerStyle"
                  [attr.aria-haspopup]="(isNavigable && showColumnMenu(column)) ? 'dialog' : undefined"
                  [attr.aria-expanded]="(isNavigable && showColumnMenu(column)) ? false : undefined"
                  [attr.aria-keyshortcuts]="isNavigable && showColumnMenu(column) ? 'Alt + ArrowDown' : undefined"
                  [attr.rowspan]="column.rowspan(totalColumnLevels)"
                  [attr.colspan]="column.colspan">
                  <span class="k-cell-inner">
                    <span class="k-link" [class.!k-cursor-default]="!isInteractive(getColumnComponent(column), 'reorderable')">
                      <ng-template
                                [templateContext]="{
                                    templateRef: column.headerTemplateRef,
                                    columnIndex: lockedColumnsCount + columnIndex,
                                    column: column,
                                    $implicit: column
                                }">
                      </ng-template>
                      @if (!column.headerTemplateRef) {
                        <span class="k-column-title">{{column.displayTitle}}</span>
                      }
                    </span>
                    @if (showColumnMenu(column)) {
                      <kendo-grid-column-menu
                        [standalone]="false"
                        [settings]="columnMenuSettings"
                        [column]="column"
                        [columnMenuTemplate]="columnMenuTemplate">
                      </kendo-grid-column-menu>
                    }
                  </span>
                  @if (resizable) {
                    <span kendoGridColumnHandle
                      kendoDraggable
                      class="k-column-resizer"
                      [isLast]="last"
                      [column]="column"
                      [columns]="columns">
                    </span>
                  }
                </th>
              }
            }
          </tr>
        }
        @if (showFilterRow) {
          <tr
            kendoGridFilterRow
            [columns]="leafColumns"
            [filter]="filter"
            [groups]="groups"
            [detailTemplate]="detailTemplate"
            [lockedColumnsCount]="lockedColumnsCount"
            kendoGridLogicalRow
            [logicalRowIndex]="totalColumnLevels + 1"
            [logicalSlaveRow]="lockedColumnsCount > 0"
            [logicalCellsCount]="columns.length"
            [logicalSlaveCellsCount]="unlockedColumnsCount"
          [totalColumns]="totalColumns"></tr>
        }
        `,
      standalone: true,
      imports: [LogicalRowDirective, LogicalCellDirective, DropTargetDirective, DraggableDirective, DraggableColumnDirective, NgClass, NgStyle, TemplateContextDirective, FilterMenuComponent, ColumnMenuComponent, IconWrapperComponent, SelectAllCheckboxDirective, FocusableDirective, ColumnHandleDirective, FilterRowComponent, CheckBoxComponent]
    }]
  }], () => [{
    type: SinglePopupService
  }, {
    type: DragHintService
  }, {
    type: DropCueService
  }, {
    type: ColumnReorderService
  }, {
    type: IdService
  }, {
    type: SortService
  }, {
    type: ColumnInfoService
  }, {
    type: ChangeDetectorRef
  }, {
    type: ContextService
  }, {
    type: NavigationService4
  }, {
    type: NgZone
  }], {
    totalColumnLevels: [{
      type: Input
    }],
    columns: [{
      type: Input
    }],
    groups: [{
      type: Input
    }],
    detailTemplate: [{
      type: Input
    }],
    scrollable: [{
      type: Input
    }],
    filterable: [{
      type: Input
    }],
    sort: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    sortable: [{
      type: Input
    }],
    groupable: [{
      type: Input
    }],
    lockedColumnsCount: [{
      type: Input
    }],
    resizable: [{
      type: Input
    }],
    reorderable: [{
      type: Input
    }],
    columnMenu: [{
      type: Input
    }],
    columnMenuTemplate: [{
      type: Input
    }],
    totalColumnsCount: [{
      type: Input
    }],
    totalColumns: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    hostClass: [{
      type: HostBinding,
      args: ["class.k-table-thead"]
    }],
    dropTargets: [{
      type: ViewChildren,
      args: [DropTargetDirective]
    }],
    filterMenus: [{
      type: ViewChildren,
      args: [FilterMenuComponent]
    }],
    columnMenus: [{
      type: ViewChildren,
      args: [ColumnMenuComponent]
    }]
  });
})();
var FooterComponent2 = class _FooterComponent {
  columnInfoService;
  ctx;
  columns = [];
  groups = [];
  detailTemplate;
  scrollable;
  lockedColumnsCount = 0;
  logicalRowIndex = 0;
  totalColumns;
  totalColumnsCount = 0;
  get footerClass() {
    return !this.scrollable;
  }
  hostClass = true;
  hostRole = "rowgroup";
  constructor(columnInfoService, ctx) {
    this.columnInfoService = columnInfoService;
    this.ctx = ctx;
  }
  get columnsToRender() {
    return columnsToRender(this.columns || []);
  }
  // Number of unlocked columns in the next table, if any
  get unlockedColumnsCount() {
    return this.totalColumnsCount - (this.isStacked ? 0 : this.lockedColumnsCount) - this.columns.length;
  }
  trackByIndex(index) {
    return index;
  }
  logicalColumnIndex(column) {
    const index = column.leafIndex;
    if (isPresent7(index)) {
      return index + (isPresent7(this.detailTemplate) ? 1 : 0);
    }
    return -1;
  }
  addStickyStyles(column) {
    const stickyStyles = this.columnInfoService.stickyColumnsStyles(column);
    return __spreadValues(__spreadValues({}, column.footerStyle), stickyStyles);
  }
  isColumnGroupComponent(column) {
    return isColumnGroupComponent(column);
  }
  get isStacked() {
    return this.ctx.grid?.isStacked;
  }
  static ɵfac = function FooterComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FooterComponent)(ɵɵdirectiveInject(ColumnInfoService), ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _FooterComponent,
    selectors: [["", "kendoGridFooter", ""]],
    hostVars: 5,
    hostBindings: function FooterComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("role", ctx.hostRole);
        ɵɵclassProp("k-grid-footer", ctx.footerClass)("k-table-tfoot", ctx.hostClass);
      }
    },
    inputs: {
      columns: "columns",
      groups: "groups",
      detailTemplate: "detailTemplate",
      scrollable: "scrollable",
      lockedColumnsCount: "lockedColumnsCount",
      logicalRowIndex: "logicalRowIndex",
      totalColumns: "totalColumns",
      totalColumnsCount: "totalColumnsCount"
    },
    attrs: _c353,
    decls: 6,
    vars: 9,
    consts: [["kendoGridLogicalRow", "", 1, "k-footer-template", 3, "logicalRowIndex", "logicalSlaveRow", "logicalCellsCount", "logicalSlaveCellsCount", "totalColumns"], ["role", "presentation", 1, "k-table-td", "k-hierarchy-cell"], ["kendoGridLogicalCell", "", "role", "gridcell", "aria-selected", "false", 1, "k-table-td", 3, "logicalRowIndex", "logicalColIndex"], ["role", "presentation", 1, "k-table-td", "k-group-cell", "k-table-group-td"], ["kendoGridLogicalCell", "", "role", "gridcell", "aria-selected", "false", 1, "k-table-td", 3, "logicalRowIndex", "logicalColIndex", "k-grid-footer-sticky", "ngClass", "ngStyle"], ["kendoGridLogicalCell", "", "role", "gridcell", "aria-selected", "false", 1, "k-table-td", 3, "logicalRowIndex", "logicalColIndex", "ngClass", "ngStyle"], [3, "templateContext"], [1, "k-grid-column-template"], [1, "k-column-template-item"]],
    template: function FooterComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainerStart(0);
        ɵɵelementStart(1, "tr", 0);
        ɵɵconditionalCreate(2, FooterComponent_Conditional_2_Template, 2, 0);
        ɵɵconditionalCreate(3, FooterComponent_Conditional_3_Template, 1, 0, "td", 1);
        ɵɵconditionalCreate(4, FooterComponent_Conditional_4_Template, 2, 0);
        ɵɵconditionalCreate(5, FooterComponent_Conditional_5_Template, 4, 2, "td", 2);
        ɵɵelementEnd();
        ɵɵelementContainerEnd();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("logicalRowIndex", ctx.logicalRowIndex)("logicalSlaveRow", ctx.lockedColumnsCount > 0 && !ctx.isStacked)("logicalCellsCount", ctx.columns.length)("logicalSlaveCellsCount", ctx.unlockedColumnsCount)("totalColumns", ctx.totalColumns);
        ɵɵadvance();
        ɵɵconditional(!ctx.isStacked ? 2 : -1);
        ɵɵadvance();
        ɵɵconditional((ctx.detailTemplate == null ? null : ctx.detailTemplate.templateRef) && !ctx.isStacked ? 3 : -1);
        ɵɵadvance();
        ɵɵconditional(!ctx.isStacked ? 4 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.isStacked ? 5 : -1);
      }
    },
    dependencies: [LogicalRowDirective, LogicalCellDirective, NgClass, NgStyle, TemplateContextDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FooterComponent2, [{
    type: Component,
    args: [{
      selector: "[kendoGridFooter]",
      template: `
    <ng-container>
      <tr
        class="k-footer-template"
        kendoGridLogicalRow
        [logicalRowIndex]="logicalRowIndex"
        [logicalSlaveRow]="lockedColumnsCount > 0 && !isStacked"
        [logicalCellsCount]="columns.length"
        [logicalSlaveCellsCount]="unlockedColumnsCount"
        [totalColumns]="totalColumns"
        >
        @if (!isStacked) {
          @for (g of groups; track g) {
            <td
              class="k-table-td k-group-cell k-table-group-td"
              role="presentation"
              >
            </td>
          }
        }
        @if (detailTemplate?.templateRef && !isStacked) {
          <td
            role="presentation"
            class="k-table-td k-hierarchy-cell"
            >
          </td>
        }
        @if (!isStacked) {
          @for (column of columnsToRender; track $index; let columnIndex = $index) {
            @if (!isColumnGroupComponent(column)) {
              <td
                kendoGridLogicalCell
                class="k-table-td"
                [logicalRowIndex]="logicalRowIndex"
                [logicalColIndex]="logicalColumnIndex(column)"
                role="gridcell"
                aria-selected="false"
                [class.k-grid-footer-sticky]="column.sticky"
                [ngClass]="column.footerClass"
                [ngStyle]="column.sticky ? addStickyStyles(column) : column.footerStyle">
                <ng-template
                            [templateContext]="{
                                templateRef: column.footerTemplateRef,
                                columnIndex: column.leafIndex,
                                column: column,
                                $implicit: column
                            }">
                </ng-template>
              </td>
            }
          }
        }

        @if (isStacked) {
          <td kendoGridLogicalCell
            class="k-table-td"
            [logicalRowIndex]="logicalRowIndex"
            [logicalColIndex]="detailTemplate ? 1 : 0"
            role="gridcell"
            aria-selected="false">
            <div class="k-grid-column-template">
              @for (column of columnsToRender; track $index) {
                @if (column.footerTemplateRef) {
                  <div class="k-column-template-item">
                    <ng-template
                                    [templateContext]="{
                                        templateRef: column.footerTemplateRef,
                                        columnIndex: column.leafIndex,
                                        column: column,
                                        $implicit: column
                                    }">
                    </ng-template>
                  </div>
                }
              }
            </div>
          </td>
        }
      </tr>
    </ng-container>
    `,
      standalone: true,
      imports: [LogicalRowDirective, LogicalCellDirective, NgClass, NgStyle, TemplateContextDirective]
    }]
  }], () => [{
    type: ColumnInfoService
  }, {
    type: ContextService
  }], {
    columns: [{
      type: Input
    }],
    groups: [{
      type: Input
    }],
    detailTemplate: [{
      type: Input
    }],
    scrollable: [{
      type: Input
    }],
    lockedColumnsCount: [{
      type: Input
    }],
    logicalRowIndex: [{
      type: Input
    }],
    totalColumns: [{
      type: Input
    }],
    totalColumnsCount: [{
      type: Input
    }],
    footerClass: [{
      type: HostBinding,
      args: ["class.k-grid-footer"]
    }],
    hostClass: [{
      type: HostBinding,
      args: ["class.k-table-tfoot"]
    }],
    hostRole: [{
      type: HostBinding,
      args: ["attr.role"]
    }]
  });
})();
var CommandColumnComponent = class _CommandColumnComponent extends ColumnBase2 {
  parent;
  template;
  constructor(parent, idService) {
    super(parent, idService);
    this.parent = parent;
  }
  get templateRef() {
    return this.template ? this.template.templateRef : void 0;
  }
  /**
   * Sets a function to determine the rowspan of each column cell.
   */
  set cellRowspan(cellRowspan) {
    super.cellRowspan = cellRowspan;
  }
  get cellRowspan() {
    return super.cellRowspan;
  }
  static ɵfac = function CommandColumnComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CommandColumnComponent)(ɵɵdirectiveInject(ColumnBase2, 13), ɵɵdirectiveInject(IdService, 8));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _CommandColumnComponent,
    selectors: [["kendo-grid-command-column"]],
    contentQueries: function CommandColumnComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, CellTemplateDirective2, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.template = _t.first);
      }
    },
    features: [ɵɵProvidersFeature([{
      provide: ColumnBase2,
      useExisting: forwardRef(() => _CommandColumnComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function CommandColumnComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CommandColumnComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: ColumnBase2,
        useExisting: forwardRef(() => CommandColumnComponent)
      }],
      selector: "kendo-grid-command-column",
      template: ``,
      standalone: true
    }]
  }], () => [{
    type: ColumnBase2,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }, {
      type: Optional
    }]
  }, {
    type: IdService,
    decorators: [{
      type: Optional
    }]
  }], {
    template: [{
      type: ContentChild,
      args: [CellTemplateDirective2, {
        static: false
      }]
    }]
  });
})();
var CheckboxColumnComponent = class _CheckboxColumnComponent extends ColumnBase2 {
  selectionService;
  cellSelectionService;
  parent;
  /**
   * Shows a select-all `kendoGridSelectAllCheckbox` checkbox in the header.
   */
  showSelectAll;
  /**
   * Shows checkboxes for rows marked as non-selectable. By default, these checkboxes are visible and disabled.
   */
  showDisabledCheckbox = true;
  /*
   * @hidden
   */
  isCheckboxColumn = true;
  template;
  constructor(selectionService, cellSelectionService, parent, idService) {
    super(parent, idService);
    this.selectionService = selectionService;
    this.cellSelectionService = cellSelectionService;
    this.parent = parent;
  }
  get templateRef() {
    return this.template ? this.template.templateRef : void 0;
  }
  /**
   * @hidden
   */
  rowSelectable(rowIdx) {
    return !this.selectionService.nonSelectableRows.has(rowIdx) && !this.cellSelectionService.nonSelectableRows.has(rowIdx);
  }
  /**
   * Defines a function to determine the rowspan of each column cell.
   */
  set cellRowspan(cellRowspan) {
    super.cellRowspan = cellRowspan;
  }
  get cellRowspan() {
    return super.cellRowspan;
  }
  static ɵfac = function CheckboxColumnComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CheckboxColumnComponent)(ɵɵdirectiveInject(SelectionService2), ɵɵdirectiveInject(CellSelectionService), ɵɵdirectiveInject(ColumnBase2, 13), ɵɵdirectiveInject(IdService, 8));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _CheckboxColumnComponent,
    selectors: [["kendo-grid-checkbox-column"]],
    contentQueries: function CheckboxColumnComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, CellTemplateDirective2, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.template = _t.first);
      }
    },
    inputs: {
      showSelectAll: "showSelectAll",
      showDisabledCheckbox: "showDisabledCheckbox"
    },
    features: [ɵɵProvidersFeature([{
      provide: ColumnBase2,
      useExisting: forwardRef(() => _CheckboxColumnComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function CheckboxColumnComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CheckboxColumnComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: ColumnBase2,
        useExisting: forwardRef(() => CheckboxColumnComponent)
      }],
      selector: "kendo-grid-checkbox-column",
      template: ``,
      standalone: true
    }]
  }], () => [{
    type: SelectionService2
  }, {
    type: CellSelectionService
  }, {
    type: ColumnBase2,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }, {
      type: Optional
    }]
  }, {
    type: IdService,
    decorators: [{
      type: Optional
    }]
  }], {
    showSelectAll: [{
      type: Input
    }],
    showDisabledCheckbox: [{
      type: Input
    }],
    template: [{
      type: ContentChild,
      args: [CellTemplateDirective2, {
        static: false
      }]
    }]
  });
})();
var SelectionCheckboxDirective = class _SelectionCheckboxDirective {
  selectionService;
  cellSelectionService;
  aggregateService;
  el;
  renderer;
  ngZone;
  checkbox;
  /**
   * Sets the index of the `dataItem` to select.
   */
  itemIndex;
  destroyClick;
  destroyKeyDown;
  ngAfterContentChecked() {
    this.setCheckedState();
  }
  constructor(selectionService, cellSelectionService, aggregateService, el, renderer, ngZone, checkbox) {
    this.selectionService = selectionService;
    this.cellSelectionService = cellSelectionService;
    this.aggregateService = aggregateService;
    this.el = el;
    this.renderer = renderer;
    this.ngZone = ngZone;
    this.checkbox = checkbox;
    this.ngZone.runOutsideAngular(() => {
      this.destroyClick = this.renderer.listen(this.el.nativeElement, "click", this.onClick.bind(this));
      this.destroyKeyDown = this.renderer.listen(this.el.nativeElement, "keydown", this.onKeyDown.bind(this));
    });
  }
  ngOnDestroy() {
    if (this.destroyClick) {
      this.destroyClick();
    }
    if (this.destroyKeyDown) {
      this.destroyKeyDown();
    }
  }
  onClick(event) {
    const nonSelectableRow = this.selectionService.nonSelectableRows.has(this.itemIndex) || this.cellSelectionService.nonSelectableRows.has(this.itemIndex);
    if (nonSelectableRow || this.cellSelectionService.active) {
      event.preventDefault();
      return;
    }
    if (this.selectionService.options.enabled) {
      this.ngZone.run(() => {
        let ev;
        const ctrlKey = event.ctrlKey || event.metaKey;
        if (event.shiftKey && this.selectionService.options.mode === "multiple") {
          const item = {
            index: this.itemIndex
          };
          ev = this.selectionService.addAllTo(item, ctrlKey, false, event.shiftKey);
        } else {
          ev = this.selectionService.toggleByIndex(this.itemIndex);
        }
        ev.ctrlKey = event.ctrlKey;
        ev.shiftKey = event.shiftKey;
        if (this.selectionService.options.cellAggregates) {
          ev.cellAggregates = this.aggregateService.onSelectionChange(ev);
        }
        this.selectionService.changes.emit(ev);
      });
    }
  }
  onKeyDown(e) {
    if (e.code === Keys.Enter || e.code === Keys.NumpadEnter) {
      this.onClick(e);
    }
  }
  /*
   * @hidden
   */
  setCheckedState() {
    const isSelected = this.selectionService.nonSelectableRows.has(this.itemIndex) ? false : this.selectionService.isSelected(this.itemIndex);
    if (this.checkbox) {
      this.checkbox.checkedState = isSelected;
    } else {
      this.renderer.setProperty(this.el.nativeElement, "checked", isSelected);
    }
  }
  static ɵfac = function SelectionCheckboxDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SelectionCheckboxDirective)(ɵɵdirectiveInject(SelectionService2), ɵɵdirectiveInject(CellSelectionService), ɵɵdirectiveInject(CellSelectionAggregateService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(CheckBoxComponent, 9));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _SelectionCheckboxDirective,
    selectors: [["", "kendoGridSelectionCheckbox", ""]],
    inputs: {
      itemIndex: [0, "kendoGridSelectionCheckbox", "itemIndex"]
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectionCheckboxDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridSelectionCheckbox]",
      standalone: true
    }]
  }], () => [{
    type: SelectionService2
  }, {
    type: CellSelectionService
  }, {
    type: CellSelectionAggregateService
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: NgZone
  }, {
    type: CheckBoxComponent,
    decorators: [{
      type: Host
    }, {
      type: Optional
    }]
  }], {
    itemIndex: [{
      type: Input,
      args: ["kendoGridSelectionCheckbox"]
    }]
  });
})();
var ChangeNotificationService = class _ChangeNotificationService {
  ngZone;
  changes = new EventEmitter();
  subscription;
  constructor(ngZone) {
    this.ngZone = ngZone;
  }
  notify() {
    if (!this.subscription || this.subscription.closed) {
      this.subscription = this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => this.changes.emit());
    }
  }
  static ɵfac = function ChangeNotificationService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ChangeNotificationService)(ɵɵinject(NgZone));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ChangeNotificationService,
    factory: _ChangeNotificationService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChangeNotificationService, [{
    type: Injectable
  }], () => [{
    type: NgZone
  }], null);
})();
var NoRecordsTemplateDirective = class _NoRecordsTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function NoRecordsTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NoRecordsTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _NoRecordsTemplateDirective,
    selectors: [["", "kendoGridNoRecordsTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NoRecordsTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridNoRecordsTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
function defaultTrackBy(index, item) {
  if (item.type === "data" && item.isEditing) {
    return item.data;
  }
  return index;
}
var NON_DATA_CELL_CLASSES = "k-hierarchy-cell k-detail-cell k-group-cell";
var NON_DATA_ROW_CLASSES = "k-grouping-row k-group-footer k-detail-row k-grid-norecords";
var IGNORE_TARGET_CLASSSES = "k-icon k-svg-icon";
var IGNORE_CONTAINER_CLASSES = "k-grid k-grid-ignore-click";
var CellComponent = class _CellComponent {
  editService;
  idService;
  ctx;
  detailsService;
  localization;
  cellContext;
  get commandCellClass() {
    return this.isCommand(this.column);
  }
  get dragHandleCellClass() {
    return isRowReorderColumn(this.column);
  }
  get dragRowHandleLabel() {
    return isRowReorderColumn(this.column) ? this.ctx.localization.get("dragRowHandleLabel") : void 0;
  }
  column;
  columns;
  columnIndex;
  isNew = false;
  isLoading = false;
  isVirtual = false;
  loadingTemplate;
  detailTemplate;
  item;
  set rowIndex(index) {
    this._rowIndex = index;
    this.updateCellContext();
  }
  get rowIndex() {
    return this._rowIndex;
  }
  dataItem;
  reorderIcon = reorderIcon;
  minusIcon = minusIcon;
  plusIcon = plusIcon;
  detailButtonIconName(viewItem) {
    return viewItem.isExpanded ? "minus" : "plus";
  }
  detailButtonSvgIcon(viewItem) {
    return viewItem.isExpanded ? this.minusIcon : this.plusIcon;
  }
  detailButtonText(viewItem) {
    return viewItem.isExpanded ? this.localization.get("detailCollapse") : this.localization.get("detailExpand");
  }
  toggleRow(index, dataItem) {
    this.detailsService.toggleRow(index, dataItem);
    return false;
  }
  get stackedRowClass() {
    const columnsLength = this.ctx.grid.stackedColumns?.columns.length;
    if (this.ctx.grid.stackedColumns.areDefault && columnsLength > 1) {
      return `k-grid-cols-${columnsLength}`;
    }
  }
  get stackedRowStyle() {
    const columnsWidths = this.ctx.grid.stackedColumns.columns.map((c) => c.width).join(" ");
    if (!this.ctx.grid.stackedColumns.areDefault && columnsWidths) {
      return {
        "grid-template-columns": `${columnsWidths}`
      };
    }
  }
  isEdited(column) {
    const currentColumn = column || this.column;
    if (!(this.editService.isEditing() || this.isNew) || !this.isColumnEditable(column)) {
      return false;
    }
    const editContext = this.editService.columnContext(this.rowIndex, currentColumn);
    return this.isFieldEditable(editContext, currentColumn);
  }
  get showLoading() {
    return this.isVirtual && this.isLoading;
  }
  get formGroup() {
    return this.editService.context(this.rowIndex).group;
  }
  getTemplateContext(column) {
    this._templateContext.isNew = this.isNew;
    this._templateContext.column = column || this.column;
    this._templateContext.dataItem = this.dataItem;
    this._templateContext.rowIndex = this.rowIndex;
    this._templateContext.columnIndex = this.columnIndex;
    this._templateContext.$implicit = this.dataItem;
    return this._templateContext;
  }
  get isStackedLayoutMode() {
    return this.ctx.grid?.isStacked;
  }
  getEditTemplateContext(column) {
    this._editTemplateContext.$implicit = this.formGroup;
    this._editTemplateContext.isNew = this.isNew;
    this._editTemplateContext.column = column || this.column;
    this._editTemplateContext.dataItem = this.dataItem;
    this._editTemplateContext.formGroup = this.formGroup;
    this._editTemplateContext.rowIndex = this.rowIndex;
    return this._editTemplateContext;
  }
  get rowReorderTemplateContext() {
    this._rowReorderTemplateContext.$implicit = this.dataItem;
    this._rowReorderTemplateContext.columnIndex = this.columnIndex;
    this._rowReorderTemplateContext.rowIndex = this.rowIndex;
    return this._rowReorderTemplateContext;
  }
  get format() {
    if (isColumnComponent(this.column) && !isNullOrEmptyString2(this.column.format)) {
      return extractFormat(this.column.format);
    }
    return void 0;
  }
  isBoundColumn(column) {
    const currentColumn = column || this.column;
    return currentColumn.field && !currentColumn.templateRef;
  }
  isCheckboxColumn(column) {
    const currentColumn = column || this.column;
    return isCheckboxColumn(currentColumn) && !currentColumn.templateRef;
  }
  get selectionCheckboxId() {
    return this.idService.selectionCheckboxId(this.rowIndex);
  }
  get selectionCheckboxLabel() {
    return this.ctx.localization.get("selectionCheckboxLabel");
  }
  get isSpanColumn() {
    return isSpanColumn(this.column) && !this.column.templateRef;
  }
  get children() {
    return columnsToRender([this.column]);
  }
  isRowReorderColumn(column) {
    const currentColumn = column || this.column;
    return isRowReorderColumn(currentColumn) && !currentColumn.templateRef;
  }
  isRowSelectable(column) {
    const currentColumn = column || this.column;
    return currentColumn.rowSelectable(this._rowIndex);
  }
  _rowIndex;
  isColumnEditable(column) {
    const currentColumn = column || this.column;
    if (!currentColumn || this.isCommand(currentColumn)) {
      return false;
    }
    return currentColumn.editable !== false;
  }
  _templateContext = {};
  _editTemplateContext = {};
  _rowReorderTemplateContext = {};
  constructor(editService, idService, ctx, detailsService, localization, cellContext) {
    this.editService = editService;
    this.idService = idService;
    this.ctx = ctx;
    this.detailsService = detailsService;
    this.localization = localization;
    this.cellContext = cellContext;
  }
  ngDoCheck() {
    this.updateCellContext();
  }
  isCommand(column) {
    return column instanceof CommandColumnComponent;
  }
  isFieldEditable(editContext, column) {
    if (!isPresent7(editContext)) {
      return false;
    }
    if (isPresent7(column.editTemplate)) {
      return true;
    }
    return isPresent7(editContext.group) && isPresent7(editContext.group.get(column.field));
  }
  updateCellContext() {
    if (this.cellContext) {
      this.cellContext.rowIndex = this._rowIndex;
    }
  }
  static ɵfac = function CellComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CellComponent)(ɵɵdirectiveInject(EditService), ɵɵdirectiveInject(IdService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(DetailsService), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(CELL_CONTEXT, 8));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _CellComponent,
    selectors: [["", "kendoGridCell", ""]],
    hostVars: 7,
    hostBindings: function CellComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("aria-label", ctx.dragRowHandleLabel);
        ɵɵclassProp("k-command-cell", ctx.commandCellClass)("k-drag-cell", ctx.dragHandleCellClass)("k-touch-action-none", ctx.dragHandleCellClass);
      }
    },
    inputs: {
      column: "column",
      columns: "columns",
      columnIndex: "columnIndex",
      isNew: "isNew",
      isLoading: "isLoading",
      isVirtual: "isVirtual",
      loadingTemplate: "loadingTemplate",
      detailTemplate: "detailTemplate",
      item: "item",
      rowIndex: "rowIndex",
      dataItem: "dataItem"
    },
    attrs: _c363,
    decls: 2,
    vars: 2,
    consts: [["headerTemplate", ""], ["template", ""], [1, "k-grid-stack-row", 3, "ngClass", "ngStyle"], [1, "k-grid-stack-cell", 3, "k-grid-stack-edit-cell", "k-drag-cell", "k-command-cell", "kendoGridFocusable"], [1, "k-grid-stack-cell"], [1, "k-grid-stack-cell", 3, "kendoGridFocusable"], [1, "k-grid-stack-header"], [3, "templateContext"], [1, "k-grid-stack-content"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "kendoGridSelectionCheckbox", "inputAttributes", "title"], [3, "kendoGridSelectionCheckbox", "inputAttributes", "title", "disabled"], ["name", "reorder", 3, "svgIcon"], ["kendoGridFocusable", "", 3, "format", "formControl"], ["kendoGridFocusable", "", 3, "formControl"], ["kendoButton", "", "fillMode", "flat", "themeColor", "primary", 3, "click", "icon", "svgIcon"], [1, "k-skeleton-text", "k-skeleton"]],
    template: function CellComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵconditionalCreate(0, CellComponent_Conditional_0_Template, 4, 3, "div", 2);
        ɵɵconditionalCreate(1, CellComponent_Conditional_1_Template, 2, 1);
      }
      if (rf & 2) {
        ɵɵconditional(ctx.isStackedLayoutMode ? 0 : -1);
        ɵɵadvance();
        ɵɵconditional(!ctx.isStackedLayoutMode ? 1 : -1);
      }
    },
    dependencies: [NgTemplateOutlet, FocusableDirective, SelectionCheckboxDirective, TemplateContextDirective, IconWrapperComponent, NumericTextBoxComponent, DatePickerComponent, FieldAccessorPipe, ReactiveFormsModule, NgControlStatus, FormControlDirective, CheckBoxComponent, TextBoxComponent, NgClass, NgStyle, ButtonComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CellComponent, [{
    type: Component,
    args: [{
      selector: "[kendoGridCell]",
      template: `
        @if (isStackedLayoutMode) {
            <div class="k-grid-stack-row"
                [ngClass]="stackedRowClass"
                [ngStyle]="stackedRowStyle">
                @for (col of columns; track $index) {
                    <div class="k-grid-stack-cell"
                        [class.k-grid-stack-edit-cell]="isEdited(col)"
                        [class.k-drag-cell]="isRowReorderColumn(col) && !isNew"
                        [class.k-command-cell]="isCommand(col)"
                        [kendoGridFocusable]="!isCommand(col)">
                        <div class="k-grid-stack-header">
                            @if (!col.headerTemplateRef) {
                                {{col.displayTitle}}
                            } @else {
                                <ng-template #headerTemplate
                                    [templateContext]="{
                                        templateRef: col.headerTemplateRef,
                                        columnIndex: col.leafIndex,
                                        column: col,
                                        $implicit: col
                                    }">
                                </ng-template>
                            }
                        </div>
                        <div class="k-grid-stack-content">
                            @if (!isEdited(col)) {
                                @if (!col.templateRef) {
                                    @if (isBoundColumn(col)) {{{ dataItem | valueOf: col.field: col.format}}}
                                    @if (isCheckboxColumn(col) && !isNew) {
                                        @if (isRowSelectable(col)) {
                                            <kendo-checkbox
                                                [kendoGridSelectionCheckbox]="rowIndex"
                                                [attr.id]="selectionCheckboxId"
                                                [inputAttributes]="{'aria-label': selectionCheckboxLabel}"
                                                [title]="selectionCheckboxLabel">
                                            </kendo-checkbox>
                                        } @else {
                                            @if (col.showDisabledCheckbox) {
                                                <kendo-checkbox
                                                    [kendoGridSelectionCheckbox]="rowIndex"
                                                    [attr.id]="selectionCheckboxId"
                                                    [inputAttributes]="{'aria-label': selectionCheckboxLabel}"
                                                    [title]="selectionCheckboxLabel"
                                                    [disabled]="true"
                                                ></kendo-checkbox>
                                            }
                                        }
                                    }
                                    @if (isRowReorderColumn(col) && !isNew) {
                                        @if (!col.dragHandleTemplate?.first) {
                                            <kendo-icon-wrapper
                                                name="reorder"
                                                [svgIcon]="reorderIcon">
                                            </kendo-icon-wrapper>
                                        } @else {
                                            <ng-template
                                                [ngTemplateOutlet]="col.rowDragHandleTemplateRef"
                                                [ngTemplateOutletContext]="rowReorderTemplateContext">
                                            </ng-template>
                                        }
                                    }
                                } @else {
                                    <ng-template #template
                                        [ngTemplateOutlet]="col.templateRef"
                                        [ngTemplateOutletContext]="getTemplateContext(col)">
                                    </ng-template>
                                }
                            }
                            @if (isEdited(col)) {
                                @if (!col.editTemplateRef) {
                                    @switch (col.editor) {
                                        @case ('numeric') {
                                            <kendo-numerictextbox
                                                [format]="format"
                                                [formControl]="$any(formGroup.get(col.field))"
                                                kendoGridFocusable
                                            ></kendo-numerictextbox>
                                        }
                                        @case ('date') {
                                            <kendo-datepicker
                                                [format]="format"
                                                [formControl]="$any(formGroup.get(col.field))"
                                                kendoGridFocusable
                                            ></kendo-datepicker>
                                        }
                                        @case ('boolean') {
                                            <kendo-checkbox
                                                [formControl]="$any(formGroup.get(col.field))"
                                                kendoGridFocusable
                                            ></kendo-checkbox>
                                        }
                                        @default {
                                            <kendo-textbox
                                                [formControl]="$any(formGroup.get(col.field))"
                                                kendoGridFocusable
                                            ></kendo-textbox>
                                        }
                                    }
                                } @else {
                                    <ng-template
                                        [ngTemplateOutlet]="col.editTemplateRef"
                                        [ngTemplateOutletContext]="getEditTemplateContext(col)">
                                    </ng-template>
                                }
                            }
                        </div>
                    </div>
                }
                @if (detailTemplate?.showIf(item.data, $any(item).index)) {
                    <div class="k-grid-stack-cell" [attr.aria-expanded]="item.isExpanded">
                        <div class="k-grid-stack-content">
                            <button kendoButton
                                fillMode="flat"
                                themeColor="primary"
                                [icon]="detailButtonIconName(item)"
                                [svgIcon]="detailButtonSvgIcon(item)"
                                (click)="toggleRow($any(item).index, item.data)">
                                {{ detailButtonText(item) }}
                            </button>
                        </div>
                    </div>
                }
            </div>
        }

        @if (!isStackedLayoutMode) {
            @switch (isEdited()) {
                @case (false) {
                    @if (!showLoading) {
                        @if (column.templateRef) {
                            <ng-template
                                [ngTemplateOutlet]="column.templateRef"
                                [ngTemplateOutletContext]="getTemplateContext()">
                            </ng-template>
                        }
                        @if (isSpanColumn) {
                            @for (childColumn of children; track $index) {
                                {{ dataItem | valueOf: childColumn.field: childColumn.format}}
                            }
                        }
                        @if (isBoundColumn()) {{{ dataItem | valueOf: column.field: column.format}}}
                        @if (isCheckboxColumn() && !isNew) {
                            @if (isRowSelectable()) {
                                <kendo-checkbox
                                    [kendoGridSelectionCheckbox]="rowIndex"
                                    [attr.id]="selectionCheckboxId"
                                    [inputAttributes]="{'aria-label': selectionCheckboxLabel}"
                                    [title]="selectionCheckboxLabel">
                                </kendo-checkbox>
                            } @else {
                                @if (column.showDisabledCheckbox) {
                                    <kendo-checkbox
                                        [kendoGridSelectionCheckbox]="rowIndex"
                                        [attr.id]="selectionCheckboxId"
                                        [inputAttributes]="{'aria-label': selectionCheckboxLabel}"
                                        [title]="selectionCheckboxLabel"
                                        [disabled]="true"
                                    ></kendo-checkbox>
                                }
                            }
                        }
                        @if (isRowReorderColumn() && !isNew) {
                            @if (!column.dragHandleTemplate?.first) {
                                <kendo-icon-wrapper
                                    name="reorder"
                                    [svgIcon]="reorderIcon">
                                </kendo-icon-wrapper>
                            } @else {
                                <ng-template
                                    [ngTemplateOutlet]="column.rowDragHandleTemplateRef"
                                    [ngTemplateOutletContext]="rowReorderTemplateContext">
                                </ng-template>
                            }
                        }
                    } @else {
                        @if (loadingTemplate) {
                            <ng-template
                                [ngTemplateOutlet]="loadingTemplate"
                                [ngTemplateOutletContext]="{$implicit: column}">
                            </ng-template>
                        } @else {
                            <div class="k-skeleton-text k-skeleton"></div>
                        }
                    }
                }
                @case (true) {
                    @if (column.editTemplateRef) {
                        <ng-template
                            [ngTemplateOutlet]="column.editTemplateRef"
                            [ngTemplateOutletContext]="getEditTemplateContext()">
                        </ng-template>
                    } @else {
                        @switch (column.editor) {
                            @case ('numeric') {
                                <kendo-numerictextbox
                                    [format]="format"
                                    [formControl]="$any(formGroup.get(column.field))"
                                    kendoGridFocusable
                                ></kendo-numerictextbox>
                            }
                            @case ('date') {
                                <kendo-datepicker
                                    [format]="format"
                                    [formControl]="$any(formGroup.get(column.field))"
                                    kendoGridFocusable
                                ></kendo-datepicker>
                            }
                            @case ('boolean') {
                                <kendo-checkbox
                                    [formControl]="$any(formGroup.get(column.field))"
                                    kendoGridFocusable
                                ></kendo-checkbox>
                            }
                            @default {
                                <kendo-textbox
                                    [formControl]="$any(formGroup.get(column.field))"
                                    kendoGridFocusable
                                ></kendo-textbox>
                            }
                        }
                    }
                }
            }
        }
    `,
      standalone: true,
      imports: [NgTemplateOutlet, FocusableDirective, SelectionCheckboxDirective, TemplateContextDirective, IconWrapperComponent, NumericTextBoxComponent, DatePickerComponent, FieldAccessorPipe, ReactiveFormsModule, CheckBoxComponent, TextBoxComponent, NgClass, NgStyle, ButtonComponent]
    }]
  }], () => [{
    type: EditService
  }, {
    type: IdService
  }, {
    type: ContextService
  }, {
    type: DetailsService
  }, {
    type: LocalizationService
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CELL_CONTEXT]
    }]
  }], {
    commandCellClass: [{
      type: HostBinding,
      args: ["class.k-command-cell"]
    }],
    dragHandleCellClass: [{
      type: HostBinding,
      args: ["class.k-drag-cell"]
    }, {
      type: HostBinding,
      args: ["class.k-touch-action-none"]
    }],
    dragRowHandleLabel: [{
      type: HostBinding,
      args: ["attr.aria-label"]
    }],
    column: [{
      type: Input
    }],
    columns: [{
      type: Input
    }],
    columnIndex: [{
      type: Input
    }],
    isNew: [{
      type: Input
    }],
    isLoading: [{
      type: Input
    }],
    isVirtual: [{
      type: Input
    }],
    loadingTemplate: [{
      type: Input
    }],
    detailTemplate: [{
      type: Input
    }],
    item: [{
      type: Input
    }],
    rowIndex: [{
      type: Input
    }],
    dataItem: [{
      type: Input
    }]
  });
})();
var columnCellIndex = (cell2, cells, isStacked) => {
  let cellIndex = 0;
  for (let idx4 = 0; idx4 < cells.length; idx4++) {
    const isChildCell = cell2.parentNode === cells[idx4];
    const isActualCell = cell2 === cells[idx4];
    const matches2 = isActualCell || isStacked && isChildCell;
    if (matches2) {
      return cellIndex;
    }
    if (!hasClasses3(cells[idx4], "k-hierarchy-cell k-group-cell")) {
      cellIndex++;
    }
  }
};
var TableBodyComponent = class _TableBodyComponent {
  detailsService;
  groupsService;
  changeNotification;
  editService;
  ctx;
  ngZone;
  renderer;
  element;
  domEvents;
  selectionService;
  cellSelectionService;
  columnInfoService;
  navigationService;
  columns = [];
  allColumns;
  groups = [];
  detailTemplate;
  noRecordsTemplate;
  rowsToRender;
  skip = 0;
  selectable;
  filterable;
  noRecordsText;
  isLocked = false;
  isLoading;
  isVirtual;
  cellLoadingTemplate;
  skipGroupDecoration = false;
  lockedColumnsCount = 0;
  totalColumnsCount = 0;
  virtualColumns;
  trackBy = defaultTrackBy;
  rowSticky;
  totalColumns;
  rowClass = () => null;
  rowHeight;
  detailRowHeight;
  hostClass = true;
  groupHeaderSlaveCellsCount;
  groupHeaderColumns;
  clickSubscription;
  touchSubscription;
  l10nSubscription;
  cellKeydownSubscription;
  clickTimeout;
  minusIcon = minusIcon;
  plusIcon = plusIcon;
  constructor(detailsService, groupsService, changeNotification, editService, ctx, ngZone, renderer, element, domEvents, selectionService, cellSelectionService, columnInfoService, navigationService) {
    this.detailsService = detailsService;
    this.groupsService = groupsService;
    this.changeNotification = changeNotification;
    this.editService = editService;
    this.ctx = ctx;
    this.ngZone = ngZone;
    this.renderer = renderer;
    this.element = element;
    this.domEvents = domEvents;
    this.selectionService = selectionService;
    this.cellSelectionService = cellSelectionService;
    this.columnInfoService = columnInfoService;
    this.navigationService = navigationService;
    this.noRecordsText = this.ctx.localization.get("noRecords");
    this.cellKeydownSubscription = this.navigationService.cellKeydown.subscribe((args) => this.cellKeydownHandler(args));
    this.trackByWrapper = this.trackByWrapper.bind(this);
    this.trackByColumns = this.trackByColumns.bind(this);
  }
  get newDataItem() {
    return this.editService.newDataItem;
  }
  // Number of unlocked columns in the next table, if any
  unlockedColumnsCount(item) {
    const allColumns = this.allColumns || this.columns;
    let allColumnsCount = allColumns.length;
    allColumns.forEach((column) => {
      if (column.isSpanColumn) {
        allColumnsCount += column.colspan - 1;
      }
    });
    const contentColumnsCount = this.totalColumnsCount - (this.isStackedMode ? 0 : this.lockedColumnsCount) - allColumnsCount;
    const headerFooterColumnsCount = this.totalColumnsCount - (this.isStackedMode ? 0 : this.lockedColumnsCount) - allColumns.length;
    return item && item.type === "data" ? contentColumnsCount : headerFooterColumnsCount;
  }
  isAriaSelected(item, column) {
    return this.cellSelectionService.isCellSelected(item, column) || this.isRowSelected(item) ? "true" : "false";
  }
  toggleRow(index, dataItem) {
    this.detailsService.toggleRow(index, dataItem);
    return false;
  }
  detailButtonIconName(viewItem) {
    return viewItem.isExpanded ? "minus" : "plus";
  }
  detailButtonSvgIcon(viewItem) {
    return viewItem.isExpanded ? this.minusIcon : this.plusIcon;
  }
  detailButtonTitle(viewItem) {
    const messageKey = viewItem.isExpanded ? "detailCollapse" : "detailExpand";
    return this.ctx.localization.get(messageKey);
  }
  isOdd(item) {
    return item.index % 2 !== 0;
  }
  isSelectable(args) {
    const rowSelectable = this.isRowSelectable(args);
    const selectionEnabled = this.selectable && this.selectable.enabled !== false;
    return selectionEnabled && rowSelectable;
  }
  isRowSelected(item) {
    return this.selectionService.isSelected(item.index);
  }
  isRowSelectable(args) {
    return this.selectionService.settings?.isRowSelectable(args) || this.cellSelectionService.settings?.isRowSelectable(args);
  }
  trackByWrapper(index, item) {
    return this.trackBy(index, item);
  }
  trackByColumns(index, item) {
    return this.virtualColumns ? index : item;
  }
  ngDoCheck() {
    if (this.rowsToRender) {
      this.rowsToRender.forEach((item) => {
        if (item.type === "data") {
          item.isEditing = this.editService.hasEdited(item.index);
        }
      });
    }
    if (this.hasGroupHeaderColumn) {
      this.groupHeaderColumns = columnsToRender(this.skipGroupDecoration ? this.columns : this.columns.toArray().slice(1));
    } else {
      this.groupHeaderColumns = [];
    }
    if (this.isLocked) {
      this.groupHeaderSlaveCellsCount = this.hasGroupHeaderColumn ? this.columnsContainer.nonLockedColumnsToRender.length : 1;
    } else {
      this.groupHeaderSlaveCellsCount = 0;
    }
  }
  ngAfterViewChecked() {
    if (this.rowSticky) {
      this.applyStickyRowsStyling();
    }
  }
  ngOnChanges(changes) {
    if (isChanged("columns", changes, false)) {
      this.changeNotification.notify();
    }
  }
  logicalRowIndex(rowIndex) {
    const skip4 = this.skip + (this.ctx.scroller?.virtualSkip ?? 0);
    let pos = rowIndex + skip4;
    if (this.hasDetailTemplate && !this.isStackedMode) {
      pos *= 2;
    }
    const absoluteRowIndex = this.isStackedMode ? pos : 1 + pos;
    const addRowOffset = this.editService.hasNewItem ? 1 : 0;
    const filterRowOffset = hasFilterRow(this.filterable) ? 1 : 0;
    const headerRowCount = this.columnInfoService.totalLevels + filterRowOffset + addRowOffset;
    return absoluteRowIndex + headerRowCount;
  }
  addRowLogicalIndex() {
    return this.columnInfoService.totalLevels + 1 + (hasFilterRow(this.filterable) ? 1 : 0);
  }
  logicalColIndex(column) {
    if (!isPresent7(column.leafIndex)) {
      return -1;
    }
    return column.leafIndex + (this.hasDetailTemplate ? 1 : 0);
  }
  ngOnInit() {
    this.ngZone.runOutsideAngular(() => {
      const clickHandler = this.clickHandler.bind(this);
      const mousedownSubscription = this.renderer.listen(this.element.nativeElement, "mousedown", clickHandler);
      const mouseupSubscription = this.renderer.listen(this.element.nativeElement, "mouseup", clickHandler);
      const clickSubscription = this.renderer.listen(this.element.nativeElement, "click", clickHandler);
      const contextmenuSubscription = this.renderer.listen(this.element.nativeElement, "contextmenu", clickHandler);
      const touchstartSubscription = this.renderer.listen(this.element.nativeElement, "touchstart", clickHandler);
      const touchendSubscription = this.renderer.listen(this.element.nativeElement, "touchend", clickHandler);
      this.clickSubscription = () => {
        mousedownSubscription();
        mouseupSubscription();
        clickSubscription();
        contextmenuSubscription();
      };
      this.touchSubscription = () => {
        touchstartSubscription();
        touchendSubscription();
      };
    });
    let originalNoRecordText = this.ctx.localization.get("noRecords");
    this.l10nSubscription = this.ctx.localization.changes.subscribe(() => {
      if (this.noRecordsText === originalNoRecordText) {
        this.noRecordsText = this.ctx.localization.get("noRecords");
        originalNoRecordText = this.noRecordsText;
      }
    });
  }
  ngOnDestroy() {
    if (this.clickSubscription) {
      this.clickSubscription();
    }
    if (this.touchSubscription) {
      this.touchSubscription();
    }
    if (this.l10nSubscription) {
      this.l10nSubscription.unsubscribe();
    }
    this.cellKeydownSubscription.unsubscribe();
    clearTimeout(this.clickTimeout);
  }
  isEditingCell(index, column) {
    return this.editService.isEditing() && this.editService.isEditedColumn(index, column);
  }
  isEditingRow(index) {
    return this.editService.isEditing() && this.editService.hasEdited(index);
  }
  get isStackedMode() {
    return this.ctx.grid?.isStacked;
  }
  get hasGroupHeaderColumn() {
    return this.columnsContainer.hasGroupHeaderColumn;
  }
  get columnsContainer() {
    return this.columnInfoService.columnsContainer;
  }
  get columnsSpan() {
    return columnsSpan(this.columns);
  }
  get allColumnsSpan() {
    return columnsSpan(this.allColumns || this.columns);
  }
  get colSpan() {
    return this.columnsSpan + this.groups.length + (this.hasDetailTemplate ? 1 : 0);
  }
  get footerColumns() {
    const colsToRender = Array.from(this.columns).reduce((cols, col) => {
      const newCols = col instanceof SpanColumnComponent ? Array.from(col.children) : [col];
      return [...cols, ...newCols];
    }, []);
    return colsToRender;
  }
  addStickyColumnStyles(column) {
    const stickyStyles = this.columnInfoService.stickyColumnsStyles(column);
    return __spreadValues(__spreadValues({}, column.style), stickyStyles);
  }
  resizeHandler() {
    this.applyStickyRowsStyling();
  }
  get hasDetailTemplate() {
    return isPresent7(this.detailTemplate);
  }
  clickHandler(eventArg) {
    const element = this.element.nativeElement;
    const target = this.eventTarget(eventArg);
    const selectionEnabled = this.selectable && this.selectable.enabled !== false;
    if (eventArg.code === Keys.Space) {
      if (!selectionEnabled) {
        return;
      }
      const cellComparer = this.isStackedMode ? closest5(target, (el) => hasClasses3(el, "k-grid-stack-cell")) || closest5(target, matchesNodeName("td")) : closest5(target, matchesNodeName("td"));
      const isCellFocused = cellComparer?.classList.contains("k-focus") || cellComparer === document.activeElement;
      const isShiftOrCtrlPressed = eventArg.shiftKey || eventArg.ctrlKey || eventArg.metaKey;
      if (isCellFocused && !isShiftOrCtrlPressed) {
        eventArg.preventDefault();
      }
    }
    let row2, body, gridElement;
    const currentTarget = target;
    const gridTbody = closest5(currentTarget, (el) => matchesNodeName("tbody")(el) && el === element);
    if (!gridTbody) {
      return;
    }
    let cell2 = closest5(currentTarget, (el) => {
      if (!matchesNodeName("td")(el)) {
        return false;
      }
      const parentRow = el.parentElement;
      if (!parentRow || !matchesNodeName("tr")(parentRow)) {
        return false;
      }
      return parentRow.parentElement === element;
    });
    if (cell2) {
      row2 = cell2.parentElement;
      body = element;
      gridElement = null;
    }
    if (cell2 && !hasClasses3(cell2, NON_DATA_CELL_CLASSES) && !hasClasses3(row2, NON_DATA_ROW_CLASSES) && body === element && !gridElement) {
      const isCellTarget = hasClasses3(currentTarget, "k-grid-stack-cell");
      if (this.isStackedMode) {
        cell2 = closest5(currentTarget, (el) => {
          if (!closestInScope5(target, matchesClasses2("k-grid-stack-row"), cell2)) {
            return false;
          }
          const parentRow = isCellTarget ? currentTarget : el.parentElement;
          return parentRow && hasClasses3(parentRow, "k-grid-stack-cell");
        });
        if (isCellTarget) {
          cell2 = findElement(currentTarget, (el) => hasClasses3(el, "k-grid-stack-content"));
        }
        if (cell2) {
          row2 = cell2.parentElement.parentElement;
        } else {
          cell2 = closest5(currentTarget, (el) => {
            if (!matchesNodeName("td")(el)) {
              return false;
            }
            const parentRow = el.parentElement;
            if (!parentRow || !matchesNodeName("tr")(parentRow)) {
              return false;
            }
            return parentRow.parentElement === element;
          });
          if (cell2) {
            row2 = cell2.parentElement;
            body = element;
            gridElement = null;
          }
        }
      }
      if (!cell2) {
        return;
      }
      this.editService.preventCellClose();
      const focusable = !isCellTarget && target !== cell2 && isFocusableWithTabKey(target, false);
      const ignoreContainer = isCellTarget ? true : !closestInScope5(target, matchesClasses2(IGNORE_CONTAINER_CLASSES), cell2);
      if (!focusable && !matchesNodeName("label")(target) && !hasClasses3(target, IGNORE_TARGET_CLASSSES) && ignoreContainer) {
        const args = this.cellClickArgs(cell2, row2, eventArg);
        if (!args) {
          return;
        }
        if (selectionEnabled && !this.isRowSelectable({
          index: args.rowIndex,
          dataItem: args.dataItem
        })) {
          return;
        }
        if (eventArg.type === "mousedown" || eventArg.type === "touchstart") {
          this.domEvents.cellMousedown.emit(args);
        } else if (eventArg.type === "mouseup" || eventArg.type === "touchend") {
          this.domEvents.cellMouseup.emit(args);
        } else {
          if (args.isEditedColumn || !this.editService.closeCell(eventArg)) {
            if (eventArg.type === "click") {
              this.clickTimeout = setTimeout(() => {
                this.emitCellClick(args);
              }, 0);
            } else {
              this.emitCellClick(args);
            }
          }
        }
      }
    }
  }
  emitCellClick(args) {
    this.domEvents.cellClick.emit(Object.assign(args, {
      isEdited: args.isEditedRow || args.isEditedColumn
    }));
  }
  cellKeydownHandler(args) {
    if (args.code === Keys.Enter || args.code === Keys.NumpadEnter || args.code === Keys.Space || this.navigationService.tableCellEntered && args.code === Keys.F2) {
      this.clickHandler(args);
    }
  }
  cellClickArgs(cell2, row2, eventArg) {
    const cells = this.isStackedMode ? row2.querySelectorAll(".k-grid-stack-cell") : row2.cells;
    let index = columnCellIndex(cell2, cells, this.isStackedMode);
    let isOuterCellClicked = false;
    if (this.isStackedMode && !isPresent7(index)) {
      const cells2 = row2.cells;
      index = columnCellIndex(cell2, cells2, this.isStackedMode);
      isOuterCellClicked = true;
    }
    if (!isPresent7(index)) {
      return;
    }
    const column = this.columns.toArray()[index];
    const columnIndex = (this.isStackedMode ? 0 : this.lockedColumnsCount) + index;
    let rowIndex = (this.isStackedMode && !isOuterCellClicked ? row2.parentElement.parentElement : row2).getAttribute("data-kendo-grid-item-index");
    rowIndex = rowIndex ? parseInt(rowIndex, 10) : -1;
    const dataItem = rowIndex === -1 ? this.editService.newDataItem : this.rowsToRender.find((item) => +item.index === rowIndex && item.type === "data")?.data;
    const isEditedColumn = this.editService.isEditedColumn(rowIndex, column);
    const isEditedRow = this.editService.isEdited(rowIndex);
    const type = eventArg.type === "keydown" ? "click" : eventArg.type;
    return {
      column: isOuterCellClicked ? null : column,
      columnIndex,
      dataItem,
      isEditedColumn,
      isEditedRow,
      originalEvent: eventArg,
      rowIndex,
      type
    };
  }
  eventTarget(args) {
    if (!isDocumentAvailable()) {
      return;
    }
    if (args.type === "touchend") {
      const touch = args.changedTouches[0];
      return document.elementFromPoint(touch.clientX, touch.clientY);
    }
    return args.target;
  }
  applyStickyRowsStyling() {
    if (!isDocumentAvailable()) {
      return;
    }
    const stickyRows = nodesToArray(this.element.nativeElement.querySelectorAll(".k-grid-row-sticky"));
    const length2 = stickyRows.length;
    if (length2) {
      let accumulatedHeight = 0;
      const stickyRowsOffsets = [];
      stickyRows.forEach((row2) => {
        const rowHeight = row2.getBoundingClientRect().height;
        stickyRowsOffsets.push({
          accumulatedHeight,
          rowHeight
        });
        accumulatedHeight += rowHeight;
      });
      stickyRows.forEach((row2, index) => {
        this.renderer.setStyle(row2, "top", `${stickyRowsOffsets[index].accumulatedHeight}px`);
        this.renderer.setStyle(row2, "bottom", `${accumulatedHeight - stickyRowsOffsets[index].accumulatedHeight - stickyRowsOffsets[index].rowHeight}px`);
      });
    }
  }
  static ɵfac = function TableBodyComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TableBodyComponent)(ɵɵdirectiveInject(DetailsService), ɵɵdirectiveInject(GroupsService), ɵɵdirectiveInject(ChangeNotificationService), ɵɵdirectiveInject(EditService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(DomEventsService), ɵɵdirectiveInject(SelectionService2), ɵɵdirectiveInject(CellSelectionService), ɵɵdirectiveInject(ColumnInfoService), ɵɵdirectiveInject(NavigationService4));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TableBodyComponent,
    selectors: [["", "kendoGridTableBody", ""]],
    hostVars: 2,
    hostBindings: function TableBodyComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-table-tbody", ctx.hostClass);
      }
    },
    inputs: {
      columns: "columns",
      allColumns: "allColumns",
      groups: "groups",
      detailTemplate: "detailTemplate",
      noRecordsTemplate: "noRecordsTemplate",
      rowsToRender: "rowsToRender",
      skip: "skip",
      selectable: "selectable",
      filterable: "filterable",
      noRecordsText: "noRecordsText",
      isLocked: "isLocked",
      isLoading: "isLoading",
      isVirtual: "isVirtual",
      cellLoadingTemplate: "cellLoadingTemplate",
      skipGroupDecoration: "skipGroupDecoration",
      lockedColumnsCount: "lockedColumnsCount",
      totalColumnsCount: "totalColumnsCount",
      virtualColumns: "virtualColumns",
      trackBy: "trackBy",
      rowSticky: "rowSticky",
      totalColumns: "totalColumns",
      rowClass: "rowClass",
      rowHeight: "rowHeight",
      detailRowHeight: "detailRowHeight"
    },
    features: [ɵɵNgOnChangesFeature],
    attrs: _c383,
    decls: 5,
    vars: 3,
    consts: [["kendoGridLogicalRow", "", 1, "k-grid-add-row", "k-grid-edit-row", "k-master-row", 3, "height", "logicalRowIndex", "logicalSlaveRow", "logicalCellsCount", "logicalSlaveCellsCount", "totalColumns"], ["role", "row", 1, "k-grid-norecords"], ["kendoGridLogicalRow", "", 1, "k-grid-add-row", "k-grid-edit-row", "k-master-row", 3, "logicalRowIndex", "logicalSlaveRow", "logicalCellsCount", "logicalSlaveCellsCount", "totalColumns"], ["kendoGridLogicalCell", "", "aria-selected", "false", 1, "k-hierarchy-cell", "k-table-td", 3, "logicalRowIndex", "logicalColIndex"], ["role", "presentation", 1, "k-group-cell", "k-table-td", "k-table-group-td"], ["kendoGridCell", "", "kendoGridLogicalCell", "", 1, "k-table-td", 3, "rowIndex", "columnIndex", "isNew", "columns", "dataItem", "logicalRowIndex", "logicalColIndex"], ["kendoGridCell", "", "kendoGridLogicalCell", "", 1, "k-table-td", 3, "rowIndex", "columnIndex", "isNew", "column", "dataItem", "k-grid-content-sticky", "ngClass", "left", "ngStyle", "logicalRowIndex", "logicalColIndex", "colSpan"], ["kendoGridCell", "", "kendoGridLogicalCell", "", 1, "k-table-td", 3, "rowIndex", "columnIndex", "isNew", "column", "dataItem", "ngClass", "ngStyle", "logicalRowIndex", "logicalColIndex", "colSpan"], [1, "k-table-td"], [3, "templateContext"], ["kendoGridGroupHeader", "", "kendoGridLogicalRow", "", 3, "height", "columns", "groups", "item", "hasDetails", "skipGroupDecoration", "hasGroupHeaderColumn", "groupHeaderColumns", "rowIndex", "totalColumnsCount", "logicalRowIndex", "logicalSlaveRow", "totalColumns", "logicalCellsCount", "logicalSlaveCellsCount"], ["kendoGridLogicalRow", "", 3, "height", "dataRowIndex", "dataItem", "logicalRowIndex", "logicalSlaveRow", "totalColumns", "logicalCellsCount", "logicalSlaveCellsCount", "class", "k-grid-row-sticky", "ngClass", "k-master-row", "k-expanded", "k-grid-edit-row", "k-selected", "k-highlighted"], ["kendoGridLogicalRow", "", 1, "k-detail-row", 3, "height", "dataRowIndex", "dataItem", "logicalRowIndex", "logicalSlaveRow", "logicalCellsCount"], ["kendoGridLogicalRow", "", 1, "k-group-footer", 3, "height", "logicalRowIndex", "logicalSlaveRow", "totalColumns", "logicalCellsCount", "logicalSlaveCellsCount"], ["kendoGridGroupHeader", "", "kendoGridLogicalRow", "", 3, "columns", "groups", "item", "hasDetails", "skipGroupDecoration", "hasGroupHeaderColumn", "groupHeaderColumns", "rowIndex", "totalColumnsCount", "logicalRowIndex", "logicalSlaveRow", "totalColumns", "logicalCellsCount", "logicalSlaveCellsCount"], ["kendoGridLogicalRow", "", 3, "dataRowIndex", "dataItem", "logicalRowIndex", "logicalSlaveRow", "totalColumns", "logicalCellsCount", "logicalSlaveCellsCount", "ngClass"], ["kendoGridLogicalCell", "", "aria-selected", "false", "role", "gridcell", 1, "k-hierarchy-cell", "k-table-td", 3, "logicalRowIndex", "logicalColIndex", "dataRowIndex", "dataItem", "detailExpandCell"], ["kendoGridCell", "", "kendoGridLogicalCell", "", 1, "k-table-td", 3, "rowIndex", "detailTemplate", "item", "columnIndex", "columns", "dataItem", "isLoading", "isVirtual", "loadingTemplate", "logicalRowIndex", "logicalColIndex", "dataRowIndex", "colIndex", "k-touch-action-none"], ["href", "#", "tabindex", "-1"], ["href", "#", "tabindex", "-1", 3, "click"], [3, "name", "svgIcon"], ["kendoGridCell", "", "kendoGridLogicalCell", "", 1, "k-table-td", 3, "rowIndex", "detailTemplate", "item", "columnIndex", "columns", "dataItem", "isLoading", "isVirtual", "loadingTemplate", "logicalRowIndex", "logicalColIndex", "dataRowIndex", "colIndex"], ["kendoGridCell", "", "kendoGridLogicalCell", "", 1, "k-table-td", 3, "rowIndex", "columnIndex", "column", "columns", "dataItem", "isLoading", "isVirtual", "loadingTemplate", "logicalRowIndex", "logicalColIndex", "dataRowIndex", "colIndex", "colSpan", "rowSpan", "k-grid-content-sticky", "k-touch-action-none", "ngClass", "k-grid-edit-cell", "ngStyle", "k-selected", "k-highlighted"], ["kendoGridCell", "", "kendoGridLogicalCell", "", 1, "k-table-td", 3, "rowIndex", "columnIndex", "column", "columns", "dataItem", "isLoading", "isVirtual", "loadingTemplate", "logicalRowIndex", "logicalColIndex", "dataRowIndex", "colIndex", "colSpan", "rowSpan", "ngClass", "ngStyle"], ["kendoGridLogicalRow", "", 1, "k-detail-row", 3, "dataRowIndex", "dataItem", "logicalRowIndex", "logicalSlaveRow", "logicalCellsCount"], ["kendoGridLogicalCell", "", "role", "gridcell", "aria-selected", "false", 1, "k-detail-cell", "k-table-td", 3, "logicalRowIndex", "logicalColIndex", "dataRowIndex", "dataItem", "colIndex", "colSpan"], [1, "k-group-cell", "k-table-td", "k-table-group-td"], [1, "k-hierarchy-cell", "k-table-td"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["kendoGridLogicalRow", "", 1, "k-group-footer", 3, "logicalRowIndex", "logicalSlaveRow", "totalColumns", "logicalCellsCount", "logicalSlaveCellsCount"], ["kendoGridLogicalCell", "", 1, "k-table-td", 3, "logicalRowIndex", "logicalColIndex"], [1, "k-grid-column-template"], [1, "k-column-template-item"], [3, "resize"]],
    template: function TableBodyComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵconditionalCreate(0, TableBodyComponent_Conditional_0_Template, 5, 10, "tr", 0);
        ɵɵconditionalCreate(1, TableBodyComponent_Conditional_1_Template, 4, 2, "tr", 1);
        ɵɵrepeaterCreate(2, TableBodyComponent_For_3_Template, 4, 4, null, null, ctx.trackByWrapper, true);
        ɵɵconditionalCreate(4, TableBodyComponent_Conditional_4_Template, 1, 0, "kendo-resize-sensor");
      }
      if (rf & 2) {
        ɵɵconditional(ctx.editService.hasNewItem ? 0 : -1);
        ɵɵadvance();
        ɵɵconditional(!(ctx.rowsToRender == null ? null : ctx.rowsToRender.length) ? 1 : -1);
        ɵɵadvance();
        ɵɵrepeater(ctx.rowsToRender);
        ɵɵadvance(2);
        ɵɵconditional(ctx.rowSticky ? 4 : -1);
      }
    },
    dependencies: [LogicalRowDirective, LogicalCellDirective, CellComponent, NgClass, NgStyle, TemplateContextDirective, GroupHeaderComponent, IconWrapperComponent, NgTemplateOutlet, ResizeSensorComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TableBodyComponent, [{
    type: Component,
    args: [{
      selector: "[kendoGridTableBody]",
      template: `
    @if (editService.hasNewItem) {
        <tr class="k-grid-add-row k-grid-edit-row k-master-row"
            [style.height.px]="rowHeight"
            kendoGridLogicalRow
                [logicalRowIndex]="addRowLogicalIndex()"
                [logicalSlaveRow]="lockedColumnsCount > 0 && !isStackedMode"
                [logicalCellsCount]="columns.length"
                [logicalSlaveCellsCount]="unlockedColumnsCount()"
                [totalColumns]="totalColumns">
            @if (!skipGroupDecoration) {
                @for (g of groups; track $index) {
                    <td class="k-group-cell k-table-td k-table-group-td" role="presentation"></td>
                }
            }
            @if (detailTemplate?.templateRef && !isStackedMode) {
                <td class="k-hierarchy-cell k-table-td"
                    kendoGridLogicalCell
                        [logicalRowIndex]="addRowLogicalIndex()"
                        [logicalColIndex]="0"
                        aria-selected="false"
                    >
                </td>
            }
            @if (isStackedMode) {
                @for (item of rowsToRender; track trackByWrapper($index, item); let rowIndex = $index) {
                    <td
                        class="k-table-td"
                        kendoGridCell
                            [rowIndex]="-1"
                            [columnIndex]="0"
                            [isNew]="true"
                            [columns]="allColumns"
                            [dataItem]="newDataItem"
                        kendoGridLogicalCell
                            [logicalRowIndex]="addRowLogicalIndex()"
                            [logicalColIndex]="0">
                    </td>
                }
            } @else {
                @for (column of columns; track virtualColumns ? $index : column; let columnIndex = $index) {
                    <td
                        class="k-table-td"
                        kendoGridCell
                            [rowIndex]="-1"
                            [columnIndex]="lockedColumnsCount + columnIndex"
                            [isNew]="true"
                            [column]="column"
                            [dataItem]="newDataItem"
                        [class.k-grid-content-sticky]="column.sticky"
                        [ngClass]="column.cssClass"
                        [style.left]="column.sticky ? '0' : undefined"
                        [ngStyle]="column.sticky ? addStickyColumnStyles(column) : column.style"
                        [attr.colspan]="column.colspan"
                        [attr.role]="column.tableCellsRole"
                        kendoGridLogicalCell
                            [logicalRowIndex]="addRowLogicalIndex()"
                            [logicalColIndex]="logicalColIndex(column)"
                            [colSpan]="column.colspan">
                    </td>
                }
            }
        </tr>
    }
    @if (!rowsToRender?.length) {
        <tr class="k-grid-norecords" role="row">
            <td [attr.colspan]="colSpan" class="k-table-td">
                @if (noRecordsTemplate?.templateRef) {
                    <ng-template
                        [templateContext]="{
                            templateRef: noRecordsTemplate?.templateRef
                         }">
                    </ng-template>
                } @else {
                    {{noRecordsText}}
                }
            </td>
        </tr>
    }
    @for (item of rowsToRender; track trackByWrapper($index, item); let rowIndex = $index) {
        @if (item.type === 'group') {
            <tr
                [style.height.px]="rowHeight"
                kendoGridGroupHeader
                    [columns]="columns"
                    [groups]="groups"
                    [item]="$any(item)"
                    [hasDetails]="!!detailTemplate?.templateRef"
                    [skipGroupDecoration]="skipGroupDecoration"
                    [hasGroupHeaderColumn]="hasGroupHeaderColumn"
                    [groupHeaderColumns]="groupHeaderColumns"
                    [rowIndex]="rowIndex + 1"
                    [totalColumnsCount]="totalColumnsCount"
                kendoGridLogicalRow
                    [logicalRowIndex]="logicalRowIndex(rowIndex)"
                    [logicalSlaveRow]="lockedColumnsCount > 0 && !isStackedMode"
                    [totalColumns]="totalColumns"
                    [logicalCellsCount]="columns.length"
                    [logicalSlaveCellsCount]="groupHeaderSlaveCellsCount">
            </tr>
        }
        @if (item.showDataItem) {
            <tr
                [style.height.px]="rowHeight"
                kendoGridLogicalRow
                    [dataRowIndex]="$any(item).index"
                    [dataItem]="item.data"
                    [logicalRowIndex]="logicalRowIndex(rowIndex)"
                    [logicalSlaveRow]="lockedColumnsCount > 0 && !isStackedMode"
                    [totalColumns]="totalColumns"
                    [logicalCellsCount]="columns.length"
                    [logicalSlaveCellsCount]="unlockedColumnsCount(item)"
                class="{{ isOdd(item) ?  'k-table-alt-row' : ''}}"
                [class.k-grid-row-sticky]="rowSticky ? rowSticky({ dataItem: item.data, index: $any(item).index }) : false"
                [ngClass]="rowClass({ dataItem: item.data, index: $any(item).index })"
                [class.k-master-row]="true"
                [class.k-expanded]="item.isExpanded && !isStackedMode"
                [class.k-grid-edit-row]="isEditingRow($any(item).index)"
                [attr.aria-selected]="(lockedColumnsCount < 1 || isStackedMode) ? isSelectable({ dataItem: item.data, index: $any(item).index }) && isRowSelected(item) : undefined"
                [attr.data-kendo-grid-item-index]="$any(item).index"
                [class.k-selected]="isSelectable({ dataItem: item.data, index: $any(item).index }) && isRowSelected(item)"
                [class.k-highlighted]="item.isHighlighted">
                @if (!skipGroupDecoration) {
                    @for (g of groups; track $index) {
                        <td class="k-group-cell k-table-td k-table-group-td" role="presentation"></td>
                    }
                }
                @if (detailTemplate?.templateRef && !isStackedMode) {
                    <td class="k-hierarchy-cell k-table-td"
                        kendoGridLogicalCell
                            [logicalRowIndex]="logicalRowIndex(rowIndex)"
                            [logicalColIndex]="0"
                            [dataRowIndex]="$any(item).index"
                            [dataItem]="item.data"
                            [detailExpandCell]="true"
                            aria-selected="false"
                            role="gridcell"
                            [attr.aria-expanded]="item.isExpanded">
                        @if (detailTemplate.showIf(item.data, $any(item).index)) {
                            <a
                                [attr.title]="detailButtonTitle(item)"
                                [attr.aria-label]="detailButtonTitle(item)"
                                href="#" tabindex="-1" (click)="toggleRow($any(item).index, item.data)">
                                <kendo-icon-wrapper
                                    [name]="detailButtonIconName(item)"
                                    [svgIcon]="detailButtonSvgIcon(item)"></kendo-icon-wrapper>
                            </a>
                        }
                    </td>
                }
                @if (isStackedMode) {
                    <td kendoGridCell
                        [rowIndex]="$any(item).index"
                        [detailTemplate]="detailTemplate"
                        [item]="item"
                        [columnIndex]="0"
                        [attr.data-kendo-grid-column-index]="0"
                        [columns]="columns"
                        [dataItem]="item.data"
                        [isLoading]="isLoading"
                        [isVirtual]="isVirtual"
                        [loadingTemplate]="cellLoadingTemplate"
                        kendoGridLogicalCell
                        [logicalRowIndex]="logicalRowIndex(rowIndex)"
                        [logicalColIndex]="0"
                        [dataRowIndex]="$any(item).index"
                        [dataItem]="item.data"
                        [colIndex]="0"
                        class="k-table-td"
                        [class.k-touch-action-none]="isSelectable({ dataItem: item.data, index: $any(item).index }) && $any(selectable).drag">
                    </td>
                } @else {
                    @for (column of columns; track virtualColumns ? $index : column; let columnIndex = $index) {
                        @if (!item.cells?.[lockedColumnsCount + columnIndex]?.skip) {
                            <td
                                kendoGridCell
                                [rowIndex]="$any(item).index"
                                [columnIndex]="lockedColumnsCount + columnIndex"
                                [attr.data-kendo-grid-column-index]="lockedColumnsCount + columnIndex"
                                [column]="column"
                                [columns]="allColumns"
                                [dataItem]="item.data"
                                [isLoading]="isLoading"
                                [isVirtual]="isVirtual"
                                [loadingTemplate]="cellLoadingTemplate"
                                kendoGridLogicalCell
                                [logicalRowIndex]="logicalRowIndex(rowIndex)"
                                [logicalColIndex]="logicalColIndex(column)"
                                [dataRowIndex]="$any(item).index"
                                [dataItem]="item.data"
                                [colIndex]="columnIndex"
                                [colSpan]="column.colspan"
                                [rowSpan]="item.cells[lockedColumnsCount + columnIndex]?.rowspan"
                                [attr.role]="column.tableCellsRole"
                                class="k-table-td"
                                [attr.aria-selected]="lockedColumnsCount < 1 && isSelectable({ dataItem: item.data, index: $any(item).index }) ? isAriaSelected(item, column) : undefined"
                                [class.k-grid-content-sticky]="column.sticky"
                                [class.k-touch-action-none]="isSelectable({ dataItem: item.data, index: $any(item).index }) && $any(selectable).drag"
                                [ngClass]="column.cssClass"
                                [class.k-grid-edit-cell]="isEditingCell($any(item).index, column)"
                                [ngStyle]="column.sticky ? addStickyColumnStyles(column) : column.style"
                                [attr.colspan]="column.colspan"
                                [class.k-selected]="isSelectable && cellSelectionService.isCellSelected(item, column)"
                                [class.k-highlighted]="item.cells[lockedColumnsCount + columnIndex]?.isHighlighted">
                            </td>
                        }
                    }
                }
            </tr>
        }
        @if (item.showDetailRow) {
            <tr
                class="k-detail-row"
                [style.height.px]="detailRowHeight"
                kendoGridLogicalRow
                    [dataRowIndex]="$any(item).index"
                    [dataItem]="item.data"
                    [logicalRowIndex]="isStackedMode ? logicalRowIndex(rowIndex) : logicalRowIndex(rowIndex) + 1"
                    [logicalSlaveRow]="false"
                    [logicalCellsCount]="1">
                @if (!isStackedMode) {
                    @for (g of groups; track $index) {
                        <td class="k-group-cell k-table-td k-table-group-td"></td>
                    }
                    <td class="k-hierarchy-cell k-table-td"></td>
                    <td class="k-detail-cell k-table-td"
                        [attr.colspan]="columnsSpan"
                        kendoGridLogicalCell
                            [logicalRowIndex]="logicalRowIndex(rowIndex) + 1"
                            [logicalColIndex]="0"
                            [dataRowIndex]="$any(item).index"
                            [dataItem]="item.data"
                            [colIndex]="0"
                            [colSpan]="allColumnsSpan + 1"
                            role="gridcell" aria-selected="false">
                        <ng-template
                            [ngTemplateOutlet]="detailTemplate.templateRef"
                            [ngTemplateOutletContext]="{
                                dataItem: item.data,
                                rowIndex: $any(item).index,
                                $implicit: item.data
                            }">
                        </ng-template>
                    </td>
                } @else {
                    <td class="k-detail-cell k-table-td"
                        [attr.colspan]="columnsSpan"
                        kendoGridLogicalCell
                            [logicalRowIndex]="logicalRowIndex(rowIndex)"
                            [logicalColIndex]="0"
                            [dataRowIndex]="$any(item).index"
                            [dataItem]="item.data"
                            [colIndex]="0"
                            [colSpan]="allColumnsSpan + 1"
                            role="gridcell"
                            aria-selected="false">
                        <ng-template
                            [ngTemplateOutlet]="detailTemplate.templateRef"
                            [ngTemplateOutletContext]="{
                                dataItem: item.data,
                                rowIndex: $any(item).index,
                                $implicit: item.data
                            }">
                        </ng-template>
                    </td>
                }
            </tr>
        }
        @if (item.type === 'footer') {
            <tr
                class="k-group-footer"
                [style.height.px]="rowHeight"
                kendoGridLogicalRow
                    [logicalRowIndex]="logicalRowIndex(rowIndex)"
                    [logicalSlaveRow]="lockedColumnsCount > 0 && !isStackedMode"
                    [totalColumns]="totalColumns"
                    [logicalCellsCount]="columns.length"
                    [logicalSlaveCellsCount]="unlockedColumnsCount(item)">
                @if (!skipGroupDecoration) {
                    @for (g of groups; track $index) {
                        <td class="k-group-cell k-table-td k-table-group-td"></td>
                    }
                }
                @if (detailTemplate?.templateRef && !isStackedMode) {
                    <td class="k-hierarchy-cell k-table-td"
                        kendoGridLogicalCell
                            [logicalRowIndex]="logicalRowIndex(rowIndex)"
                            [logicalColIndex]="0"
                            aria-selected="false">
                    </td>
                }

                @if (!isStackedMode) {
                    @for (column of footerColumns; track virtualColumns ? $index : column; let columnIndex = $index) {
                        <td kendoGridLogicalCell
                                [logicalRowIndex]="logicalRowIndex(rowIndex)"
                                [logicalColIndex]="logicalColIndex(column)"
                            [attr.data-skip]="skipGroupDecoration"
                            class="k-table-td">
                            <ng-template
                                [templateContext]="{
                                    templateRef: $any(column).groupFooterTemplateRef,
                                    group: $any(item.data),
                                    field: $any(column).field,
                                    column: column,
                                    aggregates: $any(item.data)?.aggregates,
                                    $implicit: $any(item.data)?.aggregates
                                }">
                            </ng-template>
                       </td>
                    }
                } @else {
                    <td kendoGridLogicalCell
                        [logicalRowIndex]="logicalRowIndex(rowIndex)"
                        [logicalColIndex]="hasDetailTemplate ? 1 : 0"
                        [attr.data-skip]="skipGroupDecoration"
                        class="k-table-td">
                        <div class="k-grid-column-template">
                            @for (col of footerColumns; track $index) {
                                @if ($any(col).groupFooterTemplateRef) {
                                    <div class="k-column-template-item">
                                        <ng-template
                                            [templateContext]="{
                                                templateRef: $any(col).groupFooterTemplateRef,
                                                group: $any(item.data),
                                                field: $any(col).field,
                                                column: col,
                                                aggregates: $any(item.data)?.aggregates,
                                                $implicit: $any(item.data)?.aggregates
                                            }">
                                        </ng-template>
                                    </div>
                                }
                            }
                        </div>
                    </td>
                }
            </tr>
        }
    }
    @if (rowSticky) {
        <kendo-resize-sensor (resize)="resizeHandler()"></kendo-resize-sensor>
    }
    `,
      standalone: true,
      imports: [LogicalRowDirective, LogicalCellDirective, CellComponent, NgClass, NgStyle, TemplateContextDirective, GroupHeaderComponent, IconWrapperComponent, NgTemplateOutlet, ResizeSensorComponent]
    }]
  }], () => [{
    type: DetailsService
  }, {
    type: GroupsService
  }, {
    type: ChangeNotificationService
  }, {
    type: EditService
  }, {
    type: ContextService
  }, {
    type: NgZone
  }, {
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: DomEventsService
  }, {
    type: SelectionService2
  }, {
    type: CellSelectionService
  }, {
    type: ColumnInfoService
  }, {
    type: NavigationService4
  }], {
    columns: [{
      type: Input
    }],
    allColumns: [{
      type: Input
    }],
    groups: [{
      type: Input
    }],
    detailTemplate: [{
      type: Input
    }],
    noRecordsTemplate: [{
      type: Input
    }],
    rowsToRender: [{
      type: Input
    }],
    skip: [{
      type: Input
    }],
    selectable: [{
      type: Input
    }],
    filterable: [{
      type: Input
    }],
    noRecordsText: [{
      type: Input
    }],
    isLocked: [{
      type: Input
    }],
    isLoading: [{
      type: Input
    }],
    isVirtual: [{
      type: Input
    }],
    cellLoadingTemplate: [{
      type: Input
    }],
    skipGroupDecoration: [{
      type: Input
    }],
    lockedColumnsCount: [{
      type: Input
    }],
    totalColumnsCount: [{
      type: Input
    }],
    virtualColumns: [{
      type: Input
    }],
    trackBy: [{
      type: Input
    }],
    rowSticky: [{
      type: Input
    }],
    totalColumns: [{
      type: Input
    }],
    rowClass: [{
      type: Input
    }],
    rowHeight: [{
      type: Input
    }],
    detailRowHeight: [{
      type: Input
    }],
    hostClass: [{
      type: HostBinding,
      args: ["class.k-table-tbody"]
    }]
  });
})();
var EditCommandDirective = class _EditCommandDirective extends ButtonComponent {
  editService;
  cellContext;
  rowIndex;
  isEdited;
  /**
   * @hidden
   */
  get visible() {
    return this.isEdited ? "none" : "";
  }
  /**
   * @hidden
   */
  commandClass = true;
  /**
   * @hidden
   */
  onClick(e) {
    e.preventDefault();
    this.editService.beginEdit(this.rowIndex);
  }
  constructor(editService, cellContext, element, renderer, ctx, ngZone) {
    super(element, renderer, null, ctx.localization, ngZone);
    this.editService = editService;
    this.cellContext = cellContext;
  }
  ngDoCheck() {
    if (this.cellContext) {
      this.rowIndex = this.cellContext.rowIndex;
      this.isEdited = this.editService.isEdited(this.rowIndex);
    }
  }
  static ɵfac = function EditCommandDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _EditCommandDirective)(ɵɵdirectiveInject(EditService), ɵɵdirectiveInject(CELL_CONTEXT), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _EditCommandDirective,
    selectors: [["", "kendoGridEditCommand", ""]],
    hostVars: 4,
    hostBindings: function EditCommandDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("click", function EditCommandDirective_click_HostBindingHandler($event) {
          return ctx.onClick($event);
        });
      }
      if (rf & 2) {
        ɵɵstyleProp("display", ctx.visible);
        ɵɵclassProp("k-grid-edit-command", ctx.commandClass);
      }
    },
    features: [ɵɵInheritDefinitionFeature],
    attrs: _c433,
    ngContentSelectors: _c118,
    decls: 5,
    vars: 3,
    consts: [["innerCssClass", "k-button-icon", 3, "name", "svgIcon"], [1, "k-button-icon", "k-icon"], [1, "k-button-icon", 3, "ngClass"], [1, "k-button-text"], ["role", "presentation", 1, "k-image", 3, "src"]],
    template: function EditCommandDirective_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵconditionalCreate(0, EditCommandDirective_Conditional_0_Template, 1, 2, "kendo-icon-wrapper", 0);
        ɵɵconditionalCreate(1, EditCommandDirective_Conditional_1_Template, 2, 1, "span", 1);
        ɵɵconditionalCreate(2, EditCommandDirective_Conditional_2_Template, 1, 1, "span", 2);
        ɵɵelementStart(3, "span", 3);
        ɵɵprojection(4);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵconditional(ctx.icon || ctx.svgIcon ? 0 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.imageUrl ? 1 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.iconClass ? 2 : -1);
      }
    },
    dependencies: [IconWrapperComponent, NgClass],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EditCommandDirective, [{
    type: Component,
    args: [{
      selector: "[kendoGridEditCommand]",
      template: `
        @if (icon || svgIcon) {
          <kendo-icon-wrapper
            innerCssClass="k-button-icon"
            [name]="icon"
          [svgIcon]="svgIcon"></kendo-icon-wrapper>
        }
        @if (imageUrl) {
          <span class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
          </span>
        }
        @if (iconClass) {
          <span class="k-button-icon" [ngClass]="iconClass"></span>
        }
        <span class="k-button-text"><ng-content></ng-content></span>
        `,
      standalone: true,
      imports: [IconWrapperComponent, NgClass]
    }]
  }], () => [{
    type: EditService
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [CELL_CONTEXT]
    }]
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: ContextService
  }, {
    type: NgZone
  }], {
    visible: [{
      type: HostBinding,
      args: ["style.display"]
    }],
    commandClass: [{
      type: HostBinding,
      args: ["class.k-grid-edit-command"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var CancelCommandDirective = class _CancelCommandDirective extends ButtonComponent {
  editService;
  cellContext;
  rowIndex;
  isEdited;
  /**
   * @hidden
   */
  get visible() {
    return !this.isEdited ? "none" : "";
  }
  /**
   * @hidden
   */
  commandClass = true;
  /**
   * @hidden
   */
  onClick(e) {
    e.preventDefault();
    if (this.isEdited) {
      this.editService.endEdit(this.rowIndex);
    }
  }
  constructor(editService, cellContext, element, renderer, ctx, ngZone) {
    super(element, renderer, null, ctx.localization, ngZone);
    this.editService = editService;
    this.cellContext = cellContext;
  }
  ngDoCheck() {
    if (this.cellContext) {
      this.rowIndex = this.cellContext.rowIndex;
      this.isEdited = this.editService.isEdited(this.rowIndex);
    }
  }
  static ɵfac = function CancelCommandDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CancelCommandDirective)(ɵɵdirectiveInject(EditService), ɵɵdirectiveInject(CELL_CONTEXT), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _CancelCommandDirective,
    selectors: [["", "kendoGridCancelCommand", ""]],
    hostVars: 4,
    hostBindings: function CancelCommandDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("click", function CancelCommandDirective_click_HostBindingHandler($event) {
          return ctx.onClick($event);
        });
      }
      if (rf & 2) {
        ɵɵstyleProp("display", ctx.visible);
        ɵɵclassProp("k-grid-cancel-command", ctx.commandClass);
      }
    },
    features: [ɵɵInheritDefinitionFeature],
    attrs: _c442,
    ngContentSelectors: _c118,
    decls: 5,
    vars: 3,
    consts: [["innerCssClass", "k-button-icon", 3, "name", "svgIcon"], [1, "k-button-icon", "k-icon"], [1, "k-button-icon", 3, "ngClass"], [1, "k-button-text"], ["role", "presentation", 1, "k-image", 3, "src"]],
    template: function CancelCommandDirective_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵconditionalCreate(0, CancelCommandDirective_Conditional_0_Template, 1, 2, "kendo-icon-wrapper", 0);
        ɵɵconditionalCreate(1, CancelCommandDirective_Conditional_1_Template, 2, 1, "span", 1);
        ɵɵconditionalCreate(2, CancelCommandDirective_Conditional_2_Template, 1, 1, "span", 2);
        ɵɵelementStart(3, "span", 3);
        ɵɵprojection(4);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵconditional(ctx.icon || ctx.svgIcon ? 0 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.imageUrl ? 1 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.iconClass ? 2 : -1);
      }
    },
    dependencies: [IconWrapperComponent, NgClass],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CancelCommandDirective, [{
    type: Component,
    args: [{
      selector: "[kendoGridCancelCommand]",
      template: `
        @if (icon || svgIcon) {
          <kendo-icon-wrapper
            innerCssClass="k-button-icon"
            [name]="icon"
          [svgIcon]="svgIcon"></kendo-icon-wrapper>
        }
        @if (imageUrl) {
          <span class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
          </span>
        }
        @if (iconClass) {
          <span class="k-button-icon" [ngClass]="iconClass"></span>
        }
        <span class="k-button-text"><ng-content></ng-content></span>
        `,
      standalone: true,
      imports: [IconWrapperComponent, NgClass]
    }]
  }], () => [{
    type: EditService
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [CELL_CONTEXT]
    }]
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: ContextService
  }, {
    type: NgZone
  }], {
    visible: [{
      type: HostBinding,
      args: ["style.display"]
    }],
    commandClass: [{
      type: HostBinding,
      args: ["class.k-grid-cancel-command"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var SaveCommandDirective = class _SaveCommandDirective extends ButtonComponent {
  editService;
  cellContext;
  rowIndex;
  isEdited;
  /**
   * @hidden
   */
  get visible() {
    return !this.isEdited ? "none" : "";
  }
  /**
   * @hidden
   */
  commandClass = true;
  /**
   * @hidden
   */
  onClick(e) {
    e.preventDefault();
    if (this.isEdited) {
      this.editService.save(this.rowIndex);
    }
  }
  constructor(editService, cellContext, element, renderer, ctx, ngZone) {
    super(element, renderer, null, ctx.localization, ngZone);
    this.editService = editService;
    this.cellContext = cellContext;
  }
  ngDoCheck() {
    if (this.cellContext) {
      this.rowIndex = this.cellContext.rowIndex;
      this.isEdited = this.editService.isEdited(this.rowIndex);
    }
  }
  static ɵfac = function SaveCommandDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SaveCommandDirective)(ɵɵdirectiveInject(EditService), ɵɵdirectiveInject(CELL_CONTEXT), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _SaveCommandDirective,
    selectors: [["", "kendoGridSaveCommand", ""]],
    hostVars: 4,
    hostBindings: function SaveCommandDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("click", function SaveCommandDirective_click_HostBindingHandler($event) {
          return ctx.onClick($event);
        });
      }
      if (rf & 2) {
        ɵɵstyleProp("display", ctx.visible);
        ɵɵclassProp("k-grid-save-command", ctx.commandClass);
      }
    },
    features: [ɵɵInheritDefinitionFeature],
    attrs: _c452,
    ngContentSelectors: _c118,
    decls: 5,
    vars: 3,
    consts: [["innerCssClass", "k-button-icon", 3, "name", "svgIcon"], [1, "k-button-icon", "k-icon"], [1, "k-button-icon", 3, "ngClass"], [1, "k-button-text"], ["role", "presentation", 1, "k-image", 3, "src"]],
    template: function SaveCommandDirective_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵconditionalCreate(0, SaveCommandDirective_Conditional_0_Template, 1, 2, "kendo-icon-wrapper", 0);
        ɵɵconditionalCreate(1, SaveCommandDirective_Conditional_1_Template, 2, 1, "span", 1);
        ɵɵconditionalCreate(2, SaveCommandDirective_Conditional_2_Template, 1, 1, "span", 2);
        ɵɵelementStart(3, "span", 3);
        ɵɵprojection(4);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵconditional(ctx.icon || ctx.svgIcon ? 0 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.imageUrl ? 1 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.iconClass ? 2 : -1);
      }
    },
    dependencies: [IconWrapperComponent, NgClass],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SaveCommandDirective, [{
    type: Component,
    args: [{
      selector: "[kendoGridSaveCommand]",
      template: `
        @if (icon || svgIcon) {
          <kendo-icon-wrapper
            innerCssClass="k-button-icon"
            [name]="icon"
          [svgIcon]="svgIcon"></kendo-icon-wrapper>
        }
        @if (imageUrl) {
          <span class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
          </span>
        }
        @if (iconClass) {
          <span class="k-button-icon" [ngClass]="iconClass"></span>
        }
        <span class="k-button-text"><ng-content></ng-content></span>
        `,
      standalone: true,
      imports: [IconWrapperComponent, NgClass]
    }]
  }], () => [{
    type: EditService
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [CELL_CONTEXT]
    }]
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: ContextService
  }, {
    type: NgZone
  }], {
    visible: [{
      type: HostBinding,
      args: ["style.display"]
    }],
    commandClass: [{
      type: HostBinding,
      args: ["class.k-grid-save-command"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var RemoveCommandDirective = class _RemoveCommandDirective extends ButtonComponent {
  editService;
  cellContext;
  rowIndex;
  isEdited;
  /**
   * @hidden
   */
  get visible() {
    return this.isEdited ? "none" : "";
  }
  /**
   * @hidden
   */
  commandClass = true;
  /**
   * @hidden
   */
  onClick(e) {
    e.preventDefault();
    e.stopImmediatePropagation();
    this.editService.remove(this.rowIndex);
  }
  constructor(editService, cellContext, element, renderer, ctx, ngZone) {
    super(element, renderer, null, ctx.localization, ngZone);
    this.editService = editService;
    this.cellContext = cellContext;
  }
  ngDoCheck() {
    if (this.cellContext) {
      this.rowIndex = this.cellContext.rowIndex;
      this.isEdited = this.editService.isEdited(this.rowIndex);
    }
  }
  static ɵfac = function RemoveCommandDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RemoveCommandDirective)(ɵɵdirectiveInject(EditService), ɵɵdirectiveInject(CELL_CONTEXT), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _RemoveCommandDirective,
    selectors: [["", "kendoGridRemoveCommand", ""]],
    hostVars: 4,
    hostBindings: function RemoveCommandDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("click", function RemoveCommandDirective_click_HostBindingHandler($event) {
          return ctx.onClick($event);
        });
      }
      if (rf & 2) {
        ɵɵstyleProp("display", ctx.visible);
        ɵɵclassProp("k-grid-remove-command", ctx.commandClass);
      }
    },
    features: [ɵɵInheritDefinitionFeature],
    attrs: _c462,
    ngContentSelectors: _c118,
    decls: 5,
    vars: 3,
    consts: [["innerCssClass", "k-button-icon", 3, "name", "svgIcon"], [1, "k-button-icon", "k-icon"], [1, "k-button-icon", 3, "ngClass"], [1, "k-button-text"], ["role", "presentation", 1, "k-image", 3, "src"]],
    template: function RemoveCommandDirective_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵconditionalCreate(0, RemoveCommandDirective_Conditional_0_Template, 1, 2, "kendo-icon-wrapper", 0);
        ɵɵconditionalCreate(1, RemoveCommandDirective_Conditional_1_Template, 2, 1, "span", 1);
        ɵɵconditionalCreate(2, RemoveCommandDirective_Conditional_2_Template, 1, 1, "span", 2);
        ɵɵelementStart(3, "span", 3);
        ɵɵprojection(4);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵconditional(ctx.icon || ctx.svgIcon ? 0 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.imageUrl ? 1 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.iconClass ? 2 : -1);
      }
    },
    dependencies: [IconWrapperComponent, NgClass],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RemoveCommandDirective, [{
    type: Component,
    args: [{
      selector: "[kendoGridRemoveCommand]",
      template: `
        @if (icon || svgIcon) {
          <kendo-icon-wrapper
            innerCssClass="k-button-icon"
            [name]="icon"
          [svgIcon]="svgIcon"></kendo-icon-wrapper>
        }
        @if (imageUrl) {
          <span class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
          </span>
        }
        @if (iconClass) {
          <span class="k-button-icon" [ngClass]="iconClass"></span>
        }
        <span class="k-button-text"><ng-content></ng-content></span>
        `,
      standalone: true,
      imports: [IconWrapperComponent, NgClass]
    }]
  }], () => [{
    type: EditService
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [CELL_CONTEXT]
    }]
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: ContextService
  }, {
    type: NgZone
  }], {
    visible: [{
      type: HostBinding,
      args: ["style.display"]
    }],
    commandClass: [{
      type: HostBinding,
      args: ["class.k-grid-remove-command"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var AddCommandDirective = class _AddCommandDirective extends ButtonComponent {
  editService;
  /**
   * @hidden
   */
  onClick(e) {
    e.preventDefault();
    this.editService.beginAdd();
  }
  /**
   * @hidden
   */
  get commandClass() {
    return true;
  }
  constructor(editService, element, renderer, ctx, ngZone) {
    super(element, renderer, null, ctx.localization, ngZone);
    this.editService = editService;
  }
  static ɵfac = function AddCommandDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AddCommandDirective)(ɵɵdirectiveInject(EditService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _AddCommandDirective,
    selectors: [["", "kendoGridAddCommand", ""]],
    hostVars: 2,
    hostBindings: function AddCommandDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("click", function AddCommandDirective_click_HostBindingHandler($event) {
          return ctx.onClick($event);
        });
      }
      if (rf & 2) {
        ɵɵclassProp("k-grid-add-command", ctx.commandClass);
      }
    },
    features: [ɵɵInheritDefinitionFeature],
    attrs: _c472,
    ngContentSelectors: _c118,
    decls: 5,
    vars: 3,
    consts: [["innerCssClass", "k-button-icon", 3, "name", "svgIcon"], [1, "k-button-icon", "k-icon"], [1, "k-button-icon", 3, "ngClass"], [1, "k-button-text"], ["role", "presentation", 1, "k-image", 3, "src"]],
    template: function AddCommandDirective_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵconditionalCreate(0, AddCommandDirective_Conditional_0_Template, 1, 2, "kendo-icon-wrapper", 0);
        ɵɵconditionalCreate(1, AddCommandDirective_Conditional_1_Template, 2, 1, "span", 1);
        ɵɵconditionalCreate(2, AddCommandDirective_Conditional_2_Template, 1, 1, "span", 2);
        ɵɵelementStart(3, "span", 3);
        ɵɵprojection(4);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵconditional(ctx.icon || ctx.svgIcon ? 0 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.imageUrl ? 1 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.iconClass ? 2 : -1);
      }
    },
    dependencies: [IconWrapperComponent, NgClass],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AddCommandDirective, [{
    type: Component,
    args: [{
      selector: "[kendoGridAddCommand]",
      template: `
        @if (icon || svgIcon) {
          <kendo-icon-wrapper
            innerCssClass="k-button-icon"
            [name]="icon"
          [svgIcon]="svgIcon"></kendo-icon-wrapper>
        }
        @if (imageUrl) {
          <span class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
          </span>
        }
        @if (iconClass) {
          <span class="k-button-icon" [ngClass]="iconClass"></span>
        }
        <span class="k-button-text"><ng-content></ng-content></span>
        `,
      standalone: true,
      imports: [IconWrapperComponent, NgClass]
    }]
  }], () => [{
    type: EditService
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: ContextService
  }, {
    type: NgZone
  }], {
    onClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }],
    commandClass: [{
      type: HostBinding,
      args: ["class.k-grid-add-command"]
    }]
  });
})();
var CellLoadingTemplateDirective = class _CellLoadingTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function CellLoadingTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CellLoadingTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CellLoadingTemplateDirective,
    selectors: [["", "kendoGridCellLoadingTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CellLoadingTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridCellLoadingTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var RowDragHandleTemplateDirective = class _RowDragHandleTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function RowDragHandleTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RowDragHandleTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _RowDragHandleTemplateDirective,
    selectors: [["", "kendoGridRowDragHandleTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RowDragHandleTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridRowDragHandleTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var RowDragHintTemplateDirective = class _RowDragHintTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function RowDragHintTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RowDragHintTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _RowDragHintTemplateDirective,
    selectors: [["", "kendoGridRowDragHintTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RowDragHintTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridRowDragHintTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var RowReorderColumnComponent = class _RowReorderColumnComponent extends ColumnBase2 {
  parent;
  /**
   * Defines the name for an existing font icon in the Kendo UI theme.
   * @hidden
   */
  dragHandleIcon;
  /**
   * Defines an SVGIcon to be rendered as a drag handle.
   * @hidden
   */
  dragHandleSVGIcon;
  /**
   * @hidden
   */
  dragHandleTemplate = new QueryList();
  /**
   * @hidden
   */
  dragHintTemplate = new QueryList();
  /**
   * @hidden
   */
  isRowReorderColumn = true;
  /**
   * @hidden
   */
  get rowDragHandleTemplateRef() {
    const rowTemplate = this.dragHandleTemplate.first;
    return rowTemplate ? rowTemplate.templateRef : void 0;
  }
  /**
   * @hidden
   */
  get rowDragHintTemplateRef() {
    const rowTemplate = this.dragHintTemplate.first;
    return rowTemplate ? rowTemplate.templateRef : void 0;
  }
  constructor(parent, idService) {
    super(parent, idService);
    this.parent = parent;
  }
  /**
   * Sets a function to determine the rowspan of each column cell.
   */
  set cellRowspan(cellRowspan) {
    super.cellRowspan = cellRowspan;
  }
  get cellRowspan() {
    return super.cellRowspan;
  }
  static ɵfac = function RowReorderColumnComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RowReorderColumnComponent)(ɵɵdirectiveInject(ColumnBase2, 13), ɵɵdirectiveInject(IdService, 8));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _RowReorderColumnComponent,
    selectors: [["kendo-grid-rowreorder-column"]],
    contentQueries: function RowReorderColumnComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, RowDragHandleTemplateDirective, 4)(dirIndex, RowDragHintTemplateDirective, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dragHandleTemplate = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dragHintTemplate = _t);
      }
    },
    inputs: {
      dragHandleIcon: "dragHandleIcon",
      dragHandleSVGIcon: "dragHandleSVGIcon"
    },
    features: [ɵɵProvidersFeature([{
      provide: ColumnBase2,
      useExisting: forwardRef(() => _RowReorderColumnComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function RowReorderColumnComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RowReorderColumnComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: ColumnBase2,
        useExisting: forwardRef(() => RowReorderColumnComponent)
      }],
      selector: "kendo-grid-rowreorder-column",
      template: ``,
      standalone: true
    }]
  }], () => [{
    type: ColumnBase2,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }, {
      type: Optional
    }]
  }, {
    type: IdService,
    decorators: [{
      type: Optional
    }]
  }], {
    dragHandleIcon: [{
      type: Input
    }],
    dragHandleSVGIcon: [{
      type: Input
    }],
    dragHandleTemplate: [{
      type: ContentChildren,
      args: [RowDragHandleTemplateDirective, {
        descendants: false
      }]
    }],
    dragHintTemplate: [{
      type: ContentChildren,
      args: [RowDragHintTemplateDirective, {
        descendants: false
      }]
    }]
  });
})();
var ZoneAwareEventEmitter = class extends EventEmitter {
  ngZone;
  constructor(ngZone, isAsync = false) {
    super(isAsync);
    this.ngZone = ngZone;
  }
  subscribe(generatorOrNext, error, complete) {
    let schedulerFn;
    let errorFn = (_) => null;
    let completeFn = () => null;
    if (generatorOrNext && typeof generatorOrNext === "object") {
      schedulerFn = (value2) => {
        this.ngZone.run(() => generatorOrNext.next(value2));
      };
      if (generatorOrNext.error) {
        errorFn = (err) => {
          this.ngZone.run(() => generatorOrNext.error(err));
        };
      }
      if (generatorOrNext.complete) {
        completeFn = () => {
          this.ngZone.run(() => generatorOrNext.complete());
        };
      }
    } else {
      schedulerFn = (value2) => {
        this.ngZone.run(() => generatorOrNext(value2));
      };
      if (error) {
        errorFn = (err) => {
          this.ngZone.run(() => error(err));
        };
      }
      if (complete) {
        completeFn = () => {
          this.ngZone.run(() => complete());
        };
      }
    }
    return super.subscribe(schedulerFn, errorFn, completeFn);
  }
};
var packageMetadata9 = {
  name: "@progress/kendo-angular-grid",
  productName: "Kendo UI for Angular",
  productCode: "KENDOUIANGULAR",
  productCodes: ["KENDOUIANGULAR"],
  publishDate: 0,
  version: "22.0.1",
  licensingDocsUrl: "https://www.telerik.com/kendo-angular-ui/my-license/"
};
var convertDateStringsInFilter = (filter3) => {
  if (!filter3) {
    return filter3;
  }
  if (filter3.filters && Array.isArray(filter3.filters)) {
    return __spreadProps(__spreadValues({}, filter3), {
      filters: filter3.filters.map((f) => convertDateStringsInFilter(f))
    });
  }
  if (filter3.field && filter3.value !== void 0) {
    if (typeof filter3.value === "string" && isDateOperator(filter3.operator)) {
      const date = parseDate(filter3.value);
      return __spreadProps(__spreadValues({}, filter3), {
        value: date || filter3.value
      });
    }
  }
  return filter3;
};
var isDateOperator = (operator) => {
  const dateOperators2 = ["eq", "neq", "lt", "lte", "gt", "gte"];
  return dateOperators2.includes(operator);
};
var processCellHighlights = (filter3, rowIndex, columns, highlightItems) => {
  Object.keys(filter3.cells).forEach((columnField) => {
    const actualColumnIndex = Array.from(columns).findIndex((col) => col.field === columnField);
    if (actualColumnIndex !== -1) {
      highlightItems.push({
        itemKey: rowIndex,
        columnKey: actualColumnIndex
      });
    }
  });
};
var processFilteredResults = (filteredResults, data, filter3, columns, highlightItems) => {
  filteredResults?.forEach((item) => {
    const rowIndex = data.findIndex((dataItem) => dataItem === item);
    if (filter3.cells && Object.keys(filter3.cells).length > 0) {
      processCellHighlights(filter3, rowIndex, columns, highlightItems);
    } else {
      highlightItems.push({
        itemKey: rowIndex
      });
    }
  });
};
var highlightBy = (data, filters, columns) => {
  const highlightItems = [];
  filters.forEach((filter3) => {
    const processedFilters = filter3.filters.map((filter4) => convertDateStringsInFilter(filter4));
    const filteredResults = filterBy(data, {
      logic: filter3.logic || "and",
      filters: processedFilters
    });
    processFilteredResults(filteredResults, data, filter3, columns, highlightItems);
  });
  return highlightItems;
};
var GridAIRequestResponseService = class _GridAIRequestResponseService {
  ctx;
  columnInfoService;
  zone;
  constructor(ctx, columnInfoService, zone) {
    this.ctx = ctx;
    this.columnInfoService = columnInfoService;
    this.zone = zone;
  }
  /**
   * Builds the request body for the AI service based on the Grid's column structure.
   * Returns a column descriptor tree that includes column metadata for the AI service.
   */
  buildRequestBody(promptMessage, role) {
    const columnsTree = this.buildColumnDescriptors();
    return {
      role: role || "user",
      contents: [{
        text: promptMessage
      }],
      columns: columnsTree
    };
  }
  /**
   * Builds a nested column descriptor tree based on the Grid's column structure.
   * Includes root columns and their nested children (for ColumnGroup and SpanColumn).
   */
  buildColumnDescriptors() {
    const rootColumns = this.ctx?.grid?.columnList?.rootColumns() || [];
    const buildDescriptor = (col) => {
      const hasChildren = Boolean(col.hasChildren && col.childrenArray?.length);
      const descriptor = {
        id: col.id,
        field: col.field,
        header: col.title
      };
      if (hasChildren) {
        descriptor.columns = col.childrenArray.map((c) => buildDescriptor(c));
      }
      if (!col.field) {
        if (isCheckboxColumn(col)) {
          descriptor.type = "checkbox";
        } else if (col instanceof CommandColumnComponent) {
          descriptor.type = "command";
        }
      }
      return descriptor;
    };
    return rootColumns.map((col) => buildDescriptor(col));
  }
  /**
   * Processes AI response commands and applies them to the Grid.
   * Returns an array of display messages for each command.
   */
  processCommands(commands, columns, leafColumns2) {
    const messages = [];
    this.executeCommands(commands || [], columns, leafColumns2, messages);
    return messages;
  }
  executeCommands(commands, columns, leafColumns2, messages) {
    if (!commands?.length) {
      return;
    }
    const grid = this.ctx.grid;
    const isFilterable2 = Boolean(grid.filterable);
    const isSortable = Boolean(grid.sortable);
    const isGroupable = Boolean(grid.groupable);
    const findColumnById = (id3) => grid.columnList.toArray().find((c) => c.id === id3);
    const updateColumnHierarchy = (column, updater) => {
      const changed = [];
      const queue = [column];
      while (queue.length) {
        const current = queue.shift();
        if (!current) {
          continue;
        }
        const didChange = updater(current);
        if (didChange) {
          changed.push(current);
        }
        if (current.hasChildren && current.childrenArray?.length) {
          queue.push(...current.childrenArray);
        }
      }
      return changed;
    };
    commands.forEach((cmd) => {
      let displayMessage = cmd.message || "";
      if (this.isColumnCommand(cmd.type)) {
        if (cmd.id) {
          const column = findColumnById(cmd.id);
          const replacement = this.getColumnReplacement(column);
          displayMessage = this.replaceQuotedColumnId(displayMessage, replacement);
        }
      }
      messages.push(displayMessage);
      switch (cmd.type) {
        case "GridSort":
          if (!isSortable) {
            break;
          }
          this.processArrayResponse([cmd.sort], grid.currentState.sort || [], (item) => item.field, (mergedArray) => grid.sortChange.next(mergedArray));
          break;
        case "GridClearSort":
          if (!isSortable) {
            break;
          }
          grid.sortChange.next([]);
          break;
        case "GridFilter":
          if (!isFilterable2) {
            break;
          }
          this.processFilterResponse(cmd.filter);
          break;
        case "GridClearFilter":
          if (!isFilterable2) {
            break;
          }
          grid.filterChange.next(void 0);
          break;
        case "GridGroup":
          if (!isGroupable) {
            break;
          }
          this.processArrayResponse([cmd.group], grid.currentState.group || [], (item) => item.field, (mergedArray) => grid.groupChange.next(mergedArray));
          break;
        case "GridClearGroup":
          if (!isGroupable) {
            break;
          }
          grid.groupChange.next([]);
          break;
        case "GridHighlight":
          if (!this.ctx.highlightDirective) {
            break;
          }
          this.processHighlightResponse([cmd.highlight], columns);
          break;
        case "GridClearHighlight":
          if (!this.ctx.highlightDirective) {
            break;
          }
          this.ctx.highlightDirective["setState"]([]);
          break;
        case "GridSelect": {
          this.processSelectionResponse([cmd.select], columns, leafColumns2, messages);
          break;
        }
        case "GridClearSelect": {
          const selectionInstance = this.getSelectionInstance();
          if (!selectionInstance) {
            this.updateLastMessage(messages, this.ctx.localization?.get("aiAssistantSelectionNotEnabled"));
            break;
          }
          this.applySelectionState(selectionInstance, []);
          break;
        }
        case "GridColumnResize": {
          const col = findColumnById(cmd.id);
          if (!col) {
            break;
          }
          let newWidth;
          if (typeof cmd.size === "number") {
            newWidth = cmd.size;
          } else if (typeof cmd.size === "string") {
            const numericPart = parseFloat(cmd.size);
            if (!isNaN(numericPart)) {
              newWidth = numericPart;
            }
          }
          if (typeof newWidth === "number") {
            const oldWidth = col.width;
            col.width = newWidth;
            const args = [{
              column: col,
              oldWidth,
              newWidth
            }];
            grid.columnResize.emit(args);
          }
          break;
        }
        case "GridColumnReorder": {
          const col = findColumnById(cmd.id);
          if (!col) {
            break;
          }
          const newPosition = Number(cmd.position);
          if (!isNaN(newPosition) && newPosition >= 0) {
            this.changeColumnPosition(col, newPosition);
          }
          break;
        }
        case "GridColumnShow":
        case "GridColumnHide": {
          const col = findColumnById(cmd.id);
          if (!col) {
            break;
          }
          const targetHidden = cmd.type === "GridColumnHide";
          const changed = updateColumnHierarchy(col, (current) => {
            if (current.hidden === targetHidden) {
              return false;
            }
            current.hidden = targetHidden;
            return true;
          });
          if (changed.length) {
            this.columnInfoService.changeVisibility(changed);
          }
          break;
        }
        case "GridColumnLock":
        case "GridColumnUnlock": {
          const col = findColumnById(cmd.id);
          if (!col) {
            break;
          }
          const targetLocked = cmd.type === "GridColumnLock";
          const changed = updateColumnHierarchy(col, (current) => {
            if (current.locked === targetLocked) {
              return false;
            }
            current.locked = targetLocked;
            return true;
          });
          if (changed.length) {
            this.columnInfoService.changeLocked(changed);
          }
          break;
        }
        case "GridPage": {
          this.processPageCommand(cmd);
          break;
        }
        case "GridPageSize": {
          this.processPageSizeCommand(cmd);
          break;
        }
        case "GridExportExcel": {
          this.runExportWithFileName(this.ctx.excelComponent, cmd.fileName, () => grid.saveAsExcel());
          break;
        }
        case "GridExportPDF": {
          this.runExportWithFileName(this.ctx.pdfComponent, cmd.fileName, () => grid.emitPDFExportEvent());
          break;
        }
        default:
          break;
      }
    });
  }
  processArrayResponse(newItems, currentItems, getField2, updateGrid) {
    if (newItems?.length === 0) {
      updateGrid([]);
    } else if (newItems?.length) {
      let mergedArray = [...newItems];
      const newFields = newItems.map(getField2);
      const existingItemsToKeep = currentItems.filter((item) => !newFields.includes(getField2(item)));
      mergedArray = [...mergedArray, ...existingItemsToKeep];
      updateGrid(mergedArray);
    }
  }
  runExportWithFileName(component, fileName, action) {
    if (!component || !fileName) {
      action();
      return;
    }
    const previousFileName = component.fileName;
    component.fileName = fileName;
    action();
    const isExcel = component === this.ctx.excelComponent;
    if (isExcel) {
      this.zone.runOutsideAngular(() => {
        this.ctx.excelComponent.fileCreated.subscribe(() => {
          component.fileName = previousFileName;
        });
      });
    } else {
      component.fileName = previousFileName;
    }
  }
  processPageCommand(command) {
    const pageSize = this.getCurrentPageSizeValue();
    if (!isPresent(pageSize) || pageSize <= 0) {
      return;
    }
    const total = this.getTotalItemsCount();
    const requestedPage = Number(command.page);
    let targetPage = Number.isFinite(requestedPage) ? Math.floor(requestedPage) : 1;
    if (targetPage < 1) {
      targetPage = 1;
    }
    if (isPresent(total) && pageSize > 0) {
      const maxPage = Math.max(1, Math.ceil(total / pageSize));
      targetPage = Math.min(targetPage, maxPage);
    }
    const skip4 = (targetPage - 1) * pageSize;
    this.emitGridPageChange(skip4, pageSize);
  }
  processPageSizeCommand(command) {
    const rawPageSize = Number(command.pageSize);
    if (!Number.isFinite(rawPageSize)) {
      return;
    }
    const newPageSize = Math.max(1, Math.floor(rawPageSize));
    const skip4 = Math.max(0, this.ctx.grid?.skip ?? 0);
    this.ensurePageSizeOption(newPageSize);
    this.emitGridPageChange(skip4, newPageSize);
  }
  emitGridPageChange(skip4, take4) {
    const grid = this.ctx.grid;
    const normalizedSkip = Math.max(0, Math.floor(skip4));
    const normalizedTake = Math.max(1, Math.floor(take4));
    grid.skip = normalizedSkip;
    grid.pageSize = normalizedTake;
    grid.pageChange.emit({
      skip: normalizedSkip,
      take: normalizedTake
    });
  }
  ensurePageSizeOption(pageSize) {
    const grid = this.ctx.grid;
    if (!grid) {
      return;
    }
    const pageable = grid.pageable;
    if (!pageable || typeof pageable === "boolean") {
      return;
    }
    const pageSizes = pageable.pageSizes;
    if (!Array.isArray(pageSizes) || pageSizes.length === 0) {
      return;
    }
    if (pageSizes.includes(pageSize)) {
      return;
    }
    const uniqueSizes = [pageSize, ...pageSizes.filter((size) => size !== pageSize)];
    grid.pageable = __spreadProps(__spreadValues({}, pageable), {
      pageSizes: uniqueSizes
    });
    const changeDetector = grid?.changeDetectorRef;
    if (changeDetector && typeof changeDetector.markForCheck === "function") {
      changeDetector.markForCheck();
    }
  }
  getCurrentPageSizeValue() {
    const grid = this.ctx.grid;
    if (!grid) {
      return null;
    }
    const candidates = [grid.pageSize, grid.currentState?.take, this.ctx.dataBindingDirective?.["state"]?.take];
    for (const candidate of candidates) {
      if (typeof candidate === "number" && candidate > 0) {
        return candidate;
      }
    }
    const pageable = grid.pageable;
    if (pageable && typeof pageable === "object" && Array.isArray(pageable.pageSizes)) {
      const numericSize = pageable.pageSizes.find((size) => typeof size === "number" && size > 0);
      if (numericSize) {
        return numericSize;
      }
    }
    const originalData = this.ctx.dataBindingDirective?.["originalData"];
    if (Array.isArray(originalData) && originalData.length > 0) {
      return originalData.length;
    }
    return null;
  }
  getTotalItemsCount() {
    const grid = this.ctx.grid;
    if (!grid) {
      return null;
    }
    const gridData = grid.data;
    if (gridData && typeof gridData.total === "number") {
      return gridData.total;
    }
    const view2 = grid.view;
    if (view2 && typeof view2.total === "number") {
      return view2.total;
    }
    const originalData = this.ctx.dataBindingDirective?.["originalData"];
    if (Array.isArray(originalData)) {
      return originalData.length;
    }
    return null;
  }
  getSelectionInstance() {
    const selectionDirective = this.ctx.grid?.selectionDirective;
    if (selectionDirective && typeof selectionDirective === "object") {
      return selectionDirective;
    }
    const defaultSelection = this.ctx.grid?.defaultSelection;
    if (defaultSelection && typeof defaultSelection === "object") {
      return defaultSelection;
    }
    return null;
  }
  updateLastMessage(messages, newMessage) {
    if (!messages.length) {
      return;
    }
    messages[messages.length - 1] = newMessage;
  }
  isColumnCommand(type) {
    return type === "GridColumnResize" || type === "GridColumnReorder" || type === "GridColumnShow" || type === "GridColumnHide" || type === "GridColumnLock" || type === "GridColumnUnlock";
  }
  getColumnReplacement(column) {
    if (!column) {
      return "";
    }
    if (column.title && String(column.title).trim()) {
      return String(column.title).trim();
    }
    if (column.field && String(column.field).trim()) {
      return String(column.field).trim();
    }
    return "";
  }
  replaceQuotedColumnId(message, replacement) {
    if (!replacement) {
      const columnIdPattern2 = /(?:&quot;|")(k-grid\d+-col\d+)(?:&quot;|")\s*/g;
      return message.replace(columnIdPattern2, "").replace(/\s{2,}/g, " ").trim();
    }
    const columnIdPattern = /(?:&quot;|")(k-grid\d+-col\d+)(?:&quot;|")/g;
    return message.replace(columnIdPattern, (match) => {
      const isEncoded = match.startsWith("&quot;");
      return isEncoded ? `&quot;${replacement}&quot;` : `"${replacement}"`;
    });
  }
  getHighlightItems(descriptors, columns) {
    if (!descriptors?.length) {
      return [];
    }
    const data = this.ctx.dataBindingDirective?.["originalData"] || [];
    return highlightBy(data, descriptors, columns);
  }
  processSelectionResponse(selection, columns, leafColumns2, messages) {
    const selectionInstance = this.getSelectionInstance();
    if (!selectionInstance) {
      this.updateLastMessage(messages, this.ctx.localization?.get("aiAssistantSelectionNotEnabled"));
      return;
    }
    const descriptors = (selection || []).filter((descriptor) => Boolean(descriptor));
    if (descriptors.length === 0) {
      this.applySelectionState(selectionInstance, []);
      return;
    }
    const highlightItems = this.getHighlightItems(descriptors, columns);
    if (!highlightItems.length) {
      this.applySelectionState(selectionInstance, []);
      return;
    }
    const hasCellSelections = highlightItems.some((item) => isPresent(item.columnKey));
    const hasRowSelections = highlightItems.some((item) => !isPresent(item.columnKey));
    const isCellMode = selectionInstance.isCellSelectionMode;
    if (!isCellMode && hasCellSelections || isCellMode && hasRowSelections) {
      const key = isCellMode ? "aiAssistantSelectionRowModeRequired" : "aiAssistantSelectionCellModeRequired";
      this.updateLastMessage(messages, this.ctx.localization?.get(key));
      return;
    }
    const selectionState = this.mapHighlightItemsToSelection(selectionInstance, highlightItems, isCellMode, leafColumns2);
    this.applySelectionState(selectionInstance, selectionState);
  }
  mapHighlightItemsToSelection(selectionInstance, highlightItems, isCellMode, leafColumns2) {
    const data = this.ctx.dataBindingDirective?.["originalData"] || [];
    if (isCellMode) {
      const mapped = highlightItems.filter((item) => isPresent(item.itemKey) && isPresent(item.columnKey)).map((item) => {
        const rowIndex = item.itemKey;
        const columnIndex = item.columnKey;
        const dataItem = data[rowIndex];
        if (!isPresent(dataItem)) {
          return null;
        }
        if (typeof selectionInstance["getSelectionItem"] === "function") {
          const columnComponent = leafColumns2[columnIndex];
          const selectionItem = selectionInstance["getSelectionItem"]({
            dataItem,
            index: rowIndex
          }, columnComponent, columnIndex);
          if (selectionItem && isPresent(selectionItem.itemKey) && isPresent(selectionItem.columnKey)) {
            return selectionItem;
          }
          return null;
        }
        const itemKey = typeof selectionInstance.getItemKey === "function" ? selectionInstance.getItemKey({
          dataItem,
          index: rowIndex
        }) : rowIndex;
        return isPresent(itemKey) ? {
          itemKey,
          columnKey: columnIndex
        } : null;
      }).filter((item) => isPresent(item));
      return mapped.filter((item, index, self) => self.findIndex((other) => other.itemKey === item.itemKey && other.columnKey === item.columnKey) === index);
    }
    const rowKeys = highlightItems.filter((item) => isPresent(item.itemKey)).map((item) => {
      const rowIndex = item.itemKey;
      const dataItem = data[rowIndex];
      if (!isPresent(dataItem)) {
        return null;
      }
      if (typeof selectionInstance.getItemKey === "function") {
        return selectionInstance.getItemKey({
          dataItem,
          index: rowIndex
        });
      }
      return rowIndex;
    }).filter(isPresent);
    return Array.from(new Set(rowKeys));
  }
  applySelectionState(selectionInstance, selectionState) {
    selectionInstance.selectedKeys = selectionState;
    if (typeof selectionInstance["setState"] === "function") {
      selectionInstance["setState"](selectionState);
    }
    const changeDetector = selectionInstance["cd"];
    if (changeDetector && typeof changeDetector.markForCheck === "function") {
      changeDetector.markForCheck();
    }
    if (typeof selectionInstance["notifyChange"] === "function") {
      selectionInstance["notifyChange"]();
    }
  }
  processHighlightResponse(highlight, columns) {
    const highlightedItems = this.getHighlightItems(highlight, columns);
    this.ctx.highlightDirective["setState"](highlightedItems);
  }
  processFilterResponse(filter3) {
    const processedFilter = convertDateStringsInFilter(filter3);
    const clearFilter = Object.keys(processedFilter).length === 0;
    if (clearFilter) {
      this.ctx.grid.filterChange.next(void 0);
    } else if (processedFilter?.filters.length) {
      const currentFilter = this.ctx.grid.currentState.filter;
      let mergedFilter = processedFilter;
      if (currentFilter && currentFilter.filters?.length > 0) {
        mergedFilter = {
          logic: "and",
          filters: [currentFilter, processedFilter]
        };
      }
      this.ctx.grid.filterChange.next(mergedFilter);
    }
  }
  changeColumnPosition(column, newPosition) {
    const grid = this.ctx.grid;
    if (!grid?.columns) {
      return;
    }
    const currentColumns = grid.columns.toArray();
    const currentIndex = currentColumns.findIndex((col) => col === column);
    if (currentIndex === -1) {
      return;
    }
    if (newPosition < 0 || newPosition >= currentColumns.length) {
      return;
    }
    const sortedColumns = currentColumns.map((col, idx4) => ({
      col,
      physicalIndex: idx4,
      visualOrder: col.orderIndex ?? idx4
    })).sort((a, b) => a.visualOrder - b.visualOrder);
    const currentVisualPos = sortedColumns.findIndex((item) => item.physicalIndex === currentIndex);
    if (currentVisualPos === newPosition) {
      return;
    }
    currentColumns.forEach((col, idx4) => {
      const sortedIndex = sortedColumns.findIndex((item) => item.physicalIndex === idx4);
      if (idx4 === currentIndex) {
        col.orderIndex = newPosition;
      } else if (currentVisualPos < newPosition) {
        col.orderIndex = sortedIndex > currentVisualPos && sortedIndex <= newPosition ? sortedIndex - 1 : sortedIndex;
      } else {
        col.orderIndex = sortedIndex >= newPosition && sortedIndex < currentVisualPos ? sortedIndex + 1 : sortedIndex;
      }
      col.isReordered = true;
    });
    grid.columnReorder.emit({
      column,
      oldIndex: currentVisualPos,
      newIndex: newPosition
    });
  }
  static ɵfac = function GridAIRequestResponseService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _GridAIRequestResponseService)(ɵɵinject(ContextService), ɵɵinject(ColumnInfoService), ɵɵinject(NgZone));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _GridAIRequestResponseService,
    factory: _GridAIRequestResponseService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GridAIRequestResponseService, [{
    type: Injectable
  }], () => [{
    type: ContextService
  }, {
    type: ColumnInfoService
  }, {
    type: NgZone
  }], null);
})();
var normalizeSettings2 = ({
  buttonCount = 10,
  info = true,
  type = "numeric",
  pageSizes = false,
  previousNext = true,
  responsive = true,
  position: position2 = "bottom"
}) => ({
  buttonCount,
  info,
  pageSizes,
  previousNext,
  type,
  responsive,
  position: position2
});
var normalize4 = (settings) => normalizeSettings2(settings === true ? {} : settings);
var canCreateElement = () => isDocumentAvailable() && document.createElement;
var cachedScrollbarWidth = null;
var cachedPixelRatio;
var cachedRtlScrollLeft = null;
function scrollbarWidth() {
  if (cachedScrollbarWidth === null && canCreateElement()) {
    cachedPixelRatio = window.devicePixelRatio || 1;
    const div2 = document.createElement("div");
    div2.style.cssText = "overflow:scroll;overflow-x:hidden;zoom:1;clear:both;display:block";
    div2.innerHTML = "&nbsp;";
    document.body.appendChild(div2);
    cachedScrollbarWidth = div2.offsetWidth - div2.scrollWidth;
    document.body.removeChild(div2);
  }
  return cachedScrollbarWidth;
}
function rtlScrollLeft() {
  if (cachedRtlScrollLeft === null && canCreateElement()) {
    const outer = document.createElement("div");
    outer.style.direction = "rtl";
    outer.style.display = "block";
    outer.style.clear = "both";
    outer.style.width = "100px";
    outer.style.visibility = "hidden";
    outer.style.position = "absolute";
    outer.style.left = "-10000px";
    outer.style.overflow = "scroll";
    outer.style.zoom = "1";
    const inner = document.createElement("div");
    inner.style.width = "200px";
    inner.style.height = "1px";
    outer.append(inner);
    document.body.appendChild(outer);
    const initial2 = outer.scrollLeft;
    outer.scrollLeft = -1;
    cachedRtlScrollLeft = outer.scrollLeft < 0 ? outer.scrollLeft : initial2;
    document.body.removeChild(outer);
  }
  return cachedRtlScrollLeft;
}
var BrowserSupportService = class _BrowserSupportService {
  zone;
  changeDetector;
  changes = new EventEmitter();
  subscriptions;
  constructor(zone, changeDetector) {
    this.zone = zone;
    this.changeDetector = changeDetector;
    if (typeof window === "undefined") {
      return;
    }
    this.zone.runOutsideAngular(() => {
      this.subscriptions = fromEvent(window, "resize").pipe(auditTime(100)).subscribe(() => {
        if (cachedPixelRatio !== window.devicePixelRatio) {
          zone.run(() => {
            cachedScrollbarWidth = null;
            this.changes.emit();
            this.changeDetector.markForCheck();
          });
        }
      });
    });
  }
  ngOnDestroy() {
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
      this.subscriptions = null;
    }
  }
  get scrollbarWidth() {
    return scrollbarWidth();
  }
  get rtlScrollLeft() {
    return rtlScrollLeft();
  }
  static ɵfac = function BrowserSupportService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BrowserSupportService)(ɵɵinject(NgZone), ɵɵinject(ChangeDetectorRef));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _BrowserSupportService,
    factory: _BrowserSupportService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BrowserSupportService, [{
    type: Injectable
  }], () => [{
    type: NgZone
  }, {
    type: ChangeDetectorRef
  }], null);
})();
var isGroupItem = (source) => {
  return source.items !== void 0 && source.field !== void 0;
};
var flattenGroups = (groups) => groups.reduce((acc, curr) => {
  if (isGroupItem(curr)) {
    return acc.concat(flattenGroups(curr.items));
  }
  return acc.concat([curr]);
}, []);
var itemAt = (data, index) => {
  const first = data[0];
  if (isPresent7(first) && isGroupItem(first)) {
    return flattenGroups(data)[index];
  }
  return data[index];
};
var getIterator = (data, {
  footers,
  level,
  dataIndex,
  parentGroupIndex,
  groupIndex,
  parentGroup
}) => {
  const first = data[0];
  if (isPresent7(first) && isGroupItem(first)) {
    return new GroupIterator(data, footers, level, dataIndex, parentGroupIndex, groupIndex, parentGroup);
  }
  return new ItemIterator(data, dataIndex, parentGroupIndex, parentGroup);
};
var ArrayIterator = class {
  arr;
  idx;
  constructor(arr, idx4 = 0) {
    this.arr = arr;
    this.idx = idx4;
    this.arr = arr || [];
  }
  [iterator]() {
    return this;
  }
  next() {
    return this.idx < this.arr.length ? {
      done: false,
      value: this.arr[this.idx++]
    } : {
      done: true,
      value: void 0
    };
  }
};
var Iterator = class {
  dataIndex;
  resultMap;
  _innerIterator;
  constructor(arr, dataIndex = 0, resultMap = (x) => x) {
    this.dataIndex = dataIndex;
    this.resultMap = resultMap;
    const iter = arr[iterator];
    this._innerIterator = iter ? arr[iterator]() : new ArrayIterator(arr);
  }
  [iterator]() {
    return this;
  }
  next() {
    return this.resultMap(this._innerIterator.next(), this.dataIndex++);
  }
};
var ItemIterator = class extends Iterator {
  constructor(arr, dataIndex, groupIndex, group2) {
    super(arr, dataIndex, (x, idx4) => ({
      done: x.done,
      value: {
        data: x.value,
        groupIndex,
        index: idx4,
        type: "data",
        group: group2
      }
    }));
  }
  /**
   * The index of the next record.
   * @readonly
   * @type {number}
   */
  get index() {
    return this.dataIndex;
  }
};
var prefix = (s, n) => {
  const p = s ? s + "_" : s;
  return `${p}${n}`;
};
var GroupIterator = class {
  arr;
  outputFooters;
  level;
  dataIndex;
  parentIndex;
  groupIndex;
  parentGroup;
  current;
  _innerIterator;
  _iterator;
  currentGroupIndex = "";
  constructor(arr, outputFooters = false, level = 0, dataIndex = 0, parentIndex = "", groupIndex = 0, parentGroup = void 0) {
    this.arr = arr;
    this.outputFooters = outputFooters;
    this.level = level;
    this.dataIndex = dataIndex;
    this.parentIndex = parentIndex;
    this.groupIndex = groupIndex;
    this.parentGroup = parentGroup;
    this.arr = arr || [];
    this._iterator = new Iterator(this.arr, this.dataIndex);
  }
  [iterator]() {
    return this;
  }
  nextGroupItem() {
    this.current = this._iterator.next().value;
    this._innerIterator = null;
    if (this.current) {
      this.currentGroupIndex = prefix(this.parentIndex, this.groupIndex++);
      return {
        done: false,
        value: {
          data: this.current,
          index: this.currentGroupIndex,
          level: this.level,
          type: "group",
          parentGroup: this.parentGroup
        }
      };
    } else {
      this.current = null;
      return {
        done: true,
        value: void 0
      };
    }
  }
  footerItem() {
    if (this.current) {
      const group2 = this.current;
      this.current = null;
      return {
        done: false,
        value: {
          data: group2,
          groupIndex: this.currentGroupIndex,
          level: this.level,
          type: "footer",
          group: {
            data: group2,
            index: this.currentGroupIndex,
            level: this.level,
            type: "group",
            parentGroup: this.parentGroup
          }
        }
      };
    } else {
      this.current = null;
      return {
        done: true,
        value: void 0
      };
    }
  }
  innerIterator(group2) {
    if (!this._innerIterator) {
      this._innerIterator = getIterator(group2.items, {
        dataIndex: this.dataIndex,
        footers: this.outputFooters,
        level: this.level + 1,
        parentGroupIndex: this.currentGroupIndex,
        parentGroup: {
          data: this.current,
          index: this.currentGroupIndex,
          level: this.level,
          type: "group",
          parentGroup: this.parentGroup
        }
      });
    }
    return this._innerIterator;
  }
  nextDataItem(group2) {
    const iterator2 = this.innerIterator(group2);
    const result = iterator2.next();
    if (isPresent7(result.value) && !result.done && result.value.type === "data") {
      this.dataIndex = result.value.index + 1;
    }
    return !result.done ? result : void 0;
  }
  next() {
    if (!isPresent7(this.current)) {
      return this.nextGroupItem();
    }
    const item = this.nextDataItem(this.current);
    return item ? item : this.outputFooters ? this.footerItem() : this.nextGroupItem();
  }
  /**
   * The index of the last iterated data record.
   * @readonly
   * @type {number}
   */
  get index() {
    return this.dataIndex + 1;
  }
};
var DataResultIterator = class {
  source;
  skip;
  groupFooters;
  isObject;
  constructor(source, skip4 = 0, groupFooters = false) {
    this.source = source;
    this.skip = skip4;
    this.groupFooters = groupFooters;
    this.source = this.source ? this.source : [];
    this.isObject = this.isGridDataResult(this.source);
  }
  isGridDataResult(source) {
    return source.total !== void 0 && source.data !== void 0;
  }
  get total() {
    return this.isObject ? this.source.total : this.source.length;
  }
  get data() {
    return this.isObject ? this.source.data : this.source;
  }
  map(fn) {
    return this.data.map(fn);
  }
  filter(fn) {
    return this.data.filter(fn);
  }
  reduce(fn, init) {
    return this.data.reduce(fn, init);
  }
  forEach(fn) {
    this.data.forEach(fn);
  }
  some(fn) {
    return this.data.some(fn);
  }
  [iterator]() {
    return getIterator(this.data, {
      dataIndex: this.skip,
      footers: this.groupFooters,
      groupIndex: this.skip
    });
  }
  toString() {
    return this.data.toString();
  }
};
var DataCollection = class {
  accessor;
  constructor(accessor) {
    this.accessor = accessor;
  }
  get total() {
    return this.accessor().total;
  }
  get length() {
    return this.accessor().data.length;
  }
  get first() {
    return this.accessor().data[0];
  }
  get last() {
    return this.accessor().data[this.length - 1];
  }
  at(index) {
    return itemAt(this.accessor().data, index);
  }
  map(fn) {
    return this.accessor().map(fn);
  }
  filter(fn) {
    return this.accessor().filter(fn);
  }
  reduce(fn, init) {
    return this.accessor().reduce(fn, init);
  }
  forEach(fn) {
    this.accessor().forEach(fn);
  }
  some(fn) {
    return this.accessor().some(fn);
  }
  [iterator]() {
    return this.accessor()[iterator]();
  }
  toString() {
    return this.accessor().toString();
  }
};
var PairSet = class _PairSet {
  /**
   * Symbol used internally to represent "no Y key" when storing single X keys.
   */
  static SINGLE_KEY_SYMBOL = Symbol("SINGLE_KEY");
  /**
   * Gets the total number of key entries (both single keys and key pairs).
   */
  get size() {
    return this.totalKeysCount;
  }
  /**
   * Holds a set of Y keys for each defined X key.
   * Each X key creates a map which holds a set of Y keys.
   * For single keys, the Y value is the SINGLE_KEY_SYMBOL.
   *
   * Map { 'foo' => Set { Symbol(SINGLE_KEY) } } // single key: {x: 'foo'}
   * Map { 'foo2' => Set { 'bar', 'baz' } } // pairs: {x: 'foo2', y: 'bar'}, {x: 'foo2', y: 'baz'}
   */
  keysX = /* @__PURE__ */ new Map();
  /**
   * Count each added or deleted key manually to avoid iterating over all items when calling `this.size`.
   */
  totalKeysCount = 0;
  constructor(items, keyXField, keyYField) {
    if (items && keyXField) {
      items.forEach((item) => {
        if (keyYField && item[keyYField] !== void 0) {
          this.add(item[keyXField], item[keyYField]);
        } else {
          this.addSingle(item[keyXField]);
        }
      });
    }
  }
  /**
   * Adds a single key entry.
   */
  addSingle(keyX) {
    if (!this.keysX.has(keyX)) {
      this.keysX.set(keyX, /* @__PURE__ */ new Set());
    }
    if (!this.hasSingle(keyX)) {
      this.keysX.get(keyX).add(_PairSet.SINGLE_KEY_SYMBOL);
      this.totalKeysCount += 1;
    }
  }
  /**
   * Adds a couple of items identified as a combination.
   */
  add(keyX, keyY) {
    if (!this.keysX.has(keyX)) {
      this.keysX.set(keyX, /* @__PURE__ */ new Set());
    }
    if (!this.has(keyX, keyY)) {
      this.keysX.get(keyX).add(keyY);
      this.totalKeysCount += 1;
    }
  }
  /**
   * Deletes a single key entry.
   */
  deleteSingle(keyX) {
    if (this.hasSingle(keyX)) {
      this.keysX.get(keyX).delete(_PairSet.SINGLE_KEY_SYMBOL);
      this.totalKeysCount -= 1;
      if (this.keysX.get(keyX).size === 0) {
        this.keysX.delete(keyX);
      }
    }
  }
  /**
   * Deletes a combination of a couple of items identified together.
   */
  delete(keyX, keyY) {
    if (this.has(keyX, keyY)) {
      this.keysX.get(keyX).delete(keyY);
      this.totalKeysCount -= 1;
      if (this.keysX.get(keyX).size === 0) {
        this.keysX.delete(keyX);
      }
    }
  }
  /**
   * Checks whether a single key is stored.
   */
  hasSingle(keyX) {
    return this.keysX.has(keyX) && this.keysX.get(keyX).has(_PairSet.SINGLE_KEY_SYMBOL);
  }
  /**
   * Checks whether the defined combination is stored.
   */
  has(keyX, keyY) {
    return this.keysX.has(keyX) && this.keysX.get(keyX).has(keyY);
  }
  /**
   * Checks whether any entry exists for the given X key (single or paired).
   */
  hasX(keyX) {
    return this.keysX.has(keyX) && this.keysX.get(keyX).size > 0;
  }
  /**
   * Gets all Y keys for a given X key, excluding single key entries.
   */
  getYKeys(keyX) {
    if (!this.keysX.has(keyX)) {
      return [];
    }
    const yKeys = Array.from(this.keysX.get(keyX));
    return yKeys.filter((yKey) => yKey !== _PairSet.SINGLE_KEY_SYMBOL);
  }
  /**
   * Clears all key combinations and single keys.
   */
  clear() {
    this.keysX.clear();
    this.totalKeysCount = 0;
  }
  /**
   * Converts the persisted data structure to an array of objects,
   * using the provided field names for the object props.
   * Single keys will only have the keyXField property.
   * Pair keys will have both keyXField and keyYField properties.
   */
  toArray(keyXField, keyYField) {
    return Array.from(this.keysX).reduce((pairs, pair) => {
      const [keyX, keysY] = pair;
      Array.from(keysY).forEach((keyY) => {
        if (keyY === _PairSet.SINGLE_KEY_SYMBOL) {
          pairs.push({
            [keyXField]: keyX
          });
        } else {
          const entry = {
            [keyXField]: keyX
          };
          if (keyYField) {
            entry[keyYField] = keyY;
          }
          pairs.push(entry);
        }
      });
      return pairs;
    }, []);
  }
};
var Selection = class _Selection {
  ctx;
  cd;
  /**
   * Stores the selected item keys.
   * @default []
   */
  selectedKeys = [];
  /**
   * Sets the starting row index for `Shift`+click range selection.
   *
   * @default 0
   */
  rangeSelectionStartRow;
  /**
   * Sets the starting column index for `Shift`+click range selection when cell selection is on.
   *
   * @default 0
   */
  rangeSelectionStartColumnIndex = 0;
  /**
   * Sets the item key to store in `selectedKeys`.
   * [See example](slug:grid_selection_persistence#using-data-item-field).
   */
  selectionKey;
  /**
   * Sets a function to get the column key for a data cell.
   *
   * The function must return a unique value for each column.
   * The Grid uses the column index as the default column key.
   */
  columnKey;
  /**
   * Emits when the `selectedKeys` collection changes.
   */
  selectedKeysChange = new EventEmitter();
  rowSelectionState = /* @__PURE__ */ new Set();
  cellSelectionState = new PairSet();
  /**
   * @hidden
   */
  get isCellSelectionMode() {
    return isPresent7(this.ctx.grid.selectable) && this.ctx.grid.selectable["cell"];
  }
  lastSelectionState;
  selectionChangeSubscription;
  constructor(ctx, cd) {
    this.ctx = ctx;
    this.cd = cd;
    this.init();
  }
  ngOnChanges(changes) {
    if (isPresent7(changes["selectedKeys"]) && this.lastSelectionState !== this.selectedKeys) {
      this.setState(this.selectedKeys);
    }
  }
  init() {
    if (!isPresent7(this.ctx.grid.rowSelected)) {
      this.ctx.grid.rowSelected = (row2) => this.rowSelectionState.has(this.getItemKey(row2));
    }
    if (!isPresent7(this.ctx.grid.isRowSelectable)) {
      this.ctx.grid.isRowSelectable = () => Boolean(this.ctx.grid.selectable);
    }
    if (!isPresent7(this.ctx.grid.cellSelected)) {
      this.ctx.grid.cellSelected = (row2, column, colIndex) => {
        const contender = this.getSelectionItem(row2, column, colIndex);
        return {
          selected: this.cellSelectionState.has(contender.itemKey, contender.columnKey),
          item: contender
        };
      };
    }
    this.selectionChangeSubscription = this.ctx.grid.selectionChange.subscribe(this.onSelectionChange.bind(this));
  }
  /**
   * @hidden
   */
  destroy() {
    this.selectionChangeSubscription.unsubscribe();
  }
  /**
   * @hidden
   */
  reset() {
    this.rowSelectionState.clear();
    this.cellSelectionState.clear();
  }
  /**
   * @hidden
   */
  getItemKey(row2) {
    if (this.selectionKey) {
      if (typeof this.selectionKey === "string") {
        return row2.dataItem[this.selectionKey];
      }
      if (typeof this.selectionKey === "function") {
        return this.selectionKey(row2);
      }
    }
    return row2.index;
  }
  /**
   * @hidden
   */
  stateToArray() {
    return this.isCellSelectionMode ? this.cellSelectionState.toArray("itemKey", "columnKey") : Array.from(this.rowSelectionState);
  }
  getSelectionItem(row2, col, colIndex) {
    const itemIdentifiers = {};
    itemIdentifiers.itemKey = this.getItemKey(row2);
    if (!isPresent7(col) && !isPresent7(colIndex)) {
      return itemIdentifiers;
    }
    if (this.columnKey) {
      if (typeof this.columnKey === "string") {
        itemIdentifiers.columnKey = row2.dataItem[this.columnKey];
      }
      if (typeof this.columnKey === "function") {
        itemIdentifiers.columnKey = this.columnKey(col, colIndex);
      }
    }
    return {
      itemKey: itemIdentifiers.itemKey,
      columnKey: itemIdentifiers.columnKey ? itemIdentifiers.columnKey : colIndex
    };
  }
  onSelectionChange(selection) {
    if (selection.selectedRows) {
      selection.deselectedRows.forEach((item) => {
        const itemKey = this.getItemKey(item);
        this.rowSelectionState.delete(itemKey);
      });
      if (this.ctx.grid.selectableSettings.mode === "single" && this.rowSelectionState.size > 0) {
        this.reset();
      }
      selection.selectedRows.forEach((item) => {
        const itemKey = this.getItemKey(item);
        this.rowSelectionState.add(itemKey);
      });
    } else {
      selection.deselectedCells.forEach(({
        itemKey,
        columnKey
      }) => {
        this.cellSelectionState.delete(itemKey, columnKey);
      });
      if (this.ctx.grid.selectableSettings.mode === "single" && this.cellSelectionState.size > 0) {
        this.reset();
      }
      selection.selectedCells.forEach(({
        itemKey,
        columnKey
      }) => {
        this.cellSelectionState.add(itemKey, columnKey);
      });
    }
    this.cd.markForCheck();
    this.notifyChange();
  }
  notifyChange() {
    this.lastSelectionState = this.stateToArray();
    this.selectedKeysChange.emit(this.lastSelectionState);
  }
  setState(selectedKeys) {
    this.reset();
    if (this.isCellSelectionMode) {
      this.cellSelectionState = new PairSet(selectedKeys, "itemKey", "columnKey");
    } else {
      this.rowSelectionState = new Set(selectedKeys);
    }
  }
  static ɵfac = function Selection_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _Selection)(ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _Selection,
    selectors: [["kendo-grid-selection-base"]],
    inputs: {
      selectedKeys: "selectedKeys",
      rangeSelectionStartRow: "rangeSelectionStartRow",
      rangeSelectionStartColumnIndex: "rangeSelectionStartColumnIndex",
      selectionKey: [0, "kendoGridSelectBy", "selectionKey"],
      columnKey: "columnKey"
    },
    outputs: {
      selectedKeysChange: "selectedKeysChange"
    },
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Selection, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line @angular-eslint/directive-selector
      selector: "kendo-grid-selection-base"
    }]
  }], () => [{
    type: ContextService
  }, {
    type: ChangeDetectorRef
  }], {
    selectedKeys: [{
      type: Input
    }],
    rangeSelectionStartRow: [{
      type: Input
    }],
    rangeSelectionStartColumnIndex: [{
      type: Input
    }],
    selectionKey: [{
      type: Input,
      args: ["kendoGridSelectBy"]
    }],
    columnKey: [{
      type: Input
    }],
    selectedKeysChange: [{
      type: Output
    }]
  });
})();
var set2 = (value2) => (pair) => pair.forEach((x) => x.style.height = value2);
var clearHeight = (pairs) => pairs.filter(([left2, right2]) => left2.style.height || right2.style.height).forEach(set2(""));
var zip2 = (arr1, arr2) => {
  const result = [];
  for (let idx4 = 0, len = arr1.length; idx4 < len; idx4++) {
    if (!arr2[idx4]) {
      break;
    }
    result.push([arr1[idx4], arr2[idx4]]);
  }
  return result;
};
var setHeight$1 = (heights) => (row2, idx4) => set2(`${heights[idx4] + 1}px`)(row2);
var getHeights = (rows) => rows.map(([left2, right2]) => {
  const height2 = left2.offsetHeight;
  const offsetHeight2 = right2.offsetHeight;
  if (height2 < offsetHeight2) {
    return offsetHeight2;
  }
  return height2;
});
var syncRowsHeight = (table1, table2) => {
  if (!isDocumentAvailable()) {
    return;
  }
  const activeElement = document.activeElement;
  const rows = zip2(table1.rows, table2.rows);
  clearHeight(rows);
  const heights = getHeights(rows);
  [table1, table2].forEach((x) => x.style.display = "none");
  rows.forEach(setHeight$1(heights));
  [table1, table2].forEach((x) => x.style.display = "");
  if (document.activeElement !== activeElement && (table1.contains(activeElement) || table2.contains(activeElement))) {
    activeElement.focus();
  }
};
var PDFExportEvent = class extends PreventableEvent7 {
  /**
   * @hidden
   */
  constructor() {
    super();
  }
};
var bootstrapToMedia = (media) => ({
  "xs": "(max-width: 576px)",
  "sm": "(min-width: 576px)",
  "md": "(min-width: 768px)",
  "lg": "(min-width: 992px)",
  "xl": "(min-width: 1200px)"
})[media] || media;
var browserMatchMedia = (media) => window.matchMedia(media).matches;
var ResponsiveService = class _ResponsiveService {
  /**
   * @hidden
   */
  matchMedia = browserMatchMedia;
  /**
   * @hidden
   */
  matchesMedia(media) {
    return !media || this.matchMedia(bootstrapToMedia(media));
  }
  static ɵfac = function ResponsiveService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ResponsiveService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ResponsiveService,
    factory: _ResponsiveService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ResponsiveService, [{
    type: Injectable
  }], null, null);
})();
var ToolbarTemplateDirective = class _ToolbarTemplateDirective {
  templateRef;
  _position = "top";
  /**
   * Sets the position of the toolbar. ([See example]({% slug toolbartemplate_grid %}#toc-setting-the-toolbar-position)).
   *
   * @default 'top'
   */
  set position(position2) {
    this._position = position2;
  }
  get position() {
    return this._position;
  }
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function ToolbarTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ToolbarTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ToolbarTemplateDirective,
    selectors: [["", "kendoGridToolbarTemplate", ""]],
    inputs: {
      position: "position"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ToolbarTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridToolbarTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Optional
    }]
  }], {
    position: [{
      type: Input,
      args: ["position"]
    }]
  });
})();
var NavigationMetadata = class {
  dataRows;
  headerRows;
  isVirtual;
  hasPager;
  hasDetailTemplate;
  gridElement;
  virtualColumns;
  columns;
  footerRow;
  isStacked;
  get maxLogicalRowIndex() {
    const dataRows = this.hasDetailTemplate ? this.dataRows * 2 : this.dataRows;
    return this.headerRows + dataRows + this.footerRow - 1;
  }
  constructor(dataRows, headerRows, isVirtual, hasPager, hasDetailTemplate, gridElement, virtualColumns, columns, footerRow, isStacked) {
    this.dataRows = dataRows;
    this.headerRows = headerRows;
    this.isVirtual = isVirtual;
    this.hasPager = hasPager;
    this.hasDetailTemplate = hasDetailTemplate;
    this.gridElement = gridElement;
    this.virtualColumns = virtualColumns;
    this.columns = columns;
    this.footerRow = footerRow;
    this.isStacked = isStacked;
  }
};
var ColumnVisibilityChangeEvent = class {
  /**
   * The columns whose visibility is changed.
   */
  columns;
  /**
   * @hidden
   */
  constructor(columns) {
    this.columns = columns;
  }
};
var ColumnLockedChangeEvent = class {
  /**
   * The columns whose locked state changes.
   */
  columns;
  /**
   * @hidden
   */
  constructor(columns) {
    this.columns = columns;
  }
};
var GROUP_CELL_WIDTH = 32;
var ColumnStickyChangeEvent = class {
  /**
   * The columns whose sticky state is changed.
   */
  columns;
  /**
   * @hidden
   */
  constructor(columns) {
    this.columns = columns;
  }
};
var isNextSibling = (dropTarget, dragTarget) => dropTarget === dragTarget.nextElementSibling;
var isPreviousSibling = (dropTarget, dragTarget) => dropTarget === dragTarget.previousElementSibling;
var isDifferentParent = (dropTarget, dragTarget) => dropTarget?.parentElement !== dragTarget?.parentElement;
function getOffset(element) {
  const {
    clientTop,
    clientLeft
  } = getDocument(element);
  const {
    pageYOffset,
    pageXOffset
  } = getWindow(element);
  const {
    top,
    left: left2
  } = element.getBoundingClientRect();
  return {
    top: top + pageYOffset - clientTop,
    left: left2 + pageXOffset - clientLeft
  };
}
var hintIcons = {
  forbidden: "cancel",
  before: "insert-middle",
  after: "insert-middle"
};
var hintSVGIcons = {
  forbidden: cancelIcon,
  before: insertMiddleIcon,
  after: insertMiddleIcon
};
var dropPosition = {
  forbidden: "forbidden",
  before: "before",
  after: "after"
};
var hintStyles = {
  zIndex: "20000",
  display: "flex",
  position: "fixed"
};
var hintClasses = ["k-drag-clue", "k-reorder-clue"];
var dropIndicatorStyles = {
  zIndex: "19000",
  position: "absolute"
};
var dropIndicatorClasses = ["k-drop-hint", "k-drop-hint-h"];
var getDefaultSelectors = (isStacked) => {
  return {
    handle: isStacked ? ".k-grid-stack-cell.k-drag-cell" : ".k-table-td.k-drag-cell",
    dragTarget: ".k-master-row",
    dropTarget: ".k-master-row"
  };
};
var getDocument = (element) => element?.ownerDocument.documentElement;
var getWindow = (element) => element?.ownerDocument.defaultView;
var RowReorderService = class _RowReorderService {
  renderer;
  hintElement = null;
  defaultSelectors = getDefaultSelectors;
  hintText = "";
  skip;
  dropIndicator;
  lastDropPosition = dropPosition.forbidden;
  dragTarget = null;
  dropTarget = null;
  offsetY;
  rowReorder = new EventEmitter();
  constructor(renderer) {
    this.renderer = renderer;
  }
  ngOnDestroy() {
    this.destroyDropIndicator();
    this.destroyHintElement();
  }
  press(ev) {
    this.dragTarget = ev.dragTarget;
    this.offsetY = ev.dragEvent.offsetY;
  }
  dragStart() {
    this.createDropIndicator();
  }
  drag(ev) {
    if (isPresent(ev.hintElement) && !isPresent(this.hintElement)) {
      this.hintElement = ev.hintElement;
      this.decorateHint();
    }
    const position2 = {
      x: ev.dragEvent.clientX,
      y: ev.dragEvent.clientY - this.offsetY
    };
    if (isPresent(this.hintElement)) {
      this.renderer.setStyle(this.hintElement, "left", `${position2.x}px`);
      this.renderer.setStyle(this.hintElement, "top", `${position2.y}px`);
    }
    this.positionDropIndicator(ev);
  }
  dragEnter(ev) {
    this.dropTarget = ev.dropTarget;
  }
  dragLeave() {
    this.dropTarget = null;
    this.hide();
  }
  dragEnd() {
    this.destroyDropIndicator();
    this.destroyHintElement();
    this.dragTarget = null;
    this.dropTarget = null;
    this.hintElement = null;
  }
  drop(ev) {
    this.destroyDropIndicator();
    this.destroyHintElement();
    const rowReorderArgs = this.rowReorderArgs(this.dragTarget, this.dropTarget, ev.dragData);
    this.rowReorder.emit(rowReorderArgs);
  }
  reorderRows(ev, collection) {
    if (this.lastDropPosition === dropPosition.forbidden) {
      return;
    }
    const {
      draggedRows,
      dropTargetRow
    } = ev;
    const draggedDataItem = draggedRows[0].dataItem;
    const dropTargetDataItem = dropTargetRow.dataItem;
    const draggedItemIndex = collection.indexOf(draggedDataItem);
    const dropTargetIndex = collection.indexOf(dropTargetDataItem);
    const idxToAdd = this.calculateIndexToAdd(draggedItemIndex, dropTargetIndex);
    collection.splice(draggedItemIndex, 1);
    collection.splice(idxToAdd, 0, draggedDataItem);
  }
  get hintIcon() {
    return hintIcons[this.lastDropPosition];
  }
  get hintSVGIcon() {
    return hintSVGIcons[this.lastDropPosition];
  }
  getDefaultHintText(columns, data) {
    let hintText = "";
    const columnFieldsArray = columns.toArray().filter((column) => !column.hidden && isPresent(column.field)).map((column) => column.field);
    const draggedDragRow = this.getDragRowPerElement(this.dragTarget, data);
    const draggedDataItem = draggedDragRow?.dataItem;
    isPresent(draggedDataItem) && columnFieldsArray.forEach((column) => {
      const columnValue = draggedDataItem[column];
      if (isPresent(columnValue)) {
        hintText += `${columnValue} `;
      }
    });
    return hintText.trim();
  }
  getDraggedRow(data) {
    return this.getDragRowPerElement(this.dragTarget, data);
  }
  /**
   * Triggers row reordering programmatically via keyboard shortcut.
   * @param dragRowIndex - The index of the row to move
   * @param dropRowIndex - The index of the target row
   * @param dropPosition - The position relative to the target row ('before' or 'after')
   * @param data - The data array
   */
  reorderViaKeyboard(dragRowIndex, dropRowIndex, dropPosition2, data) {
    if (dropPosition2 === "forbidden") {
      return;
    }
    const dragRow = this.createVirtualRowElement(dragRowIndex);
    const dropRow = this.createVirtualRowElement(dropRowIndex);
    this.lastDropPosition = dropPosition2;
    const rowReorderArgs = this.rowReorderArgs(dragRow, dropRow, data);
    this.rowReorder.emit(rowReorderArgs);
  }
  createVirtualRowElement(rowIndex) {
    const virtualElement = {
      getAttribute: (attr) => {
        if (attr === "data-kendo-grid-item-index") {
          return String(rowIndex);
        }
        return null;
      }
    };
    return virtualElement;
  }
  rowReorderArgs(dragRow, dropRow, data) {
    const dragRowData = this.getDragRowPerElement(dragRow, data);
    const dropRowData = this.getDragRowPerElement(dropRow, data);
    return {
      draggedRows: [dragRowData],
      dropTargetRow: dropRowData,
      dropPosition: this.lastDropPosition
    };
  }
  getDragRowPerElement(row2, data) {
    let rowIndex = row2?.getAttribute("data-kendo-grid-item-index");
    rowIndex = rowIndex ? parseInt(rowIndex, 10) : -1;
    const skip4 = this.skip || 0;
    const dataItem = rowIndex === -1 ? null : data[rowIndex - skip4];
    return {
      dataItem,
      rowIndex,
      element: row2
    };
  }
  createDropIndicator() {
    if (!isDocumentAvailable()) {
      return;
    }
    this.dropIndicator = document.createElement("div");
    this.decorateDropIndicator();
    this.dropIndicator.innerHTML = `
            <div class="k-drop-hint-start"></div>
            <div class="k-drop-hint-line"></div>
        `;
    document.body.appendChild(this.dropIndicator);
    this.hide();
  }
  destroyDropIndicator() {
    if (!isDocumentAvailable()) {
      return;
    }
    if (this.dropIndicator && this.dropIndicator.parentElement) {
      document.body.removeChild(this.dropIndicator);
      this.dropIndicator = null;
    }
  }
  destroyHintElement() {
    if (!isDocumentAvailable()) {
      return;
    }
    if (this.hintElement?.parentElement) {
      this.hintElement.parentElement.removeChild(this.hintElement);
      this.hintElement = null;
    }
  }
  decorateHint() {
    hintClasses.forEach((className) => this.renderer.addClass(this.hintElement, className));
    Object.keys(hintStyles).forEach((style2) => this.renderer.setStyle(this.hintElement, style2, hintStyles[style2]));
  }
  positionDropIndicator(ev) {
    this.lastDropPosition = this.getDropPosition(ev.dragEvent);
    this.updateDropIndicatorPosition();
  }
  calculateIndexToAdd(dragIndex, dropIndex) {
    if (dragIndex > dropIndex && this.lastDropPosition === dropPosition.after) {
      return dropIndex + 1;
    } else if (dragIndex > dropIndex && this.lastDropPosition === dropPosition.before) {
      return dropIndex;
    } else if (dragIndex < dropIndex && this.lastDropPosition === dropPosition.after) {
      return dropIndex;
    } else if (dragIndex < dropIndex && this.lastDropPosition === dropPosition.before) {
      return dropIndex - 1;
    }
  }
  decorateDropIndicator() {
    dropIndicatorClasses.forEach((className) => this.renderer.addClass(this.dropIndicator, className));
    Object.keys(dropIndicatorStyles).forEach((style2) => this.renderer.setStyle(this.dropIndicator, style2, dropIndicatorStyles[style2]));
  }
  getDropPosition(e) {
    if (this.dropTarget === this.dragTarget || !isPresent(this.dropTarget)) {
      return dropPosition.forbidden;
    }
    if (isDifferentParent(this.dropTarget, this.dragTarget)) {
      return dropPosition.forbidden;
    }
    const itemViewPortCoords = this.dropTarget.getBoundingClientRect();
    const itemDivisionsCount = 2;
    const itemDivisionHeight = itemViewPortCoords.height / itemDivisionsCount;
    const pointerPosition = e.clientY;
    const itemTop = itemViewPortCoords.top;
    let currentDropPosition = null;
    if (pointerPosition < itemTop + itemDivisionHeight) {
      currentDropPosition = dropPosition.before;
    } else if (pointerPosition >= itemTop + itemViewPortCoords.height - itemDivisionHeight) {
      currentDropPosition = dropPosition.after;
    }
    if (currentDropPosition === dropPosition.before && isNextSibling(this.dropTarget, this.dragTarget)) {
      currentDropPosition = dropPosition.forbidden;
    } else if (currentDropPosition === dropPosition.after && isPreviousSibling(this.dropTarget, this.dragTarget)) {
      currentDropPosition = dropPosition.forbidden;
    }
    return currentDropPosition;
  }
  updateDropIndicatorPosition() {
    if (this.shouldHideDropIndicator() || !this.dropTarget) {
      this.hide();
      return;
    }
    this.show();
    const destinationItemOffset = getOffset(this.dropTarget);
    let indicatorOffsetTop = destinationItemOffset.top;
    const indicatorOffsetLeft = destinationItemOffset.left + this.dropIndicator.offsetWidth / 2;
    if (this.lastDropPosition === dropPosition.after) {
      indicatorOffsetTop += this.dropTarget.offsetHeight;
    }
    this.renderer.setStyle(this.dropIndicator, "left", `${indicatorOffsetLeft}px`);
    this.renderer.setStyle(this.dropIndicator, "top", `${indicatorOffsetTop}px`);
  }
  shouldHideDropIndicator() {
    return this.lastDropPosition === dropPosition.forbidden;
  }
  hide() {
    if (isPresent(this.dropIndicator)) {
      this.dropIndicator.style.display = "none";
    }
  }
  show() {
    if (isPresent(this.dropIndicator)) {
      this.dropIndicator.style.display = "";
    }
  }
  static ɵfac = function RowReorderService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RowReorderService)(ɵɵinject(Renderer2));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _RowReorderService,
    factory: _RowReorderService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RowReorderService, [{
    type: Injectable
  }], () => [{
    type: Renderer2
  }], {
    rowReorder: [{
      type: Output
    }]
  });
})();
var StatusBarTemplateDirective = class _StatusBarTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function StatusBarTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _StatusBarTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _StatusBarTemplateDirective,
    selectors: [["", "kendoGridStatusBarTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StatusBarTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridStatusBarTemplate]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var ClipboardService = class _ClipboardService {
  contextService;
  targetColField;
  targetRowIndex;
  constructor(contextService) {
    this.contextService = contextService;
  }
  createClipboardData(data, columns, options) {
    let result = {
      gridItems: [],
      dataString: ""
    };
    const fieldCols = columns.flatMap((c) => c instanceof ColumnComponent2 && isPresent(c.field) ? [c] : []);
    const clipboardData = {
      items: [],
      dataStrings: []
    };
    const colFields = fieldCols.map((c) => c.field);
    if (options.wholeRow) {
      this.targetColField = fieldCols[0]?.field;
      this.targetRowIndex = data[0].dataRowIndex;
      data.forEach((item) => {
        clipboardData.items.push({
          dataItem: __spreadValues({}, item.dataItem),
          fields: colFields
        });
        clipboardData.dataStrings.push(this.itemToString(item.dataItem, fieldCols));
      });
      result = {
        gridItems: options.operationType === "cut" ? clipboardData.items.map((item) => {
          item.fields.forEach((field) => item.dataItem[field] = null);
          return item;
        }) : [...clipboardData.items],
        dataString: options.copyHeaders ? this.addHeaders(clipboardData.dataStrings.join(`\r
`), fieldCols) : clipboardData.dataStrings.join(`
`)
      };
    } else {
      if (options.target === "selection") {
        const {
          tabular,
          groups
        } = this.groupSelection();
        const selectionDirective = this.contextService.grid.selectionDirective;
        const colIdentifier = selectionDirective.columnKey;
        if (tabular) {
          const selectionKeys = groups[0].items.map((item) => item.columnKey);
          const selectedFieldCols = columns.flatMap((c, i) => c instanceof ColumnComponent2 && c.field && isPresent(selectionKeys.find((k) => typeof colIdentifier === "function" ? k === colIdentifier(c, i) : k === i)) ? [c] : []);
          const selectedColFields = selectedFieldCols.map((c) => c.field);
          this.targetColField = selectedColFields[0];
          result.dataString = data.flatMap((item) => {
            const itemString = this.itemToString(item.dataItem, selectedFieldCols);
            const existingItem = isPresent(itemString);
            if (!isPresent(this.targetRowIndex) && isPresent(itemString)) {
              this.targetRowIndex = item.dataRowIndex;
            }
            if (options.operationType === "cut") {
              selectedColFields.forEach((f) => item.dataItem[f] = null);
            }
            result.gridItems.push({
              dataItem: item.dataItem,
              fields: selectedColFields
            });
            return existingItem ? [itemString] : [];
          }).join(`\r
`);
          if (options.copyHeaders) {
            result.dataString = this.addHeaders(result.dataString, selectedFieldCols);
          }
        } else {
          const rowIdentifier = selectionDirective.selectionKey;
          result.dataString = data.flatMap((item) => {
            const key = rowIdentifier ? typeof rowIdentifier === "string" ? item.dataItem[rowIdentifier] : rowIdentifier({
              index: item.dataRowIndex,
              dataItem: item.dataItem
            }) : item.dataRowIndex;
            const selectionKeys = groups.find((gr) => gr.value === key).items.map((item2) => item2.columnKey);
            const selectedFieldCols = columns.flatMap((c, i) => c instanceof ColumnComponent2 && c.field && isPresent(selectionKeys.find((k) => typeof colIdentifier === "function" ? k === colIdentifier(c, i) : k === i)) ? [c] : []);
            const selectedColFields = selectedFieldCols.map((c) => c.field);
            if (!this.targetColField) {
              this.targetColField = selectedColFields[0];
            }
            const itemString = this.itemToString(item.dataItem, selectedFieldCols);
            const existingItem = isPresent(itemString);
            if (!isPresent(this.targetRowIndex) && existingItem) {
              this.targetRowIndex = item.dataRowIndex;
            }
            if (existingItem) {
              if (options.operationType === "cut") {
                selectedColFields.forEach((f) => item.dataItem[f] = null);
              }
              result.gridItems.push({
                dataItem: item.dataItem,
                fields: selectedColFields
              });
            }
            return existingItem ? options.copyHeaders ? [this.addHeaders(itemString, selectedFieldCols)] : [itemString] : [];
          }).join(`\r
`);
        }
      } else {
        const item = data[0];
        const col = columns[item.colIndex];
        const colField = col.field;
        const title = col.title;
        const copiedData = item.dataItem[colField];
        this.targetRowIndex = item.dataRowIndex;
        this.targetColField = colField;
        if (options.operationType === "cut" && colField) {
          item.dataItem[colField] = null;
        }
        result = {
          gridItems: [{
            dataItem: item.dataItem,
            fields: colField ? [colField] : []
          }],
          dataString: options.copyHeaders ? [title || colField, copiedData].join(`\r
`) : colField ? copiedData : ``
        };
      }
    }
    return result;
  }
  getGridData(data, columns, targetType, targetRowIndex, options) {
    const separator = data.includes(`\r
`) ? `\r
` : data.includes(`
`) ? `
` : null;
    const dataRows = separator ? data.split(separator).filter((rowData) => rowData.length) : [data];
    this.targetRowIndex = targetRowIndex;
    if (targetType === "activeCell") {
      if (options.wholeRow) {
        this.targetColField = columns.find((c) => c instanceof ColumnComponent2 && c.field)?.field;
      } else {
        const activeCellIndex = this.contextService.grid.activeCell.colIndex;
        for (let i = 0; i < columns.length; i++) {
          const col = columns[i];
          if (col instanceof ColumnComponent2 && col.field && i >= activeCellIndex) {
            this.targetColField = col.field;
            break;
          }
        }
      }
    } else {
      if (options.wholeRow || !options.isCellSelection) {
        this.targetColField = columns.filter((c) => c instanceof ColumnComponent2 && c.field)[0]["field"];
      } else {
        const {
          groups
        } = this.groupSelection();
        const selectionDirective = this.contextService.grid.selectionDirective;
        const colIdentifier = selectionDirective.columnKey;
        const visibleCols = columns.filter((c) => c.isVisible);
        const selectionKeys = groups[0].items.map((item) => item.columnKey);
        const selectedFieldCols = visibleCols.flatMap((c, i) => c instanceof ColumnComponent2 && c.field && isPresent(selectionKeys.find((k) => typeof colIdentifier === "function" ? k === colIdentifier(c, i) : k === i)) ? [c] : []);
        const selectedColFields = selectedFieldCols.map((c) => c.field);
        this.targetColField = selectedColFields[0];
      }
    }
    const items = dataRows.map((rowString) => {
      const cells = rowString.includes(`	`) ? rowString.split(`	`) : [rowString];
      const colFields = columns.flatMap((c) => c instanceof ColumnComponent2 && c.field ? [c.field] : []);
      const targetColFieldIndex = colFields.indexOf(this.targetColField);
      const affectedFields = colFields.slice(targetColFieldIndex, targetColFieldIndex + cells.length);
      const item = {};
      colFields.slice(targetColFieldIndex, targetColFieldIndex + cells.length).forEach((colField, index) => item[colField] = cells[index]);
      return {
        dataItem: item,
        fields: affectedFields
      };
    });
    return items;
  }
  itemToString = (item, cols) => {
    if (!cols.length) {
      return null;
    }
    return cols.map((col) => item[col.field]).join(`	`);
  };
  groupSelection() {
    const selection = this.contextService.grid.selection;
    const groups = groupBy(selection, [{
      field: "itemKey"
    }]).map((gr) => {
      gr.items.sort((a, b) => a.columnKey - b.columnKey);
      return gr;
    });
    for (let i = 1; i < groups.length; i++) {
      if (!this.areEqual(groups[i].items, groups[i - 1].items)) {
        return {
          tabular: false,
          groups
        };
      }
    }
    return {
      tabular: true,
      groups
    };
  }
  areEqual(arr1, arr2) {
    if (arr1.length !== arr2.length) {
      return false;
    }
    for (let i = 0; i < arr1.length; i++) {
      if (arr1[i].columnKey !== arr2[i].columnKey) {
        return false;
      }
    }
    return true;
  }
  addHeaders(initialData, cols) {
    const headersRowData = cols.map((c) => c.title || c.field).join(`	`);
    return `${headersRowData}\r
${initialData}`;
  }
  static ɵfac = function ClipboardService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ClipboardService)(ɵɵinject(ContextService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ClipboardService,
    factory: _ClipboardService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClipboardService, [{
    type: Injectable
  }], () => [{
    type: ContextService
  }], null);
})();
var StatusBarComponent = class _StatusBarComponent {
  aggregateService;
  hostClasses = true;
  get isStatusBarTemplate() {
    return this.statusBarTemplate ? "" : "none";
  }
  hostAriaLive = "polite";
  statusBarTemplate;
  constructor(aggregateService) {
    this.aggregateService = aggregateService;
  }
  ngOnInit() {
    this.aggregateService.init();
  }
  get aggregates() {
    return this.aggregateService.aggregates;
  }
  static ɵfac = function StatusBarComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _StatusBarComponent)(ɵɵdirectiveInject(CellSelectionAggregateService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _StatusBarComponent,
    selectors: [["kendo-grid-status-bar"]],
    hostVars: 7,
    hostBindings: function StatusBarComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("aria-live", ctx.hostAriaLive);
        ɵɵstyleProp("display", ctx.isStatusBarTemplate);
        ɵɵclassProp("k-selection-aggregates", ctx.hostClasses)("k-grid-selection-aggregates", ctx.hostClasses);
      }
    },
    inputs: {
      statusBarTemplate: "statusBarTemplate"
    },
    decls: 1,
    vars: 1,
    consts: [[3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
    template: function StatusBarComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵconditionalCreate(0, StatusBarComponent_Conditional_0_Template, 1, 4, null, 0);
      }
      if (rf & 2) {
        ɵɵconditional(ctx.statusBarTemplate ? 0 : -1);
      }
    },
    dependencies: [NgTemplateOutlet],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StatusBarComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-status-bar",
      template: `
        @if (statusBarTemplate) {
          <ng-template
            [ngTemplateOutlet]="statusBarTemplate?.templateRef"
            [ngTemplateOutletContext]="{ aggregates: aggregates }">
          </ng-template>
        }
        `,
      standalone: true,
      imports: [NgTemplateOutlet]
    }]
  }], () => [{
    type: CellSelectionAggregateService
  }], {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-selection-aggregates"]
    }, {
      type: HostBinding,
      args: ["class.k-grid-selection-aggregates"]
    }],
    isStatusBarTemplate: [{
      type: HostBinding,
      args: ["style.display"]
    }],
    hostAriaLive: [{
      type: HostBinding,
      args: ["attr.aria-live"]
    }],
    statusBarTemplate: [{
      type: Input
    }]
  });
})();
var createElement = () => {
  if (!isDocumentAvailable()) {
    return;
  }
  const marquee = document.createElement("div");
  marquee.className = "k-marquee";
  const marqueeColor = document.createElement("div");
  marqueeColor.className = "k-marquee-color";
  marquee.appendChild(marqueeColor);
  return marquee;
};
var POINTER_OFFSET = 2;
var MINIMAL_DRAG_DISTANCE = 5;
var offsets = {
  topLeft: {
    x: POINTER_OFFSET,
    y: POINTER_OFFSET
  },
  topRight: {
    x: -POINTER_OFFSET,
    y: POINTER_OFFSET
  },
  bottomLeft: {
    x: POINTER_OFFSET,
    y: -POINTER_OFFSET
  },
  bottomRight: {
    x: -POINTER_OFFSET,
    y: -POINTER_OFFSET
  }
};
var GridMarqueeDirective = class _GridMarqueeDirective {
  draggable;
  selection;
  cellSelection;
  domEvents;
  host;
  renderer;
  // possibly add snap
  pressArgs;
  marqueeElement;
  pressTarget;
  subscriptions;
  selectionStarted = false;
  dragEndSubscription;
  constructor(draggable, selection, cellSelection, domEvents, host, renderer) {
    this.draggable = draggable;
    this.selection = selection;
    this.cellSelection = cellSelection;
    this.domEvents = domEvents;
    this.host = host;
    this.renderer = renderer;
  }
  ngOnInit() {
    this.subscriptions = this.draggable.kendoPress.subscribe(this.start.bind(this));
    this.subscriptions.add(this.draggable.kendoDrag.subscribe(this.moveMarquee.bind(this)));
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
    this.clean();
  }
  start(args) {
    const isInvalidTarget = args.originalEvent.target.matches(".k-grid-content, .k-grid-content-locked, .k-grid-aria-root, .k-checkbox");
    const isRowReorderColumn2 = isPresent(args.originalEvent.target.closest(".k-drag-cell"));
    if (isInvalidTarget || isRowReorderColumn2) {
      this.pressArgs = null;
      return;
    }
    this.pressArgs = args;
    this.pressTarget = null;
  }
  moveMarquee(args) {
    if (!this.pressTarget) {
      this.pressTarget = this.cellSelection.active ? this.cellSelection.mouseDownEventArgs : this.selection.mouseDownEventArgs;
    }
    const press = this.pressArgs;
    if (!press) {
      return;
    }
    if (!this.selectionStarted) {
      const distance = Math.sqrt((args.pageX - press.pageX) ** 2 + (args.pageY - press.pageY) ** 2);
      if (distance > MINIMAL_DRAG_DISTANCE) {
        this.selectionStarted = true;
        this.renderer.addClass(this.host.nativeElement, "user-select-none");
        this.renderer.setStyle(this.host.nativeElement, "user-select", "none");
        this.dragEndSubscription = merge(this.domEvents.cellMouseup.pipe(take(1)), this.draggable.kendoRelease.pipe(delay(1), take(1))).subscribe(this.endSelection.bind(this));
      } else {
        return;
      }
    }
    this.initMarquee();
    const element = this.marqueeElement;
    const marqueeQuadrant = this.getMarqueeQuadrant(args.pageX, args.pageY, press.pageX, press.pageY);
    let left2 = Math.min(args.pageX, press.pageX);
    let top = Math.min(args.pageY, press.pageY);
    const width2 = Math.abs(args.pageX - press.pageX);
    const height2 = Math.abs(args.pageY - press.pageY);
    if (marqueeQuadrant) {
      left2 += offsets[marqueeQuadrant].x;
      top += offsets[marqueeQuadrant].y;
    }
    element.style.left = `${left2}px`;
    element.style.top = `${top}px`;
    element.style.width = `${width2}px`;
    element.style.height = `${height2}px`;
  }
  endSelection(args) {
    if (args.type === "mouseup" || args.type === "touchend") {
      const modifier = args.originalEvent.ctrlKey || args.originalEvent.metaKey;
      const preserveCurrentSelection = modifier && (isMultipleRangesEnabled(this.selection.settings) || isMultipleRangesEnabled(this.cellSelection.settings));
      if (this.cellSelection.active) {
        this.cellSelection.dragging = true;
        this.cellSelection.changes.emit(this.cellSelection.selectRange(this.pressTarget.rowIndex, this.pressTarget.column.leafIndex, args.rowIndex, args.column.leafIndex, preserveCurrentSelection));
      } else if (this.selection.active) {
        this.selection.dragging = true;
        this.selection.changes.emit(this.selection.selectRange(this.pressTarget.rowIndex, args.rowIndex, preserveCurrentSelection));
      }
    }
    this.clean();
  }
  clean() {
    if (this.marqueeElement) {
      document.body.removeChild(this.marqueeElement);
      this.marqueeElement = null;
    }
    if (this.dragEndSubscription) {
      this.dragEndSubscription.unsubscribe();
    }
    this.renderer.removeClass(this.host.nativeElement, "user-select-none");
    this.renderer.removeStyle(this.host.nativeElement, "user-select");
    this.dragEndSubscription = null;
    this.pressTarget = null;
    this.pressArgs = null;
    this.selectionStarted = false;
    this.cellSelection.active ? this.cellSelection.dragging = false : this.selection.dragging = false;
  }
  initMarquee() {
    if (!isDocumentAvailable()) {
      return;
    }
    if (!this.marqueeElement) {
      this.marqueeElement = createElement();
      document.body.appendChild(this.marqueeElement);
    }
  }
  getMarqueeQuadrant(pointerX, pointerY, startX, startY) {
    const leftHalf = pointerX < startX;
    const rightHalf = pointerX > startX;
    const topHalf = pointerY < startY;
    const bottomHalf = pointerY > startY;
    if (leftHalf && topHalf) {
      return "topLeft";
    }
    if (leftHalf && bottomHalf) {
      return "bottomLeft";
    }
    if (rightHalf && topHalf) {
      return "topRight";
    }
    if (rightHalf && bottomHalf) {
      return "bottomRight";
    }
    return null;
  }
  static ɵfac = function GridMarqueeDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _GridMarqueeDirective)(ɵɵdirectiveInject(DraggableDirective), ɵɵdirectiveInject(SelectionService2), ɵɵdirectiveInject(CellSelectionService), ɵɵdirectiveInject(DomEventsService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _GridMarqueeDirective,
    selectors: [["", "kendoGridSelectionMarquee", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GridMarqueeDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridSelectionMarquee]",
      standalone: true
    }]
  }], () => [{
    type: DraggableDirective
  }, {
    type: SelectionService2
  }, {
    type: CellSelectionService
  }, {
    type: DomEventsService
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }], null);
})();
var RowHeightService2 = class {
  total;
  offsets = [];
  heights = [];
  constructor(total = 0, rowHeight) {
    this.total = total;
    let agg = 0;
    for (let idx4 = 0; idx4 < total; idx4++) {
      this.offsets.push(agg);
      agg += rowHeight;
      this.heights.push(rowHeight);
    }
  }
  height(rowIndex) {
    return this.heights[rowIndex];
  }
  index(position2) {
    for (let i = 0; i < this.offsets.length; i++) {
      if (position2 === this.offsets[i]) {
        return i;
      }
      if (position2 < this.offsets[i]) {
        return i - 1;
      }
    }
    return this.total - 1;
  }
  offset(rowIndex) {
    return this.offsets[rowIndex];
  }
  totalHeight() {
    if (!this.offsets.length) {
      return 0;
    }
    const lastOffset = this.offsets[this.offsets.length - 1];
    const lastHeight = this.heights[this.heights.length - 1];
    return lastOffset + lastHeight;
  }
  update(startIndex, rowHeights) {
    let agg = this.offsets[startIndex];
    for (let i = startIndex; i < this.heights.length; i++) {
      this.offsets[i] = agg;
      const currHeight = rowHeights[i - startIndex] || this.heights[i];
      agg += currHeight;
      this.heights[i] = currHeight;
    }
  }
};
var ScrollAction2 = class {
  offset;
  changeVirtualData;
  constructor(offset3, changeVirtualData) {
    this.offset = offset3;
    this.changeVirtualData = changeVirtualData;
  }
};
var PageAction2 = class {
  skip;
  take;
  constructor(skip4, take4) {
    this.skip = skip4;
    this.take = take4;
  }
};
var ScrollBottomAction = class {
};
var SCROLL_BOTTOM_THRESHOLD = 2;
var ScrollerService2 = class {
  scrollObservable;
  ctx;
  total = 0;
  rowHeightService;
  table = null;
  lockedTable = null;
  tableBody = null;
  container = null;
  scrollHeightContainer = null;
  scrollableVirtual = false;
  tableTransformOffset = 0;
  virtualSkip = 0;
  virtualPageSize = 0;
  firstToLoad = 0;
  lastLoaded = 0;
  scrollSyncing = false;
  scrollSubscription;
  subscription;
  lastScrollTop = 0;
  firstLoaded = 0;
  expandedRows = {};
  take;
  constructor(scrollObservable, ctx) {
    this.scrollObservable = scrollObservable;
    this.ctx = ctx;
  }
  create(rowHeightService, skip4, take4, total) {
    this.rowHeightService = rowHeightService;
    this.firstLoaded = skip4;
    this.lastLoaded = skip4 + take4;
    this.take = take4;
    this.total = total;
    this.lastScrollTop = 0;
    const offset3 = this.rowHeightService.offset(skip4);
    const subject = new BehaviorSubject(new ScrollAction2(offset3, this.scrollableVirtual && (Boolean(this.ctx.grid?.pageable) || Boolean(this.ctx.grid?.group?.length))));
    this.subscription = Observable.create((observer) => {
      this.unsubscribe();
      this.scrollSubscription = this.scrollObservable.subscribe((x) => this.onScroll(x, observer));
    }).subscribe((x) => subject.next(x));
    return subject;
  }
  reset(skipScroll = false) {
    if (!skipScroll) {
      this.firstToLoad = 0;
      this.firstLoaded = 0;
      this.lastLoaded = 0;
      this.virtualSkip = 0;
    }
    this.rowHeightService = void 0;
    if (skipScroll) {
      this.scrollSyncing = true;
    }
    if (!skipScroll && this.container && this.container.scrollTop !== 0) {
      this.scrollSyncing = true;
      this.container.scrollTop = 0;
      this.lastScrollTop = 0;
      this.translate(0, true);
      this.tableTransformOffset = 0;
    }
  }
  update(skipAdjust = false) {
    const itemHeights = this.getItemHeights();
    if (this.firstLoaded > this.firstToLoad) {
      const count2 = Math.min(this.firstLoaded - this.firstToLoad, this.take);
      const newItemsHeight = this.getTotalHeight(count2, itemHeights);
      const newItemsExpectedHeight = this.getExpectedTotalHeight(count2);
      const diff = newItemsHeight - newItemsExpectedHeight;
      if (!skipAdjust && diff !== 0) {
        this.adjustScroll(diff);
      }
    }
    this.rowHeightService?.update(this.firstToLoad, itemHeights);
    this.scrollHeightContainer && this.setScrollHeightContainerHeight();
    this.firstLoaded = this.firstToLoad;
    this.lastLoaded = this.firstLoaded + itemHeights.length - 1;
  }
  destroy() {
    this.unsubscribe();
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
  }
  onScroll({
    scrollTop,
    offsetHeight,
    scrollHeight,
    clientHeight
  }, observer) {
    if (this.scrollSyncing) {
      this.scrollSyncing = false;
      return;
    }
    if (!isDocumentAvailable() || this.lastScrollTop === scrollTop) {
      return;
    }
    const up = this.lastScrollTop >= scrollTop;
    const down = !up;
    this.lastScrollTop = scrollTop;
    let firstItemIndex = this.rowHeightService.index(scrollTop);
    const lastItemIndex = this.rowHeightService.index(scrollTop + offsetHeight);
    const overflow = Math.max(firstItemIndex + (this.virtualPageSize || this.take) - this.total, 0);
    firstItemIndex = Math.max(firstItemIndex - overflow, 0);
    if (down) {
      const atBottom = scrollHeight - clientHeight - scrollTop < SCROLL_BOTTOM_THRESHOLD;
      if (atBottom) {
        observer.next(new ScrollBottomAction());
      }
    }
    if (!this.scrollableVirtual) {
      return;
    }
    if (down && lastItemIndex >= this.lastLoaded && this.lastLoaded < this.total - 1) {
      this.firstToLoad = firstItemIndex;
      this.loadPage(observer);
    } else if (up && firstItemIndex < this.firstLoaded) {
      const nonVisibleBuffer = Math.max(Math.floor((this.virtualPageSize || this.take) * 0.3) - overflow, 0);
      this.firstToLoad = Math.max(firstItemIndex - nonVisibleBuffer, 0);
      this.loadPage(observer);
    }
  }
  loadPage(observer) {
    if (!this.rowHeightService) {
      return;
    }
    this.translate(this.rowHeightService.offset(this.firstToLoad));
    observer.next(new ScrollAction2(this.rowHeightService.offset(this.firstToLoad)));
    this.virtualPageChange(this.firstToLoad, observer);
  }
  unsubscribe() {
    if (this.scrollSubscription) {
      this.scrollSubscription.unsubscribe();
      this.scrollSubscription = void 0;
    }
  }
  translate(dY, forceSet) {
    if (this.scrollableVirtual && this.table) {
      if (forceSet) {
        this.table.style.transform = "translateY(" + dY + "px)";
        if (this.lockedTable) {
          this.lockedTable.style.transform = "translateY(" + dY + "px)";
        }
      } else {
        this.tableTransformOffset = dY;
      }
    }
  }
  adjustScroll(scrollOffset, initialAdjust = false) {
    if (Number.isNaN(scrollOffset)) {
      return;
    }
    this.scrollSyncing = true;
    if (this.container) {
      if (initialAdjust) {
        this.container.scrollTop = scrollOffset;
        this.translate(scrollOffset, true);
        this.tableTransformOffset = scrollOffset;
        this.firstToLoad = this.rowHeightService.index(scrollOffset);
      } else {
        this.container.scrollTop += scrollOffset;
      }
    }
  }
  isExpanded(rowIndex) {
    return this.expandedRows[rowIndex] || false;
  }
  resetVirtualSkip = () => {
    if (this.scrollableVirtual && this.virtualSkip) {
      this.virtualSkip = 0;
    }
  };
  setScrollHeightContainerHeight() {
    if (this.scrollableVirtual) {
      let containerHeight = this.rowHeightService?.totalHeight() || 0;
      containerHeight = isFirefox ? Math.min(firefoxMaxHeight, containerHeight) : containerHeight;
      this.scrollHeightContainer.style.height = containerHeight + "px";
    } else {
      this.scrollHeightContainer.style.height = "0";
    }
  }
  getItemHeights() {
    const result = [];
    if (this.tableBody) {
      Array.from(this.tableBody.children).forEach((item, index) => {
        const itemHeight = item.getBoundingClientRect().height;
        if (item.classList.contains("k-detail-row")) {
          result[result.length - 1] += itemHeight;
          this.expandedRows[index] = true;
        } else {
          result.push(itemHeight);
        }
      });
    }
    return result;
  }
  getTotalHeight(count2, itemHeights) {
    return itemHeights.slice(0, count2).reduce((sum, current) => sum + current, 0);
  }
  getExpectedTotalHeight(count2) {
    const service = this.rowHeightService;
    if (!service) {
      return 0;
    }
    const lastItemIndex = this.firstToLoad + (count2 - 1);
    return service.offset(lastItemIndex) + service.height(lastItemIndex) - service.offset(this.firstToLoad);
  }
  virtualPageChange = (skip4, observer) => {
    if (this.ctx.grid.pageable || this.ctx.grid.group?.length) {
      this.virtualSkip = skip4;
      observer.next(new ScrollAction2(this.rowHeightService?.offset(skip4) || 0, true));
    } else if (skip4 !== this.ctx.grid.skip) {
      observer.next(new PageAction2(Math.max(0, skip4), this.take));
    }
  };
};
var columnsToResize = ({
  columns
}) => Math.max(1, resizableColumns(columns).filter((c) => !c.isColumnGroup).length);
var row = (selector) => (element) => element.querySelector(selector);
var headerRow = (index) => (element) => element.querySelectorAll("thead>tr")[index];
var cell = (index, selector = "td") => (element) => element.querySelectorAll(`${selector}:not(.k-group-cell):not(.k-hierarchy-cell)`)[index];
var offsetWidth = (element) => element.offsetWidth;
var pipe = (...fns) => (data) => fns.reduce((state2, fn) => state2 ? fn(state2) : 0, data);
var TableDirective = class _TableDirective {
  element;
  renderer;
  service;
  zone;
  cdr;
  ctx;
  locked = false;
  virtualColumns;
  get minWidth() {
    return this.firstResize ? 0 : null;
  }
  firstResize = false;
  subscription;
  autoFitSubscription;
  constructor(element, renderer, service, zone, cdr, ctx) {
    this.element = element;
    this.renderer = renderer;
    this.service = service;
    this.zone = zone;
    this.cdr = cdr;
    this.ctx = ctx;
  }
  ngOnInit() {
    const obs = this.service.changes.pipe(filter((e) => this.locked === e.locked));
    this.subscription = obs.pipe(filter((e) => e.type === "start"), tap(this.initState.bind(this)), map(columnsToResize), switchMap((take4) => obs.pipe(filter((e) => e.type === "resizeTable"), map((e) => e.delta), bufferCount(take4)))).subscribe(this.resize.bind(this));
    this.autoFitSubscription = this.service.registerTable({
      autoFit: this.autoFitObservable.bind(this),
      locked: this.locked
    });
  }
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
    if (this.autoFitSubscription) {
      this.autoFitSubscription();
      this.autoFitSubscription = null;
    }
  }
  initState() {
    this.firstResize = true;
    const constrainedWithVirtualColumns = this.ctx.grid?.resizable === "constrained" && this.virtualColumns;
    if (!this.virtualColumns || this.locked || constrainedWithVirtualColumns) {
      this.service.originalWidth = offsetWidth(this.element.nativeElement);
    }
  }
  resize(deltas) {
    const constrainedModeNoShift = this.ctx.grid?.resizable === "constrained" && !this.service.isShiftPressed;
    const unconstrainedModeShift = (this.ctx.grid?.resizable === true || this.ctx.grid?.resizable === "unconstrained") && this.service.isShiftPressed;
    const isConstrainedMode = constrainedModeNoShift || unconstrainedModeShift;
    if (isConstrainedMode && !this.service.autoFitResize) {
      this.renderer.setStyle(this.element.nativeElement, "width", this.service.originalWidth + "px");
    } else if (!this.virtualColumns || this.locked) {
      const delta = deltas.reduce((sum, item) => sum + item, 0);
      const width2 = this.service.originalWidth + delta;
      this.renderer.setStyle(this.element.nativeElement, "width", width2 + "px");
    }
    this.cdr.detectChanges();
  }
  autoFitObservable(columnInfo) {
    return Observable.create((observer) => {
      this.zone.runOutsideAngular(() => {
        this.renderer.addClass(this.element.nativeElement, "k-autofitting");
        this.cdr.detectChanges();
        const widths = columnInfo.map(this.measureColumn.bind(this));
        this.renderer.removeClass(this.element.nativeElement, "k-autofitting");
        observer.next(widths);
      });
    });
  }
  measureColumn(info) {
    const dom = this.element.nativeElement;
    const header = pipe(headerRow(info.level), cell(info.headerIndex, "th"), offsetWidth)(dom);
    let data = 0;
    if (!info.isParentSpan || info.isParentSpan && info.isLastInSpan) {
      data = pipe(row("tbody>tr:not(.k-grouping-row):not(.k-grid-norecords)"), cell(info.index), offsetWidth)(dom);
    }
    const footer = pipe(row("tfoot>tr"), cell(info.index), offsetWidth)(dom);
    return Math.max(header, data, footer);
  }
  static ɵfac = function TableDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TableDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ColumnResizingService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ContextService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _TableDirective,
    selectors: [["", "kendoGridResizableTable", ""]],
    hostVars: 2,
    hostBindings: function TableDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵstyleProp("min-width", ctx.minWidth);
      }
    },
    inputs: {
      locked: "locked",
      virtualColumns: "virtualColumns"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TableDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridResizableTable]",
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: ColumnResizingService
  }, {
    type: NgZone
  }, {
    type: ChangeDetectorRef
  }, {
    type: ContextService
  }], {
    locked: [{
      type: Input
    }],
    virtualColumns: [{
      type: Input
    }],
    minWidth: [{
      type: HostBinding,
      args: ["style.min-width"]
    }]
  });
})();
var RowspanService = class {
  skipCells = [];
  addCells(rowIndex, colIndex, rowspan) {
    for (let i = 1; i < rowspan; i++) {
      if (!this.skipCells.some(this.cellExists(rowIndex + i, colIndex))) {
        this.skipCells.push({
          rowIndex: rowIndex + i,
          colIndex
        });
      }
    }
  }
  reset() {
    this.skipCells = [];
  }
  shouldSkip(rowIndex, colIndex) {
    return !!this.skipCells.find(this.cellExists(rowIndex, colIndex));
  }
  cellExists = (rowIndex, colIndex) => (cell2) => cell2.rowIndex === rowIndex && cell2.colIndex === colIndex;
};
var DataMappingService = class _DataMappingService {
  rowspanService;
  groupsService;
  detailsService;
  ctx;
  recalculateRowspan = true;
  dataArray = null;
  constructor(rowspanService, groupsService, detailsService, ctx) {
    this.rowspanService = rowspanService;
    this.groupsService = groupsService;
    this.detailsService = detailsService;
    this.ctx = ctx;
  }
  isGroup(item) {
    return item.type === "group";
  }
  /**
   * Maps the data to the Grid row items, applying rowspan and detail row logic.
   */
  dataMapper(data, nonLockedColumnsToRender, lockedLeafColumns, detailTemplate, showFooter) {
    const result = [];
    if (!data || !nonLockedColumnsToRender && !lockedLeafColumns) {
      return [];
    }
    let dataIndex = 0;
    for (const item of data) {
      if (this.shouldRenderItem(item, detailTemplate, showFooter)) {
        if (item.type === "data") {
          item.cells = [];
          for (let i = 0; i < lockedLeafColumns.length + nonLockedColumnsToRender.length; i++) {
            const column = i < lockedLeafColumns.length ? lockedLeafColumns.get(i) : nonLockedColumnsToRender.get(i - lockedLeafColumns.length);
            const cell2 = {};
            if (column.cellRowspan && this.shouldSkipCell(dataIndex, i)) {
              cell2.skip = true;
            } else {
              cell2.rowspan = column.cellRowspan ? this.getRowspan({
                index: dataIndex,
                dataItem: item
              }, column, i, data) : 1;
            }
            if (isPresent(this.ctx.highlightDirective)) {
              cell2.isHighlighted = this.ctx.highlightDirective.isCellHighlighted(item, column, i);
            }
            item.cells.push(cell2);
          }
          if (isPresent(this.ctx.highlightDirective)) {
            item.isHighlighted = this.ctx.highlightDirective.isRowHighlighted(item);
          }
        }
        result.push(item);
      }
      dataIndex++;
    }
    this.recalculateRowspan = true;
    this.rowspanService.reset();
    return result;
  }
  isDataItem(item) {
    return !this.isGroup(item) && !this.isFooter(item);
  }
  isFooter(item) {
    return item.type === "footer";
  }
  isFooterItemInExpandedGroup(item) {
    const footerItem = {
      data: item.data,
      index: item.groupIndex,
      parentGroup: item.group.parentGroup
    };
    return this.isInExpandedGroup(footerItem);
  }
  isDataItemInExpandedGroup(item) {
    const dataItem = {
      data: item.group.data,
      index: item.groupIndex,
      parentGroup: item.group.parentGroup
    };
    return this.isInExpandedGroup(dataItem);
  }
  isInExpandedGroup(item) {
    return this.groupsService.isInExpandedGroup(item);
  }
  isParentGroupExpanded(item) {
    return this.groupsService.isInExpandedGroup(item.parentGroup);
  }
  isExpanded(viewItem) {
    return this.detailsService.isExpanded(viewItem.index, viewItem.data);
  }
  shouldRenderItem(item, detailTemplate, showFooter) {
    const renderGroupHeader = this.isGroup(item) && this.isParentGroupExpanded(item);
    const renderDataItem = this.isDataItem(item) && (!item.group || this.isDataItemInExpandedGroup(item));
    const renderDetailTemplate = renderDataItem && detailTemplate?.templateRef && detailTemplate.showIf(item.data, item.index) && this.isExpanded(item);
    const isVisibleFooter = this.isFooter(item) && item.group && (this.isFooterItemInExpandedGroup(item) || showFooter && this.isParentGroupExpanded(item.group));
    const renderFooter = isVisibleFooter && !item.data.hideFooter;
    item.showDataItem = renderDataItem;
    item.showDetailRow = renderDataItem && renderDetailTemplate;
    item.isExpanded = this.isExpanded(item);
    return renderGroupHeader || renderDataItem || renderDetailTemplate || renderFooter;
  }
  shouldSkipCell(rowIndex, colIndex) {
    return this.rowspanService.shouldSkip(rowIndex, colIndex);
  }
  cachedDataArray(data) {
    if (!this.dataArray) {
      this.dataArray = data.map((item) => item);
    }
    return this.dataArray;
  }
  getRowspan(row2, column, colIndex, data) {
    if (this.recalculateRowspan) {
      this.dataArray = null;
      this.recalculateRowspan = false;
    }
    const rowspan = column.cellRowspan(row2, column, this.cachedDataArray(data));
    if (rowspan > 1) {
      this.rowspanService.addCells(row2.index, colIndex, rowspan);
    }
    return rowspan;
  }
  static ɵfac = function DataMappingService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DataMappingService)(ɵɵinject(RowspanService), ɵɵinject(GroupsService), ɵɵinject(DetailsService), ɵɵinject(ContextService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DataMappingService,
    factory: _DataMappingService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DataMappingService, [{
    type: Injectable
  }], () => [{
    type: RowspanService
  }, {
    type: GroupsService
  }, {
    type: DetailsService
  }, {
    type: ContextService
  }], null);
})();
var elementAt = (index, elements, elementOffset) => {
  for (let idx4 = 0, elementIdx = 0; idx4 < elements.length; idx4++) {
    const offset3 = elementOffset(elements[idx4]);
    if (elementIdx <= index && index <= elementIdx + offset3 - 1) {
      return elements[idx4];
    }
    elementIdx += offset3;
  }
};
var rowAt = (index, rows) => elementAt(index, rows, () => 1);
var cellAt = (index, cells) => elementAt(index, cells, (cell2) => !hasClasses3(cell2, NON_DATA_CELL_CLASSES) ? parseInt(cell2.getAttribute("colSpan"), 10) || 1 : 0);
var EMPTY_OBJECT = {};
var SCROLLER_FACTORY_TOKEN2 = new InjectionToken("grid-scroll-service-factory");
function DEFAULT_SCROLLER_FACTORY2(observable, ctx) {
  return new ScrollerService2(observable, ctx);
}
var wheelDeltaY = (e) => {
  const deltaY = e.wheelDeltaY;
  if (e.wheelDelta && (deltaY === void 0 || deltaY)) {
    return e.wheelDelta;
  } else if (e.detail && e.axis === e.VERTICAL_AXIS) {
    return -e.detail * 10;
  }
  return 0;
};
var preventLockedScroll = (args, element) => {
  const delta = wheelDeltaY(args);
  const scrollTop = element.scrollTop;
  const allowScroll = scrollTop === 0 && 0 < delta || element.scrollHeight <= element.offsetHeight + scrollTop && delta < 0;
  if (!allowScroll) {
    args.preventDefault();
  }
};
var translateY = (renderer, value2) => (el) => renderer.setStyle(el, "transform", `translateY(${value2}px)`);
var maybeNativeElement = (el) => el ? el.nativeElement : null;
var hasScrollbar = (el, parent) => el.nativeElement.offsetWidth > parent.nativeElement.clientWidth;
var setHeight = (renderer) => ({
  el,
  height: height2
}) => renderer.setStyle(el, "height", `${height2}px`);
var bufferSize = 1;
var ListComponent2 = class _ListComponent {
  changeNotification;
  suspendService;
  groupsService;
  ngZone;
  renderer;
  scrollSyncService;
  resizeService;
  editService;
  supportService;
  navigationService;
  ctx;
  columnResizingService;
  changeDetector;
  pdfService;
  columnInfo;
  dataMappingService;
  hostClass = true;
  hostRole = "presentation";
  data;
  groups = [];
  total;
  rowHeight;
  detailRowHeight;
  take;
  skip = 0;
  columns = new ColumnsContainer(() => []);
  detailTemplate;
  noRecordsTemplate;
  selectable = false;
  groupable = false;
  filterable;
  rowClass;
  rowSticky;
  loading;
  trackBy = defaultTrackBy;
  virtualColumns;
  isVirtual;
  cellLoadingTemplate;
  loadingTemplate;
  sort = new Array();
  size = "medium";
  contentScroll = new EventEmitter();
  pageChange = new EventEmitter();
  scrollBottom = new EventEmitter();
  columnsStartIdx = 0;
  allItems = [];
  itemsToRender = [];
  get showFooter() {
    return this.groupable && this.groupable.showFooter;
  }
  get totalWidth() {
    if (this.virtualColumns && this.columns.unlockedWidth) {
      return this.columns.unlockedWidth;
    }
  }
  container;
  lockedContainer;
  lockedTable;
  table;
  resizeSensors = new QueryList();
  scroller;
  subscriptions;
  scrollerSubscription;
  dispatcher = new Subject();
  rowHeightService;
  skipScroll;
  rebind;
  containerScrollTop = 0;
  viewportColumns;
  columnsEndIdx;
  viewportColumnsWidth;
  scrollLeft = 0;
  virtualPageSize;
  observer;
  get lockedLeafColumns() {
    return this.columns.lockedLeafColumns;
  }
  get nonLockedLeafColumns() {
    return this.columns.nonLockedLeafColumns;
  }
  get nonLockedColumnsToRender() {
    if (this.virtualColumns && !this.pdfService.exporting && !this.isStacked) {
      return this.viewportColumns;
    }
    return this.nonLockedLeafColumns;
  }
  get leafColumns() {
    return this.columns.leafColumnsToRender;
  }
  get lockedWidth() {
    const groupCellsWidth = this.groups.length * GROUP_CELL_WIDTH;
    return expandColumns(this.lockedLeafColumns.toArray()).reduce((prev, curr) => prev + (curr.width || 0), groupCellsWidth);
  }
  get nonLockedWidth() {
    if ((!this.rtl && this.lockedLeafColumns.length || this.virtualColumns) && !this.isStacked) {
      return sumColumnWidths(expandColumns(this.nonLockedColumnsToRender.toArray()));
    }
    return void 0;
  }
  get isLocked() {
    return this.lockedLeafColumns.length > 0 && !this.isStacked;
  }
  rtl = false;
  columnUpdateFrame;
  hasLockedContainer;
  minRowHeight;
  handleSkipOnData = false;
  scrollToIndex = null;
  constructor(scrollerFactory, detailsService, changeNotification, suspendService, groupsService, ngZone, renderer, scrollSyncService, resizeService, editService, supportService, navigationService, scrollRequestService, ctx, columnResizingService, changeDetector, pdfService, columnInfo, dataMappingService) {
    this.changeNotification = changeNotification;
    this.suspendService = suspendService;
    this.groupsService = groupsService;
    this.ngZone = ngZone;
    this.renderer = renderer;
    this.scrollSyncService = scrollSyncService;
    this.resizeService = resizeService;
    this.editService = editService;
    this.supportService = supportService;
    this.navigationService = navigationService;
    this.ctx = ctx;
    this.columnResizingService = columnResizingService;
    this.changeDetector = changeDetector;
    this.pdfService = pdfService;
    this.columnInfo = columnInfo;
    this.dataMappingService = dataMappingService;
    this.scroller = this.ctx.scroller = scrollerFactory(this.dispatcher, this.ctx);
    this.subscriptions = detailsService.changes.subscribe(() => this.detailExpand());
    this.subscriptions.add(scrollRequestService.requests.subscribe((req) => isPresent7(req.adjustIndex) ? this.scrollTo(req.request, req.adjustIndex) : this.scrollToItem(req.request)));
    this.subscriptions.add(this.pdfService.restoreDOMVirtualization.subscribe(() => {
      this.ngZone.onStable.pipe(take(1)).subscribe(() => {
        this.init();
        this.setScrollerOptions();
        this.scroller.update();
      });
    }));
  }
  ngOnInit() {
    this.minRowHeight = this.isVirtual ? this.rowHeight || calcRowHeight(this.table.nativeElement) : this.rowHeight;
    this.init();
    this.subscriptions.add(this.ngZone.runOutsideAngular(this.handleRowSync.bind(this)));
    this.subscriptions.add(this.groupsService.changes.subscribe(() => {
      this.skipScroll = this.isVirtual;
    }));
    this.subscriptions.add(this.ngZone.runOutsideAngular(this.handleRowNavigationLocked.bind(this)));
    this.subscriptions.add(merge(this.columns.changes, this.resizeService.changes).subscribe(() => {
      if (this.virtualColumns) {
        this.ngZone.run(() => {
          this.updateViewportColumns();
          this.changeDetector.markForCheck();
        });
      }
    }));
    this.subscriptions.add(this.ctx.localization.changes.subscribe(({
      rtl
    }) => this.rtl = rtl));
  }
  ngOnChanges(changes) {
    if (!isDocumentAvailable()) {
      return;
    }
    const changesInSkip = changes["skip"];
    const hasInitialSkip = changesInSkip && changesInSkip.firstChange && changesInSkip.currentValue > 0;
    if (hasInitialSkip) {
      this.handleSkipOnData = true;
    }
    if (isChanged("isVirtual", changes)) {
      if (this.isVirtual && !(this.minRowHeight || this.rowHeight)) {
        this.minRowHeight = calcRowHeight(this.table.nativeElement);
      }
      this.ngZone.onStable.pipe(take(1)).subscribe(() => {
        this.scroller.reset();
        this.rowHeightService = this.scroller.rowHeightService = new RowHeightService2(this.total, this.rowHeight || this.minRowHeight);
        this.setScrollerOptions();
        this.scroller.update();
      });
    }
    if (isChanged("skip", changes) && !this.rebind) {
      this.skipScroll = true;
      this.container.nativeElement.scrollTop = this.isVirtual && this.ctx.grid?.pageable ? 0 : this.rowHeightService.offset(this.skip);
    }
    if (anyChanged(["total", "take"], changes)) {
      const isVirtualOnly = this.isVirtual && !this.ctx.grid?.pageable;
      const onlyTakeChanged = isChanged("take", changes) && !isChanged("total", changes);
      if (isVirtualOnly && onlyTakeChanged) {
        this.skipScroll = true;
      }
      this.init();
    }
    this.rebind = false;
  }
  zoneSub;
  get totalIsAllItems() {
    return this.isVirtual && Boolean(this.ctx.grid?.pageable || this.ctx.grid?.group?.length);
  }
  rebindGroupedDataFlag = false;
  ngDoCheck() {
    if (this.virtualColumns && (!this.viewportColumns || this.viewportWidthChange())) {
      this.updateViewportColumns();
    }
    if (!isPresent7(this.virtualPageSize) && !this.ctx.grid?.pageable && isPresent7(this.ctx.grid?.pageSize)) {
      this.virtualPageSize = this.ctx.grid.pageSize;
    }
    const shouldCalculatePageSize = isDocumentAvailable() && this.isVirtual && !isPresent7(this.virtualPageSize) && (!isPresent7(this.ctx.grid?.pageSize) || this.ctx.grid?.pageable);
    const previousTotal = this.allItems.length;
    this.allItems = this.dataMappingService.dataMapper(this.data, this.nonLockedColumnsToRender, this.lockedLeafColumns, this.detailTemplate, this.showFooter);
    const totalChanged = previousTotal !== this.allItems.length;
    const totalIncreased = this.allItems.length > previousTotal;
    if (this.totalIsAllItems && totalChanged) {
      this.scroller.reset(this.skipScroll);
      this.scroller.total = this.allItems.length;
      this.itemsToRender = this.allItems.slice(this.scroller.virtualSkip, this.scroller.virtualSkip + this.virtualPageSize);
    } else if (totalChanged && !this.ctx.grid?.group?.length) {
      if (!this.isVirtual && totalIncreased) {
        this.scroller.total = this.total;
      } else {
        this.scroller.reset(this.skipScroll);
        this.scroller.total = this.total;
        this.skipScroll = false;
        this.scroller.scrollSyncing = false;
      }
    }
    if (!this.isVirtual || this.isVirtual && !this.ctx.grid?.pageable && !this.ctx.grid?.group?.length) {
      this.itemsToRender = this.allItems;
    }
    const rebindGroupedData = this.isVirtual && !totalChanged && this.ctx.grid?.group?.length && !this.rebindGroupedDataFlag;
    if (rebindGroupedData) {
      this.rebindGroupedDataFlag = true;
    }
    if (shouldCalculatePageSize || !isPresent7(this.scroller.rowHeightService)) {
      const calculatedPageSize = this.virtualPageSize ?? this.calcVirtualPageSize();
      if (calculatedPageSize > 0) {
        this.ngZone.onStable.pipe(take(1)).subscribe(() => {
          if (!isPresent7(this.ctx.grid?.pageSize)) {
            this.ctx.grid.pageSize = calculatedPageSize;
            this.ngZone.run(() => {
              this.pageChange.emit({
                skip: this.skip || 0,
                take: calculatedPageSize
              });
            });
          }
          if (this.ctx.grid?.pageable || this.ctx.grid?.group?.length) {
            this.virtualPageSize = this.scroller.virtualPageSize = calculatedPageSize;
            this.ngZone.run(() => this.itemsToRender = this.allItems.slice(this.scroller.virtualSkip, this.scroller.virtualSkip + this.virtualPageSize));
          }
        });
      }
    } else if (this.rebindGroupedDataFlag) {
      this.ngZone.run(() => this.itemsToRender = this.allItems.slice(this.scroller.virtualSkip, this.scroller.virtualSkip + this.virtualPageSize));
      this.rebindGroupedDataFlag = false;
    }
    if (!this.zoneSub) {
      this.zoneSub = this.ngZone.onStable.subscribe(() => {
        if (!this.scroller.rowHeightService) {
          const total = this.isVirtual && (this.ctx.grid?.pageable || this.ctx.grid?.group?.length) ? this.allItems.length : this.total;
          this.scroller.rowHeightService = this.rowHeightService = new RowHeightService2(total, this.rowHeight || this.minRowHeight);
        }
        if (this.allItems.length && this.handleSkipOnData && this.isVirtual && this.skip > 0 && this.total > 0) {
          this.ngZone.onStable.pipe(take(1)).subscribe(() => {
            this.scroller.adjustScroll(this.scroller.rowHeightService.offset(this.skip), true);
            this.handleSkipOnData = false;
          });
        }
        if (this.isVirtual && this.ctx.grid?.group?.length && this.scroller.total !== this.allItems.length) {
          this.scroller.total = this.allItems.length;
          this.rowHeightService = this.scroller.rowHeightService = new RowHeightService2(this.scroller.total, this.rowHeight || this.minRowHeight);
        }
        this.isVirtual && this.scroller.update();
        if (isPresent7(this.scrollToIndex)) {
          const offset3 = this.scroller.rowHeightService.offset(this.scrollToIndex);
          if (offset3 > this.container.nativeElement.scrollTop) {
            this.scroller.adjustScroll(offset3 - this.container.nativeElement.scrollTop);
          }
          this.scrollToIndex = null;
        }
        if (this.isVirtual) {
          this.ctx.grid?.updateNavigationMetadata();
          const shouldResetViewport = !this.navigationService.activeRow || this.navigationService.activeRow?.dataRowIndex > -1 || isPresent7(this.navigationService.activeRow?.groupItem);
          if (shouldResetViewport) {
            this.resetNavigationViewport();
          }
        }
        this.zoneSub.unsubscribe();
        this.zoneSub = null;
      });
    }
  }
  ngAfterViewInit() {
    if (!isDocumentAvailable()) {
      return;
    }
    this.attachContainerScroll();
    this.initResizeService();
    this.setScrollerOptions();
  }
  ngAfterViewChecked() {
    const isLocked2 = this.isLocked;
    if (isLocked2 && !this.hasLockedContainer) {
      this.syncRowsHeight();
    }
    this.hasLockedContainer = isLocked2;
  }
  syncRowsHeight() {
    if (this.lockedContainer) {
      syncRowsHeight(this.lockedTable.nativeElement, this.table.nativeElement);
    }
  }
  ngOnDestroy() {
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
    }
    if (this.zoneSub) {
      this.zoneSub.unsubscribe();
      this.zoneSub = null;
    }
    if (this.resizeService) {
      this.resizeService.destroy();
    }
    this.observer?.disconnect();
    this.cleanupScroller();
  }
  init() {
    if (this.suspendService.scroll) {
      return;
    }
    const total = this.isVirtual && this.ctx.grid?.pageable ? this.ctx.grid.pageSize : this.total;
    this.rowHeightService = this.scroller.rowHeightService = new RowHeightService2(total, this.rowHeight || this.minRowHeight);
    if (!isUniversal()) {
      if (this.skipScroll) {
        this.scroller.take = this.take;
        this.scroller.total = this.total;
        this.setScrollerOptions();
        this.scroller.update();
      } else {
        this.ngZone.runOutsideAngular(this.createScroller.bind(this));
      }
    }
  }
  lockedScroll() {
    if (!this.suspendService.scroll) {
      const lockedScrollTop = this.lockedContainer.nativeElement.scrollTop;
      if (lockedScrollTop !== this.containerScrollTop) {
        this.container.nativeElement.scrollTop = this.containerScrollTop = lockedScrollTop;
      }
    }
  }
  lockedMousewheel(args) {
    if (!args.ctrlKey) {
      preventLockedScroll(args, this.container.nativeElement);
      const scrollDelta = wheelDeltaY(args);
      this.container.nativeElement.scrollTop -= scrollDelta;
    }
  }
  lockedKeydown(args) {
    const code = normalizeKeys(args);
    if (code === Keys.PageDown || code === Keys.PageUp) {
      const dir = code === Keys.PageDown ? 1 : -1;
      const element = this.container.nativeElement;
      element.scrollTop += element.offsetHeight * dir * 0.8;
      args.preventDefault();
    }
  }
  updateViewportColumns(range2) {
    const columns = this.columns.nonLockedLeafColumns.toArray();
    let {
      startIdx,
      endIdx,
      offset: offset3
    } = range2 || this.calculateViewportColumns();
    const start = Math.max(0, startIdx - bufferSize);
    const end = Math.min(endIdx + bufferSize, columns.length - 1);
    if (start < startIdx) {
      for (let idx4 = startIdx - 1; idx4 >= start; idx4--) {
        offset3 -= columns[idx4].width;
      }
    }
    let currentColumns = columns.slice(start, end + 1);
    this.viewportColumnsWidth = currentColumns.reduce((total, column) => total + column.width, 0);
    const stickyBeforeStart = columns.slice(0, start).filter((c) => c.sticky && !currentColumns.some((col) => col === c));
    const stickyAfterEnd = columns.slice(end, columns.length).filter((c) => c.sticky && !currentColumns.some((col) => col === c));
    currentColumns = [...stickyBeforeStart, ...currentColumns, ...stickyAfterEnd];
    if (start > 0) {
      const offsetColumn = new ColumnBase2();
      offsetColumn.width = offset3;
      currentColumns.unshift(offsetColumn);
    }
    this.viewportColumns = new QueryList();
    this.viewportColumns.reset(currentColumns);
    this.columnsStartIdx = start;
    this.columnsEndIdx = end;
    this.columnInfo.columnRangeChange.emit({
      start,
      end,
      offset: offset3
    });
    if (!range2) {
      this.updateColumnViewport(startIdx, endIdx);
    }
  }
  /**
   * @hidden
   */
  get isStacked() {
    return this.ctx.grid?.isStacked;
  }
  resetNavigationViewport() {
    if (!isDocumentAvailable()) {
      return;
    }
    if (this.skipScroll || this.scroller.scrollSyncing) {
      this.ngZone.runOutsideAngular(() => {
        setTimeout(() => {
          this.skipScroll = this.scroller.scrollSyncing = false;
        });
      });
      return;
    }
    if (!this.container || !this.navigationService.tableEnabled || !this.navigationService.needsViewport() || this.allItems.length === 0) {
      return;
    }
    const {
      scrollTop,
      offsetHeight
    } = this.container.nativeElement;
    const scrollBottom = scrollTop + offsetHeight;
    const firstItemIndex = this.rowHeightService.index(scrollTop);
    const lastItemIndex = this.rowHeightService.index(scrollBottom);
    const lastItemOffset = this.rowHeightService.offset(lastItemIndex);
    let viewportStart = firstItemIndex;
    let viewportEnd = lastItemIndex;
    if (isPresent7(this.detailTemplate)) {
      viewportStart *= 2;
      viewportEnd *= 2;
      const firstItemHeight = this.rowHeightService.offset(firstItemIndex);
      if (firstItemHeight + this.rowHeight < scrollTop) {
        viewportStart++;
      }
      const lastItemHeight = this.rowHeightService.height(lastItemIndex);
      const lastItemExpanded = this.scroller.isExpanded(lastItemIndex);
      const lastItemDetailOverflows = lastItemOffset + lastItemHeight > scrollBottom;
      if (lastItemExpanded && !lastItemDetailOverflows) {
        viewportEnd++;
      }
    }
    const offset3 = this.isVirtual && this.ctx.grid?.pageable ? this.skip : 0;
    this.navigationService.setViewport(viewportStart + offset3, viewportEnd + offset3);
  }
  detailExpand() {
    this.resetNavigationViewport();
  }
  attachContainerScroll() {
    if (isUniversal()) {
      return;
    }
    this.ngZone.runOutsideAngular(() => {
      this.subscriptions.add(fromEvent(this.container.nativeElement, "scroll").pipe(map((event) => event.target), filter(() => !this.suspendService.scroll), tap((target) => {
        this.onContainerScroll(target);
        this.resetNavigationViewport();
        if (this.virtualColumns || this.isVirtual) {
          this.handleColumnScroll();
        }
        const rowViewport = this.navigationService.viewport || EMPTY_OBJECT;
        const columnViewport = this.navigationService.columnViewport || EMPTY_OBJECT;
        this.contentScroll.emit({
          scrollLeft: target.scrollLeft,
          scrollTop: target.scrollTop,
          startRow: rowViewport.firstItemIndex,
          endRow: rowViewport.lastItemIndex,
          startColumn: columnViewport.firstItemIndex,
          endColumn: columnViewport.lastItemIndex
        });
      })).subscribe(this.dispatcher));
    });
    this.scrollSyncService.registerEmitter(this.container.nativeElement, "body");
  }
  createScroller() {
    this.cleanupScroller();
    const observable = this.scroller.create(this.rowHeightService, this.skip, this.take, this.total);
    this.skipScroll = false;
    this.scrollerSubscription = observable.pipe(filter((x) => x instanceof PageAction2), filter((x) => {
      const temp = this.skipScroll;
      this.skipScroll = false;
      return !temp && x.skip !== this.skip;
    }), tap(() => this.rebind = true)).subscribe((x) => this.ngZone.run(() => this.pageChange.emit(x)));
    this.scrollerSubscription.add(observable.pipe(filter((x) => x instanceof ScrollAction2)).subscribe(this.scroll.bind(this)));
    this.scrollerSubscription.add(observable.pipe(filter((x) => x instanceof ScrollBottomAction)).subscribe(() => this.scrollBottom.emit()));
  }
  scroll(scrollActionArgs) {
    this.skipScroll = false;
    if (this.isVirtual) {
      [maybeNativeElement(this.table), maybeNativeElement(this.lockedTable)].filter(isPresent7).forEach(translateY(this.renderer, scrollActionArgs.offset));
      if (this.virtualPageSize && scrollActionArgs.changeVirtualData && (this.ctx.grid.pageable || this.ctx.grid.group?.length)) {
        this.ngZone.run(() => this.itemsToRender = this.allItems.slice(this.scroller.virtualSkip, this.scroller.virtualSkip + this.virtualPageSize));
      }
    }
    this.resetNavigationViewport();
  }
  onContainerScroll({
    scrollTop
  }) {
    this.containerScrollTop = scrollTop;
    if (this.lockedContainer) {
      this.lockedContainer.nativeElement.scrollTop = scrollTop;
    }
  }
  handleRowSync() {
    const isLocked2 = () => isPresent7(this.lockedContainer);
    const onStable = () => this.ngZone.onStable.asObservable().pipe(take(1));
    return merge(this.changeNotification.changes, this.groupsService.changes.pipe(filter(isLocked2), switchMapTo(onStable())), this.editService.changed, this.resizeService.changes, this.columnResizingService.changes.pipe(filter((change) => change.type === "end")), this.supportService.changes).pipe(filter(isLocked2)).subscribe(() => {
      const scrollTop = this.container.nativeElement.scrollTop;
      const scrollLeft = this.container.nativeElement.scrollLeft;
      this.syncRowsHeight();
      this.syncContainerHeight();
      this.lockedContainer.nativeElement.scrollTop = this.container.nativeElement.scrollTop = scrollTop;
      this.container.nativeElement.scrollLeft = scrollLeft;
      this.resizeSensors.forEach((sensor) => sensor.acceptSize());
    });
  }
  handleRowNavigationLocked() {
    return this.navigationService.changes.pipe(filter(() => isPresent7(this.lockedContainer)), delay(10)).subscribe((args) => {
      if (this.lockedLeafColumns.length <= args.prevColIndex && args.colIndex < this.lockedLeafColumns.length) {
        const cell2 = this.navigationService.activeCell;
        if (cell2 && cell2.colIndex + cell2.colSpan < args.prevColIndex) {
          this.container.nativeElement.scrollLeft = 0;
        }
      }
    });
  }
  scrollToVirtualRow(itemIndex2, adjustIndexForDetailTemplate = true) {
    if (!isDocumentAvailable()) {
      return;
    }
    if (isPresent7(this.detailTemplate) && adjustIndexForDetailTemplate) {
      itemIndex2 = Math.floor(itemIndex2 / 2);
    }
    const offset3 = this.rowHeightService.offset(itemIndex2);
    this.container.nativeElement.scrollTop = offset3;
    this.scrollToIndex = itemIndex2;
  }
  scrollTo({
    row: row2,
    column
  }, adjustIndex = false) {
    if (isNumber3(row2)) {
      if (this.isVirtual) {
        this.scrollToVirtualRow(row2, adjustIndex);
      } else {
        const element = rowAt(row2, this.table.nativeElement.rows);
        if (element) {
          this.container.nativeElement.scrollTop = element.offsetTop;
        }
      }
    }
    if (isNumber3(column)) {
      column -= this.lockedLeafColumns.length;
      if (this.virtualColumns) {
        const columns = this.columns.leafColumnsToRender;
        let offset3 = 0;
        for (let idx4 = 0; idx4 < column; idx4++) {
          offset3 += columns[idx4].width || 0;
        }
        const startOffset = this.lockedLeafColumns.length ? 0 : this.groups.length * GROUP_CELL_WIDTH + (this.detailTemplate && column > 0 ? GROUP_CELL_WIDTH : 0);
        this.container.nativeElement.scrollLeft = this.normalizeScrollLeft(offset3 + startOffset);
      } else if (column === 0 && this.detailTemplate) {
        this.container.nativeElement.scrollLeft = this.normalizeScrollLeft(0);
      } else {
        const firstRow = rowAt(0, this.table.nativeElement.rows);
        if (firstRow) {
          const element = cellAt(column, firstRow.cells);
          if (element) {
            this.container.nativeElement.scrollLeft = this.elementScrollLeft(element);
          }
        }
      }
    }
  }
  scrollToItem(item) {
    if (!isDocumentAvailable()) {
      return;
    }
    const data = this.ctx.grid.data;
    const gridData = Array.isArray(data) ? data : data.data;
    const gridDataItems = gridData.flatMap(recursiveFlatMap);
    const dataItemIndex = gridDataItems.findIndex((dataItem) => dataItem[item.idField] === item.id);
    if (dataItemIndex !== -1) {
      const row2 = Array.from(this.table.nativeElement.rows).find((r) => {
        const dataAttribute = r.getAttribute("data-kendo-grid-item-index");
        return dataAttribute && +dataAttribute === this.ctx.grid.skip + dataItemIndex;
      });
      row2 && row2.scrollIntoView();
      this.resetNavigationViewport();
    }
  }
  cleanupScroller() {
    if (this.scrollerSubscription) {
      this.scrollerSubscription.unsubscribe();
    }
    if (this.scroller) {
      this.scroller.destroy();
    }
  }
  initResizeService() {
    this.resizeService.connect(merge(...this.resizeSensors.map((sensor) => sensor.resize)));
  }
  syncContainerHeight() {
    [maybeNativeElement(this.lockedContainer)].filter(isPresent7).map((el) => {
      el.style.height = "";
      let height2 = this.container.nativeElement.offsetHeight;
      if (hasScrollbar(this.table, this.container)) {
        height2 -= this.supportService.scrollbarWidth;
      }
      return {
        el,
        height: height2
      };
    }).forEach(setHeight(this.renderer));
  }
  handleColumnScroll() {
    const container = this.container.nativeElement;
    const scrollLeft = container.scrollLeft;
    if (this.scrollLeft !== scrollLeft) {
      this.scrollLeft = scrollLeft;
      const range2 = this.calculateViewportColumns();
      this.updateColumnViewport(range2.startIdx, range2.endIdx);
      if (range2.startIdx < this.columnsStartIdx || this.columnsEndIdx < range2.endIdx) {
        cancelAnimationFrame2(this.columnUpdateFrame);
        this.columnUpdateFrame = requestAnimationFrame2(() => {
          this.ngZone.run(() => {
            this.updateViewportColumns(range2);
            this.changeDetector.markForCheck();
          });
        });
      }
    }
  }
  updateColumnViewport(startIdx, endIdx) {
    const lockedCount = this.lockedLeafColumns.length;
    const leafColumns2 = this.nonLockedLeafColumns.toArray();
    const viewportStart = lockedCount + startIdx + (this.detailTemplate && startIdx > 0 ? 1 : 0);
    let viewportEnd = lockedCount + endIdx + (this.detailTemplate ? 1 : 0);
    for (let idx4 = 0; idx4 < leafColumns2.length; idx4++) {
      const column = leafColumns2[idx4];
      if (column.isSpanColumn) {
        viewportEnd += column.children.length;
      }
    }
    this.navigationService.setColumnViewport(viewportStart, viewportEnd);
  }
  calculateViewportColumns() {
    const {
      scrollLeft,
      clientWidth
    } = this.container.nativeElement;
    const columns = this.columns.nonLockedLeafColumns.toArray();
    const normalizedScrollLeft = this.normalizeScrollLeft(scrollLeft);
    const viewportEnd = normalizedScrollLeft + clientWidth;
    let startIdx;
    let endIdx = 0;
    let current = 0;
    let offset3 = 0;
    let idx4;
    for (idx4 = 0; idx4 < columns.length; idx4++) {
      const column = columns[idx4];
      current += column.width || 0;
      if (startIdx === void 0 && current > normalizedScrollLeft) {
        startIdx = idx4;
        offset3 = current - (column.width || 0);
      }
      if (current >= viewportEnd) {
        endIdx = idx4;
        break;
      }
    }
    if (!endIdx && idx4 > 0) {
      endIdx = columns.length - 1;
    }
    return {
      startIdx,
      endIdx,
      offset: offset3
    };
  }
  viewportWidthChange() {
    const currentWidth = this.viewportColumns.toArray().reduce((total, column) => total + column.width, 0);
    return currentWidth !== this.viewportColumnsWidth;
  }
  normalizeScrollLeft(position2) {
    return this.rtl ? rtlScrollPosition(position2, this.container.nativeElement, this.supportService.rtlScrollLeft) : position2;
  }
  elementScrollLeft(element) {
    if (this.rtl) {
      return this.normalizeScrollLeft(this.container.nativeElement.scrollWidth - element.offsetLeft - element.offsetWidth);
    }
    return element.offsetLeft;
  }
  calcVirtualPageSize = () => {
    const containerHeight = this.container.nativeElement.offsetHeight;
    if (containerHeight && (this.rowHeight ?? this.minRowHeight)) {
      return Math.ceil(containerHeight / (this.rowHeight ?? this.minRowHeight) * 1.5);
    }
    return 0;
  };
  setScrollerOptions() {
    this.scroller.scrollableVirtual = this.isVirtual;
    this.scroller.table = this.table.nativeElement;
    this.scroller.lockedTable = this.lockedTable?.nativeElement || null;
    this.scroller.tableBody = this.table.nativeElement.tBodies[0];
    this.scroller.container = this.container.nativeElement;
    this.scroller.scrollHeightContainer = this.container.nativeElement.querySelector(".k-height-container");
    this.scroller.total = this.isVirtual && !this.ctx.grid?.pageable ? this.total : this.allItems.length;
  }
  static ɵfac = function ListComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ListComponent)(ɵɵdirectiveInject(SCROLLER_FACTORY_TOKEN2), ɵɵdirectiveInject(DetailsService), ɵɵdirectiveInject(ChangeNotificationService), ɵɵdirectiveInject(SuspendService), ɵɵdirectiveInject(GroupsService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ScrollSyncService2), ɵɵdirectiveInject(ResizeService), ɵɵdirectiveInject(EditService), ɵɵdirectiveInject(BrowserSupportService), ɵɵdirectiveInject(NavigationService4), ɵɵdirectiveInject(ScrollRequestService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ColumnResizingService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PDFService), ɵɵdirectiveInject(ColumnInfoService), ɵɵdirectiveInject(DataMappingService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ListComponent,
    selectors: [["kendo-grid-list"]],
    viewQuery: function ListComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c492, 7)(_c50, 5)(_c51, 5)(_c522, 7)(ResizeSensorComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.container = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.lockedContainer = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.lockedTable = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.table = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.resizeSensors = _t);
      }
    },
    hostVars: 3,
    hostBindings: function ListComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("role", ctx.hostRole);
        ɵɵclassProp("k-grid-container", ctx.hostClass);
      }
    },
    inputs: {
      data: "data",
      groups: "groups",
      total: "total",
      rowHeight: "rowHeight",
      detailRowHeight: "detailRowHeight",
      take: "take",
      skip: "skip",
      columns: "columns",
      detailTemplate: "detailTemplate",
      noRecordsTemplate: "noRecordsTemplate",
      selectable: "selectable",
      groupable: "groupable",
      filterable: "filterable",
      rowClass: "rowClass",
      rowSticky: "rowSticky",
      loading: "loading",
      trackBy: "trackBy",
      virtualColumns: "virtualColumns",
      isVirtual: "isVirtual",
      cellLoadingTemplate: "cellLoadingTemplate",
      loadingTemplate: "loadingTemplate",
      sort: "sort",
      size: "size"
    },
    outputs: {
      contentScroll: "contentScroll",
      pageChange: "pageChange",
      scrollBottom: "scrollBottom"
    },
    features: [ɵɵProvidersFeature([{
      provide: SCROLLER_FACTORY_TOKEN2,
      useValue: DEFAULT_SCROLLER_FACTORY2
    }]), ɵɵNgOnChangesFeature],
    decls: 12,
    vars: 38,
    consts: [["container", ""], ["table", ""], ["lockedContainer", ""], ["lockedTable", ""], ["role", "presentation", "tabindex", "-1", 1, "k-grid-content-locked", 3, "width", "kendoEventsOutsideAngular", "scope"], ["tabindex", "-1", 1, "k-grid-content", "k-virtual-content", 3, "kendoGridResizableContainer", "lockedWidth"], ["role", "presentation"], ["kendoGridResizableTable", "", "kendoGridTable", "", "role", "presentation", 1, "k-grid-table", 3, "virtualColumns", "size"], ["kendoGridColGroup", "", 3, "groups", "columns", "detailTemplate", "sort"], ["kendoGridTableBody", "", "role", "rowgroup", 3, "skipGroupDecoration", "rowsToRender", "groups", "columns", "allColumns", "detailTemplate", "noRecordsTemplate", "lockedColumnsCount", "totalColumnsCount", "totalColumns", "skip", "selectable", "trackBy", "filterable", "rowClass", "rowSticky", "virtualColumns", "isLoading", "isVirtual", "cellLoadingTemplate", "rowHeight", "detailRowHeight"], ["role", "presentation", 1, "k-height-container"], ["role", "presentation", 1, "k-width-container"], ["role", "presentation", "tabindex", "-1", 1, "k-grid-content-locked", 3, "kendoEventsOutsideAngular", "scope"], ["kendoGridResizableTable", "", "role", "presentation", "kendoGridTable", "", 1, "k-grid-table", 3, "locked", "size"], ["kendoGridTableBody", "", "role", "presentation", 3, "groups", "isLocked", "rowsToRender", "rowHeight", "detailRowHeight", "noRecordsText", "columns", "totalColumnsCount", "totalColumns", "detailTemplate", "skip", "selectable", "trackBy", "filterable", "rowClass", "isLoading", "isVirtual", "cellLoadingTemplate"]],
    template: function ListComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵconditionalCreate(0, ListComponent_Conditional_0_Template, 9, 36, "div", 4);
        ɵɵelementStart(1, "div", 5, 0)(3, "div", 6)(4, "table", 7, 1);
        ɵɵelement(6, "colgroup", 8)(7, "tbody", 9);
        ɵɵelementEnd();
        ɵɵconditionalCreate(8, ListComponent_Conditional_8_Template, 1, 0, "kendo-resize-sensor");
        ɵɵelementEnd();
        ɵɵconditionalCreate(9, ListComponent_Conditional_9_Template, 1, 0, "kendo-resize-sensor");
        ɵɵconditionalCreate(10, ListComponent_Conditional_10_Template, 2, 0, "div", 10);
        ɵɵconditionalCreate(11, ListComponent_Conditional_11_Template, 2, 2, "div", 11);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵconditional(ctx.isLocked && !ctx.isStacked ? 0 : -1);
        ɵɵadvance();
        ɵɵproperty("kendoGridResizableContainer", ctx.lockedLeafColumns.length > 0)("lockedWidth", ctx.lockedWidth + 1);
        ɵɵadvance(3);
        ɵɵstyleProp("width", ctx.nonLockedWidth, "px");
        ɵɵproperty("virtualColumns", ctx.virtualColumns)("size", ctx.size);
        ɵɵadvance(2);
        ɵɵproperty("groups", ctx.isLocked ? ɵɵpureFunction0(37, _c532) : ctx.groups)("columns", ctx.nonLockedColumnsToRender)("detailTemplate", ctx.detailTemplate)("sort", ctx.sort);
        ɵɵadvance();
        ɵɵproperty("skipGroupDecoration", ctx.isLocked)("rowsToRender", ctx.itemsToRender)("groups", ctx.groups)("columns", ctx.nonLockedColumnsToRender)("allColumns", ctx.nonLockedLeafColumns)("detailTemplate", ctx.detailTemplate)("noRecordsTemplate", ctx.noRecordsTemplate)("lockedColumnsCount", ctx.lockedLeafColumns.length)("totalColumnsCount", ctx.leafColumns.length)("totalColumns", ctx.columns)("skip", ctx.skip)("selectable", ctx.selectable)("trackBy", ctx.trackBy)("filterable", ctx.filterable)("rowClass", ctx.rowClass)("rowSticky", ctx.rowSticky)("virtualColumns", ctx.virtualColumns)("isLoading", ctx.loading)("isVirtual", ctx.isVirtual)("cellLoadingTemplate", ctx.cellLoadingTemplate)("rowHeight", ctx.rowHeight)("detailRowHeight", ctx.detailRowHeight);
        ɵɵadvance();
        ɵɵconditional(ctx.isLocked ? 8 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.isLocked || ctx.virtualColumns ? 9 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.isVirtual ? 10 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.virtualColumns && !ctx.isStacked ? 11 : -1);
      }
    },
    dependencies: [EventsOutsideAngularDirective, TableDirective, GridTableDirective, ColGroupComponent, TableBodyComponent, ResizeSensorComponent, ResizableContainerDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ListComponent2, [{
    type: Component,
    args: [{
      providers: [{
        provide: SCROLLER_FACTORY_TOKEN2,
        useValue: DEFAULT_SCROLLER_FACTORY2
      }],
      selector: "kendo-grid-list",
      template: `
    @if (isLocked && !isStacked) {
      <div #lockedContainer class="k-grid-content-locked" role="presentation"
        [style.width.px]="lockedWidth" tabindex="-1"
        [kendoEventsOutsideAngular]="{
            keydown: lockedKeydown,
            scroll: lockedScroll,
            mousewheel: lockedMousewheel,
            DOMMouseScroll: lockedMousewheel
        }"
        [scope]="this"
        >
        <div role="presentation">
          <table
            kendoGridResizableTable
            [locked]="true"
            #lockedTable
            class="k-grid-table"
            role="presentation"
            kendoGridTable
            [size]="size"
            [style.width.px]="lockedWidth">
            <colgroup kendoGridColGroup
              [groups]="groups"
              [columns]="$any(lockedLeafColumns)"
              [detailTemplate]="detailTemplate"
              [sort]="sort">
          </colgroup>
          <tbody kendoGridTableBody
            role="presentation"
            [groups]="groups"
            [isLocked]="true"
            [rowsToRender]="itemsToRender"
            [rowHeight]="rowHeight"
            [detailRowHeight]="detailRowHeight"
            [noRecordsText]="''"
            [columns]="$any(lockedLeafColumns)"
            [totalColumnsCount]="leafColumns.length"
            [totalColumns]="columns"
            [detailTemplate]="detailTemplate"
            [skip]="skip"
            [selectable]="selectable"
            [trackBy]="trackBy"
            [filterable]="filterable"
            [rowClass]="rowClass"
            [isLoading]="loading"
            [isVirtual]="isVirtual"
            [cellLoadingTemplate]="cellLoadingTemplate">
          </tbody>
        </table>
        <kendo-resize-sensor></kendo-resize-sensor>
      </div>
      @if (isVirtual) {
        <div class="k-height-container" role="presentation">
          <div></div>
        </div>
      }
    </div>
    }
    <div
      #container
      class="k-grid-content k-virtual-content"
      [kendoGridResizableContainer]="lockedLeafColumns.length > 0"
      [lockedWidth]="lockedWidth + 1"
      tabindex="-1"
      >
      <div role="presentation">
        <table
          [style.width.px]="nonLockedWidth"
          #table
          kendoGridResizableTable
          [virtualColumns]="virtualColumns"
          class="k-grid-table"
          kendoGridTable
          [size]="size"
          role="presentation">
          <colgroup kendoGridColGroup
            [groups]="isLocked ? [] : groups"
            [columns]="$any(nonLockedColumnsToRender)"
            [detailTemplate]="detailTemplate"
            [sort]="sort">
        </colgroup>
        <tbody kendoGridTableBody
          role="rowgroup"
          [skipGroupDecoration]="isLocked"
          [rowsToRender]="itemsToRender"
          [groups]="groups"
          [columns]="$any(nonLockedColumnsToRender)"
          [allColumns]="$any(nonLockedLeafColumns)"
          [detailTemplate]="detailTemplate"
          [noRecordsTemplate]="noRecordsTemplate"
          [lockedColumnsCount]="lockedLeafColumns.length"
          [totalColumnsCount]="leafColumns.length"
          [totalColumns]="columns"
          [skip]="skip"
          [selectable]="selectable"
          [trackBy]="trackBy"
          [filterable]="filterable"
          [rowClass]="rowClass"
          [rowSticky]="rowSticky"
          [virtualColumns]="virtualColumns"
          [isLoading]="loading"
          [isVirtual]="isVirtual"
          [cellLoadingTemplate]="cellLoadingTemplate"
          [rowHeight]="rowHeight"
          [detailRowHeight]="detailRowHeight">
        </tbody>
      </table>
      @if (isLocked) {
        <kendo-resize-sensor></kendo-resize-sensor>
      }
    </div>
    @if (isLocked || virtualColumns) {
      <kendo-resize-sensor></kendo-resize-sensor>
    }
    @if (isVirtual) {
      <div class="k-height-container" role="presentation">
        <div></div>
      </div>
    }
    @if (virtualColumns && !isStacked) {
      <div class="k-width-container" role="presentation">
        <div [style.width.px]="totalWidth"></div>
      </div>
    }
    </div>
    `,
      standalone: true,
      imports: [EventsOutsideAngularDirective, TableDirective, GridTableDirective, ColGroupComponent, TableBodyComponent, ResizeSensorComponent, ResizableContainerDirective]
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [SCROLLER_FACTORY_TOKEN2]
    }]
  }, {
    type: DetailsService
  }, {
    type: ChangeNotificationService
  }, {
    type: SuspendService
  }, {
    type: GroupsService
  }, {
    type: NgZone
  }, {
    type: Renderer2
  }, {
    type: ScrollSyncService2
  }, {
    type: ResizeService
  }, {
    type: EditService
  }, {
    type: BrowserSupportService
  }, {
    type: NavigationService4
  }, {
    type: ScrollRequestService
  }, {
    type: ContextService
  }, {
    type: ColumnResizingService
  }, {
    type: ChangeDetectorRef
  }, {
    type: PDFService
  }, {
    type: ColumnInfoService
  }, {
    type: DataMappingService
  }], {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-grid-container"]
    }],
    hostRole: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    data: [{
      type: Input
    }],
    groups: [{
      type: Input
    }],
    total: [{
      type: Input
    }],
    rowHeight: [{
      type: Input
    }],
    detailRowHeight: [{
      type: Input
    }],
    take: [{
      type: Input
    }],
    skip: [{
      type: Input
    }],
    columns: [{
      type: Input
    }],
    detailTemplate: [{
      type: Input
    }],
    noRecordsTemplate: [{
      type: Input
    }],
    selectable: [{
      type: Input
    }],
    groupable: [{
      type: Input
    }],
    filterable: [{
      type: Input
    }],
    rowClass: [{
      type: Input
    }],
    rowSticky: [{
      type: Input
    }],
    loading: [{
      type: Input
    }],
    trackBy: [{
      type: Input
    }],
    virtualColumns: [{
      type: Input
    }],
    isVirtual: [{
      type: Input
    }],
    cellLoadingTemplate: [{
      type: Input
    }],
    loadingTemplate: [{
      type: Input
    }],
    sort: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    contentScroll: [{
      type: Output
    }],
    pageChange: [{
      type: Output
    }],
    scrollBottom: [{
      type: Output
    }],
    container: [{
      type: ViewChild,
      args: ["container", {
        static: true
      }]
    }],
    lockedContainer: [{
      type: ViewChild,
      args: ["lockedContainer"]
    }],
    lockedTable: [{
      type: ViewChild,
      args: ["lockedTable"]
    }],
    table: [{
      type: ViewChild,
      args: ["table", {
        static: true
      }]
    }],
    resizeSensors: [{
      type: ViewChildren,
      args: [ResizeSensorComponent]
    }]
  });
})();
var ToolbarComponent = class _ToolbarComponent {
  ctx;
  wrapper;
  context = {};
  role = "toolbar";
  hostClasses = true;
  get sizeSmallClass() {
    return this.size === "small";
  }
  get sizeMediumClass() {
    return this.size === "medium" || !this.size;
  }
  set position(value2) {
    this.context.position = value2;
  }
  set size(size) {
    this._size = size;
    if (size === "none") {
      this.wrapper.nativeElement.classList.remove("k-toolbar-sm", "k-toolbar-md");
    }
  }
  get size() {
    return this._size;
  }
  clickHandler(ev) {
    if (this.navigable && isDocumentAvailable()) {
      const closestFocusableElement = closestInScope(ev.target, isFocusable, this.wrapper.nativeElement)?.closest("[kendoGridToolbarFocusable]");
      const targetIndex = this.navigationService.navigableElements.indexOf(closestFocusableElement);
      if (targetIndex > -1) {
        this.navigationService.currentActiveIndex = targetIndex;
      }
      this.navigationService.updateFocus();
      if (ev.target === this.wrapper.nativeElement) {
        this.navigationService.focus();
      }
    }
  }
  arrowLeftListener() {
    if (this.navigable && isDocumentAvailable() && this.navigationService.navigableElements.length) {
      this.navigationService.currentActiveIndex--;
      if (this.navigationService.currentActiveIndex < 0) {
        this.navigationService.currentActiveIndex = this.navigationService.navigableElements.length - 1;
      }
      this.navigationService.updateFocus();
    }
  }
  arrowRightListener() {
    if (this.navigable && isDocumentAvailable() && this.navigationService.navigableElements.length) {
      this.navigationService.currentActiveIndex++;
      if (this.navigationService.currentActiveIndex >= this.navigationService.navigableElements.length) {
        this.navigationService.currentActiveIndex = 0;
      }
      this.navigationService.updateFocus();
    }
  }
  homeKeyListener(e) {
    if (this.navigable && isDocumentAvailable() && this.navigationService.navigableElements.length) {
      e.preventDefault();
      this.navigationService.currentActiveIndex = 0;
      this.navigationService.updateFocus();
    }
  }
  endKeyListener(e) {
    if (this.navigable && isDocumentAvailable() && this.navigationService.navigableElements.length) {
      e.preventDefault();
      this.navigationService.currentActiveIndex = this.navigationService.navigableElements.length - 1;
      this.navigationService.updateFocus();
    }
  }
  navigable;
  get toolbarTemplateRef() {
    return this.ctx.grid.toolbarTemplate ? this.ctx.grid.toolbarTemplate.templateRef : void 0;
  }
  _size = "medium";
  navigationService;
  constructor(ctx, wrapper) {
    this.ctx = ctx;
    this.wrapper = wrapper;
    this.navigationService = this.ctx[`${this.wrapper.nativeElement.getAttribute("position")}ToolbarNavigation`];
    if (this.navigationService) {
      this.navigationService.toolbarElement = this.wrapper.nativeElement;
    }
  }
  static ɵfac = function ToolbarComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ToolbarComponent)(ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ToolbarComponent,
    selectors: [["kendo-grid-toolbar"]],
    hostVars: 11,
    hostBindings: function ToolbarComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("click", function ToolbarComponent_click_HostBindingHandler($event) {
          return ctx.clickHandler($event);
        })("keydown.arrowleft", function ToolbarComponent_keydown_arrowleft_HostBindingHandler($event) {
          return ctx.arrowLeftListener($event);
        })("keydown.arrowright", function ToolbarComponent_keydown_arrowright_HostBindingHandler($event) {
          return ctx.arrowRightListener($event);
        })("keydown.home", function ToolbarComponent_keydown_home_HostBindingHandler($event) {
          return ctx.homeKeyListener($event);
        })("keydown.end", function ToolbarComponent_keydown_end_HostBindingHandler($event) {
          return ctx.endKeyListener($event);
        });
      }
      if (rf & 2) {
        ɵɵattribute("role", ctx.role);
        ɵɵclassProp("k-toolbar", ctx.hostClasses)("k-grid-toolbar", ctx.hostClasses)("k-toolbar-solid", ctx.hostClasses)("k-toolbar-sm", ctx.sizeSmallClass)("k-toolbar-md", ctx.sizeMediumClass);
      }
    },
    inputs: {
      position: "position",
      size: "size",
      navigable: "navigable"
    },
    decls: 1,
    vars: 1,
    consts: [[3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
    template: function ToolbarComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵconditionalCreate(0, ToolbarComponent_Conditional_0_Template, 1, 2, null, 0);
      }
      if (rf & 2) {
        ɵɵconditional(ctx.toolbarTemplateRef ? 0 : -1);
      }
    },
    dependencies: [NgTemplateOutlet],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ToolbarComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-toolbar",
      template: `
        @if (toolbarTemplateRef) {
          <ng-template
            [ngTemplateOutlet]="toolbarTemplateRef"
          [ngTemplateOutletContext]="context"></ng-template>
        }
        `,
      standalone: true,
      imports: [NgTemplateOutlet]
    }]
  }], () => [{
    type: ContextService
  }, {
    type: ElementRef
  }], {
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-toolbar"]
    }, {
      type: HostBinding,
      args: ["class.k-grid-toolbar"]
    }, {
      type: HostBinding,
      args: ["class.k-toolbar-solid"]
    }],
    sizeSmallClass: [{
      type: HostBinding,
      args: ["class.k-toolbar-sm"]
    }],
    sizeMediumClass: [{
      type: HostBinding,
      args: ["class.k-toolbar-md"]
    }],
    position: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    clickHandler: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }],
    arrowLeftListener: [{
      type: HostListener,
      args: ["keydown.arrowleft", ["$event"]]
    }],
    arrowRightListener: [{
      type: HostListener,
      args: ["keydown.arrowright", ["$event"]]
    }],
    homeKeyListener: [{
      type: HostListener,
      args: ["keydown.home", ["$event"]]
    }],
    endKeyListener: [{
      type: HostListener,
      args: ["keydown.end", ["$event"]]
    }],
    navigable: [{
      type: Input
    }]
  });
})();
var GridMessages = class _GridMessages extends ComponentMessages {
  /**
   * Sets the text for the empty group panel.
   */
  groupPanelEmpty;
  /**
   * Sets the text when there are no records.
   */
  noRecords;
  /**
   * Sets the label for the pager. By default, it follows the pattern **Page {currentPage} of {totalPages}**.
   * For example, when the current page is 1 and the total number of pages is 10, the label is
   * **Page navigation, page 1 of 10**.
   *
   * The message includes the current page number, total number of pages, and a localizable string.
   * You can reorder these parts by using placeholders in the `pagerLabel` input.
   * Use `{currentPage}` and `{totalPages}` to insert the actual values.
   * [See example](slug:globalization_grid#toc-custom-messages).
   */
  pagerLabel;
  /**
   * Sets the label for the **First page** button.
   */
  pagerFirstPage;
  /**
   * Sets the label for the **Last page** button.
   */
  pagerLastPage;
  /**
   * Sets the label for the **Previous page** button.
   */
  pagerPreviousPage;
  /**
   * Sets the label for the **Next page** button.
   */
  pagerNextPage;
  /**
   * Sets the text displayed before the pager input.
   */
  pagerPage;
  /**
   * Sets the text displayed after the page-size selector.
   */
  pagerItemsPerPage;
  /**
   * Sets the text displayed before the total-page number.
   */
  pagerOf;
  /**
   * Sets the text displayed after the total number of items.
   */
  pagerItems;
  /**
   * Sets the title attribute of the page number input element.
   */
  pagerPageNumberInputTitle;
  /**
   * Sets the text for the aria-label attribute on the page number input element.
   */
  pagerInputLabel;
  /**
   * Sets the text for the title and `aria-label` attributes on the page chooser in the Grid Pager.
   */
  pagerSelectPage;
  /**
   * Sets the label for the filter cell or icon.
   */
  filter;
  /**
   * Sets the label for the filter input.
   *
   * The filter input label includes the column name and a localizable string.
   * For example, for a column named **Product Name**, the default label is **Product Name Filter**.
   *
   * You can reorder the column name and the localizable part by using a placeholder in `filterInputLabel`.
   * Use `{columnName}` to insert the column name, for example, **filter for {columnName}**.
   * [See example](slug:globalization_grid#toc-custom-messages).
   */
  filterInputLabel;
  /**
   * Sets the title for the filter menu icon.
   *
   * The title includes the column name and a localizable string.
   * For example, for a column named **Product Name**, the default title is **Product Name Filter Menu**.
   *
   * You can reorder the column name and the localizable part by using a placeholder in `filterMenuTitle`.
   * Use `{columnName}` to insert the column name, for example, **filter for {columnName}**.
   * [See example](slug:globalization_grid#toc-custom-messages).
   */
  filterMenuTitle;
  /**
   * Sets the label for the filter menu operators DropDownList.
   *
   * The label includes the column name and a localizable string.
   * For example, for a column named **Product Name**, the default label is **Product Name Filter Menu Operators**.
   *
   * You can reorder the column name and the localizable part by using a placeholder in `filterMenuOperatorsDropDownLabel`.
   * Use `{columnName}` to insert the column name, for example, **filter operators for {columnName}**.
   * [See example](slug:globalization_grid#toc-custom-messages).
   */
  filterMenuOperatorsDropDownLabel;
  /**
   * Sets the label for the filter menu logic DropDownList.
   *
   * The label includes the column name and a localizable string.
   * For example, for a column named **Product Name**, the default label is **Product Name Filter Menu Logic**.
   *
   * You can reorder the column name and the localizable part by using a placeholder in `filterMenuLogicDropDownLabel`.
   * Use `{columnName}` to insert the column name, for example, **filter logic for {columnName}**.
   * [See example](slug:globalization_grid#toc-custom-messages).
   */
  filterMenuLogicDropDownLabel;
  /**
   * Sets the label for the filter cell operators DropDownList.
   *
   * The label includes the column name and a localizable string.
   * For example, for a column named **Product Name**, the default label is **Filter cell operators for Product Name**.
   *
   * You can reorder the column name and the localizable part by using a placeholder in `filterCellOperatorLabel`.
   * Use `{columnName}` to insert the column name, for example, **Filter operators for {columnName}**.
   * [See example](slug:globalization_grid#toc-custom-messages).
   */
  filterCellOperatorLabel;
  /**
   * Sets the label for the boolean filter cell DropDownList.
   *
   * The label includes the column name and a localizable string.
   * For example, for a column named **Product Name**, the default label is **Boolean filter cell for Product Name**.
   *
   * You can reorder the column name and the localizable part by using a placeholder in `booleanFilterCellLabel`.
   * Use `{columnName}` to insert the column name, for example, **Boolean Filter operator for {columnName}**.
   * [See example](slug:globalization_grid#toc-custom-messages).
   */
  booleanFilterCellLabel;
  /**
   * The text of the AI Assistant Apply button.
   */
  aiAssistantApplyButtonText;
  /**
   * The text of the AI Assistant toolbar tool.
   */
  aiAssistantToolbarToolText;
  /**
   * The text of the AI Assistant Window title.
   */
  aiAssistantWindowTitle;
  /**
   * The title of the AI Assistant Window close button.
   */
  aiAssistantWindowCloseTitle;
  /**
   * The title of the AI Assistant Prompt Output Card.
   */
  aiAssistantOutputCardTitle;
  /**
   * The success message dispayed in the AI Assistant Prompt Output Card's body.
   */
  aiAssistantOutputCardBodyContent;
  /**
   * The message shown when AI selection requires the Grid selectable option.
   */
  aiAssistantSelectionNotEnabled;
  /**
   * The message shown when AI selection requires row selection mode.
   */
  aiAssistantSelectionRowModeRequired;
  /**
   * The message shown when AI selection requires cell selection mode.
   */
  aiAssistantSelectionCellModeRequired;
  /**
   * The title of the AI Assistant Window maximize button.
   */
  aiAssistantWindowMaximizeTitle;
  /**
   * The title of the AI Assistant Window minimize button.
   */
  aiAssistantWindowMinimizeTitle;
  /**
   * The title of the AI Assistant Window restore button.
   */
  aiAssistantWindowRestoreTitle;
  /**
   * Sets the text for the `Equal` (**Is equal to**) filter operator.
   */
  filterEqOperator;
  /**
   * Sets the text for the `NotEqual` (**Is not equal to**) filter operator.
   */
  filterNotEqOperator;
  /**
   * Sets the text for the `IsNull` (**Is null**) filter operator.
   */
  filterIsNullOperator;
  /**
   * Sets the text for the `IsNotNull` (**Is not null**) filter operator.
   */
  filterIsNotNullOperator;
  /**
   * Sets the text for the `IsEmpty` (**Is empty**) filter operator.
   */
  filterIsEmptyOperator;
  /**
   * Sets the text for the `IsNotEmpty` (**Is not empty**) filter operator.
   */
  filterIsNotEmptyOperator;
  /**
   * Sets the text for the `StartsWith` (**Starts with**) filter operator.
   */
  filterStartsWithOperator;
  /**
   * Sets the text for the `Contains` (**Contains**) filter operator.
   */
  filterContainsOperator;
  /**
   * Sets the text for the `DoesNotContain` (**Does not contain**) filter operator.
   */
  filterNotContainsOperator;
  /**
   * Sets the text for the `EndsWith` (**Ends with**) string filter operator.
   */
  filterEndsWithOperator;
  /**
   * Sets the text for the `GreaterOrEqualTo` (**Is greater than or equal to**) numeric filter operator.
   */
  filterGteOperator;
  /**
   * Sets the text for the `Greater` (**Is greater than**) numeric filter operator.
   */
  filterGtOperator;
  /**
   * Sets the text for the `LessOrEqualTo` (**Is less than or equal to**) numeric filter operator.
   */
  filterLteOperator;
  /**
   * Sets the text for the `Less` (**Is less than**) numeric filter operator.
   */
  filterLtOperator;
  /**
   * Sets the text for the `IsTrue` Boolean filter option.
   */
  filterIsTrue;
  /**
   * Sets the text for the `IsFalse` Boolean filter option.
   */
  filterIsFalse;
  /**
   * Sets the text for the `(All)` option in the Boolean filter.
   */
  filterBooleanAll;
  /**
   * Sets the title for the Operators ActionSheet in adaptive mode.
   */
  adaptiveFilterOperatorsTitle;
  /**
   * Sets the text for the `AfterOrEqualTo` (**Is after or equal to**) date filter operator.
   */
  filterAfterOrEqualOperator;
  /**
   * Sets the text for the `After` (**Is after**) date filter operator.
   */
  filterAfterOperator;
  /**
   * Sets the text for the `Before` (**Is before**) date filter operator.
   */
  filterBeforeOperator;
  /**
   * Sets the text for the `BeforeOrEqualTo` (**Is before or equal to**) date filter operator.
   */
  filterBeforeOrEqualOperator;
  /**
   * Sets the text for the **Filter** button.
   */
  filterFilterButton;
  /**
   * Sets the text for the **Clear filter** button.
   */
  filterClearButton;
  /**
   * Sets the title for the **Close** button of the ActionSheet that appears instead of the Popup on small screens in adaptive mode.
   */
  adaptiveCloseButtonTitle;
  /**
   * Sets the title for the **Back** button of the ActionSheet that appears instead of the Popup on small screens in adaptive mode.
   */
  adaptiveBackButtonTitle;
  /**
   * Sets the text for the `And` filter logic.
   */
  filterAndLogic;
  /**
   * Sets the text for the `Or` filter logic.
   */
  filterOrLogic;
  /**
   * Sets the button text for the Filter toolbar tool.
   */
  filterToolbarToolText;
  /**
   * Sets the loading text. The `loading` property a Grid accessibility feature.
   * Screen readers can detect its value, but it is not visible otherwise.
   */
  loading;
  /**
   * Sets the text for the `aria-label` attribute on the Grid focusable element.
   */
  gridLabel;
  /**
   * Sets the title for the column menu icon.
   *
   * The title includes the column name and a localizable string.
   * For example, for a column named **Product Name**, the default title is **Product Name Column Menu**.
   *
   * You can reorder the column name and the localizable part by using a placeholder in `columnMenu`.
   * Use `{columnName}` to insert the column name, for example, **menu for {columnName}**.
   * [See example](slug:globalization_grid#toc-custom-messages).
   */
  columnMenu;
  /**
   * Sets the text in the column menu for the set column position item.
   */
  setColumnPosition;
  /**
   * Sets the text for the Grid Column Chooser and Column Chooser toolbar tool.
   */
  columns;
  /**
   * Sets the text for the **Select all** checkbox in the Column Chooser.
   */
  columnChooserSelectAll;
  /**
   * The message for the selected columns count in the Column Chooser.
   * Follows the pattern **{selectedColumnsCount} Selected items ** by default.
   *
   * The message consists of two parts - selected columns count and a localizable string.
   * To allow for reordering its parts, the `columnChooserSelectedColumnsCount` input accepts a string with a placeholder for the selected columns count.
   * The `{selectedColumnsCount}` placeholder will be replaced internally with the respective actual value.
   */
  columnChooserSelectedColumnsCount;
  /**
   * Sets the subtitle for the adaptive Grid Column Chooser and Column Chooser toolbar tool.
   */
  columnsSubtitle;
  /**
   * Sets the title for the adaptive Filter Toolbar Tool and Filter Menu.
   */
  adaptiveFilterTitle;
  /**
   * Sets the title for the adaptive Sort Toolbar Tool.
   */
  adaptiveSortTitle;
  /**
   * Sets the title for the adaptive Group Toolbar Tool.
   */
  adaptiveGroupTitle;
  /**
   * Sets the text for the **Clear all filters** button in the Filter Toolbar Tool and adaptive Filter Toolbar Tool.
   */
  filterClearAllButton;
  /**
   * Sets the text for the **Clear grouping** button in the Group Toolbar Tool and adaptive Group Toolbar Tool.
   */
  groupClearButton;
  /**
   * Sets the text for the clear sort button in the Sort Toolbar Tool and adaptive Sort Toolbar Tool.
   */
  sortClearButton;
  /**
   * Sets the text for the **Done** sort button.
   */
  sortDoneButton;
  /**
   * Sets the text for the **Done** group button in the adaptive Group Toolbar Tool.
   */
  groupDoneButton;
  /**
   * Sets the text in the column menu for the lock item.
   */
  lock;
  /**
   * Sets the text in the column menu for the unlock item.
   */
  unlock;
  /**
   * Sets the text in the column menu for the stick item.
   */
  stick;
  /**
   * Sets the text in the column menu for the unstick item.
   */
  unstick;
  /**
   * Sets the label for the sort icon.
   */
  sortable;
  /**
   * Sets the text in the column menu for the ascending sort item.
   */
  sortAscending;
  /**
   * Sets the text in the column menu for the descending sort item.
   */
  sortDescending;
  /**
   * Sets the text in the column menu for the autosize this column item.
   */
  autosizeThisColumn;
  /**
   * Sets the text in the column menu for the autosize all columns item.
   */
  autosizeAllColumns;
  /**
   * Sets the title of the Group Chip for ascending sorting order of groups.
   */
  sortedAscending;
  /**
   * Sets the title of the Group Chip for descending sorting order of groups.
   */
  sortedDescending;
  /**
   * Sets the status announcement when a column is no longer sorted.
   */
  sortedDefault;
  /**
   * Sets the button text for the Sort toolbar tool.
   */
  sortToolbarToolText;
  /**
   * Sets the text in the column menu or column chooser item for the **Apply** button.
   */
  columnsApply;
  /**
   * Sets the text in the column menu or column chooser item for the **Reset** button.
   */
  columnsReset;
  /**
   * Sets the title for the expand icon of detail rows. Applies also to the expand button text in stacked mode.
   */
  detailExpand;
  /**
   * Sets the title for the collapse icon of detail rows. Applies also to the collapse button text in stacked mode.
   */
  detailCollapse;
  /**
   * Sets the text for the **Today** button in the Date filter.
   */
  filterDateToday;
  /**
   * Sets the title for the **Toggle** button in the Date filter.
   */
  filterDateToggle;
  /**
   * Sets the title for the **Decrement** button in the Numeric filter.
   */
  filterNumericDecrement;
  /**
   * Sets the title for the **Increment** button in the Numeric filter.
   */
  filterNumericIncrement;
  /**
   * Sets the labels of the checkboxes in the checkbox column.
   */
  selectionCheckboxLabel;
  /**
   * Sets the label for the select all checkbox in the checkbox column.
   */
  selectAllCheckboxLabel;
  /**
   * Sets the text for the title and `aria-label` attributes on the collapse icon of group rows.
   */
  groupCollapse;
  /**
   * Sets the text for the title and `aria-label` attributes on the expand icon of group rows.
   */
  groupExpand;
  /**
   * Sets the label for the top toolbar.
   */
  topToolbarLabel;
  /**
   * Sets the label for the bottom toolbar.
   */
  bottomToolbarLabel;
  /**
   * Sets the text for the Grid Edit toolbar tool.
   */
  editToolbarToolText;
  /**
   * Sets the text for the Grid Save toolbar tool.
   */
  saveToolbarToolText;
  /**
   * Sets the text for the Grid Add toolbar tool.
   */
  addToolbarToolText;
  /**
   * Sets the text for the Grid Cancel toolbar tool.
   */
  cancelToolbarToolText;
  /**
   * Sets the text for the Grid Remove toolbar tool.
   */
  removeToolbarToolText;
  /**
   * Sets the text for the Grid Excel Export toolbar tool.
   */
  excelExportToolbarToolText;
  /**
   * Sets the text for the Grid PDF Export toolbar tool.
   */
  pdfExportToolbarToolText;
  /**
   * Sets the label for the group panel toolbar.
   */
  groupPanelLabel;
  /**
   * Sets the label for the Grid drag row handle.
   */
  dragRowHandleLabel;
  /**
   * Sets the title for the column menu **Filter** tab.
   */
  columnMenuFilterTabTitle;
  /**
   * Sets the title for the column menu **General** tab.
   */
  columnMenuGeneralTabTitle;
  /**
   * Sets the title for the column menu **Columns** tab.
   */
  columnMenuColumnsTabTitle;
  /**
   * Sets the text for the Group pane Chip Menu **Move as previous** item.
   */
  groupChipMenuPrevious;
  /**
   * Sets the text for the Group pane Chip Menu **Move as next** item.
   */
  groupChipMenuNext;
  /**
   * Sets the button text for the Group toolbar tool.
   */
  groupToolbarToolText;
  /**
   * Sets the default text for a form validation error when you use built-in external editing.
   * <br/><br/>
   * The text includes the data item property name, the error name from the `FormControl` object, and a localizable string.
   * <br/><br/>
   * For a field named `ProductName` and an error named `required`, the default error text is `ProductName has required validation error`.
   * <br/><br/>
   * To customize the error text, use the `{errorName}` and `{fieldName}` placeholders and a custom localizable string.
   * For example, `{errorName} detected for {fieldName} field`.
   * <br/><br/>
   * The `{errorName}` and `{fieldName}` placeholders are replaced with the field and error names for the invalid form control,
   * and the error message is rendered as `required error detected for ProductName field`.
   * [See example](slug:globalization_grid#toc-custom-messages).
   */
  formValidationErrorText;
  /**
   * Sets the title for the remove item confirmation Dialog.
   */
  removeConfirmationDialogTitle;
  /**
   * Sets the content for the remove item confirmation Dialog.
   */
  removeConfirmationDialogContent;
  /**
   * Sets the text for the confirm action button in the remove confirmation Dialog.
   */
  removeConfirmationDialogConfirmText;
  /**
   * Sets the text for the reject action button in the remove confirmation Dialog.
   */
  removeConfirmationDialogRejectText;
  /**
   * Sets the title for the external editing Dialog or ActionSheet when editing an item.
   */
  externalEditingTitle;
  /**
   * Sets the title for the external editing Dialog or ActionSheet when adding a new item.
   */
  externalEditingAddTitle;
  /**
   * Sets the text for the external editing Dialog <b>Save</b> button.
   */
  externalEditingSaveText;
  /**
   * Sets the text for the external editing Dialog <b>Cancel</b> button.
   */
  externalEditingCancelText;
  /**
   * The placeholder text for the multi-checkbox filter search input
   */
  multiCheckboxFilterSearchPlaceholder;
  /**
   * The label for the multi-checkbox filter select all option
   */
  multiCheckboxFilterSelectAllLabel;
  /**
   * The text for the multi-checkbox filter selected items count
   *
   * The text includes the selected items count and a localizable string.
   * For 3 selected items the default text is `3 selected items`.
   *
   * To customize the text, use the `{selectedItemsCount}` placeholder and a custom localizable string.
   * For example, `{selectedItemsCount} items are selected`.
   *
   * The `{selectedItemsCount}` placeholder is replaced with the count of selected items,
   * and the message is rendered as `3 items are selected`.
   */
  multiCheckboxFilterSelectedItemsCount;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵGridMessages_BaseFactory;
    return function GridMessages_Factory(__ngFactoryType__) {
      return (ɵGridMessages_BaseFactory || (ɵGridMessages_BaseFactory = ɵɵgetInheritedFactory(_GridMessages)))(__ngFactoryType__ || _GridMessages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _GridMessages,
    selectors: [["kendo-grid-messages-base"]],
    inputs: {
      groupPanelEmpty: "groupPanelEmpty",
      noRecords: "noRecords",
      pagerLabel: "pagerLabel",
      pagerFirstPage: "pagerFirstPage",
      pagerLastPage: "pagerLastPage",
      pagerPreviousPage: "pagerPreviousPage",
      pagerNextPage: "pagerNextPage",
      pagerPage: "pagerPage",
      pagerItemsPerPage: "pagerItemsPerPage",
      pagerOf: "pagerOf",
      pagerItems: "pagerItems",
      pagerPageNumberInputTitle: "pagerPageNumberInputTitle",
      pagerInputLabel: "pagerInputLabel",
      pagerSelectPage: "pagerSelectPage",
      filter: "filter",
      filterInputLabel: "filterInputLabel",
      filterMenuTitle: "filterMenuTitle",
      filterMenuOperatorsDropDownLabel: "filterMenuOperatorsDropDownLabel",
      filterMenuLogicDropDownLabel: "filterMenuLogicDropDownLabel",
      filterCellOperatorLabel: "filterCellOperatorLabel",
      booleanFilterCellLabel: "booleanFilterCellLabel",
      aiAssistantApplyButtonText: "aiAssistantApplyButtonText",
      aiAssistantToolbarToolText: "aiAssistantToolbarToolText",
      aiAssistantWindowTitle: "aiAssistantWindowTitle",
      aiAssistantWindowCloseTitle: "aiAssistantWindowCloseTitle",
      aiAssistantOutputCardTitle: "aiAssistantOutputCardTitle",
      aiAssistantOutputCardBodyContent: "aiAssistantOutputCardBodyContent",
      aiAssistantSelectionNotEnabled: "aiAssistantSelectionNotEnabled",
      aiAssistantSelectionRowModeRequired: "aiAssistantSelectionRowModeRequired",
      aiAssistantSelectionCellModeRequired: "aiAssistantSelectionCellModeRequired",
      aiAssistantWindowMaximizeTitle: "aiAssistantWindowMaximizeTitle",
      aiAssistantWindowMinimizeTitle: "aiAssistantWindowMinimizeTitle",
      aiAssistantWindowRestoreTitle: "aiAssistantWindowRestoreTitle",
      filterEqOperator: "filterEqOperator",
      filterNotEqOperator: "filterNotEqOperator",
      filterIsNullOperator: "filterIsNullOperator",
      filterIsNotNullOperator: "filterIsNotNullOperator",
      filterIsEmptyOperator: "filterIsEmptyOperator",
      filterIsNotEmptyOperator: "filterIsNotEmptyOperator",
      filterStartsWithOperator: "filterStartsWithOperator",
      filterContainsOperator: "filterContainsOperator",
      filterNotContainsOperator: "filterNotContainsOperator",
      filterEndsWithOperator: "filterEndsWithOperator",
      filterGteOperator: "filterGteOperator",
      filterGtOperator: "filterGtOperator",
      filterLteOperator: "filterLteOperator",
      filterLtOperator: "filterLtOperator",
      filterIsTrue: "filterIsTrue",
      filterIsFalse: "filterIsFalse",
      filterBooleanAll: "filterBooleanAll",
      adaptiveFilterOperatorsTitle: "adaptiveFilterOperatorsTitle",
      filterAfterOrEqualOperator: "filterAfterOrEqualOperator",
      filterAfterOperator: "filterAfterOperator",
      filterBeforeOperator: "filterBeforeOperator",
      filterBeforeOrEqualOperator: "filterBeforeOrEqualOperator",
      filterFilterButton: "filterFilterButton",
      filterClearButton: "filterClearButton",
      adaptiveCloseButtonTitle: "adaptiveCloseButtonTitle",
      adaptiveBackButtonTitle: "adaptiveBackButtonTitle",
      filterAndLogic: "filterAndLogic",
      filterOrLogic: "filterOrLogic",
      filterToolbarToolText: "filterToolbarToolText",
      loading: "loading",
      gridLabel: "gridLabel",
      columnMenu: "columnMenu",
      setColumnPosition: "setColumnPosition",
      columns: "columns",
      columnChooserSelectAll: "columnChooserSelectAll",
      columnChooserSelectedColumnsCount: "columnChooserSelectedColumnsCount",
      columnsSubtitle: "columnsSubtitle",
      adaptiveFilterTitle: "adaptiveFilterTitle",
      adaptiveSortTitle: "adaptiveSortTitle",
      adaptiveGroupTitle: "adaptiveGroupTitle",
      filterClearAllButton: "filterClearAllButton",
      groupClearButton: "groupClearButton",
      sortClearButton: "sortClearButton",
      sortDoneButton: "sortDoneButton",
      groupDoneButton: "groupDoneButton",
      lock: "lock",
      unlock: "unlock",
      stick: "stick",
      unstick: "unstick",
      sortable: "sortable",
      sortAscending: "sortAscending",
      sortDescending: "sortDescending",
      autosizeThisColumn: "autosizeThisColumn",
      autosizeAllColumns: "autosizeAllColumns",
      sortedAscending: "sortedAscending",
      sortedDescending: "sortedDescending",
      sortedDefault: "sortedDefault",
      sortToolbarToolText: "sortToolbarToolText",
      columnsApply: "columnsApply",
      columnsReset: "columnsReset",
      detailExpand: "detailExpand",
      detailCollapse: "detailCollapse",
      filterDateToday: "filterDateToday",
      filterDateToggle: "filterDateToggle",
      filterNumericDecrement: "filterNumericDecrement",
      filterNumericIncrement: "filterNumericIncrement",
      selectionCheckboxLabel: "selectionCheckboxLabel",
      selectAllCheckboxLabel: "selectAllCheckboxLabel",
      groupCollapse: "groupCollapse",
      groupExpand: "groupExpand",
      topToolbarLabel: "topToolbarLabel",
      bottomToolbarLabel: "bottomToolbarLabel",
      editToolbarToolText: "editToolbarToolText",
      saveToolbarToolText: "saveToolbarToolText",
      addToolbarToolText: "addToolbarToolText",
      cancelToolbarToolText: "cancelToolbarToolText",
      removeToolbarToolText: "removeToolbarToolText",
      excelExportToolbarToolText: "excelExportToolbarToolText",
      pdfExportToolbarToolText: "pdfExportToolbarToolText",
      groupPanelLabel: "groupPanelLabel",
      dragRowHandleLabel: "dragRowHandleLabel",
      columnMenuFilterTabTitle: "columnMenuFilterTabTitle",
      columnMenuGeneralTabTitle: "columnMenuGeneralTabTitle",
      columnMenuColumnsTabTitle: "columnMenuColumnsTabTitle",
      groupChipMenuPrevious: "groupChipMenuPrevious",
      groupChipMenuNext: "groupChipMenuNext",
      groupToolbarToolText: "groupToolbarToolText",
      formValidationErrorText: "formValidationErrorText",
      removeConfirmationDialogTitle: "removeConfirmationDialogTitle",
      removeConfirmationDialogContent: "removeConfirmationDialogContent",
      removeConfirmationDialogConfirmText: "removeConfirmationDialogConfirmText",
      removeConfirmationDialogRejectText: "removeConfirmationDialogRejectText",
      externalEditingTitle: "externalEditingTitle",
      externalEditingAddTitle: "externalEditingAddTitle",
      externalEditingSaveText: "externalEditingSaveText",
      externalEditingCancelText: "externalEditingCancelText",
      multiCheckboxFilterSearchPlaceholder: "multiCheckboxFilterSearchPlaceholder",
      multiCheckboxFilterSelectAllLabel: "multiCheckboxFilterSelectAllLabel",
      multiCheckboxFilterSelectedItemsCount: "multiCheckboxFilterSelectedItemsCount"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GridMessages, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line @angular-eslint/directive-selector
      selector: "kendo-grid-messages-base"
    }]
  }], null, {
    groupPanelEmpty: [{
      type: Input
    }],
    noRecords: [{
      type: Input
    }],
    pagerLabel: [{
      type: Input
    }],
    pagerFirstPage: [{
      type: Input
    }],
    pagerLastPage: [{
      type: Input
    }],
    pagerPreviousPage: [{
      type: Input
    }],
    pagerNextPage: [{
      type: Input
    }],
    pagerPage: [{
      type: Input
    }],
    pagerItemsPerPage: [{
      type: Input
    }],
    pagerOf: [{
      type: Input
    }],
    pagerItems: [{
      type: Input
    }],
    pagerPageNumberInputTitle: [{
      type: Input
    }],
    pagerInputLabel: [{
      type: Input
    }],
    pagerSelectPage: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    filterInputLabel: [{
      type: Input
    }],
    filterMenuTitle: [{
      type: Input
    }],
    filterMenuOperatorsDropDownLabel: [{
      type: Input
    }],
    filterMenuLogicDropDownLabel: [{
      type: Input
    }],
    filterCellOperatorLabel: [{
      type: Input
    }],
    booleanFilterCellLabel: [{
      type: Input
    }],
    aiAssistantApplyButtonText: [{
      type: Input
    }],
    aiAssistantToolbarToolText: [{
      type: Input
    }],
    aiAssistantWindowTitle: [{
      type: Input
    }],
    aiAssistantWindowCloseTitle: [{
      type: Input
    }],
    aiAssistantOutputCardTitle: [{
      type: Input
    }],
    aiAssistantOutputCardBodyContent: [{
      type: Input
    }],
    aiAssistantSelectionNotEnabled: [{
      type: Input
    }],
    aiAssistantSelectionRowModeRequired: [{
      type: Input
    }],
    aiAssistantSelectionCellModeRequired: [{
      type: Input
    }],
    aiAssistantWindowMaximizeTitle: [{
      type: Input
    }],
    aiAssistantWindowMinimizeTitle: [{
      type: Input
    }],
    aiAssistantWindowRestoreTitle: [{
      type: Input
    }],
    filterEqOperator: [{
      type: Input
    }],
    filterNotEqOperator: [{
      type: Input
    }],
    filterIsNullOperator: [{
      type: Input
    }],
    filterIsNotNullOperator: [{
      type: Input
    }],
    filterIsEmptyOperator: [{
      type: Input
    }],
    filterIsNotEmptyOperator: [{
      type: Input
    }],
    filterStartsWithOperator: [{
      type: Input
    }],
    filterContainsOperator: [{
      type: Input
    }],
    filterNotContainsOperator: [{
      type: Input
    }],
    filterEndsWithOperator: [{
      type: Input
    }],
    filterGteOperator: [{
      type: Input
    }],
    filterGtOperator: [{
      type: Input
    }],
    filterLteOperator: [{
      type: Input
    }],
    filterLtOperator: [{
      type: Input
    }],
    filterIsTrue: [{
      type: Input
    }],
    filterIsFalse: [{
      type: Input
    }],
    filterBooleanAll: [{
      type: Input
    }],
    adaptiveFilterOperatorsTitle: [{
      type: Input
    }],
    filterAfterOrEqualOperator: [{
      type: Input
    }],
    filterAfterOperator: [{
      type: Input
    }],
    filterBeforeOperator: [{
      type: Input
    }],
    filterBeforeOrEqualOperator: [{
      type: Input
    }],
    filterFilterButton: [{
      type: Input
    }],
    filterClearButton: [{
      type: Input
    }],
    adaptiveCloseButtonTitle: [{
      type: Input
    }],
    adaptiveBackButtonTitle: [{
      type: Input
    }],
    filterAndLogic: [{
      type: Input
    }],
    filterOrLogic: [{
      type: Input
    }],
    filterToolbarToolText: [{
      type: Input
    }],
    loading: [{
      type: Input
    }],
    gridLabel: [{
      type: Input
    }],
    columnMenu: [{
      type: Input
    }],
    setColumnPosition: [{
      type: Input
    }],
    columns: [{
      type: Input
    }],
    columnChooserSelectAll: [{
      type: Input
    }],
    columnChooserSelectedColumnsCount: [{
      type: Input
    }],
    columnsSubtitle: [{
      type: Input
    }],
    adaptiveFilterTitle: [{
      type: Input
    }],
    adaptiveSortTitle: [{
      type: Input
    }],
    adaptiveGroupTitle: [{
      type: Input
    }],
    filterClearAllButton: [{
      type: Input
    }],
    groupClearButton: [{
      type: Input
    }],
    sortClearButton: [{
      type: Input
    }],
    sortDoneButton: [{
      type: Input
    }],
    groupDoneButton: [{
      type: Input
    }],
    lock: [{
      type: Input
    }],
    unlock: [{
      type: Input
    }],
    stick: [{
      type: Input
    }],
    unstick: [{
      type: Input
    }],
    sortable: [{
      type: Input
    }],
    sortAscending: [{
      type: Input
    }],
    sortDescending: [{
      type: Input
    }],
    autosizeThisColumn: [{
      type: Input
    }],
    autosizeAllColumns: [{
      type: Input
    }],
    sortedAscending: [{
      type: Input
    }],
    sortedDescending: [{
      type: Input
    }],
    sortedDefault: [{
      type: Input
    }],
    sortToolbarToolText: [{
      type: Input
    }],
    columnsApply: [{
      type: Input
    }],
    columnsReset: [{
      type: Input
    }],
    detailExpand: [{
      type: Input
    }],
    detailCollapse: [{
      type: Input
    }],
    filterDateToday: [{
      type: Input
    }],
    filterDateToggle: [{
      type: Input
    }],
    filterNumericDecrement: [{
      type: Input
    }],
    filterNumericIncrement: [{
      type: Input
    }],
    selectionCheckboxLabel: [{
      type: Input
    }],
    selectAllCheckboxLabel: [{
      type: Input
    }],
    groupCollapse: [{
      type: Input
    }],
    groupExpand: [{
      type: Input
    }],
    topToolbarLabel: [{
      type: Input
    }],
    bottomToolbarLabel: [{
      type: Input
    }],
    editToolbarToolText: [{
      type: Input
    }],
    saveToolbarToolText: [{
      type: Input
    }],
    addToolbarToolText: [{
      type: Input
    }],
    cancelToolbarToolText: [{
      type: Input
    }],
    removeToolbarToolText: [{
      type: Input
    }],
    excelExportToolbarToolText: [{
      type: Input
    }],
    pdfExportToolbarToolText: [{
      type: Input
    }],
    groupPanelLabel: [{
      type: Input
    }],
    dragRowHandleLabel: [{
      type: Input
    }],
    columnMenuFilterTabTitle: [{
      type: Input
    }],
    columnMenuGeneralTabTitle: [{
      type: Input
    }],
    columnMenuColumnsTabTitle: [{
      type: Input
    }],
    groupChipMenuPrevious: [{
      type: Input
    }],
    groupChipMenuNext: [{
      type: Input
    }],
    groupToolbarToolText: [{
      type: Input
    }],
    formValidationErrorText: [{
      type: Input
    }],
    removeConfirmationDialogTitle: [{
      type: Input
    }],
    removeConfirmationDialogContent: [{
      type: Input
    }],
    removeConfirmationDialogConfirmText: [{
      type: Input
    }],
    removeConfirmationDialogRejectText: [{
      type: Input
    }],
    externalEditingTitle: [{
      type: Input
    }],
    externalEditingAddTitle: [{
      type: Input
    }],
    externalEditingSaveText: [{
      type: Input
    }],
    externalEditingCancelText: [{
      type: Input
    }],
    multiCheckboxFilterSearchPlaceholder: [{
      type: Input
    }],
    multiCheckboxFilterSelectAllLabel: [{
      type: Input
    }],
    multiCheckboxFilterSelectedItemsCount: [{
      type: Input
    }]
  });
})();
var LocalizedMessagesDirective7 = class _LocalizedMessagesDirective extends GridMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function LocalizedMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LocalizedMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LocalizedMessagesDirective,
    selectors: [["", "kendoGridLocalizedMessages", ""]],
    features: [ɵɵProvidersFeature([{
      provide: GridMessages,
      useExisting: forwardRef(() => _LocalizedMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalizedMessagesDirective7, [{
    type: Directive,
    args: [{
      providers: [{
        provide: GridMessages,
        useExisting: forwardRef(() => LocalizedMessagesDirective7)
      }],
      selector: "[kendoGridLocalizedMessages]",
      standalone: true
    }]
  }], () => [{
    type: LocalizationService
  }], null);
})();
var FilterToolbarToolComponent = class _FilterToolbarToolComponent {
  element;
  filterService;
  ctx;
  columnInfoService;
  ngZone;
  adaptiveGridService;
  filterItems;
  menuItems;
  filterContainers;
  close = new EventEmitter();
  get hostStyles() {
    return {
      "maxHeight": "400px",
      "overflowX": "hidden",
      "overflowY": "auto"
    };
  }
  columnMenuService;
  columns;
  filter;
  isFilterApplied(column) {
    if (!this.filter?.filters) {
      return false;
    }
    if (Array.isArray(this.filter.filters)) {
      for (const filterGroup of this.filter.filters) {
        if (filterGroup.filters && Array.isArray(filterGroup.filters)) {
          for (const filter3 of filterGroup.filters) {
            if (filter3.field === column.field) {
              return true;
            }
          }
        } else if (filterGroup.field === column.field) {
          return true;
        }
      }
    }
    return false;
  }
  isItemFocused(filterItem) {
    return this.currentFocusedItem === filterItem;
  }
  onItemFocus(item) {
    this.currentFocusedItem = item;
  }
  onItemFocusOut() {
    this.currentFocusedItem = null;
  }
  currentFocusedItem = null;
  subscriptions;
  constructor(element, filterService, ctx, columnInfoService, ngZone, adaptiveGridService) {
    this.element = element;
    this.filterService = filterService;
    this.ctx = ctx;
    this.columnInfoService = columnInfoService;
    this.ngZone = ngZone;
    this.adaptiveGridService = adaptiveGridService;
  }
  ngOnInit() {
    this.columns = this.columnInfoService.leafNamedColumns.filter((column) => column?.filterable);
    this.filter = this.ctx.grid.filter;
    this.subscriptions = this.filterService.changes.subscribe((filter3) => {
      this.filter = cloneFilters(filter3);
    });
  }
  ngAfterViewInit() {
    this.ngZone.onStable.pipe(take(1)).subscribe(() => {
      this.filterItems?.get(0)?.nativeElement.focus({
        preventScroll: true
      });
    });
  }
  ngOnDestroy() {
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
    }
  }
  navigateView(column) {
    if (this.ctx.grid.isActionSheetExpanded && this.adaptiveGridService.viewType === "filterToolbarTool") {
      const componentRef = this.ctx.grid.adaptiveRenderer.filterToolbarToolTemplate.createComponent(FilterMenuContainerComponent);
      componentRef.instance.column = this.getColumnComponent(column);
      componentRef.instance.filter = this.filter;
      this.subscriptions.add(componentRef.instance.close.subscribe(() => {
        this.adaptiveGridService.reset();
      }));
      this.adaptiveGridService.filterMenuContainerComponentRef = componentRef;
      this.adaptiveGridService.secondaryView = "columnFilter";
      this.adaptiveGridService.column = this.getColumnComponent(column);
      this.ctx.grid.adaptiveRenderer.actionSheet.nextView();
    }
  }
  getColumnComponent(column) {
    return column;
  }
  handleClose(filterItem) {
    filterItem.expanded = false;
    filterItem.contentState = "collapsed";
    const filterContainer = this.filterContainers.find((container) => container.column === filterItem.column);
    if (filterContainer) {
      filterContainer.resetChildFilters();
    }
  }
  toggleItem(event, index) {
    const menuItem = this.menuItems.get(index);
    if (!menuItem || event.target.closest(".k-filter-menu-container")) {
      return;
    }
    if (menuItem.expanded) {
      this.filterContainers.get(index).isExpanded = false;
      menuItem.expanded = false;
      menuItem.contentState = "collapsed";
    } else {
      this.filterContainers.get(index).isExpanded = true;
      menuItem.expanded = true;
      menuItem.contentState = "expanded";
    }
  }
  static ɵfac = function FilterToolbarToolComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FilterToolbarToolComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(FilterService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ColumnInfoService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(AdaptiveGridService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _FilterToolbarToolComponent,
    selectors: [["kendo-filter-toolbar-tool"]],
    viewQuery: function FilterToolbarToolComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c552, 5, ElementRef)(_c552, 5)(_c562, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.filterItems = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.menuItems = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.filterContainers = _t);
      }
    },
    outputs: {
      close: "close"
    },
    decls: 3,
    vars: 2,
    consts: [["filterItem", ""], ["filterContainer", ""], ["role", "button", "tabindex", "0", 1, "k-columnmenu-item-wrapper", 3, "column", "text", "indicatorIcon", "expanded", "focused"], ["role", "button", "tabindex", "0", 1, "k-columnmenu-item-wrapper", 3, "focus", "focusout", "keydown.enter", "itemClick", "column", "text", "indicatorIcon", "expanded", "focused"], ["kendoGridColumnMenuItemContentTemplate", ""], [3, "keydown.shift.tab", "close", "column", "filter", "isExpanded"]],
    template: function FilterToolbarToolComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div");
        ɵɵrepeaterCreate(1, FilterToolbarToolComponent_For_2_Template, 3, 5, "kendo-grid-columnmenu-item", 2, ɵɵrepeaterTrackByIdentity);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵstyleMap(ctx.hostStyles);
        ɵɵadvance();
        ɵɵrepeater(ctx.columns);
      }
    },
    dependencies: [FilterMenuContainerComponent, ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterToolbarToolComponent, [{
    type: Component,
    args: [{
      selector: "kendo-filter-toolbar-tool",
      template: `
        <div [style]="hostStyles">
          @for (column of columns; track column; let i = $index) {
            <kendo-grid-columnmenu-item
              class="k-columnmenu-item-wrapper" #filterItem
              role="button"
              tabindex="0"
              [column]="getColumnComponent(column)"
              [text]="column.title || getColumnComponent(column).field"
              (focus)="onItemFocus(filterItem)"
              (focusout)="onItemFocusOut()"
              (keydown.enter)="toggleItem($event, i)"
              [indicatorIcon]="isFilterApplied(column)"
              (itemClick)="navigateView(getColumnComponent(column))"
              [expanded]="false"
              [focused]="isItemFocused(filterItem)">
              <ng-template kendoGridColumnMenuItemContentTemplate>
                <kendo-grid-filter-menu-container
                  #filterContainer
                  (keydown.shift.tab)="$event.stopImmediatePropagation()"
                  [column]="getColumnComponent(column)"
                  [filter]="filter"
                  [isExpanded]="false"
                  (close)="handleClose(filterItem)">
                </kendo-grid-filter-menu-container>
              </ng-template>
            </kendo-grid-columnmenu-item>
          }
        </div>
        `,
      standalone: true,
      imports: [KENDO_BUTTON, FilterMenuContainerComponent, ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective]
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: FilterService
  }, {
    type: ContextService
  }, {
    type: ColumnInfoService
  }, {
    type: NgZone
  }, {
    type: AdaptiveGridService
  }], {
    filterItems: [{
      type: ViewChildren,
      args: ["filterItem", {
        read: ElementRef
      }]
    }],
    menuItems: [{
      type: ViewChildren,
      args: ["filterItem"]
    }],
    filterContainers: [{
      type: ViewChildren,
      args: ["filterContainer"]
    }],
    close: [{
      type: Output
    }]
  });
})();
var directions = (initialDirection) => initialDirection === "asc" ? ["asc", "desc"] : ["desc", "asc"];
var SortToolbarToolComponent = class _SortToolbarToolComponent {
  element;
  ngZone;
  sortItems;
  wrapperClasses = true;
  onEscKeyDown(event) {
    event.preventDefault();
    this.hostButton?.focus(event);
    this.close.emit();
  }
  close = new EventEmitter();
  sortClear = new EventEmitter();
  sort = new Array();
  columns = [];
  sortAscSmallIcon = sortAscSmallIcon;
  sortDescSmallIcon = sortDescSmallIcon;
  clearIcon = xIcon;
  _columnInfoService;
  set columnInfoService(columnInfoService) {
    this._columnInfoService = columnInfoService;
    this.columns = this.columnInfoService.leafNamedColumns.filter((column) => column?.sortable);
  }
  get columnInfoService() {
    return this._columnInfoService;
  }
  _ctx;
  set ctx(ctx) {
    this._ctx = ctx;
    this.sort = ctx.grid.sort;
  }
  get ctx() {
    return this._ctx;
  }
  _sortService;
  set sortService(sortService) {
    this._sortService = sortService;
    this.subscription = this._sortService.changes.subscribe((sort2) => {
      this.sort = sort2;
    });
  }
  get sortService() {
    return this._sortService;
  }
  subscription;
  hostButton;
  constructor(element, ngZone) {
    this.element = element;
    this.ngZone = ngZone;
  }
  ngAfterViewInit() {
    this.ngZone.onStable.pipe(take(1)).subscribe(() => {
      this.sortItems?.get(0)?.nativeElement.focus({
        preventScroll: true
      });
    });
  }
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
  }
  toggleSort(column, ev) {
    if (this.hostButton.location !== "toolbar") {
      ev.stopImmediatePropagation();
    }
    const field = column?.field;
    if (!field) {
      return;
    }
    const descriptor = this.getDescriptor(column);
    this.sort = descriptor;
    this.sortService.sort(descriptor);
  }
  getColumnComponent(column) {
    return column;
  }
  sortDescriptor(field) {
    return this.sort.find((item) => item.field === field) || {
      field
    };
  }
  getDescriptor(column) {
    const {
      allowUnsort,
      mode,
      initialDirection
    } = normalize$1(this.ctx.grid.sortable, column.sortable);
    const field = column?.field;
    if (!field) {
      return;
    }
    const descriptorT = this.sort.find((item) => item.field === field) || {
      field
    };
    const [first, second] = directions(initialDirection);
    let dir = first;
    if (descriptorT.dir === first) {
      dir = second;
    } else if (descriptorT.dir === second && allowUnsort) {
      dir = void 0;
    }
    const descriptor = {
      field,
      dir
    };
    if (mode === "single") {
      return [descriptor];
    }
    return [...this.sort.filter((desc) => desc.field !== field), descriptor];
  }
  showSortNumbering(column) {
    return this.sort && this.sort.filter(({
      dir
    }) => isPresent(dir)).length > 1 && this.sortOrder(column.field) > 0;
  }
  sortOrder(field) {
    return this.sort.filter(({
      dir
    }) => isPresent(dir)).findIndex((x) => x.field === field) + 1;
  }
  clearSorting() {
    if (!this.sort || this.sort.length === 0) {
      return;
    }
    this.sort = [];
    this.sortService.sort([]);
    this.sortClear.emit();
  }
  static ɵfac = function SortToolbarToolComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SortToolbarToolComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _SortToolbarToolComponent,
    selectors: [["kendo-sort-toolbar-tool"]],
    viewQuery: function SortToolbarToolComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c572, 5, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.sortItems = _t);
      }
    },
    hostVars: 4,
    hostBindings: function SortToolbarToolComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("keydown.escape", function SortToolbarToolComponent_keydown_escape_HostBindingHandler($event) {
          return ctx.onEscKeyDown($event);
        });
      }
      if (rf & 2) {
        ɵɵclassProp("k-column-menu", ctx.wrapperClasses)("k-column-menu-md", ctx.wrapperClasses);
      }
    },
    outputs: {
      close: "close",
      sortClear: "sortClear"
    },
    decls: 6,
    vars: 8,
    consts: [["sortItem", ""], [1, "k-column-menu-item-wrapper"], ["role", "button", 1, "k-columnmenu-item", 3, "tabindex"], [1, "k-actions", "k-actions-stretched", "k-actions-horizontal", "k-column-menu-footer"], ["kendoButton", "", "icon", "x", 3, "click", "svgIcon"], ["role", "button", 1, "k-columnmenu-item", 3, "click", "keydown.enter", "tabindex"], [1, "k-columnmenu-indicators"], [3, "name", "svgIcon"], [1, "k-sort-index"]],
    template: function SortToolbarToolComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 1);
        ɵɵrepeaterCreate(1, SortToolbarToolComponent_For_2_Template, 6, 4, "div", 2, ɵɵrepeaterTrackByIdentity);
        ɵɵelementEnd();
        ɵɵelementStart(3, "div", 3)(4, "button", 4);
        ɵɵlistener("click", function SortToolbarToolComponent_Template_button_click_4_listener() {
          return ctx.clearSorting();
        });
        ɵɵtext(5);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵstyleProp("max-height", 200, "px")("overflow-x", "hidden")("overflow-y", "auto");
        ɵɵadvance();
        ɵɵrepeater(ctx.columns);
        ɵɵadvance(3);
        ɵɵproperty("svgIcon", ctx.clearIcon);
        ɵɵadvance();
        ɵɵtextInterpolate1(" ", ctx.ctx == null ? null : ctx.ctx.localization.get("sortClearButton"), " ");
      }
    },
    dependencies: [IconWrapperComponent, ButtonComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SortToolbarToolComponent, [{
    type: Component,
    args: [{
      selector: "kendo-sort-toolbar-tool",
      template: `
        <div
          class="k-column-menu-item-wrapper"
          [style.max-height.px]="200"
          [style.overflow-x]="'hidden'"
          [style.overflow-y]="'auto'"
          >
          @for (column of columns; track column) {
            <div
              #sortItem
              role="button"
              class="k-columnmenu-item"
              (click)="toggleSort(column, $event)"
              (keydown.enter)="toggleSort(column, $event)"
              [tabindex]="'0'"
              >
              {{column.title || getColumnComponent(column).field}}
              <span class="k-columnmenu-indicators">
                @if (sortDescriptor(getColumnComponent(column).field).dir) {
                  <kendo-icon-wrapper
                    name="sort-{{sortDescriptor(getColumnComponent(column).field).dir}}-small"
                    [svgIcon]="sortDescriptor(getColumnComponent(column).field).dir === 'asc' ? sortAscSmallIcon : sortDescSmallIcon"
                  ></kendo-icon-wrapper>
                }
                @if (showSortNumbering(getColumnComponent(column))) {
                  <span class="k-sort-index">{{sortOrder(getColumnComponent(column).field)}}</span>
                }
              </span>
            </div>
          }
        </div>
        
        <div class="k-actions k-actions-stretched k-actions-horizontal k-column-menu-footer">
          <button kendoButton
            [svgIcon]="clearIcon"
            icon="x"
            (click)="clearSorting()">
            {{ctx?.localization.get('sortClearButton')}}
          </button>
        </div>
        `,
      standalone: true,
      imports: [IconWrapperComponent, KENDO_BUTTON]
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NgZone
  }], {
    sortItems: [{
      type: ViewChildren,
      args: ["sortItem", {
        read: ElementRef
      }]
    }],
    wrapperClasses: [{
      type: HostBinding,
      args: ["class.k-column-menu"]
    }, {
      type: HostBinding,
      args: ["class.k-column-menu-md"]
    }],
    onEscKeyDown: [{
      type: HostListener,
      args: ["keydown.escape", ["$event"]]
    }],
    close: [{
      type: Output
    }],
    sortClear: [{
      type: Output
    }]
  });
})();
var FormFormFieldComponent = class _FormFormFieldComponent {
  localization;
  cdr;
  control;
  floatingLabel;
  showError;
  input;
  constructor(localization, cdr) {
    this.localization = localization;
    this.cdr = cdr;
  }
  // required to avoid ExpressionChangedAfterItHasBeenCheckedError caused by
  // binding to the label's 'for' attribute dynamically
  ngAfterContentInit() {
    this.cdr.detectChanges();
  }
  messageFor(key, errorName, field) {
    return replaceMessagePlaceholder(replaceMessagePlaceholder(this.localization.get(key), "fieldName", field), "errorName", errorName);
  }
  static ɵfac = function FormFormFieldComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormFormFieldComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _FormFormFieldComponent,
    selectors: [["kendo-form-formfield"]],
    viewQuery: function FormFormFieldComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c58, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.input = _t.first);
      }
    },
    inputs: {
      control: "control",
      floatingLabel: "floatingLabel",
      showError: "showError"
    },
    decls: 9,
    vars: 9,
    consts: [["input", ""], ["cb", ""], [3, "orientation"], ["labelCssClass", "k-form-label", 3, "text"], ["labelCssClass", "k-form-label", 3, "align-items", "text", "for"], [3, "formControl"], [1, "k-form-field-checkbox-wrap"], ["labelCssClass", "k-form-label", 3, "text", "for"], [1, "k-checkbox-label", 3, "for", "text"]],
    template: function FormFormFieldComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "kendo-formfield", 2);
        ɵɵconditionalCreate(1, FormFormFieldComponent_Conditional_1_Template, 4, 4, "kendo-floatinglabel", 3);
        ɵɵconditionalCreate(2, FormFormFieldComponent_Conditional_2_Template, 1, 4, "kendo-label", 4);
        ɵɵconditionalCreate(3, FormFormFieldComponent_Conditional_3_Template, 2, 1, "kendo-textbox", 5);
        ɵɵconditionalCreate(4, FormFormFieldComponent_Conditional_4_Template, 2, 1, "kendo-numerictextbox", 5);
        ɵɵconditionalCreate(5, FormFormFieldComponent_Conditional_5_Template, 2, 1, "kendo-datepicker", 5);
        ɵɵconditionalCreate(6, FormFormFieldComponent_Conditional_6_Template, 4, 2, "div", 6);
        ɵɵconditionalCreate(7, FormFormFieldComponent_Conditional_7_Template, 2, 1, "kendo-formhint");
        ɵɵconditionalCreate(8, FormFormFieldComponent_Conditional_8_Template, 3, 2);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("orientation", ctx.control.orientation);
        ɵɵadvance();
        ɵɵconditional(ctx.control.label && ctx.floatingLabel && ctx.control.dataType !== "boolean" ? 1 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.control.label && !ctx.floatingLabel && ctx.control.dataType !== "boolean" ? 2 : -1);
        ɵɵadvance();
        ɵɵconditional(!ctx.floatingLabel && ctx.control.dataType === "text" ? 3 : -1);
        ɵɵadvance();
        ɵɵconditional(!ctx.floatingLabel && ctx.control.dataType === "numeric" ? 4 : -1);
        ɵɵadvance();
        ɵɵconditional(!ctx.floatingLabel && ctx.control.dataType === "date" ? 5 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.control.label && ctx.control.dataType === "boolean" ? 6 : -1);
        ɵɵadvance();
        ɵɵconditional((ctx.control == null ? null : ctx.control.hint) ? 7 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.showError && (ctx.control.formControl == null ? null : ctx.control.formControl.invalid) && ctx.control.formControl.touched ? 8 : -1);
      }
    },
    dependencies: [KeyValuePipe, ReactiveFormsModule, NgControlStatus, FormControlDirective, LabelComponent, FloatingLabelComponent, FormFieldComponent, HintComponent, ErrorComponent, TextBoxComponent, NumericTextBoxComponent, CheckBoxComponent, DatePickerComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormFormFieldComponent, [{
    type: Component,
    args: [{
      selector: "kendo-form-formfield",
      standalone: true,
      imports: [KeyValuePipe, ReactiveFormsModule, KENDO_LABELS, KENDO_FORMFIELD, KENDO_TEXTBOX, KENDO_NUMERICTEXTBOX, KENDO_BUTTON, KENDO_CHECKBOX, KENDO_DATEPICKER],
      template: `
        <kendo-formfield
          [orientation]="control.orientation">
          @if (control.label && floatingLabel && $any(control.dataType) !== 'boolean') {
            <kendo-floatinglabel
              labelCssClass="k-form-label"
              [text]="control.label">
              @if ($any(control.dataType) === 'text') {
                <kendo-textbox
                [formControl]="control.formControl"></kendo-textbox>
              }
              @if ($any(control.dataType) === 'numeric') {
                <kendo-numerictextbox
                [formControl]="control.formControl"></kendo-numerictextbox>
              }
              @if ($any(control.dataType) === 'date') {
                <kendo-datepicker
                [formControl]="control.formControl"></kendo-datepicker>
              }
            </kendo-floatinglabel>
          }
          @if (control.label && !floatingLabel && $any(control.dataType) !== 'boolean') {
            <kendo-label [style.align-items]="'start'"
              labelCssClass="k-form-label"
              [text]="control.label"
              [for]="input">
            </kendo-label>
          }
          @if (!floatingLabel && (control.dataType) === 'text') {
            <kendo-textbox #input
            [formControl]="control.formControl"></kendo-textbox>
          }
          @if (!floatingLabel && $any(control.dataType) === 'numeric') {
            <kendo-numerictextbox #input
            [formControl]="control.formControl"></kendo-numerictextbox>
          }
          @if (!floatingLabel && $any(control.dataType) === 'date') {
            <kendo-datepicker #input
            [formControl]="control.formControl"></kendo-datepicker>
          }
          @if (control.label && $any(control.dataType) === 'boolean') {
            <div
              class="k-form-field-checkbox-wrap">
              <kendo-checkbox #cb [formControl]="control.formControl"></kendo-checkbox>
              @if (control.label) {
                <kendo-label
                  class="k-checkbox-label"
                  [for]="cb"
                  [text]="control.label">
                </kendo-label>
              }
            </div>
          }
        
          @if (control?.hint) {
            <kendo-formhint>{{control.hint}}</kendo-formhint>
          }
          @if (showError && control.formControl?.invalid && control.formControl.touched) {
            @for (err of control?.formControl?.errors | keyvalue; track err) {
              <kendo-formerror>{{control.errors ? control.errors[err.key] : messageFor('formValidationError', err.key, control.name)}}</kendo-formerror>
            }
          }
        </kendo-formfield>
        `
    }]
  }], () => [{
    type: LocalizationService
  }, {
    type: ChangeDetectorRef
  }], {
    control: [{
      type: Input
    }],
    floatingLabel: [{
      type: Input
    }],
    showError: [{
      type: Input
    }],
    input: [{
      type: ViewChild,
      args: ["input"]
    }]
  });
})();
var idx3 = 0;
var FormComponent = class _FormComponent {
  controls = [];
  set formSettings(value2) {
    this._formSettings = __spreadValues(__spreadValues({}, this._formSettings), value2);
  }
  get formSettings() {
    return this._formSettings;
  }
  formGroup;
  set actionButtons(value2) {
    if (typeof value2 === "boolean") {
      this.normalizeActionButtonSettings(value2);
    } else {
      this._actionButtons = value2;
    }
  }
  get actionButtons() {
    return this._actionButtons;
  }
  formSubmit = new EventEmitter();
  get componentIndex() {
    return idx3++;
  }
  _formSettings = {
    orientation: "vertical",
    showErrors: true,
    floatingLabels: false
  };
  defaultActionButtons = [{
    actionType: "submit",
    text: "Submit",
    svgIcon: saveIcon,
    icon: "save",
    themeColor: "primary"
  }, {
    actionType: "reset",
    svgIcon: cancelIcon,
    text: "Reset",
    icon: "cancel"
  }];
  _actionButtons = this.defaultActionButtons;
  ngOnInit() {
    idx3++;
  }
  normalizeActionButtonSettings(value2) {
    this._actionButtons = value2 ? this.defaultActionButtons : [];
  }
  static ɵfac = function FormComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _FormComponent,
    selectors: [["kendo-grid-external-form"]],
    inputs: {
      controls: "controls",
      formSettings: "formSettings",
      formGroup: "formGroup",
      actionButtons: "actionButtons"
    },
    outputs: {
      formSubmit: "formSubmit"
    },
    decls: 4,
    vars: 4,
    consts: [["template", ""], ["role", "form", 1, "k-form", "k-form-md", 3, "ngSubmit", "reset", "formGroup"], [1, "k-form-buttons"], [3, "control", "showError", "floatingLabel"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["kendoButton", "", 3, "k-form-submit", "size", "themeColor", "rounded", "svgIcon", "icon"], ["kendoButton", "", 3, "size", "themeColor", "rounded", "svgIcon", "icon"]],
    template: function FormComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 1);
        ɵɵlistener("ngSubmit", function FormComponent_Template_div_ngSubmit_0_listener($event) {
          return ctx.formSubmit.next({
            originalEvent: $event,
            formGroup: ctx.formGroup
          });
        })("reset", function FormComponent_Template_div_reset_0_listener($event) {
          return $event.preventDefault();
        });
        ɵɵrepeaterCreate(1, FormComponent_For_2_Template, 4, 1, null, null, ɵɵrepeaterTrackByIdentity);
        ɵɵconditionalCreate(3, FormComponent_Conditional_3_Template, 3, 0, "div", 2);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵclassProp("k-form-horizontal", ctx.formSettings.orientation === "horizontal");
        ɵɵproperty("formGroup", ctx.formGroup);
        ɵɵadvance();
        ɵɵrepeater(ctx.controls);
        ɵɵadvance(2);
        ɵɵconditional(ctx.actionButtons.length ? 3 : -1);
      }
    },
    dependencies: [NgTemplateOutlet, ReactiveFormsModule, NgControlStatusGroup, FormGroupDirective, FormFormFieldComponent, ButtonComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-external-form",
      standalone: true,
      template: `
        <div role="form"
          class="k-form k-form-md"
          [class.k-form-horizontal]="formSettings.orientation === 'horizontal'"
          [formGroup]="formGroup"
          (ngSubmit)="formSubmit.next({originalEvent: $event, formGroup})"
          (reset)="$event.preventDefault()">
          @for (control of controls; track control; let idx = $index) {
            @if (!control.template) {
              <kendo-form-formfield
                [control]="control"
                [showError]="formSettings.showErrors"
              [floatingLabel]="formSettings.floatingLabels"></kendo-form-formfield>
            } @else {
              <ng-container
                [ngTemplateOutlet]="control.template"
              [ngTemplateOutletContext]="control.templateContext"></ng-container>
            }
            <ng-template #template>
              <ng-container
                [ngTemplateOutlet]="control.template"
              [ngTemplateOutletContext]="control.templateContext"></ng-container>
            </ng-template>
          }
          @if ($any(actionButtons).length) {
            <div class="k-form-buttons">
              @for (button of $any(actionButtons); track button) {
                <button kendoButton
                  [class.k-form-submit]="button.actionType === 'submit'"
                  [size]="button.size"
                  [themeColor]="button.themeColor || button.actionType === 'submit' ? 'primary' : undefined"
                  [rounded]="button.rounded"
                  [attr.type]="button.actionType"
                  [svgIcon]="button.svgIcon"
                  [icon]="button.icon">
                  {{button.text}}
                </button>
              }
            </div>
          }
        </div>
        `,
      imports: [NgTemplateOutlet, ReactiveFormsModule, FormFormFieldComponent, KENDO_BUTTON]
    }]
  }], null, {
    controls: [{
      type: Input
    }],
    formSettings: [{
      type: Input
    }],
    formGroup: [{
      type: Input
    }],
    actionButtons: [{
      type: Input
    }],
    formSubmit: [{
      type: Output
    }]
  });
})();
var DialogFormComponent = class _DialogFormComponent extends DialogContentBase {
  localization;
  controls;
  formGroup;
  formSettings;
  saveIcon = saveIcon;
  cancelIcon = cancelIcon;
  constructor(dialogRef, localization) {
    super(dialogRef);
    this.localization = localization;
  }
  save() {
    this.dialog.close({
      text: this.localization.get("externalEditingSaveText")
    });
  }
  cancel() {
    this.dialog.close({
      text: this.localization.get("externalEditingCancelText")
    });
  }
  messageFor(key) {
    return this.localization.get(key);
  }
  static ɵfac = function DialogFormComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DialogFormComponent)(ɵɵdirectiveInject(DialogRef), ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DialogFormComponent,
    selectors: [["kendo-grid-dialog-form"]],
    inputs: {
      controls: "controls",
      formGroup: "formGroup",
      formSettings: "formSettings"
    },
    features: [ɵɵInheritDefinitionFeature],
    decls: 6,
    vars: 10,
    consts: [[3, "controls", "formGroup", "formSettings", "actionButtons"], [3, "layout"], ["kendoButton", "", "themeColor", "primary", 3, "click", "svgIcon", "disabled"], ["kendoButton", "", 3, "click", "svgIcon"]],
    template: function DialogFormComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelement(0, "kendo-grid-external-form", 0);
        ɵɵelementStart(1, "kendo-dialog-actions", 1)(2, "button", 2);
        ɵɵlistener("click", function DialogFormComponent_Template_button_click_2_listener() {
          return ctx.save();
        });
        ɵɵtext(3);
        ɵɵelementEnd();
        ɵɵelementStart(4, "button", 3);
        ɵɵlistener("click", function DialogFormComponent_Template_button_click_4_listener() {
          return ctx.cancel();
        });
        ɵɵtext(5);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵproperty("controls", ctx.controls)("formGroup", ctx.formGroup)("formSettings", ctx.formSettings)("actionButtons", false);
        ɵɵadvance();
        ɵɵproperty("layout", ctx.dialog == null ? null : ctx.dialog.dialog == null ? null : ctx.dialog.dialog.instance == null ? null : ctx.dialog.dialog.instance.actionsLayout);
        ɵɵadvance();
        ɵɵproperty("svgIcon", ctx.saveIcon)("disabled", !ctx.formGroup.valid);
        ɵɵadvance();
        ɵɵtextInterpolate1(" ", ctx.messageFor("externalEditingSaveText"), " ");
        ɵɵadvance();
        ɵɵproperty("svgIcon", ctx.cancelIcon);
        ɵɵadvance();
        ɵɵtextInterpolate1(" ", ctx.messageFor("externalEditingCancelText"), " ");
      }
    },
    dependencies: [FormComponent, DialogActionsComponent, ButtonComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DialogFormComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-dialog-form",
      standalone: true,
      imports: [FormComponent, DialogActionsComponent, KENDO_BUTTON],
      template: `
        <kendo-grid-external-form
            [controls]="controls"
            [formGroup]="formGroup"
            [formSettings]="formSettings"
            [actionButtons]="false"></kendo-grid-external-form>
        <kendo-dialog-actions [layout]="this.dialog?.dialog?.instance?.actionsLayout">
            <button
                kendoButton
                themeColor="primary"
                [svgIcon]="saveIcon"
                [disabled]="!formGroup.valid"
                (click)="save()"
            >
                {{messageFor('externalEditingSaveText')}}
            </button>
            <button
                kendoButton
                [svgIcon]="cancelIcon"
                (click)="cancel()">
                {{messageFor('externalEditingCancelText')}}
            </button>
        </kendo-dialog-actions>
    `
    }]
  }], () => [{
    type: DialogRef
  }, {
    type: LocalizationService
  }], {
    controls: [{
      type: Input
    }],
    formGroup: [{
      type: Input
    }],
    formSettings: [{
      type: Input
    }]
  });
})();
var GroupToolbarToolComponent = class _GroupToolbarToolComponent {
  element;
  ngZone;
  hostClass = true;
  get lgClass() {
    return this.adaptive;
  }
  get mdClass() {
    return !this.adaptive;
  }
  onEscKeyDown(event) {
    event.preventDefault();
    this.hostButton?.focus(event);
    this.close.emit();
  }
  set groupItems(items) {
    this._groupItems = items;
    if (items?.first && (!isPresent(this.currentFocusedItemIndex) || this.currentFocusedItemIndex >= items.length || this.currentFocusedItemIndex < 0)) {
      this.ngZone.onStable.pipe(take(1)).subscribe(() => {
        this.currentFocusedItemIndex = 0;
        this.groupItems.first.nativeElement.focus({
          preventScroll: true
        });
      });
      return;
    }
    if (items?.first) {
      items.get(this.currentFocusedItemIndex).nativeElement.focus({
        preventScroll: true
      });
    }
  }
  get groupItems() {
    return this._groupItems;
  }
  _groupItems;
  adaptive = false;
  close = new EventEmitter();
  groupClear = new EventEmitter();
  currentFocusedItemIndex;
  group = new Array();
  columns = [];
  iconSize = "medium";
  upIcon = chevronUpIcon;
  downIcon = chevronDownIcon;
  removeIcon = xCircleIcon;
  addIcon = plusCircleIcon;
  clearIcon = xIcon;
  _ctx;
  set ctx(ctx) {
    if (!ctx || !ctx.grid) {
      return;
    }
    this._ctx = ctx;
    this.group = ctx.grid.group;
    this.subscription = ctx.grid.groupChange.subscribe((group2) => {
      this.group = group2;
      this.updateGroupedColumns();
    });
    this.ngZone.onStable.pipe(take(1)).subscribe(() => {
      this.updateGroupedColumns();
    });
  }
  get ctx() {
    return this._ctx;
  }
  groupedColumns = [];
  ungroupedColumns = [];
  subscription;
  hostButton;
  constructor(element, ngZone) {
    this.element = element;
    this.ngZone = ngZone;
  }
  ngOnInit() {
    this.iconSize = this.adaptive ? "large" : "medium";
  }
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
  }
  addGroup(column, ev) {
    ev.stopImmediatePropagation();
    const index = this.group.length;
    const groups = this.group.filter((x) => x.field !== column?.field);
    if (groups.length || this.group.length === 0) {
      this.group = [...groups.slice(0, index), {
        field: column?.field
      }, ...groups.slice(index)];
      this.ctx.grid.groupChange.emit(this.group);
      this.updateGroupedColumns();
      this.ngZone.onStable.pipe(take(1)).subscribe(() => {
        const newIndex = this.groupedColumns.length - 1;
        const newItem = this.groupItems.get(newIndex);
        if (newItem) {
          this.currentFocusedItemIndex = (this.groupedColumns?.length || 0) + newIndex;
          newItem.nativeElement.focus();
        }
      });
    }
  }
  removeGroup(column, ev) {
    ev.stopImmediatePropagation();
    this.group = this.group.filter((x) => x.field !== column?.field);
    this.ctx.grid.groupChange.emit(this.group);
    this.updateGroupedColumns();
    this.ngZone.onStable.pipe(take(1)).subscribe(() => {
      const newIndex = this.ungroupedColumns.findIndex((ungroupedColumn) => ungroupedColumn?.field === column?.field);
      const newItem = this.groupItems.get(newIndex + this.groupedColumns.length);
      if (newItem) {
        newItem.nativeElement.focus();
      }
    });
  }
  moveGroupUp(column, ev) {
    ev.stopImmediatePropagation();
    const index = this.group.findIndex((x) => x.field === column?.field);
    if (index > 0) {
      const groupToMove = this.group[index];
      this.group.splice(index, 1);
      this.group.splice(index - 1, 0, groupToMove);
      this.ctx.grid.groupChange.emit(this.group);
      this.updateGroupedColumns();
      this.ngZone.onStable.pipe(take(1)).subscribe(() => {
        const newItem = this.groupItems.get(index - 1);
        if (newItem) {
          newItem.nativeElement.focus();
          this.currentFocusedItemIndex = index - 1;
        }
      });
    }
  }
  moveGroupDown(column, ev) {
    ev.stopImmediatePropagation();
    const index = this.group.findIndex((x) => x.field === column?.field);
    if (index < this.group.length - 1) {
      const groupToMove = this.group[index];
      this.group.splice(index, 1);
      this.group.splice(index + 1, 0, groupToMove);
      this.ctx.grid.groupChange.emit(this.group);
      this.updateGroupedColumns();
      this.ngZone.onStable.pipe(take(1)).subscribe(() => {
        const newItem = this.groupItems.get(index + 1);
        if (newItem) {
          newItem.nativeElement.focus();
          this.currentFocusedItemIndex = index + 1;
        }
      });
    }
  }
  clear() {
    this.group = [];
    this.ctx.grid.groupChange.emit(this.group);
    this.groupClear.emit(this.group);
  }
  getColumnComponent(column) {
    return column;
  }
  onItemFocus(groupIndex, index) {
    const currentIndex = (typeof groupIndex === "number" ? groupIndex : this.groupedColumns?.length || 0) + index;
    this.currentFocusedItemIndex = currentIndex;
  }
  handleGroupedKeydown(column, index, ev) {
    const code = normalizeKeys(ev);
    if (code === Keys.Enter || code === Keys.Backspace || code === Keys.Delete) {
      this.removeGroup(column, ev);
    } else if (code === Keys.ArrowUp && ev.shiftKey) {
      this.moveGroupUp(column, ev);
    } else if (code === Keys.ArrowDown && ev.shiftKey) {
      this.moveGroupDown(column, ev);
    } else if (code === Keys.ArrowUp) {
      this.navigateToPreviousItem();
    } else if (code === Keys.ArrowDown) {
      this.navigateToNextItem();
    }
  }
  handleUngroupedKeydown(column, index, ev) {
    const code = normalizeKeys(ev);
    if (code === Keys.Enter) {
      this.addGroup(column, ev);
    } else if (code === Keys.ArrowUp) {
      this.navigateToPreviousItem();
    } else if (code === Keys.ArrowDown) {
      this.navigateToNextItem();
    }
  }
  updateGroupedColumns() {
    const columns = this.ctx.grid["columnInfoService"].leafNamedColumns;
    const groupableColumns = columns.filter((column) => column?.groupable);
    this.groupedColumns = this.group.map((group2) => columns.find((column) => column?.field === group2.field)).filter((column) => !!column);
    this.ungroupedColumns = groupableColumns.filter((column) => !this.groupedColumns.some((gc) => gc?.field === column?.field));
  }
  navigateToNextItem() {
    if (this.currentFocusedItemIndex < this.groupItems.length - 1) {
      this.currentFocusedItemIndex++;
      this.groupItems.get(this.currentFocusedItemIndex).nativeElement.focus();
    } else if (this.currentFocusedItemIndex === this.groupItems.length - 1) {
      this.currentFocusedItemIndex = 0;
      this.groupItems.get(this.currentFocusedItemIndex).nativeElement.focus();
    }
  }
  navigateToPreviousItem() {
    if (this.currentFocusedItemIndex > 0) {
      this.currentFocusedItemIndex--;
      this.groupItems.get(this.currentFocusedItemIndex).nativeElement.focus();
    } else if (this.currentFocusedItemIndex === 0) {
      this.currentFocusedItemIndex = this.groupItems.length - 1;
      this.groupItems.get(this.currentFocusedItemIndex).nativeElement.focus();
    }
  }
  static ɵfac = function GroupToolbarToolComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _GroupToolbarToolComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _GroupToolbarToolComponent,
    selectors: [["kendo-group-toolbar-tool"]],
    viewQuery: function GroupToolbarToolComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c59, 5, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.groupItems = _t);
      }
    },
    hostVars: 6,
    hostBindings: function GroupToolbarToolComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("keydown.escape", function GroupToolbarToolComponent_keydown_escape_HostBindingHandler($event) {
          return ctx.onEscKeyDown($event);
        });
      }
      if (rf & 2) {
        ɵɵclassProp("k-group-menu", ctx.hostClass)("k-group-menu-lg", ctx.lgClass)("k-group-menu-md", ctx.mdClass);
      }
    },
    inputs: {
      adaptive: "adaptive"
    },
    outputs: {
      close: "close",
      groupClear: "groupClear"
    },
    decls: 3,
    vars: 3,
    consts: [["groupItem", ""], [1, "k-group-menu-item-wrap"], [1, "k-actions", "k-actions-stretched", "k-actions-horizontal", "k-column-menu-footer"], ["role", "button", "tabindex", "0", 1, "k-group-menu-item"], ["role", "button", "tabindex", "0", 1, "k-group-menu-item", 3, "keydown", "focus"], [1, "k-group-menu-item-actions"], [1, "k-group-item-text"], [1, "k-spacer"], [1, "k-group-menu-item-action", "k-group-menu-item-remove-action", 3, "click"], ["name", "x-circle", 3, "svgIcon", "size"], [1, "k-group-menu-item-action", "k-group-menu-item-up-action", 3, "click"], ["name", "arrow-chevron-up", 3, "svgIcon", "size"], [1, "k-group-menu-item-action", "k-group-menu-item-down-action", 3, "click"], ["name", "arrow-chevron-down", 3, "svgIcon", "size"], [1, "k-group-menu-item-action", "k-group-menu-item-add-action", 3, "click"], ["name", "plus-circle", 3, "svgIcon", "size"], ["kendoButton", "", "icon", "x", 3, "click", "svgIcon"]],
    template: function GroupToolbarToolComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵconditionalCreate(0, GroupToolbarToolComponent_Conditional_0_Template, 3, 0, "div", 1);
        ɵɵconditionalCreate(1, GroupToolbarToolComponent_Conditional_1_Template, 3, 0, "div", 1);
        ɵɵconditionalCreate(2, GroupToolbarToolComponent_Conditional_2_Template, 3, 2, "div", 2);
      }
      if (rf & 2) {
        ɵɵconditional(ctx.groupedColumns.length ? 0 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.ungroupedColumns.length ? 1 : -1);
        ɵɵadvance();
        ɵɵconditional(!ctx.adaptive ? 2 : -1);
      }
    },
    dependencies: [IconWrapperComponent, ButtonComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GroupToolbarToolComponent, [{
    type: Component,
    args: [{
      selector: "kendo-group-toolbar-tool",
      template: `
        @if (groupedColumns.length) {
          <div class="k-group-menu-item-wrap">
            @for (column of groupedColumns; track column; let i = $index) {
              <div
                #groupItem
                role="button"
                class="k-group-menu-item"
                tabindex="0"
                (keydown)="handleGroupedKeydown(column, i, $event)"
                (focus)="onItemFocus(i, 0)"
                >
                @if (groupedColumns.length > 1) {
                  <span class="k-group-menu-item-actions">
                    <span
                      class="k-group-menu-item-action k-group-menu-item-up-action"
                      (click)="moveGroupUp(column, $event)"
                      [attr.aria-disabled]="i === 0"
                      [class.k-disabled]="i === 0"
                      >
                      <kendo-icon-wrapper
                        name="arrow-chevron-up"
                        [svgIcon]="upIcon"
                        [size]="iconSize"
                      ></kendo-icon-wrapper>
                    </span>
                    <span
                      class="k-group-menu-item-action k-group-menu-item-down-action"
                      (click)="moveGroupDown(column, $event)"
                      [attr.aria-disabled]="i === groupedColumns.length - 1"
                      [class.k-disabled]="i === groupedColumns.length - 1"
                      >
                      <kendo-icon-wrapper
                        name="arrow-chevron-down"
                        [svgIcon]="downIcon"
                        [size]="iconSize"
                      ></kendo-icon-wrapper>
                    </span>
                  </span>
                }
                <span class="k-group-item-text">{{column.title || getColumnComponent(column).field}}</span>
                <span class="k-spacer"></span>
                <span class="k-group-menu-item-actions">
                  <span class="k-group-menu-item-action k-group-menu-item-remove-action" (click)="removeGroup(column, $event)">
                    <kendo-icon-wrapper
                      name="x-circle"
                      [svgIcon]="removeIcon"
                      [size]="iconSize"
                    ></kendo-icon-wrapper>
                  </span>
                </span>
              </div>
            }
          </div>
        }
        
        @if (ungroupedColumns.length) {
          <div class="k-group-menu-item-wrap">
            @for (column of ungroupedColumns; track column; let i = $index) {
              <div
                #groupItem
                role="button"
                class="k-group-menu-item"
                tabindex="0"
                (keydown)="handleUngroupedKeydown(column, i, $event)"
                (focus)="onItemFocus(null, i)"
                >
                <span class="k-group-item-text">{{column.title || getColumnComponent(column).field}}</span>
                <span class="k-spacer"></span>
                <span class="k-group-menu-item-actions">
                  <span class="k-group-menu-item-action k-group-menu-item-add-action" (click)="addGroup(column, $event)">
                    <kendo-icon-wrapper
                      name="plus-circle"
                      [svgIcon]="addIcon"
                      [size]="iconSize"
                    ></kendo-icon-wrapper>
                  </span>
                </span>
              </div>
            }
          </div>
        }
        
        @if (!adaptive) {
          <div class="k-actions k-actions-stretched k-actions-horizontal k-column-menu-footer">
            <button kendoButton
              [svgIcon]="clearIcon"
              (click)="clear()"
              icon="x"
              >
              {{ctx?.localization.get('groupClearButton')}}
            </button>
          </div>
        }
        `,
      standalone: true,
      imports: [IconWrapperComponent, KENDO_BUTTON]
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NgZone
  }], {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-group-menu"]
    }],
    lgClass: [{
      type: HostBinding,
      args: ["class.k-group-menu-lg"]
    }],
    mdClass: [{
      type: HostBinding,
      args: ["class.k-group-menu-md"]
    }],
    onEscKeyDown: [{
      type: HostListener,
      args: ["keydown.escape", ["$event"]]
    }],
    groupItems: [{
      type: ViewChildren,
      args: ["groupItem", {
        read: ElementRef
      }]
    }],
    adaptive: [{
      type: Input
    }],
    close: [{
      type: Output
    }],
    groupClear: [{
      type: Output
    }]
  });
})();
var AdaptiveRendererComponent = class _AdaptiveRendererComponent {
  service;
  adaptiveGridService;
  filterService;
  ctx;
  adaptiveService;
  sortService;
  columnInfoService;
  xIcon = xIcon;
  checkIcon = checkIcon;
  filterIcon = filterIcon;
  arrowRotateCcwIcon = arrowRotateCcwIcon;
  chevronLeft = chevronLeftIcon;
  filterClearIcon = filterClearIcon;
  cancelIcon = cancelIcon;
  saveIcon = saveIcon;
  columns;
  externalEditingSettings;
  get hasSort() {
    return hasSort(this.ctx.grid.columnMenu, this.adaptiveGridService.column);
  }
  get hasColumnChooser() {
    return hasColumnChooser(this.ctx.grid.columnMenu);
  }
  get hasFilter() {
    return hasFilter(this.ctx.grid.columnMenu, this.adaptiveGridService.column);
  }
  get hasAutoSizeColumn() {
    return hasAutoSizeColumn(this.ctx.grid.columnMenu);
  }
  get hasAutoSizeAllColumns() {
    return hasAutoSizeAllColumns(this.ctx.grid.columnMenu);
  }
  get hasLock() {
    return hasLock(this.ctx.grid.columnMenu, this.adaptiveGridService.column);
  }
  get hasStick() {
    return hasStick(this.ctx.grid.columnMenu, this.adaptiveGridService.column);
  }
  get hasPosition() {
    return hasPosition(this.ctx.grid.columnMenu, this.adaptiveGridService.column);
  }
  getColumnComponent(column) {
    return column;
  }
  get hasTitle() {
    const hasTitle = this.adaptiveGridService.viewType === "columnMenu" || this.adaptiveGridService.viewType === "filterToolbarTool" || this.adaptiveGridService.viewType === "columnChooserToolbarTool" || this.adaptiveGridService.viewType === "filterMenu" || this.adaptiveGridService.viewType === "sortToolbarTool" || this.adaptiveGridService.viewType === "groupToolbarTool" || this.adaptiveGridService.viewType === "externalEditing";
    return hasTitle;
  }
  get hasSubtitle() {
    const hasSubtitle = this.adaptiveGridService.viewType === "columnMenu" && this.adaptiveGridService.secondaryView === "columnChooser" || this.adaptiveGridService.viewType === "columnChooserToolbarTool";
    return hasSubtitle;
  }
  get actionSheetTitle() {
    if (this.adaptiveGridService.viewType === "columnMenu") {
      if (this.adaptiveGridService.secondaryView === "columnChooser") {
        return this.messageFor("columns");
      }
      if (this.adaptiveGridService.secondaryView === "columnPosition") {
        return this.messageFor("setColumnPosition");
      }
      if (this.adaptiveGridService.secondaryView === "columnFilter") {
        return this.adaptiveGridService.column.title || this.adaptiveGridService.column.field;
      }
      return this.columnMenuTitle;
    }
    if (this.adaptiveGridService.viewType === "filterToolbarTool") {
      if (this.adaptiveGridService.secondaryView === "columnFilter") {
        return this.adaptiveGridService.column.title || this.adaptiveGridService.column.field;
      }
      return this.messageFor("adaptiveFilterTitle");
    }
    if (this.adaptiveGridService.viewType === "filterMenu") {
      return this.adaptiveGridService.column.title || this.adaptiveGridService.column.field;
    }
    if (this.adaptiveGridService.viewType === "columnChooserToolbarTool") {
      return this.messageFor("columns");
    }
    if (this.adaptiveGridService.viewType === "sortToolbarTool") {
      return this.messageFor("adaptiveSortTitle");
    }
    if (this.adaptiveGridService.viewType === "groupToolbarTool") {
      return this.messageFor("adaptiveGroupTitle");
    }
    if (this.adaptiveGridService.viewType === "externalEditing") {
      return this.messageFor(this.externalEditingSettings.event.isNew ? "externalEditingAddTitle" : "externalEditingTitle");
    }
  }
  get adaptiveFilterTitle() {
    const columnTitle = this.adaptiveGridService.column.title || this.adaptiveGridService.column.field;
    return `${this.messageFor("adaptiveFilterTitle")} ${columnTitle}`;
  }
  get columnMenuTitle() {
    const columnName = this.adaptiveGridService.column.title || this.adaptiveGridService.column.field;
    return columnName;
  }
  get filterLabel() {
    const localizationMsg = this.messageFor("filterMenuTitle") || "";
    const columnName = this.adaptiveGridService.column.title || this.adaptiveGridService.column.field;
    return replaceMessagePlaceholder(localizationMsg, "columnName", columnName);
  }
  get hasXCloseIcon() {
    return this.adaptiveGridService.viewType !== "sortToolbarTool" && this.adaptiveGridService.viewType !== "groupToolbarTool";
  }
  get hasCheckCloseIcon() {
    return this.adaptiveGridService.viewType === "sortToolbarTool" || this.adaptiveGridService.viewType === "groupToolbarTool";
  }
  columnChooserContent;
  filterToolbarToolTemplate;
  filterMenuContainer;
  actionSheet;
  set groupToolbarTool(value2) {
    value2 && (value2.ctx = this.ctx);
  }
  adaptiveSizeChangeSubscription;
  constructor(service, adaptiveGridService, filterService, ctx, adaptiveService, sortService, columnInfoService) {
    this.service = service;
    this.adaptiveGridService = adaptiveGridService;
    this.filterService = filterService;
    this.ctx = ctx;
    this.adaptiveService = adaptiveService;
    this.sortService = sortService;
    this.columnInfoService = columnInfoService;
    this.adaptiveSizeChangeSubscription = this.adaptiveService.sizeChanges.subscribe(() => {
      if (this.ctx.grid.isOpen) {
        if (this.actionSheet.expanded) {
          this.actionSheet.toggle(false);
        } else {
          this.adaptiveGridService.popupRef.close();
          this.adaptiveGridService.popupRef = null;
        }
      }
    });
  }
  ngOnInit() {
    this.columns = this.columnInfoService.leafNamedColumns.filter((column) => column?.sortable);
  }
  ngOnDestroy() {
    if (this.adaptiveSizeChangeSubscription) {
      this.adaptiveSizeChangeSubscription.unsubscribe();
    }
  }
  messageFor = (token) => this.ctx.localization.get(token);
  close() {
    this.actionSheet.toggle(false);
    this.adaptiveGridService.reset();
  }
  prevView() {
    this.adaptiveGridService.secondaryView = null;
    this.adaptiveGridService.filterMenuContainerComponentRef?.destroy();
    this.actionSheet.prevView();
  }
  clearFilters() {
    const emptyFilter = {
      logic: "and",
      filters: []
    };
    this.filterService.filter(emptyFilter);
    this.actionSheet.toggle(false);
  }
  navigateToColumnsView() {
    this.adaptiveGridService.secondaryView = "columnChooser";
    this.actionSheet.nextView();
  }
  navigateToFilterView() {
    this.adaptiveGridService.secondaryView = "columnFilter";
    this.actionSheet.nextView();
  }
  navigateToPositionView() {
    this.adaptiveGridService.secondaryView = "columnPosition";
    this.actionSheet.nextView();
  }
  applyChanges() {
    this.columnChooserContent.applyChanges();
    this.actionSheet.toggle(false);
  }
  sortBy(column) {
    this.toggleSort(this.getColumnComponent(column));
  }
  toggleSort(column) {
    const field = column?.field;
    if (!field) {
      return;
    }
    const descriptor = this.getDescriptor(column);
    this.sortService.sort(descriptor);
  }
  getDescriptor(column) {
    const {
      allowUnsort,
      mode,
      initialDirection
    } = normalize$1(this.ctx.grid.sortable, column.sortable);
    const field = column?.field;
    if (!field) {
      return;
    }
    const descriptorT = this.ctx.grid.sort.find((item) => item.field === field) || {
      field
    };
    const [first, second] = directions(initialDirection);
    let dir = first;
    if (descriptorT.dir === first) {
      dir = second;
    } else if (descriptorT.dir === second && allowUnsort) {
      dir = void 0;
    }
    const descriptor = {
      field,
      dir
    };
    if (mode === "single") {
      return [descriptor];
    }
    return [...this.ctx.grid.sort.filter((desc) => desc.field !== field), descriptor];
  }
  clearSorting() {
    if (this.ctx.grid.sort.length > 0) {
      this.sortService.sort([]);
    }
    this.actionSheet.toggle(false);
  }
  clearGrouping() {
    if (this.ctx.grid.group.length > 0) {
      this.ctx.grid.group = [];
      this.ctx.grid.groupChange.emit(this.ctx.grid.group);
    }
    this.actionSheet.toggle(false);
  }
  onAnimationEnd() {
    this.adaptiveGridService.notifyAnimationEnd();
  }
  cancelChanges() {
    this.columnChooserContent.cancelChanges();
    this.columnChooserContent.cdr.detectChanges();
  }
  onTab(event) {
    this.columnChooserContent.onTab(event);
  }
  saveEditing() {
    const {
      event,
      formGroup,
      externalEditingDirective
    } = this.externalEditingSettings;
    externalEditingDirective.saveHandler(__spreadProps(__spreadValues({}, event), {
      formGroup
    }));
    this.actionSheet.toggle(false);
  }
  static ɵfac = function AdaptiveRendererComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AdaptiveRendererComponent)(ɵɵdirectiveInject(ColumnMenuService), ɵɵdirectiveInject(AdaptiveGridService), ɵɵdirectiveInject(FilterService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(AdaptiveService), ɵɵdirectiveInject(SortService), ɵɵdirectiveInject(ColumnInfoService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _AdaptiveRendererComponent,
    selectors: [["kendo-grid-adaptive-renderer"]],
    viewQuery: function AdaptiveRendererComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c60, 5)(_c61, 5, ViewContainerRef)(_c622, 5)(ActionSheetComponent, 5)(GroupToolbarToolComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columnChooserContent = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.filterToolbarToolTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.filterMenuContainer = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.actionSheet = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.groupToolbarTool = _t.first);
      }
    },
    decls: 16,
    vars: 17,
    consts: [["actionSheetHeaderTemplate", ""], ["actionSheetFooterTemplate", ""], ["filterFooterButtons", ""], ["columnChooserContent", ""], ["filterToolbarToolTemplate", ""], ["filterMenuContainer", ""], ["sortItem", ""], ["lockItem", ""], ["stickItem", ""], ["positionItem", ""], ["chooserItem", ""], ["autoSizeColumnItem", ""], ["autoSizeAllColumnsItem", ""], ["filterItem", ""], ["resetButton", ""], ["applyButton", ""], [3, "collapse", "cssClass", "cssStyle", "overlayClickClose"], [3, "kendoEventsOutsideAngular", "scope"], ["kendoActionSheetHeaderTemplate", ""], ["kendoActionSheetContentTemplate", ""], ["kendoActionSheetFooterTemplate", ""], [3, "ngTemplateOutlet"], [1, "k-column-menu", "k-column-menu-lg"], [1, "k-columnmenu-item-wrapper"], [3, "column", "text"], [3, "itemClick", "column", "text"], ["kendoButton", "", "size", "large", "fillMode", "solid", "icon", "x", 3, "click", "svgIcon"], ["kendoButton", "", "size", "large", "fillMode", "solid", "icon", "check", "themeColor", "primary", 3, "click", "svgIcon"], [3, "columns", "isLast", "autoSync", "allowHideAll"], ["kendoButton", "", "icon", "filter-clear", "size", "large", 3, "click", "svgIcon"], [3, "close", "keydown.enter", "column", "filter"], [3, "kendoGridColumnMenuItem", "service"], [3, "showLock", "showStick", "kendoGridColumnMenuItem", "service", "expanded"], [1, "k-separator", 3, "borderColor"], [3, "kendoGridColumnMenuItem", "service", "expanded"], [3, "service", "kendoGridColumnMenuItem", "column"], [3, "service", "kendoGridColumnMenuItem"], [3, "collapse", "showLock", "showStick", "kendoGridColumnMenuItem", "service", "expanded"], [1, "k-separator"], [3, "collapse", "kendoGridColumnMenuItem", "service", "expanded"], [3, "column", "filter", "kendoEventsOutsideAngular", "scope"], [3, "service"], [3, "close", "column", "filter", "kendoEventsOutsideAngular", "scope"], [3, "controls", "formGroup", "formSettings", "actionButtons"], ["kendoButton", "", "size", "large", "icon", "cancel", 3, "click", "svgIcon"], ["kendoButton", "", "themeColor", "primary", "size", "large", "icon", "save", 3, "click", "svgIcon", "disabled"], [3, "adaptive"], [1, "k-actionsheet-titlebar-group"], [1, "k-actionsheet-actions"], [1, "k-actionsheet-title"], [1, "k-text-center"], [1, "k-actionsheet-subtitle", "k-text-center"], ["kendoButton", "", "icon", "chevron-left", "fillMode", "flat", "size", "large", 3, "click", "svgIcon", "title"], ["kendoButton", "", "icon", "x", "fillMode", "flat", "size", "large", 3, "click", "svgIcon", "title"], ["kendoButton", "", "icon", "check", "fillMode", "flat", "size", "large", "themeColor", "primary", 3, "click", "svgIcon", "title"], ["kendoButton", "", "size", "large", "fillMode", "solid", "icon", "arrow-rotate-ccw", "type", "button", 3, "svgIcon", "kendoEventsOutsideAngular", "scope"], ["kendoButton", "", "type", "button", "icon", "check", "size", "large", "fillMode", "solid", "themeColor", "primary", 3, "svgIcon", "kendoEventsOutsideAngular", "scope"], ["kendoButton", "", "size", "large", "fillMode", "solid", 3, "click"], ["kendoButton", "", "size", "large", "fillMode", "solid", "themeColor", "primary", 3, "click", "disabled"]],
    template: function AdaptiveRendererComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "kendo-actionsheet", 16);
        ɵɵlistener("collapse", function AdaptiveRendererComponent_Template_kendo_actionsheet_collapse_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.adaptiveGridService.reset());
        });
        ɵɵconditionalCreate(1, AdaptiveRendererComponent_Conditional_1_Template, 4, 0, "kendo-actionsheet-view");
        ɵɵconditionalCreate(2, AdaptiveRendererComponent_Conditional_2_Template, 4, 0, "kendo-actionsheet-view");
        ɵɵconditionalCreate(3, AdaptiveRendererComponent_Conditional_3_Template, 4, 4, "kendo-actionsheet-view", 17);
        ɵɵconditionalCreate(4, AdaptiveRendererComponent_Conditional_4_Template, 4, 0, "kendo-actionsheet-view");
        ɵɵconditionalCreate(5, AdaptiveRendererComponent_Conditional_5_Template, 4, 0, "kendo-actionsheet-view");
        ɵɵconditionalCreate(6, AdaptiveRendererComponent_Conditional_6_Template, 3, 4, "kendo-actionsheet-view", 17);
        ɵɵconditionalCreate(7, AdaptiveRendererComponent_Conditional_7_Template, 5, 2, "kendo-actionsheet-view");
        ɵɵconditionalCreate(8, AdaptiveRendererComponent_Conditional_8_Template, 4, 0, "kendo-actionsheet-view");
        ɵɵconditionalCreate(9, AdaptiveRendererComponent_Conditional_9_Template, 4, 0, "kendo-actionsheet-view");
        ɵɵelementEnd();
        ɵɵtemplate(10, AdaptiveRendererComponent_ng_template_10_Template, 7, 5, "ng-template", null, 0, ɵɵtemplateRefExtractor)(12, AdaptiveRendererComponent_ng_template_12_Template, 6, 17, "ng-template", null, 1, ɵɵtemplateRefExtractor)(14, AdaptiveRendererComponent_ng_template_14_Template, 4, 3, "ng-template", null, 2, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        ɵɵproperty("cssClass", ɵɵpureFunction2(12, _c632, ctx.adaptiveService.size === "small", ctx.adaptiveService.size === "medium"))("cssStyle", ɵɵpureFunction1(15, _c642, ctx.adaptiveService.size === "small" ? "100vh" : "60vh"))("overlayClickClose", true);
        ɵɵadvance();
        ɵɵconditional(ctx.adaptiveGridService.viewType === "sortToolbarTool" ? 1 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.adaptiveGridService.viewType === "columnChooserToolbarTool" ? 2 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.adaptiveGridService.viewType === "filterToolbarTool" ? 3 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.adaptiveGridService.viewType === "filterToolbarTool" ? 4 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.adaptiveGridService.viewType === "filterMenu" ? 5 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.adaptiveGridService.viewType === "columnMenu" ? 6 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.adaptiveGridService.viewType === "columnMenu" ? 7 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.adaptiveGridService.viewType === "externalEditing" ? 8 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.adaptiveGridService.viewType === "groupToolbarTool" ? 9 : -1);
      }
    },
    dependencies: [NgTemplateOutlet, ActionSheetComponent, ActionSheetViewComponent, FilterToolbarToolComponent, GroupToolbarToolComponent, ButtonComponent, ActionSheetHeaderTemplateDirective, ActionSheetContentTemplateDirective, ActionSheetFooterTemplateDirective, ColumnMenuContainerComponent, ColumnMenuFilterComponent, ColumnMenuSortComponent, ColumnMenuLockComponent, ColumnMenuStickComponent, ColumnMenuPositionComponent, ColumnMenuChooserComponent, ColumnMenuAutoSizeColumnComponent, ColumnMenuAutoSizeAllColumnsComponent, ColumnMenuItemComponent, ColumnMenuItemDirective, FilterMenuContainerComponent, EventsOutsideAngularDirective, FormComponent, ColumnChooserContentComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AdaptiveRendererComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-adaptive-renderer",
      template: `
        <kendo-actionsheet
            [cssClass]="{
                'k-adaptive-actionsheet': true,
                'k-actionsheet-fullscreen': adaptiveService.size === 'small',
                'k-actionsheet-bottom': adaptiveService.size === 'medium'
            }"
            [cssStyle]="{
                height: adaptiveService.size === 'small' ? '100vh' : '60vh'
            }"
          [overlayClickClose]="true"
          (collapse)="adaptiveGridService.reset()">
        
          <!-- sortToolbarTool view -->
          @if (adaptiveGridService.viewType === 'sortToolbarTool') {
            <kendo-actionsheet-view>
              <ng-template kendoActionSheetHeaderTemplate>
                <ng-container [ngTemplateOutlet]="actionSheetHeaderTemplate">
                </ng-container>
              </ng-template>
              <ng-template kendoActionSheetContentTemplate>
                <div class="k-column-menu k-column-menu-lg">
                  <div class="k-columnmenu-item-wrapper">
                    @for (column of columns; track column) {
                      <kendo-grid-columnmenu-item
                        [column]="getColumnComponent(column)"
                        [text]="column.title || getColumnComponent(column).field"
                        (itemClick)="sortBy(column)">
                      </kendo-grid-columnmenu-item>
                    }
                  </div>
                </div>
              </ng-template>
              <ng-template kendoActionSheetFooterTemplate>
                <button
                  kendoButton
                  size="large"
                  fillMode="solid"
                  icon="x"
                  [svgIcon]="xIcon"
                  (click)="clearSorting()">
                  {{messageFor('sortClearButton')}}
                </button>
                <button
                  kendoButton
                  size="large"
                  fillMode="solid"
                  icon="check"
                  [svgIcon]="checkIcon"
                  themeColor="primary"
                  (click)="actionSheet.toggle(false)">
                  {{messageFor('sortDoneButton')}}
                </button>
              </ng-template>
            </kendo-actionsheet-view>
          }
        
          <!-- columnChooserToolbarTool view -->
          @if (adaptiveGridService.viewType === 'columnChooserToolbarTool') {
            <kendo-actionsheet-view>
              <ng-template kendoActionSheetHeaderTemplate>
                <ng-container [ngTemplateOutlet]="actionSheetHeaderTemplate">
                </ng-container>
              </ng-template>
              <ng-template kendoActionSheetContentTemplate>
                <kendo-grid-column-chooser-content
                  #columnChooserContent
                  [columns]="columns"
                  [isLast]="true"
                  [autoSync]="false"
                  [allowHideAll]="false"
                  >
                </kendo-grid-column-chooser-content>
              </ng-template>
              <ng-template kendoActionSheetFooterTemplate>
                <ng-container [ngTemplateOutlet]="actionSheetFooterTemplate">
                </ng-container>
              </ng-template>
            </kendo-actionsheet-view>
          }
        
          <!-- filterToolbarTool first view -->
          @if (adaptiveGridService.viewType === 'filterToolbarTool') {
            <kendo-actionsheet-view
              [kendoEventsOutsideAngular]="{transitionend: onAnimationEnd}"
              [scope]="this">
              <ng-template kendoActionSheetHeaderTemplate>
                <ng-container [ngTemplateOutlet]="actionSheetHeaderTemplate">
                </ng-container>
              </ng-template>
              <ng-template kendoActionSheetContentTemplate>
                <div class="k-column-menu k-column-menu-lg">
                  <kendo-filter-toolbar-tool></kendo-filter-toolbar-tool>
                </div>
              </ng-template>
              <ng-template kendoActionSheetFooterTemplate>
                <button kendoButton
                  icon="filter-clear"
                  [svgIcon]="filterClearIcon"
                  size="large"
                  (click)="clearFilters()">
                  {{messageFor('filterClearAllButton')}}
                </button>
              </ng-template>
            </kendo-actionsheet-view>
          }
        
          <!-- filterToolbarTool second view -->
          @if (adaptiveGridService.viewType === 'filterToolbarTool') {
            <kendo-actionsheet-view>
              <ng-template kendoActionSheetHeaderTemplate>
                <ng-container [ngTemplateOutlet]="actionSheetHeaderTemplate">
                </ng-container>
              </ng-template>
              <ng-template kendoActionSheetContentTemplate>
                <ng-container #filterToolbarToolTemplate></ng-container>
              </ng-template>
              <ng-template kendoActionSheetFooterTemplate>
                <ng-container [ngTemplateOutlet]="filterFooterButtons">
                </ng-container>
              </ng-template>
            </kendo-actionsheet-view>
          }
        
          <!-- filterMenu view -->
          @if (adaptiveGridService.viewType === 'filterMenu') {
            <kendo-actionsheet-view>
              <ng-template kendoActionSheetHeaderTemplate >
                <ng-container [ngTemplateOutlet]="actionSheetHeaderTemplate">
                </ng-container>
              </ng-template>
              <ng-template kendoActionSheetContentTemplate>
                <kendo-grid-filter-menu-container
                  #filterMenuContainer
                  [column]="adaptiveGridService.column"
                  [filter]="ctx.grid.filter"
                  (close)="close()"
                  (keydown.enter)="$event.stopImmediatePropagation()">
                </kendo-grid-filter-menu-container>
              </ng-template>
              <ng-template kendoActionSheetFooterTemplate>
                <ng-container [ngTemplateOutlet]="filterFooterButtons">
                </ng-container>
              </ng-template>
            </kendo-actionsheet-view>
          }
        
          <!-- columnMenu first view -->
          @if (adaptiveGridService.viewType === 'columnMenu') {
            <kendo-actionsheet-view
              [kendoEventsOutsideAngular]="{transitionend: onAnimationEnd}"
              [scope]="this">
              <ng-template kendoActionSheetHeaderTemplate>
                <ng-container [ngTemplateOutlet]="actionSheetHeaderTemplate">
                </ng-container>
              </ng-template>
              <ng-template kendoActionSheetContentTemplate>
                <div class="k-column-menu k-column-menu-lg">
                  <kendo-grid-columnmenu-container>
                    @if (hasSort) {
                      <kendo-grid-columnmenu-sort #sortItem [kendoGridColumnMenuItem]="sortItem" [service]="adaptiveGridService.columnMenuService">
                      </kendo-grid-columnmenu-sort>
                    }
                    @if (hasLock && !hasPosition) {
                      <kendo-grid-columnmenu-lock #lockItem [kendoGridColumnMenuItem]="lockItem" [service]="adaptiveGridService.columnMenuService">
                      </kendo-grid-columnmenu-lock>
                    }
                    @if (hasStick && !hasPosition) {
                      <kendo-grid-columnmenu-stick #stickItem [kendoGridColumnMenuItem]="stickItem" [service]="adaptiveGridService.columnMenuService">
                      </kendo-grid-columnmenu-stick>
                    }
                    @if (hasPosition) {
                      <kendo-grid-columnmenu-position
                        #positionItem
                        [showLock]="hasLock"
                        [showStick]="hasStick"
                        [kendoGridColumnMenuItem]="positionItem"
                        [service]="adaptiveGridService.columnMenuService"
                        [expanded]="false"
                        (collapse)="navigateToPositionView()">
                      </kendo-grid-columnmenu-position>
                    }
                    @if (hasLock || hasStick || adaptiveGridService.column.sortable) {
                      <span [style.borderColor]="'rgba(0, 0, 0, 0.08)'" class="k-separator"></span>
                    }
                    @if (hasColumnChooser) {
                      <kendo-grid-columnmenu-chooser
                        #chooserItem
                        [kendoGridColumnMenuItem]="chooserItem"
                        [service]="adaptiveGridService.columnMenuService"
                        [expanded]="false"
                        (collapse)="navigateToColumnsView()">
                      </kendo-grid-columnmenu-chooser>
                    }
                    @if (hasAutoSizeColumn) {
                      <kendo-grid-columnmenu-autosize-column
                        #autoSizeColumnItem
                        [service]="adaptiveGridService.columnMenuService"
                        [kendoGridColumnMenuItem]="autoSizeColumnItem"
                        [column]="adaptiveGridService.column"
                        >
                      </kendo-grid-columnmenu-autosize-column>
                    }
                    @if (hasAutoSizeAllColumns) {
                      <kendo-grid-columnmenu-autosize-all-columns
                        #autoSizeAllColumnsItem
                        [service]="adaptiveGridService.columnMenuService"
                        [kendoGridColumnMenuItem]="autoSizeAllColumnsItem"
                        >
                      </kendo-grid-columnmenu-autosize-all-columns>
                    }
                    @if (adaptiveGridService.column.filterable) {
                      <span [style.borderColor]="'rgba(0, 0, 0, 0.08)'" class="k-separator"></span>
                    }
                    @if (hasFilter) {
                      <kendo-grid-columnmenu-filter
                        #filterItem
                        [kendoGridColumnMenuItem]="filterItem"
                        [service]="adaptiveGridService.columnMenuService"
                        [expanded]="false"
                        (collapse)="navigateToFilterView()">
                      </kendo-grid-columnmenu-filter>
                    }
                  </kendo-grid-columnmenu-container>
                </div>
              </ng-template>
            </kendo-actionsheet-view>
          }
        
          <!-- columnMenu second view -->
          @if (adaptiveGridService.viewType === 'columnMenu') {
            <kendo-actionsheet-view>
              <ng-template kendoActionSheetHeaderTemplate>
                <ng-container [ngTemplateOutlet]="actionSheetHeaderTemplate">
                </ng-container>
              </ng-template>
              <ng-template kendoActionSheetContentTemplate>
                @if (adaptiveGridService.secondaryView === 'columnChooser') {
                  <kendo-grid-column-chooser-content
                    #columnChooserContent
                    [columns]="adaptiveGridService.columns"
                    [isLast]="true"
                    [autoSync]="false"
                    [allowHideAll]="false"
                    >
                  </kendo-grid-column-chooser-content>
                }
                @if (adaptiveGridService.secondaryView === 'columnFilter') {
                  <kendo-grid-filter-menu-container
                    [column]="adaptiveGridService.column"
                    [filter]="ctx.grid.filter"
                    (close)="close()"
                    [kendoEventsOutsideAngular]="{'keydown.escape': close}"
                    [scope]="this">
                  </kendo-grid-filter-menu-container>
                }
                @if (adaptiveGridService.secondaryView === 'columnPosition' && hasLock) {
                  <kendo-grid-columnmenu-lock
                    [service]="adaptiveGridService.columnMenuService">
                  </kendo-grid-columnmenu-lock>
                }
                @if (adaptiveGridService.secondaryView === 'columnPosition' && hasStick) {
                  <kendo-grid-columnmenu-stick
                    [service]="adaptiveGridService.columnMenuService">
                  </kendo-grid-columnmenu-stick>
                }
              </ng-template>
              @if (adaptiveGridService.secondaryView === 'columnChooser') {
                <ng-template kendoActionSheetFooterTemplate>
                  <ng-container [ngTemplateOutlet]="actionSheetFooterTemplate">
                  </ng-container>
                </ng-template>
              }
              @if (adaptiveGridService.secondaryView === 'columnFilter') {
                <ng-template kendoActionSheetFooterTemplate>
                  <ng-container [ngTemplateOutlet]="filterFooterButtons">
                  </ng-container>
                </ng-template>
              }
            </kendo-actionsheet-view>
          }
        
          <!-- external editing view -->
          @if (adaptiveGridService.viewType === 'externalEditing') {
            <kendo-actionsheet-view>
              <ng-template kendoActionSheetHeaderTemplate>
                <ng-container [ngTemplateOutlet]="actionSheetHeaderTemplate">
                </ng-container>
              </ng-template>
              <ng-template kendoActionSheetContentTemplate>
                <kendo-grid-external-form
                  [controls]="externalEditingSettings.formControls"
                  [formGroup]="externalEditingSettings.formGroup"
                  [formSettings]="externalEditingSettings.formSettings"
                  [actionButtons]="false">
                </kendo-grid-external-form>
              </ng-template>
              <ng-template kendoActionSheetFooterTemplate>
                <button kendoButton
                  size="large"
                  icon="cancel"
                  [svgIcon]="cancelIcon"
                  (click)="actionSheet.toggle(false)">
                  {{messageFor('externalEditingCancelText')}}
                </button>
                <button kendoButton
                  themeColor="primary"
                  size="large"
                  icon="save"
                  [svgIcon]="saveIcon"
                  (click)="saveEditing()"
                  [disabled]="!externalEditingSettings.formGroup.valid">
                  {{messageFor('externalEditingSaveText')}}
                </button>
              </ng-template>
            </kendo-actionsheet-view>
          }
        
          <!-- groupToolbarTool view -->
          @if (adaptiveGridService.viewType === 'groupToolbarTool') {
            <kendo-actionsheet-view>
              <ng-template kendoActionSheetHeaderTemplate>
                <ng-container [ngTemplateOutlet]="actionSheetHeaderTemplate">
                </ng-container>
              </ng-template>
              <ng-template kendoActionSheetContentTemplate>
                <kendo-group-toolbar-tool [adaptive]="true"></kendo-group-toolbar-tool>
              </ng-template>
              <ng-template kendoActionSheetFooterTemplate>
                <button
                  kendoButton
                  size="large"
                  fillMode="solid"
                  icon="x"
                  [svgIcon]="xIcon"
                  (click)="clearGrouping()">
                  {{messageFor('groupClearButton')}}
                </button>
                <button
                  kendoButton
                  size="large"
                  fillMode="solid"
                  icon="check"
                  [svgIcon]="checkIcon"
                  themeColor="primary"
                  (click)="actionSheet.toggle(false)">
                  {{messageFor('groupDoneButton')}}
                </button>
              </ng-template>
            </kendo-actionsheet-view>
          }
        </kendo-actionsheet>
        
        <ng-template #actionSheetHeaderTemplate>
          <div class="k-actionsheet-titlebar-group">
            @if (adaptiveGridService.secondaryView) {
              <div class="k-actionsheet-actions">
                <button
                  kendoButton
                  icon="chevron-left"
                  [svgIcon]="chevronLeft"
                  fillMode="flat"
                  size="large"
                  [title]="messageFor('adaptiveBackButtonTitle')"
                  (click)="prevView()">
                </button>
              </div>
            }
            <div class="k-actionsheet-title">
              @if (hasTitle) {
                <div class="k-text-center">
                  {{actionSheetTitle}}
                </div>
              }
              @if (hasSubtitle) {
                <div
                  class="k-actionsheet-subtitle k-text-center">
                  {{messageFor('columnsSubtitle')}}
                </div>
              }
            </div>
            @if (hasXCloseIcon) {
              <div class="k-actionsheet-actions">
                <button
                  kendoButton
                  icon="x"
                  [svgIcon]="xIcon"
                  fillMode="flat"
                  size="large"
                  [title]="messageFor('adaptiveCloseButtonTitle')"
                  (click)="close()">
                </button>
              </div>
            }
            @if (hasCheckCloseIcon) {
              <div class="k-actionsheet-actions">
                <button
                  kendoButton
                  icon="check"
                  [svgIcon]="checkIcon"
                  fillMode="flat"
                  size="large"
                  themeColor="primary"
                  [title]="messageFor('adaptiveCloseButtonTitle')"
                  (click)="actionSheet.toggle(false)">
                </button>
              </div>
            }
          </div>
        </ng-template>
        
        <ng-template #actionSheetFooterTemplate>
          <button
            #resetButton
            kendoButton
            size="large"
            fillMode="solid"
            [svgIcon]="arrowRotateCcwIcon"
            icon="arrow-rotate-ccw"
            type="button"
                [kendoEventsOutsideAngular]="{click: cancelChanges, 
                                            'keydown.enter': cancelChanges,
                                            'keydown.space': cancelChanges,
                                            'keydown.tab': onTab
                                            }"
            [scope]="this">
            {{ messageFor('columnsReset') }}
          </button>
          <button
            #applyButton
            kendoButton
            type="button"
            [svgIcon]="checkIcon"
            icon="check"
            size="large"
            fillMode="solid"
            themeColor="primary"
                [kendoEventsOutsideAngular]="{click: applyChanges,
                                            'keydown.enter': applyChanges,
                                            'keydown.space': applyChanges
                                            }"
            [scope]="this">
            {{ messageFor('columnsApply') }}
          </button>
        </ng-template>
        
        <ng-template #filterFooterButtons>
          <button
            kendoButton
            size="large"
            fillMode="solid"
            (click)="adaptiveGridService.resetFilter()">
            {{messageFor('filterClearButton')}}
          </button>
          <button
            kendoButton
            size="large"
            fillMode="solid"
            themeColor="primary"
            [disabled]="adaptiveGridService.filterMenuContainer.disabled"
            (click)="adaptiveGridService.submitFilter()">
            {{messageFor('filterFilterButton')}}
          </button>
        </ng-template>
        `,
      standalone: true,
      imports: [NgTemplateOutlet, ActionSheetComponent, ActionSheetViewComponent, FilterToolbarToolComponent, GroupToolbarToolComponent, ButtonComponent, ActionSheetHeaderTemplateDirective, ActionSheetContentTemplateDirective, ActionSheetFooterTemplateDirective, ButtonComponent, ColumnMenuContainerComponent, ColumnMenuFilterComponent, ColumnMenuSortComponent, ColumnMenuLockComponent, ColumnMenuStickComponent, ColumnMenuPositionComponent, ColumnMenuChooserComponent, ColumnMenuAutoSizeColumnComponent, ColumnMenuAutoSizeAllColumnsComponent, ColumnMenuItemComponent, ColumnMenuItemDirective, FilterMenuContainerComponent, ColumnMenuLockComponent, EventsOutsideAngularDirective, FormComponent, ColumnChooserContentComponent]
    }]
  }], () => [{
    type: ColumnMenuService
  }, {
    type: AdaptiveGridService
  }, {
    type: FilterService
  }, {
    type: ContextService
  }, {
    type: AdaptiveService
  }, {
    type: SortService
  }, {
    type: ColumnInfoService
  }], {
    columnChooserContent: [{
      type: ViewChild,
      args: ["columnChooserContent", {
        static: false
      }]
    }],
    filterToolbarToolTemplate: [{
      type: ViewChild,
      args: ["filterToolbarToolTemplate", {
        read: ViewContainerRef,
        static: false
      }]
    }],
    filterMenuContainer: [{
      type: ViewChild,
      args: ["filterMenuContainer"]
    }],
    actionSheet: [{
      type: ViewChild,
      args: [ActionSheetComponent]
    }],
    groupToolbarTool: [{
      type: ViewChild,
      args: [GroupToolbarToolComponent]
    }]
  });
})();
var createControl = (source) => (acc, key) => {
  acc[key] = new FormControl(source[key]);
  return acc;
};
var validateColumnsField = (columns) => expandColumns(columns.toArray()).filter(isColumnComponent).filter(({
  field
}) => !isValidFieldName(field)).forEach(({
  field
}) => console.warn(ColumnConfigurationErrorMessages.fieldName(field)));
var handleExpandCollapseGroupsService = (service, expandEmitter, collapseEmitter, map3) => service.changes.pipe(filter(({
  group: group2,
  emit
}) => emit && isPresent7(group2))).subscribe((x) => x.expand ? expandEmitter.emit(map3(x)) : collapseEmitter.emit(map3(x)));
var handleExpandCollapseDetailsService = (service, expandEmitter, collapseEmitter, map3) => service.changes.pipe(filter(({
  dataItem
}) => isPresent7(dataItem))).subscribe((x) => x.expand ? expandEmitter.emit(map3(x)) : collapseEmitter.emit(map3(x)));
var isInEditedCell = (element, gridElement, isStacked = false) => (closest5(element, matchesClasses2("k-grid-edit-cell")) || isStacked && closest5(element, matchesClasses2("k-grid-stack-edit-cell"))) && closest5(element, matchesNodeName("kendo-grid")) === gridElement;
var NOTIFY_DELAY = 500;
var GridComponent = class _GridComponent {
  supportService;
  selectionService;
  cellSelectionService;
  wrapper;
  groupInfoService;
  groupsService;
  changeNotification;
  detailsService;
  editService;
  filterService;
  pdfService;
  responsiveService;
  renderer;
  excelService;
  ngZone;
  scrollSyncService;
  domEvents;
  columnResizingService;
  changeDetectorRef;
  columnReorderService;
  columnInfoService;
  navigationService;
  sortService;
  scrollRequestService;
  localization;
  ctx;
  sizingService;
  adaptiveGridService;
  rowReorderService;
  dataMappingService;
  aiRequestResponseService;
  idService;
  /**
   * Sets the data of the Grid. If you provide an array, the Grid gets the total count automatically.
   * ([more information and example]({% slug binding_grid %})).
   */
  set data(value2) {
    this._data = value2;
    if (this.selectable && this.selectableSettings?.enabled && this.isVirtual) {
      this.blockArrowSelection = false;
    }
    if (this.notifyTimeout) {
      clearTimeout(this.notifyTimeout);
      this.notifyTimeout = null;
    }
    if (this.rowReorderable) {
      this.ngZone.runOutsideAngular(() => {
        this.notifyTimeout = setTimeout(() => {
          this.notifyReorderContainers();
        }, NOTIFY_DELAY);
      });
    }
  }
  get data() {
    return this._data;
  }
  get hintText() {
    return this.rowReorderService.getDefaultHintText(this.columnList, this.flatData);
  }
  /**
   * @hidden
   */
  get customHintTemplate() {
    if (this.rowReorderable) {
      const allColumns = this.columnList.toArray();
      const rowReorderColumn = allColumns.find((column) => column.isRowReorderColumn);
      return rowReorderColumn.rowDragHintTemplateRef;
    }
  }
  /**
   * @hidden
   */
  get hintContext() {
    if (this.customHintTemplate) {
      const draggedRow = this.rowReorderService?.getDraggedRow(this.flatData);
      return {
        $implicit: draggedRow?.dataItem,
        rowIndex: draggedRow?.rowIndex
      };
    }
  }
  /**
   * Defines the page size used by the Grid pager.
   * Required for the [`paging`]({% slug paging_grid %}) feature.
   */
  pageSize;
  /**
   * Defines the height in pixels for the Grid when `scrollable` is set.
   * You can also set the height using `style.height` with units like `px`, `%`, `em`, or `rem`.
   */
  height;
  /**
   * Sets the `style.height` attribute of each Grid data or group header/footer row (`tr`) element in the DOM in pixels.
   * If some row cells have content that requires more space, the row automatically expands to fit the content.
   */
  rowHeight;
  /**
   * Enables or disables adaptive mode. Adaptive rendering is off by default.
   *
   * @default 'none'
   */
  adaptiveMode = "none";
  /**
   * Sets the `style.height` attribute of each Grid detail row (`tr.k-detail-row`) element in the DOM in pixels.
   * If the detail row has content that requires more space, the row automatically expands to fit the content.
   */
  detailRowHeight;
  /**
   * Defines the number of records to skip in the pager.
   * Required for the [`paging`]({% slug paging_grid %}) feature.
   */
  get skip() {
    return this._skip;
  }
  set skip(value2) {
    if (typeof value2 === "number" && value2 >= 0) {
      this._skip = this.rowReorderService.skip = value2;
    }
  }
  /**
   * Defines the scroll mode for the Grid.
   *
   * @default 'scrollable'
   */
  scrollable = "scrollable";
  /**
   * Enables the selection feature of the Grid. The `selectable` property can be set to `true`, `false`, or an object with additional settings.
   * [See example](slug:grid_row_selection).
   *
   * @default false
   */
  selectable = false;
  /**
   * Sets the descriptors for sorting the data ([see example](slug:manual_sorting_grid)).
   */
  set sort(value2) {
    if (isArray2(value2)) {
      this._sort = value2;
    }
  }
  get sort() {
    return this._sort;
  }
  /**
   * Specifies the sizing for Grid elements like tables, buttons, and inputs.
   *
   * @default 'medium'
   */
  set size(size) {
    this._size = size;
    if (size === "none") {
      this.wrapper.nativeElement.classList.remove("k-grid-sm", "k-grid-md");
    }
    this.sizingService.changes.next(this.size);
  }
  get size() {
    return this._size;
  }
  /**
   * A function that defines how to track changes for the data rows.
   * By default, the Grid tracks changes by the index of the data item.
   * Edited rows are tracked by reference.
   * [See example](slug:track_changes_grid).
   */
  trackBy = defaultTrackBy;
  /**
   * Sets the filter descriptor for the data ([see examples](slug:manual_filtering_grid)).
   */
  filter;
  /**
   * Sets the descriptors for grouping the data ([see example](slug:manual_grouping_grid)).
   */
  set group(value2) {
    if (isArray2(value2)) {
      this._group = value2;
    }
  }
  get group() {
    return this._group;
  }
  /**
   * If `true`, renders only columns in the current viewport.
   *
   * @default false
   */
  virtualColumns = false;
  /**
   * @hidden
   */
  get showStatusBar() {
    return !!this.selectable;
  }
  /**
   * @hidden
   */
  get showTopToolbar() {
    return this.toolbarTemplate && ["top", "both"].indexOf(this.toolbarTemplate.position) > -1;
  }
  /**
   * @hidden
   */
  get showBottomToolbar() {
    return this.toolbarTemplate && ["bottom", "both"].indexOf(this.toolbarTemplate.position) > -1;
  }
  /**
   * @hidden
   */
  get isLocked() {
    return this.lockedLeafColumns.length > 0 && !this.isStacked;
  }
  /**
   * @hidden
   */
  get showTopPager() {
    const position2 = this.pageable.position;
    return this.pageable !== false && ["top", "both"].indexOf(position2) > -1;
  }
  /**
   * @hidden
   */
  get showBottomPager() {
    const position2 = this.pageable.position;
    return this.pageable !== false && position2 !== "top";
  }
  /**
   * @hidden
   */
  get hasPager() {
    return this.showTopPager || this.showBottomPager;
  }
  /**
   * @hidden
   */
  get showGroupPanel() {
    const isGroupable = this.groupable && this.groupable.enabled !== false;
    const isGrouped = this.group?.length > 0;
    return this.isStacked ? isGroupable && isGrouped : isGroupable;
  }
  /**
   * @hidden
   */
  get groupableEmptyText() {
    return this.groupable.emptyText;
  }
  /**
   * @hidden
   */
  get marqueeSelection() {
    return this.selectionService.enableMarquee || this.cellSelectionService.enableMarquee;
  }
  /**
   * @hidden
   */
  get isAdaptiveModeEnabled() {
    return this.adaptiveMode === "auto";
  }
  /**
   * @hidden
   *
   * The `isOpen` property is used to determine if a Grid Popup or ActionSheet is open.
   */
  get isOpen() {
    return isPresent7(this.adaptiveGridService.popupRef) || this.isActionSheetExpanded;
  }
  /**
   * @hidden
   */
  get isActionSheetExpanded() {
    return Boolean(this.adaptiveRenderer?.actionSheet?.expanded);
  }
  /**
   * @hidden
   */
  gridData = () => {
    return this.flatData;
  };
  /**
   * Enables the [filtering](slug:filtering_grid) feature of the Grid for columns with a `field` option.
   *
   * @default false
   */
  filterable = false;
  /**
   * Enables [sorting]({% slug sorting_grid %}) feature of the Grid for columns with a `field` option.
   * @default false
   */
  sortable = false;
  /**
   * Configures the Grid pager ([see example](slug:paging_grid_settings)).
   * @default false
   */
  pageable = false;
  get normalizedPageableSettings() {
    return normalize4(this.pageable);
  }
  /**
   * If `true`, allows grouping by dragging column headers ([see example]({% slug grouping_grid %})).
   *
   * @default false
   */
  groupable = false;
  /**
   * Determines if the Grid can be resized.
   *
   * @default false
   */
  gridResizable = false;
  /**
   * Enables row reordering feature of the Grid ([see example]({% slug reordering_rows_grid %})).
   *
   * @default false
   */
  set rowReorderable(value2) {
    this._rowReorderable = value2;
    if (value2) {
      this.rowReorderSubscription = this.rowReorderService.rowReorder.subscribe((args) => {
        this.ngZone.run(() => {
          this.rowReorder.emit(args);
        });
      });
    } else {
      this.rowReorderSubscription?.unsubscribe();
    }
  }
  get rowReorderable() {
    return this._rowReorderable;
  }
  /**
   * By default, navigation is enabled. To disable, set to `false`.
   * To enable navigation for specific sections, provide a [`GridNavigableSection`](slug:api_grid_gridnavigablesection).
   */
  set navigable(value2) {
    if (typeof value2 === "boolean") {
      this._navigable = value2 ? ["table", "pager", "toolbar"] : [];
      this.ctx.navigable = value2;
      return;
    } else {
      this.ctx.navigable = value2.includes("table");
    }
    this._navigable = value2;
  }
  get navigable() {
    return this._navigable;
  }
  /**
   * If `true`, resizes columns during initialization to fit headers and content.
   * Columns with `autoSize` set to `false` are excluded.
   * [See example](slug:resizing_columns_grid).
   *
   * @default false
   */
  autoSize = false;
  /**
   * Sets a function to apply custom CSS classes to each data row ([see example](slug:styling_grid_rows)).
   */
  set rowClass(fn) {
    if (isDevMode() && typeof fn !== "function") {
      throw new Error(GridConfigurationErrorMessages.functionType("rowClass", fn));
    }
    this._rowClass = fn;
  }
  get rowClass() {
    return this._rowClass;
  }
  /**
   * Sets a function to determine if a data row is sticky (always visible after scrolling).
   */
  set rowSticky(fn) {
    if (isDevMode() && isPresent7(fn) && typeof fn !== "function") {
      throw new Error(GridConfigurationErrorMessages.functionType("rowSticky", fn));
    }
    if (isPresent7(fn)) {
      this._rowSticky = fn;
    }
  }
  get rowSticky() {
    return this._rowSticky;
  }
  /**
   * Sets a function to determine if a data row is selected ([see example]({% slug grid_selection_custom %}#toc-setting-the-selected-rows)).
   */
  set rowSelected(fn) {
    if (isDevMode() && typeof fn !== "function") {
      throw new Error(GridConfigurationErrorMessages.functionType("rowSelected", fn));
    }
    this._rowSelected = fn;
  }
  get rowSelected() {
    return this._rowSelected;
  }
  /**
   * Sets a function to determine if a data row is selectable.
   */
  set isRowSelectable(fn) {
    if (isDevMode() && typeof fn !== "function") {
      throw new Error(GridConfigurationErrorMessages.functionType("isRowSelectable", fn));
    }
    this._isRowSelectable = fn;
  }
  get isRowSelectable() {
    return this._isRowSelectable;
  }
  /**
   * Sets a function to determine if a data cell is selected.
   * The function returns an object with `selected` and `item` properties ([see example]({% slug grid_selection_custom %}#toc-setting-the-selected-cells)).
   */
  set cellSelected(fn) {
    if (isDevMode() && typeof fn !== "function") {
      throw new Error(GridConfigurationErrorMessages.functionType("cellSelected", fn));
    }
    this._cellSelected = fn;
  }
  get cellSelected() {
    return this._cellSelected;
  }
  /**
   * Returns the currently focused cell (if any).
   */
  get activeCell() {
    return this.navigationService.activeCell;
  }
  /**
   * Returns the currently focused row (if any).
   */
  get activeRow() {
    return this.navigationService.activeRow;
  }
  /**
   * Returns the current Grid selection.
   *
   * @hidden
   */
  get selection() {
    return this.selectable || this.selectionDirective ? this.defaultSelection ? this.defaultSelection.stateToArray() : this.selectionDirective.stateToArray() : [];
  }
  /**
   * Gets the current `GridState`, including data operations and column state.
   * Use this to store and restore the Grid state.
   */
  get currentState() {
    return {
      filter: this.filter,
      group: this.group,
      sort: this.sort,
      skip: this.skip,
      take: this.pageSize,
      columnsState: this.columns.toArray().flatMap(recursiveColumnsFlatMap),
      currentData: structuredClone(this.data)
    };
  }
  /**
   * If `true`, allows resizing columns by dragging header cell edges ([see example]({% slug resizing_columns_grid %})).
   *
   * @default false
   */
  resizable = false;
  /**
   * If `true`, allows reordering columns by dragging header cells ([see example]({% slug reordering_columns_grid %})).
   *
   * @default false
   */
  reorderable = false;
  /**
   * If `true`, displays the Grid loading indicator ([see example]({% slug binding_grid %})).
   *
   * @default false
   */
  set loading(value2) {
    this._loading = value2;
    this.rowReorderable && this.notifyReorderContainers();
  }
  get loading() {
    return this._loading;
  }
  /**
   * If `true`, displays the column menu for columns ([see example]({% slug columnmenu_grid %})).
   *
   * @default false
   */
  columnMenu = false;
  /**
   * If `true`, hides the Grid header. The header is visible by default.
   * The header includes column headers and the [filter row](slug:filter_row).
   *
   * @default false
   */
  hideHeader = false;
  /**
   * Specifies if the currently inactive toolbar tools will be visible. Applicable when the toolbar is configured using the `<kendo-toolbar>` component. By default, such tools are hidden.
   *
   * @default false
   */
  showInactiveTools = false;
  /**
   * Sets a function to determine if a specific row is expanded.
   */
  set isDetailExpanded(callback) {
    this.detailsService.userCallback = callback;
  }
  get isDetailExpanded() {
    return this.detailsService.userCallback;
  }
  /**
   * Sets a function to determine if a specific group row is expanded.
   */
  set isGroupExpanded(callback) {
    this.groupsService.userCallback = callback;
    this.groupable = isPresent7(callback);
  }
  get isGroupExpanded() {
    return this.groupsService.userCallback;
  }
  /**
   * Sets the Grid data layout display mode.
   *
   * @default 'columns'
   */
  dataLayoutMode = "columns";
  /**
   * Fires when the Grid data is filtered through the UI and the filter descriptor changes.
   */
  filterChange = new EventEmitter();
  /**
   * Fires when the page is changed through the UI ([see example]({% slug paging_grid %})).
   */
  pageChange = new EventEmitter();
  /**
   * Fires when the Grid data is grouped through the UI and the group descriptors change ([see example]({% slug grouping_grid %})).
   */
  groupChange;
  /**
   * Fires when the Grid data is sorted through the UI and the sort descriptors change ([see example]({% slug sorting_grid %})).
   */
  sortChange = new EventEmitter();
  /**
   * Fires when the Grid selection changes through the UI.
   */
  selectionChange = new EventEmitter();
  /**
   * Fires when a row is reordered through the UI.
   */
  rowReorder = new EventEmitter();
  /**
   * Fires when the data state of the Grid is changed.
   */
  dataStateChange = new EventEmitter();
  /**
   * Fires when the data or columns state of the Grid is changed.
   */
  gridStateChange = new EventEmitter();
  /**
   * Fires when a group is expanded through the UI.
   */
  groupExpand = new EventEmitter();
  /**
   * Fires when a group is collapsed through the UI.
   */
  groupCollapse = new EventEmitter();
  /**
   * Fires when a detail row is expanded through the UI.
   */
  detailExpand = new EventEmitter();
  /**
   * Fires when a detail row is collapsed through the UI.
   */
  detailCollapse = new EventEmitter();
  /**
   * Fires when a row enters edit mode ([see example](slug:inline_editing_grid#editing-records-1)).
   */
  edit = new EventEmitter();
  /**
   * Fires when editing is canceled by clicking the **Cancel** command button ([see example]({% slug inline_editing_grid %}#toc-canceling-editing-1)).
   */
  cancel = new EventEmitter();
  /**
   * Fires when a row is saved by clicking the **Save** command button ([see example]({% slug inline_editing_grid %}#toc-saving-records-1)).
   */
  save = new EventEmitter();
  /**
   * Fires when a row is removed by clicking the **Remove** command button ([see example]({% slug inline_editing_grid %}#toc-removing-records-1)).
   */
  remove = new EventEmitter();
  /**
   * Fires when a new row is added by clicking the **Add** command button ([see example]({% slug inline_editing_grid %}#toc-adding-records-1)).
   */
  add = new EventEmitter();
  /**
   * Fires when a cell edit is closed ([see example](slug:editing_incell_grid)).
   */
  cellClose = new EventEmitter();
  /**
   * Fires when a cell is clicked ([see example](slug:editing_incell_grid)).
   */
  cellClick;
  /**
   * Fires when the PDF export command is triggered.
   */
  pdfExport = new EventEmitter();
  /**
   * Fires when the Excel export command is triggered.
   */
  excelExport = new EventEmitter();
  /**
   * Fires when columns are resized.
   */
  columnResize;
  /**
   * Fires when columns are reordered.
   */
  columnReorder = new EventEmitter();
  /**
   * Fires when column visibility changes.
   */
  columnVisibilityChange = new EventEmitter();
  /**
   * Fires when columns are locked or unlocked.
   */
  columnLockedChange = new EventEmitter();
  /**
   * Fires when columns are made sticky or unsticky.
   */
  columnStickyChange = new EventEmitter();
  /**
   * Fires when the last record is scrolled into view ([see example]({% slug scrollmmodes_grid %}#toc-endless-scrolling)).
   */
  scrollBottom = new EventEmitter();
  /**
   * Fires when the grid content is scrolled.
   * The event is triggered outside the Angular zone for performance. Enter the Angular zone if you make changes that require change detection.
   */
  contentScroll = new EventEmitter();
  /**
   * A query list of all declared columns.
   */
  columns = new QueryList();
  get dir() {
    return this.direction;
  }
  hostClass = true;
  get sizeSmallClass() {
    return this.size === "small";
  }
  get sizeMediumClass() {
    return this.size === "medium" || !this.size;
  }
  get stackedClass() {
    return this.dataLayoutMode === "stacked";
  }
  get lockedClasses() {
    return this.lockedLeafColumns.length > 0 && !this.isStacked;
  }
  get virtualClasses() {
    return this.isVirtual;
  }
  get noScrollbarClass() {
    return this.scrollbarWidth === 0;
  }
  get isResizable() {
    return Boolean(this.gridResizable);
  }
  get minWidth() {
    return this.gridResizable.minWidth;
  }
  get maxWidth() {
    return this.gridResizable.maxWidth;
  }
  get minHeight() {
    return this.gridResizable.minHeight;
  }
  get maxHeight() {
    return this.gridResizable.maxHeight;
  }
  detailTemplateChildren;
  get detailTemplate() {
    if (this._customDetailTemplate) {
      return this._customDetailTemplate;
    }
    return this.detailTemplateChildren ? this.detailTemplateChildren.first : void 0;
  }
  set detailTemplate(detailTemplate) {
    this._customDetailTemplate = detailTemplate;
  }
  cellLoadingTemplateChildren;
  get cellLoadingTemplate() {
    if (this._cellLoadingTemplate) {
      return this._cellLoadingTemplate;
    }
    return this.cellLoadingTemplateChildren ? this.cellLoadingTemplateChildren.first : void 0;
  }
  set cellLoadingTemplate(cellLoadingTemplate) {
    this._cellLoadingTemplate = cellLoadingTemplate;
  }
  loadingTemplateChildren;
  get loadingTemplate() {
    if (this._loadingTemplate) {
      return this._loadingTemplate;
    }
    return this.loadingTemplateChildren ? this.loadingTemplateChildren.first : void 0;
  }
  set loadingTemplate(loadingTemplate) {
    this._loadingTemplate = loadingTemplate;
  }
  statusBarTemplateChildren;
  get statusBarTemplate() {
    if (this._statusBarTemplate) {
      return this._statusBarTemplate;
    }
    return this.statusBarTemplateChildren ? this.statusBarTemplateChildren.first : void 0;
  }
  set statusBarTemplate(statusBarTemplate) {
    this._statusBarTemplate = statusBarTemplate;
  }
  noRecordsTemplateChildren;
  get noRecordsTemplate() {
    if (this._customNoRecordsTemplate) {
      return this._customNoRecordsTemplate;
    }
    return this.noRecordsTemplateChildren ? this.noRecordsTemplateChildren.first : void 0;
  }
  set noRecordsTemplate(customNoRecordsTemplate) {
    this._customNoRecordsTemplate = customNoRecordsTemplate;
  }
  pagerTemplateChildren;
  get pagerTemplate() {
    if (this._customPagerTemplate) {
      return this._customPagerTemplate;
    }
    return this.pagerTemplateChildren ? this.pagerTemplateChildren.first : void 0;
  }
  set pagerTemplate(customPagerTemplate) {
    this._customPagerTemplate = customPagerTemplate;
  }
  toolbarTemplateChildren;
  get toolbarTemplate() {
    if (this._customToolbarTemplate) {
      return this._customToolbarTemplate;
    }
    return this.toolbarTemplateChildren ? this.toolbarTemplateChildren.first : void 0;
  }
  set toolbarTemplate(customToolbarTemplate) {
    this._customToolbarTemplate = customToolbarTemplate;
  }
  columnMenuTemplates;
  lockedHeader;
  header;
  footer = new QueryList();
  ariaRoot;
  dragTargetContainer;
  dropTargetContainer;
  dialogContainer;
  windowContainer;
  adaptiveRenderer;
  listComponent;
  get scrollbarWidth() {
    return this.supportService.scrollbarWidth;
  }
  get showPagerInput() {
    return this._showPagerInput;
  }
  set showPagerInput(value2) {
    if (this._showPagerInput === value2) {
      return;
    }
    this._showPagerInput = value2;
  }
  get showPagerPageText() {
    return this._showPagerPageText;
  }
  set showPagerPageText(value2) {
    if (!this.normalizedPageableSettings?.responsive) {
      this._showPagerPageText = true;
    }
    if (this._showPagerPageText === value2) {
      return;
    }
    this._showPagerPageText = value2;
  }
  get showPagerItemsText() {
    return this._showPagerItemsText;
  }
  set showPagerItemsText(value2) {
    if (!this.normalizedPageableSettings?.responsive) {
      this._showPagerItemsText = true;
    }
    if (this._showPagerItemsText === value2) {
      return;
    }
    this._showPagerItemsText = value2;
  }
  get headerPadding() {
    if (isUniversal()) {
      return "";
    }
    const padding = Math.max(0, this.scrollbarWidth) + "px";
    const right2 = this.rtl ? 0 : padding;
    const left2 = this.rtl ? padding : 0;
    return `0 ${right2} 0 ${left2}`;
  }
  columnMenuOptions;
  columnList;
  selectionDirective = false;
  ariaRootId = `k-${guid()}`;
  showLicenseWatermark = false;
  /**
   * @hidden
   */
  licenseMessage;
  columnsContainer = new ColumnsContainer(() => this.columnList.filterHierarchy((column) => {
    if (!isUniversal()) {
      column.matchesMedia = this.matchesMedia(column);
    }
    return column.isVisible;
  }));
  view = new DataCollection(() => new DataResultIterator(this.data, this.skip, this.hasGroupFooters));
  get hasGroupFooters() {
    return this.columnsContainer.hasGroupFooter;
  }
  get showFooter() {
    return this.columnsContainer.hasFooter;
  }
  get showGroupFooters() {
    return this.groupable && this.groupable.showFooter;
  }
  get ariaRowCount() {
    return this.totalColumnLevels + 1 + this.view.total + (hasFilterRow(this.filterable) ? 1 : 0);
  }
  get ariaColCount() {
    return this.columnsContainer.leafColumnsToRender.length;
  }
  get navigation() {
    return this.navigationService;
  }
  /**
   * @hidden
   */
  get flatData() {
    return isArray2(this.data) ? this.data : this.data.data;
  }
  shouldGenerateColumns = true;
  direction;
  notifyTimeout = null;
  _sort = new Array();
  _group = new Array();
  _skip = 0;
  _data = [];
  cachedWindowWidth = 0;
  defaultSelection;
  _rowSelected = null;
  _isRowSelectable = null;
  _cellSelected = null;
  _customDetailTemplate;
  _cellLoadingTemplate;
  _loadingTemplate;
  _statusBarTemplate;
  _customNoRecordsTemplate;
  _customPagerTemplate;
  _customToolbarTemplate;
  _rowReorderable = false;
  leafViewportColumns;
  viewportColumns;
  _navigable = ["table", "pager", "toolbar"];
  _size = "medium";
  _loading = false;
  _showPagerInput = true;
  _showPagerPageText = true;
  _showPagerItemsText = true;
  get isVirtual() {
    return this.scrollable === "virtual";
  }
  get isScrollable() {
    return this.scrollable !== "none";
  }
  /**
   * @hidden
   */
  get isStacked() {
    return typeof this.dataLayoutMode === "string" ? this.dataLayoutMode !== "columns" : this.dataLayoutMode.mode !== "columns";
  }
  get visibleColumns() {
    return this.columnsContainer.allColumns;
  }
  get lockedColumns() {
    return this.columnsContainer.lockedColumns;
  }
  get nonLockedColumns() {
    return this.columnsContainer.nonLockedColumns;
  }
  get lockedLeafColumns() {
    return this.columnsContainer.lockedLeafColumns;
  }
  get stickyColumns() {
    return this.columns.filter((column) => column.sticky);
  }
  get nonLockedLeafColumns() {
    return this.columnsContainer.nonLockedLeafColumns;
  }
  get leafColumns() {
    return this.columnsContainer.leafColumns;
  }
  get totalColumnLevels() {
    return this.columnsContainer.totalLevels;
  }
  get headerColumns() {
    if (this.virtualColumns && !this.pdfService.exporting) {
      return this.viewportColumns;
    }
    return this.nonLockedColumns;
  }
  get headerLeafColumns() {
    if (this.virtualColumns && !this.pdfService.exporting) {
      return this.leafViewportColumns;
    }
    return this.nonLockedLeafColumns;
  }
  get lockedWidth() {
    if (this.isStacked) {
      return 0;
    }
    const groupCellsWidth = this.group.length * GROUP_CELL_WIDTH;
    return expandColumns(this.lockedLeafColumns.toArray()).reduce((prev, curr) => prev + (curr.width || 0), groupCellsWidth);
  }
  get nonLockedWidth() {
    if ((!this.rtl && this.lockedLeafColumns.length || this.virtualColumns) && !this.isStacked) {
      return !this.virtualColumns ? this.columnsContainer.unlockedWidth : this.leafViewportColumns.reduce((acc, column) => acc + (column.width || 0), 0);
    }
    return void 0;
  }
  get selectableSettings() {
    if (this.selectionService) {
      return this.selectionService.options;
    }
    return void 0;
  }
  get columnMenuTemplate() {
    const template = this.columnMenuTemplates.first;
    return template ? template.templateRef : null;
  }
  get totalCount() {
    if (this.isVirtual || !isPresent7(this.pageSize)) {
      return this.view.total;
    }
    return this.pageSize;
  }
  /**
   * @hidden
   */
  getDefaultSelectors(type) {
    return this.rowReorderService.defaultSelectors(this.isStacked)[type];
  }
  /**
   * @hidden
   */
  getHintSettings(type) {
    return this.rowReorderService[type];
  }
  /**
   * @hidden
   */
  blockArrowSelection = false;
  undoRedoService;
  rowsToRender;
  selectionSubscription;
  stateChangeSubscription;
  groupExpandCollapseSubscription;
  editServiceSubscription;
  detailsServiceSubscription;
  filterSubscription;
  sortSubscription;
  columnsChangeSubscription;
  pdfSubscription;
  excelSubscription;
  columnsContainerChangeSubscription;
  cellClickSubscription;
  footerChangeSubscription;
  columnResizingSubscription;
  columnReorderSubscription;
  detachElementEventHandlers;
  localizationSubscription;
  columnVisibilityChangeSubscription;
  columnLockedChangeSubscription;
  columnStickyChangeSubscription;
  focusElementSubscription;
  columnRangeChangeSubscription;
  rowReorderSubscription;
  rtl = false;
  _rowSticky;
  constructor(supportService, selectionService, cellSelectionService, wrapper, groupInfoService, groupsService, changeNotification, detailsService, editService, filterService, pdfService, responsiveService, renderer, excelService, ngZone, scrollSyncService, domEvents, columnResizingService, changeDetectorRef, columnReorderService, columnInfoService, navigationService, sortService, scrollRequestService, localization, ctx, sizingService, adaptiveGridService, rowReorderService, dataMappingService, aiRequestResponseService, idService) {
    this.supportService = supportService;
    this.selectionService = selectionService;
    this.cellSelectionService = cellSelectionService;
    this.wrapper = wrapper;
    this.groupInfoService = groupInfoService;
    this.groupsService = groupsService;
    this.changeNotification = changeNotification;
    this.detailsService = detailsService;
    this.editService = editService;
    this.filterService = filterService;
    this.pdfService = pdfService;
    this.responsiveService = responsiveService;
    this.renderer = renderer;
    this.excelService = excelService;
    this.ngZone = ngZone;
    this.scrollSyncService = scrollSyncService;
    this.domEvents = domEvents;
    this.columnResizingService = columnResizingService;
    this.changeDetectorRef = changeDetectorRef;
    this.columnReorderService = columnReorderService;
    this.columnInfoService = columnInfoService;
    this.navigationService = navigationService;
    this.sortService = sortService;
    this.scrollRequestService = scrollRequestService;
    this.localization = localization;
    this.ctx = ctx;
    this.sizingService = sizingService;
    this.adaptiveGridService = adaptiveGridService;
    this.rowReorderService = rowReorderService;
    this.dataMappingService = dataMappingService;
    this.aiRequestResponseService = aiRequestResponseService;
    this.idService = idService;
    const isValid = N(packageMetadata9);
    this.licenseMessage = getLicenseMessage(packageMetadata9);
    this.showLicenseWatermark = shouldShowValidationUI(isValid);
    this.ctx.grid = this;
    this.ctx.navigable = typeof this.navigable === "boolean" ? this.navigable : this.navigable.includes("table");
    this.groupChange = new ZoneAwareEventEmitter(this.ngZone);
    this.cellClick = new ZoneAwareEventEmitter(this.ngZone);
    this.columnResize = new ZoneAwareEventEmitter(this.ngZone);
    this.localizationSubscription = this.localization.changes.subscribe(({
      rtl
    }) => {
      this.rtl = rtl;
      this.direction = this.rtl ? "rtl" : "ltr";
    });
    this.groupInfoService.registerColumnsContainer(() => this.columnList);
    this.columnInfoService.init(this.columnsContainer, () => this.columnList);
    this.columnVisibilityChangeSubscription = this.columnInfoService.visibilityChange.subscribe((changed) => {
      this.columnVisibilityChange.emit(new ColumnVisibilityChangeEvent(changed));
    });
    this.columnLockedChangeSubscription = this.columnInfoService.lockedChange.subscribe((changed) => {
      this.columnLockedChange.emit(new ColumnLockedChangeEvent(changed));
    });
    this.columnStickyChangeSubscription = this.columnInfoService.stickyChange.subscribe((changed) => {
      this.columnStickyChange.emit(new ColumnStickyChangeEvent(changed));
    });
    this.groupExpandCollapseSubscription = handleExpandCollapseGroupsService(groupsService, this.groupExpand, this.groupCollapse, ({
      group: group2,
      groupIndex,
      parentGroup
    }) => ({
      group: group2,
      groupIndex,
      parentGroup
    }));
    this.detailsServiceSubscription = handleExpandCollapseDetailsService(detailsService, this.detailExpand, this.detailCollapse, (args) => args);
    this.filterSubscription = this.filterService.changes.subscribe((x) => {
      this.filterChange.emit(x);
    });
    this.sortSubscription = this.sortService.changes.subscribe((x) => {
      this.sortChange.emit(x);
    });
    this.attachStateChangesEmitter();
    this.attachEditHandlers();
    this.attachDomEventHandlers();
    this.pdfSubscription = this.pdfService.exportClick.subscribe(this.emitPDFExportEvent.bind(this));
    this.excelSubscription = this.excelService.exportClick.subscribe(this.saveAsExcel.bind(this));
    this.columnsContainerChange();
    this.handleColumnResize();
    this.columnList = new ColumnList(this.columns);
    this.columnReorderSubscription = this.columnReorderService.changes.subscribe(this.reorder.bind(this));
    this.columnRangeChangeSubscription = this.columnInfoService.columnRangeChange.subscribe(this.onColumnRangeChange.bind(this));
    this.columnsContainer.isStacked = this.isStacked;
  }
  /**
   * Expands the master row at the specified data row index ([see example]({% slug hierarchy_grid %})).
   *
   * This method is for backwards compatibility with legacy versions that track expanded state by row index.
   * For new development, use the [`kendoGridDetailsExpandBy` directive]({% slug api_grid_expanddetailsdirective %})
   * or provide an `isDetailExpanded` callback. See [Controlling the Expanded State]({% slug master_detail_expanded_state_grid %}) for examples.
   *
   * @param index The data row index of the master row.
   */
  expandRow(index) {
    this.toggleDetailRowLegacy(index, true);
  }
  /**
   * Collapses the master row at the specified data row index ([see example]({% slug hierarchy_grid %})).
   *
   * This method is for backwards compatibility with legacy versions that track expanded state by row index.
   * For new development, use the [`kendoGridDetailsExpandBy` directive]({% slug api_grid_expanddetailsdirective %})
   * or provide an `isDetailExpanded` callback. See [Controlling the Expanded State]({% slug master_detail_expanded_state_grid %}) for examples.
   *
   * @param index The data row index of the master row.
   */
  collapseRow(index) {
    this.toggleDetailRowLegacy(index, false);
  }
  /**
   * Expands a group header at the given hierarchical index, such as `0_1` for the second inner group of the first master group.
   *
   * This method is for backwards compatibility with legacy versions that track expanded group state by hierarchical group index.
   * If the Grid is pageable, the group indexes are offset by the current Grid [skip]({% slug api_grid_gridcomponent %}#toc-skip).
   *
   * @param {string} index The underscore-separated hierarchical index of the group.
   */
  expandGroup(index) {
    this.toggleGroupRowLegacy(index, true);
  }
  /**
   * Collapses a group header at the given hierarchical index, such as `0_1` for the second inner group of the first master group.
   *
   * This method is for backwards compatibility with legacy versions that track expanded group state by hierarchical group index.
   * If the Grid is pageable, the group indexes are offset by the current Grid [skip]({% slug api_grid_gridcomponent %}#toc-skip).
   *
   * @param {string} index The underscore-separated hierarchical index of the group.
   */
  collapseGroup(index) {
    this.toggleGroupRowLegacy(index, false);
  }
  /**
   * @hidden
   */
  resetGroupsState() {
    this.groupsService.reset();
  }
  /**
   * Builds the request body for the AI service based on the provided prompt message.
   * Allows developers to construct their own AI service requests.
   *
   * @param promptMessage - The prompt message to send to the AI service.
   * @returns The request body object ready to be sent to the AI service.
   *
   * @example
   * ```ts
   * const requestBody = this.grid.getAIRequest('Sort by Product Name ascending');
   *
   * // Send to your AI service
   * this.http.post('https://your-ai-service.com/api', requestBody).subscribe(response => {
   *   this.grid.handleAIResponse(response);
   * });
   * ```
   */
  getAIRequest(promptMessage) {
    return this.aiRequestResponseService.buildRequestBody(promptMessage);
  }
  /**
   * Processes an AI service response and applies the commands to the Grid.
   * Allows developers to handle their own AI service responses manually.
   *
   * @param response - The AI service response containing optional message and commands array.
   *
   * @example
   * ```ts
   * const response = {
   *   message: 'Applying sorting',
   *   commands: [
   *     { type: 'GridSort', sort: { field: 'ProductName', dir: 'asc' }, message: 'Sorted by Product Name' }
   *   ]
   * };
   * this.grid.handleAIResponse(response);
   * ```
   */
  handleAIResponse(response) {
    const columns = this.columnInfoService.leafNamedColumns?.map((col) => ({
      field: col.field
    })) || [];
    const leafColumns2 = this.columnInfoService.leafNamedColumns || [];
    this.aiRequestResponseService.processCommands(response.commands || [], columns, leafColumns2);
  }
  /**
   * @hidden
   */
  onDataChange() {
    this.autoGenerateColumns();
    this.changeNotification.notify();
    this.pdfService.dataChanged.emit();
    if (isPresent7(this.defaultSelection)) {
      this.defaultSelection.reset();
    }
    this.initSelectionService();
    this.updateNavigationMetadata();
  }
  ngDoCheck() {
    if (!this.isScrollable) {
      this.rowsToRender = this.dataMappingService.dataMapper(this.view, this.nonLockedLeafColumns, this.lockedLeafColumns, this.detailTemplate, this.showGroupFooters);
    }
  }
  ngOnChanges(changes) {
    if (isChanged("data", changes)) {
      this.onDataChange();
    }
    if (this.lockedLeafColumns.length && anyChanged(["pageSize", "skip", "sort", "group"], changes)) {
      this.changeNotification.notify();
    }
    if (anyChanged(["pageSize", "scrollable", "virtualColumns"], changes)) {
      this.updateNavigationMetadata();
    }
    if (isChanged("virtualColumns", changes)) {
      this.viewportColumns = this.leafViewportColumns = null;
    }
    if (isChanged("height", changes, false)) {
      this.renderer.setStyle(this.wrapper.nativeElement, "height", `${this.height}px`);
    }
    if (isChanged("filterable", changes) && this.lockedColumns.length) {
      this.syncHeaderHeight(this.ngZone.onStable.asObservable().pipe(take(1)));
    }
    if (anyChanged(["columnMenu", "sortable", "filterable"], changes, false)) {
      this.columnMenuOptions = this.columnMenu && Object.assign({
        filter: Boolean(this.filterable),
        sort: Boolean(this.sortable)
      }, this.columnMenu);
    }
    if (isChanged("scrollable", changes) && this.isScrollable) {
      this.ngZone.onStable.pipe(take(1)).subscribe(() => this.attachScrollSync());
    }
    if (isChanged("selectable", changes) && this.shouldResetSelection(changes["selectable"])) {
      if (this.defaultSelection) {
        this.defaultSelection.reset();
      } else if (this.selectionDirective) {
        this.selectionDirective.reset();
      }
    }
    if (isChanged("groupable", changes, true)) {
      this.groupable = changes["groupable"].currentValue;
    }
    if (isChanged("navigable", changes, true)) {
      if (this.navigationService.enabled) {
        this.navigationService.setActiveSections(this.navigable);
      } else {
        if (this.navigable.length) {
          this.navigationService.init(this.navigationMetadata(), this.navigable);
        }
      }
    }
    if (isChanged("dataLayoutMode", changes)) {
      if (this.isStacked) {
        this.generateStackedColumns();
      } else {
        this.stackedColumns = {
          columns: [],
          areDefault: false
        };
      }
      this.columnsContainer.isStacked = this.isStacked;
    }
  }
  ngAfterContentInit() {
    this.shouldGenerateColumns = !this.columns.length;
    this.autoGenerateColumns();
    this.columnList = new ColumnList(this.columns);
    this.columnsChangeSubscription = this.columns.changes.subscribe(() => this.verifySettings());
  }
  ngAfterViewInit() {
    this.attachScrollSync();
    this.attachElementEventHandlers();
    this.updateNavigationMetadata();
    this.applyAutoSize();
    const toolbarComponentWrapper = this.wrapper?.nativeElement?.querySelector("kendo-toolbar");
    if (toolbarComponentWrapper) {
      this.renderer.addClass(toolbarComponentWrapper, "k-grid-toolbar");
    }
  }
  ngAfterContentChecked() {
    this.columnsContainer.refresh();
    this.verifySettings();
    this.initSelectionService();
  }
  ngOnInit() {
    if (this.navigable.length) {
      this.navigationService.init(this.navigationMetadata(), this.navigable);
    }
    this.isStacked && this.generateStackedColumns();
  }
  ngOnDestroy() {
    if (this.selectionSubscription) {
      this.selectionSubscription.unsubscribe();
    }
    if (this.rowReorderSubscription) {
      this.rowReorderSubscription.unsubscribe();
    }
    if (this.columnReorderSubscription) {
      this.columnReorderSubscription.unsubscribe();
    }
    if (this.stateChangeSubscription) {
      this.stateChangeSubscription.unsubscribe();
    }
    if (this.groupExpandCollapseSubscription) {
      this.groupExpandCollapseSubscription.unsubscribe();
    }
    if (this.detailsServiceSubscription) {
      this.detailsServiceSubscription.unsubscribe();
    }
    if (this.editServiceSubscription) {
      this.editServiceSubscription.unsubscribe();
    }
    if (this.pdfSubscription) {
      this.pdfSubscription.unsubscribe();
    }
    if (this.filterSubscription) {
      this.filterSubscription.unsubscribe();
    }
    if (this.sortSubscription) {
      this.sortSubscription.unsubscribe();
    }
    if (this.columnsChangeSubscription) {
      this.columnsChangeSubscription.unsubscribe();
    }
    if (this.excelSubscription) {
      this.excelSubscription.unsubscribe();
    }
    if (this.columnsContainerChangeSubscription) {
      this.columnsContainerChangeSubscription.unsubscribe();
    }
    if (this.scrollSyncService) {
      this.scrollSyncService.destroy();
    }
    if (this.detachElementEventHandlers) {
      this.detachElementEventHandlers();
    }
    if (this.defaultSelection) {
      this.defaultSelection.destroy();
    }
    if (this.cellClickSubscription) {
      this.cellClickSubscription.unsubscribe();
    }
    if (this.footerChangeSubscription) {
      this.footerChangeSubscription.unsubscribe();
    }
    this.ngZone = null;
    if (this.columnResizingSubscription) {
      this.columnResizingSubscription.unsubscribe();
    }
    if (this.columnReorderSubscription) {
      this.columnReorderSubscription.unsubscribe();
    }
    if (this.localizationSubscription) {
      this.localizationSubscription.unsubscribe();
    }
    if (this.columnVisibilityChangeSubscription) {
      this.columnVisibilityChangeSubscription.unsubscribe();
    }
    if (this.columnLockedChangeSubscription) {
      this.columnLockedChangeSubscription.unsubscribe();
    }
    if (this.columnStickyChangeSubscription) {
      this.columnStickyChangeSubscription.unsubscribe();
    }
    if (this.focusElementSubscription) {
      this.focusElementSubscription.unsubscribe();
    }
    if (this.rowReorderSubscription) {
      this.rowReorderSubscription.unsubscribe();
    }
    this.columnRangeChangeSubscription.unsubscribe();
  }
  /**
   * @hidden
   */
  onResize() {
    if (this.isVirtual) {
      this.ctx.scroller.update();
      this.listComponent.resetNavigationViewport();
    }
  }
  /**
   * @hidden
   */
  attachScrollSync() {
    if (isUniversal()) {
      return;
    }
    if (this.header) {
      this.scrollSyncService.registerEmitter(this.header.nativeElement, "header");
    }
    if (this.footer) {
      this.footerChangeSubscription = observe(this.footer).subscribe((footers) => footers.map((footer) => footer.nativeElement).filter(isPresent7).forEach((element) => {
        this.scrollSyncService.registerEmitter(element, "footer");
        element.scrollLeft = this.wrapper.nativeElement.querySelector(".k-grid-content")?.scrollLeft;
      }));
    }
  }
  /**
   * @hidden
   */
  get ariaLabel() {
    return this.localization.get("gridLabel");
  }
  /**
   * @hidden
   */
  messageFor = (token) => this.localization.get(token);
  /**
   * Switches the specified table row to edit mode ([see example]({% slug inline_editing_grid %}#toc-editing-records-1)).
   *
   * @param rowIndex The data row index to switch to edit mode.
   * @param group The [`FormGroup`](link:site.data.urls.angular['formgroupapi']) that describes the edit form.
   * @param options Additional options to configure the focus target when the editor opens.
   */
  editRow(rowIndex, group2, options) {
    this.editService.editRow(rowIndex, group2);
    if (isPresent7(options) && options.skipFocus) {
      return;
    }
    const row2 = `tr[data-kendo-grid-item-index="${rowIndex}"]`;
    const columnIndex = options && options.columnIndex;
    const target = isNaN(columnIndex) ? row2 : `${row2} td[data-kendo-grid-column-index="${columnIndex}"]`;
    this.focusEditElement(target);
  }
  /**
   * @hidden
   */
  handleReorderEvents(ev, evType) {
    this.rowReorderService[evType](ev);
  }
  /**
   * Closes the editor for the specified row ([see example]({% slug inline_editing_grid %}#toc-canceling-editing-1)).
   *
   * @param {number} index The row index to switch out of edit mode. If you do not provide an index, the new item editor closes.
   */
  closeRow(index) {
    this.editService.close(index);
    this.isStacked && (this.navigationService.stackedCellEntered = false);
  }
  /**
   * Creates a new row editor ([see example]({% slug inline_editing_grid %}#toc-adding-records-1)).
   *
   * @param {FormGroup} group The [`FormGroup`](link:site.data.urls.angular['formgroupapi']) that describes the edit form. If you pass a data item, the method builds the `FormGroup` from the data item fields.
   */
  addRow(group2) {
    const isFormGroup = group2 instanceof FormGroup;
    if (!isFormGroup) {
      const fields = Object.keys(group2).reduce(createControl(group2), {});
      group2 = new FormGroup(fields);
    }
    this.editService.addRow(group2);
    this.focusEditElement(".k-grid-add-row");
  }
  /**
   * Puts the specified cell in edit mode ([see example](slug:editing_incell_grid)).
   *
   * @param {number} rowIndex The data row index to switch to edit mode.
   * @param {number|string|any} column The leaf column index, field name, or column instance to edit.
   * @param {FormGroup} group The [`FormGroup`](link:site.data.urls.angular['formgroupapi']) that describes the edit form.
   */
  editCell(rowIndex, column, group2) {
    const instance = this.columnInstance(column);
    this.editService.editCell(rowIndex, instance, group2);
    this.focusEditElement(this.isStacked ? ".k-grid-stack-edit-cell" : ".k-grid-edit-cell");
  }
  /**
   * Closes the current cell in edit mode and fires the [`cellClose`]({% slug api_grid_gridcomponent %}#toc-cellclose) event.
   *
   * @returns {boolean} `true` if the cell closed. Returns `false` if the [`cellClose`]({% slug api_grid_gridcomponent %}#toc-cellclose) event was prevented.
   */
  closeCell() {
    return !this.editService.closeCell();
  }
  /**
   * Closes the current cell in edit mode.
   */
  cancelCell() {
    this.editService.cancelCell();
  }
  /**
   * Returns `true` if a row or cell is currently edited.
   *
   * @returns {boolean} `true` if a row or cell is currently edited.
   */
  isEditing() {
    return this.editService.isEditing();
  }
  /**
   * Returns `true` if a cell is currently edited.
   *
   * @returns {boolean} `true` if a cell is currently being edited.
   */
  isEditingCell() {
    return this.editService.isEditingCell();
  }
  /**
   * Initiates the PDF export ([see example]({% slug pdfexport_grid %})).
   */
  saveAsPDF() {
    this.pdfService.save(this);
  }
  /**
   * Exports the Grid element to a Drawing [Group]({% slug api_kendo-drawing_group %}) using the `kendo-grid-pdf` component options
   * ([see example]({% slug pdfexport_grid %}#toc-exporting-multiple-grids-to-the-same-pdf)).
   *
   * @returns {Promise} A promise that resolves with the Drawing `Group`.
   */
  drawPDF() {
    const promise = createPromise();
    this.pdfService.draw(this, promise);
    return promise;
  }
  /**
   * Initiates the Excel export ([see example]({% slug excelexport_grid %})).
   */
  saveAsExcel() {
    this.excelService.save(this);
  }
  /**
   * Applies the given `GridState` object to the Grid.
   */
  loadState(state2) {
    if (state2.columnsState) {
      this.traverseColumns(this.columns, (column) => {
        const columnState = state2.columnsState.find((col) => col.id === column.id);
        if (columnState) {
          column.width = columnState.width;
          column.hidden = columnState.hidden;
          column.locked = columnState.locked;
          column.sticky = columnState.sticky;
          column.orderIndex = columnState.orderIndex;
        }
      });
      this.columns.reset(this.columns.toArray());
      this.columnsContainer.refresh();
    }
    this.sort = state2.sort;
    this.group = state2.group;
    this.filter = state2.filter;
    this.skip = state2.skip;
    this.pageSize = state2.take;
    if (state2.currentData) {
      this.data = state2.currentData;
    }
    this.changeDetectorRef.markForCheck();
  }
  traverseColumns(columns, callback) {
    columns.forEach((column) => {
      if (column.isColumnGroup || column.isSpanColumn) {
        this.traverseColumns(column.children, callback);
      } else {
        callback(column);
      }
    });
  }
  /**
   * Applies the minimum possible width for the specified column so the whole text fits without wrapping.
   * This method expects the Grid to be [`resizable`](slug:resizing_columns_grid). Run this method after the Grid is populated with data.
   * [See example](slug:resizing_columns_grid#toc-auto-fitting-the-content)
   */
  autoFitColumn(column) {
    this.columnResizingService.autoFit(column);
  }
  /**
   * Adjusts the width of the specified columns to fit the entire content, including headers, without wrapping.
   * If you do not specify columns, `autoFitColumns` applies to all columns. Run this method after the Grid is populated with data.
   * [See example](slug:resizing_columns_grid#toc-auto-fitting-the-content)
   */
  autoFitColumns(columns = this.columns) {
    let cols;
    if (columns instanceof QueryList) {
      cols = columns.toArray();
    } else {
      cols = columns;
    }
    this.columnResizingService.autoFit(...cols);
  }
  /**
   * Adjusts the width of the Grid columns to fit the entire Grid width.
   * - when the sum of all columns widths is less than the available Grid width&mdash;the available space is distributed evenly between all columns.
   * - when the sum of all columns widths is greater than the available Grid width&mdash;the columns are shrinked equally to fit the Grid width.
   *
   * Run this method after the Grid is populated with data.
   */
  autoFitColumnsToGrid() {
    const gridElement = this.wrapper.nativeElement;
    if (!gridElement) {
      return;
    }
    const leafColumns2 = this.columnsContainer.leafColumns.toArray();
    if (!leafColumns2.length || leafColumns2.length === 0) {
      return;
    }
    this.columnResizingService.autoFitToGrid(gridElement, this.scrollbarWidth, ...leafColumns2);
  }
  /**
   * @hidden
   */
  notifyPageChange(source, event) {
    if (source === "list" && !this.isVirtual) {
      return;
    }
    this.pageChange.emit(event);
  }
  /**
   * @hidden
   */
  handlePagerVisibilityChange(prop2, ev) {
    this[prop2] = ev;
  }
  /**
   * @hidden
   */
  notifyScrollBottom() {
    if (this.scrollable === "none") {
      return;
    }
    if (hasObservers(this.scrollBottom)) {
      this.ngZone.run(() => this.scrollBottom.emit({
        sender: this
      }));
    }
  }
  /**
   * @hidden
   */
  focusEditElement(containerSelector) {
    if (this.focusElementSubscription) {
      this.focusElementSubscription.unsubscribe();
    }
    this.ngZone.runOutsideAngular(() => {
      this.focusElementSubscription = this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {
        const wrapper = this.wrapper.nativeElement;
        if (!this.setEditFocus(wrapper.querySelector(containerSelector)) && this.isLocked) {
          this.setEditFocus(wrapper.querySelector(`.k-grid-content ${containerSelector}`));
        }
        this.focusElementSubscription = null;
      });
    });
  }
  /**
   * Focuses the last active or the first cell of the Grid.
   *
   * @returns {NavigationCell} The focused cell.
   */
  focus() {
    this.assertNavigable();
    return this.navigationService.focusCell();
  }
  /**
   * Focuses the cell with the specified row and column index.
   *
   * The row index is based on the logical structure of the Grid and does not correspond to the data item index.
   * Header rows are included, starting at index 0.
   * Group headers and footers are included.
   * The row indexing is absolute and does not change with paging.
   *
   * If the Grid is configured for scrolling, including virtual scrolling, the scroll position will be updated.
   * If the row is not present on the current page, the method will have no effect.
   *
   * @param rowIndex The logical row index to focus. The top header row has an index 0.
   * @param colIndex The column index to focus.
   * @returns {NavigationCell} The focused cell.
   *
   */
  focusCell(rowIndex, colIndex) {
    this.assertNavigable();
    return this.navigationService.focusCell(rowIndex, colIndex);
  }
  /**
   * Focuses the next cell, optionally wrapping to the next row.
   *
   * @param wrap A Boolean value which indicates if the focus will move to the next row. Defaults to `true`.
   * @returns {NavigationCell} The focused cell. If the focus is already on the last cell, returns `null`.
   */
  focusNextCell(wrap = true) {
    this.assertNavigable();
    return this.navigationService.focusNextCell(wrap);
  }
  /**
   * Focuses the previous cell. Optionally wraps to the previous row.
   *
   * @param wrap - A Boolean value which indicates if the focus will move to the next row. Defaults to `true`.
   * @returns {NavigationCell} The focused cell. If the focus is already on the first cell, returns `null`.
   */
  focusPrevCell(wrap = true) {
    this.assertNavigable();
    return this.navigationService.focusPrevCell(wrap);
  }
  /**
   * Scrolls to the specified row and column ([see example](slug:scrollmmodes_grid#toc-scrolling-to-a-specific-row-and-column)).
   */
  scrollTo(request) {
    this.scrollRequestService.scrollTo(request, false);
  }
  /**
   * Scrolls to the specified data item and column ([see example](slug:scrollmmodes_grid#toc-scrolling-to-a-specific-item)).
   */
  scrollToItem(request) {
    this.scrollRequestService.scrollToItem(request);
  }
  /**
   * Changes the position of the specified column.
   * The reordering of columns operates only on the level inferred by the source column.
   * For this method to work, the `source` column must be visible.
   *
   * @param {ColumnBase} source The column to move.
   * @param {number} destIndex The new position of the column.
   * @param {ColumnReorderConfig} options Additional options.
   */
  reorderColumn(source, destIndex, options = {
    before: false
  }) {
    const columnsForLevel = sortColumns(this.allColumnsForLevel(source.level));
    let target = columnsForLevel[destIndex];
    if (!target) {
      return;
    }
    const lastNonLocked2 = target.isLocked && !source.isLocked && this.columnsContainer.nonLockedColumns.length === 1;
    if (lastNonLocked2) {
      return;
    }
    if (isSpanColumnComponent(target) && !options.before) {
      target = target.children.last;
    }
    this.reorder({
      before: options.before,
      source,
      target
    });
  }
  /**
   * @hidden
   */
  updateNavigationMetadata() {
    this.navigationService.metadata = this.navigationMetadata();
  }
  reorder({
    target,
    source,
    before,
    changeContainer
  }) {
    this.ngZone.run(() => {
      const columnsForLevel = sortColumns(this.allColumnsForLevel(source.level));
      let newIndex = columnsForLevel.indexOf(target);
      if (target.parent && target.parent.isSpanColumn) {
        newIndex = columnsForLevel.indexOf(target.parent);
        if (before) {
          target = target.parent;
        }
      }
      const oldIndex = columnsForLevel.indexOf(source);
      if (changeContainer) {
        if (before && 0 < newIndex && oldIndex < newIndex) {
          newIndex--;
        } else if (!before && oldIndex > newIndex) {
          newIndex++;
        }
      }
      const args = new ColumnReorderEvent({
        column: source,
        oldIndex,
        newIndex
      });
      this.columnReorder.emit(args);
      if (args.isDefaultPrevented()) {
        return;
      }
      if (changeContainer) {
        this.columnLockedChange.emit(new ColumnLockedChangeEvent([source]));
      }
      this.updateColumnIndices({
        columnsForLevel,
        source,
        target,
        before
      });
      if (source.locked !== target.locked) {
        source.locked = target.locked;
      }
      this.columnsContainer.refresh();
      if (this.virtualColumns) {
        this.listComponent.updateViewportColumns();
      }
      this.changeDetectorRef.markForCheck();
    });
  }
  updateColumnIndices({
    columnsForLevel,
    source,
    target,
    before
  }) {
    const expandedColumns = expandColumnsWithSpan(columnsForLevel);
    const sourceColumnIndex = expandedColumns.indexOf(source);
    let nextSourceIndex = 0;
    let nextIndex = 0;
    let toSkip = 1;
    if (source.isSpanColumn) {
      toSkip += source.children.length;
    }
    let i = 0;
    while (i < expandedColumns.length) {
      const column = expandedColumns[i];
      if (column === target) {
        nextSourceIndex = before ? nextIndex : nextIndex + 1;
        nextIndex = before ? nextIndex + toSkip : nextIndex;
        column.orderIndex = nextIndex;
        if (nextSourceIndex === nextIndex + 1) {
          nextIndex += toSkip;
        }
      } else if (column === source) {
        i += toSkip;
        column.isReordered = true;
        continue;
      } else {
        column.orderIndex = nextIndex;
      }
      column.isReordered = true;
      nextIndex++;
      i++;
    }
    for (i = sourceColumnIndex; i < sourceColumnIndex + toSkip; i++) {
      expandedColumns[i].orderIndex = nextSourceIndex++;
      expandedColumns[i].isReordered = true;
    }
    this.updateIndicesForLevel(source.level + 1);
    this.columnResizingService.areColumnsReordered = true;
  }
  updateIndicesForLevel(level) {
    const colsForParentLevel = this.allColumnsForLevel(level - 1);
    const colsForLevel = [];
    sortColumns(colsForParentLevel).forEach((c) => {
      if (c.isColumnGroup) {
        colsForLevel.push(...c.childrenArray.sort((a, b) => a.orderIndex - b.orderIndex));
      }
    });
    expandColumnsWithSpan(colsForLevel).forEach((c, i) => {
      c.orderIndex = i;
      c.isReordered = true;
    });
    if (level < this.columnList.totalColumnLevels()) {
      this.updateIndicesForLevel(level + 1);
    }
  }
  allColumnsForLevel(level) {
    return this.columnList.toArray().filter((column) => column.level === level);
  }
  initSelectionService() {
    if (!this.selectable) {
      this.selectionService.ngOnDestroy();
      this.cellSelectionService.ngOnDestroy();
      return;
    }
    if (!this.selectionDirective && !isPresent7(this.defaultSelection)) {
      this.defaultSelection = new Selection(this.ctx, this.changeDetectorRef);
    }
    const cellSelectionMode = this.selectable["cell"];
    const activeService = cellSelectionMode ? this.cellSelectionService : this.selectionService;
    const inactiveService = cellSelectionMode ? this.selectionService : this.cellSelectionService;
    if (inactiveService.active) {
      inactiveService.ngOnDestroy();
      activeService.addSubscriptions();
      inactiveService.active = false;
    }
    activeService.active = true;
    activeService.init({
      cellSelected: cellSelectionMode ? this.cellSelected : void 0,
      rowSelected: cellSelectionMode ? void 0 : this.rowSelected,
      isRowSelectable: this.isRowSelectable,
      selectable: this.selectable,
      view: this.view,
      columns: cellSelectionMode ? this.columnList.toArray() : void 0,
      isStacked: this.isStacked
    });
    if (!this.selectionDirective && !this.selectableSettings.enabled) {
      this.defaultSelection.reset();
    }
    if (this.selectionSubscription) {
      this.selectionSubscription.unsubscribe();
    }
    if (cellSelectionMode) {
      this.selectionSubscription = this.cellSelectionService.changes.subscribe((event) => {
        this.ngZone.run(() => this.selectionChange.emit(event));
      });
    } else {
      this.selectionSubscription = this.selectionService.changes.subscribe((event) => {
        this.ngZone.run(() => this.selectionChange.emit(event));
      });
    }
  }
  setEditFocus(element) {
    if (element) {
      return this.navigationService.tryFocus(element);
    }
  }
  columnInstance(column) {
    let instance;
    if (typeof column === "number") {
      instance = this.columnsContainer.lockedLeafColumns.toArray().concat(this.columnsContainer.nonLockedLeafColumns.toArray())[column];
    } else if (typeof column === "string") {
      instance = this.columnList.filter((item) => item.field === column)[0];
    } else {
      instance = column;
    }
    if (!instance && isDevMode()) {
      throw new Error(ColumnConfigurationErrorMessages.invalidColumn(column));
    }
    return instance;
  }
  verifySettings() {
    if (isDevMode()) {
      const locked = this.lockedLeafColumns.length || this.columnMenu && this.columnMenu.lock;
      const stickyColumns = this.stickyColumns.length || this.columnMenu && this.columnMenu.stick;
      if (locked && this.detailTemplate) {
        throw new Error(GridConfigurationErrorMessages.incompatibleFeatures("detail template", "locked columns"));
      }
      if (stickyColumns && this.detailTemplate) {
        throw new Error(GridConfigurationErrorMessages.incompatibleFeatures("detail template", "sticky columns"));
      }
      if (this.lockedLeafColumns.length && !this.nonLockedLeafColumns.length) {
        console.warn(GridConfigurationErrorMessages.nonLockedColumnPresent);
      }
      if (!this.isStacked && (locked || this.virtualColumns) && expandColumns(this.columnList.toArray()).filter((column) => !column.width && !isColumnGroupComponent(column)).length) {
        console.warn(ColumnConfigurationErrorMessages.requiredWidth(locked ? "Locked" : "Virtual"));
      }
      if (locked && !this.isScrollable) {
        console.warn(ColumnConfigurationErrorMessages.requiredScroll("Locked"));
      }
      if (stickyColumns && !this.isScrollable) {
        console.warn(ColumnConfigurationErrorMessages.requiredScroll("Sticky"));
      }
      if (this.virtualColumns && !this.isScrollable) {
        console.warn(ColumnConfigurationErrorMessages.requiredScroll("Virtual"));
      }
      if (this.columnList.filter(isColumnGroupComponent).filter((x) => !x.hasChildren).length) {
        throw new Error(ColumnConfigurationErrorMessages.groupColumnContent);
      }
      if (this.columnList.filter((x) => x.locked && x.parent && !x.parent.isLocked).length) {
        throw new Error(ColumnConfigurationErrorMessages.lockedParent);
      }
      if (!this.isStacked && stickyColumns && expandColumns(this.columnList.toArray()).filter((column) => !column.width && !isColumnGroupComponent(column)).length) {
        console.warn(ColumnConfigurationErrorMessages.requiredWidth("Sticky"));
      }
      if (this.rowSticky && this.scrollable === "virtual") {
        throw new Error(GridConfigurationErrorMessages.incompatibleFeatures("sticky rows", 'row virtualization (scrollable="virtual")'));
      }
      if (this.rowSticky && this.groupable) {
        throw new Error(GridConfigurationErrorMessages.incompatibleFeatures("sticky rows", "grouping"));
      }
      if (this.wrapper?.nativeElement?.querySelector("kendo-toolbar") && this.toolbarTemplate) {
        console.warn(GridConfigurationErrorMessages.unsupportedToolbarConfig);
      }
      validateColumnsField(this.columnList);
    }
  }
  autoGenerateColumns() {
    if (this.shouldGenerateColumns && !this.columns.length && this.view.length) {
      this.columns.reset(Object.keys(this.view.at(0)).map((field) => {
        const column = new ColumnComponent2(void 0, this.idService);
        column.field = field;
        return column;
      }));
    }
  }
  /**
   * @hidden
   */
  stackedColumns = {
    columns: [],
    areDefault: false
  };
  generateStackedColumns() {
    if (!this.isStacked || !isPresent7(this.dataLayoutMode)) {
      return;
    }
    this.stackedColumns.columns = [];
    if (typeof this.dataLayoutMode === "object") {
      if (this.dataLayoutMode.mode === "stacked" && this.dataLayoutMode.stackedCols) {
        const columns = this.dataLayoutMode.stackedCols;
        if (typeof columns === "number") {
          for (let i = 0; i < columns; i++) {
            const currCol = {
              width: `${this.wrapper.nativeElement.clientWidth / columns}px`
            };
            this.stackedColumns.columns.push(currCol);
          }
          this.stackedColumns.areDefault = true;
        } else if (Array.isArray(columns)) {
          this.stackedColumns.columns = columns.map((colSize) => {
            const stackedColumn = {};
            if (typeof colSize === "number") {
              stackedColumn.width = `${colSize}px`;
            } else if (typeof colSize === "object" && colSize?.width) {
              stackedColumn.width = typeof colSize.width === "number" ? `${colSize.width}px` : colSize.width;
            } else if (typeof colSize === "string") {
              stackedColumn.width = colSize;
            }
            return stackedColumn;
          });
          this.stackedColumns.areDefault = false;
        }
      }
    } else {
      this.stackedColumns = {
        columns: [{
          width: this.wrapper.nativeElement.clientWidth
        }],
        areDefault: true
      };
    }
  }
  attachStateChangesEmitter() {
    this.stateChangeSubscription = merge(this.pageChange.pipe(tap(() => {
      if (this.pageable) {
        this.ctx.scroller?.reset();
      }
    }), map((x) => ({
      filter: this.filter,
      group: this.group,
      skip: x.skip,
      sort: this.sort,
      take: x.take
    }))), this.sortChange.pipe(tap(() => {
      this.ctx.scroller?.reset();
    }), map((sort2) => ({
      filter: this.filter,
      group: this.group,
      skip: this.isVirtual && !this.pageable ? 0 : this.skip,
      sort: sort2,
      take: this.pageSize
    }))), this.groupChange.pipe(tap(() => {
      this.ctx.scroller?.reset();
    }), map((group2) => ({
      filter: this.filter,
      group: group2,
      skip: this.pageable ? this.skip : 0,
      sort: this.sort,
      take: this.pageable || !group2?.length ? this.pageSize : void 0
    }))), this.filterChange.pipe(tap(() => {
      this.ctx.scroller?.reset();
    }), map((filter3) => ({
      filter: filter3,
      group: this.group,
      skip: 0,
      sort: this.sort,
      take: this.pageSize
    })))).subscribe((x) => {
      this.closeCell();
      this.cancelCell();
      if (this.selectable && this.selectableSettings?.enabled && this.isVirtual) {
        this.blockArrowSelection = true;
      }
      this.isVirtual && this.ctx.scroller?.resetVirtualSkip();
      this.dataStateChange.emit(x);
      hasObservers(this.gridStateChange) && this.gridStateChange.emit(__spreadValues(__spreadValues({}, this.currentState), x));
    });
    this.stateChangeSubscription.add(merge(this.columnReorder, this.columnResize, this.columnVisibilityChange, this.columnLockedChange, this.columnStickyChange).pipe(flatMap(() => this.ngZone.onStable.pipe(take(1)))).subscribe(() => this.ngZone.run(() => {
      hasObservers(this.gridStateChange) && this.gridStateChange.emit(this.currentState);
      if (this.isVirtual) {
        this.ctx.scroller?.update();
        this.listComponent?.resetNavigationViewport();
      }
    })));
  }
  attachEditHandlers() {
    if (!this.editService) {
      return;
    }
    this.editServiceSubscription = this.editService.changes.subscribe(this.emitCRUDEvent.bind(this));
  }
  emitCRUDEvent(args) {
    const {
      action,
      rowIndex,
      formGroup
    } = args;
    let dataItem = this.view.at(rowIndex - this.skip);
    if (action !== "add" && !dataItem) {
      dataItem = formGroup.value;
    }
    this.closeCell();
    Object.assign(args, {
      dataItem,
      sender: this
    });
    switch (action) {
      case "add":
        this.add.emit(args);
        break;
      case "cancel":
        this.cancel.emit(args);
        break;
      case "edit":
        this.edit.emit(args);
        break;
      case "remove":
        this.remove.emit(args);
        break;
      case "save":
        this.save.emit(args);
        break;
      case "cellClose":
        this.cellClose.emit(args);
        break;
      default:
        break;
    }
  }
  attachDomEventHandlers() {
    this.cellClickSubscription = this.domEvents.cellClick.subscribe((args) => {
      if (this.isStacked && !isPresent7(args.column)) {
        return;
      }
      this.cellClick.emit(Object.assign({
        sender: this
      }, args));
    });
  }
  attachElementEventHandlers() {
    if (isUniversal()) {
      return;
    }
    const wrapper = this.wrapper.nativeElement;
    const ariaRoot = this.ariaRoot.nativeElement;
    this.ngZone.runOutsideAngular(() => {
      const resizeCheck = this.resizeCheck.bind(this);
      const resizeSubscription = this.renderer.listen("window", "resize", resizeCheck);
      const orientationSubscription = this.renderer.listen("window", "orientationchange", resizeCheck);
      const documentClickSubscription = this.renderer.listen("document", "click", (args) => {
        const activeElement = document.activeElement;
        if (this.editService.shouldCloseCell() && !closest5(args.target, matchesClasses2("k-animation-container k-grid-ignore-click")) && !(activeElement && (closest5(activeElement, matchesClasses2("k-animation-container")) || isInEditedCell(activeElement, this.wrapper.nativeElement, this.isStacked)))) {
          this.editService.closeCell(args);
        }
      });
      const windowBlurSubscription = this.renderer.listen("window", "blur", (args) => {
        const activeElement = document.activeElement;
        if (activeElement && !(matchesNodeName("input")(activeElement) && activeElement.type === "file" && isInEditedCell(activeElement, this.wrapper.nativeElement, this.isStacked))) {
          this.editService.closeCell(args);
        }
        this.domEvents.windowBlur.emit(args);
      });
      const clickSubscription = this.renderer.listen(wrapper, "click", (args) => {
        this.domEvents.click.emit(args);
      });
      const keydownSubscription = this.renderer.listen(wrapper, "keydown", (args) => {
        this.domEvents.keydown.emit(args);
      });
      const shiftKeyupSubscription = this.renderer.listen(wrapper, "keyup", (args) => {
        if (args.key === "Shift") {
          this.domEvents.shiftKeyup.emit(args);
        }
      });
      let focused = false;
      const focusInSubscription = this.renderer.listen(ariaRoot, "focusin", (args) => {
        this.domEvents.focus.emit(args);
        if (!focused) {
          this.domEvents.focusIn.emit(args);
          focused = true;
        }
      });
      const focusOutSubscription = this.renderer.listen(ariaRoot, "focusout", (args) => {
        const next2 = args.relatedTarget || document.activeElement;
        const outside = !closest5(next2, (node) => node === ariaRoot);
        if (outside) {
          this.domEvents.focusOut.emit(args);
          this.domEvents.shiftKeyup.emit(args);
          focused = false;
        }
      });
      this.detachElementEventHandlers = () => {
        resizeSubscription();
        orientationSubscription();
        documentClickSubscription();
        windowBlurSubscription();
        clickSubscription();
        keydownSubscription();
        shiftKeyupSubscription();
        focusInSubscription();
        focusOutSubscription();
      };
    });
  }
  matchesMedia(c) {
    return this.responsiveService.matchesMedia(c.media);
  }
  resizeCheck() {
    if (window.innerWidth !== this.cachedWindowWidth) {
      this.cachedWindowWidth = window.innerWidth;
      let hasChanges = false;
      this.columnList.filterHierarchy((column) => {
        const matchesMedia = this.matchesMedia(column);
        if (column.matchesMedia !== matchesMedia) {
          hasChanges = true;
          column.matchesMedia = matchesMedia;
        }
        return column.isVisible;
      });
      if (hasChanges) {
        this.ngZone.run(() => {
          this.changeDetectorRef.markForCheck();
        });
      }
    }
  }
  emitPDFExportEvent() {
    const args = new PDFExportEvent();
    this.pdfExport.emit(args);
    if (!args.isDefaultPrevented()) {
      this.saveAsPDF();
    }
  }
  syncHeaderHeight(observable) {
    return observable.pipe(filter(() => isPresent7(this.lockedHeader))).subscribe(() => syncRowsHeight(this.lockedHeader.nativeElement.children[0], this.header.nativeElement.children[0]));
  }
  columnsContainerChange() {
    this.columnsContainerChangeSubscription = this.syncHeaderHeight(this.columnsContainer.changes.pipe(filter(() => this.lockedColumns.length > 0), switchMap(() => this.ngZone.onStable.asObservable().pipe(take(1)))));
  }
  handleColumnResize() {
    const resizes = this.columnResizingService.changes;
    this.columnResizingSubscription = resizes.pipe(tap((e) => {
      if (e.type === "start") {
        this.renderer.addClass(this.wrapper.nativeElement, "k-grid-column-resizing");
      } else if (e.type === "end") {
        this.renderer.removeClass(this.wrapper.nativeElement, "k-grid-column-resizing");
      }
    }), filter((e) => e.type === "start"), switchMap(() => resizes.pipe(takeUntil(resizes.pipe(filter((e) => e.type === "triggerAutoFit"))), filter((e) => e.type === "end")))).subscribe(this.notifyResize.bind(this));
  }
  notifyResize(e) {
    const args = e.resizedColumns.filter((item) => isTruthy(item.column.resizable) && !item.column.isColumnGroup).map((item) => ({
      column: item.column,
      newWidth: roundDown(item.column.width),
      oldWidth: roundDown(item.oldWidth)
    }));
    this.columnResize.emit(args);
  }
  assertNavigable() {
    if (isDevMode() && !this.navigationService.enabled) {
      throw new Error(GridConfigurationErrorMessages.focusNavigable);
    }
  }
  _rowClass = () => null;
  navigationMetadata() {
    const isVirtual = this.isVirtual;
    const dataVirtualization = isVirtual && !this.pageable && !this.group?.length;
    const groupedVirtual = isVirtual && this.group?.length > 0;
    let dataRows;
    if (this.pageable) {
      dataRows = this.skip + Math.min(this.pageSize, this.view.length);
    } else {
      dataRows = this.view.total;
    }
    if (groupedVirtual) {
      dataRows = this.ctx.scroller?.total ?? 0;
      if (!dataVirtualization) {
        dataRows += this.skip;
      }
    }
    const addRowOffset = this.editService.hasNewItem ? 1 : 0;
    const filterRowOffset = hasFilterRow(this.filterable) ? 1 : 0;
    const headerRows = this.isStacked ? 0 : this.totalColumnLevels + 1 + filterRowOffset + addRowOffset;
    return new NavigationMetadata(dataRows, headerRows, isVirtual, this.hasPager, isPresent7(this.detailTemplate), this.wrapper, this.virtualColumns, this.columnsContainer, this.showFooter ? 1 : 0, this.isStacked);
  }
  applyAutoSize() {
    const cols = this.columns.filter((c) => this.autoSize ? c.autoSize !== false : c.autoSize);
    if (cols.length > 0) {
      this.ngZone.onStable.pipe(take(1)).subscribe(() => this.autoFitColumns(cols));
    }
  }
  onColumnRangeChange(range2) {
    const viewportColumns = this.viewportColumns = [];
    const columnsArray = this.columnsContainer.nonLockedLeafColumns.toArray();
    let leafViewportColumns = columnsArray.slice(range2.start, range2.end + 1);
    const stickyBeforeStart = columnsArray.slice(0, range2.start).filter((c) => c.sticky && !leafViewportColumns.some((col) => col === c));
    const stickyAfterEnd = columnsArray.slice(range2.end, columnsArray.length).filter((c) => c.sticky && !leafViewportColumns.some((col) => col === c));
    leafViewportColumns = [...stickyBeforeStart, ...leafViewportColumns, ...stickyAfterEnd];
    for (let idx4 = 0; idx4 < leafViewportColumns.length; idx4++) {
      let column = leafViewportColumns[idx4];
      while (column.parent) {
        column = column.parent;
      }
      const toAdd = [column];
      while (toAdd.length) {
        column = toAdd.shift();
        viewportColumns.push(column);
        if (column.isColumnGroup) {
          const children2 = columnsArray.filter((c) => c.parent && c.parent.id === column.id);
          toAdd.unshift(...children2);
        }
      }
      const lastFromGroup = viewportColumns[viewportColumns.length - 1];
      column = leafViewportColumns[idx4];
      while (column !== lastFromGroup && idx4 < leafViewportColumns.length) {
        idx4++;
        column = leafViewportColumns[idx4];
      }
    }
    if (range2.start > 0) {
      const first = leafViewportColumns[0];
      let offset3 = range2.offset;
      let current = viewportColumns[0];
      let index = 0;
      while (current !== first) {
        offset3 -= current.isColumnGroup ? 0 : current.width;
        index++;
        current = viewportColumns[index];
      }
      if (offset3 > 0) {
        const totalLevels = this.columnsContainer.totalLevels;
        let previous;
        for (let idx4 = 0; idx4 <= totalLevels; idx4++) {
          const offsetColumn = idx4 < totalLevels ? new ColumnGroupComponent2(previous) : new ColumnBase2(previous);
          previous = offsetColumn;
          offsetColumn.title = " ";
          offsetColumn.width = offset3;
          viewportColumns.unshift(offsetColumn);
        }
      }
    }
    this.leafViewportColumns = viewportColumns.filter((c) => !c.isColumnGroup);
  }
  toggleDetailRowLegacy(index, expand2) {
    const hasCallback = typeof this.isDetailExpanded === "function";
    if (isDevMode() && hasCallback) {
      throw new Error(GridConfigurationErrorMessages.expandCollapseMethods("expandRow", "collapseRow", "kendoGridDetailsExpandBy", "isDetailExpanded"));
    }
    if (!isDevMode() && hasCallback) {
      return;
    }
    if (this.detailsService.isExpanded(index, null) !== expand2) {
      this.detailsService.toggleRow(index, null);
    }
  }
  toggleGroupRowLegacy(index, expand2) {
    const hasCallback = typeof this.isGroupExpanded === "function";
    if (isDevMode() && hasCallback) {
      throw new Error(GridConfigurationErrorMessages.expandCollapseMethods("expandGroup", "collapseGroup", "kendoGridExpandGroupBy", "isGroupExpanded"));
    }
    if (!isDevMode() && hasCallback) {
      return;
    }
    if (this.groupsService.isExpanded({
      groupIndex: index
    }) !== expand2) {
      this.groupsService.toggleRow({
        index
      }, false);
    }
    this.changeDetectorRef.markForCheck();
  }
  shouldResetSelection(selectableChanges) {
    const previousValue = selectableChanges.previousValue;
    if (!previousValue) {
      return false;
    }
    const currentValue = selectableChanges.currentValue;
    if (!currentValue || currentValue.enabled === false) {
      return true;
    }
    return previousValue.cell !== currentValue.cell;
  }
  notifyReorderContainers() {
    this.dragTargetContainer?.notify();
    this.dropTargetContainer?.notify();
  }
  static ɵfac = function GridComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _GridComponent)(ɵɵdirectiveInject(BrowserSupportService), ɵɵdirectiveInject(SelectionService2), ɵɵdirectiveInject(CellSelectionService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(GroupInfoService), ɵɵdirectiveInject(GroupsService), ɵɵdirectiveInject(ChangeNotificationService), ɵɵdirectiveInject(DetailsService), ɵɵdirectiveInject(EditService), ɵɵdirectiveInject(FilterService), ɵɵdirectiveInject(PDFService), ɵɵdirectiveInject(ResponsiveService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ExcelService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ScrollSyncService2), ɵɵdirectiveInject(DomEventsService), ɵɵdirectiveInject(ColumnResizingService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ColumnReorderService), ɵɵdirectiveInject(ColumnInfoService), ɵɵdirectiveInject(NavigationService4), ɵɵdirectiveInject(SortService), ɵɵdirectiveInject(ScrollRequestService), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(SizingOptionsService), ɵɵdirectiveInject(AdaptiveGridService), ɵɵdirectiveInject(RowReorderService), ɵɵdirectiveInject(DataMappingService), ɵɵdirectiveInject(GridAIRequestResponseService), ɵɵdirectiveInject(IdService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _GridComponent,
    selectors: [["kendo-grid"]],
    contentQueries: function GridComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, ColumnBase2, 4)(dirIndex, DetailTemplateDirective, 4)(dirIndex, CellLoadingTemplateDirective, 4)(dirIndex, LoadingTemplateDirective, 4)(dirIndex, StatusBarTemplateDirective, 4)(dirIndex, NoRecordsTemplateDirective, 4)(dirIndex, PagerTemplateDirective, 4)(dirIndex, ToolbarTemplateDirective, 4)(dirIndex, ColumnMenuTemplateDirective, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columns = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.detailTemplateChildren = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.cellLoadingTemplateChildren = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.loadingTemplateChildren = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.statusBarTemplateChildren = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.noRecordsTemplateChildren = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.pagerTemplateChildren = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.toolbarTemplateChildren = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columnMenuTemplates = _t);
      }
    },
    viewQuery: function GridComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c69, 5)(_c70, 5)(_c71, 7)(DragTargetContainerDirective, 5)(DropTargetContainerDirective, 5)(_c722, 5, ViewContainerRef)(_c732, 5, ViewContainerRef)(AdaptiveRendererComponent, 5)(ListComponent2, 5)(_c742, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.lockedHeader = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.header = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.ariaRoot = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dragTargetContainer = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dropTargetContainer = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dialogContainer = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.windowContainer = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.adaptiveRenderer = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.listComponent = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.footer = _t);
      }
    },
    hostVars: 25,
    hostBindings: function GridComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.dir);
        ɵɵstyleProp("min-width", ctx.minWidth)("max-width", ctx.maxWidth)("min-height", ctx.minHeight)("max-height", ctx.maxHeight);
        ɵɵclassProp("k-grid", ctx.hostClass)("k-grid-sm", ctx.sizeSmallClass)("k-grid-md", ctx.sizeMediumClass)("k-grid-stack", ctx.stackedClass)("k-grid-lockedcolumns", ctx.lockedClasses)("k-grid-virtual", ctx.virtualClasses)("k-grid-no-scrollbar", ctx.noScrollbarClass)("k-grid-resizable", ctx.isResizable);
      }
    },
    inputs: {
      data: "data",
      pageSize: "pageSize",
      height: "height",
      rowHeight: "rowHeight",
      adaptiveMode: "adaptiveMode",
      detailRowHeight: "detailRowHeight",
      skip: "skip",
      scrollable: "scrollable",
      selectable: "selectable",
      sort: "sort",
      size: "size",
      trackBy: "trackBy",
      filter: "filter",
      group: "group",
      virtualColumns: "virtualColumns",
      filterable: "filterable",
      sortable: "sortable",
      pageable: "pageable",
      groupable: "groupable",
      gridResizable: "gridResizable",
      rowReorderable: "rowReorderable",
      navigable: "navigable",
      autoSize: "autoSize",
      rowClass: "rowClass",
      rowSticky: "rowSticky",
      rowSelected: "rowSelected",
      isRowSelectable: "isRowSelectable",
      cellSelected: "cellSelected",
      resizable: "resizable",
      reorderable: "reorderable",
      loading: "loading",
      columnMenu: "columnMenu",
      hideHeader: "hideHeader",
      showInactiveTools: "showInactiveTools",
      isDetailExpanded: "isDetailExpanded",
      isGroupExpanded: "isGroupExpanded",
      dataLayoutMode: "dataLayoutMode"
    },
    outputs: {
      filterChange: "filterChange",
      pageChange: "pageChange",
      groupChange: "groupChange",
      sortChange: "sortChange",
      selectionChange: "selectionChange",
      rowReorder: "rowReorder",
      dataStateChange: "dataStateChange",
      gridStateChange: "gridStateChange",
      groupExpand: "groupExpand",
      groupCollapse: "groupCollapse",
      detailExpand: "detailExpand",
      detailCollapse: "detailCollapse",
      edit: "edit",
      cancel: "cancel",
      save: "save",
      remove: "remove",
      add: "add",
      cellClose: "cellClose",
      cellClick: "cellClick",
      pdfExport: "pdfExport",
      excelExport: "excelExport",
      columnResize: "columnResize",
      columnReorder: "columnReorder",
      columnVisibilityChange: "columnVisibilityChange",
      columnLockedChange: "columnLockedChange",
      columnStickyChange: "columnStickyChange",
      scrollBottom: "scrollBottom",
      contentScroll: "contentScroll"
    },
    exportAs: ["kendoGrid"],
    features: [ɵɵProvidersFeature([BrowserSupportService, LocalizationService, ColumnInfoService, SelectionService2, CellSelectionService, DetailsService, GroupsService, GroupInfoService, ChangeNotificationService, EditService, PDFService, SuspendService, {
      provide: CELL_CONTEXT,
      useValue: EMPTY_CELL_CONTEXT
    }, {
      provide: L10N_PREFIX,
      useValue: "kendo.grid"
    }, FilterService, ResponsiveService, PagerContextService, PagerNavigationService, ExcelService, ScrollSyncService2, ResizeService, LocalDataChangesService, DomEventsService, ColumnResizingService, SinglePopupService, DragAndDropService, DragHintService, DropCueService, ColumnReorderService, NavigationService4, FocusRoot, IdService, CellSelectionAggregateService, ScrollRequestService, SortService, ContextService, SizingOptionsService, RowReorderService, ClipboardService, GridAIRequestResponseService, RowspanService, AdaptiveGridService, ColumnMenuService, MenuTabbingService, DataMappingService]), ɵɵNgOnChangesFeature],
    ngContentSelectors: _c76,
    decls: 25,
    vars: 37,
    consts: () => {
      let i18n_0;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_0 = goog.getMsg("Drag a column header and drop it here to group by that column");
        i18n_0 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_0;
      } else {
        i18n_0 = $localize`:kendo.grid.groupPanelEmpty|The label visible in the Grid group panel when it is empty:Drag a column header and drop it here to group by that column`;
      }
      let i18n_1;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_1 = goog.getMsg("No records available.");
        i18n_1 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_1;
      } else {
        i18n_1 = $localize`:kendo.grid.noRecords|The label visible in the Grid when there are no records:No records available.`;
      }
      let i18n_2;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_2 = goog.getMsg("Go to the first page");
        i18n_2 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_2;
      } else {
        i18n_2 = $localize`:kendo.grid.pagerFirstPage|The label for the first page button in Grid pager:Go to the first page`;
      }
      let i18n_3;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_3 = goog.getMsg("Go to the previous page");
        i18n_3 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_3;
      } else {
        i18n_3 = $localize`:kendo.grid.pagerPreviousPage|The label for the previous page button in Grid pager:Go to the previous page`;
      }
      let i18n_4;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_4 = goog.getMsg("Go to the next page");
        i18n_4 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_4;
      } else {
        i18n_4 = $localize`:kendo.grid.pagerNextPage|The label for the next page button in Grid pager:Go to the next page`;
      }
      let i18n_5;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_5 = goog.getMsg("Go to the last page");
        i18n_5 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_5;
      } else {
        i18n_5 = $localize`:kendo.grid.pagerLastPage|The label for the last page button in Grid pager:Go to the last page`;
      }
      let i18n_6;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_6 = goog.getMsg("Page");
        i18n_6 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_6;
      } else {
        i18n_6 = $localize`:kendo.grid.pagerPage|The label before the current page number in the Grid pager:Page`;
      }
      let i18n_7;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_7 = goog.getMsg("of");
        i18n_7 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_7;
      } else {
        i18n_7 = $localize`:kendo.grid.pagerOf|The label before the total pages number in the Grid pager:of`;
      }
      let i18n_8;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_8 = goog.getMsg("items");
        i18n_8 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_8;
      } else {
        i18n_8 = $localize`:kendo.grid.pagerItems|The label after the total pages number in the Grid pager:items`;
      }
      let i18n_9;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_9 = goog.getMsg("Page Number");
        i18n_9 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_9;
      } else {
        i18n_9 = $localize`:kendo.grid.pagerPageNumberInputTitle|The label for the pager input in the Grid pager:Page Number`;
      }
      let i18n_10;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_10 = goog.getMsg("items per page");
        i18n_10 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_10;
      } else {
        i18n_10 = $localize`:kendo.grid.pagerItemsPerPage|The label for the page size chooser in the Grid pager:items per page`;
      }
      let i18n_11;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_11 = goog.getMsg("Type a page number");
        i18n_11 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_11;
      } else {
        i18n_11 = $localize`:kendo.grid.pagerInputLabel|The text of the aria-label attribute applied to the input element for entering the page number:Type a page number`;
      }
      let i18n_12;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_12 = goog.getMsg("Filter");
        i18n_12 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_12;
      } else {
        i18n_12 = $localize`:kendo.grid.filter|The label of the filter cell or icon:Filter`;
      }
      let i18n_13;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_13 = goog.getMsg("Is equal to");
        i18n_13 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_13;
      } else {
        i18n_13 = $localize`:kendo.grid.filterEqOperator|The text of the equal filter operator:Is equal to`;
      }
      let i18n_14;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_14 = goog.getMsg("Is not equal to");
        i18n_14 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_14;
      } else {
        i18n_14 = $localize`:kendo.grid.filterNotEqOperator|The text of the not equal filter operator:Is not equal to`;
      }
      let i18n_15;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_15 = goog.getMsg("Is null");
        i18n_15 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_15;
      } else {
        i18n_15 = $localize`:kendo.grid.filterIsNullOperator|The text of the is null filter operator:Is null`;
      }
      let i18n_16;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_16 = goog.getMsg("Is not null");
        i18n_16 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_16;
      } else {
        i18n_16 = $localize`:kendo.grid.filterIsNotNullOperator|The text of the is not null filter operator:Is not null`;
      }
      let i18n_17;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_17 = goog.getMsg("Is empty");
        i18n_17 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_17;
      } else {
        i18n_17 = $localize`:kendo.grid.filterIsEmptyOperator|The text of the is empty filter operator:Is empty`;
      }
      let i18n_18;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_18 = goog.getMsg("Is not empty");
        i18n_18 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_18;
      } else {
        i18n_18 = $localize`:kendo.grid.filterIsNotEmptyOperator|The text of the is not empty filter operator:Is not empty`;
      }
      let i18n_19;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_19 = goog.getMsg("Starts with");
        i18n_19 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_19;
      } else {
        i18n_19 = $localize`:kendo.grid.filterStartsWithOperator|The text of the starts with filter operator:Starts with`;
      }
      let i18n_20;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_20 = goog.getMsg("Contains");
        i18n_20 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_20;
      } else {
        i18n_20 = $localize`:kendo.grid.filterContainsOperator|The text of the contains filter operator:Contains`;
      }
      let i18n_21;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_21 = goog.getMsg("Does not contain");
        i18n_21 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_21;
      } else {
        i18n_21 = $localize`:kendo.grid.filterNotContainsOperator|The text of the does not contain filter operator:Does not contain`;
      }
      let i18n_22;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_22 = goog.getMsg("Ends with");
        i18n_22 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_22;
      } else {
        i18n_22 = $localize`:kendo.grid.filterEndsWithOperator|The text of the ends with filter operator:Ends with`;
      }
      let i18n_23;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_23 = goog.getMsg("Is greater than or equal to");
        i18n_23 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_23;
      } else {
        i18n_23 = $localize`:kendo.grid.filterGteOperator|The text of the greater than or equal filter operator:Is greater than or equal to`;
      }
      let i18n_24;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_24 = goog.getMsg("Is greater than");
        i18n_24 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_24;
      } else {
        i18n_24 = $localize`:kendo.grid.filterGtOperator|The text of the greater than filter operator:Is greater than`;
      }
      let i18n_25;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_25 = goog.getMsg("Is less than or equal to");
        i18n_25 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_25;
      } else {
        i18n_25 = $localize`:kendo.grid.filterLteOperator|The text of the less than or equal filter operator:Is less than or equal to`;
      }
      let i18n_26;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_26 = goog.getMsg("Is less than");
        i18n_26 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_26;
      } else {
        i18n_26 = $localize`:kendo.grid.filterLtOperator|The text of the less than filter operator:Is less than`;
      }
      let i18n_27;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_27 = goog.getMsg("Is True");
        i18n_27 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_27;
      } else {
        i18n_27 = $localize`:kendo.grid.filterIsTrue|The text of the IsTrue boolean filter option:Is True`;
      }
      let i18n_28;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_28 = goog.getMsg("Is False");
        i18n_28 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_28;
      } else {
        i18n_28 = $localize`:kendo.grid.filterIsFalse|The text of the IsFalse boolean filter option:Is False`;
      }
      let i18n_29;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_29 = goog.getMsg("(All)");
        i18n_29 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_29;
      } else {
        i18n_29 = $localize`:kendo.grid.filterBooleanAll|The text of the (All) boolean filter option:(All)`;
      }
      let i18n_30;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_30 = goog.getMsg("Is after or equal to");
        i18n_30 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_30;
      } else {
        i18n_30 = $localize`:kendo.grid.filterAfterOrEqualOperator|The text of the after or equal date filter operator:Is after or equal to`;
      }
      let i18n_31;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_31 = goog.getMsg("Is after");
        i18n_31 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_31;
      } else {
        i18n_31 = $localize`:kendo.grid.filterAfterOperator|The text of the after date filter operator:Is after`;
      }
      let i18n_32;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_32 = goog.getMsg("Is before");
        i18n_32 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_32;
      } else {
        i18n_32 = $localize`:kendo.grid.filterBeforeOperator|The text of the before date filter operator:Is before`;
      }
      let i18n_33;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_33 = goog.getMsg("Is before or equal to");
        i18n_33 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_33;
      } else {
        i18n_33 = $localize`:kendo.grid.filterBeforeOrEqualOperator|The text of the before or equal date filter operator:Is before or equal to`;
      }
      let i18n_34;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_34 = goog.getMsg("Filter");
        i18n_34 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_34;
      } else {
        i18n_34 = $localize`:kendo.grid.filterFilterButton|The text of the filter button:Filter`;
      }
      let i18n_35;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_35 = goog.getMsg("Clear");
        i18n_35 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_35;
      } else {
        i18n_35 = $localize`:kendo.grid.filterClearButton|The text of the clear filter button:Clear`;
      }
      let i18n_36;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_36 = goog.getMsg("Clear sorting");
        i18n_36 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_36;
      } else {
        i18n_36 = $localize`:kendo.grid.sortClearButton|The text of the clear sort button located in the Sort Toolbar Tool and adaptive Sort Toolbar Tool:Clear sorting`;
      }
      let i18n_37;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_37 = goog.getMsg("Close");
        i18n_37 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_37;
      } else {
        i18n_37 = $localize`:kendo.grid.adaptiveCloseButtonTitle|The title of the Close button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode:Close`;
      }
      let i18n_38;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_38 = goog.getMsg("Back");
        i18n_38 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_38;
      } else {
        i18n_38 = $localize`:kendo.grid.adaptiveBackButtonTitle|The title of the Back button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode:Back`;
      }
      let i18n_39;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_39 = goog.getMsg("Clear all filters");
        i18n_39 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_39;
      } else {
        i18n_39 = $localize`:kendo.grid.filterClearAllButton|The text of the clear all filters button located in the Filter Toolbar Tool and adaptive Filter Toolbar Tool:Clear all filters`;
      }
      let i18n_40;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_40 = goog.getMsg("Clear grouping");
        i18n_40 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_40;
      } else {
        i18n_40 = $localize`:kendo.grid.groupClearButton|The text of the clear grouping button in the Group Toolbar Tool and adaptive Group Toolbar Tool:Clear grouping`;
      }
      let i18n_41;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_41 = goog.getMsg("Done");
        i18n_41 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_41;
      } else {
        i18n_41 = $localize`:kendo.grid.sortDoneButton|The text of the done sort button:Done`;
      }
      let i18n_42;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_42 = goog.getMsg("Done");
        i18n_42 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_42;
      } else {
        i18n_42 = $localize`:kendo.grid.groupDoneButton|The text of the done group button in the adaptive Group Toolbar Tool:Done`;
      }
      let i18n_43;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_43 = goog.getMsg("And");
        i18n_43 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_43;
      } else {
        i18n_43 = $localize`:kendo.grid.filterAndLogic|The text of the And filter logic:And`;
      }
      let i18n_44;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_44 = goog.getMsg("Or");
        i18n_44 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_44;
      } else {
        i18n_44 = $localize`:kendo.grid.filterOrLogic|The text of the Or filter logic:Or`;
      }
      let i18n_45;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_45 = goog.getMsg("Filter");
        i18n_45 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_45;
      } else {
        i18n_45 = $localize`:kendo.grid.filterToolbarToolText|The button text of the Filter toolbar tool:Filter`;
      }
      let i18n_46;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_46 = goog.getMsg("Loading");
        i18n_46 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_46;
      } else {
        i18n_46 = $localize`:kendo.grid.loading|The loading text:Loading`;
      }
      let i18n_47;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_47 = goog.getMsg("Data table");
        i18n_47 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_47;
      } else {
        i18n_47 = $localize`:kendo.grid.gridLabel|The Grid aria-label:Data table`;
      }
      let i18n_48;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_48 = goog.getMsg("Columns");
        i18n_48 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_48;
      } else {
        i18n_48 = $localize`:kendo.grid.columns|The text for the Grid Column Chooser and Column Chooser toolbar tool:Columns`;
      }
      let i18n_49;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_49 = goog.getMsg("Selected fields are visible");
        i18n_49 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_49;
      } else {
        i18n_49 = $localize`:kendo.grid.columnsSubtitle|The subtitle for the adaptive Grid Column Chooser and Column Chooser toolbar tool:Selected fields are visible`;
      }
      let i18n_50;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_50 = goog.getMsg("Filter by");
        i18n_50 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_50;
      } else {
        i18n_50 = $localize`:kendo.grid.adaptiveFilterTitle|The title that is displayed in the adaptive Filter Toolbar Tool and Filter Menu:Filter by`;
      }
      let i18n_51;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_51 = goog.getMsg("Operators");
        i18n_51 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_51;
      } else {
        i18n_51 = $localize`:kendo.grid.adaptiveFilterOperatorsTitle|The title that is displayed in the Operators Action Sheet:Operators`;
      }
      let i18n_52;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_52 = goog.getMsg("Sort by");
        i18n_52 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_52;
      } else {
        i18n_52 = $localize`:kendo.grid.adaptiveSortTitle|The title that is displayed in the adaptive Sort Toolbar Tool:Sort by`;
      }
      let i18n_53;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_53 = goog.getMsg("Group by");
        i18n_53 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_53;
      } else {
        i18n_53 = $localize`:kendo.grid.adaptiveGroupTitle|The title that is displayed in the adaptive Group Toolbar Tool.:Group by`;
      }
      let i18n_54;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_54 = goog.getMsg("Lock");
        i18n_54 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_54;
      } else {
        i18n_54 = $localize`:kendo.grid.lock|The text shown in the column menu for the lock item:Lock`;
      }
      let i18n_55;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_55 = goog.getMsg("Unlock");
        i18n_55 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_55;
      } else {
        i18n_55 = $localize`:kendo.grid.unlock|The text shown in the column menu for the unlock item:Unlock`;
      }
      let i18n_56;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_56 = goog.getMsg("Set Column Position");
        i18n_56 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_56;
      } else {
        i18n_56 = $localize`:kendo.grid.setColumnPosition|The text shown in the column menu for the set column position item:Set Column Position`;
      }
      let i18n_57;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_57 = goog.getMsg("Stick");
        i18n_57 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_57;
      } else {
        i18n_57 = $localize`:kendo.grid.stick|The text shown in the column menu for the stick item:Stick`;
      }
      let i18n_58;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_58 = goog.getMsg("Unstick");
        i18n_58 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_58;
      } else {
        i18n_58 = $localize`:kendo.grid.unstick|The text shown in the column menu for the unstick item:Unstick`;
      }
      let i18n_59;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_59 = goog.getMsg("Sortable");
        i18n_59 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_59;
      } else {
        i18n_59 = $localize`:kendo.grid.sortable|The label of the sort icon:Sortable`;
      }
      let i18n_60;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_60 = goog.getMsg("Sort Ascending");
        i18n_60 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_60;
      } else {
        i18n_60 = $localize`:kendo.grid.sortAscending|The text shown in the column menu for the sort ascending item:Sort Ascending`;
      }
      let i18n_61;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_61 = goog.getMsg("Sort Descending");
        i18n_61 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_61;
      } else {
        i18n_61 = $localize`:kendo.grid.sortDescending|The text shown in the column menu for the sort descending item:Sort Descending`;
      }
      let i18n_62;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_62 = goog.getMsg("Autosize All Columns");
        i18n_62 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_62;
      } else {
        i18n_62 = $localize`:kendo.grid.autosizeAllColumns|The text shown in the column menu for the autosize all columns item:Autosize All Columns`;
      }
      let i18n_63;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_63 = goog.getMsg("Autosize This Column");
        i18n_63 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_63;
      } else {
        i18n_63 = $localize`:kendo.grid.autosizeThisColumn|The text shown in the column menu for the autosize this column item:Autosize This Column`;
      }
      let i18n_64;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_64 = goog.getMsg("Not Sorted");
        i18n_64 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_64;
      } else {
        i18n_64 = $localize`:kendo.grid.sortedDefault|The status announcement when a column is no longer sorted:Not Sorted`;
      }
      let i18n_65;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_65 = goog.getMsg("Sorted Ascending");
        i18n_65 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_65;
      } else {
        i18n_65 = $localize`:kendo.grid.sortedAscending|The title of the Group Chip indicating the ascending sorting order of the groups:Sorted Ascending`;
      }
      let i18n_66;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_66 = goog.getMsg("Sorted Descending");
        i18n_66 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_66;
      } else {
        i18n_66 = $localize`:kendo.grid.sortedDescending|The title of the Group Chip indicating the descending sorting order of the groups:Sorted Descending`;
      }
      let i18n_67;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_67 = goog.getMsg("Apply");
        i18n_67 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_67;
      } else {
        i18n_67 = $localize`:kendo.grid.columnsApply|The text shown in the column menu or column chooser for the columns apply button:Apply`;
      }
      let i18n_68;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_68 = goog.getMsg("Reset");
        i18n_68 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_68;
      } else {
        i18n_68 = $localize`:kendo.grid.columnsReset|The text shown in the column menu or column chooser for the columns reset button:Reset`;
      }
      let i18n_69;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_69 = goog.getMsg("Expand Details");
        i18n_69 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_69;
      } else {
        i18n_69 = $localize`:kendo.grid.detailExpand|The title of the expand icon of detail rows. Applies also to the expand button text in stacked mode.:Expand Details`;
      }
      let i18n_70;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_70 = goog.getMsg("Collapse Details");
        i18n_70 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_70;
      } else {
        i18n_70 = $localize`:kendo.grid.detailCollapse|The title of the collapse icon of detail rows. Applies also to the collapse button text in stacked mode.:Collapse Details`;
      }
      let i18n_71;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_71 = goog.getMsg("TODAY");
        i18n_71 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_71;
      } else {
        i18n_71 = $localize`:kendo.grid.filterDateToday|The text of the Today button of the Date filter.:TODAY`;
      }
      let i18n_72;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_72 = goog.getMsg("Toggle Calendar");
        i18n_72 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_72;
      } else {
        i18n_72 = $localize`:kendo.grid.filterDateToggle|The title of the Toggle button of the Date filter.:Toggle Calendar`;
      }
      let i18n_73;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_73 = goog.getMsg("Decrement");
        i18n_73 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_73;
      } else {
        i18n_73 = $localize`:kendo.grid.filterNumericDecrement|The title of the Decrement button of the Numeric filter.:Decrement`;
      }
      let i18n_74;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_74 = goog.getMsg("Increment");
        i18n_74 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_74;
      } else {
        i18n_74 = $localize`:kendo.grid.filterNumericIncrement|The title of the Increment button of the Numeric filter.:Increment`;
      }
      let i18n_75;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_75 = goog.getMsg("Select Row");
        i18n_75 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_75;
      } else {
        i18n_75 = $localize`:kendo.grid.selectionCheckboxLabel|The labels of the checkbox column checkboxes.:Select Row`;
      }
      let i18n_76;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_76 = goog.getMsg("Select All Rows");
        i18n_76 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_76;
      } else {
        i18n_76 = $localize`:kendo.grid.selectAllCheckboxLabel|The label of the checkbox column select all checkbox.:Select All Rows`;
      }
      let i18n_77;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_77 = goog.getMsg("Sort");
        i18n_77 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_77;
      } else {
        i18n_77 = $localize`:kendo.grid.sortToolbarToolText|The button text of the Sort toolbar tool.:Sort`;
      }
      let i18n_78;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_78 = goog.getMsg("Collapse Group");
        i18n_78 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_78;
      } else {
        i18n_78 = $localize`:kendo.grid.groupCollapse|The text of the title and aria-label attributes applied to the collapse icon of group rows.:Collapse Group`;
      }
      let i18n_79;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_79 = goog.getMsg("Expand Group");
        i18n_79 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_79;
      } else {
        i18n_79 = $localize`:kendo.grid.groupExpand|The text of the title and aria-label attributes applied to the expand icon of group rows.:Expand Group`;
      }
      let i18n_80;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_80 = goog.getMsg("Select page");
        i18n_80 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_80;
      } else {
        i18n_80 = $localize`:kendo.grid.pagerSelectPage|The text of the title and aria-label attributes applied to the page chooser in the Grid Pager:Select page`;
      }
      let i18n_81;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_81 = goog.getMsg("Top toolbar");
        i18n_81 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_81;
      } else {
        i18n_81 = $localize`:kendo.grid.topToolbarLabel|The label for the Grid top toolbar:Top toolbar`;
      }
      let i18n_82;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_82 = goog.getMsg("Bottom toolbar");
        i18n_82 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_82;
      } else {
        i18n_82 = $localize`:kendo.grid.bottomToolbarLabel|The label for the Grid bottom toolbar:Bottom toolbar`;
      }
      let i18n_83;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_83 = goog.getMsg("Edit");
        i18n_83 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_83;
      } else {
        i18n_83 = $localize`:kendo.grid.editToolbarToolText|The text for the Grid Edit toolbar tool:Edit`;
      }
      let i18n_84;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_84 = goog.getMsg("Save");
        i18n_84 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_84;
      } else {
        i18n_84 = $localize`:kendo.grid.saveToolbarToolText|The text for the Grid Save toolbar tool:Save`;
      }
      let i18n_85;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_85 = goog.getMsg("Add");
        i18n_85 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_85;
      } else {
        i18n_85 = $localize`:kendo.grid.addToolbarToolText|The text for the Grid Add toolbar tool:Add`;
      }
      let i18n_86;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_86 = goog.getMsg("Cancel");
        i18n_86 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_86;
      } else {
        i18n_86 = $localize`:kendo.grid.cancelToolbarToolText|The text for the Grid Cancel toolbar tool:Cancel`;
      }
      let i18n_87;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_87 = goog.getMsg("Delete");
        i18n_87 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_87;
      } else {
        i18n_87 = $localize`:kendo.grid.removeToolbarToolText|The text for the Grid Remove toolbar tool:Delete`;
      }
      let i18n_88;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_88 = goog.getMsg("Excel Export");
        i18n_88 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_88;
      } else {
        i18n_88 = $localize`:kendo.grid.excelExportToolbarToolText|The text for the Grid Excel export toolbar tool:Excel Export`;
      }
      let i18n_89;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_89 = goog.getMsg("PDF Export");
        i18n_89 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_89;
      } else {
        i18n_89 = $localize`:kendo.grid.pdfExportToolbarToolText|The text for the Grid PDF export toolbar tool:PDF Export`;
      }
      let i18n_90;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_90 = goog.getMsg("Group panel");
        i18n_90 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_90;
      } else {
        i18n_90 = $localize`:kendo.grid.groupPanelLabel|The label for the Grid group panel toolbar:Group panel`;
      }
      let i18n_91;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_91 = goog.getMsg("Drag row");
        i18n_91 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_91;
      } else {
        i18n_91 = $localize`:kendo.grid.dragRowHandleLabel|The label for the Grid drag row handle:Drag row`;
      }
      let i18n_92;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_92 = goog.getMsg("Filter");
        i18n_92 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_92;
      } else {
        i18n_92 = $localize`:kendo.grid.columnMenuFilterTabTitle|The title for the column menu Filter tab:Filter`;
      }
      let i18n_93;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_93 = goog.getMsg("General");
        i18n_93 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_93;
      } else {
        i18n_93 = $localize`:kendo.grid.columnMenuGeneralTabTitle|The title for the column menu General tab:General`;
      }
      let i18n_94;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_94 = goog.getMsg("Columns");
        i18n_94 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_94;
      } else {
        i18n_94 = $localize`:kendo.grid.columnMenuColumnsTabTitle|The title for the column menu Columns tab:Columns`;
      }
      let i18n_95;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_95 = goog.getMsg("Move as previous");
        i18n_95 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_95;
      } else {
        i18n_95 = $localize`:kendo.grid.groupChipMenuPrevious|The text for the Group pane Chip Menu Move as previous item:Move as previous`;
      }
      let i18n_96;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_96 = goog.getMsg("Move as next");
        i18n_96 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_96;
      } else {
        i18n_96 = $localize`:kendo.grid.groupChipMenuNext|The text for the Group pane Chip Menu Move as next item:Move as next`;
      }
      let i18n_97;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_97 = goog.getMsg("Group");
        i18n_97 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_97;
      } else {
        i18n_97 = $localize`:kendo.grid.groupToolbarToolText|The button text of the Group toolbar tool:Group`;
      }
      let i18n_98;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_98 = goog.getMsg("Please confirm");
        i18n_98 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_98;
      } else {
        i18n_98 = $localize`:kendo.grid.removeConfirmationDialogTitle|The title of the built-in remove item confirmation Dialog:Please confirm`;
      }
      let i18n_99;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_99 = goog.getMsg("Are you sure you want to delete this item?");
        i18n_99 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_99;
      } else {
        i18n_99 = $localize`:kendo.grid.removeConfirmationDialogContent|The content of the built-in remove item confirmation Dialog:Are you sure you want to delete this item?`;
      }
      let i18n_100;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_100 = goog.getMsg("Yes");
        i18n_100 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_100;
      } else {
        i18n_100 = $localize`:kendo.grid.removeConfirmationDialogConfirmText|The text of the built-in remove item confirmation Dialog confirm action button:Yes`;
      }
      let i18n_101;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_101 = goog.getMsg("No");
        i18n_101 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_101;
      } else {
        i18n_101 = $localize`:kendo.grid.removeConfirmationDialogRejectText|The text of the built-in remove item confirmation Dialog reject action button:No`;
      }
      let i18n_102;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_102 = goog.getMsg("Edit");
        i18n_102 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_102;
      } else {
        i18n_102 = $localize`:kendo.grid.externalEditingTitle|The title of the built-in external editing form container when editing an item:Edit`;
      }
      let i18n_103;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_103 = goog.getMsg("Add");
        i18n_103 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_103;
      } else {
        i18n_103 = $localize`:kendo.grid.externalEditingAddTitle|The title of the built-in external editing form container when adding a new item:Add`;
      }
      let i18n_104;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_104 = goog.getMsg("Save");
        i18n_104 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_104;
      } else {
        i18n_104 = $localize`:kendo.grid.externalEditingSaveText|The text of the external editing form Save button:Save`;
      }
      let i18n_105;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_105 = goog.getMsg("Cancel");
        i18n_105 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_105;
      } else {
        i18n_105 = $localize`:kendo.grid.externalEditingCancelText|The text of the external editing form Cancel button:Cancel`;
      }
      let i18n_106;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_106 = goog.getMsg("AI Assistant");
        i18n_106 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_106;
      } else {
        i18n_106 = $localize`:kendo.grid.aiAssistantToolbarToolText|The text of the AI Assistant toolbar tool:AI Assistant`;
      }
      let i18n_107;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_107 = goog.getMsg("AI Assistant");
        i18n_107 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_107;
      } else {
        i18n_107 = $localize`:kendo.grid.aiAssistantWindowTitle|The text of the AI Assistant Window title:AI Assistant`;
      }
      let i18n_108;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_108 = goog.getMsg("Apply");
        i18n_108 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_108;
      } else {
        i18n_108 = $localize`:kendo.grid.aiAssistantApplyButtonText|The text of the AI Assistant Apply button:Apply`;
      }
      let i18n_109;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_109 = goog.getMsg("Close");
        i18n_109 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_109;
      } else {
        i18n_109 = $localize`:kendo.grid.aiAssistantWindowCloseTitle|The title of the AI Assistant Window close button:Close`;
      }
      let i18n_110;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_110 = goog.getMsg("Maximize");
        i18n_110 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_110;
      } else {
        i18n_110 = $localize`:kendo.grid.aiAssistantWindowMaximizeTitle|The title of the AI Assistant Window maximize button:Maximize`;
      }
      let i18n_111;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_111 = goog.getMsg("Minimize");
        i18n_111 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_111;
      } else {
        i18n_111 = $localize`:kendo.grid.aiAssistantWindowMinimizeTitle|The title of the AI Assistant Window minimize button:Minimize`;
      }
      let i18n_112;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_112 = goog.getMsg("Restore");
        i18n_112 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_112;
      } else {
        i18n_112 = $localize`:kendo.grid.aiAssistantWindowRestoreTitle|The title of the AI Assistant Window restore button:Restore`;
      }
      let i18n_113;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_113 = goog.getMsg("Generated with AI");
        i18n_113 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_113;
      } else {
        i18n_113 = $localize`:kendo.grid.aiAssistantOutputCardTitle|The title of the AI Assistant Prompt Output Card:Generated with AI`;
      }
      let i18n_114;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_114 = goog.getMsg("Operation is successful. Data is:");
        i18n_114 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_114;
      } else {
        i18n_114 = $localize`:kendo.grid.aiAssistantOutputCardBodyContent|The success message dispayed in the AI Assistant Prompt Output Card's body:Operation is successful. Data is:`;
      }
      let i18n_115;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_115 = goog.getMsg("Selection can be applied only when the Grid selectable option is enabled.");
        i18n_115 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_115;
      } else {
        i18n_115 = $localize`:kendo.grid.aiAssistantSelectionNotEnabled|The message shown when AI selection requires the Grid selectable option:Selection can be applied only when the Grid selectable option is enabled.`;
      }
      let i18n_116;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_116 = goog.getMsg("Selection can be applied only when row selection mode is enabled.");
        i18n_116 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_116;
      } else {
        i18n_116 = $localize`:kendo.grid.aiAssistantSelectionRowModeRequired|The message shown when AI selection requires row selection mode:Selection can be applied only when row selection mode is enabled.`;
      }
      let i18n_117;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_117 = goog.getMsg("Selection can be applied only when cell selection mode is enabled.");
        i18n_117 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_117;
      } else {
        i18n_117 = $localize`:kendo.grid.aiAssistantSelectionCellModeRequired|The message shown when AI selection requires cell selection mode:Selection can be applied only when cell selection mode is enabled.`;
      }
      let i18n_118;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_118 = goog.getMsg("Select all");
        i18n_118 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_118;
      } else {
        i18n_118 = $localize`:kendo.grid.columnChooserSelectAll|The text for the Select all checkbox in the Column Chooser:Select all`;
      }
      let i18n_119;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_119 = goog.getMsg("Search...");
        i18n_119 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_119;
      } else {
        i18n_119 = $localize`:kendo.grid.multiCheckboxFilterSearchPlaceholder|The placeholder text for the multi-checkbox filter search input:Search...`;
      }
      let i18n_120;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_120 = goog.getMsg("Select all");
        i18n_120 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_120;
      } else {
        i18n_120 = $localize`:kendo.grid.multiCheckboxFilterSelectAllLabel|The label for the multi-checkbox filter select all option:Select all`;
      }
      let i18n_121;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_121 = goog.getMsg("{$interpolation}", {
          "interpolation": "�0�"
        }, {
          original_code: {
            "interpolation": "{{ 'Page navigation, page {currentPage} of {totalPages}' }}"
          }
        });
        i18n_121 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_121;
      } else {
        i18n_121 = $localize`:kendo.grid.pagerLabel|The label for the Grid pager:${"�0�"}:INTERPOLATION:`;
      }
      let i18n_122;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_122 = goog.getMsg("{$interpolation}", {
          "interpolation": "�0�"
        }, {
          original_code: {
            "interpolation": "{{ '{columnName} Filter' }}"
          }
        });
        i18n_122 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_122;
      } else {
        i18n_122 = $localize`:kendo.grid.filterInputLabel|The label of the filter row and menu inputs:${"�0�"}:INTERPOLATION:`;
      }
      let i18n_123;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_123 = goog.getMsg("{$interpolation}", {
          "interpolation": "�0�"
        }, {
          original_code: {
            "interpolation": "{{ '{columnName} Filter Menu' }}"
          }
        });
        i18n_123 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_123;
      } else {
        i18n_123 = $localize`:kendo.grid.filterMenuTitle|The title of the filter menu icon:${"�0�"}:INTERPOLATION:`;
      }
      let i18n_124;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_124 = goog.getMsg("{$interpolation}", {
          "interpolation": "�0�"
        }, {
          original_code: {
            "interpolation": "{{ '{columnName} Filter Operators' }}"
          }
        });
        i18n_124 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_124;
      } else {
        i18n_124 = $localize`:kendo.grid.filterMenuOperatorsDropDownLabel|The label of the filter menu operators dropdown:${"�0�"}:INTERPOLATION:`;
      }
      let i18n_125;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_125 = goog.getMsg("{$interpolation}", {
          "interpolation": "�0�"
        }, {
          original_code: {
            "interpolation": "{{ 'Filter cell operators for {columnName}' }}"
          }
        });
        i18n_125 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_125;
      } else {
        i18n_125 = $localize`:kendo.grid.filterCellOperatorLabel|The label of the filter cell operators dropdown:${"�0�"}:INTERPOLATION:`;
      }
      let i18n_126;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_126 = goog.getMsg("{$interpolation}", {
          "interpolation": "�0�"
        }, {
          original_code: {
            "interpolation": "{{ 'Boolean filter cell for {columnName}' }}"
          }
        });
        i18n_126 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_126;
      } else {
        i18n_126 = $localize`:kendo.grid.booleanFilterCellLabel|The label of the boolean filter cell dropdown:${"�0�"}:INTERPOLATION:`;
      }
      let i18n_127;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_127 = goog.getMsg("{$interpolation}", {
          "interpolation": "�0�"
        }, {
          original_code: {
            "interpolation": "{{ '{columnName} Filter Logic' }}"
          }
        });
        i18n_127 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_127;
      } else {
        i18n_127 = $localize`:kendo.grid.filterMenuLogicDropDownLabel|The label of the filter menu logic dropdown:${"�0�"}:INTERPOLATION:`;
      }
      let i18n_128;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_128 = goog.getMsg("{$interpolation}", {
          "interpolation": "�0�"
        }, {
          original_code: {
            "interpolation": "{{ '{columnName} Column Menu' }}"
          }
        });
        i18n_128 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_128;
      } else {
        i18n_128 = $localize`:kendo.grid.columnMenu|The title of the column menu icon:${"�0�"}:INTERPOLATION:`;
      }
      let i18n_129;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_129 = goog.getMsg("{$interpolation}", {
          "interpolation": "�0�"
        }, {
          original_code: {
            "interpolation": "{{ 'The {fieldName} field has {errorName} validation error' }}"
          }
        });
        i18n_129 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_129;
      } else {
        i18n_129 = $localize`:kendo.grid.formValidationErrorText|The default text of a form validation error when using external editing.:${"�0�"}:INTERPOLATION:`;
      }
      let i18n_130;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_130 = goog.getMsg("{$interpolation}", {
          "interpolation": "�0�"
        }, {
          original_code: {
            "interpolation": "{{ '{selectedColumnsCount} Selected items' }}"
          }
        });
        i18n_130 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_130;
      } else {
        i18n_130 = $localize`:kendo.grid.columnChooserSelectedColumnsCount|The text displayed in the Column Chooser for the number of selected columns:${"�0�"}:INTERPOLATION:`;
      }
      let i18n_131;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_131 = goog.getMsg("{$interpolation}", {
          "interpolation": "�0�"
        }, {
          original_code: {
            "interpolation": "{{ '{selectedItemsCount} selected items' }}"
          }
        });
        i18n_131 = MSG_C__USERS_USER1_DESKTOP_VANSH_GIT_PROJECTS_USER_MANAGEMENT_V1_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_131;
      } else {
        i18n_131 = $localize`:kendo.grid.multiCheckboxFilterSelectedItemsCount|The text for the multi-checkbox filter selected items count:${"�0�"}:INTERPOLATION:`;
      }
      return [["ariaRoot", ""], ["defaultHint", ""], ["defaultPager", ""], ["dialogContainer", ""], ["windowContainer", ""], ["topPager", ""], ["header", ""], ["lockedHeader", ""], ["footer", ""], ["bottomPager", ""], ["pagerLabel", i18n_121, "filterInputLabel", i18n_122, "filterMenuTitle", i18n_123, "filterMenuOperatorsDropDownLabel", i18n_124, "filterCellOperatorLabel", i18n_125, "booleanFilterCellLabel", i18n_126, "filterMenuLogicDropDownLabel", i18n_127, "columnMenu", i18n_128, "formValidationErrorText", i18n_129, "columnChooserSelectedColumnsCount", i18n_130, "multiCheckboxFilterSelectedItemsCount", i18n_131], ["kendoGridLocalizedMessages", "", "groupPanelEmpty", i18n_0, "noRecords", i18n_1, "pagerFirstPage", i18n_2, "pagerPreviousPage", i18n_3, "pagerNextPage", i18n_4, "pagerLastPage", i18n_5, "pagerPage", i18n_6, "pagerOf", i18n_7, "pagerItems", i18n_8, "pagerPageNumberInputTitle", i18n_9, "pagerItemsPerPage", i18n_10, "pagerInputLabel", i18n_11, "filter", i18n_12, "filterEqOperator", i18n_13, "filterNotEqOperator", i18n_14, "filterIsNullOperator", i18n_15, "filterIsNotNullOperator", i18n_16, "filterIsEmptyOperator", i18n_17, "filterIsNotEmptyOperator", i18n_18, "filterStartsWithOperator", i18n_19, "filterContainsOperator", i18n_20, "filterNotContainsOperator", i18n_21, "filterEndsWithOperator", i18n_22, "filterGteOperator", i18n_23, "filterGtOperator", i18n_24, "filterLteOperator", i18n_25, "filterLtOperator", i18n_26, "filterIsTrue", i18n_27, "filterIsFalse", i18n_28, "filterBooleanAll", i18n_29, "filterAfterOrEqualOperator", i18n_30, "filterAfterOperator", i18n_31, "filterBeforeOperator", i18n_32, "filterBeforeOrEqualOperator", i18n_33, "filterFilterButton", i18n_34, "filterClearButton", i18n_35, "sortClearButton", i18n_36, "adaptiveCloseButtonTitle", i18n_37, "adaptiveBackButtonTitle", i18n_38, "filterClearAllButton", i18n_39, "groupClearButton", i18n_40, "sortDoneButton", i18n_41, "groupDoneButton", i18n_42, "filterAndLogic", i18n_43, "filterOrLogic", i18n_44, "filterToolbarToolText", i18n_45, "loading", i18n_46, "gridLabel", i18n_47, "columns", i18n_48, "columnsSubtitle", i18n_49, "adaptiveFilterTitle", i18n_50, "adaptiveFilterOperatorsTitle", i18n_51, "adaptiveSortTitle", i18n_52, "adaptiveGroupTitle", i18n_53, "lock", i18n_54, "unlock", i18n_55, "setColumnPosition", i18n_56, "stick", i18n_57, "unstick", i18n_58, "sortable", i18n_59, "sortAscending", i18n_60, "sortDescending", i18n_61, "autosizeAllColumns", i18n_62, "autosizeThisColumn", i18n_63, "sortedDefault", i18n_64, "sortedAscending", i18n_65, "sortedDescending", i18n_66, "columnsApply", i18n_67, "columnsReset", i18n_68, "detailExpand", i18n_69, "detailCollapse", i18n_70, "filterDateToday", i18n_71, "filterDateToggle", i18n_72, "filterNumericDecrement", i18n_73, "filterNumericIncrement", i18n_74, "selectionCheckboxLabel", i18n_75, "selectAllCheckboxLabel", i18n_76, "sortToolbarToolText", i18n_77, "groupCollapse", i18n_78, "groupExpand", i18n_79, "pagerSelectPage", i18n_80, "topToolbarLabel", i18n_81, "bottomToolbarLabel", i18n_82, "editToolbarToolText", i18n_83, "saveToolbarToolText", i18n_84, "addToolbarToolText", i18n_85, "cancelToolbarToolText", i18n_86, "removeToolbarToolText", i18n_87, "excelExportToolbarToolText", i18n_88, "pdfExportToolbarToolText", i18n_89, "groupPanelLabel", i18n_90, "dragRowHandleLabel", i18n_91, "columnMenuFilterTabTitle", i18n_92, "columnMenuGeneralTabTitle", i18n_93, "columnMenuColumnsTabTitle", i18n_94, "groupChipMenuPrevious", i18n_95, "groupChipMenuNext", i18n_96, "groupToolbarToolText", i18n_97, "removeConfirmationDialogTitle", i18n_98, "removeConfirmationDialogContent", i18n_99, "removeConfirmationDialogConfirmText", i18n_100, "removeConfirmationDialogRejectText", i18n_101, "externalEditingTitle", i18n_102, "externalEditingAddTitle", i18n_103, "externalEditingSaveText", i18n_104, "externalEditingCancelText", i18n_105, "aiAssistantToolbarToolText", i18n_106, "aiAssistantWindowTitle", i18n_107, "aiAssistantApplyButtonText", i18n_108, "aiAssistantWindowCloseTitle", i18n_109, "aiAssistantWindowMaximizeTitle", i18n_110, "aiAssistantWindowMinimizeTitle", i18n_111, "aiAssistantWindowRestoreTitle", i18n_112, "aiAssistantOutputCardTitle", i18n_113, "aiAssistantOutputCardBodyContent", i18n_114, "aiAssistantSelectionNotEnabled", i18n_115, "aiAssistantSelectionRowModeRequired", i18n_116, "aiAssistantSelectionCellModeRequired", i18n_117, "columnChooserSelectAll", i18n_118, "multiCheckboxFilterSearchPlaceholder", i18n_119, "multiCheckboxFilterSelectAllLabel", i18n_120, 6, "pagerLabel", "filterInputLabel", "filterMenuTitle", "filterMenuOperatorsDropDownLabel", "filterCellOperatorLabel", "booleanFilterCellLabel", "filterMenuLogicDropDownLabel", "columnMenu", "formValidationErrorText", "columnChooserSelectedColumnsCount", "multiCheckboxFilterSelectedItemsCount"], ["position", "top", 3, "size", "navigable"], [1, "k-grid-pager", "k-grid-pager-top", 3, "navigable", "pageSize", "total", "skip", "size", "responsive", "buttonCount", "info", "pageSizeValues", "previousNext", "type"], ["role", "toolbar", 3, "navigable", "text", "groups"], ["role", "grid", "kendoDragTargetContainer", "", "kendoDropTargetContainer", "", "mode", "manual", 1, "k-grid-aria-root", 3, "onPress", "onDragStart", "onDrag", "onDragEnter", "onDragLeave", "onDragEnd", "onDrop", "dragDisabled", "dropDisabled", "dragTargetFilter", "dropTargetFilter", "dragHandle", "hint", "hintContext", "dragData", "id"], ["kendoGridTable", "", "kendoGridResizableTable", "", "role", "presentation", 1, "k-grid-table", 3, "table-layout", "size"], ["kendoGridLoading", "", 3, "loadingTemplate"], [3, "statusBarTemplate"], [1, "k-grid-pager", 3, "navigable", "pageSize", "total", "skip", "size", "responsive", "buttonCount", "info", "pageSizeValues", "previousNext", "type"], ["position", "bottom", 1, "k-grid-toolbar-bottom", 3, "size", "navigable"], ["kendoWatermarkOverlay", "", 3, "licenseMessage"], [1, "k-grid-pager", "k-grid-pager-top", 3, "pageChange", "pagerInputVisibilityChange", "pageTextVisibilityChange", "itemsTextVisibilityChange", "navigable", "pageSize", "total", "skip", "size", "responsive", "buttonCount", "info", "pageSizeValues", "previousNext", "type"], ["kendoPagerTemplate", ""], [3, "ariaLabel", "firstPage", "inputLabel", "previousPage", "nextPage", "lastPage", "selectPage", "page", "itemsPerPage", "items", "of", "pageNumberInputTitle"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["role", "toolbar", 3, "change", "navigable", "text", "groups"], ["role", "presentation", 1, "k-grid-header", 3, "k-grid-draggable-header", "padding"], ["kendoDraggable", "", "kendoGridSelectionMarquee", "", 3, "pageChange", "scrollBottom", "contentScroll", "data", "rowHeight", "detailRowHeight", "total", "take", "groups", "groupable", "skip", "trackBy", "columns", "selectable", "filterable", "detailTemplate", "noRecordsTemplate", "size", "rowClass", "rowSticky", "loading", "isVirtual", "cellLoadingTemplate", "loadingTemplate", "virtualColumns", "enableDrag", "sort"], [1, "k-grid-footer", 3, "padding"], ["role", "presentation", 1, "k-grid-header"], ["role", "presentation", 1, "k-grid-header-locked", 3, "width"], ["role", "presentation", "data-scrollable", "", 1, "k-grid-header-wrap", 3, "kendoGridResizableContainer", "lockedWidth"], ["role", "presentation", "kendoGridResizableTable", "", "kendoGridTable", "", 1, "k-grid-header-table", 3, "virtualColumns", "size"], ["kendoGridColGroup", "", 3, "columns", "groups", "detailTemplate"], ["kendoGridHeader", "", "role", "rowgroup", 3, "resizable", "scrollable", "columns", "totalColumnLevels", "sort", "filter", "filterable", "groupable", "reorderable", "groups", "sortable", "columnMenu", "columnMenuTemplate", "lockedColumnsCount", "totalColumnsCount", "totalColumns", "detailTemplate", "tabIndex"], ["role", "presentation", 1, "k-width-container"], ["role", "presentation", 1, "k-grid-header-locked"], ["kendoGridResizableTable", "", "role", "presentation", "kendoGridTable", "", 1, "k-grid-header-table", 3, "locked", "size"], ["kendoGridHeader", "", "role", "rowgroup", 3, "resizable", "scrollable", "columns", "totalColumnLevels", "sort", "groups", "filter", "filterable", "groupable", "reorderable", "sortable", "columnMenu", "columnMenuTemplate", "totalColumnsCount", "totalColumns", "detailTemplate", "tabIndex"], [1, "k-grid-footer"], [1, "k-grid-footer-locked", 3, "width"], ["data-scrollable", "", 1, "k-grid-footer-wrap", 3, "kendoGridResizableContainer", "lockedWidth"], ["role", "presentation", "kendoGridTable", "", "kendoGridResizableTable", "", 1, "k-grid-footer-table", 3, "size"], ["kendoGridFooter", "", 3, "logicalRowIndex", "scrollable", "groups", "columns", "lockedColumnsCount", "detailTemplate", "totalColumns", "totalColumnsCount"], [1, "k-grid-footer-locked"], ["role", "presentation", "kendoGridResizableTable", "", "kendoGridTable", "", 1, "k-grid-footer-table", 3, "locked", "size"], ["kendoGridFooter", "", 3, "scrollable", "groups", "columns", "detailTemplate", "logicalRowIndex", "totalColumns", "totalColumnsCount"], ["kendoGridTable", "", "kendoGridResizableTable", "", "role", "presentation", 1, "k-grid-table", 3, "size"], ["kendoGridColGroup", "", 3, "columns", "groups", "sort", "detailTemplate"], ["kendoGridHeader", "", "role", "rowgroup", 1, "k-grid-header", 3, "k-grid-draggable-header", "resizable", "scrollable", "columns", "totalColumnLevels", "totalColumns", "groups", "groupable", "reorderable", "sort", "sortable", "filter", "filterable", "columnMenu", "columnMenuTemplate", "detailTemplate", "tabIndex"], ["kendoGridTableBody", "", "kendoDraggable", "", "kendoGridSelectionMarquee", "", 3, "isLoading", "rowHeight", "detailRowHeight", "groups", "rowsToRender", "skip", "columns", "totalColumnsCount", "totalColumns", "selectable", "filterable", "noRecordsTemplate", "detailTemplate", "trackBy", "rowClass", "enableDrag"], ["kendoGridFooter", "", 3, "scrollable", "logicalRowIndex", "groups", "columns", "detailTemplate", "totalColumns", "totalColumnsCount"], ["kendoGridHeader", "", "role", "rowgroup", 1, "k-grid-header", 3, "resizable", "scrollable", "columns", "totalColumnLevels", "totalColumns", "groups", "groupable", "reorderable", "sort", "sortable", "filter", "filterable", "columnMenu", "columnMenuTemplate", "detailTemplate", "tabIndex"], [1, "k-grid-pager", 3, "pageChange", "pagerInputVisibilityChange", "pageTextVisibilityChange", "itemsTextVisibilityChange", "navigable", "pageSize", "total", "skip", "size", "responsive", "buttonCount", "info", "pageSizeValues", "previousNext", "type"], ["innerCssClass", "k-drag-status", 3, "name", "svgIcon"], [1, "k-pager-numbers-wrap"], [3, "size"], [3, "size", "buttonCount"], [3, "size", "showPageText"], [3, "size", "pageSizes", "showItemsText"], [3, "resize"]];
    },
    template: function GridComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵprojectionDef(_c752);
        ɵɵelementContainerStart(0, 11);
        ɵɵi18nAttributes(1, 10);
        ɵɵelementContainerEnd();
        ɵɵconditionalCreate(2, GridComponent_Conditional_2_Template, 1, 4, "kendo-grid-toolbar", 12);
        ɵɵprojection(3);
        ɵɵconditionalCreate(4, GridComponent_Conditional_4_Template, 4, 23, "kendo-pager", 13);
        ɵɵconditionalCreate(5, GridComponent_Conditional_5_Template, 1, 5, "kendo-grid-group-panel", 14);
        ɵɵelementStart(6, "div", 15, 0);
        ɵɵlistener("onPress", function GridComponent_Template_div_onPress_6_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleReorderEvents($event, "press"));
        })("onDragStart", function GridComponent_Template_div_onDragStart_6_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleReorderEvents($event, "dragStart"));
        })("onDrag", function GridComponent_Template_div_onDrag_6_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleReorderEvents($event, "drag"));
        })("onDragEnter", function GridComponent_Template_div_onDragEnter_6_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleReorderEvents($event, "dragEnter"));
        })("onDragLeave", function GridComponent_Template_div_onDragLeave_6_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleReorderEvents($event, "dragLeave"));
        })("onDragEnd", function GridComponent_Template_div_onDragEnd_6_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleReorderEvents($event, "dragEnd"));
        })("onDrop", function GridComponent_Template_div_onDrop_6_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleReorderEvents($event, "drop"));
        });
        ɵɵconditionalCreate(8, GridComponent_Conditional_8_Template, 3, 26);
        ɵɵconditionalCreate(9, GridComponent_Conditional_9_Template, 5, 25, "table", 16);
        ɵɵconditionalCreate(10, GridComponent_Conditional_10_Template, 1, 1, "div", 17);
        ɵɵelementEnd();
        ɵɵconditionalCreate(11, GridComponent_Conditional_11_Template, 1, 1, "kendo-grid-status-bar", 18);
        ɵɵconditionalCreate(12, GridComponent_Conditional_12_Template, 4, 23, "kendo-pager", 19);
        ɵɵconditionalCreate(13, GridComponent_Conditional_13_Template, 1, 4, "kendo-grid-toolbar", 20);
        ɵɵtemplate(14, GridComponent_ng_template_14_Template, 2, 3, "ng-template", null, 1, ɵɵtemplateRefExtractor)(16, GridComponent_ng_template_16_Template, 7, 6, "ng-template", null, 2, ɵɵtemplateRefExtractor);
        ɵɵelement(18, "div", null, 3)(20, "div", null, 4);
        ɵɵconditionalCreate(22, GridComponent_Conditional_22_Template, 1, 0, "kendo-grid-adaptive-renderer");
        ɵɵconditionalCreate(23, GridComponent_Conditional_23_Template, 1, 0, "kendo-resize-sensor");
        ɵɵconditionalCreate(24, GridComponent_Conditional_24_Template, 1, 1, "div", 21);
      }
      if (rf & 2) {
        const defaultHint_r11 = ɵɵreference(15);
        ɵɵi18nExp("Page navigation, page {currentPage} of {totalPages}")("{columnName} Filter")("{columnName} Filter Menu")("{columnName} Filter Operators")("Filter cell operators for {columnName}")("Boolean filter cell for {columnName}")("{columnName} Filter Logic")("{columnName} Column Menu")("The {fieldName} field has {errorName} validation error")("{selectedColumnsCount} Selected items")("{selectedItemsCount} selected items");
        ɵɵi18nApply(1);
        ɵɵadvance(2);
        ɵɵconditional(ctx.showTopToolbar ? 2 : -1);
        ɵɵadvance(2);
        ɵɵconditional(ctx.showTopPager ? 4 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.showGroupPanel ? 5 : -1);
        ɵɵadvance();
        ɵɵproperty("dragDisabled", !ctx.rowReorderable)("dropDisabled", !ctx.rowReorderable)("dragTargetFilter", ctx.getDefaultSelectors("dragTarget"))("dropTargetFilter", ctx.getDefaultSelectors("dropTarget"))("dragHandle", ctx.getDefaultSelectors("handle"))("hint", ɵɵpureFunction1(35, _c77, ctx.customHintTemplate || defaultHint_r11))("hintContext", ctx.hintContext)("dragData", ctx.gridData)("id", ctx.ariaRootId);
        ɵɵattribute("aria-label", ctx.ariaLabel)("aria-rowcount", ctx.ariaRowCount)("aria-colcount", ctx.ariaColCount);
        ɵɵadvance(2);
        ɵɵconditional(ctx.isScrollable ? 8 : -1);
        ɵɵadvance();
        ɵɵconditional(!ctx.isScrollable ? 9 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.loading ? 10 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.showStatusBar ? 11 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.showBottomPager ? 12 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.showBottomToolbar ? 13 : -1);
        ɵɵadvance(9);
        ɵɵconditional(ctx.isAdaptiveModeEnabled ? 22 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.isVirtual ? 23 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.showLicenseWatermark ? 24 : -1);
      }
    },
    dependencies: [LocalizedMessagesDirective7, ToolbarComponent, GroupPanelComponent, TableDirective, GridTableDirective, ColGroupComponent, HeaderComponent2, ResizableContainerDirective, ListComponent2, DragTargetContainerDirective, DropTargetContainerDirective, DraggableDirective, GridMarqueeDirective, FooterComponent2, TableBodyComponent, LoadingComponent, StatusBarComponent, IconWrapperComponent, WatermarkOverlayComponent, CustomMessagesComponent, PagerInfoComponent, PagerInputComponent, PagerNextButtonsComponent, PagerNumericButtonsComponent, PagerPageSizesComponent, PagerPrevButtonsComponent, PagerTemplateDirective, PagerComponent, NgTemplateOutlet, AdaptiveRendererComponent, ResizeSensorComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GridComponent, [{
    type: Component,
    args: [{
      encapsulation: ViewEncapsulation.None,
      exportAs: "kendoGrid",
      providers: [BrowserSupportService, LocalizationService, ColumnInfoService, SelectionService2, CellSelectionService, DetailsService, GroupsService, GroupInfoService, ChangeNotificationService, EditService, PDFService, SuspendService, {
        provide: CELL_CONTEXT,
        useValue: EMPTY_CELL_CONTEXT
      }, {
        provide: L10N_PREFIX,
        useValue: "kendo.grid"
      }, FilterService, ResponsiveService, PagerContextService, PagerNavigationService, ExcelService, ScrollSyncService2, ResizeService, LocalDataChangesService, DomEventsService, ColumnResizingService, SinglePopupService, DragAndDropService, DragHintService, DropCueService, ColumnReorderService, NavigationService4, FocusRoot, IdService, CellSelectionAggregateService, ScrollRequestService, SortService, ContextService, SizingOptionsService, RowReorderService, ClipboardService, GridAIRequestResponseService, RowspanService, AdaptiveGridService, ColumnMenuService, MenuTabbingService, DataMappingService],
      selector: "kendo-grid",
      template: `
        <ng-container kendoGridLocalizedMessages
          i18n-groupPanelEmpty="kendo.grid.groupPanelEmpty|The label visible in the Grid group panel when it is empty"
          groupPanelEmpty="Drag a column header and drop it here to group by that column"

          i18n-noRecords="kendo.grid.noRecords|The label visible in the Grid when there are no records"
          noRecords="No records available."

          i18n-pagerLabel="kendo.grid.pagerLabel|The label for the Grid pager"
          pagerLabel="{{ 'Page navigation, page {currentPage} of {totalPages}' }}"

          i18n-pagerFirstPage="kendo.grid.pagerFirstPage|The label for the first page button in Grid pager"
          pagerFirstPage="Go to the first page"

          i18n-pagerPreviousPage="kendo.grid.pagerPreviousPage|The label for the previous page button in Grid pager"
          pagerPreviousPage="Go to the previous page"

          i18n-pagerNextPage="kendo.grid.pagerNextPage|The label for the next page button in Grid pager"
          pagerNextPage="Go to the next page"

          i18n-pagerLastPage="kendo.grid.pagerLastPage|The label for the last page button in Grid pager"
          pagerLastPage="Go to the last page"

          i18n-pagerPage="kendo.grid.pagerPage|The label before the current page number in the Grid pager"
          pagerPage="Page"

          i18n-pagerOf="kendo.grid.pagerOf|The label before the total pages number in the Grid pager"
          pagerOf="of"

          i18n-pagerItems="kendo.grid.pagerItems|The label after the total pages number in the Grid pager"
          pagerItems="items"

          i18n-pagerPageNumberInputTitle="kendo.grid.pagerPageNumberInputTitle|The label for the pager input in the Grid pager"
          pagerPageNumberInputTitle="Page Number"

          i18n-pagerItemsPerPage="kendo.grid.pagerItemsPerPage|The label for the page size chooser in the Grid pager"
          pagerItemsPerPage="items per page"

          i18n-pagerInputLabel="kendo.grid.pagerInputLabel|The text of the aria-label attribute applied to the input element for entering the page number"
          pagerInputLabel="Type a page number"

          i18n-filter="kendo.grid.filter|The label of the filter cell or icon"
          filter="Filter"

          i18n-filterInputLabel="kendo.grid.filterInputLabel|The label of the filter row and menu inputs"
          filterInputLabel="{{ '{columnName} Filter' }}"

          i18n-filterMenuTitle="kendo.grid.filterMenuTitle|The title of the filter menu icon"
          filterMenuTitle="{{ '{columnName} Filter Menu' }}"

          i18n-filterMenuOperatorsDropDownLabel="kendo.grid.filterMenuOperatorsDropDownLabel|The label of the filter menu operators dropdown"
          filterMenuOperatorsDropDownLabel="{{ '{columnName} Filter Operators' }}"

          i18n-filterCellOperatorLabel="kendo.grid.filterCellOperatorLabel|The label of the filter cell operators dropdown"
          filterCellOperatorLabel="{{ 'Filter cell operators for {columnName}' }}"

          i18n-booleanFilterCellLabel="kendo.grid.booleanFilterCellLabel|The label of the boolean filter cell dropdown"
          booleanFilterCellLabel="{{ 'Boolean filter cell for {columnName}' }}"

          i18n-filterMenuLogicDropDownLabel="kendo.grid.filterMenuLogicDropDownLabel|The label of the filter menu logic dropdown"
          filterMenuLogicDropDownLabel="{{ '{columnName} Filter Logic' }}"

          i18n-filterEqOperator="kendo.grid.filterEqOperator|The text of the equal filter operator"
          filterEqOperator="Is equal to"

          i18n-filterNotEqOperator="kendo.grid.filterNotEqOperator|The text of the not equal filter operator"
          filterNotEqOperator="Is not equal to"

          i18n-filterIsNullOperator="kendo.grid.filterIsNullOperator|The text of the is null filter operator"
          filterIsNullOperator="Is null"

          i18n-filterIsNotNullOperator="kendo.grid.filterIsNotNullOperator|The text of the is not null filter operator"
          filterIsNotNullOperator="Is not null"

          i18n-filterIsEmptyOperator="kendo.grid.filterIsEmptyOperator|The text of the is empty filter operator"
          filterIsEmptyOperator="Is empty"

          i18n-filterIsNotEmptyOperator="kendo.grid.filterIsNotEmptyOperator|The text of the is not empty filter operator"
          filterIsNotEmptyOperator="Is not empty"

          i18n-filterStartsWithOperator="kendo.grid.filterStartsWithOperator|The text of the starts with filter operator"
          filterStartsWithOperator="Starts with"

          i18n-filterContainsOperator="kendo.grid.filterContainsOperator|The text of the contains filter operator"
          filterContainsOperator="Contains"

          i18n-filterNotContainsOperator="kendo.grid.filterNotContainsOperator|The text of the does not contain filter operator"
          filterNotContainsOperator="Does not contain"

          i18n-filterEndsWithOperator="kendo.grid.filterEndsWithOperator|The text of the ends with filter operator"
          filterEndsWithOperator="Ends with"

          i18n-filterGteOperator="kendo.grid.filterGteOperator|The text of the greater than or equal filter operator"
          filterGteOperator="Is greater than or equal to"

          i18n-filterGtOperator="kendo.grid.filterGtOperator|The text of the greater than filter operator"
          filterGtOperator="Is greater than"

          i18n-filterLteOperator="kendo.grid.filterLteOperator|The text of the less than or equal filter operator"
          filterLteOperator="Is less than or equal to"

          i18n-filterLtOperator="kendo.grid.filterLtOperator|The text of the less than filter operator"
          filterLtOperator="Is less than"

          i18n-filterIsTrue="kendo.grid.filterIsTrue|The text of the IsTrue boolean filter option"
          filterIsTrue="Is True"

          i18n-filterIsFalse="kendo.grid.filterIsFalse|The text of the IsFalse boolean filter option"
          filterIsFalse="Is False"

          i18n-filterBooleanAll="kendo.grid.filterBooleanAll|The text of the (All) boolean filter option"
          filterBooleanAll="(All)"

          i18n-filterAfterOrEqualOperator="kendo.grid.filterAfterOrEqualOperator|The text of the after or equal date filter operator"
          filterAfterOrEqualOperator="Is after or equal to"

          i18n-filterAfterOperator="kendo.grid.filterAfterOperator|The text of the after date filter operator"
          filterAfterOperator="Is after"

          i18n-filterBeforeOperator="kendo.grid.filterBeforeOperator|The text of the before date filter operator"
          filterBeforeOperator="Is before"

          i18n-filterBeforeOrEqualOperator="kendo.grid.filterBeforeOrEqualOperator|The text of the before or equal date filter operator"
          filterBeforeOrEqualOperator="Is before or equal to"

          i18n-filterFilterButton="kendo.grid.filterFilterButton|The text of the filter button"
          filterFilterButton="Filter"

          i18n-filterClearButton="kendo.grid.filterClearButton|The text of the clear filter button"
          filterClearButton="Clear"

          i18n-sortClearButton="kendo.grid.sortClearButton|The text of the clear sort button located in the Sort Toolbar Tool and adaptive Sort Toolbar Tool"
          sortClearButton="Clear sorting"

          i18n-adaptiveCloseButtonTitle="kendo.grid.adaptiveCloseButtonTitle|The title of the Close button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode"
          adaptiveCloseButtonTitle="Close"

          i18n-adaptiveBackButtonTitle="kendo.grid.adaptiveBackButtonTitle|The title of the Back button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode"
          adaptiveBackButtonTitle="Back"

          i18n-filterClearAllButton="kendo.grid.filterClearAllButton|The text of the clear all filters button located in the Filter Toolbar Tool and adaptive Filter Toolbar Tool"
          filterClearAllButton="Clear all filters"

          i18n-groupClearButton="kendo.grid.groupClearButton|The text of the clear grouping button in the Group Toolbar Tool and adaptive Group Toolbar Tool"
          groupClearButton="Clear grouping"

          i18n-sortDoneButton="kendo.grid.sortDoneButton|The text of the done sort button"
          sortDoneButton="Done"

          i18n-groupDoneButton="kendo.grid.groupDoneButton|The text of the done group button in the adaptive Group Toolbar Tool"
          groupDoneButton="Done"

          i18n-filterAndLogic="kendo.grid.filterAndLogic|The text of the And filter logic"
          filterAndLogic="And"

          i18n-filterOrLogic="kendo.grid.filterOrLogic|The text of the Or filter logic"
          filterOrLogic="Or"

          i18n-filterToolbarToolText="kendo.grid.filterToolbarToolText|The button text of the Filter toolbar tool"
          filterToolbarToolText="Filter"

          i18n-loading="kendo.grid.loading|The loading text"
          loading="Loading"

          i18n-gridLabel="kendo.grid.gridLabel|The Grid aria-label"
          gridLabel="Data table"

          i18n-columnMenu="kendo.grid.columnMenu|The title of the column menu icon"
          columnMenu="{{ '{columnName} Column Menu' }}"

          i18n-columns="kendo.grid.columns|The text for the Grid Column Chooser and Column Chooser toolbar tool"
          columns="Columns"

          i18n-columnsSubtitle="kendo.grid.columnsSubtitle|The subtitle for the adaptive Grid Column Chooser and Column Chooser toolbar tool"
          columnsSubtitle="Selected fields are visible"

          i18n-adaptiveFilterTitle="kendo.grid.adaptiveFilterTitle|The title that is displayed in the adaptive Filter Toolbar Tool and Filter Menu"
          adaptiveFilterTitle="Filter by"

          i18n-adaptiveFilterOperatorsTitle="kendo.grid.adaptiveFilterOperatorsTitle|The title that is displayed in the Operators Action Sheet"
          adaptiveFilterOperatorsTitle="Operators"

          i18n-adaptiveSortTitle="kendo.grid.adaptiveSortTitle|The title that is displayed in the adaptive Sort Toolbar Tool"
          adaptiveSortTitle="Sort by"

          i18n-adaptiveGroupTitle="kendo.grid.adaptiveGroupTitle|The title that is displayed in the adaptive Group Toolbar Tool."
          adaptiveGroupTitle="Group by"

          i18n-lock="kendo.grid.lock|The text shown in the column menu for the lock item"
          lock="Lock"

          i18n-unlock="kendo.grid.unlock|The text shown in the column menu for the unlock item"
          unlock="Unlock"

          i18n-setColumnPosition="kendo.grid.setColumnPosition|The text shown in the column menu for the set column position item"
          setColumnPosition="Set Column Position"

          i18n-stick="kendo.grid.stick|The text shown in the column menu for the stick item"
          stick="Stick"

          i18n-unstick="kendo.grid.unstick|The text shown in the column menu for the unstick item"
          unstick="Unstick"

          i18n-sortable="kendo.grid.sortable|The label of the sort icon"
          sortable="Sortable"

          i18n-sortAscending="kendo.grid.sortAscending|The text shown in the column menu for the sort ascending item"
          sortAscending="Sort Ascending"

          i18n-sortDescending="kendo.grid.sortDescending|The text shown in the column menu for the sort descending item"
          sortDescending="Sort Descending"

          i18n-autosizeAllColumns="kendo.grid.autosizeAllColumns|The text shown in the column menu for the autosize all columns item"
          autosizeAllColumns="Autosize All Columns"

          i18n-autosizeThisColumn="kendo.grid.autosizeThisColumn|The text shown in the column menu for the autosize this column item"
          autosizeThisColumn="Autosize This Column"

          i18n-sortedDefault="kendo.grid.sortedDefault|The status announcement when a column is no longer sorted"
          sortedDefault="Not Sorted"

          i18n-sortedAscending="kendo.grid.sortedAscending|The title of the Group Chip indicating the ascending sorting order of the groups"
          sortedAscending="Sorted Ascending"

          i18n-sortedDescending="kendo.grid.sortedDescending|The title of the Group Chip indicating the descending sorting order of the groups"
          sortedDescending="Sorted Descending"

          i18n-columnsApply="kendo.grid.columnsApply|The text shown in the column menu or column chooser for the columns apply button"
          columnsApply="Apply"

          i18n-columnsReset="kendo.grid.columnsReset|The text shown in the column menu or column chooser for the columns reset button"
          columnsReset="Reset"

          i18n-detailExpand="kendo.grid.detailExpand|The title of the expand icon of detail rows. Applies also to the expand button text in stacked mode."
          detailExpand="Expand Details"

          i18n-detailCollapse="kendo.grid.detailCollapse|The title of the collapse icon of detail rows. Applies also to the collapse button text in stacked mode."
          detailCollapse="Collapse Details"

          i18n-filterDateToday="kendo.grid.filterDateToday|The text of the Today button of the Date filter."
          filterDateToday="TODAY"

          i18n-filterDateToggle="kendo.grid.filterDateToggle|The title of the Toggle button of the Date filter."
          filterDateToggle="Toggle Calendar"

          i18n-filterNumericDecrement="kendo.grid.filterNumericDecrement|The title of the Decrement button of the Numeric filter."
          filterNumericDecrement="Decrement"

          i18n-filterNumericIncrement="kendo.grid.filterNumericIncrement|The title of the Increment button of the Numeric filter."
          filterNumericIncrement="Increment"

          i18n-selectionCheckboxLabel="kendo.grid.selectionCheckboxLabel|The labels of the checkbox column checkboxes."
          selectionCheckboxLabel="Select Row"

          i18n-selectAllCheckboxLabel="kendo.grid.selectAllCheckboxLabel|The label of the checkbox column select all checkbox."
          selectAllCheckboxLabel="Select All Rows"

          i18n-sortToolbarToolText="kendo.grid.sortToolbarToolText|The button text of the Sort toolbar tool."
          sortToolbarToolText="Sort"

          i18n-groupCollapse="kendo.grid.groupCollapse|The text of the title and aria-label attributes applied to the collapse icon of group rows."
          groupCollapse="Collapse Group"

          i18n-groupExpand="kendo.grid.groupExpand|The text of the title and aria-label attributes applied to the expand icon of group rows."
          groupExpand="Expand Group"

          i18n-pagerSelectPage="kendo.grid.pagerSelectPage|The text of the title and aria-label attributes applied to the page chooser in the Grid Pager"
          pagerSelectPage="Select page"

          i18n-topToolbarLabel="kendo.grid.topToolbarLabel|The label for the Grid top toolbar"
          topToolbarLabel="Top toolbar"

          i18n-bottomToolbarLabel="kendo.grid.bottomToolbarLabel|The label for the Grid bottom toolbar"
          bottomToolbarLabel="Bottom toolbar"

          i18n-editToolbarToolText="kendo.grid.editToolbarToolText|The text for the Grid Edit toolbar tool"
          editToolbarToolText="Edit"

          i18n-saveToolbarToolText="kendo.grid.saveToolbarToolText|The text for the Grid Save toolbar tool"
          saveToolbarToolText="Save"

          i18n-addToolbarToolText="kendo.grid.addToolbarToolText|The text for the Grid Add toolbar tool"
          addToolbarToolText="Add"

          i18n-cancelToolbarToolText="kendo.grid.cancelToolbarToolText|The text for the Grid Cancel toolbar tool"
          cancelToolbarToolText="Cancel"

          i18n-removeToolbarToolText="kendo.grid.removeToolbarToolText|The text for the Grid Remove toolbar tool"
          removeToolbarToolText="Delete"

          i18n-excelExportToolbarToolText="kendo.grid.excelExportToolbarToolText|The text for the Grid Excel export toolbar tool"
          excelExportToolbarToolText="Excel Export"

          i18n-pdfExportToolbarToolText="kendo.grid.pdfExportToolbarToolText|The text for the Grid PDF export toolbar tool"
          pdfExportToolbarToolText="PDF Export"

          i18n-groupPanelLabel="kendo.grid.groupPanelLabel|The label for the Grid group panel toolbar"
          groupPanelLabel="Group panel"

          i18n-dragRowHandleLabel="kendo.grid.dragRowHandleLabel|The label for the Grid drag row handle"
          dragRowHandleLabel="Drag row"

          i18n-columnMenuFilterTabTitle="kendo.grid.columnMenuFilterTabTitle|The title for the column menu Filter tab"
          columnMenuFilterTabTitle="Filter"

          i18n-columnMenuGeneralTabTitle="kendo.grid.columnMenuGeneralTabTitle|The title for the column menu General tab"
          columnMenuGeneralTabTitle="General"

          i18n-columnMenuColumnsTabTitle="kendo.grid.columnMenuColumnsTabTitle|The title for the column menu Columns tab"
          columnMenuColumnsTabTitle="Columns"

          i18n-groupChipMenuPrevious="kendo.grid.groupChipMenuPrevious|The text for the Group pane Chip Menu Move as previous item"
          groupChipMenuPrevious="Move as previous"

          i18n-groupChipMenuNext="kendo.grid.groupChipMenuNext|The text for the Group pane Chip Menu Move as next item"
          groupChipMenuNext="Move as next"

          i18n-groupToolbarToolText="kendo.grid.groupToolbarToolText|The button text of the Group toolbar tool"
          groupToolbarToolText="Group"

          i18n-formValidationErrorText="kendo.grid.formValidationErrorText|The default text of a form validation error when using external editing."
          formValidationErrorText="{{ 'The {fieldName} field has {errorName} validation error' }}"

          i18n-removeConfirmationDialogTitle="kendo.grid.removeConfirmationDialogTitle|The title of the built-in remove item confirmation Dialog"
          removeConfirmationDialogTitle="Please confirm"

          i18n-removeConfirmationDialogContent="kendo.grid.removeConfirmationDialogContent|The content of the built-in remove item confirmation Dialog"
          removeConfirmationDialogContent="Are you sure you want to delete this item?"

          i18n-removeConfirmationDialogConfirmText="kendo.grid.removeConfirmationDialogConfirmText|The text of the built-in remove item confirmation Dialog confirm action button"
          removeConfirmationDialogConfirmText="Yes"

          i18n-removeConfirmationDialogRejectText="kendo.grid.removeConfirmationDialogRejectText|The text of the built-in remove item confirmation Dialog reject action button"
          removeConfirmationDialogRejectText="No"

          i18n-externalEditingTitle="kendo.grid.externalEditingTitle|The title of the built-in external editing form container when editing an item"
          externalEditingTitle="Edit"

          i18n-externalEditingAddTitle="kendo.grid.externalEditingAddTitle|The title of the built-in external editing form container when adding a new item"
          externalEditingAddTitle="Add"

          i18n-externalEditingSaveText="kendo.grid.externalEditingSaveText|The text of the external editing form Save button"
          externalEditingSaveText="Save"

          i18n-externalEditingCancelText="kendo.grid.externalEditingCancelText|The text of the external editing form Cancel button"
          externalEditingCancelText="Cancel"

          i18n-aiAssistantToolbarToolText="kendo.grid.aiAssistantToolbarToolText|The text of the AI Assistant toolbar tool"
          aiAssistantToolbarToolText="AI Assistant"

          i18n-aiAssistantWindowTitle="kendo.grid.aiAssistantWindowTitle|The text of the AI Assistant Window title"
          aiAssistantWindowTitle="AI Assistant"

          i18n-aiAssistantApplyButtonText="kendo.grid.aiAssistantApplyButtonText|The text of the AI Assistant Apply button"
          aiAssistantApplyButtonText="Apply"

          i18n-aiAssistantWindowCloseTitle="kendo.grid.aiAssistantWindowCloseTitle|The title of the AI Assistant Window close button"
          aiAssistantWindowCloseTitle="Close"

          i18n-aiAssistantWindowMaximizeTitle="kendo.grid.aiAssistantWindowMaximizeTitle|The title of the AI Assistant Window maximize button"
          aiAssistantWindowMaximizeTitle="Maximize"

          i18n-aiAssistantWindowMinimizeTitle="kendo.grid.aiAssistantWindowMinimizeTitle|The title of the AI Assistant Window minimize button"
          aiAssistantWindowMinimizeTitle="Minimize"

          i18n-aiAssistantWindowRestoreTitle="kendo.grid.aiAssistantWindowRestoreTitle|The title of the AI Assistant Window restore button"
          aiAssistantWindowRestoreTitle="Restore"

          i18n-aiAssistantOutputCardTitle="kendo.grid.aiAssistantOutputCardTitle|The title of the AI Assistant Prompt Output Card"
          aiAssistantOutputCardTitle="Generated with AI"

          i18n-aiAssistantOutputCardBodyContent="kendo.grid.aiAssistantOutputCardBodyContent|The success message dispayed in the AI Assistant Prompt Output Card's body"
          aiAssistantOutputCardBodyContent="Operation is successful. Data is:"

          i18n-aiAssistantSelectionNotEnabled="kendo.grid.aiAssistantSelectionNotEnabled|The message shown when AI selection requires the Grid selectable option"
          aiAssistantSelectionNotEnabled="Selection can be applied only when the Grid selectable option is enabled."

          i18n-aiAssistantSelectionRowModeRequired="kendo.grid.aiAssistantSelectionRowModeRequired|The message shown when AI selection requires row selection mode"
          aiAssistantSelectionRowModeRequired="Selection can be applied only when row selection mode is enabled."

          i18n-aiAssistantSelectionCellModeRequired="kendo.grid.aiAssistantSelectionCellModeRequired|The message shown when AI selection requires cell selection mode"
          aiAssistantSelectionCellModeRequired="Selection can be applied only when cell selection mode is enabled."

          i18n-columnChooserSelectAll="kendo.grid.columnChooserSelectAll|The text for the Select all checkbox in the Column Chooser"
          columnChooserSelectAll="Select all"

          i18n-columnChooserSelectedColumnsCount="kendo.grid.columnChooserSelectedColumnsCount|The text displayed in the Column Chooser for the number of selected columns"
          columnChooserSelectedColumnsCount="{{ '{selectedColumnsCount} Selected items' }}"

          i18n-multiCheckboxFilterSearchPlaceholder="kendo.grid.multiCheckboxFilterSearchPlaceholder|The placeholder text for the multi-checkbox filter search input"
          multiCheckboxFilterSearchPlaceholder="Search..."

          i18n-multiCheckboxFilterSelectAllLabel="kendo.grid.multiCheckboxFilterSelectAllLabel|The label for the multi-checkbox filter select all option"
          multiCheckboxFilterSelectAllLabel="Select all"

          i18n-multiCheckboxFilterSelectedItemsCount="kendo.grid.multiCheckboxFilterSelectedItemsCount|The text for the multi-checkbox filter selected items count"
          multiCheckboxFilterSelectedItemsCount="{{ '{selectedItemsCount} selected items' }}"
          >
        </ng-container>
        @if (showTopToolbar) {
          <kendo-grid-toolbar
            [size]="size"
            [attr.aria-label]="messageFor('topToolbarLabel')"
            [navigable]="navigation.toolbarEnabled"
            [attr.aria-controls]="ariaRootId"
          position="top"></kendo-grid-toolbar>
        }
        <ng-content select="kendo-toolbar"></ng-content>
        @if (showTopPager) {
          <kendo-pager
            #topPager
            [navigable]="navigation.pagerEnabled"
            class="k-grid-pager k-grid-pager-top"
            [pageSize]="pageSize"
            [total]="view.total"
            [skip]="skip"
            [size]="size"
            [responsive]="normalizedPageableSettings.responsive && !pagerTemplate"
            [buttonCount]="normalizedPageableSettings.buttonCount"
            [info]="normalizedPageableSettings.info"
            [pageSizeValues]="normalizedPageableSettings.pageSizes"
            [previousNext]="normalizedPageableSettings.previousNext"
            [type]="normalizedPageableSettings.type"
            (pageChange)="notifyPageChange('pager', $event)"
            (pagerInputVisibilityChange)="handlePagerVisibilityChange('showPagerInput', $event)"
            (pageTextVisibilityChange)="handlePagerVisibilityChange('showPagerPageText', $event)"
            (itemsTextVisibilityChange)="handlePagerVisibilityChange('showPagerItemsText', $event)">
            <ng-template kendoPagerTemplate>
              <ng-container
                [ngTemplateOutlet]="pagerTemplate ? pagerTemplate?.templateRef : defaultPager"
              [ngTemplateOutletContext]="topPager.templateContext"></ng-container>
            </ng-template>
            <kendo-pager-messages
              [ariaLabel]="messageFor('pagerLabel')"
              [firstPage]="messageFor('pagerFirstPage')"
              [inputLabel]="messageFor('pagerInputLabel')"
              [previousPage]="messageFor('pagerPreviousPage')"
              [nextPage]="messageFor('pagerNextPage')"
              [lastPage]="messageFor('pagerLastPage')"
              [selectPage]="messageFor('pagerSelectPage')"
              [page]="messageFor('pagerPage')"
              [itemsPerPage]="messageFor('pagerItemsPerPage')"
              [items]="messageFor('pagerItems')"
              [of]="messageFor('pagerOf')"
              [pageNumberInputTitle]="messageFor('pagerPageNumberInputTitle')">
            </kendo-pager-messages>
          </kendo-pager>
        }
        @if (showGroupPanel) {
          <kendo-grid-group-panel
            [navigable]="navigation.toolbarEnabled"
            [text]="groupableEmptyText"
            [groups]="group"
            role="toolbar"
            [attr.aria-label]="messageFor('groupPanelLabel')"
            [attr.aria-controls]="ariaRootId"
            (change)="groupChange.emit($event)">
          </kendo-grid-group-panel>
        }
        <div #ariaRoot
          class="k-grid-aria-root"
          role="grid"
          kendoDragTargetContainer
          kendoDropTargetContainer
          mode="manual"
          [dragDisabled]="!rowReorderable"
          [dropDisabled]="!rowReorderable"
          [dragTargetFilter]="getDefaultSelectors('dragTarget')"
          [dropTargetFilter]="getDefaultSelectors('dropTarget')"
          [dragHandle]="getDefaultSelectors('handle')"
          [hint]="{hintTemplate: customHintTemplate || defaultHint}"
          [hintContext]="hintContext"
          (onPress)="handleReorderEvents($event, 'press')"
          (onDragStart)="handleReorderEvents($event, 'dragStart')"
          (onDrag)="handleReorderEvents($event, 'drag')"
          (onDragEnter)="handleReorderEvents($event, 'dragEnter')"
          (onDragLeave)="handleReorderEvents($event, 'dragLeave')"
          (onDragEnd)="handleReorderEvents($event, 'dragEnd')"
          (onDrop)="handleReorderEvents($event, 'drop')"
          [dragData]="gridData"
          [id]="ariaRootId"
          [attr.aria-label]="ariaLabel"
          [attr.aria-rowcount]="ariaRowCount"
          [attr.aria-colcount]="ariaColCount">
          @if (isScrollable) {
            @if (!hideHeader && !isStacked) {
              <div
                class="k-grid-header"
                [class.k-grid-draggable-header]="groupable || reorderable"
                role="presentation"
                [style.padding]="headerPadding">
                @if (isLocked) {
                  <div
                    #lockedHeader
                    role="presentation"
                    class="k-grid-header-locked"
                    [style.width.px]="lockedWidth">
                    <table
                      kendoGridResizableTable
                      [locked]="true"
                      role="presentation"
                      class="k-grid-header-table"
                      [style.width.px]="lockedWidth"
                      kendoGridTable
                      [size]="size">
                      <colgroup kendoGridColGroup
                        [columns]="$any(lockedLeafColumns)"
                        [groups]="group"
                        [detailTemplate]="detailTemplate">
                    </colgroup>
                    <thead kendoGridHeader
                      role="rowgroup"
                      [resizable]="resizable"
                      [scrollable]="true"
                      [columns]="$any(lockedColumns)"
                      [totalColumnLevels]="totalColumnLevels"
                      [sort]="sort"
                      [groups]="group"
                      [filter]="filter"
                      [filterable]="filterable"
                      [groupable]="showGroupPanel"
                      [reorderable]="reorderable"
                      [sortable]="sortable"
                      [columnMenu]="columnMenuOptions"
                      [columnMenuTemplate]="columnMenuTemplate"
                      [totalColumnsCount]="leafColumns.length"
                      [totalColumns]="columnsContainer"
                      [detailTemplate]="detailTemplate"
                      [tabIndex]="navigation.tableEnabled ? '-1' : '0'">
                    </thead>
                  </table>
                </div>
              }
              <div #header class="k-grid-header-wrap" role="presentation" data-scrollable
                [kendoGridResizableContainer]="lockedLeafColumns.length > 0"
                [lockedWidth]="lockedWidth + scrollbarWidth + 2">
                <table
                  role="presentation"
                  class="k-grid-header-table"
                  [style.width.px]="nonLockedWidth"
                  kendoGridResizableTable
                  [virtualColumns]="virtualColumns"
                  kendoGridTable
                  [size]="size">
                  <colgroup kendoGridColGroup
                    [columns]="headerLeafColumns"
                    [groups]="isLocked ? [] : group"
                    [detailTemplate]="detailTemplate">
                </colgroup>
                <thead kendoGridHeader
                  [resizable]="resizable"
                  role="rowgroup"
                  [scrollable]="true"
                  [columns]="headerColumns"
                  [totalColumnLevels]="totalColumnLevels"
                  [sort]="sort"
                  [filter]="filter"
                  [filterable]="filterable"
                  [groupable]="showGroupPanel"
                  [reorderable]="reorderable"
                  [groups]="isLocked ? [] : group"
                  [sortable]="sortable"
                  [columnMenu]="columnMenuOptions"
                  [columnMenuTemplate]="columnMenuTemplate"
                  [lockedColumnsCount]="lockedLeafColumns.length"
                  [totalColumnsCount]="leafColumns.length"
                  [totalColumns]="columnsContainer"
                  [detailTemplate]="detailTemplate"
                  [tabIndex]="navigation.tableEnabled ? '-1' : '0'">
                </thead>
              </table>
              @if (virtualColumns) {
                <div class="k-width-container" role="presentation">
                  <div [style.width.px]="columnsContainer.unlockedWidth"></div>
                </div>
              }
            </div>
          </div>
        }
        <kendo-grid-list
          [data]="$any(view)"
          [rowHeight]="rowHeight"
          [detailRowHeight]="detailRowHeight"
          [total]="totalCount"
          [take]="pageSize"
          [groups]="group"
          [groupable]="groupable"
          [skip]="skip"
          [trackBy]="trackBy"
          [columns]="columnsContainer"
          [selectable]="selectable"
          [filterable]="filterable"
          [detailTemplate]="detailTemplate"
          [noRecordsTemplate]="noRecordsTemplate"
          [size]="size"
          (pageChange)="notifyPageChange('list', $event)"
          [rowClass]="rowClass"
          [rowSticky]="rowSticky"
          [loading]="loading"
          [isVirtual]="isVirtual"
          [cellLoadingTemplate]="cellLoadingTemplate?.templateRef"
          [loadingTemplate]="loadingTemplate?.templateRef"
          [virtualColumns]="virtualColumns"
          (scrollBottom)="notifyScrollBottom()"
          (contentScroll)="contentScroll.emit($event)"
          kendoDraggable
          kendoGridSelectionMarquee
          [enableDrag]="marqueeSelection"
          [sort]="sort">
        </kendo-grid-list>
        @if (showFooter) {
          <div
            class="k-grid-footer"
            [style.padding]="headerPadding">
            @if (lockedLeafColumns.length && !isStacked) {
              <div
                class="k-grid-footer-locked"
                [style.width.px]="lockedWidth">
                <table
                  role="presentation"
                  class="k-grid-footer-table"
                  kendoGridResizableTable
                  [locked]="true"
                  [style.width.px]="lockedWidth"
                  kendoGridTable
                  [size]="size">
                  @if (!isStacked) {
                    <colgroup kendoGridColGroup
                      [columns]="$any(lockedLeafColumns)"
                      [groups]="group"
                      [detailTemplate]="detailTemplate">
                  </colgroup>
                }
                <tfoot kendoGridFooter
                  [scrollable]="true"
                  [groups]="group"
                  [columns]="$any(lockedLeafColumns)"
                  [detailTemplate]="detailTemplate"
                  [logicalRowIndex]="ariaRowCount"
                  [totalColumns]="columnsContainer"
                  [totalColumnsCount]="leafColumns.length">
                </tfoot>
              </table>
            </div>
          }
          <div #footer
            class="k-grid-footer-wrap" data-scrollable
            [kendoGridResizableContainer]="lockedLeafColumns.length > 0 && !isStacked"
            [lockedWidth]="lockedWidth + scrollbarWidth + 3">
            <table
              role="presentation"
              class="k-grid-footer-table"
              [style.width.px]="nonLockedWidth"
              kendoGridTable
              kendoGridResizableTable
              [size]="size">
              @if (!isStacked) {
                <colgroup kendoGridColGroup
                  [columns]="$any(headerLeafColumns)"
                  [groups]="isLocked ? [] : group"
                  [detailTemplate]="detailTemplate">
              </colgroup>
            }
            <tfoot kendoGridFooter
              [logicalRowIndex]="ariaRowCount"
              [scrollable]="true"
              [groups]="isLocked ? [] : group"
              [columns]="$any(headerColumns)"
              [lockedColumnsCount]="isStacked ? 0 : lockedLeafColumns.length"
              [detailTemplate]="detailTemplate"
              [totalColumns]="columnsContainer"
              [totalColumnsCount]="leafColumns.length">
            </tfoot>
          </table>
        </div>
        </div>
        }
        }
        @if (!isScrollable) {
          <table
            [style.table-layout]="resizable ? 'fixed' : null"
            kendoGridTable
            kendoGridResizableTable
            class="k-grid-table"
            role="presentation"
            [size]="size">
            <colgroup kendoGridColGroup
              [columns]="$any(leafColumns)"
              [groups]="group"
              [sort]="sort"
              [detailTemplate]="detailTemplate">
          </colgroup>
          @if (!hideHeader && !isStacked) {
            <thead kendoGridHeader
              class="k-grid-header"
              [class.k-grid-draggable-header]="groupable || reorderable"
              role="rowgroup"
              [resizable]="resizable"
              [scrollable]="false"
              [columns]="$any(visibleColumns)"
              [totalColumnLevels]="totalColumnLevels"
              [totalColumns]="columnsContainer"
              [groups]="group"
              [groupable]="showGroupPanel"
              [reorderable]="reorderable"
              [sort]="sort"
              [sortable]="sortable"
              [filter]="filter"
              [filterable]="filterable"
              [columnMenu]="columnMenuOptions"
              [columnMenuTemplate]="columnMenuTemplate"
              [detailTemplate]="detailTemplate"
              [tabIndex]="navigation.tableEnabled ? '-1' : '0'">
            </thead>
          }
          <tbody kendoGridTableBody
            [isLoading]="loading"
            [rowHeight]="rowHeight"
            [detailRowHeight]="detailRowHeight"
            [groups]="group"
            [rowsToRender]="rowsToRender"
            [skip]="skip"
            [columns]="$any(leafColumns)"
            [totalColumnsCount]="leafColumns.length"
            [totalColumns]="columnsContainer"
            [selectable]="selectable"
            [filterable]="filterable"
            [noRecordsTemplate]="noRecordsTemplate"
            [detailTemplate]="detailTemplate"
            [trackBy]="trackBy"
            [rowClass]="rowClass"
            kendoDraggable
            kendoGridSelectionMarquee
            [enableDrag]="marqueeSelection">
          </tbody>
          @if (showFooter) {
            <tfoot kendoGridFooter
              [scrollable]="false"
              [logicalRowIndex]="ariaRowCount"
              [groups]="group"
              [columns]="$any(leafColumns)"
              [detailTemplate]="detailTemplate"
              [totalColumns]="columnsContainer"
              [totalColumnsCount]="leafColumns.length">
            </tfoot>
          }
        </table>
        }
        @if (loading) {
          <div [loadingTemplate]="loadingTemplate" kendoGridLoading></div>
        }
        </div>
        @if (showStatusBar) {
          <kendo-grid-status-bar
            [statusBarTemplate]="statusBarTemplate">
          </kendo-grid-status-bar>
        }
        @if (showBottomPager) {
          <kendo-pager
            #bottomPager
            class="k-grid-pager"
            [navigable]="navigation.pagerEnabled"
            [pageSize]="pageSize"
            [total]="view.total"
            [skip]="skip"
            [size]="size"
            [responsive]="normalizedPageableSettings.responsive && !pagerTemplate"
            [buttonCount]="normalizedPageableSettings.buttonCount"
            [info]="normalizedPageableSettings.info"
            [pageSizeValues]="normalizedPageableSettings.pageSizes"
            [previousNext]="normalizedPageableSettings.previousNext"
            [type]="normalizedPageableSettings.type"
            (pageChange)="notifyPageChange('pager', $event)"
            (pagerInputVisibilityChange)="handlePagerVisibilityChange('showPagerInput', $event)"
            (pageTextVisibilityChange)="handlePagerVisibilityChange('showPagerPageText', $event)"
            (itemsTextVisibilityChange)="handlePagerVisibilityChange('showPagerItemsText', $event)">
            <ng-template kendoPagerTemplate>
              <ng-container
                [ngTemplateOutlet]="pagerTemplate ? pagerTemplate?.templateRef : defaultPager"
              [ngTemplateOutletContext]="bottomPager.templateContext"></ng-container>
            </ng-template>
            <kendo-pager-messages
              [ariaLabel]="messageFor('pagerLabel')"
              [firstPage]="messageFor('pagerFirstPage')"
              [inputLabel]="messageFor('pagerInputLabel')"
              [previousPage]="messageFor('pagerPreviousPage')"
              [nextPage]="messageFor('pagerNextPage')"
              [lastPage]="messageFor('pagerLastPage')"
              [selectPage]="messageFor('pagerSelectPage')"
              [page]="messageFor('pagerPage')"
              [itemsPerPage]="messageFor('pagerItemsPerPage')"
              [items]="messageFor('pagerItems')"
              [of]="messageFor('pagerOf')"
              [pageNumberInputTitle]="messageFor('pagerPageNumberInputTitle')">
            </kendo-pager-messages>
          </kendo-pager>
        }
        @if (showBottomToolbar) {
          <kendo-grid-toolbar
            class="k-grid-toolbar-bottom"
            [size]="size"
            [navigable]="navigation.toolbarEnabled"
            [attr.aria-label]="messageFor('bottomToolbarLabel')"
            [attr.aria-controls]="ariaRootId"
            position="bottom">
          </kendo-grid-toolbar>
        }

        <ng-template #defaultHint>
          <kendo-icon-wrapper
            [name]="getHintSettings('hintIcon')"
            [svgIcon]="getHintSettings('hintSVGIcon')"
            innerCssClass="k-drag-status">
          </kendo-icon-wrapper>
          {{hintText}}
        </ng-template>

        <ng-template #defaultPager>
          <div class="k-pager-numbers-wrap">
            @if (normalizedPageableSettings.previousNext) {
              <kendo-pager-prev-buttons [size]="size"></kendo-pager-prev-buttons>
            }
            @if (normalizedPageableSettings.type === 'numeric' && normalizedPageableSettings.buttonCount > 0) {
              <kendo-pager-numeric-buttons
                [size]="size"
                [buttonCount]="normalizedPageableSettings.buttonCount">
              </kendo-pager-numeric-buttons>
            }
            @if (normalizedPageableSettings.type === 'input' || showPagerInput) {
              <kendo-pager-input [size]="size" [showPageText]="showPagerPageText"></kendo-pager-input>
            }
            @if (normalizedPageableSettings.previousNext) {
              <kendo-pager-next-buttons [size]="size"></kendo-pager-next-buttons>
            }
          </div>
          @if (normalizedPageableSettings.pageSizes) {
            <kendo-pager-page-sizes
              [size]="size"
              [pageSizes]="normalizedPageableSettings.pageSizes"
              [showItemsText]="showPagerItemsText">
            </kendo-pager-page-sizes>
          }
          @if (normalizedPageableSettings.info) {
            <kendo-pager-info>
            </kendo-pager-info>
          }
        </ng-template>
        <div #dialogContainer></div>
        <div #windowContainer></div>

        @if (isAdaptiveModeEnabled) {
          <kendo-grid-adaptive-renderer></kendo-grid-adaptive-renderer>
        }
        @if (isVirtual) {
          <kendo-resize-sensor (resize)="onResize()"></kendo-resize-sensor>
        }

        @if (showLicenseWatermark) {
          <div kendoWatermarkOverlay [licenseMessage]="licenseMessage"></div>
        }
        `,
      standalone: true,
      imports: [LocalizedMessagesDirective7, ToolbarComponent, GroupPanelComponent, TableDirective, GridTableDirective, ColGroupComponent, HeaderComponent2, ResizableContainerDirective, ListComponent2, DragTargetContainerDirective, DropTargetContainerDirective, DraggableDirective, GridMarqueeDirective, FooterComponent2, TableBodyComponent, LoadingComponent, StatusBarComponent, IconWrapperComponent, WatermarkOverlayComponent, ...KENDO_PAGER, NgTemplateOutlet, AdaptiveRendererComponent, ResizeSensorComponent]
    }]
  }], () => [{
    type: BrowserSupportService
  }, {
    type: SelectionService2
  }, {
    type: CellSelectionService
  }, {
    type: ElementRef
  }, {
    type: GroupInfoService
  }, {
    type: GroupsService
  }, {
    type: ChangeNotificationService
  }, {
    type: DetailsService
  }, {
    type: EditService
  }, {
    type: FilterService
  }, {
    type: PDFService
  }, {
    type: ResponsiveService
  }, {
    type: Renderer2
  }, {
    type: ExcelService
  }, {
    type: NgZone
  }, {
    type: ScrollSyncService2
  }, {
    type: DomEventsService
  }, {
    type: ColumnResizingService
  }, {
    type: ChangeDetectorRef
  }, {
    type: ColumnReorderService
  }, {
    type: ColumnInfoService
  }, {
    type: NavigationService4
  }, {
    type: SortService
  }, {
    type: ScrollRequestService
  }, {
    type: LocalizationService
  }, {
    type: ContextService
  }, {
    type: SizingOptionsService
  }, {
    type: AdaptiveGridService
  }, {
    type: RowReorderService
  }, {
    type: DataMappingService
  }, {
    type: GridAIRequestResponseService
  }, {
    type: IdService
  }], {
    data: [{
      type: Input
    }],
    pageSize: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    rowHeight: [{
      type: Input
    }],
    adaptiveMode: [{
      type: Input
    }],
    detailRowHeight: [{
      type: Input
    }],
    skip: [{
      type: Input
    }],
    scrollable: [{
      type: Input
    }],
    selectable: [{
      type: Input
    }],
    sort: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    trackBy: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    group: [{
      type: Input
    }],
    virtualColumns: [{
      type: Input
    }],
    filterable: [{
      type: Input
    }],
    sortable: [{
      type: Input
    }],
    pageable: [{
      type: Input
    }],
    groupable: [{
      type: Input
    }],
    gridResizable: [{
      type: Input
    }],
    rowReorderable: [{
      type: Input
    }],
    navigable: [{
      type: Input
    }],
    autoSize: [{
      type: Input
    }],
    rowClass: [{
      type: Input
    }],
    rowSticky: [{
      type: Input
    }],
    rowSelected: [{
      type: Input
    }],
    isRowSelectable: [{
      type: Input
    }],
    cellSelected: [{
      type: Input
    }],
    resizable: [{
      type: Input
    }],
    reorderable: [{
      type: Input
    }],
    loading: [{
      type: Input
    }],
    columnMenu: [{
      type: Input
    }],
    hideHeader: [{
      type: Input
    }],
    showInactiveTools: [{
      type: Input
    }],
    isDetailExpanded: [{
      type: Input
    }],
    isGroupExpanded: [{
      type: Input
    }],
    dataLayoutMode: [{
      type: Input
    }],
    filterChange: [{
      type: Output
    }],
    pageChange: [{
      type: Output
    }],
    groupChange: [{
      type: Output
    }],
    sortChange: [{
      type: Output
    }],
    selectionChange: [{
      type: Output
    }],
    rowReorder: [{
      type: Output
    }],
    dataStateChange: [{
      type: Output
    }],
    gridStateChange: [{
      type: Output
    }],
    groupExpand: [{
      type: Output
    }],
    groupCollapse: [{
      type: Output
    }],
    detailExpand: [{
      type: Output
    }],
    detailCollapse: [{
      type: Output
    }],
    edit: [{
      type: Output
    }],
    cancel: [{
      type: Output
    }],
    save: [{
      type: Output
    }],
    remove: [{
      type: Output
    }],
    add: [{
      type: Output
    }],
    cellClose: [{
      type: Output
    }],
    cellClick: [{
      type: Output
    }],
    pdfExport: [{
      type: Output
    }],
    excelExport: [{
      type: Output
    }],
    columnResize: [{
      type: Output
    }],
    columnReorder: [{
      type: Output
    }],
    columnVisibilityChange: [{
      type: Output
    }],
    columnLockedChange: [{
      type: Output
    }],
    columnStickyChange: [{
      type: Output
    }],
    scrollBottom: [{
      type: Output
    }],
    contentScroll: [{
      type: Output
    }],
    columns: [{
      type: ContentChildren,
      args: [ColumnBase2]
    }],
    dir: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    hostClass: [{
      type: HostBinding,
      args: ["class.k-grid"]
    }],
    sizeSmallClass: [{
      type: HostBinding,
      args: ["class.k-grid-sm"]
    }],
    sizeMediumClass: [{
      type: HostBinding,
      args: ["class.k-grid-md"]
    }],
    stackedClass: [{
      type: HostBinding,
      args: ["class.k-grid-stack"]
    }],
    lockedClasses: [{
      type: HostBinding,
      args: ["class.k-grid-lockedcolumns"]
    }],
    virtualClasses: [{
      type: HostBinding,
      args: ["class.k-grid-virtual"]
    }],
    noScrollbarClass: [{
      type: HostBinding,
      args: ["class.k-grid-no-scrollbar"]
    }],
    isResizable: [{
      type: HostBinding,
      args: ["class.k-grid-resizable"]
    }],
    minWidth: [{
      type: HostBinding,
      args: ["style.minWidth"]
    }],
    maxWidth: [{
      type: HostBinding,
      args: ["style.maxWidth"]
    }],
    minHeight: [{
      type: HostBinding,
      args: ["style.minHeight"]
    }],
    maxHeight: [{
      type: HostBinding,
      args: ["style.maxHeight"]
    }],
    detailTemplateChildren: [{
      type: ContentChildren,
      args: [DetailTemplateDirective]
    }],
    cellLoadingTemplateChildren: [{
      type: ContentChildren,
      args: [CellLoadingTemplateDirective]
    }],
    loadingTemplateChildren: [{
      type: ContentChildren,
      args: [LoadingTemplateDirective]
    }],
    statusBarTemplateChildren: [{
      type: ContentChildren,
      args: [StatusBarTemplateDirective]
    }],
    noRecordsTemplateChildren: [{
      type: ContentChildren,
      args: [NoRecordsTemplateDirective]
    }],
    pagerTemplateChildren: [{
      type: ContentChildren,
      args: [PagerTemplateDirective]
    }],
    toolbarTemplateChildren: [{
      type: ContentChildren,
      args: [ToolbarTemplateDirective]
    }],
    columnMenuTemplates: [{
      type: ContentChildren,
      args: [ColumnMenuTemplateDirective]
    }],
    lockedHeader: [{
      type: ViewChild,
      args: ["lockedHeader"]
    }],
    header: [{
      type: ViewChild,
      args: ["header"]
    }],
    footer: [{
      type: ViewChildren,
      args: ["footer"]
    }],
    ariaRoot: [{
      type: ViewChild,
      args: ["ariaRoot", {
        static: true
      }]
    }],
    dragTargetContainer: [{
      type: ViewChild,
      args: [DragTargetContainerDirective]
    }],
    dropTargetContainer: [{
      type: ViewChild,
      args: [DropTargetContainerDirective]
    }],
    dialogContainer: [{
      type: ViewChild,
      args: ["dialogContainer", {
        read: ViewContainerRef
      }]
    }],
    windowContainer: [{
      type: ViewChild,
      args: ["windowContainer", {
        read: ViewContainerRef
      }]
    }],
    adaptiveRenderer: [{
      type: ViewChild,
      args: [AdaptiveRendererComponent]
    }],
    listComponent: [{
      type: ViewChild,
      args: [ListComponent2]
    }]
  });
})();
var CustomMessagesComponent5 = class _CustomMessagesComponent extends GridMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function CustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _CustomMessagesComponent,
    selectors: [["kendo-grid-messages"]],
    features: [ɵɵProvidersFeature([{
      provide: GridMessages,
      useExisting: forwardRef(() => _CustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function CustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CustomMessagesComponent5, [{
    type: Component,
    args: [{
      providers: [{
        provide: GridMessages,
        useExisting: forwardRef(() => CustomMessagesComponent5)
      }],
      selector: "kendo-grid-messages",
      template: ``,
      standalone: true
    }]
  }], () => [{
    type: LocalizationService
  }], null);
})();
var DataBindingDirective = class _DataBindingDirective {
  grid;
  changeDetector;
  localDataChangesService;
  rowReorderService;
  /**
   * Sets the number of records to skip in the Grid.
   *
   * @default 0
   */
  set skip(value2) {
    if (!isPresent7(value2)) {
      value2 = 0;
    }
    this.grid.skip = this.state.skip = value2;
    if (this.rowReorderService) {
      this.rowReorderService.skip = value2;
    }
  }
  /**
   * Sets the sort descriptors for the Grid data.
   *
   */
  set sort(value2) {
    this.grid.sort = this.state.sort = value2;
  }
  /**
   * Sets the filter descriptor for the Grid data.
   *
   */
  set filter(value2) {
    this.grid.filter = this.state.filter = value2;
  }
  /**
   * Sets the page size for the Grid pager.
   *
   */
  set pageSize(value2) {
    this.grid.pageSize = this.state.take = value2;
  }
  /**
   * Sets the group descriptors for the Grid data.
   *
   */
  set group(value2) {
    this.grid.group = this.state.group = value2;
  }
  /**
   * Sets the data array for the Grid.
   *
   */
  set data(value2) {
    this.originalData = value2 || [];
    if (this.localDataChangesService) {
      this.localDataChangesService.data = value2;
    }
    this.dataChanged = true;
  }
  state = {
    skip: 0
  };
  originalData = [];
  dataChanged;
  stateChangeSubscription;
  dataChangedSubscription;
  rowReorderSubscription;
  constructor(grid, changeDetector, localDataChangesService, rowReorderService, ctx) {
    this.grid = grid;
    this.changeDetector = changeDetector;
    this.localDataChangesService = localDataChangesService;
    this.rowReorderService = rowReorderService;
    if (localDataChangesService) {
      this.dataChangedSubscription = this.localDataChangesService.changes.subscribe(this.rebind.bind(this));
    }
    ctx && (ctx.dataBindingDirective = this);
  }
  /**
   * @hidden
   */
  ngOnInit() {
    this.applyState(this.state);
    this.stateChangeSubscription = this.grid.dataStateChange.subscribe(this.onStateChange.bind(this));
    if (this.rowReorderService) {
      this.rowReorderSubscription = this.grid.rowReorder.subscribe(this.onRowReorder.bind(this));
    }
  }
  /**
   * @hidden
   */
  ngOnDestroy() {
    if (this.stateChangeSubscription) {
      this.stateChangeSubscription.unsubscribe();
    }
    if (this.dataChangedSubscription) {
      this.dataChangedSubscription.unsubscribe();
    }
    if (this.rowReorderSubscription) {
      this.rowReorderSubscription.unsubscribe();
    }
  }
  ngOnChanges(changes) {
    if (anyChanged(["pageSize", "skip", "sort", "group", "filter"], changes)) {
      this.rebind();
    }
  }
  ngDoCheck() {
    if (this.dataChanged) {
      this.updateGridData();
    }
  }
  /**
   * @hidden
   */
  onStateChange(state2) {
    this.applyState(state2);
    this.rebind();
  }
  /**
   * @hidden
   */
  onRowReorder(ev) {
    this.rowReorderService.reorderRows(ev, this.originalData);
    this.rebind();
  }
  /**
   * @hidden
   */
  rebind() {
    this.data = this.originalData;
    this.updateGridData();
    this.notifyDataChange();
  }
  /**
   * Notifies the Grid that its data has changed.
   */
  notifyDataChange() {
    this.grid.onDataChange();
    if (this.changeDetector) {
      this.changeDetector.markForCheck();
    }
  }
  process(state2) {
    if (this.grid.isVirtual && (!isPresent7(state2.take) || state2.take === 0) && !state2.group?.length) {
      return {
        data: [],
        total: this.originalData?.length || 0
      };
    }
    return process(this.originalData, state2);
  }
  applyState({
    skip: skip4,
    take: take4,
    sort: sort2,
    group: group2,
    filter: filter3
  }) {
    this.skip = skip4;
    this.pageSize = take4;
    this.sort = sort2;
    this.group = group2;
    this.filter = filter3;
  }
  updateGridData() {
    if (this.grid.isVirtual && !this.grid.pageable) {
      if (this.state.group?.length) {
        this.state.take = void 0;
      } else if (!isPresent7(this.state.take) && isPresent7(this.grid.pageSize)) {
        this.state.take = this.grid.pageSize;
      }
    }
    this.grid.data = this.process(this.state);
    this.grid.updateNavigationMetadata();
    this.grid.ngDoCheck();
    this.dataChanged = false;
  }
  static ɵfac = function DataBindingDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DataBindingDirective)(ɵɵdirectiveInject(GridComponent), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(LocalDataChangesService), ɵɵdirectiveInject(RowReorderService), ɵɵdirectiveInject(ContextService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DataBindingDirective,
    selectors: [["", "kendoGridBinding", ""]],
    inputs: {
      skip: "skip",
      sort: "sort",
      filter: "filter",
      pageSize: "pageSize",
      group: "group",
      data: [0, "kendoGridBinding", "data"]
    },
    exportAs: ["kendoGridBinding"],
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DataBindingDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridBinding]",
      exportAs: "kendoGridBinding",
      standalone: true
    }]
  }], () => [{
    type: GridComponent
  }, {
    type: ChangeDetectorRef
  }, {
    type: LocalDataChangesService
  }, {
    type: RowReorderService
  }, {
    type: ContextService
  }], {
    skip: [{
      type: Input
    }],
    sort: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    pageSize: [{
      type: Input
    }],
    group: [{
      type: Input
    }],
    data: [{
      type: Input,
      args: ["kendoGridBinding"]
    }]
  });
})();
var SelectionDirective = class _SelectionDirective extends Selection {
  ctx;
  constructor(ctx, cd) {
    super(ctx, cd);
    this.ctx = ctx;
  }
  /**
   * @hidden
   */
  ngOnInit() {
    if (this.ctx.grid.selectable === false) {
      this.ctx.grid.selectable = true;
    }
    this.ctx.grid.selectionDirective = this;
  }
  /**
   * @hidden
   */
  ngOnDestroy() {
    super.destroy();
  }
  static ɵfac = function SelectionDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SelectionDirective)(ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _SelectionDirective,
    selectors: [["", "kendoGridSelectBy", ""]],
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectionDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridSelectBy]",
      standalone: true
    }]
  }], () => [{
    type: ContextService
  }, {
    type: ChangeDetectorRef
  }], null);
})();
var LocalEditService = class {
  grid;
  localDataChangesService;
  constructor(grid, localDataChangesService) {
    this.grid = grid;
    this.localDataChangesService = localDataChangesService;
  }
  create(item) {
    if (this.hasLocalData && this.grid.skip) {
      this.localDataChangesService.data.splice(this.grid.skip, 0, item);
    } else {
      this.data.unshift(item);
    }
    this.dataChanged();
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  update(_item) {
  }
  remove(item) {
    const data = this.data;
    for (let idx4 = 0; idx4 < data.length; idx4++) {
      if (item === data[idx4]) {
        data.splice(idx4, 1);
        this.dataChanged({
          action: "remove",
          item
        });
        break;
      }
    }
  }
  assignValues(target, source) {
    Object.assign(target, source);
  }
  dataChanged(args = {}) {
    if (this.hasLocalData) {
      this.localDataChangesService.changes.emit(args);
    }
  }
  get hasLocalData() {
    return Array.isArray(this.localDataChangesService.data);
  }
  get data() {
    if (this.hasLocalData) {
      return this.localDataChangesService.data;
    }
    const data = this.grid.data;
    if (Array.isArray(data)) {
      return data;
    }
    if (isDevMode()) {
      throw new Error(GridConfigurationErrorMessages.requiredEditService);
    }
    return [];
  }
};
var EditingDirectiveBase = class _EditingDirectiveBase {
  grid;
  localDataChangesService;
  // Consider adding support for the dependency injection of the service to allow for specifying a generic service without code.
  // The Input should still be kept.
  /**
   * The edit service that will handle the operations.
   */
  set editService(value2) {
    this.userEditService = value2;
  }
  get editService() {
    return this.userEditService || this.defaultEditService;
  }
  removeConfirmationSubject = new Subject();
  dialogService;
  localization;
  defaultRemoveConfirmation = (_item) => {
    const dialog = this.dialogService.open({
      appendTo: this.grid.dialogContainer,
      title: this.localization.get("removeConfirmationDialogTitle"),
      content: this.localization.get("removeConfirmationDialogContent"),
      actions: [{
        text: this.localization.get("removeConfirmationDialogConfirmText"),
        themeColor: "primary",
        svgIcon: checkIcon,
        icon: "check"
      }, {
        text: this.localization.get("removeConfirmationDialogRejectText"),
        svgIcon: xIcon,
        icon: "x"
      }]
    });
    dialog.result.pipe(take(1)).subscribe((e) => this.removeConfirmationSubject.next(e.text === this.localization.get("removeConfirmationDialogConfirmText")));
    return this.removeConfirmationSubject;
  };
  /**
   * A function that is called to confirm if the `dataItem` will be removed.
   * By default, the Grid displays its built-in confirmation dialog. To use a custom dialog, provide a `RemoveConfirmationCallback` function.
   * To prevent showing a confirmation dialog, set the `removeConfirmation` property to `false`.
   *
   * @default true
   */
  removeConfirmation = true;
  subscriptions = new Subscription();
  defaultEditService;
  userEditService;
  navigationService;
  constructor(grid, localDataChangesService) {
    this.grid = grid;
    this.localDataChangesService = localDataChangesService;
    this.defaultEditService = this.createDefaultService();
    this.dialogService = inject(DialogService);
    this.localization = inject(LocalizationService);
    this.navigationService = inject(NavigationService4);
  }
  /**
   * @hidden
   */
  ngOnInit() {
    this.subscriptions.add(this.grid.add.subscribe(this.addHandler.bind(this)));
    this.subscriptions.add(this.grid.remove.subscribe(this.removeHandler.bind(this)));
    this.subscriptions.add(this.grid.cancel.subscribe(this.cancelHandler.bind(this)));
    this.subscriptions.add(this.grid.save.subscribe(this.saveHandler.bind(this)));
    this.subscriptions.add(this.grid.dataStateChange.subscribe(this.onStateChange.bind(this)));
  }
  /**
   * @hidden
   */
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  createDefaultService() {
    return new LocalEditService(this.grid, this.localDataChangesService);
  }
  addHandler(_args) {
    this.grid.addRow(this.createModel({
      isNew: true
    }));
  }
  saveHandler(args) {
    const item = this.saveModel(args);
    if (item) {
      if (args.isNew) {
        this.editService.create(item);
      } else {
        this.editService.update(item);
      }
    }
    this.grid.closeRow(args.rowIndex);
  }
  cancelHandler({
    rowIndex
  }) {
    this.closeEditor(rowIndex);
  }
  removeHandler({
    dataItem
  }) {
    const removeItem = (shouldRemove) => {
      if (shouldRemove) {
        this.editService.remove(dataItem);
      }
    };
    if (this.removeConfirmation) {
      const confirmationCallback = typeof this.removeConfirmation === "boolean" ? this.defaultRemoveConfirmation : this.removeConfirmation;
      const result = confirmationCallback(dataItem);
      if (result instanceof Promise) {
        result.then((res) => {
          removeItem(res);
          this.returnFocusToGrid();
        });
      } else if (result instanceof Observable) {
        result.pipe(take(1)).subscribe((res) => {
          removeItem(res);
          this.returnFocusToGrid();
        });
      } else {
        removeItem(result);
        this.returnFocusToGrid();
      }
    } else {
      removeItem(true);
    }
  }
  onStateChange() {
    this.closeEditor();
  }
  closeEditor(rowIndex) {
    this.grid.closeRow(rowIndex);
  }
  returnFocusToGrid() {
    if (!this.navigationService.focusCell()) {
      this.navigationService.focusPrevCell() || this.navigationService.focusNextCell();
    }
  }
  static ɵfac = function EditingDirectiveBase_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _EditingDirectiveBase)(ɵɵdirectiveInject(GridComponent), ɵɵdirectiveInject(LocalDataChangesService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _EditingDirectiveBase,
    selectors: [["", "kendoGridEditingDirectiveBase", ""]],
    inputs: {
      editService: "editService",
      removeConfirmation: "removeConfirmation"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EditingDirectiveBase, [{
    type: Directive,
    args: [{
      selector: "[kendoGridEditingDirectiveBase]"
    }]
  }], () => [{
    type: GridComponent
  }, {
    type: LocalDataChangesService
  }], {
    editService: [{
      type: Input
    }],
    removeConfirmation: [{
      type: Input
    }]
  });
})();
var LocalRowEditService = class extends LocalEditService {
  update() {
    this.dataChanged();
  }
};
var RowEditingDirectiveBase = class _RowEditingDirectiveBase extends EditingDirectiveBase {
  rowIndex;
  /**
   * @hidden
   */
  ngOnInit() {
    super.ngOnInit();
    this.subscriptions.add(this.grid.edit.subscribe(this.editHandler.bind(this)));
  }
  createDefaultService() {
    return new LocalRowEditService(this.grid, this.localDataChangesService);
  }
  addHandler() {
    this.closeEditor();
    super.addHandler();
  }
  editHandler(args) {
    this.closeEditor();
    this.rowIndex = args.rowIndex;
    this.grid.editRow(args.rowIndex, this.createModel(args));
  }
  saveHandler(args) {
    super.saveHandler(args);
    this.clean();
  }
  closeEditor(rowIndex = this.rowIndex) {
    super.closeEditor(rowIndex);
    this.clean();
  }
  clean() {
    delete this.rowIndex;
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵRowEditingDirectiveBase_BaseFactory;
    return function RowEditingDirectiveBase_Factory(__ngFactoryType__) {
      return (ɵRowEditingDirectiveBase_BaseFactory || (ɵRowEditingDirectiveBase_BaseFactory = ɵɵgetInheritedFactory(_RowEditingDirectiveBase)))(__ngFactoryType__ || _RowEditingDirectiveBase);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _RowEditingDirectiveBase,
    selectors: [["", "kendoGridRowEditingDirectiveBase", ""]],
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RowEditingDirectiveBase, [{
    type: Directive,
    args: [{
      selector: "[kendoGridRowEditingDirectiveBase]"
    }]
  }], null, null);
})();
var TemplateEditingDirective = class _TemplateEditingDirective extends RowEditingDirectiveBase {
  grid;
  localDataChangesService;
  /**
   * Specifies the function that creates the `dataItem` for new rows.
   */
  createNewItem;
  dataItem;
  originalValues;
  constructor(grid, localDataChangesService) {
    super(grid, localDataChangesService);
    this.grid = grid;
    this.localDataChangesService = localDataChangesService;
  }
  editHandler(args) {
    super.editHandler(args);
    this.dataItem = args.dataItem;
    this.originalValues = {};
    this.editService.assignValues(this.originalValues, this.dataItem);
  }
  closeEditor(rowIndex) {
    if (this.dataItem) {
      this.editService.assignValues(this.dataItem, this.originalValues);
    }
    super.closeEditor(rowIndex);
  }
  createModel(args) {
    if (args.isNew) {
      return this.createNewItem();
    }
  }
  saveModel(args) {
    return args.dataItem;
  }
  clean() {
    super.clean();
    delete this.dataItem;
  }
  static ɵfac = function TemplateEditingDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TemplateEditingDirective)(ɵɵdirectiveInject(GridComponent), ɵɵdirectiveInject(LocalDataChangesService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _TemplateEditingDirective,
    selectors: [["", "kendoGridTemplateEditing", ""]],
    inputs: {
      createNewItem: [0, "kendoGridTemplateEditing", "createNewItem"]
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TemplateEditingDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridTemplateEditing]",
      standalone: true
    }]
  }], () => [{
    type: GridComponent
  }, {
    type: LocalDataChangesService
  }], {
    createNewItem: [{
      type: Input,
      args: ["kendoGridTemplateEditing"]
    }]
  });
})();
var markAllAsTouched = (control) => {
  control.markAsTouched();
  if (control.hasOwnProperty("controls")) {
    const controls = control.controls;
    for (const inner in controls) {
      if (controls.hasOwnProperty(inner)) {
        markAllAsTouched(controls[inner]);
      }
    }
  }
};
var ReactiveEditingDirective = class _ReactiveEditingDirective extends RowEditingDirectiveBase {
  grid;
  localDataChangesService;
  /**
   * Specifies the function that creates the `FormGroup` for the edited model.
   */
  createFormGroup;
  constructor(grid, localDataChangesService) {
    super(grid, localDataChangesService);
    this.grid = grid;
    this.localDataChangesService = localDataChangesService;
  }
  createModel(args) {
    return this.createFormGroup(args);
  }
  saveModel({
    dataItem,
    formGroup,
    isNew
  }) {
    if (!formGroup.dirty && !isNew) {
      return;
    }
    if (formGroup.valid) {
      this.editService.assignValues(dataItem, formGroup.value);
      return dataItem;
    }
    markAllAsTouched(formGroup);
  }
  static ɵfac = function ReactiveEditingDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ReactiveEditingDirective)(ɵɵdirectiveInject(GridComponent), ɵɵdirectiveInject(LocalDataChangesService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ReactiveEditingDirective,
    selectors: [["", "kendoGridReactiveEditing", ""]],
    inputs: {
      createFormGroup: [0, "kendoGridReactiveEditing", "createFormGroup"]
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ReactiveEditingDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridReactiveEditing]",
      standalone: true
    }]
  }], () => [{
    type: GridComponent
  }, {
    type: LocalDataChangesService
  }], {
    createFormGroup: [{
      type: Input,
      args: ["kendoGridReactiveEditing"]
    }]
  });
})();
var InCellEditingDirective = class _InCellEditingDirective extends EditingDirectiveBase {
  grid;
  localDataChangesService;
  cdr;
  /**
   * Specifies the function that creates the `FormGroup` for the edited model.
   */
  createFormGroup;
  constructor(grid, localDataChangesService, cdr) {
    super(grid, localDataChangesService);
    this.grid = grid;
    this.localDataChangesService = localDataChangesService;
    this.cdr = cdr;
  }
  // Need mixin
  createModel(args) {
    return this.createFormGroup(args);
  }
  saveModel({
    dataItem,
    formGroup,
    isNew
  }) {
    if (!formGroup.dirty && !isNew) {
      return;
    }
    if (formGroup.valid) {
      this.editService.assignValues(dataItem, formGroup.value);
      return dataItem;
    }
    markAllAsTouched(formGroup);
  }
  /**
   * @hidden
   */
  ngOnInit() {
    super.ngOnInit();
    this.subscriptions.add(this.grid.cellClick.subscribe(this.cellClickHandler.bind(this)));
    this.subscriptions.add(this.grid.cellClose.subscribe(this.cellCloseHandler.bind(this)));
  }
  removeHandler(args) {
    super.removeHandler(args);
    this.grid.cancelCell();
  }
  cellClickHandler(args) {
    if (!args.isEdited && args.type !== "contextmenu") {
      const colIndex = this.grid.isStacked ? args.column.leafIndex : args.columnIndex;
      this.grid.editCell(args.rowIndex, colIndex, this.createFormGroup(args));
      this.cdr.markForCheck();
    }
  }
  cellCloseHandler(args) {
    const {
      formGroup,
      dataItem
    } = args;
    if (!formGroup.valid) {
      args.preventDefault();
    } else if (formGroup.dirty) {
      if (args.originalEvent && args.originalEvent.code === Keys.Escape) {
        return;
      }
      this.editService.assignValues(dataItem, formGroup.value);
      this.editService.update(dataItem);
    }
    this.cdr.markForCheck();
  }
  static ɵfac = function InCellEditingDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _InCellEditingDirective)(ɵɵdirectiveInject(GridComponent), ɵɵdirectiveInject(LocalDataChangesService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _InCellEditingDirective,
    selectors: [["", "kendoGridInCellEditing", ""]],
    inputs: {
      createFormGroup: [0, "kendoGridInCellEditing", "createFormGroup"]
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InCellEditingDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridInCellEditing]",
      standalone: true
    }]
  }], () => [{
    type: GridComponent
  }, {
    type: LocalDataChangesService
  }, {
    type: ChangeDetectorRef
  }], {
    createFormGroup: [{
      type: Input,
      args: ["kendoGridInCellEditing"]
    }]
  });
})();
var ExternalEditingDirective = class _ExternalEditingDirective extends EditingDirectiveBase {
  grid;
  localDataChangesService;
  adaptiveGridService;
  /**
   * Specifies the function that creates the `FormGroup` for the edited model.
   */
  createFormGroup;
  /**
   * Customizes form orientation, hints, labels, and error messages.
   */
  formSettings;
  /**
   * Customizes the Dialog that contains the edit form.
   */
  dialogSettings;
  constructor(grid, localDataChangesService, adaptiveGridService) {
    super(grid, localDataChangesService);
    this.grid = grid;
    this.localDataChangesService = localDataChangesService;
    this.adaptiveGridService = adaptiveGridService;
  }
  ngOnInit() {
    super.ngOnInit();
    this.subscriptions.add(this.grid.edit.subscribe(this.editHandler.bind(this)));
  }
  /**
   * @hidden
   * Opens a Dialog that contains the edit form.
   */
  openEditFormDialog(editEventArgs, formGroup, formSettings) {
    const formControls = this.normalizeFormSettings(formGroup, editEventArgs);
    if (this.grid.adaptiveMode === "auto" && this.adaptiveGridService.windowSize !== "large") {
      if (!this.grid.isActionSheetExpanded) {
        this.adaptiveGridService.viewType = "externalEditing";
        this.grid.adaptiveRenderer.externalEditingSettings = {
          formControls,
          formGroup,
          formSettings,
          event: editEventArgs,
          externalEditingDirective: this
        };
        this.grid.adaptiveRenderer.actionSheet.toggle(true);
      }
    } else {
      const settings = __spreadValues({
        appendTo: this.grid.dialogContainer,
        content: DialogFormComponent,
        title: this.localization.get("externalEditingTitle")
      }, this.dialogSettings);
      const dialog = this.dialogService.open(settings);
      this.adaptiveGridService.popupRef = dialog;
      dialog.content.setInput("controls", formControls);
      formSettings && dialog.content.setInput("formSettings", formSettings);
      dialog.content.setInput("formGroup", formGroup);
      dialog.result.subscribe((r) => {
        const resultType = r["text"];
        if (resultType === this.localization.get("externalEditingSaveText")) {
          this.saveHandler(__spreadProps(__spreadValues({}, editEventArgs), {
            formGroup
          }));
        }
        dialog.close();
      });
    }
  }
  createModel(args) {
    return this.createFormGroup(args);
  }
  editHandler(args) {
    const formGroup = this.createModel(args);
    this.openEditFormDialog(args, formGroup, this.formSettings);
  }
  saveModel({
    dataItem,
    formGroup,
    isNew
  }) {
    if (!formGroup.dirty && !isNew) {
      return;
    }
    if (formGroup.valid) {
      const item = dataItem || [];
      this.editService.assignValues(item, formGroup.value);
      return item;
    }
    markAllAsTouched(formGroup);
  }
  addHandler(args) {
    const formGroup = this.createModel(args);
    this.openEditFormDialog(args, formGroup, this.formSettings);
  }
  normalizeFormSettings(args, editEventArgs) {
    const editableColumnFields = this.grid.columns.toArray().filter((c) => c.field && c.editable && isPresent(args.get(c.field))).map((c) => c.field);
    const settings = editableColumnFields.map((k) => {
      const column = this.grid.columns.toArray().find((c) => c.field === k);
      const title = column.title || k;
      const template = column.editTemplateRef;
      const templateContext = template ? {
        $implicit: args,
        isNew: editEventArgs.isNew,
        column,
        dataItem: editEventArgs.dataItem,
        formGroup: args,
        rowIndex: editEventArgs.rowIndex
      } : null;
      const customSettings = this.formSettings?.fields?.[k];
      return {
        name: k,
        label: customSettings?.label || title,
        hint: customSettings?.hint,
        errors: customSettings?.errors,
        formControl: args.get(k),
        dataType: column.editor,
        orientation: this.formSettings?.orientation || "vertical",
        template,
        templateContext
      };
    });
    return settings.filter((item) => isPresent(item));
  }
  static ɵfac = function ExternalEditingDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ExternalEditingDirective)(ɵɵdirectiveInject(GridComponent), ɵɵdirectiveInject(LocalDataChangesService), ɵɵdirectiveInject(AdaptiveGridService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ExternalEditingDirective,
    selectors: [["", "kendoGridExternalEditing", ""]],
    inputs: {
      createFormGroup: [0, "kendoGridExternalEditing", "createFormGroup"],
      formSettings: "formSettings",
      dialogSettings: "dialogSettings"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExternalEditingDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridExternalEditing]",
      standalone: true
    }]
  }], () => [{
    type: GridComponent
  }, {
    type: LocalDataChangesService
  }, {
    type: AdaptiveGridService
  }], {
    createFormGroup: [{
      type: Input,
      args: ["kendoGridExternalEditing"]
    }],
    formSettings: [{
      type: Input
    }],
    dialogSettings: [{
      type: Input
    }]
  });
})();
var ExpandDetailsDirective = class _ExpandDetailsDirective {
  grid;
  /**
   * Fires when the `expandedDetailKeys` collection changes.
   */
  expandedDetailKeysChange = new EventEmitter();
  /**
   * Sets the item key stored in the `expandedDetailKeys` collection.
   * Accepts a property name or a function that returns a unique key for each data item.
   * ([See example]({% slug master_detail_expanded_state_grid %}#toc-built-in-directive)).
   */
  get expandDetailsKey() {
    return this._expandBy;
  }
  set expandDetailsKey(key) {
    if (isString2(key)) {
      this._expandBy = getter(key);
    } else {
      this._expandBy = key;
    }
  }
  /**
   * @hidden
   * A deprecated alias for setting the `expandDetailsKey` property.
   */
  get expandDetailBy() {
    return this.expandDetailsKey;
  }
  set expandDetailBy(key) {
    this.expandDetailsKey = key;
  }
  /**
   * Holds the collection of expanded detail row keys.
   * Set this property to control which detail rows are expanded.
   */
  expandedDetailKeys = [];
  /**
   * Specifies if detail rows are expanded by default.
   * When set to `true`, items in the `expandedDetailKeys` collection are collapsed, and all others are expanded.
   * @default false
   */
  initiallyExpanded = false;
  expandedState = /* @__PURE__ */ new Set();
  lastExpandedState;
  _expandBy;
  subscriptions = new Subscription();
  constructor(grid) {
    this.grid = grid;
    this.grid.isDetailExpanded = this.isExpanded.bind(this);
    this.subscriptions.add(merge(this.grid.detailExpand.pipe(map((e) => __spreadValues({
      expand: true
    }, e))), this.grid.detailCollapse.pipe(map((e) => __spreadValues({
      expand: false
    }, e)))).subscribe(this.toggleState.bind(this)));
  }
  ngOnChanges(changes) {
    if (isPresent7(changes["expandedDetailKeys"]) && this.lastExpandedState !== this.expandedDetailKeys) {
      this.expandedState = new Set(this.expandedDetailKeys);
    }
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  get keyGetter() {
    return this._expandBy || getter(void 0);
  }
  /**
   * @hidden
   */
  isExpanded(args) {
    const key = this.keyGetter(args.dataItem);
    const hasKey = this.expandedState.has(key);
    return this.initiallyExpanded ? !hasKey : hasKey;
  }
  toggleState(args) {
    const key = this.keyGetter(args.dataItem);
    if (Boolean(this.initiallyExpanded) !== args.expand) {
      this.expandedState.add(key);
    } else {
      this.expandedState.delete(key);
    }
    this.notifyChange();
  }
  notifyChange() {
    this.lastExpandedState = Array.from(this.expandedState);
    this.expandedDetailKeysChange.emit(this.lastExpandedState);
  }
  static ɵfac = function ExpandDetailsDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ExpandDetailsDirective)(ɵɵdirectiveInject(GridComponent));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ExpandDetailsDirective,
    selectors: [["", "kendoGridExpandDetailsBy", ""]],
    inputs: {
      expandDetailsKey: [0, "kendoGridExpandDetailsBy", "expandDetailsKey"],
      expandDetailBy: "expandDetailBy",
      expandedDetailKeys: "expandedDetailKeys",
      initiallyExpanded: "initiallyExpanded"
    },
    outputs: {
      expandedDetailKeysChange: "expandedDetailKeysChange"
    },
    exportAs: ["kendoGridExpandDetailsBy"],
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExpandDetailsDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridExpandDetailsBy]",
      exportAs: "kendoGridExpandDetailsBy",
      standalone: true
    }]
  }], () => [{
    type: GridComponent
  }], {
    expandedDetailKeysChange: [{
      type: Output
    }],
    expandDetailsKey: [{
      type: Input,
      args: ["kendoGridExpandDetailsBy"]
    }],
    expandDetailBy: [{
      type: Input
    }],
    expandedDetailKeys: [{
      type: Input
    }],
    initiallyExpanded: [{
      type: Input
    }]
  });
})();
var mapParentGroup = (parentGroup) => {
  const parentGroupKeys = [];
  while (parentGroup) {
    parentGroupKeys.push({
      field: parentGroup.group.field,
      value: parentGroup.group.value
    });
    parentGroup = parentGroup.parentGroup;
  }
  return parentGroupKeys;
};
var DEFAULT_KEY_GETTER = (groupRowArgs) => ({
  field: groupRowArgs.group.field,
  value: groupRowArgs.group.value,
  parentGroupKeys: mapParentGroup(groupRowArgs.parentGroup)
});
var ExpandGroupDirective = class _ExpandGroupDirective {
  grid;
  /**
   * Fires when the `expandedGroupKeys` collection changes.
   */
  expandedGroupKeysChange = new EventEmitter();
  /**
   * Sets the item format stored in the `expandedGroupKeys` collection.
   * Accepts a property name or a function that returns a unique key for each group
   * ([see example]({% slug groups_expanded_state_grid %}#toc-custom-group-key-format)).
   */
  get expandGroupBy() {
    return this._expandGroupBy;
  }
  set expandGroupBy(key) {
    if (typeof key === "function") {
      this._expandGroupBy = key;
    }
  }
  /**
   * Holds the collection of expanded group keys.
   * Set this property to control which group rows are expanded.
   */
  get expandedGroupKeys() {
    return this._expandedGroupKeys;
  }
  set expandedGroupKeys(expandedGroups) {
    this._expandedGroupKeys = (expandedGroups || []).slice();
  }
  /**
   * Specifies if group items are expanded by default.
   * @default false
   */
  groupsInitiallyExpanded = false;
  _expandGroupBy;
  _expandedGroupKeys;
  subscriptions = new Subscription();
  constructor(grid) {
    this.grid = grid;
    this.grid.isGroupExpanded = this.isExpanded.bind(this);
    this.subscriptions.add(merge(this.grid.groupExpand.pipe(map((e) => __spreadValues({
      expand: true
    }, e))), this.grid.groupCollapse.pipe(map((e) => __spreadValues({
      expand: false
    }, e)))).subscribe(this.toggleState.bind(this)));
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  get keyGetter() {
    return this.expandGroupBy || DEFAULT_KEY_GETTER;
  }
  /**
   * @hidden
   */
  isExpanded(groupArgs) {
    const itemIndex2 = this.getItemIndex(groupArgs);
    return itemIndex2 > -1 ? !this.groupsInitiallyExpanded : this.groupsInitiallyExpanded;
  }
  getItemIndex(groupArgs) {
    if (this.expandGroupBy) {
      return this.expandedGroupKeys.indexOf(this.keyGetter(groupArgs));
    }
    return this.expandedGroupKeys.findIndex((item) => {
      let index = 0;
      let parentGroup = groupArgs.parentGroup;
      while (isPresent7(parentGroup)) {
        if (!isPresent7(item.parentGroupKeys) || !isPresent7(item.parentGroupKeys[index]) || parentGroup.group.value !== item.parentGroupKeys[index].value || parentGroup.group.field !== item.parentGroupKeys[index].field) {
          return false;
        }
        parentGroup = parentGroup.parentGroup;
        index++;
      }
      return item.value === groupArgs.group.value && item.field === groupArgs.group.field;
    });
  }
  toggleState(groupArgs) {
    const key = this.keyGetter(groupArgs);
    if (Boolean(this.groupsInitiallyExpanded) !== groupArgs.expand) {
      this.expandedGroupKeys.push(key);
    } else {
      const index = this.expandedGroupKeys.findIndex((group2) => {
        if (this.expandGroupBy) {
          return group2 === key;
        } else if (key.parentGroupKeys?.length === 0) {
          return group2.value === key.value;
        }
        return JSON.stringify(group2) === JSON.stringify(key);
      });
      this.expandedGroupKeys.splice(index, 1);
    }
    this.expandedGroupKeysChange.emit(this.expandedGroupKeys.slice());
  }
  static ɵfac = function ExpandGroupDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ExpandGroupDirective)(ɵɵdirectiveInject(GridComponent));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ExpandGroupDirective,
    selectors: [["", "kendoGridExpandGroupBy", ""]],
    inputs: {
      expandGroupBy: [0, "kendoGridExpandGroupBy", "expandGroupBy"],
      expandedGroupKeys: "expandedGroupKeys",
      groupsInitiallyExpanded: "groupsInitiallyExpanded"
    },
    outputs: {
      expandedGroupKeysChange: "expandedGroupKeysChange"
    },
    exportAs: ["kendoGridExpandGroupBy"]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExpandGroupDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridExpandGroupBy]",
      exportAs: "kendoGridExpandGroupBy",
      standalone: true
    }]
  }], () => [{
    type: GridComponent
  }], {
    expandedGroupKeysChange: [{
      type: Output
    }],
    expandGroupBy: [{
      type: Input,
      args: ["kendoGridExpandGroupBy"]
    }],
    expandedGroupKeys: [{
      type: Input
    }],
    groupsInitiallyExpanded: [{
      type: Input
    }]
  });
})();
var GridSpacerComponent = class _GridSpacerComponent {
  hostClass = true;
  get sizedClass() {
    return isPresent7(this.width);
  }
  get flexBasisStyle() {
    return this.width;
  }
  /**
   * Specifies the width of the GridSpacer.
   * Accepts string values for the [CSS `flex-basis`](https://developer.mozilla.org/en-US/docs/Web/CSS/flex-basis) property.
   * If not set, the GridSpacer takes all available space.
   */
  width;
  static ɵfac = function GridSpacerComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _GridSpacerComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _GridSpacerComponent,
    selectors: [["kendo-grid-spacer"]],
    hostVars: 6,
    hostBindings: function GridSpacerComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵstyleProp("flex-basis", ctx.flexBasisStyle);
        ɵɵclassProp("k-spacer", ctx.hostClass)("k-spacer-sized", ctx.sizedClass);
      }
    },
    inputs: {
      width: "width"
    },
    decls: 0,
    vars: 0,
    template: function GridSpacerComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GridSpacerComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-spacer",
      template: ``,
      standalone: true
    }]
  }], null, {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-spacer"]
    }],
    sizedClass: [{
      type: HostBinding,
      args: ["class.k-spacer-sized"]
    }],
    flexBasisStyle: [{
      type: HostBinding,
      args: ["style.flexBasis"]
    }],
    width: [{
      type: Input
    }]
  });
})();
var GridToolbarFocusableDirective = class _GridToolbarFocusableDirective {
  host;
  ctx;
  /**
   * @hidden
   */
  get element() {
    return this.host.nativeElement;
  }
  /**
   * @hidden
   */
  get toolbarPosition() {
    return isDocumentAvailable() && this.host.nativeElement.closest(".k-toolbar")?.getAttribute("position");
  }
  constructor(host, ctx) {
    this.host = host;
    this.ctx = ctx;
  }
  ngAfterViewInit() {
    if (!isDocumentAvailable() || !this.toolbarPosition || !this.isToolbarNavigable) {
      return;
    }
    this.ctx[`${this.toolbarPosition}ToolbarNavigation`]?.navigableElements.push(this.element);
    this.ctx[`${this.toolbarPosition}ToolbarNavigation`]?.notify();
  }
  ngOnDestroy() {
    if (!isDocumentAvailable() || !this.toolbarPosition) {
      return;
    }
    const elements = this.ctx[`${this.toolbarPosition}ToolbarNavigation`].navigableElements;
    this.ctx[`${this.toolbarPosition}ToolbarNavigation`].navigableElements = elements.filter((el) => el !== this.element);
    this.ctx[`${this.toolbarPosition}ToolbarNavigation`].notify();
  }
  get isToolbarNavigable() {
    if (typeof this.ctx.grid.navigable === "boolean") {
      return this.ctx.grid.navigable;
    }
    if (Array.isArray(this.ctx.grid.navigable)) {
      return this.ctx.grid.navigable.includes("toolbar");
    }
    return false;
  }
  static ɵfac = function GridToolbarFocusableDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _GridToolbarFocusableDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ContextService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _GridToolbarFocusableDirective,
    selectors: [["", "kendoGridToolbarFocusable", ""], ["", "kendoGridAddCommand", ""], ["", "kendoGridCancelCommand", ""], ["", "kendoGridEditCommand", ""], ["", "kendoGridRemoveCommand", ""], ["", "kendoGridSaveCommand", ""], ["", "kendoGridExcelCommand", ""], ["", "kendoGridPDFCommand", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GridToolbarFocusableDirective, [{
    type: Directive,
    args: [{
      selector: `
        [kendoGridToolbarFocusable],
        [kendoGridAddCommand],
        [kendoGridCancelCommand],
        [kendoGridEditCommand],
        [kendoGridRemoveCommand],
        [kendoGridSaveCommand],
        [kendoGridExcelCommand],
        [kendoGridPDFCommand]
    `,
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: ContextService
  }], null);
})();
var GridClipboardDirective = class _GridClipboardDirective {
  host;
  clipboardService;
  renderer;
  zone;
  /**
   * Sets the clipboard operation target. Possible values are `'activeCell'` and `'selection'`.([See example]({% slug clipboard_grid %}#toc-clipboard-target))
   *
   * @default 'selection'
   */
  set clipboardTarget(value2) {
    if (isDevMode()) {
      this.zone.onStable.pipe(take(1)).subscribe(() => {
        if (value2 === "activeCell" && !this.host.navigable.length) {
          console.warn(ClipboardErrorMessages.clipboardTarget.activeCellNavigable);
        } else if (value2 === "selection" && !(this.host.selectable || this.host.selectionDirective)) {
          console.warn(ClipboardErrorMessages.selectionSelectable);
        }
      });
    }
    this._target = value2;
  }
  get clipboardTarget() {
    return this._target;
  }
  /**
   * Configures the clipboard directive settings.
   *
   * @default { wholeRow: false, copyHeaders: false, copy: true, cut: true, paste: true }
   */
  set clipboardSettings(value2) {
    this._clipboardSettings = Object.assign({}, this._clipboardSettings, value2);
  }
  get clipboardSettings() {
    return this._clipboardSettings;
  }
  /**
   * Fires when a clipboard action (`cut`, `copy`, or `paste`) occurs in the Grid.
   */
  clipboard = new EventEmitter();
  _target = "selection";
  _clipboardSettings = {
    wholeRow: false,
    copyHeaders: false,
    copy: true,
    cut: true,
    paste: true
  };
  subs = new Subscription();
  constructor(host, clipboardService, renderer, zone) {
    this.host = host;
    this.clipboardService = clipboardService;
    this.renderer = renderer;
    this.zone = zone;
  }
  ngAfterViewInit() {
    if (!isDocumentAvailable()) {
      return;
    }
    if (this.clipboardTarget === "selection" && !(this.host.selectable || this.host.selectionDirective)) {
      console.warn(ClipboardErrorMessages.selectionSelectable);
    }
    this.zone.runOutsideAngular(() => {
      this.subs.add(this.renderer.listen(document, "copy", (args) => this.onClipboard("copy", args)));
      this.subs.add(this.renderer.listen(document, "cut", (args) => this.onClipboard("cut", args)));
      this.subs.add(this.renderer.listen(document, "paste", (args) => this.onClipboard("paste", args)));
    });
  }
  ngOnDestroy() {
    this.subs.unsubscribe();
  }
  onClipboard = (operationType, args) => {
    if (!this.clipboardSettings[operationType] || !this.inGrid(args)) {
      return;
    }
    const gridData = Array.isArray(this.host.data) ? this.host.data : this.host.data.data;
    const gridDataItems = gridData.flatMap(recursiveFlatMap);
    const selection = this.host.selection;
    const selectionDirective = this.host.selectionDirective;
    const targetType = this.clipboardTarget;
    const isCellSelection = this.host.selectable?.cell || selectionDirective.isCellSelectionMode;
    let clipboardData = [];
    switch (targetType) {
      case "activeCell":
        {
          const targetCell2 = __spreadValues({}, this.host.activeCell);
          clipboardData = targetCell2 && [{
            dataItem: targetCell2.dataItem,
            dataRowIndex: targetCell2.dataRowIndex,
            colIndex: targetCell2.colIndex
          }];
        }
        break;
      case "selection":
        {
          const identifier = selectionDirective.selectionKey;
          clipboardData = gridDataItems.flatMap((item, index) => {
            if (identifier) {
              const key = typeof identifier === "string" ? item[identifier] : identifier({
                index: index + this.host.skip,
                dataItem: item
              });
              return isCellSelection ? selection.some((s) => s.itemKey === key) ? [{
                dataItem: item,
                dataRowIndex: index + this.host.skip
              }] : [] : selection.indexOf(key) > -1 ? [{
                dataItem: item,
                dataRowIndex: index + this.host.skip
              }] : [];
            }
            return isCellSelection ? selection.some((s) => s.itemKey === index + this.host.skip) ? [{
              dataItem: item,
              dataRowIndex: index + this.host.skip
            }] : [] : selection.indexOf(index + this.host.skip) > -1 ? [{
              dataItem: item,
              dataRowIndex: index + this.host.skip
            }] : [];
          });
        }
        break;
    }
    const isPaste = operationType === "paste";
    const pastedData = args.clipboardData.getData("text");
    const visibleCols = this.host.columns.toArray().filter((c) => c.isVisible);
    if (visibleCols.some((c) => c.orderIndex > 0)) {
      visibleCols.sort((a, b) => a.orderIndex - b.orderIndex);
    }
    const data = isPaste ? {
      dataString: pastedData,
      gridItems: this.clipboardService.getGridData(pastedData, visibleCols, this.clipboardTarget, clipboardData[0]?.dataRowIndex, {
        wholeRow: this.clipboardSettings.wholeRow,
        isCellSelection
      })
    } : this.clipboardService.createClipboardData(clipboardData || [], visibleCols, {
      wholeRow: this.clipboardSettings.wholeRow || this.clipboardTarget === "selection" && !isCellSelection,
      target: this.clipboardTarget,
      copyHeaders: this.clipboardSettings.copyHeaders,
      operationType
    });
    !isPaste && navigator.clipboard.writeText(data.dataString);
    if (hasObservers(this.clipboard)) {
      this.zone.run(() => {
        this.clipboard.emit({
          type: operationType,
          originalEvent: args,
          clipboardData: data.dataString,
          gridData: data.gridItems,
          target: {
            dataRowIndex: this.clipboardService.targetRowIndex,
            colField: this.clipboardService.targetColField,
            dataItem: clipboardData.find((item) => item.dataRowIndex === this.clipboardService.targetRowIndex)?.dataItem
          }
        });
      });
    }
    this.clipboardService.targetColField = this.clipboardService.targetRowIndex = null;
  };
  inGrid = (args) => {
    const target = document.activeElement.matches(".k-table-td") ? document.activeElement : args.target;
    const inContentArea = closest5(target, (node) => node.parentElement?.classList.contains("k-grid-container"));
    const inHost = contains$1(this.host.wrapper.nativeElement, target);
    return target && inHost && inContentArea;
  };
  static ɵfac = function GridClipboardDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _GridClipboardDirective)(ɵɵdirectiveInject(GridComponent), ɵɵdirectiveInject(ClipboardService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _GridClipboardDirective,
    selectors: [["", "kendoGridClipboard", ""]],
    inputs: {
      clipboardTarget: "clipboardTarget",
      clipboardSettings: "clipboardSettings"
    },
    outputs: {
      clipboard: "clipboard"
    },
    exportAs: ["kendoGridClipboard"],
    features: [ɵɵProvidersFeature([ClipboardService])]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GridClipboardDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridClipboard]",
      exportAs: "kendoGridClipboard",
      providers: [ClipboardService],
      standalone: true
    }]
  }], () => [{
    type: GridComponent
  }, {
    type: ClipboardService
  }, {
    type: Renderer2
  }, {
    type: NgZone
  }], {
    clipboardTarget: [{
      type: Input
    }],
    clipboardSettings: [{
      type: Input
    }],
    clipboard: [{
      type: Output
    }]
  });
})();
var PDFCommandToolbarDirective = class _PDFCommandToolbarDirective extends ToolbarToolBase {
  pdfService;
  host;
  constructor(pdfService, host, ctx, zone, cdr) {
    super(host, ToolbarToolName.pdfExport, ctx, zone, cdr);
    this.pdfService = pdfService;
    this.host = host;
  }
  ngOnInit() {
    super.ngOnInit();
    this.host.className = "k-grid-pdf";
  }
  /**
   * @hidden
   */
  onClick(e) {
    e.preventDefault();
    this.pdfService.exportClick.emit();
  }
  static ɵfac = function PDFCommandToolbarDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PDFCommandToolbarDirective)(ɵɵdirectiveInject(PDFService), ɵɵdirectiveInject(ToolBarButtonComponent), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PDFCommandToolbarDirective,
    selectors: [["", "kendoGridPDFTool", ""]],
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PDFCommandToolbarDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridPDFTool]",
      standalone: true
    }]
  }], () => [{
    type: PDFService
  }, {
    type: ToolBarButtonComponent
  }, {
    type: ContextService
  }, {
    type: NgZone
  }, {
    type: ChangeDetectorRef
  }], null);
})();
var ExcelCommandToolbarDirective = class _ExcelCommandToolbarDirective extends ToolbarToolBase {
  excelService;
  constructor(excelService, host, ctx, zone, cdr) {
    super(host, ToolbarToolName.excelExport, ctx, zone, cdr);
    this.excelService = excelService;
  }
  ngOnInit() {
    super.ngOnInit();
    this.host.className = "k-grid-excel";
  }
  /**
   * @hidden
   */
  onClick(e) {
    e.preventDefault();
    this.excelService.exportClick.emit();
  }
  static ɵfac = function ExcelCommandToolbarDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ExcelCommandToolbarDirective)(ɵɵdirectiveInject(ExcelService), ɵɵdirectiveInject(ToolBarButtonComponent), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ExcelCommandToolbarDirective,
    selectors: [["", "kendoGridExcelTool", ""]],
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExcelCommandToolbarDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridExcelTool]",
      standalone: true
    }]
  }], () => [{
    type: ExcelService
  }, {
    type: ToolBarButtonComponent
  }, {
    type: ContextService
  }, {
    type: NgZone
  }, {
    type: ChangeDetectorRef
  }], null);
})();
var ToolbarEditingToolBase = class _ToolbarEditingToolBase extends ToolbarToolBase {
  host;
  commandName;
  ctx;
  editService;
  selection;
  isEdited = false;
  lastToolState = null;
  constructor(host, commandName, ctx, zone, cdr, editService, selection) {
    super(host, commandName, ctx, zone, cdr);
    this.host = host;
    this.commandName = commandName;
    this.ctx = ctx;
    this.editService = editService;
    this.selection = selection;
  }
  ngAfterViewInit() {
    super.ngAfterViewInit();
    const commandText = this.ctx.localization.get(`${this.commandName}ToolbarToolText`);
    this.buttonElement?.setAttribute("title", commandText);
  }
  ngDoCheck() {
    if (!isPresent(this.editService)) {
      return;
    }
    this.isEdited = this.editService.isEditing();
    const isAddNewItem = this.editService.hasNewItem;
    let isToolInactive = false;
    let formGroup;
    const selectionPresent = isPresent(this.lastSelectionIndex);
    if (this.isEdited || isAddNewItem) {
      formGroup = isAddNewItem ? this.editService.context()?.group : this.editService.editedIndices[0].group;
    }
    switch (this.commandName) {
      case ToolbarToolName.edit:
        isToolInactive = this.isEdited || !selectionPresent;
        break;
      case ToolbarToolName.save:
        isToolInactive = !(this.isEdited || isAddNewItem) || !formGroup?.valid;
        break;
      case ToolbarToolName.remove:
        isToolInactive = this.isEdited || !selectionPresent;
        break;
      case ToolbarToolName.cancel:
        isToolInactive = !(this.isEdited || isAddNewItem);
        break;
    }
    if (this.lastToolState !== isToolInactive) {
      this.lastToolState = isToolInactive;
      if (this.ctx.grid.showInactiveTools) {
        this.host.disabled = isToolInactive;
      } else if (this.host.isHidden !== isToolInactive) {
        this.host.isHidden = isToolInactive;
        const toolbar = this.host.host;
        toolbar.refreshService.refresh(this.host);
        this.zone.onStable.pipe(take(1)).subscribe(() => {
          toolbar.onResize();
        });
      }
    }
  }
  get lastSelectionIndex() {
    return this.selection?.selected[this.selection?.selected.length - 1];
  }
  get isSelectionPresent() {
    return isPresent(this.lastSelectionIndex) && this.lastSelectionIndex > -1;
  }
  static ɵfac = function ToolbarEditingToolBase_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ToolbarEditingToolBase)(ɵɵdirectiveInject(ToolBarButtonComponent), ɵɵdirectiveInject("command"), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(EditService), ɵɵdirectiveInject(SelectionService2));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ToolbarEditingToolBase,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ToolbarEditingToolBase, [{
    type: Directive,
    args: [{}]
  }], () => [{
    type: ToolBarButtonComponent
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: ["command"]
    }]
  }, {
    type: ContextService
  }, {
    type: NgZone
  }, {
    type: ChangeDetectorRef
  }, {
    type: EditService
  }, {
    type: SelectionService2
  }], null);
})();
var AddCommandToolbarDirective = class _AddCommandToolbarDirective extends ToolbarEditingToolBase {
  editService;
  host;
  constructor(editService, host, ctx, zone, cdr) {
    super(host, ToolbarToolName.add, ctx, zone, cdr, editService);
    this.editService = editService;
    this.host = host;
  }
  ngOnInit() {
    super.ngOnInit();
    this.host.className = "k-grid-add-command";
  }
  /**
   * @hidden
   */
  onClick(e) {
    e.preventDefault();
    this.editService.beginAdd();
  }
  static ɵfac = function AddCommandToolbarDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AddCommandToolbarDirective)(ɵɵdirectiveInject(EditService), ɵɵdirectiveInject(ToolBarButtonComponent), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _AddCommandToolbarDirective,
    selectors: [["", "kendoGridAddTool", ""]],
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AddCommandToolbarDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridAddTool]",
      standalone: true
    }]
  }], () => [{
    type: EditService
  }, {
    type: ToolBarButtonComponent
  }, {
    type: ContextService
  }, {
    type: NgZone
  }, {
    type: ChangeDetectorRef
  }], null);
})();
var UndoRedoStack = class {
  maxSize;
  /** The current active node in the undo-redo history */
  currentNode = null;
  /** The root node of the stack (first state) */
  rootNode = null;
  /** Track the size of the stack */
  _size = 0;
  /**
   * Creates a new UndoRedoStack.
   * @param maxSize Optional maximum number of states to maintain (unlimited if not provided)
   */
  constructor(maxSize = -1) {
    this.maxSize = maxSize;
  }
  /**
   * Gets the current number of states in the stack
   */
  get size() {
    return this._size;
  }
  /**
   * Gets the current active state
   */
  get current() {
    return this.currentNode ? this.currentNode.state : null;
  }
  /**
   * Checks if undo is available (if there's a previous state)
   */
  get canUndo() {
    return isPresent(this.currentNode?.previous);
  }
  /**
   * Checks if redo is available (if there's a next state)
   */
  get canRedo() {
    return isPresent(this.currentNode?.next);
  }
  /**
   * Adds a new state to the undo-redo stack
   * @param state The state to add
   * @param id Optional identifier for the state
   * @returns The newly created node
   */
  add(state2, id3) {
    const newNode = {
      state: state2,
      previous: this.currentNode,
      next: null,
      id: id3
    };
    if (this.currentNode) {
      if (this.currentNode.next) {
        this.truncateForward(this.currentNode);
      }
      this.currentNode.next = newNode;
    } else {
      this.rootNode = newNode;
    }
    this.currentNode = newNode;
    this._size++;
    this.enforceMaxSize();
    return newNode;
  }
  /**
   * Finds a node by its identifier
   * @param id The identifier to search for
   * @returns The found node or null if not found
   */
  find(id3) {
    if (!this.rootNode) {
      return null;
    }
    let node = this.rootNode;
    while (node) {
      if (node.id === id3) {
        return node;
      }
      node = node.next;
    }
    return null;
  }
  /**
   * Removes a node by its identifier
   * @param id The identifier of the node to remove
   * @returns True if the node was found and removed, false otherwise
   */
  remove(id3) {
    const nodeToRemove = this.find(id3);
    if (!nodeToRemove) {
      return false;
    }
    if (nodeToRemove === this.currentNode) {
      this.currentNode = nodeToRemove.previous || nodeToRemove.next;
    }
    if (nodeToRemove.previous) {
      nodeToRemove.previous.next = nodeToRemove.next;
    } else {
      this.rootNode = nodeToRemove.next;
    }
    if (nodeToRemove.next) {
      nodeToRemove.next.previous = nodeToRemove.previous;
    }
    nodeToRemove.previous = null;
    nodeToRemove.next = null;
    this._size--;
    return true;
  }
  /**
   * Performs an undo operation, moving to the previous state
   * @returns The previous state or null if can't undo
   */
  undo() {
    if (!this.canUndo) {
      return null;
    }
    this.currentNode = this.currentNode.previous;
    return this.currentNode.state;
  }
  peekNext() {
    return this.currentNode.next?.state || null;
  }
  peekPrev() {
    return this.currentNode.previous?.state || null;
  }
  /**
   * Performs a redo operation, moving to the next state
   * @returns The next state or null if can't redo
   */
  redo() {
    if (!this.canRedo) {
      return null;
    }
    this.currentNode = this.currentNode.next;
    return this.currentNode.state;
  }
  /**
   * Clears all history
   */
  clear() {
    this.currentNode = null;
    this.rootNode = null;
    this._size = 0;
  }
  /**
   * Removes all states after the specified node
   * @param node The node to truncate from
   * @returns The number of nodes removed
   */
  truncateForward(node) {
    if (!node.next) {
      return 0;
    }
    let removedCount = 0;
    let currentNext = node.next;
    while (currentNext) {
      const temp = currentNext.next;
      currentNext.previous = null;
      currentNext.next = null;
      currentNext = temp;
      removedCount++;
    }
    node.next = null;
    this._size -= removedCount;
    return removedCount;
  }
  /**
   * Ensures the stack doesn't exceed the maximum size by removing oldest nodes
   */
  enforceMaxSize() {
    if (this.maxSize <= 0 || this._size <= this.maxSize) {
      return;
    }
    let nodesToRemove = this._size - this.maxSize;
    let currentNode = this.rootNode;
    while (nodesToRemove > 0 && currentNode) {
      currentNode = currentNode.next;
      nodesToRemove--;
    }
    if (currentNode) {
      currentNode.previous = null;
      this.rootNode = currentNode;
      this._size = this.maxSize;
    }
  }
  /**
   * Gets all states in the stack as an array (from oldest to newest)
   */
  toArray() {
    const result = [];
    let node = this.rootNode;
    while (node) {
      result.push(node.state);
      node = node.next;
    }
    return result;
  }
  /**
   * Gets the history nodes as an array (useful for debugging)
   */
  getNodes() {
    const result = [];
    let node = this.rootNode;
    while (node) {
      result.push(node);
      node = node.next;
    }
    return result;
  }
};
var UndoRedoEvent = class extends PreventableEvent {
  /**
   * The event data for the action that changed the state.
   */
  originalEvent;
  /**
   * The Grid state and rendered data at the time of the action.
   */
  gridState;
  /**
   * @hidden
   */
  constructor({
    originalEvent,
    gridState
  }) {
    super();
    this.originalEvent = originalEvent;
    this.gridState = gridState;
  }
};
var UndoRedoService = class _UndoRedoService {
  originalEvent;
  onUndo = new Subject();
  onRedo = new Subject();
  stackEndReached = new Subject();
  static ɵfac = function UndoRedoService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _UndoRedoService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _UndoRedoService,
    factory: _UndoRedoService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UndoRedoService, [{
    type: Injectable
  }], null, null);
})();
var UndoRedoDirective = class _UndoRedoDirective {
  host;
  editService;
  undoRedoService;
  changeNotification;
  ctx;
  localDataChangesService;
  /**
   * Sets the maximum number of actions to keep in the undo-redo stack.
   * @default 10
   */
  maxStoredStates = 10;
  /**
   * Defines the property name of the data item unique key that will be used to identify the items when performing undo-redo actions.
   */
  itemIdKey;
  /**
   * Fires when you perform the undo action. Provides the Grid state to apply.
   */
  onUndo = new EventEmitter();
  /**
   * Fires when you perform the redo action. Provides the Grid state to apply.
   */
  onRedo = new EventEmitter();
  /**
   * Returns all undo-redo actions currently in the stack.
   */
  get undoRedoItems() {
    return this.stack.toArray();
  }
  stack;
  subs = new Subscription();
  addToState = true;
  constructor(host, editService, undoRedoService, changeNotification, ctx, localDataChangesService) {
    this.host = host;
    this.editService = editService;
    this.undoRedoService = undoRedoService;
    this.changeNotification = changeNotification;
    this.ctx = ctx;
    this.localDataChangesService = localDataChangesService;
    this.host.undoRedoService = this.undoRedoService;
  }
  ngOnInit() {
    this.stack = new UndoRedoStack(this.maxStoredStates);
    this.subs = this.host.gridStateChange.subscribe((state2) => {
      if (this.addToState) {
        this.stack.add({
          originalEvent: {
            skip: state2.skip,
            take: state2.take,
            sort: state2.sort,
            filter: state2.filter,
            group: state2.group
          },
          gridState: state2
        });
      }
      let stackEndPointReached;
      if (this.stack.canUndo) {
        stackEndPointReached = this.stack.canRedo ? false : "end";
      } else {
        stackEndPointReached = "start";
      }
      this.undoRedoService.stackEndReached.next(stackEndPointReached);
    });
    this.subs.add(this.editService.changes.pipe(filter((event) => event.action === "save" || event.action === "remove")).subscribe((event) => {
      this.stack.add({
        originalEvent: __spreadProps(__spreadValues({}, event), {
          dataItem: structuredClone(event.dataItem)
        }),
        gridState: this.host.currentState
      });
      this.addToState = false;
      this.host.gridStateChange.emit(this.stack.current.gridState);
      this.addToState = true;
      this.updateUndoRedoDisabled();
    }));
    this.subs.add(this.changeNotification.changes.subscribe(() => {
      if (!this.ctx.dataBindingDirective) {
        this.stack.current.gridState = this.host.currentState;
      }
    }));
    ["Undo", "Redo"].forEach((action) => {
      this.subs.add(this.undoRedoService[`on${action}`].subscribe(() => {
        if (!this.stack[`can${action}`]) {
          return;
        }
        let eventData;
        if (action === "Undo") {
          const isSaveOrRemove2 = this.stack.current.originalEvent.action === "save" || this.stack.current.originalEvent.action === "remove";
          eventData = isSaveOrRemove2 ? this.stack.current : this.stack.peekPrev();
        } else {
          eventData = this.stack.peekNext();
        }
        const event = new UndoRedoEvent(eventData);
        if (hasObservers(this[`on${action}`])) {
          this[`on${action}`].emit(event);
          if (event.isDefaultPrevented()) {
            return;
          }
        }
        this.stack[`${action.toLowerCase()}`]();
        this.updateUndoRedoDisabled();
        const originalAction = event.originalEvent.action;
        const isLocalData = isPresent(this.ctx?.dataBindingDirective);
        if (!isLocalData) {
          return;
        }
        const isSaveOrRemove = originalAction === "save" || originalAction === "remove";
        if (isSaveOrRemove) {
          if (originalAction === "save") {
            const stateItem = this.getGridDataItems(this.stack.current.gridState.currentData).find((item) => item[this.itemIdKey] === event.originalEvent.dataItem[this.itemIdKey]);
            this.localDataChangesService?.data.splice(event.originalEvent.rowIndex, 1, stateItem);
          } else if (action === "Undo") {
            this.localDataChangesService?.data.splice(event.originalEvent.rowIndex, 0, event.originalEvent.dataItem);
          } else {
            this.localDataChangesService?.data.splice(event.originalEvent.rowIndex, 1);
          }
          this.localDataChangesService?.changes.emit();
        } else {
          this.host.loadState(__spreadProps(__spreadValues({}, this.stack.current.gridState), {
            currentData: null
          }));
          if (this.isDataStateChangeEvent(event.originalEvent)) {
            const {
              skip: skip4,
              take: take4,
              sort: sort2,
              filter: filter3,
              group: group2
            } = event.gridState;
            this.host.dataStateChange.emit({
              skip: skip4,
              take: take4,
              sort: sort2,
              filter: filter3,
              group: group2
            });
          }
        }
      }));
    });
  }
  ngAfterViewInit() {
    this.stack.add({
      originalEvent: {
        skip: this.host.skip,
        take: this.host.pageSize,
        sort: this.host.sort,
        filter: this.host.filter,
        group: this.host.group
      },
      gridState: this.host.currentState
    });
  }
  ngOnDestroy() {
    this.stack.clear();
    this.stack = null;
    this.subs.unsubscribe();
  }
  /**
   * Re-applies the last action that you reverted with the `undo` method.
   */
  redo() {
    if (this.stack.canRedo) {
      this.stack.redo();
      this.host.loadState(this.stack.current.gridState);
      if (!this.stack.canRedo) {
        this.undoRedoService.stackEndReached.next("end");
      }
    }
  }
  /**
   * Reverts the last user action that you performed.
   */
  undo() {
    if (this.stack.canUndo) {
      this.stack.undo();
      this.host.loadState(this.stack.current.gridState);
      if (!this.stack.canUndo) {
        this.undoRedoService.stackEndReached.next("start");
      }
    }
  }
  updateUndoRedoDisabled() {
    if (!this.stack.canRedo) {
      this.undoRedoService.stackEndReached.next("end");
      return;
    }
    if (!this.stack.canUndo) {
      this.undoRedoService.stackEndReached.next("start");
      return;
    }
    this.undoRedoService.stackEndReached.next(false);
  }
  getGridDataItems(data) {
    return Array.isArray(data) ? data.flatMap(recursiveFlatMap) : data.data.flatMap(recursiveFlatMap);
  }
  isDataStateChangeEvent(event) {
    return event && ["skip", "take", "sort", "filter", "group"].some((prop2) => prop2 in event);
  }
  static ɵfac = function UndoRedoDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _UndoRedoDirective)(ɵɵdirectiveInject(GridComponent), ɵɵdirectiveInject(EditService), ɵɵdirectiveInject(UndoRedoService), ɵɵdirectiveInject(ChangeNotificationService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(LocalDataChangesService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _UndoRedoDirective,
    selectors: [["", "kendoGridUndoRedo", ""]],
    inputs: {
      maxStoredStates: "maxStoredStates",
      itemIdKey: "itemIdKey"
    },
    outputs: {
      onUndo: "undo",
      onRedo: "redo"
    },
    exportAs: ["kendoGridUndoRedo"],
    features: [ɵɵProvidersFeature([UndoRedoService])]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UndoRedoDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridUndoRedo]",
      standalone: true,
      exportAs: "kendoGridUndoRedo",
      providers: [UndoRedoService]
    }]
  }], () => [{
    type: GridComponent
  }, {
    type: EditService
  }, {
    type: UndoRedoService
  }, {
    type: ChangeNotificationService
  }, {
    type: ContextService
  }, {
    type: LocalDataChangesService
  }], {
    maxStoredStates: [{
      type: Input
    }],
    itemIdKey: [{
      type: Input
    }],
    onUndo: [{
      type: Output,
      args: ["undo"]
    }],
    onRedo: [{
      type: Output,
      args: ["redo"]
    }]
  });
})();
var UndoCommandToolbarDirective = class _UndoCommandToolbarDirective {
  undoRedoService;
  host;
  subs = new Subscription();
  /**
   * @hidden
   */
  constructor(undoRedoService, host) {
    this.undoRedoService = undoRedoService;
    this.host = host;
  }
  /**
   * @hidden
   */
  ngOnInit() {
    this.subs = this.host.click.subscribe((e) => this.onClick(e));
    this.host.className = "k-grid-undo-command";
    this.host.svgIcon = undoIcon;
    this.host.icon = "undo";
    this.host.text = "Undo";
    this.host.disabled = true;
    this.subs.add(this.undoRedoService.stackEndReached.subscribe((stackEnd) => this.host.disabled = stackEnd === "start"));
  }
  /**
   * @hidden
   */
  ngOnDestroy() {
    this.subs.unsubscribe();
  }
  /**
   * @hidden
   */
  onClick(e) {
    e.preventDefault();
    this.undoRedoService.onUndo.next(void 0);
  }
  static ɵfac = function UndoCommandToolbarDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _UndoCommandToolbarDirective)(ɵɵdirectiveInject(UndoRedoService), ɵɵdirectiveInject(ToolBarButtonComponent));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _UndoCommandToolbarDirective,
    selectors: [["", "kendoGridUndoTool", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UndoCommandToolbarDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridUndoTool]",
      standalone: true
    }]
  }], () => [{
    type: UndoRedoService
  }, {
    type: ToolBarButtonComponent
  }], null);
})();
var RedoCommandToolbarDirective = class _RedoCommandToolbarDirective {
  undoRedoService;
  host;
  subs = new Subscription();
  /**
   * @hidden
   */
  constructor(undoRedoService, host) {
    this.undoRedoService = undoRedoService;
    this.host = host;
  }
  /**
   * @hidden
   */
  ngOnInit() {
    this.subs = this.host.click.subscribe((e) => this.onClick(e));
    this.host.className = "k-grid-redo-command";
    this.host.svgIcon = redoIcon;
    this.host.icon = "redo";
    this.host.text = "Redo";
    this.host.disabled = true;
    this.subs.add(this.undoRedoService.stackEndReached.subscribe((stackEnd) => this.host.disabled = stackEnd === "end"));
  }
  /**
   * @hidden
   */
  ngOnDestroy() {
    this.subs.unsubscribe();
  }
  /**
   * @hidden
   */
  onClick(e) {
    e.preventDefault();
    this.undoRedoService.onRedo.next(void 0);
  }
  static ɵfac = function RedoCommandToolbarDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RedoCommandToolbarDirective)(ɵɵdirectiveInject(UndoRedoService), ɵɵdirectiveInject(ToolBarButtonComponent));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _RedoCommandToolbarDirective,
    selectors: [["", "kendoGridRedoTool", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RedoCommandToolbarDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridRedoTool]",
      standalone: true
    }]
  }], () => [{
    type: UndoRedoService
  }, {
    type: ToolBarButtonComponent
  }], null);
})();
var incrementingId$2 = 0;
var SortCommandToolbarDirective = class _SortCommandToolbarDirective {
  host;
  popupService;
  ctx;
  sortService;
  columnInfoService;
  ngZone;
  renderer;
  adaptiveGridService;
  popupRef;
  nextId = incrementingId$2++;
  toolSubs = new Subscription();
  popupSubs;
  actionSheetCloseSub;
  removeClickListener;
  /**
   * @hidden
   */
  isSortingApplied(sort2) {
    return isPresent(sort2) && sort2.length > 0 && sort2.filter((item) => item.dir !== void 0).length > 0;
  }
  constructor(host, popupService, ctx, sortService, columnInfoService, ngZone, renderer, adaptiveGridService) {
    this.host = host;
    this.popupService = popupService;
    this.ctx = ctx;
    this.sortService = sortService;
    this.columnInfoService = columnInfoService;
    this.ngZone = ngZone;
    this.renderer = renderer;
    this.adaptiveGridService = adaptiveGridService;
  }
  ngOnInit() {
    this.toolSubs = this.host.click.subscribe((e) => this.onClick(e));
    this.toolSubs.add(this.sortService.changes.subscribe((sort2) => {
      this.host.showBadge = this.isSortingApplied(sort2);
    }));
    this.host.hasBadgeContainer = true;
    this.host.showBadge = this.isSortingApplied(this.ctx.grid.sort);
    const hasToolbarIcon = isPresent(this.host.toolbarOptions.icon) && this.host.toolbarOptions.icon !== "";
    const hasOverflowIcon = isPresent(this.host.overflowOptions.icon) && this.host.overflowOptions.icon !== "";
    const hasIcon = hasToolbarIcon && hasOverflowIcon;
    const hasSvgIcon = isPresent(this.host.toolbarOptions.svgIcon) && isPresent(this.host.overflowOptions.svgIcon);
    if (!hasIcon) {
      this.host.icon = "arrows-swap";
    }
    if (!hasSvgIcon) {
      this.host.svgIcon = arrowsSwapIcon;
    }
  }
  ngAfterViewInit() {
    if (!isPresent(this.host.text)) {
      this.ngZone.onStable.pipe(take(1)).subscribe(() => {
        this.host.text = this.ctx.localization.get(`sortToolbarToolText`);
      });
    }
    this.buttonElement?.setAttribute("aria-haspopup", "dialog");
    this.buttonElement?.setAttribute("aria-expanded", "false");
    this.buttonElement?.setAttribute("title", this.ctx.localization.get("sortToolbarToolText"));
  }
  ngOnDestroy() {
    if (this.toolSubs) {
      this.toolSubs.unsubscribe();
    }
    if (this.popupSubs) {
      this.popupSubs.unsubscribe();
    }
    if (this.popupRef) {
      this.popupRef.close();
      this.popupRef = null;
    }
    if (this.actionSheetCloseSub) {
      this.actionSheetCloseSub.unsubscribe();
      this.actionSheetCloseSub = null;
    }
    if (this.removeClickListener) {
      this.removeClickListener();
      this.removeClickListener = null;
    }
  }
  onClick(e) {
    e.preventDefault();
    if (this.ctx.grid.adaptiveMode === "auto" && this.adaptiveGridService.windowSize !== "large") {
      if (!this.ctx.grid.isActionSheetExpanded) {
        this.adaptiveGridService.viewType = "sortToolbarTool";
        this.ctx.grid.adaptiveRenderer.actionSheet.toggle(true);
        this.host.selected = true;
        this.actionSheetCloseSub = this.ctx.grid.adaptiveRenderer.actionSheet.collapse.subscribe(() => this.host.selected = false);
      }
    } else {
      if (this.popupRef) {
        this.closePopup();
        return;
      }
      this.openPopup();
    }
  }
  openPopup() {
    const direction = this.ctx.localization.rtl ? "right" : "left";
    this.popupRef = this.popupService.open({
      anchor: this.buttonElement,
      content: SortToolbarToolComponent,
      popupClass: "k-grid-columnmenu-popup",
      positionMode: "absolute",
      anchorAlign: {
        vertical: "bottom",
        horizontal: direction
      },
      popupAlign: {
        vertical: "top",
        horizontal: direction
      }
    });
    this.adaptiveGridService.popupRef = this.popupRef;
    this.setPopupAttributes();
    this.host.selected = true;
    this.ngZone.runOutsideAngular(() => {
      if (!isDocumentAvailable()) {
        return;
      }
      this.removeClickListener = this.renderer.listen("document", "click", (e) => {
        if (this.popupRef && !closest(e.target, (node) => node === this.popupRef.popupElement || node === this.buttonElement)) {
          this.ngZone.run(() => {
            this.closePopup();
          });
        }
      });
    });
    this.popupSubs = this.popupRef.popup.instance.anchorViewportLeave.subscribe(() => {
      this.popupSubs?.unsubscribe();
      this.popupSubs = null;
      this.closePopup();
    });
    this.initPopupProperties();
  }
  setPopupAttributes() {
    const popupElement = this.popupRef.popupElement;
    const popupId = `k-sort-tool-${this.nextId}-popup`;
    const popupAriaElement = popupElement.querySelector(".k-popup");
    this.renderer.setAttribute(popupElement, "dir", this.ctx.localization.rtl ? "rtl" : "ltr");
    this.renderer.setAttribute(popupAriaElement, "id", popupId);
    this.renderer.setAttribute(popupAriaElement, "role", "dialog");
    this.buttonElement?.setAttribute("aria-expanded", "true");
    this.buttonElement?.setAttribute("aria-controls", popupId);
  }
  initPopupProperties() {
    this.popupRef.content.instance.columnInfoService = this.columnInfoService;
    this.popupRef.content.instance.ctx = this.ctx;
    this.popupRef.content.instance.sortService = this.sortService;
    this.popupRef.content.instance.hostButton = this.host;
    this.popupSubs.add(this.popupRef.content.instance.sortClear.subscribe(() => {
      this.closePopup();
    }));
    this.popupSubs.add(this.popupRef.content.instance.close.subscribe(() => {
      this.closePopup();
    }));
  }
  closePopup() {
    this.buttonElement?.setAttribute("aria-expanded", "false");
    this.buttonElement?.removeAttribute("aria-controls");
    this.host.selected = false;
    if (this.popupRef) {
      this.popupRef.close();
      this.popupRef = null;
    }
    if (this.popupSubs) {
      this.popupSubs.unsubscribe();
      this.popupSubs = null;
    }
    if (this.removeClickListener) {
      this.removeClickListener();
      this.removeClickListener = null;
    }
  }
  get buttonElement() {
    return this.host.getButton();
  }
  static ɵfac = function SortCommandToolbarDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SortCommandToolbarDirective)(ɵɵdirectiveInject(ToolBarButtonComponent), ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(SortService), ɵɵdirectiveInject(ColumnInfoService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(AdaptiveGridService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _SortCommandToolbarDirective,
    selectors: [["", "kendoGridSortTool", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SortCommandToolbarDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridSortTool]",
      standalone: true
    }]
  }], () => [{
    type: ToolBarButtonComponent
  }, {
    type: PopupService
  }, {
    type: ContextService
  }, {
    type: SortService
  }, {
    type: ColumnInfoService
  }, {
    type: NgZone
  }, {
    type: Renderer2
  }, {
    type: AdaptiveGridService
  }], null);
})();
var FilterToolWrapperComponent = class _FilterToolWrapperComponent {
  injector;
  container;
  wrapperClasses = true;
  onEscKeyDown(event) {
    event.preventDefault();
    this.close.emit();
    this.hostButton?.focus(event);
  }
  onClick(event) {
    if (this.hostButton.location !== "toolbar") {
      event.stopImmediatePropagation();
    }
  }
  close = new EventEmitter();
  hostButton;
  clearIcon = filterClearIcon;
  columnInfoService;
  set ctx(ctx) {
    this._ctx = ctx;
    this.filter = ctx.grid.filter;
    this.createPopup();
  }
  get ctx() {
    return this._ctx;
  }
  set filterService(filterService) {
    this._filterService = filterService;
    this.subscriptions = this._filterService.changes.subscribe((filter3) => {
      this.filter = filter3;
    });
    this.createPopup();
  }
  get filterService() {
    return this._filterService;
  }
  columnMenuService;
  popupRef;
  filter;
  subscriptions;
  _ctx;
  _filterService;
  constructor(injector) {
    this.injector = injector;
  }
  ngOnDestroy() {
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
    }
    if (this.popupRef) {
      this.popupRef.destroy();
      this.popupRef = null;
    }
  }
  clear() {
    if (!this.filter || this.filter.filters?.length === 0) {
      return;
    }
    this.filter = {
      logic: "and",
      filters: []
    };
    this.popupRef.instance.filter = cloneFilters(this.filter);
    this.filterService.filter(this.filter);
    this.close.emit();
  }
  createPopup() {
    if (this._ctx && this._filterService && this.container && !this.popupRef) {
      const customInjector = Injector.create({
        providers: [{
          provide: FilterService,
          useValue: this._filterService
        }, {
          provide: ContextService,
          useValue: this._ctx
        }, {
          provide: ColumnInfoService,
          useValue: this.columnInfoService
        }, AdaptiveGridService, SinglePopupService, ScrollSyncService2],
        parent: this.injector
      });
      this.popupRef = this.container.createComponent(FilterToolbarToolComponent, {
        injector: customInjector
      });
      this.subscriptions.add(this.popupRef.instance.close.subscribe(() => this.close.emit()));
    }
  }
  static ɵfac = function FilterToolWrapperComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FilterToolWrapperComponent)(ɵɵdirectiveInject(Injector));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _FilterToolWrapperComponent,
    selectors: [["kendo-filter-tool-wrapper"]],
    viewQuery: function FilterToolWrapperComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c492, 7, ViewContainerRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.container = _t.first);
      }
    },
    hostVars: 4,
    hostBindings: function FilterToolWrapperComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("keydown.escape", function FilterToolWrapperComponent_keydown_escape_HostBindingHandler($event) {
          return ctx.onEscKeyDown($event);
        })("click", function FilterToolWrapperComponent_click_HostBindingHandler($event) {
          return ctx.onClick($event);
        });
      }
      if (rf & 2) {
        ɵɵclassProp("k-column-menu", ctx.wrapperClasses)("k-column-menu-md", ctx.wrapperClasses);
      }
    },
    outputs: {
      close: "close"
    },
    decls: 5,
    vars: 2,
    consts: [["container", ""], [1, "k-actions", "k-actions-stretched", "k-actions-horizontal", "k-column-menu-footer"], ["kendoButton", "", "icon", "filter-clear", 3, "click", "svgIcon"]],
    template: function FilterToolWrapperComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainer(0, null, 0);
        ɵɵelementStart(2, "div", 1)(3, "button", 2);
        ɵɵlistener("click", function FilterToolWrapperComponent_Template_button_click_3_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.clear());
        });
        ɵɵtext(4);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵadvance(3);
        ɵɵproperty("svgIcon", ctx.clearIcon);
        ɵɵadvance();
        ɵɵtextInterpolate1(" ", ctx.ctx == null ? null : ctx.ctx.localization.get("filterClearAllButton"), " ");
      }
    },
    dependencies: [ButtonComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterToolWrapperComponent, [{
    type: Component,
    args: [{
      selector: "kendo-filter-tool-wrapper",
      template: `
        <ng-container #container></ng-container>
        <div class="k-actions k-actions-stretched k-actions-horizontal k-column-menu-footer">
            <button kendoButton
                    [svgIcon]="clearIcon"
                    icon="filter-clear"
                    (click)="clear()">
                    {{ctx?.localization.get('filterClearAllButton')}}
            </button>
        </div>
    `,
      standalone: true,
      imports: [KENDO_BUTTON]
    }]
  }], () => [{
    type: Injector
  }], {
    container: [{
      type: ViewChild,
      args: ["container", {
        read: ViewContainerRef,
        static: true
      }]
    }],
    wrapperClasses: [{
      type: HostBinding,
      args: ["class.k-column-menu"]
    }, {
      type: HostBinding,
      args: ["class.k-column-menu-md"]
    }],
    onEscKeyDown: [{
      type: HostListener,
      args: ["keydown.escape", ["$event"]]
    }],
    onClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }],
    close: [{
      type: Output
    }]
  });
})();
var incrementingId$1 = 0;
var FilterCommandToolbarDirective = class _FilterCommandToolbarDirective {
  host;
  popupService;
  ctx;
  filterService;
  columnInfoService;
  ngZone;
  renderer;
  adaptiveGridService;
  popupRef;
  nextId = incrementingId$1++;
  toolSubs = new Subscription();
  popupSubs;
  actionSheetCloseSub;
  removeClickListener;
  /**
   * @hidden
   */
  isFilterApplied(filter3) {
    return isPresent(filter3) && filter3.filters?.length > 0;
  }
  constructor(host, popupService, ctx, filterService, columnInfoService, ngZone, renderer, adaptiveGridService) {
    this.host = host;
    this.popupService = popupService;
    this.ctx = ctx;
    this.filterService = filterService;
    this.columnInfoService = columnInfoService;
    this.ngZone = ngZone;
    this.renderer = renderer;
    this.adaptiveGridService = adaptiveGridService;
  }
  ngOnInit() {
    this.toolSubs = this.host.click.subscribe((e) => this.onClick(e));
    this.toolSubs.add(this.filterService.changes.subscribe((filter3) => {
      this.host.showBadge = this.isFilterApplied(filter3);
    }));
    this.host.hasBadgeContainer = true;
    this.host.showBadge = this.isFilterApplied(this.ctx.grid.filter);
    const hasToolbarIcon = isPresent(this.host.toolbarOptions.icon) && this.host.toolbarOptions.icon !== "";
    const hasOverflowIcon = isPresent(this.host.overflowOptions.icon) && this.host.overflowOptions.icon !== "";
    const hasIcon = hasToolbarIcon && hasOverflowIcon;
    const hasSvgIcon = isPresent(this.host.toolbarOptions.svgIcon) && isPresent(this.host.overflowOptions.svgIcon);
    if (!hasIcon) {
      this.host.icon = "filter";
    }
    if (!hasSvgIcon) {
      this.host.svgIcon = filterIcon;
    }
  }
  ngAfterViewInit() {
    if (!isPresent(this.host.text)) {
      this.ngZone.onStable.pipe(take(1)).subscribe(() => {
        this.host.text = this.ctx.localization.get(`filterToolbarToolText`);
      });
    }
    this.buttonElement?.setAttribute("aria-haspopup", "dialog");
    this.buttonElement?.setAttribute("aria-expanded", "false");
    this.buttonElement?.setAttribute("title", this.ctx.localization.get("filterToolbarToolText"));
  }
  ngOnDestroy() {
    if (this.toolSubs) {
      this.toolSubs.unsubscribe();
    }
    if (this.popupSubs) {
      this.popupSubs.unsubscribe();
    }
    if (this.popupRef) {
      this.popupRef.close();
      this.popupRef = null;
    }
    if (this.actionSheetCloseSub) {
      this.actionSheetCloseSub.unsubscribe();
      this.actionSheetCloseSub = null;
    }
    if (this.removeClickListener) {
      this.removeClickListener();
      this.removeClickListener = null;
    }
  }
  onClick(e) {
    e.preventDefault();
    if (this.popupRef) {
      this.closePopup();
      return;
    }
    this.openPopup();
  }
  openPopup() {
    const direction = this.ctx.localization.rtl ? "right" : "left";
    if (this.ctx.grid.adaptiveMode === "auto" && this.adaptiveGridService.windowSize !== "large") {
      if (!this.ctx.grid.isActionSheetExpanded) {
        this.adaptiveGridService.viewType = "filterToolbarTool";
        this.ctx.grid.adaptiveRenderer.actionSheet.toggle(true);
        this.host.selected = true;
        this.actionSheetCloseSub = this.ctx.grid.adaptiveRenderer.actionSheet.collapse.subscribe(() => this.host.selected = false);
      }
    } else {
      this.popupRef = this.popupService.open({
        anchor: this.buttonElement,
        content: FilterToolWrapperComponent,
        popupClass: "k-grid-columnmenu-popup",
        positionMode: "absolute",
        anchorAlign: {
          vertical: "bottom",
          horizontal: direction
        },
        popupAlign: {
          vertical: "top",
          horizontal: direction
        }
      });
      this.adaptiveGridService.popupRef = this.popupRef;
      this.setPopupAttributes();
      this.host.selected = true;
      this.ngZone.runOutsideAngular(() => {
        if (!isDocumentAvailable()) {
          return;
        }
        this.removeClickListener = this.renderer.listen("document", "click", (e) => {
          if (this.popupRef && !closest(e.target, (node) => node === this.popupRef.popupElement || node === this.buttonElement)) {
            this.ngZone.run(() => {
              this.closePopup();
            });
          }
        });
      });
      this.popupSubs = this.popupRef.popup.instance.anchorViewportLeave.subscribe(() => {
        this.popupSubs?.unsubscribe();
        this.popupSubs = null;
        this.closePopup();
      });
      this.initPopupProperties();
    }
  }
  setPopupAttributes() {
    const popupElement = this.popupRef.popupElement;
    const popupId = `k-filter-tool-${this.nextId}-popup`;
    const popupAriaElement = popupElement.querySelector(".k-popup");
    this.renderer.setAttribute(popupElement, "dir", this.ctx.localization.rtl ? "rtl" : "ltr");
    this.renderer.setAttribute(popupAriaElement, "id", popupId);
    this.renderer.setAttribute(popupAriaElement, "role", "dialog");
    this.buttonElement?.setAttribute("aria-expanded", "true");
    this.buttonElement?.setAttribute("aria-controls", popupId);
  }
  initPopupProperties() {
    this.popupRef.content.instance.columnInfoService = this.columnInfoService;
    this.popupRef.content.instance.ctx = this.ctx;
    this.popupRef.content.instance.filterService = this.filterService;
    this.popupRef.content.instance.hostButton = this.host;
    this.popupSubs.add(this.popupRef.content.instance.close.subscribe(() => {
      this.closePopup();
    }));
  }
  closePopup() {
    this.buttonElement?.setAttribute("aria-expanded", "false");
    this.buttonElement?.removeAttribute("aria-controls");
    this.host.selected = false;
    if (this.popupRef) {
      this.popupRef.close();
      this.popupRef = null;
    }
    if (this.popupSubs) {
      this.popupSubs.unsubscribe();
      this.popupSubs = null;
    }
    if (this.removeClickListener) {
      this.removeClickListener();
      this.removeClickListener = null;
    }
  }
  get buttonElement() {
    return this.host.getButton();
  }
  static ɵfac = function FilterCommandToolbarDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FilterCommandToolbarDirective)(ɵɵdirectiveInject(ToolBarButtonComponent), ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(FilterService), ɵɵdirectiveInject(ColumnInfoService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(AdaptiveGridService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FilterCommandToolbarDirective,
    selectors: [["", "kendoGridFilterTool", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterCommandToolbarDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridFilterTool]",
      standalone: true
    }]
  }], () => [{
    type: ToolBarButtonComponent
  }, {
    type: PopupService
  }, {
    type: ContextService
  }, {
    type: FilterService
  }, {
    type: ColumnInfoService
  }, {
    type: NgZone
  }, {
    type: Renderer2
  }, {
    type: AdaptiveGridService
  }], null);
})();
var EditCommandToolbarDirective = class _EditCommandToolbarDirective extends ToolbarEditingToolBase {
  editService;
  constructor(editService, host, selection, ctx, zone, cdr) {
    super(host, ToolbarToolName.edit, ctx, zone, cdr, editService, selection);
    this.editService = editService;
  }
  /**
   * @hidden
   */
  onClick(e) {
    e.preventDefault();
    if (!this.isSelectionPresent) {
      return;
    }
    this.editService.beginEdit(this.lastSelectionIndex);
  }
  static ɵfac = function EditCommandToolbarDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _EditCommandToolbarDirective)(ɵɵdirectiveInject(EditService), ɵɵdirectiveInject(ToolBarButtonComponent), ɵɵdirectiveInject(SelectionService2), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _EditCommandToolbarDirective,
    selectors: [["", "kendoGridEditTool", ""]],
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EditCommandToolbarDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridEditTool]",
      standalone: true
    }]
  }], () => [{
    type: EditService
  }, {
    type: ToolBarButtonComponent
  }, {
    type: SelectionService2
  }, {
    type: ContextService
  }, {
    type: NgZone
  }, {
    type: ChangeDetectorRef
  }], null);
})();
var SaveCommandToolbarDirective = class _SaveCommandToolbarDirective extends ToolbarEditingToolBase {
  editService;
  constructor(editService, host, selection, ctx, zone, cdr) {
    super(host, ToolbarToolName.save, ctx, zone, cdr, editService, selection);
    this.editService = editService;
  }
  /**
   * @hidden
   */
  onClick(e) {
    e.preventDefault();
    if (this.editService.hasNewItem) {
      this.editService.save();
    } else if (this.isSelectionPresent && this.editService.isEdited(this.lastSelectionIndex)) {
      this.editService.save(this.lastSelectionIndex);
    } else {
      this.editService.editedIndices.forEach((i) => this.editService.save(i.index));
    }
  }
  static ɵfac = function SaveCommandToolbarDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SaveCommandToolbarDirective)(ɵɵdirectiveInject(EditService), ɵɵdirectiveInject(ToolBarButtonComponent), ɵɵdirectiveInject(SelectionService2), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _SaveCommandToolbarDirective,
    selectors: [["", "kendoGridSaveTool", ""]],
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SaveCommandToolbarDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridSaveTool]",
      standalone: true
    }]
  }], () => [{
    type: EditService
  }, {
    type: ToolBarButtonComponent
  }, {
    type: SelectionService2
  }, {
    type: ContextService
  }, {
    type: NgZone
  }, {
    type: ChangeDetectorRef
  }], null);
})();
var RemoveCommandToolbarDirective = class _RemoveCommandToolbarDirective extends ToolbarEditingToolBase {
  editService;
  selection;
  constructor(editService, host, selection, ctx, zone, cdr) {
    super(host, ToolbarToolName.remove, ctx, zone, cdr, editService, selection);
    this.editService = editService;
    this.selection = selection;
  }
  /**
   * @hidden
   */
  onClick(e) {
    e.preventDefault();
    if (this.isSelectionPresent) {
      this.editService.remove(this.lastSelectionIndex);
    }
  }
  static ɵfac = function RemoveCommandToolbarDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RemoveCommandToolbarDirective)(ɵɵdirectiveInject(EditService), ɵɵdirectiveInject(ToolBarButtonComponent), ɵɵdirectiveInject(SelectionService2), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _RemoveCommandToolbarDirective,
    selectors: [["", "kendoGridRemoveTool", ""]],
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RemoveCommandToolbarDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridRemoveTool]",
      standalone: true
    }]
  }], () => [{
    type: EditService
  }, {
    type: ToolBarButtonComponent
  }, {
    type: SelectionService2
  }, {
    type: ContextService
  }, {
    type: NgZone
  }, {
    type: ChangeDetectorRef
  }], null);
})();
var CancelCommandToolbarDirective = class _CancelCommandToolbarDirective extends ToolbarEditingToolBase {
  editService;
  constructor(editService, host, selection, ctx, zone, cdr) {
    super(host, ToolbarToolName.cancel, ctx, zone, cdr, editService, selection);
    this.editService = editService;
  }
  /**
   * @hidden
   */
  onClick(e) {
    e.preventDefault();
    if (this.editService.hasNewItem) {
      this.editService.endEdit();
    } else if (this.isSelectionPresent && this.editService.isEdited(this.lastSelectionIndex)) {
      this.editService.endEdit(this.lastSelectionIndex);
    } else {
      this.editService.editedIndices.forEach((i) => this.editService.endEdit(i.index));
    }
  }
  static ɵfac = function CancelCommandToolbarDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CancelCommandToolbarDirective)(ɵɵdirectiveInject(EditService), ɵɵdirectiveInject(ToolBarButtonComponent), ɵɵdirectiveInject(SelectionService2), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CancelCommandToolbarDirective,
    selectors: [["", "kendoGridCancelTool", ""]],
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CancelCommandToolbarDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridCancelTool]",
      standalone: true
    }]
  }], () => [{
    type: EditService
  }, {
    type: ToolBarButtonComponent
  }, {
    type: SelectionService2
  }, {
    type: ContextService
  }, {
    type: NgZone
  }, {
    type: ChangeDetectorRef
  }], null);
})();
var incrementingId2 = 0;
var GroupCommandToolbarDirective = class _GroupCommandToolbarDirective {
  host;
  popupService;
  ctx;
  ngZone;
  renderer;
  adaptiveGridService;
  popupRef;
  nextId = incrementingId2++;
  toolSubs = new Subscription();
  popupSubs;
  actionSheetCloseSub;
  removeClickListener;
  constructor(host, popupService, ctx, ngZone, renderer, adaptiveGridService) {
    this.host = host;
    this.popupService = popupService;
    this.ctx = ctx;
    this.ngZone = ngZone;
    this.renderer = renderer;
    this.adaptiveGridService = adaptiveGridService;
  }
  ngOnInit() {
    this.toolSubs = this.host.click.subscribe((e) => this.onClick(e));
    this.toolSubs.add(this.ctx.grid.groupChange.subscribe((group2) => {
      this.host.showBadge = this.isGroupingApplied(group2);
    }));
    this.host.hasBadgeContainer = true;
    this.host.showBadge = this.isGroupingApplied(this.ctx.grid.group);
    const hasToolbarIcon = isPresent(this.host.toolbarOptions.icon) && this.host.toolbarOptions.icon !== "";
    const hasOverflowIcon = isPresent(this.host.overflowOptions.icon) && this.host.overflowOptions.icon !== "";
    const hasIcon = hasToolbarIcon && hasOverflowIcon;
    const hasSvgIcon = isPresent(this.host.toolbarOptions.svgIcon) && isPresent(this.host.overflowOptions.svgIcon);
    if (!hasIcon) {
      this.host.icon = "group";
    }
    if (!hasSvgIcon) {
      this.host.svgIcon = groupIcon;
    }
  }
  ngAfterViewInit() {
    if (!isPresent(this.host.text)) {
      this.ngZone.onStable.pipe(take(1)).subscribe(() => {
        this.host.text = this.ctx.localization.get(`groupToolbarToolText`);
      });
    }
    this.buttonElement?.setAttribute("aria-haspopup", "dialog");
    this.buttonElement?.setAttribute("aria-expanded", "false");
    this.buttonElement?.setAttribute("title", this.ctx.localization.get("groupToolbarToolText"));
  }
  ngOnDestroy() {
    if (this.toolSubs) {
      this.toolSubs.unsubscribe();
    }
    if (this.popupSubs) {
      this.popupSubs.unsubscribe();
    }
    if (this.popupRef) {
      this.popupRef.close();
      this.popupRef = null;
    }
    if (this.actionSheetCloseSub) {
      this.actionSheetCloseSub.unsubscribe();
      this.actionSheetCloseSub = null;
    }
    if (this.removeClickListener) {
      this.removeClickListener();
      this.removeClickListener = null;
    }
  }
  onClick(e) {
    e.preventDefault();
    if (this.ctx.grid.adaptiveMode === "auto" && this.adaptiveGridService.windowSize !== "large") {
      if (!this.ctx.grid.isActionSheetExpanded) {
        this.adaptiveGridService.viewType = "groupToolbarTool";
        this.ctx.grid.adaptiveRenderer.actionSheet.toggle(true);
        this.host.selected = true;
        this.actionSheetCloseSub = this.ctx.grid.adaptiveRenderer.actionSheet.collapse.subscribe(() => this.host.selected = false);
      }
    } else {
      if (this.popupRef) {
        this.closePopup();
        return;
      }
      this.openPopup();
    }
  }
  openPopup() {
    const direction = this.ctx.localization.rtl ? "right" : "left";
    this.popupRef = this.popupService.open({
      anchor: this.buttonElement,
      content: GroupToolbarToolComponent,
      popupClass: "k-grid-columnmenu-popup",
      positionMode: "absolute",
      anchorAlign: {
        vertical: "bottom",
        horizontal: direction
      },
      popupAlign: {
        vertical: "top",
        horizontal: direction
      }
    });
    this.adaptiveGridService.popupRef = this.popupRef;
    this.setPopupAttributes();
    this.host.selected = true;
    this.ngZone.runOutsideAngular(() => {
      if (!isDocumentAvailable()) {
        return;
      }
      this.removeClickListener = this.renderer.listen("document", "click", (e) => {
        if (this.popupRef && !closest(e.target, (node) => node === this.popupRef.popupElement || node === this.buttonElement)) {
          this.ngZone.run(() => {
            this.closePopup();
          });
        }
      });
    });
    this.popupSubs = this.popupRef.popup.instance.anchorViewportLeave.subscribe(() => {
      this.popupSubs?.unsubscribe();
      this.popupSubs = null;
      this.closePopup();
    });
    this.initPopupProperties();
  }
  setPopupAttributes() {
    const popupElement = this.popupRef.popupElement;
    const popupId = `k-group-tool-${this.nextId}-popup`;
    const popupAriaElement = popupElement.querySelector(".k-popup");
    this.renderer.setAttribute(popupElement, "dir", this.ctx.localization.rtl ? "rtl" : "ltr");
    this.renderer.setAttribute(popupAriaElement, "id", popupId);
    this.renderer.setAttribute(popupAriaElement, "role", "dialog");
    this.buttonElement?.setAttribute("aria-expanded", "true");
    this.buttonElement?.setAttribute("aria-controls", popupId);
  }
  initPopupProperties() {
    this.popupRef.content.instance.ctx = this.ctx;
    this.popupRef.content.instance.hostButton = this.host;
    this.popupSubs.add(this.popupRef.content.instance.groupClear.subscribe(() => {
      this.closePopup();
    }));
    this.popupSubs.add(this.popupRef.content.instance.close.subscribe(() => {
      this.closePopup();
    }));
  }
  closePopup() {
    this.buttonElement?.setAttribute("aria-expanded", "false");
    this.buttonElement?.removeAttribute("aria-controls");
    this.host.selected = false;
    if (this.popupRef) {
      this.popupRef.close();
      this.popupRef = null;
    }
    if (this.popupSubs) {
      this.popupSubs.unsubscribe();
      this.popupSubs = null;
    }
    if (this.removeClickListener) {
      this.removeClickListener();
      this.removeClickListener = null;
    }
  }
  get buttonElement() {
    return this.host.getButton();
  }
  isGroupingApplied(group2) {
    return isPresent(group2) && group2.length > 0;
  }
  static ɵfac = function GroupCommandToolbarDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _GroupCommandToolbarDirective)(ɵɵdirectiveInject(ToolBarButtonComponent), ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(AdaptiveGridService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _GroupCommandToolbarDirective,
    selectors: [["", "kendoGridGroupTool", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GroupCommandToolbarDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridGroupTool]",
      standalone: true
    }]
  }], () => [{
    type: ToolBarButtonComponent
  }, {
    type: PopupService
  }, {
    type: ContextService
  }, {
    type: NgZone
  }, {
    type: Renderer2
  }, {
    type: AdaptiveGridService
  }], null);
})();
var HighlightDirective = class _HighlightDirective {
  ctx;
  /**
   * Stores the highlighted items keys.
   * @default []
   */
  highlightedKeys = [];
  /**
   * Sets the item key to store in `highlightedKeys`. The Grid uses the row index as the default item key.
   */
  highlightItemKey;
  /**
   * Sets the column key for a data cell. The Grid uses the column index as the default column key.
   */
  highlightColumnKey;
  rowHighlightState = /* @__PURE__ */ new Set();
  cellHighlightState = new PairSet();
  constructor(ctx) {
    this.ctx = ctx;
    this.ctx.highlightDirective = this;
  }
  ngOnChanges(changes) {
    if (isPresent(changes["highlightedKeys"])) {
      this.setState(this.highlightedKeys);
    }
  }
  ngOnDestroy() {
    this.reset();
    this.ctx.highlightDirective = null;
  }
  /**
   * @hidden
   */
  isRowHighlighted(row2) {
    return this.rowHighlightState.has(this.getItemKey(row2));
  }
  /**
   * @hidden
   */
  isCellHighlighted(row2, column, colIndex) {
    const highlightItem = this.getHighlightItem(row2, column, colIndex);
    return this.cellHighlightState.has(highlightItem.itemKey, highlightItem.columnKey);
  }
  getItemKey(row2) {
    if (this.highlightItemKey) {
      if (typeof this.highlightItemKey === "string") {
        return row2.data?.[this.highlightItemKey];
      }
      if (typeof this.highlightItemKey === "function") {
        return this.highlightItemKey(row2);
      }
    }
    return row2.index;
  }
  getHighlightItem(row2, col, colIndex) {
    const itemIdentifiers = {};
    itemIdentifiers.itemKey = this.getItemKey(row2);
    if (!isPresent(col) && !isPresent(colIndex)) {
      return itemIdentifiers;
    }
    if (this.highlightColumnKey) {
      if (typeof this.highlightColumnKey === "string") {
        itemIdentifiers.columnKey = row2.dataItem[this.highlightColumnKey];
      }
      if (typeof this.highlightColumnKey === "function") {
        itemIdentifiers.columnKey = this.highlightColumnKey(col, colIndex);
      }
    }
    return {
      itemKey: itemIdentifiers.itemKey,
      columnKey: itemIdentifiers.columnKey ? itemIdentifiers.columnKey : colIndex
    };
  }
  setState(highlightedKeys) {
    this.reset();
    if (!highlightedKeys || highlightedKeys.length === 0) {
      return;
    }
    const rowHighlights = highlightedKeys.filter((item) => !isPresent(item.columnKey));
    const cellHighlights = highlightedKeys.filter((item) => isPresent(item.columnKey));
    if (cellHighlights.length > 0) {
      this.cellHighlightState = new PairSet(cellHighlights, "itemKey", "columnKey");
    }
    if (rowHighlights.length > 0) {
      rowHighlights.forEach((item) => {
        this.rowHighlightState.add(item.itemKey);
      });
    }
  }
  reset() {
    this.rowHighlightState.clear();
    this.cellHighlightState.clear();
  }
  static ɵfac = function HighlightDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HighlightDirective)(ɵɵdirectiveInject(ContextService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _HighlightDirective,
    selectors: [["", "kendoGridHighlight", ""]],
    inputs: {
      highlightedKeys: "highlightedKeys",
      highlightItemKey: [0, "kendoGridHighlight", "highlightItemKey"],
      highlightColumnKey: "highlightColumnKey"
    },
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HighlightDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridHighlight]",
      standalone: true
    }]
  }], () => [{
    type: ContextService
  }], {
    highlightedKeys: [{
      type: Input
    }],
    highlightItemKey: [{
      type: Input,
      args: ["kendoGridHighlight"]
    }],
    highlightColumnKey: [{
      type: Input
    }]
  });
})();
var DEFAULT_AI_REQUEST_OPTIONS = {
  headers: new HttpHeaders({
    "Content-Type": "application/json"
  }),
  role: "user",
  method: "POST",
  responseType: "json"
};
var GridAIAssistantResponseSuccessEvent = class extends PreventableEvent {
  /**
   * The HTTP response from the AI service.
   */
  response;
  constructor(response) {
    super();
    this.response = response;
  }
};
var GridAIAssistantResponseErrorEvent = class extends PreventableEvent {
  /**
   * The HTTP error response from the AI service.
   */
  error;
  constructor(error) {
    super();
    this.error = error;
  }
};
var AiAssistantComponent = class _AiAssistantComponent {
  http;
  ctx;
  columnInfoService;
  zone;
  aiRequestResponseService;
  aiPrompt;
  activeView = 0;
  requestUrl;
  requestOptions;
  aiPromptSettings;
  aiToolDirective;
  streaming = false;
  disabledGenerateButton = false;
  lastMessage;
  requestData;
  currentRequestSubscription = null;
  //Remove this when the AI Assistant has a built-in loading indicator
  loadingOutput = {
    id: "k-loading-item",
    output: "",
    prompt: ""
  };
  // flat columns used for highlight utilities (expects { field })
  columns = [];
  leafColumns = [];
  idCounter = 0;
  constructor(http, ctx, columnInfoService, zone, aiRequestResponseService) {
    this.http = http;
    this.ctx = ctx;
    this.columnInfoService = columnInfoService;
    this.zone = zone;
    this.aiRequestResponseService = aiRequestResponseService;
  }
  ngAfterViewInit() {
    this.leafColumns = this.columnInfoService.leafNamedColumns || [];
    this.columns = this.leafColumns.map((col) => ({
      field: col.field
    }));
  }
  ngOnDestroy() {
    this.unsubscribeCurrentRequest();
  }
  message(message) {
    return this.ctx.localization.get(message);
  }
  cancelRequest() {
    this.aiToolDirective.cancelRequest.emit();
    this.unsubscribeCurrentRequest();
    this.streaming = false;
  }
  onPromptRequest(ev) {
    if (this.aiToolDirective.promptOutputs.length === 0) {
      this.aiToolDirective.promptOutputs.push(this.loadingOutput);
    }
    this.unsubscribeCurrentRequest();
    this.streaming = true;
    this.activeView = 1;
    if (ev.prompt) {
      this.lastMessage = ev.prompt;
    }
    this.requestData = {
      columns: [],
      // Will be populated by service
      promptMessage: ev.prompt,
      url: this.requestUrl,
      requestOptions: __spreadValues({}, this.requestOptions)
    };
    if (!this.requestOptions.body) {
      this.requestData.requestOptions.body = this.aiRequestResponseService.buildRequestBody(this.requestData.promptMessage, this.requestData.requestOptions.role);
    }
    this.aiToolDirective.promptRequest.emit({
      requestData: this.requestData,
      isRetry: ev.isRetry
    });
    if (!this.requestUrl) {
      return;
    }
    this.currentRequestSubscription = this.sendPromptRequest().subscribe((res) => {
      if (res.body) {
        this.processResponse(res);
        this.streaming = false;
      }
      this.currentRequestSubscription = null;
    }, (error) => {
      this.handleError(error);
      this.streaming = false;
      this.currentRequestSubscription = null;
    });
  }
  sendPromptRequest() {
    const request = new HttpRequest(this.requestData.requestOptions.method, this.requestData.url, this.requestData.requestOptions.body, this.requestData.requestOptions);
    return this.http.request(request);
  }
  processResponse(response) {
    if (this.aiToolDirective.autoClose) {
      this.aiToolDirective.emitOpenClose = true;
      this.aiToolDirective.toggleWindow();
    }
    const responseBody = response.body || {
      commands: []
    };
    const responseSuccessEvent = new GridAIAssistantResponseSuccessEvent(response);
    this.aiToolDirective.responseSuccess.emit(responseSuccessEvent);
    if (responseSuccessEvent.isDefaultPrevented()) {
      this.deleteLoadingOutput();
      return;
    }
    const messages = [];
    if (responseBody.message) {
      messages.push(responseBody.message);
    }
    const commandMessages = this.aiRequestResponseService.processCommands(responseBody.commands || [], this.columns, this.leafColumns);
    messages.push(...commandMessages);
    const responseContentStart = [`${this.ctx.localization.get("aiAssistantOutputCardBodyContent")} 
`];
    const responseContentBody = messages.map((output2, idx4) => `${idx4 + 1} ${output2}`).join("\n");
    const output = {
      id: this.idCounter++,
      title: this.ctx.localization.get("aiAssistantOutputCardTitle"),
      prompt: this.lastMessage,
      output: responseContentStart.concat(responseContentBody).join("")
    };
    this.deleteLoadingOutput();
    this.aiToolDirective.promptOutputs.unshift(output);
  }
  handleError(error) {
    const responseErrorEvent = new GridAIAssistantResponseErrorEvent(error);
    this.aiToolDirective.responseError.emit(responseErrorEvent);
    if (responseErrorEvent.isDefaultPrevented()) {
      this.deleteLoadingOutput();
      return;
    }
    const output = {
      id: this.idCounter++,
      prompt: this.lastMessage,
      output: error.message
    };
    this.deleteLoadingOutput();
    this.aiToolDirective.promptOutputs.unshift(output);
  }
  deleteLoadingOutput() {
    if (this.aiToolDirective.promptOutputs[0]?.id === this.loadingOutput.id) {
      this.aiToolDirective.promptOutputs.splice(0, 1);
    }
  }
  unsubscribeCurrentRequest() {
    if (this.currentRequestSubscription) {
      this.currentRequestSubscription.unsubscribe();
      this.currentRequestSubscription = null;
    }
  }
  static ɵfac = function AiAssistantComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AiAssistantComponent)(ɵɵdirectiveInject(HttpClient), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ColumnInfoService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(GridAIRequestResponseService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _AiAssistantComponent,
    selectors: [["ng-component"]],
    viewQuery: function AiAssistantComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(AIPromptComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.aiPrompt = _t.first);
      }
    },
    decls: 8,
    vars: 13,
    consts: [["aiPrompt", ""], ["promptView", ""], [3, "activeViewChange", "promptRequest", "promptRequestCancel", "promptSuggestions", "showOutputRating", "streaming", "speechToTextButton", "activeView", "generateButtonSVGIcon", "generateButtonIcon", "disabledGenerateButton", "promptOutputs", "textAreaSettings"], ["kendoAIPromptOutputTemplate", ""], ["kendoAIPromptOutputBodyTemplate", ""], [3, "generateOutput"], [1, "k-card"], [1, "k-card-header"], [1, "k-card-title"], [1, "k-skeleton", "k-skeleton-text", "k-skeleton-pulse"], [1, "k-card-subtitle"], [1, "k-skeleton", "k-skeleton-text", "k-skeleton-pulse", 2, "width", "100%"], [1, "k-card-body"], [1, "k-skeleton", "k-skeleton-rect", "k-skeleton-pulse", 2, "height", "80px"], [1, "k-card-actions"]],
    template: function AiAssistantComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "kendo-aiprompt", 2, 0);
        ɵɵtwoWayListener("activeViewChange", function AiAssistantComponent_Template_kendo_aiprompt_activeViewChange_0_listener($event) {
          ɵɵrestoreView(_r1);
          ɵɵtwoWayBindingSet(ctx.activeView, $event) || (ctx.activeView = $event);
          return ɵɵresetView($event);
        });
        ɵɵlistener("promptRequest", function AiAssistantComponent_Template_kendo_aiprompt_promptRequest_0_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onPromptRequest($event));
        })("promptRequestCancel", function AiAssistantComponent_Template_kendo_aiprompt_promptRequestCancel_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.cancelRequest());
        });
        ɵɵelement(2, "kendo-aiprompt-prompt-view", null, 1)(4, "kendo-aiprompt-output-view");
        ɵɵconditionalCreate(5, AiAssistantComponent_Conditional_5_Template, 1, 0, null, 3);
        ɵɵconditionalCreate(6, AiAssistantComponent_Conditional_6_Template, 1, 0, null, 4);
        ɵɵelement(7, "kendo-aiprompt-messages", 5);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        let tmp_12_0;
        let tmp_13_0;
        const aiPrompt_r3 = ɵɵreference(1);
        const promptView_r4 = ɵɵreference(3);
        ɵɵproperty("promptSuggestions", ctx.aiPromptSettings == null ? null : ctx.aiPromptSettings.promptSuggestions)("showOutputRating", ctx.aiPromptSettings == null ? null : ctx.aiPromptSettings.showOutputRating)("streaming", ctx.streaming)("speechToTextButton", ctx.aiPromptSettings == null ? null : ctx.aiPromptSettings.speechToTextButton);
        ɵɵtwoWayProperty("activeView", ctx.activeView);
        ɵɵproperty("generateButtonSVGIcon", ctx.aiPromptSettings == null ? null : ctx.aiPromptSettings.generateButtonSVGIcon)("generateButtonIcon", ctx.aiPromptSettings == null ? null : ctx.aiPromptSettings.generateButtonIcon)("disabledGenerateButton", ctx.disabledGenerateButton || (promptView_r4.textAreaValue == null ? null : promptView_r4.textAreaValue.length) === 0)("promptOutputs", ctx.aiPromptSettings == null ? null : ctx.aiPromptSettings.promptOutputs)("textAreaSettings", ctx.aiPromptSettings == null ? null : ctx.aiPromptSettings.textAreaSettings);
        ɵɵadvance(5);
        ɵɵconditional((tmp_12_0 = ctx.streaming && aiPrompt_r3.streaming) ? 5 : -1, tmp_12_0);
        ɵɵadvance();
        ɵɵconditional((tmp_13_0 = !(ctx.streaming && aiPrompt_r3.streaming)) ? 6 : -1, tmp_13_0);
        ɵɵadvance();
        ɵɵproperty("generateOutput", ctx.message("aiAssistantApplyButtonText"));
      }
    },
    dependencies: [AIPromptComponent, AIPromptCustomMessagesComponent, PromptViewComponent, OutputViewComponent, AIPromptOutputTemplateDirective, AIPromptOutputBodyTemplateDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AiAssistantComponent, [{
    type: Component,
    args: [{
      standalone: true,
      imports: [AIPromptComponent, AIPromptCustomMessagesComponent, PromptViewComponent, OutputViewComponent, AIPromptOutputTemplateDirective, AIPromptOutputBodyTemplateDirective],
      template: `
        <kendo-aiprompt
          #aiPrompt
          [promptSuggestions]="aiPromptSettings?.promptSuggestions"
          [showOutputRating]="aiPromptSettings?.showOutputRating"
          [streaming]="streaming"
          [speechToTextButton]="aiPromptSettings?.speechToTextButton"
          [(activeView)]="activeView"
          [generateButtonSVGIcon]="aiPromptSettings?.generateButtonSVGIcon"
          [generateButtonIcon]="aiPromptSettings?.generateButtonIcon"
          [disabledGenerateButton]="disabledGenerateButton || promptView.textAreaValue?.length === 0"
          [promptOutputs]="aiPromptSettings?.promptOutputs"
          [textAreaSettings]="aiPromptSettings?.textAreaSettings"
          (promptRequest)="onPromptRequest($event)"
          (promptRequestCancel)="cancelRequest()"
          >
          <kendo-aiprompt-prompt-view #promptView></kendo-aiprompt-prompt-view>
          <kendo-aiprompt-output-view></kendo-aiprompt-output-view>
          @if (streaming && aiPrompt.streaming; as output) {
            <ng-template kendoAIPromptOutputTemplate let-output>
              <div class="k-card">
                <div class="k-card-header">
                  <div class="k-card-title">
                    <span class="k-skeleton k-skeleton-text k-skeleton-pulse" [style.width.px]="200"></span>
                  </div>
                  <div class="k-card-subtitle">
                    <span class="k-skeleton k-skeleton-text k-skeleton-pulse" style="width: 100%;"></span>
                  </div>
                </div>
                <div class="k-card-body">
                  <span class="k-skeleton k-skeleton-rect k-skeleton-pulse" style="height: 80px;"></span>
                </div>
                <div class="k-card-actions">
                  <span class="k-skeleton k-skeleton-text k-skeleton-pulse" style="width: 100%;"></span>
                </div>
              </div>
            </ng-template>
          }
          @if (!(streaming && aiPrompt.streaming); as output) {
            <ng-template kendoAIPromptOutputBodyTemplate let-output>
              <p>{{output.output}}</p>
            </ng-template>
          }
          <kendo-aiprompt-messages
            [generateOutput]="message('aiAssistantApplyButtonText')"
          ></kendo-aiprompt-messages>
        </kendo-aiprompt>
        `
    }]
  }], () => [{
    type: HttpClient
  }, {
    type: ContextService
  }, {
    type: ColumnInfoService
  }, {
    type: NgZone
  }, {
    type: GridAIRequestResponseService
  }], {
    aiPrompt: [{
      type: ViewChild,
      args: [AIPromptComponent]
    }]
  });
})();
var AIAssistantToolbarDirective = class _AIAssistantToolbarDirective extends ToolbarToolBase {
  windowService;
  host;
  ctx;
  zone;
  refresh;
  /**
   * The URL to which the AI Assistant tool sends the AI request.
   * - When you set this property, the AI Assistant tool sends and handles an HTTP request to the provided `requestUrl`. You can handle the `promptRequest` event to modify the request options before the tool sends it.
   * - When you do not set this property, the AI Assistant tool does not send an HTTP request. You should handle the `promptRequest` event to send and handle a custom HTTP request.
   */
  requestUrl;
  /**
   * Configures the request options that the AI Assistant tool sends with the AI request.
   *
   * @default { headers: new HttpHeaders({ 'Content-Type': 'application/json' }), role: 'user', method: 'POST', responseType: 'json', withCredentials: false }
   */
  requestOptions;
  /**
   * Configures the initial settings for the AI Assistant Window when opened.
   */
  aiWindowSettings;
  /**
   * Configures the initial settings for the AI Prompt component that the AI Assistant Window component uses when opened.
   */
  aiPromptSettings;
  /**
   * Determines whether to close the AI Assistant Window automatically after a successful request.
   * @default true
   */
  autoClose = true;
  /**
   * Determines whether to keep the AI Prompt's outputs after closing the AI Assistant Window.
   * @default false
   */
  keepOutputHistory = false;
  /**
   * Emits an event before the AI Assistant tool sends the AI request.
   *  - When you provide a `requestUrl`, you can handle the event to modify the request options.
   *  - When you do not provide a `requestUrl`, you can handle the event to perform an entirely custom request.
   */
  promptRequest = new EventEmitter();
  /**
   * Emits an event when the user clicks the cancel button.
   */
  cancelRequest = new EventEmitter();
  /**
   * Emits an event when the AI Assistant tool completes the AI request successfully.
   * The event contains the response from the AI service and is preventable to allow stopping the default response handling.
   */
  responseSuccess = new EventEmitter();
  /**
   * Emits an event when the AI Assistant tool completes the AI request with an error.
   * The event contains the error response from the AI service and is preventable to allow stopping the default error handling.
   */
  responseError = new EventEmitter();
  /**
   * Emits an event when the AI Assistant tool closes.
   */
  close = new EventEmitter();
  /**
   * Emits an event when the AI Assistant tool opens.
   */
  open = new EventEmitter();
  tableWizardIcon = tableWizardIcon;
  emitOpenClose = false;
  promptOutputs = [];
  windowRef;
  subs = new Subscription();
  defaultAiPromptSettings = {
    speechToTextButton: true,
    generateButtonSVGIcon: this.tableWizardIcon,
    generateButtonIcon: "table-wizard"
  };
  constructor(windowService, host, ctx, zone, refresh, cdr) {
    super(host, ToolbarToolName.aiAssistant, ctx, zone, cdr);
    this.windowService = windowService;
    this.host = host;
    this.ctx = ctx;
    this.zone = zone;
    this.refresh = refresh;
    this.host.rounded = "full";
    this.host.themeColor = "primary";
    this.host.showText = "never";
  }
  ngOnInit() {
    this.subs.add(this.host.click.subscribe(() => this.onClick()));
    const hasToolbarIcon = isPresent(this.host.toolbarOptions.icon) && this.host.toolbarOptions.icon !== "";
    const hasOverflowIcon = isPresent(this.host.overflowOptions.icon) && this.host.overflowOptions.icon !== "";
    const hasIcon = hasToolbarIcon && hasOverflowIcon;
    const hasSvgIcon = isPresent(this.host.toolbarOptions.svgIcon) && isPresent(this.host.overflowOptions.svgIcon);
    if (!hasIcon) {
      this.host.icon = "sparkles";
    }
    if (!hasSvgIcon) {
      this.host.svgIcon = sparklesIcon;
    }
    this.requestOptions = __spreadValues(__spreadValues({}, DEFAULT_AI_REQUEST_OPTIONS), this.requestOptions);
  }
  ngAfterViewInit() {
    super.ngAfterViewInit();
    this.zone.onStable.pipe(take(1)).subscribe(() => {
      this.buttonElement?.setAttribute("aria-haspopup", "dialog");
      this.buttonElement?.setAttribute("aria-expanded", "false");
      const needsTitle = this.host.showText !== "always" && this.host.showText !== "toolbar";
      if (needsTitle && !this.host.title) {
        this.buttonElement?.setAttribute("title", this.ctx.localization.get("aiAssistantToolbarToolText"));
      }
    });
    this.subs.add(this.refresh.onRefresh.pipe(filter((tool) => tool === this.host)).subscribe((tool) => {
      if (tool.overflows && this.windowRef) {
        this.windowRef.close();
      }
    }));
  }
  ngOnDestroy() {
    super.ngOnDestroy();
    this.subs.unsubscribe();
    this.promptOutputs = [];
  }
  /**
   * @hidden
   */
  onClick() {
    this.emitOpenClose = true;
    this.toggleWindow();
  }
  /**
   * Toggles the AI Assistant window.
   */
  toggleWindow() {
    if (!this.windowRef) {
      this.openWindow();
    } else {
      this.closeWindow();
    }
  }
  openWindow() {
    if (!this.keepOutputHistory) {
      this.promptOutputs = [];
    }
    const defaultWindowWidth = 437;
    const rtl = this.ctx.localization.rtl;
    const defaultWindowSettings = {
      left: rtl ? this.buttonElement.offsetLeft - (this.aiWindowSettings.width || defaultWindowWidth) : this.buttonElement.offsetLeft + this.buttonElement.offsetWidth,
      top: this.buttonElement.offsetTop + this.buttonElement.offsetHeight,
      width: defaultWindowWidth,
      title: this.ctx.localization.get("aiAssistantWindowTitle"),
      cssClass: "k-grid-assistant-window",
      content: AiAssistantComponent,
      autoFocusedElement: ".k-input-inner",
      appendTo: this.ctx.grid.windowContainer
    };
    this.aiWindowSettings = __spreadValues(__spreadValues({}, defaultWindowSettings), this.aiWindowSettings);
    this.windowRef = this.windowService.open(this.aiWindowSettings);
    this.windowRef.window.instance.messages = {
      closeTitle: this.ctx.localization.get("aiAssistantWindowCloseTitle"),
      maximizeTitle: this.ctx.localization.get("aiAssistantWindowMaximizeTitle"),
      minimizeTitle: this.ctx.localization.get("aiAssistantWindowMinimizeTitle"),
      restoreTitle: this.ctx.localization.get("aiAssistantWindowRestoreTitle")
    };
    const aiPrompt = this.windowRef.content.instance;
    aiPrompt.requestUrl = this.requestUrl;
    aiPrompt.requestOptions = this.requestOptions;
    aiPrompt.aiToolDirective = this;
    aiPrompt.disabledGenerateButton = this.aiPromptSettings?.disabledGenerateButton;
    aiPrompt.streaming = this.aiPromptSettings?.streaming || false;
    aiPrompt.activeView = this.aiPromptSettings?.activeView || 0;
    aiPrompt.aiPromptSettings = __spreadValues(__spreadValues({}, this.defaultAiPromptSettings), this.aiPromptSettings);
    if (!aiPrompt.aiPromptSettings.promptOutputs) {
      aiPrompt.aiPromptSettings.promptOutputs = this.promptOutputs;
    }
    if (this.emitOpenClose) {
      this.zone.onStable.pipe(take(1)).subscribe(() => {
        const event = {
          aiWindow: this.windowRef.window.instance,
          aiPrompt: this.windowRef.content.instance.aiPrompt
        };
        this.open.emit(event);
        this.emitOpenClose = false;
      });
    }
    this.subs.add(this.windowRef.window.instance.close.subscribe(() => {
      this.emitOpenClose = true;
      this.closeWindow(true);
    }));
    this.host.selected = true;
  }
  closeWindow(focusAnchor = false) {
    this.windowRef.close();
    if (this.emitOpenClose) {
      this.close.emit();
      this.emitOpenClose = false;
    }
    this.windowRef = null;
    this.buttonElement?.setAttribute("aria-expanded", "false");
    this.buttonElement?.removeAttribute("aria-controls");
    this.host.selected = false;
    focusAnchor && this.buttonElement?.focus();
  }
  static ɵfac = function AIAssistantToolbarDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AIAssistantToolbarDirective)(ɵɵdirectiveInject(WindowService), ɵɵdirectiveInject(ToolBarButtonComponent), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(RefreshService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _AIAssistantToolbarDirective,
    selectors: [["", "kendoGridAIAssistantTool", ""]],
    inputs: {
      requestUrl: "requestUrl",
      requestOptions: "requestOptions",
      aiWindowSettings: "aiWindowSettings",
      aiPromptSettings: "aiPromptSettings",
      autoClose: "autoClose",
      keepOutputHistory: "keepOutputHistory"
    },
    outputs: {
      promptRequest: "promptRequest",
      cancelRequest: "cancelRequest",
      responseSuccess: "responseSuccess",
      responseError: "responseError",
      close: "close",
      open: "open"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AIAssistantToolbarDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridAIAssistantTool]",
      standalone: true
    }]
  }], () => [{
    type: WindowService
  }, {
    type: ToolBarButtonComponent
  }, {
    type: ContextService
  }, {
    type: NgZone
  }, {
    type: RefreshService
  }, {
    type: ChangeDetectorRef
  }], {
    requestUrl: [{
      type: Input
    }],
    requestOptions: [{
      type: Input
    }],
    aiWindowSettings: [{
      type: Input
    }],
    aiPromptSettings: [{
      type: Input
    }],
    autoClose: [{
      type: Input
    }],
    keepOutputHistory: [{
      type: Input
    }],
    promptRequest: [{
      type: Output
    }],
    cancelRequest: [{
      type: Output
    }],
    responseSuccess: [{
      type: Output
    }],
    responseError: [{
      type: Output
    }],
    close: [{
      type: Output
    }],
    open: [{
      type: Output
    }]
  });
})();
var SelectAllToolbarToolComponent = class _SelectAllToolbarToolComponent extends ToolBarToolComponent {
  idService;
  ctx;
  constructor(idService, ctx) {
    super();
    this.idService = idService;
    this.ctx = ctx;
  }
  /**
   * @hidden
   */
  selectAllCheckboxId() {
    return this.idService.selectAllCheckboxId();
  }
  /**
   * @hidden
   */
  get selectAllCheckboxLabel() {
    return this.ctx.localization.get("selectAllCheckboxLabel");
  }
  static ɵfac = function SelectAllToolbarToolComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SelectAllToolbarToolComponent)(ɵɵdirectiveInject(IdService), ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _SelectAllToolbarToolComponent,
    selectors: [["kendo-grid-select-all-tool"]],
    features: [ɵɵProvidersFeature([{
      provide: ToolBarToolComponent,
      useExisting: forwardRef(() => _SelectAllToolbarToolComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 4,
    vars: 0,
    consts: [["toolbarTemplate", "", "sectionTemplate", "", "popupTemplate", ""], ["checkbox", ""], ["size", "large", "kendoGridSelectAllCheckbox", "", "kendoGridFocusable", "", 3, "inputAttributes"], [1, "k-checkbox-label", 3, "for"]],
    template: function SelectAllToolbarToolComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, SelectAllToolbarToolComponent_ng_template_0_Template, 4, 6, "ng-template", null, 0, ɵɵtemplateRefExtractor);
      }
    },
    dependencies: [CheckBoxComponent, SelectAllCheckboxDirective, FocusableDirective, LabelDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectAllToolbarToolComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: ToolBarToolComponent,
        useExisting: forwardRef(() => SelectAllToolbarToolComponent)
      }],
      selector: "kendo-grid-select-all-tool",
      template: `
        <ng-template #toolbarTemplate #sectionTemplate #popupTemplate>
            <kendo-checkbox #checkbox
                [attr.id]="selectAllCheckboxId()"
                size="large"
                [inputAttributes]="{'aria-label': selectAllCheckboxLabel}"
                kendoGridSelectAllCheckbox
                kendoGridFocusable
            ></kendo-checkbox>
            <label class="k-checkbox-label" [for]="checkbox.focusableId">{{selectAllCheckboxLabel}}</label>
        </ng-template>
    `,
      standalone: true,
      imports: [CheckBoxComponent, SelectAllCheckboxDirective, FocusableDirective, LabelDirective]
    }]
  }], () => [{
    type: IdService
  }, {
    type: ContextService
  }], null);
})();
var KENDO_GRID_COLUMN_DRAGANDDROP = [DraggableColumnDirective, DropTargetDirective];
var KENDO_GRID_SHARED = [ColumnComponent2, ColumnGroupComponent2, LogicalCellDirective, LogicalRowDirective, FocusableDirective, FooterTemplateDirective3, ColGroupComponent, ResizableContainerDirective, TemplateContextDirective, FieldAccessorPipe, DetailTemplateDirective, SpanColumnComponent, LoadingComponent, GridTableDirective];
var KENDO_GRID_GROUP_EXPORTS = [GroupHeaderTemplateDirective2, GroupHeaderColumnTemplateDirective2, GroupFooterTemplateDirective2, GroupHeaderComponent, GroupPanelComponent];
var KENDO_GRID_FILTER_OPERATORS = [FilterCellOperatorsComponent, ContainsFilterOperatorComponent, DoesNotContainFilterOperatorComponent, EndsWithFilterOperatorComponent, EqualFilterOperatorComponent, IsEmptyFilterOperatorComponent, IsNotEmptyFilterOperatorComponent, IsNotNullFilterOperatorComponent, IsNullFilterOperatorComponent, NotEqualFilterOperatorComponent, StartsWithFilterOperatorComponent, GreaterFilterOperatorComponent, GreaterOrEqualToFilterOperatorComponent, LessFilterOperatorComponent, LessOrEqualToFilterOperatorComponent, AfterFilterOperatorComponent, AfterEqFilterOperatorComponent, BeforeEqFilterOperatorComponent, BeforeFilterOperatorComponent];
var KENDO_GRID_FILTER_SHARED = [...KENDO_GRID_SHARED, ...KENDO_GRID_FILTER_OPERATORS, FilterInputDirective];
var KENDO_GRID_FILTER_MENU_EXPORTS = [FilterMenuComponent, FilterMenuContainerComponent, FilterMenuInputWrapperComponent, StringFilterMenuInputComponent, StringFilterMenuComponent, FilterMenuTemplateDirective, NumericFilterMenuComponent, NumericFilterMenuInputComponent, DateFilterMenuInputComponent, DateFilterMenuComponent, FilterMenuHostDirective, BooleanFilterMenuComponent, FilterMenuDropDownListDirective, BooleanFilterRadioButtonDirective];
var KENDO_GRID_FILTER_MENU = [...KENDO_GRID_FILTER_SHARED, ...KENDO_GRID_FILTER_MENU_EXPORTS];
var KENDO_GRID_FILTER_ROW_EXPORTS = [FilterRowComponent, FilterCellComponent, FilterCellTemplateDirective, StringFilterCellComponent, NumericFilterCellComponent, AutoCompleteFilterCellComponent, BooleanFilterCellComponent, FilterCellHostDirective, FilterCellWrapperComponent, DateFilterCellComponent];
var KENDO_GRID_FILTER_ROW = [...KENDO_GRID_FILTER_ROW_EXPORTS, ...KENDO_GRID_FILTER_SHARED];
var KENDO_GRID_COLUMN_MENU_DECLARATIONS = [ColumnListComponent, ColumnChooserComponent, ColumnChooserToolbarDirective, ColumnMenuChooserComponent, ColumnMenuFilterComponent, ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, ColumnMenuSortComponent, ColumnMenuComponent, ColumnMenuLockComponent, ColumnMenuTemplateDirective, ColumnMenuContainerComponent, ColumnMenuItemDirective, ColumnMenuStickComponent, ColumnMenuPositionComponent, ColumnMenuAutoSizeColumnComponent, ColumnMenuAutoSizeAllColumnsComponent];
var KENDO_GRID_COLUMN_MENU_EXPORTS = [ColumnChooserComponent, ColumnChooserToolbarDirective, ColumnMenuFilterComponent, ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, ColumnMenuSortComponent, ColumnMenuLockComponent, ColumnMenuStickComponent, ColumnMenuPositionComponent, ColumnMenuChooserComponent, ColumnMenuTemplateDirective, ColumnMenuContainerComponent, ColumnMenuItemDirective, ColumnMenuComponent, ColumnMenuAutoSizeColumnComponent, ColumnMenuAutoSizeAllColumnsComponent];
var KENDO_GRID_HEADER_EXPORTS = [HeaderComponent2, HeaderTemplateDirective2, ColumnHandleDirective, SelectAllCheckboxDirective];
var KENDO_GRID_FOOTER_EXPORTS = [FooterComponent2];
var KENDO_GRID_BODY_EXPORTS = [CommandColumnComponent, CheckboxColumnComponent, SelectionCheckboxDirective, CellTemplateDirective2, EditTemplateDirective, RowDragHandleTemplateDirective, RowDragHintTemplateDirective, TableBodyComponent, NoRecordsTemplateDirective, CellComponent, EditCommandDirective, CancelCommandDirective, SaveCommandDirective, RemoveCommandDirective, AddCommandDirective, AddCommandToolbarDirective, EditCommandToolbarDirective, SaveCommandToolbarDirective, RemoveCommandToolbarDirective, CancelCommandToolbarDirective, CellLoadingTemplateDirective, LoadingTemplateDirective, RowReorderColumnComponent, SortCommandToolbarDirective, FilterCommandToolbarDirective, AIAssistantToolbarDirective, GroupCommandToolbarDirective, SelectAllToolbarToolComponent];
var KENDO_GRID_DECLARATIONS = [GridComponent, ListComponent2, ToolbarComponent, LocalizedMessagesDirective7, CustomMessagesComponent5, DataBindingDirective, ToolbarTemplateDirective, SelectionDirective, HighlightDirective, TemplateEditingDirective, ReactiveEditingDirective, InCellEditingDirective, ExternalEditingDirective, ExpandDetailsDirective, ExpandGroupDirective, GridMarqueeDirective, GridSpacerComponent, GridToolbarFocusableDirective, StatusBarComponent, StatusBarTemplateDirective, GridClipboardDirective, FormComponent, DialogFormComponent, FormFormFieldComponent, UndoRedoDirective];
var KENDO_GRID_EXPORTS = [GridComponent, ToolbarTemplateDirective, ToolbarComponent, GridSpacerComponent, StatusBarTemplateDirective, DataBindingDirective, SelectionDirective, HighlightDirective, CustomMessagesComponent5, TemplateEditingDirective, ReactiveEditingDirective, InCellEditingDirective, ExternalEditingDirective, ExpandDetailsDirective, ExpandGroupDirective, GridToolbarFocusableDirective, ...KENDO_GRID_GROUP_EXPORTS, ...KENDO_GRID_SHARED, ...KENDO_GRID_BODY_EXPORTS, ...KENDO_GRID_HEADER_EXPORTS, ...KENDO_GRID_FILTER_ROW_EXPORTS, ...KENDO_GRID_FILTER_OPERATORS, ...KENDO_GRID_FILTER_MENU_EXPORTS, ...KENDO_GRID_COLUMN_MENU_EXPORTS, GridClipboardDirective, UndoRedoDirective, UndoCommandToolbarDirective, RedoCommandToolbarDirective];
var KENDO_GRID_EXCEL_EXPORT = [ExcelComponent, ExcelCommandDirective, ExcelCommandToolbarDirective, ColumnComponent, ColumnGroupComponent, FooterTemplateDirective, GroupFooterTemplateDirective, GroupHeaderColumnTemplateDirective, GroupHeaderTemplateDirective];
var KENDO_GRID_PDF_EXPORT = [PDFComponent, PDFMarginComponent, PDFCommandDirective, PDFTemplateDirective, PDFCommandToolbarDirective];
var KENDO_GRID = [...KENDO_GRID_EXPORTS, ...KENDO_GRID_EXCEL_EXPORT, ...KENDO_GRID_PDF_EXPORT];
var GridModule = class _GridModule {
  static ɵfac = function GridModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _GridModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _GridModule,
    imports: [GroupHeaderTemplateDirective2, GroupHeaderColumnTemplateDirective2, GroupFooterTemplateDirective2, GroupHeaderComponent, GroupPanelComponent, ColumnComponent2, ColumnGroupComponent2, LogicalCellDirective, LogicalRowDirective, FocusableDirective, FooterTemplateDirective3, ColGroupComponent, ResizableContainerDirective, TemplateContextDirective, FieldAccessorPipe, DetailTemplateDirective, SpanColumnComponent, LoadingComponent, GridTableDirective, CommandColumnComponent, CheckboxColumnComponent, SelectionCheckboxDirective, CellTemplateDirective2, EditTemplateDirective, RowDragHandleTemplateDirective, RowDragHintTemplateDirective, TableBodyComponent, NoRecordsTemplateDirective, CellComponent, EditCommandDirective, CancelCommandDirective, SaveCommandDirective, RemoveCommandDirective, AddCommandDirective, AddCommandToolbarDirective, EditCommandToolbarDirective, SaveCommandToolbarDirective, RemoveCommandToolbarDirective, CancelCommandToolbarDirective, CellLoadingTemplateDirective, LoadingTemplateDirective, RowReorderColumnComponent, SortCommandToolbarDirective, FilterCommandToolbarDirective, AIAssistantToolbarDirective, GroupCommandToolbarDirective, SelectAllToolbarToolComponent, HeaderComponent2, HeaderTemplateDirective2, ColumnHandleDirective, SelectAllCheckboxDirective, FooterComponent2, CustomMessagesComponent, PagerFocusableDirective, PagerInfoComponent, PagerInputComponent, PagerNextButtonsComponent, PagerNumericButtonsComponent, PagerPageSizesComponent, PagerPrevButtonsComponent, PagerTemplateDirective, PagerComponent, PagerSpacerComponent, ToolBarComponent, ToolbarCustomMessagesComponent, ToolBarButtonComponent, ToolBarButtonGroupComponent, ToolBarDropDownButtonComponent, ToolBarSeparatorComponent, ToolBarSpacerComponent, ToolBarSplitButtonComponent, ToolBarToolComponent, FilterRowComponent, FilterCellComponent, FilterCellTemplateDirective, StringFilterCellComponent, NumericFilterCellComponent, AutoCompleteFilterCellComponent, BooleanFilterCellComponent, FilterCellHostDirective, FilterCellWrapperComponent, DateFilterCellComponent, ColumnComponent2, ColumnGroupComponent2, LogicalCellDirective, LogicalRowDirective, FocusableDirective, FooterTemplateDirective3, ColGroupComponent, ResizableContainerDirective, TemplateContextDirective, FieldAccessorPipe, DetailTemplateDirective, SpanColumnComponent, LoadingComponent, GridTableDirective, FilterCellOperatorsComponent, ContainsFilterOperatorComponent, DoesNotContainFilterOperatorComponent, EndsWithFilterOperatorComponent, EqualFilterOperatorComponent, IsEmptyFilterOperatorComponent, IsNotEmptyFilterOperatorComponent, IsNotNullFilterOperatorComponent, IsNullFilterOperatorComponent, NotEqualFilterOperatorComponent, StartsWithFilterOperatorComponent, GreaterFilterOperatorComponent, GreaterOrEqualToFilterOperatorComponent, LessFilterOperatorComponent, LessOrEqualToFilterOperatorComponent, AfterFilterOperatorComponent, AfterEqFilterOperatorComponent, BeforeEqFilterOperatorComponent, BeforeFilterOperatorComponent, FilterInputDirective, ColumnComponent2, ColumnGroupComponent2, LogicalCellDirective, LogicalRowDirective, FocusableDirective, FooterTemplateDirective3, ColGroupComponent, ResizableContainerDirective, TemplateContextDirective, FieldAccessorPipe, DetailTemplateDirective, SpanColumnComponent, LoadingComponent, GridTableDirective, FilterCellOperatorsComponent, ContainsFilterOperatorComponent, DoesNotContainFilterOperatorComponent, EndsWithFilterOperatorComponent, EqualFilterOperatorComponent, IsEmptyFilterOperatorComponent, IsNotEmptyFilterOperatorComponent, IsNotNullFilterOperatorComponent, IsNullFilterOperatorComponent, NotEqualFilterOperatorComponent, StartsWithFilterOperatorComponent, GreaterFilterOperatorComponent, GreaterOrEqualToFilterOperatorComponent, LessFilterOperatorComponent, LessOrEqualToFilterOperatorComponent, AfterFilterOperatorComponent, AfterEqFilterOperatorComponent, BeforeEqFilterOperatorComponent, BeforeFilterOperatorComponent, FilterInputDirective, FilterMenuComponent, FilterMenuContainerComponent, FilterMenuInputWrapperComponent, StringFilterMenuInputComponent, StringFilterMenuComponent, FilterMenuTemplateDirective, NumericFilterMenuComponent, NumericFilterMenuInputComponent, DateFilterMenuInputComponent, DateFilterMenuComponent, FilterMenuHostDirective, BooleanFilterMenuComponent, FilterMenuDropDownListDirective, BooleanFilterRadioButtonDirective, ColumnListComponent, ColumnChooserComponent, ColumnChooserToolbarDirective, ColumnMenuChooserComponent, ColumnMenuFilterComponent, ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, ColumnMenuSortComponent, ColumnMenuComponent, ColumnMenuLockComponent, ColumnMenuTemplateDirective, ColumnMenuContainerComponent, ColumnMenuItemDirective, ColumnMenuStickComponent, ColumnMenuPositionComponent, ColumnMenuAutoSizeColumnComponent, ColumnMenuAutoSizeAllColumnsComponent, GridComponent, ListComponent2, ToolbarComponent, LocalizedMessagesDirective7, CustomMessagesComponent5, DataBindingDirective, ToolbarTemplateDirective, SelectionDirective, HighlightDirective, TemplateEditingDirective, ReactiveEditingDirective, InCellEditingDirective, ExternalEditingDirective, ExpandDetailsDirective, ExpandGroupDirective, GridMarqueeDirective, GridSpacerComponent, GridToolbarFocusableDirective, StatusBarComponent, StatusBarTemplateDirective, GridClipboardDirective, FormComponent, DialogFormComponent, FormFormFieldComponent, UndoRedoDirective, ToolBarComponent, ToolbarCustomMessagesComponent, ToolBarButtonComponent, ToolBarButtonGroupComponent, ToolBarDropDownButtonComponent, ToolBarSeparatorComponent, ToolBarSpacerComponent, ToolBarSplitButtonComponent, ToolBarToolComponent, TableDirective, UndoCommandToolbarDirective, RedoCommandToolbarDirective],
    exports: [GridComponent, ToolbarTemplateDirective, ToolbarComponent, GridSpacerComponent, StatusBarTemplateDirective, DataBindingDirective, SelectionDirective, HighlightDirective, CustomMessagesComponent5, TemplateEditingDirective, ReactiveEditingDirective, InCellEditingDirective, ExternalEditingDirective, ExpandDetailsDirective, ExpandGroupDirective, GridToolbarFocusableDirective, GroupHeaderTemplateDirective2, GroupHeaderColumnTemplateDirective2, GroupFooterTemplateDirective2, GroupHeaderComponent, GroupPanelComponent, ColumnComponent2, ColumnGroupComponent2, LogicalCellDirective, LogicalRowDirective, FocusableDirective, FooterTemplateDirective3, ColGroupComponent, ResizableContainerDirective, TemplateContextDirective, FieldAccessorPipe, DetailTemplateDirective, SpanColumnComponent, LoadingComponent, GridTableDirective, CommandColumnComponent, CheckboxColumnComponent, SelectionCheckboxDirective, CellTemplateDirective2, EditTemplateDirective, RowDragHandleTemplateDirective, RowDragHintTemplateDirective, TableBodyComponent, NoRecordsTemplateDirective, CellComponent, EditCommandDirective, CancelCommandDirective, SaveCommandDirective, RemoveCommandDirective, AddCommandDirective, AddCommandToolbarDirective, EditCommandToolbarDirective, SaveCommandToolbarDirective, RemoveCommandToolbarDirective, CancelCommandToolbarDirective, CellLoadingTemplateDirective, LoadingTemplateDirective, RowReorderColumnComponent, SortCommandToolbarDirective, FilterCommandToolbarDirective, AIAssistantToolbarDirective, GroupCommandToolbarDirective, SelectAllToolbarToolComponent, HeaderComponent2, HeaderTemplateDirective2, ColumnHandleDirective, SelectAllCheckboxDirective, FilterRowComponent, FilterCellComponent, FilterCellTemplateDirective, StringFilterCellComponent, NumericFilterCellComponent, AutoCompleteFilterCellComponent, BooleanFilterCellComponent, FilterCellHostDirective, FilterCellWrapperComponent, DateFilterCellComponent, FilterCellOperatorsComponent, ContainsFilterOperatorComponent, DoesNotContainFilterOperatorComponent, EndsWithFilterOperatorComponent, EqualFilterOperatorComponent, IsEmptyFilterOperatorComponent, IsNotEmptyFilterOperatorComponent, IsNotNullFilterOperatorComponent, IsNullFilterOperatorComponent, NotEqualFilterOperatorComponent, StartsWithFilterOperatorComponent, GreaterFilterOperatorComponent, GreaterOrEqualToFilterOperatorComponent, LessFilterOperatorComponent, LessOrEqualToFilterOperatorComponent, AfterFilterOperatorComponent, AfterEqFilterOperatorComponent, BeforeEqFilterOperatorComponent, BeforeFilterOperatorComponent, FilterMenuComponent, FilterMenuContainerComponent, FilterMenuInputWrapperComponent, StringFilterMenuInputComponent, StringFilterMenuComponent, FilterMenuTemplateDirective, NumericFilterMenuComponent, NumericFilterMenuInputComponent, DateFilterMenuInputComponent, DateFilterMenuComponent, FilterMenuHostDirective, BooleanFilterMenuComponent, FilterMenuDropDownListDirective, BooleanFilterRadioButtonDirective, ColumnChooserComponent, ColumnChooserToolbarDirective, ColumnMenuFilterComponent, ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, ColumnMenuSortComponent, ColumnMenuLockComponent, ColumnMenuStickComponent, ColumnMenuPositionComponent, ColumnMenuChooserComponent, ColumnMenuTemplateDirective, ColumnMenuContainerComponent, ColumnMenuItemDirective, ColumnMenuComponent, ColumnMenuAutoSizeColumnComponent, ColumnMenuAutoSizeAllColumnsComponent, GridClipboardDirective, UndoRedoDirective, UndoCommandToolbarDirective, RedoCommandToolbarDirective, ToolBarComponent, ToolbarCustomMessagesComponent, ToolBarButtonComponent, ToolBarButtonGroupComponent, ToolBarDropDownButtonComponent, ToolBarSeparatorComponent, ToolBarSpacerComponent, ToolBarSplitButtonComponent, ToolBarToolComponent, CustomMessagesComponent, PagerFocusableDirective, PagerInfoComponent, PagerInputComponent, PagerNextButtonsComponent, PagerNumericButtonsComponent, PagerPageSizesComponent, PagerPrevButtonsComponent, PagerTemplateDirective, PagerComponent, PagerSpacerComponent]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [PopupService, ResizeBatchService, IconsService, DialogContainerService, DialogService, WindowService, WindowContainerService, CalendarDOMService, CenturyViewService, DecadeViewService, MonthViewService, YearViewService, NavigationService],
    imports: [GroupHeaderComponent, GroupPanelComponent, TableBodyComponent, CellComponent, EditCommandDirective, CancelCommandDirective, SaveCommandDirective, RemoveCommandDirective, AddCommandDirective, SelectAllToolbarToolComponent, HeaderComponent2, CustomMessagesComponent, PagerInfoComponent, PagerInputComponent, PagerNextButtonsComponent, PagerNumericButtonsComponent, PagerPageSizesComponent, PagerPrevButtonsComponent, PagerComponent, PagerSpacerComponent, ToolBarComponent, ToolbarCustomMessagesComponent, ToolBarButtonComponent, ToolBarButtonGroupComponent, ToolBarDropDownButtonComponent, ToolBarSeparatorComponent, ToolBarSpacerComponent, ToolBarSplitButtonComponent, StringFilterCellComponent, NumericFilterCellComponent, AutoCompleteFilterCellComponent, BooleanFilterCellComponent, FilterCellWrapperComponent, DateFilterCellComponent, FilterCellOperatorsComponent, FilterCellOperatorsComponent, FilterMenuComponent, FilterMenuContainerComponent, FilterMenuInputWrapperComponent, StringFilterMenuInputComponent, StringFilterMenuComponent, NumericFilterMenuComponent, NumericFilterMenuInputComponent, DateFilterMenuInputComponent, DateFilterMenuComponent, BooleanFilterMenuComponent, ColumnListComponent, ColumnChooserComponent, ColumnMenuChooserComponent, ColumnMenuFilterComponent, ColumnMenuItemComponent, ColumnMenuSortComponent, ColumnMenuComponent, ColumnMenuLockComponent, ColumnMenuStickComponent, ColumnMenuPositionComponent, ColumnMenuAutoSizeColumnComponent, ColumnMenuAutoSizeAllColumnsComponent, GridComponent, ListComponent2, FormComponent, DialogFormComponent, FormFormFieldComponent, ToolBarComponent, ToolbarCustomMessagesComponent, ToolBarButtonComponent, ToolBarButtonGroupComponent, ToolBarDropDownButtonComponent, ToolBarSeparatorComponent, ToolBarSpacerComponent, ToolBarSplitButtonComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GridModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_GRID_EXPORTS, ...KENDO_TOOLBAR, ...KENDO_PAGER],
      imports: [...KENDO_GRID_GROUP_EXPORTS, ...KENDO_GRID_SHARED, ...KENDO_GRID_BODY_EXPORTS, ...KENDO_GRID_HEADER_EXPORTS, ...KENDO_GRID_FOOTER_EXPORTS, ...KENDO_PAGER, ...KENDO_TOOLBAR, ...KENDO_GRID_FILTER_ROW, ...KENDO_GRID_FILTER_MENU, ...KENDO_GRID_COLUMN_MENU_DECLARATIONS, ...KENDO_GRID_DECLARATIONS, ...KENDO_TOOLBAR, TableDirective, UndoCommandToolbarDirective, RedoCommandToolbarDirective],
      providers: [PopupService, ResizeBatchService, IconsService, DialogContainerService, DialogService, WindowService, WindowContainerService, CalendarDOMService, CenturyViewService, DecadeViewService, MonthViewService, YearViewService, NavigationService]
    }]
  }], null, null);
})();
var PDFModule = class _PDFModule {
  static ɵfac = function PDFModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PDFModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PDFModule,
    imports: [IconComponent, SVGIconComponent, PDFComponent, PDFMarginComponent, PDFCommandDirective, PDFTemplateDirective, PDFCommandToolbarDirective],
    exports: [PDFComponent, PDFMarginComponent, PDFCommandDirective, PDFTemplateDirective, PDFCommandToolbarDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService],
    imports: [KENDO_ICONS, PDFCommandDirective]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PDFModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_ICONS, ...KENDO_GRID_PDF_EXPORT],
      exports: [...KENDO_GRID_PDF_EXPORT],
      providers: [IconsService]
    }]
  }], null, null);
})();
var ExcelModule = class _ExcelModule {
  static ɵfac = function ExcelModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ExcelModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _ExcelModule,
    imports: [IconComponent, SVGIconComponent, ExcelComponent, ExcelCommandDirective, ExcelCommandToolbarDirective, ColumnComponent, ColumnGroupComponent, FooterTemplateDirective, GroupFooterTemplateDirective, GroupHeaderColumnTemplateDirective, GroupHeaderTemplateDirective],
    exports: [ExcelComponent, ExcelCommandDirective, ExcelCommandToolbarDirective, ColumnComponent, ColumnGroupComponent, FooterTemplateDirective, GroupFooterTemplateDirective, GroupHeaderColumnTemplateDirective, GroupHeaderTemplateDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService],
    imports: [KENDO_ICONS, ExcelCommandDirective, ColumnComponent, ColumnGroupComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExcelModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_ICONS, ...KENDO_GRID_EXCEL_EXPORT],
      exports: [...KENDO_GRID_EXCEL_EXPORT],
      providers: [IconsService]
    }]
  }], null, null);
})();
export {
  AIAssistantToolbarDirective,
  AdaptiveGridService,
  AddCommandDirective,
  AddCommandToolbarDirective,
  AfterEqFilterOperatorComponent,
  AfterFilterOperatorComponent,
  AutoCompleteFilterCellComponent,
  BaseFilterCellComponent,
  BeforeEqFilterOperatorComponent,
  BeforeFilterOperatorComponent,
  BooleanFilterCellComponent,
  BooleanFilterComponent,
  BooleanFilterMenuComponent,
  BooleanFilterRadioButtonDirective,
  BrowserSupportService,
  CELL_CONTEXT,
  CancelCommandDirective,
  CancelCommandToolbarDirective,
  CellCloseEvent,
  CellComponent,
  CellLoadingTemplateDirective,
  CellSelectionAggregateService,
  CellSelectionService,
  CellTemplateDirective2 as CellTemplateDirective,
  ChangeNotificationService,
  CheckboxColumnComponent,
  ColGroupComponent,
  ColumnBase2 as ColumnBase,
  ColumnChooserComponent,
  ColumnChooserToolbarDirective,
  ColumnComponent2 as ColumnComponent,
  ColumnGroupComponent2 as ColumnGroupComponent,
  ColumnHandleDirective,
  ColumnInfoService,
  ColumnListComponent,
  ColumnLockedChangeEvent,
  ColumnMenuAutoSizeAllColumnsComponent,
  ColumnMenuAutoSizeColumnComponent,
  ColumnMenuChooserComponent,
  ColumnMenuComponent,
  ColumnMenuContainerComponent,
  ColumnMenuFilterComponent,
  ColumnMenuItemComponent,
  ColumnMenuItemContentTemplateDirective,
  ColumnMenuItemDirective,
  ColumnMenuLockComponent,
  ColumnMenuPositionComponent,
  ColumnMenuService,
  ColumnMenuSortComponent,
  ColumnMenuStickComponent,
  ColumnMenuTemplateDirective,
  ColumnReorderEvent,
  ColumnReorderService,
  ColumnResizingService,
  ColumnStickyChangeEvent,
  ColumnVisibilityChangeEvent,
  ColumnsContainer,
  CommandColumnComponent,
  ContainsFilterOperatorComponent,
  ContextService,
  CustomMessagesComponent5 as CustomMessagesComponent,
  DEFAULT_AI_REQUEST_OPTIONS,
  DEFAULT_SCROLLER_FACTORY2 as DEFAULT_SCROLLER_FACTORY,
  DataBindingDirective,
  DateFilterCellComponent,
  DateFilterComponent,
  DateFilterMenuComponent,
  DateFilterMenuInputComponent,
  DetailCollapseEvent,
  DetailExpandEvent,
  DetailTemplateDirective,
  DetailsService,
  DoesNotContainFilterOperatorComponent,
  DomEventsService,
  DragAndDropService,
  DragHintService,
  DropCueService,
  EditCommandDirective,
  EditCommandToolbarDirective,
  EditService as EditServiceClass,
  EditTemplateDirective,
  EditingDirectiveBase,
  EndsWithFilterOperatorComponent,
  EqualFilterOperatorComponent,
  ExcelCommandDirective,
  ExcelCommandToolbarDirective,
  ExcelComponent,
  ExcelExportEvent,
  ExcelModule,
  ExcelService,
  ExpandDetailsDirective,
  ExpandGroupDirective,
  ExternalEditingDirective,
  FieldAccessorPipe,
  FilterCellComponent,
  FilterCellHostDirective,
  FilterCellOperatorsComponent,
  FilterCellTemplateDirective,
  FilterCellWrapperComponent,
  FilterCommandToolbarDirective,
  FilterInputDirective,
  FilterMenuComponent,
  FilterMenuContainerComponent,
  FilterMenuDropDownListDirective,
  FilterMenuHostDirective,
  FilterMenuInputWrapperComponent,
  FilterMenuTemplateDirective,
  FilterOperatorBase,
  FilterRowComponent,
  FilterService,
  FocusRoot,
  FocusableDirective,
  FooterComponent2 as FooterComponent,
  FooterTemplateDirective3 as FooterTemplateDirective,
  GreaterFilterOperatorComponent,
  GreaterOrEqualToFilterOperatorComponent,
  GridAIAssistantResponseErrorEvent,
  GridAIAssistantResponseSuccessEvent,
  GridClipboardDirective,
  GridComponent,
  GridModule,
  GridSpacerComponent,
  GridTableDirective,
  GridToolbarFocusableDirective,
  GridToolbarNavigationService,
  GroupCommandToolbarDirective,
  GroupFooterTemplateDirective2 as GroupFooterTemplateDirective,
  GroupHeaderColumnTemplateDirective2 as GroupHeaderColumnTemplateDirective,
  GroupHeaderComponent,
  GroupHeaderTemplateDirective2 as GroupHeaderTemplateDirective,
  GroupInfoService,
  GroupPanelComponent,
  GroupsService,
  HeaderComponent2 as HeaderComponent,
  HeaderTemplateDirective2 as HeaderTemplateDirective,
  HighlightDirective,
  IdService,
  InCellEditingDirective,
  IsEmptyFilterOperatorComponent,
  IsNotEmptyFilterOperatorComponent,
  IsNotNullFilterOperatorComponent,
  IsNullFilterOperatorComponent,
  KENDO_GRID,
  KENDO_GRID_BODY_EXPORTS,
  KENDO_GRID_COLUMN_DRAGANDDROP,
  KENDO_GRID_COLUMN_MENU_DECLARATIONS,
  KENDO_GRID_COLUMN_MENU_EXPORTS,
  KENDO_GRID_DECLARATIONS,
  KENDO_GRID_EXCEL_EXPORT,
  KENDO_GRID_EXPORTS,
  KENDO_GRID_FILTER_MENU,
  KENDO_GRID_FILTER_MENU_EXPORTS,
  KENDO_GRID_FILTER_OPERATORS,
  KENDO_GRID_FILTER_ROW,
  KENDO_GRID_FILTER_ROW_EXPORTS,
  KENDO_GRID_FILTER_SHARED,
  KENDO_GRID_FOOTER_EXPORTS,
  KENDO_GRID_GROUP_EXPORTS,
  KENDO_GRID_HEADER_EXPORTS,
  KENDO_GRID_PDF_EXPORT,
  KENDO_GRID_SHARED,
  LessFilterOperatorComponent,
  LessOrEqualToFilterOperatorComponent,
  ListComponent2 as ListComponent,
  LoadingComponent,
  LoadingTemplateDirective,
  LocalDataChangesService,
  LogicalCellDirective,
  LogicalRowDirective,
  MenuTabbingService,
  MultiCheckboxFilterComponent,
  NavigationService4 as NavigationService,
  NoRecordsTemplateDirective,
  NotEqualFilterOperatorComponent,
  NumericFilterCellComponent,
  NumericFilterComponent,
  NumericFilterMenuComponent,
  NumericFilterMenuInputComponent,
  PDFCommandDirective,
  PDFCommandToolbarDirective,
  PDFComponent,
  PDFMarginComponent,
  PDFModule,
  PDFService,
  PDFTemplateDirective,
  PopupCloseEvent,
  ReactiveEditingDirective,
  RedoCommandToolbarDirective,
  RemoveCommandDirective,
  RemoveCommandToolbarDirective,
  ResizableContainerDirective,
  ResizeService,
  ResponsiveService,
  RowDragHandleTemplateDirective,
  RowDragHintTemplateDirective,
  RowEditingDirectiveBase,
  RowReorderColumnComponent,
  RowReorderService,
  SaveCommandDirective,
  SaveCommandToolbarDirective,
  ScrollRequestService,
  ScrollSyncService2 as ScrollSyncService,
  SelectAllCheckboxDirective,
  SelectAllToolbarToolComponent,
  SelectionCheckboxDirective,
  SelectionDirective,
  SelectionService2 as SelectionService,
  SinglePopupService,
  SizingOptionsService,
  Skip,
  SortCommandToolbarDirective,
  SortService,
  SpanColumnComponent,
  StartsWithFilterOperatorComponent,
  StatusBarTemplateDirective,
  StringFilterCellComponent,
  StringFilterComponent,
  StringFilterMenuComponent,
  StringFilterMenuInputComponent,
  SuspendService,
  TableBodyComponent,
  TableDirective,
  TemplateEditingDirective,
  ToolbarComponent,
  ToolbarTemplateDirective,
  UndoCommandToolbarDirective,
  UndoRedoDirective,
  UndoRedoEvent,
  defaultTrackBy,
  hasFilterMenu,
  hasFilterRow,
  isFilterable
};
//# sourceMappingURL=@progress_kendo-angular-grid.js.map
