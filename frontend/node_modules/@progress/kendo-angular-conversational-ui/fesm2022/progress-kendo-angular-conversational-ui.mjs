/**-----------------------------------------------------------------------------------------
* Copyright © 2026 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import * as i0 from '@angular/core';
import { InjectionToken, Input, ViewChild, HostBinding, Inject, Directive, Injectable, Optional, forwardRef, EventEmitter, Output, ContentChild, ContentChildren, Component, isDevMode, ElementRef, ViewChildren, HostListener, ViewContainerRef, inject, SkipSelf, NgModule } from '@angular/core';
import { IconWrapperComponent, IconsService } from '@progress/kendo-angular-icons';
import * as i1$2 from '@progress/kendo-angular-popup';
import { PopupComponent, KENDO_POPUP, PopupService } from '@progress/kendo-angular-popup';
import { isPresent, normalizeKeys, Keys, focusableSelector, guid, getter, isDocumentAvailable, closest as closest$1, ResizeSensorComponent, isChanged, processCssValue, ResizeBatchService } from '@progress/kendo-angular-common';
import { DialogContainerService, DialogService, WindowService, WindowContainerService } from '@progress/kendo-angular-dialog';
import { NgTemplateOutlet, NgClass } from '@angular/common';
import { Subject, Subscription, fromEvent } from 'rxjs';
import { moreHorizontalIcon, commentIcon, sparklesIcon, stopSmIcon, thumbUpIcon, thumbDownOutlineIcon, thumbDownIcon, thumbUpOutlineIcon, copyIcon, arrowRotateCwIcon, chevronUpIcon, chevronDownIcon, paperPlaneIcon, undoIcon, downloadIcon, chevronLeftIcon, chevronRightIcon, xIcon, moreVerticalIcon, paperclipIcon, fileIcon, pinIcon, cancelOutlineIcon, menuIcon } from '@progress/kendo-svg-icons';
import * as i1 from '@progress/kendo-angular-l10n';
import { ComponentMessages, LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';
import { validatePackage } from '@progress/kendo-licensing';
import * as i2 from '@progress/kendo-angular-buttons';
import { ButtonComponent, FloatingActionButtonComponent, SpeechToTextButtonComponent, DropDownButtonComponent, KENDO_BUTTONS, KENDO_BUTTON } from '@progress/kendo-angular-buttons';
import { take, debounceTime } from 'rxjs/operators';
import * as i5 from '@progress/kendo-angular-layout';
import { PanelBarComponent, KENDO_CARD } from '@progress/kendo-angular-layout';
import * as i3 from '@progress/kendo-angular-inputs';
import { TextAreaComponent, TextAreaSuffixComponent, TextAreaPrefixComponent, InputSpacerComponent, KENDO_TEXTAREA } from '@progress/kendo-angular-inputs';
import { fileSVGGroupIcon, fileGroupClass, getTotalFilesSizeMessage, FileSelectComponent } from '@progress/kendo-angular-upload';
import { FormsModule } from '@angular/forms';
import * as i1$1 from '@progress/kendo-angular-intl';
import { ToolBarComponent, ToolBarButtonComponent } from '@progress/kendo-angular-toolbar';
import { AppBarComponent } from '@progress/kendo-angular-navigation';
import * as i4 from '@progress/kendo-angular-menu';
import { ContextMenuComponent, KENDO_CONTEXTMENU } from '@progress/kendo-angular-menu';

/**
 * @hidden
 */
class PreventableEvent {
    prevented = false;
    /**
     * Prevents the default action for a specified event.
     * In this way, the source component suppresses
     * the built-in behavior that follows the event.
     */
    preventDefault() {
        this.prevented = true;
    }
    /**
     * Returns `true` if the event was prevented
     * by any of its subscribers.
     *
     * @returns `true` if the default action was prevented.
     * Otherwise, returns `false`.
     */
    isDefaultPrevented() {
        return this.prevented;
    }
}

/**
 * Represents the arguments for the `executeAction` event.
 *
 * The `executeAction` event fires when the user clicks a quick action button.
 * Call `preventDefault()` to suppress the built-in action handler.
 */
class ExecuteActionEvent extends PreventableEvent {
    /**
     * Represents the action to execute.
     */
    action;
    /**
     * Represents the message that contains the action.
     */
    message;
    /**
     * @hidden
     */
    constructor(action, message) {
        super();
        this.action = action;
        this.message = message;
    }
}

/**
 * Describes the arguments for the `sendMessage` event.
 */
class SendMessageEvent {
    /**
     * Represents the message that contains the metadata and user input.
     *
     * The Chat does not automatically add the message to its data. For more information, see [Data Binding](slug:databinding_chat).
     */
    message;
    /**
     * @hidden
     */
    constructor(message) {
        this.message = message;
    }
}

/**
 * @hidden
 */
const MY_TOKEN = new InjectionToken('COMMAND_TOKEN');
/**
 * @hidden
 */
const DEFAULT_SVG_ICONS = {
    prompt: sparklesIcon,
    output: commentIcon,
    command: moreHorizontalIcon
};
/**
 * @hidden
 */
const DEFAULT_ICONS = {
    prompt: 'sparkles',
    output: 'comment',
    command: 'more-horizontal'
};

/**
 * @hidden
 */
class BaseView {
    viewType;
    localization;
    hostClasses = true;
    /**
     * @hidden
     */
    template;
    constructor(viewType, localization) {
        this.viewType = viewType;
        this.localization = localization;
        if (this.viewType !== 'custom') {
            this.icon = DEFAULT_ICONS[this.viewType];
            this.svgIcon = DEFAULT_SVG_ICONS[this.viewType];
        }
    }
    /**
     * Sets the text for the Toolbar button of the current view.
     */
    set buttonText(value) {
        this._buttonText = value;
    }
    get buttonText() {
        return isPresent(this._buttonText) ?
            this._buttonText :
            this.messageFor(`${this.viewType}View`);
    }
    /**
     * Sets the font icon for the Toolbar button of the current view.
     */
    set icon(value) {
        if (isPresent(value)) {
            this._icon = value;
        }
        else {
            this.icon = DEFAULT_ICONS[this.viewType];
        }
    }
    get icon() {
        return this._icon;
    }
    /**
     * Sets the SVG icon for the Toolbar button of the current view.
     */
    set svgIcon(value) {
        if (isPresent(value)) {
            this._svgIcon = value;
        }
        else {
            this.svgIcon = DEFAULT_SVG_ICONS[this.viewType];
        }
    }
    get svgIcon() {
        return this._svgIcon;
    }
    /**
     * @hidden
     */
    messageFor(text) {
        return this.localization.get(text);
    }
    _buttonText;
    _icon;
    _svgIcon;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: BaseView, deps: [{ token: MY_TOKEN }, { token: i1.LocalizationService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: BaseView, isStandalone: true, inputs: { buttonText: "buttonText", icon: "icon", svgIcon: "svgIcon" }, host: { properties: { "class.k-prompt-view": "this.hostClasses" } }, viewQueries: [{ propertyName: "template", first: true, predicate: ["content"], descendants: true, static: true }], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: BaseView, decorators: [{
            type: Directive
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [MY_TOKEN]
                }] }, { type: i1.LocalizationService }], propDecorators: { hostClasses: [{
                type: HostBinding,
                args: ['class.k-prompt-view']
            }], template: [{
                type: ViewChild,
                args: ['content', { static: true }]
            }], buttonText: [{
                type: Input
            }], icon: [{
                type: Input
            }], svgIcon: [{
                type: Input
            }] } });

/**
 * @hidden
 */
const packageMetadata = {
    name: '@progress/kendo-angular-conversational-ui',
    productName: 'Kendo UI for Angular',
    productCode: 'KENDOUIANGULAR',
    productCodes: ['KENDOUIANGULAR'],
    publishDate: 0,
    version: '22.0.1',
    licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/'
};

/**
 * @hidden
 * Default settings for the Speech to Text button.
 * These settings can be overridden by the user.
 */
const STB_DEFAULT_SETTINGS$1 = {
    continuous: false,
    disabled: false,
    fillMode: 'flat',
    integrationMode: 'webSpeech',
    interimResults: false,
    lang: 'en-US',
    maxAlternatives: 1,
    rounded: 'medium',
    size: 'medium',
    themeColor: 'base'
};
/**
 * @hidden
 */
class AIPromptService {
    aiPrompt;
    promptValue = '';
    showOutputRating = false;
    requestEvent = new Subject();
    executeEvent = new Subject();
    outputCopyEvent = new Subject();
    outputRatingChangeEvent = new Subject();
    promptCommands;
    promptOutputs;
    promptSuggestions;
    textAreaSettings;
    outputTemplate;
    outputBodyTemplate;
    _speechToTextButton;
    get speechToTextButton() {
        return this._speechToTextButton;
    }
    set speechToTextButton(settings) {
        if (settings === true) {
            this._speechToTextButton = STB_DEFAULT_SETTINGS$1;
        }
        else if (settings === false) {
            this._speechToTextButton = null;
        }
        else {
            this._speechToTextButton = { ...settings };
        }
    }
    getFlattenPromptCommands(commands = this.promptCommands) {
        let newArr = [];
        commands.forEach(c => {
            if (c.hasOwnProperty('children')) {
                const childrenArr = c.children;
                newArr = newArr.concat(childrenArr);
                if (childrenArr.length > 0) {
                    this.getFlattenPromptCommands(childrenArr);
                }
            }
        });
        return newArr.concat(this.promptCommands);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AIPromptService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AIPromptService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AIPromptService, decorators: [{
            type: Injectable
        }] });

/**
 * Represents a template for additional Toolbar actions.
 * The actions appear after the Toolbar buttons for all views.
 *
 * To define the template, nest an `<ng-template>` tag
 * with the `kendoAIPromptToolbarActionsTemplate` directive inside the `<kendo-aiprompt>` tag.
 *
 * @example
 * ```html
 * <kendo-aiprompt>
 *   <ng-template kendoAIPromptToolbarActionsTemplate>
 *     <button kendoButton>Custom Action</button>
 *   </ng-template>
 * </kendo-aiprompt>
 * ```
 */
class AIPromptToolbarActionsDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AIPromptToolbarActionsDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: AIPromptToolbarActionsDirective, isStandalone: true, selector: "[kendoAIPromptToolbarActionsTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AIPromptToolbarActionsDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoAIPromptToolbarActionsTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }] });

/**
 * @hidden
 */
class ToolbarNavigationService {
    localizationService;
    focusableElements = [];
    currentFocusedIndex = 0;
    constructor(localizationService) {
        this.localizationService = localizationService;
    }
    register(tool) {
        if (!this.focusableElements.some(el => el === tool)) {
            this.focusableElements.push(tool);
        }
    }
    unregister(tool) {
        this.currentFocusedIndex = 0;
        this.focusableElements = this.focusableElements.filter(el => el !== tool);
    }
    isActive(focusable) {
        return this.focusableElements[this.currentFocusedIndex] === focusable;
    }
    setActiveIndex(tool) {
        this.currentFocusedIndex = Math.max(this.focusableElements.indexOf(tool), 0);
    }
    move(direction) {
        let delta = direction === 'right' ? 1 : -1;
        if (this.localizationService.rtl) {
            delta = -delta;
        }
        this.currentFocusedIndex += delta;
        if (this.currentFocusedIndex < 0) {
            this.currentFocusedIndex = this.focusableElements.length - 1;
        }
        else if (this.currentFocusedIndex >= this.focusableElements.length) {
            this.currentFocusedIndex = 0;
        }
        this.focusableElements[this.currentFocusedIndex].activate();
    }
    focusFirst() {
        this.focusableElements[this.currentFocusedIndex].activate();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ToolbarNavigationService, deps: [{ token: i1.LocalizationService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ToolbarNavigationService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ToolbarNavigationService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: i1.LocalizationService }] });

/**
 * @hidden
 */
class AIPromptToolbarFocusableDirective {
    host;
    navigationService;
    renderer;
    constructor(host, navigationService, renderer) {
        this.host = host;
        this.navigationService = navigationService;
        this.renderer = renderer;
        navigationService.register(this);
    }
    get element() {
        return this.host.nativeElement;
    }
    ngAfterViewInit() {
        this.renderer.setAttribute(this.element, 'tabindex', this.navigationService.isActive(this) ? '0' : '-1');
        this.element.addEventListener('keydown', this.keyDownHandler, { capture: true });
        this.element.addEventListener('click', this.clickHandler, { capture: true });
    }
    ngOnDestroy() {
        this.navigationService.unregister(this);
        this.element.removeEventListener('keydown', this.keyDownHandler, { capture: true });
        this.element.removeEventListener('click', this.clickHandler, { capture: true });
    }
    activate() {
        this.renderer.setAttribute(this.element, 'tabindex', '0');
        this.element.focus();
    }
    keyDownHandler = (e) => {
        const code = normalizeKeys(e);
        const targetsSelf = e.target === this.element;
        const isLeftArrow = code === Keys.ArrowLeft;
        const isRightArrow = code === Keys.ArrowRight;
        const isArrow = isLeftArrow || isRightArrow;
        if (!targetsSelf || !isArrow) {
            return;
        }
        this.renderer.setAttribute(this.element, 'tabindex', '-1');
        this.element.querySelectorAll(focusableSelector).forEach(el => {
            this.renderer.setAttribute(el, 'tabindex', '-1');
        });
        if (isRightArrow) {
            this.navigationService.move('right');
        }
        else if (isLeftArrow) {
            this.navigationService.move('left');
        }
    };
    clickHandler = () => {
        this.navigationService.setActiveIndex(this);
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AIPromptToolbarFocusableDirective, deps: [{ token: i0.ElementRef }, { token: ToolbarNavigationService }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: AIPromptToolbarFocusableDirective, isStandalone: true, selector: "[kendoAIPromptToolbarFocusable]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AIPromptToolbarFocusableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoAIPromptToolbarFocusable]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: ToolbarNavigationService }, { type: i0.Renderer2 }] });

/**
 * @hidden
 */
let Messages$2 = class Messages extends ComponentMessages {
    /**
     * Sets the Toolbar button text for the **Prompt** view.
     */
    promptView;
    /**
     * Sets the Toolbar button text for the **Output** view.
     */
    outputView;
    /**
     * Sets the text for the **Generate** button in the **Prompt** view.
     */
    generateOutput;
    /**
     * Sets the placeholder text for the **Prompt** view text area.
     */
    promptPlaceholder;
    /**
     * Sets the text for the **Copy** button text in each **Output** view card.
     */
    copyOutput;
    /**
     * Sets the **Retry** button text in each **Output** view card.
     */
    retryGeneration;
    /**
     * Sets the title of each card in the **Output** view.
     */
    outputTitle;
    /**
     * Sets the title of each retry card in the **Output** view.
     */
    outputRetryTitle;
    /**
     * Sets the title of the **Prompt suggestions** button.
     */
    promptSuggestions;
    /**
     * Sets the aria-label for the **Speech to Text** button.
     */
    speechToTextButton;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: Messages, deps: null, target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: Messages, isStandalone: true, inputs: { promptView: "promptView", outputView: "outputView", generateOutput: "generateOutput", promptPlaceholder: "promptPlaceholder", copyOutput: "copyOutput", retryGeneration: "retryGeneration", outputTitle: "outputTitle", outputRetryTitle: "outputRetryTitle", promptSuggestions: "promptSuggestions", speechToTextButton: "speechToTextButton" }, usesInheritance: true, ngImport: i0 });
};
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: Messages$2, decorators: [{
            type: Directive
        }], propDecorators: { promptView: [{
                type: Input
            }], outputView: [{
                type: Input
            }], generateOutput: [{
                type: Input
            }], promptPlaceholder: [{
                type: Input
            }], copyOutput: [{
                type: Input
            }], retryGeneration: [{
                type: Input
            }], outputTitle: [{
                type: Input
            }], outputRetryTitle: [{
                type: Input
            }], promptSuggestions: [{
                type: Input
            }], speechToTextButton: [{
                type: Input
            }] } });

/**
 * @hidden
 */
let LocalizedMessagesDirective$2 = class LocalizedMessagesDirective extends Messages$2 {
    service;
    constructor(service) {
        super();
        this.service = service;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: LocalizedMessagesDirective, deps: [{ token: i1.LocalizationService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: LocalizedMessagesDirective, isStandalone: true, selector: "[kendoAIPromptLocalizedMessages]", providers: [
            {
                provide: Messages$2,
                useExisting: forwardRef(() => LocalizedMessagesDirective)
            }
        ], usesInheritance: true, ngImport: i0 });
};
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: LocalizedMessagesDirective$2, decorators: [{
            type: Directive,
            args: [{
                    providers: [
                        {
                            provide: Messages$2,
                            useExisting: forwardRef(() => LocalizedMessagesDirective$2)
                        }
                    ],
                    selector: '[kendoAIPromptLocalizedMessages]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1.LocalizationService }] });

/**
 * Represents the template for the response in the AIPrompt component. The template context is set to the current output object.
 *
 * @example
 * ```html
 * <kendo-aiprompt>
 *   <ng-template kendoAIPromptOutputTemplate let-output>
 *     <div>{{output.prompt}}</div>
 *   </ng-template>
 * </kendo-aiprompt>
 * ```
 */
class AIPromptOutputTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AIPromptOutputTemplateDirective, deps: [{ token: i0.TemplateRef }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: AIPromptOutputTemplateDirective, isStandalone: true, selector: "[kendoAIPromptOutputTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AIPromptOutputTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoAIPromptOutputTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef }] });

/**
 * Represents the template for the body of the response in the AIPrompt component. The template context is set to the current output object.
 *
 * @example
 * ```html
 * <kendo-aiprompt>
 *   <ng-template kendoAIPromptOutputBodyTemplate let-output>
 *     <div>{{output.prompt}}</div>
 *   </ng-template>
 * </kendo-aiprompt>
 * ```
 */
class AIPromptOutputBodyTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AIPromptOutputBodyTemplateDirective, deps: [{ token: i0.TemplateRef }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: AIPromptOutputBodyTemplateDirective, isStandalone: true, selector: "[kendoAIPromptOutputBodyTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AIPromptOutputBodyTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoAIPromptOutputBodyTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef }] });

/**
 * Represents the [Kendo UI AIPrompt component for Angular](slug:overview_aiprompt).
 *
 * @example
 * ```html
 * <kendo-aiprompt
 *   [promptCommands]="commands"
 *   [promptSuggestions]="suggestions"
 *   [promptOutputs]="outputs"
 *   [showOutputRating]="true"
 *   (promptRequest)="onPromptRequest($event)">
 * </kendo-aiprompt>
 * ```
 *
 * @remarks
 * Supported children components are: {@link AIPromptCustomMessagesComponent}, {@link CustomViewComponent}, {@link CommandViewComponent}, {@link PromptViewComponent}, {@link OutputViewComponent}.
 */
class AIPromptComponent {
    localization;
    service;
    navigationService;
    ngZone;
    element;
    renderer;
    hostClasses = true;
    get dirAttr() {
        return this.direction;
    }
    constructor(localization, service, navigationService, ngZone, element, renderer) {
        this.localization = localization;
        this.service = service;
        this.navigationService = navigationService;
        this.ngZone = ngZone;
        this.element = element;
        this.renderer = renderer;
        validatePackage(packageMetadata);
        this.direction = localization.rtl ? 'rtl' : 'ltr';
        this.subs.add(localization.changes.subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
        }));
    }
    /**
     * @hidden
     */
    fabButton;
    /**
     * @hidden
     */
    views;
    /**
     * @hidden
     */
    toolbarActionsTemplate;
    /**
     * @hidden
     */
    outputTemplate;
    /**
     * @hidden
     */
    outputBodyTemplate;
    /**
     * The active view index of the AIPrompt component.
     */
    set activeView(idx) {
        if (this._activeView !== idx) {
            this._activeView = idx;
            if (this.service.promptValue) {
                this.service.promptValue = '';
            }
        }
    }
    get activeView() {
        return this._activeView;
    }
    /**
     * Sets the collection of commands to render in the Command view.
     */
    set promptCommands(value) {
        this.service.promptCommands = value;
    }
    /**
     * Sets the collection of suggestions to render in the Prompt view.
     */
    set promptSuggestions(value) {
        this.service.promptSuggestions = value;
    }
    /**
     * Sets the collection of generated prompt outputs to render in the Output view.
     */
    set promptOutputs(value) {
        this.service.promptOutputs = value;
    }
    /**
     * Specifies whether the rating buttons appear in each Output view card.
     * The rating buttons do not appear by default.
     * @default false
     */
    set showOutputRating(value) {
        this.service.showOutputRating = value;
    }
    /**
     * Specifies whether the Stop generation button appears in the Output view.
     * The Stop generation button does not appear by default.
     * @default false
     */
    streaming = false;
    /**
     * Sets the settings for the Speech to Text button in the Prompt view
     * ([see example](slug:configuration_aiprompt#enabling-speech-to-text)).
     */
    set speechToTextButton(settings) {
        if (settings) {
            this.service.speechToTextButton = settings;
        }
        else {
            this.service.speechToTextButton = false;
        }
    }
    /**
     * Sets the settings for the TextArea in the Prompt view
     * ([see example](slug:configuration_aiprompt#configuring-the-prompt-text-area)).
     */
    set textAreaSettings(settings) {
        this.service.textAreaSettings = settings;
    }
    /**
     * Sets the SVG icon for the Generate button in the Prompt view.
     */
    generateButtonSVGIcon = sparklesIcon;
    /**
     * Sets the icon for the Generate button in the Prompt view.
     * @default 'sparkles'
     */
    generateButtonIcon = 'sparkles';
    /**
     * Sets the disabled state for the Generate button in the Prompt view.
     * @default false
     */
    disabledGenerateButton = false;
    /**
     * Fires when the `activeView` property is updated.
     * Use this event for two-way binding of the `activeView` property.
     */
    activeViewChange = new EventEmitter();
    /**
     * Fires when you click the Generate button in the Prompt view or the Retry button in the Output view.
     * Use the event's `isRetry` field to determine the source element.
     */
    promptRequest = new EventEmitter();
    /**
     * Fires when you click a Command view command.
     * The event data contains the selected command.
     */
    commandExecute = new EventEmitter();
    /**
     * Fires when you click a Copy button in any Output view card.
     */
    outputCopy = new EventEmitter();
    /**
     * Fires when you click a rating button in any Output view card.
     */
    outputRatingChange = new EventEmitter();
    /**
     * Fires when you click the Stop Generation button in the Output view.
     */
    promptRequestCancel = new EventEmitter();
    ngOnInit() {
        const aiPromptElement = this.element.nativeElement;
        this.subs.add(this.renderer.listen(aiPromptElement, 'keydown', (event) => {
            if (event.key === 'Escape') {
                this.promptRequestCancel.emit();
            }
        }));
    }
    ngOnChanges(changes) {
        if (changes['streaming'] && changes['streaming'].currentValue === true) {
            this.ngZone.onStable.pipe(take(1)).subscribe(() => {
                this.fabButton?.focus();
            });
        }
    }
    ngAfterContentChecked() {
        if (this.outputTemplate !== this.service.outputTemplate) {
            this.service.outputTemplate = this.outputTemplate;
        }
        if (this.outputBodyTemplate !== this.service.outputBodyTemplate) {
            this.service.outputBodyTemplate = this.outputBodyTemplate;
        }
    }
    ngAfterViewInit() {
        this.ngZone.runOutsideAngular(() => {
            this.service.aiPrompt = this;
            this.subs.add(this.service.requestEvent.subscribe(ev => this.promptRequest.emit(ev)));
            this.subs.add(this.service.executeEvent.subscribe(ev => this.commandExecute.emit(ev)));
            this.subs.add(this.service.outputCopyEvent.subscribe(ev => this.outputCopy.emit(ev)));
            this.subs.add(this.service.outputRatingChangeEvent.subscribe(ev => this.outputRatingChange.emit(ev)));
        });
    }
    ngOnDestroy() {
        this.subs.unsubscribe();
    }
    /**
     * Focuses the first focusable element in the AIPrompt component.
     */
    focus() {
        this.navigationService.focusFirst();
    }
    subs = new Subscription();
    /**
     * @hidden
     */
    get selectedView() {
        return this.viewsArray[this.activeView];
    }
    /**
     * @hidden
     */
    sparklesIcon = sparklesIcon;
    /**
     * @hidden
     */
    outputIcon = commentIcon;
    /**
     * @hidden
     */
    fabStopGenerationSVGIcon = stopSmIcon;
    /**
     * @hidden
     */
    get viewsArray() {
        return this.views?.toArray();
    }
    /**
     * @hidden
     */
    fabPositionMode = 'absolute';
    /**
     * @hidden
     */
    fabAlignment = { vertical: 'bottom', horizontal: 'end' };
    direction;
    _activeView = 0;
    /**
     * @hidden
     */
    viewChange(idx) {
        if (idx !== this.activeView) {
            this.activeView = idx;
            this.activeViewChange.emit(idx);
        }
    }
    /**
     * @hidden
     */
    messageFor(text) {
        return this.localization.get(text);
    }
    /**
     * @hidden
     */
    get viewTemplate() {
        return this.selectedView?.viewType === 'custom' ? this.selectedView?.viewTemplate : this.selectedView?.template;
    }
    /**
     * @hidden
     */
    handleGenerateOutput() {
        const value = this.service.promptValue;
        const eventArgs = {
            prompt: value,
            sender: this,
            isRetry: false
        };
        this.promptRequest.emit(eventArgs);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AIPromptComponent, deps: [{ token: i1.LocalizationService }, { token: AIPromptService }, { token: ToolbarNavigationService }, { token: i0.NgZone }, { token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: AIPromptComponent, isStandalone: true, selector: "kendo-aiprompt", inputs: { activeView: "activeView", promptCommands: "promptCommands", promptSuggestions: "promptSuggestions", promptOutputs: "promptOutputs", showOutputRating: "showOutputRating", streaming: "streaming", speechToTextButton: "speechToTextButton", textAreaSettings: "textAreaSettings", generateButtonSVGIcon: "generateButtonSVGIcon", generateButtonIcon: "generateButtonIcon", disabledGenerateButton: "disabledGenerateButton" }, outputs: { activeViewChange: "activeViewChange", promptRequest: "promptRequest", commandExecute: "commandExecute", outputCopy: "outputCopy", outputRatingChange: "outputRatingChange", promptRequestCancel: "promptRequestCancel" }, host: { properties: { "class.k-prompt": "this.hostClasses", "attr.dir": "this.dirAttr" } }, providers: [
            LocalizationService,
            AIPromptService,
            ToolbarNavigationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.aiprompt'
            }
        ], queries: [{ propertyName: "toolbarActionsTemplate", first: true, predicate: AIPromptToolbarActionsDirective, descendants: true }, { propertyName: "outputTemplate", first: true, predicate: AIPromptOutputTemplateDirective, descendants: true }, { propertyName: "outputBodyTemplate", first: true, predicate: AIPromptOutputBodyTemplateDirective, descendants: true }, { propertyName: "views", predicate: BaseView }], viewQueries: [{ propertyName: "fabButton", first: true, predicate: ["fabButton"], descendants: true }], exportAs: ["kendoAIPrompt"], usesOnChanges: true, ngImport: i0, template: `
        <ng-container kendoAIPromptLocalizedMessages
          i18n-promptView="kendo.aiprompt.promptView|The Toolbar button text for the Prompt view."
          promptView="Ask AI"
          i18n-outputView="kendo.aiprompt.outputView|The Toolbar button text for the Output view."
          outputView="Output"
          i18n-generateOutput="kendo.aiprompt.generateOutput|The text for the Generate button in the Prompt view."
          generateOutput="Generate"
          i18n-promptPlaceholder="kendo.aiprompt.promptPlaceholder|The placeholder text for the Prompt View text area."
          promptPlaceholder="Ask or generate content with AI"
          i18n-copyOutput="kendo.aiprompt.copyOutput|The Copy button text in each Output view card."
          copyOutput="Copy"
          i18n-retryGeneration="kendo.aiprompt.retryGeneration|The Retry button text in each Output view card."
          retryGeneration="Retry"
          i18n-outputTitle="kendo.aiprompt.outputTitle|The title of each Output view card."
          outputTitle="Generated with AI"
          i18n-outputRetryTitle="kendo.aiprompt.outputRetryTitle|The title of each Output view retry card."
          outputRetryTitle="Generated with AI"
          i18n-promptSuggestions="kendo.aiprompt.promptSuggestions|The title of the Prompt suggestions button."
          promptSuggestions="Prompt suggestions"
          i18n-speechToTextButton="kendo.aiprompt.speechToTextButton|The aria-label for the Speech to Text button."
          speechToTextButton="Voice input">
        </ng-container>
        <div class="k-prompt-header">
          <div class="k-toolbar-flat k-toolbar k-toolbar-md"
            role="toolbar">
            @for (view of viewsArray; track view; let idx = $index) {
              <button
                kendoButton
                kendoAIPromptToolbarFocusable
                type="button"
                fillMode="flat"
                rounded="full"
                themeColor="primary"
                [svgIcon]="view.svgIcon"
                [icon]="view.icon"
                [selected]="idx === activeView"
                (click)="viewChange(idx)">
                {{view.buttonText}}
              </button>
            }
        
            @if (toolbarActionsTemplate) {
              <ng-template
                [ngTemplateOutlet]="toolbarActionsTemplate?.templateRef">
              </ng-template>
            }
          </div>
        </div>
        <div class="k-prompt-content">
          @if (streaming && selectedView?.viewType === 'output') {
            <kendo-floatingactionbutton #fabButton
              class="k-prompt-stop-fab"
              buttonClass="k-generating k-active"
              [positionMode]="fabPositionMode"
              [align]="fabAlignment"
              [svgIcon]="fabStopGenerationSVGIcon"
              icon="stop"
              (click)="promptRequestCancel.emit()"
              >
            </kendo-floatingactionbutton>
          }
          <div class="k-prompt-view">
            <ng-container *ngTemplateOutlet="viewTemplate">
            </ng-container>
          </div>
        </div>
        @if (selectedView?.viewType === 'prompt') {
          <div class="k-prompt-footer">
            <div class="k-actions k-actions-start k-actions-horizontal k-prompt-actions">
              <button
                kendoButton
                type="button"
                themeColor="primary"
                rounded="full"
                [attr.title]="messageFor('generateOutput')"
                [attr.aria-label]="messageFor('generateOutput')"
                [attr.aria-disabled]="disabledGenerateButton"
                [svgIcon]="generateButtonSVGIcon"
                [icon]="generateButtonIcon"
                [disabled]="disabledGenerateButton"
              (click)="handleGenerateOutput()">{{messageFor('generateOutput')}}</button>
            </div>
          </div>
        }
        `, isInline: true, dependencies: [{ kind: "directive", type: LocalizedMessagesDirective$2, selector: "[kendoAIPromptLocalizedMessages]" }, { kind: "component", type: ButtonComponent, selector: "button[kendoButton]", inputs: ["arrowIcon", "toggleable", "togglable", "selected", "tabIndex", "imageUrl", "iconClass", "icon", "disabled", "size", "rounded", "fillMode", "themeColor", "svgIcon", "primary", "look"], outputs: ["selectedChange", "click"], exportAs: ["kendoButton"] }, { kind: "directive", type: AIPromptToolbarFocusableDirective, selector: "[kendoAIPromptToolbarFocusable]" }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: FloatingActionButtonComponent, selector: "kendo-floatingactionbutton", inputs: ["themeColor", "size", "rounded", "disabled", "align", "offset", "positionMode", "icon", "svgIcon", "iconClass", "buttonClass", "dialClass", "text", "dialItemAnimation", "tabIndex", "dialItems"], outputs: ["blur", "focus", "dialItemClick", "open", "close"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AIPromptComponent, decorators: [{
            type: Component,
            args: [{
                    exportAs: 'kendoAIPrompt',
                    selector: 'kendo-aiprompt',
                    providers: [
                        LocalizationService,
                        AIPromptService,
                        ToolbarNavigationService,
                        {
                            provide: L10N_PREFIX,
                            useValue: 'kendo.aiprompt'
                        }
                    ],
                    template: `
        <ng-container kendoAIPromptLocalizedMessages
          i18n-promptView="kendo.aiprompt.promptView|The Toolbar button text for the Prompt view."
          promptView="Ask AI"
          i18n-outputView="kendo.aiprompt.outputView|The Toolbar button text for the Output view."
          outputView="Output"
          i18n-generateOutput="kendo.aiprompt.generateOutput|The text for the Generate button in the Prompt view."
          generateOutput="Generate"
          i18n-promptPlaceholder="kendo.aiprompt.promptPlaceholder|The placeholder text for the Prompt View text area."
          promptPlaceholder="Ask or generate content with AI"
          i18n-copyOutput="kendo.aiprompt.copyOutput|The Copy button text in each Output view card."
          copyOutput="Copy"
          i18n-retryGeneration="kendo.aiprompt.retryGeneration|The Retry button text in each Output view card."
          retryGeneration="Retry"
          i18n-outputTitle="kendo.aiprompt.outputTitle|The title of each Output view card."
          outputTitle="Generated with AI"
          i18n-outputRetryTitle="kendo.aiprompt.outputRetryTitle|The title of each Output view retry card."
          outputRetryTitle="Generated with AI"
          i18n-promptSuggestions="kendo.aiprompt.promptSuggestions|The title of the Prompt suggestions button."
          promptSuggestions="Prompt suggestions"
          i18n-speechToTextButton="kendo.aiprompt.speechToTextButton|The aria-label for the Speech to Text button."
          speechToTextButton="Voice input">
        </ng-container>
        <div class="k-prompt-header">
          <div class="k-toolbar-flat k-toolbar k-toolbar-md"
            role="toolbar">
            @for (view of viewsArray; track view; let idx = $index) {
              <button
                kendoButton
                kendoAIPromptToolbarFocusable
                type="button"
                fillMode="flat"
                rounded="full"
                themeColor="primary"
                [svgIcon]="view.svgIcon"
                [icon]="view.icon"
                [selected]="idx === activeView"
                (click)="viewChange(idx)">
                {{view.buttonText}}
              </button>
            }
        
            @if (toolbarActionsTemplate) {
              <ng-template
                [ngTemplateOutlet]="toolbarActionsTemplate?.templateRef">
              </ng-template>
            }
          </div>
        </div>
        <div class="k-prompt-content">
          @if (streaming && selectedView?.viewType === 'output') {
            <kendo-floatingactionbutton #fabButton
              class="k-prompt-stop-fab"
              buttonClass="k-generating k-active"
              [positionMode]="fabPositionMode"
              [align]="fabAlignment"
              [svgIcon]="fabStopGenerationSVGIcon"
              icon="stop"
              (click)="promptRequestCancel.emit()"
              >
            </kendo-floatingactionbutton>
          }
          <div class="k-prompt-view">
            <ng-container *ngTemplateOutlet="viewTemplate">
            </ng-container>
          </div>
        </div>
        @if (selectedView?.viewType === 'prompt') {
          <div class="k-prompt-footer">
            <div class="k-actions k-actions-start k-actions-horizontal k-prompt-actions">
              <button
                kendoButton
                type="button"
                themeColor="primary"
                rounded="full"
                [attr.title]="messageFor('generateOutput')"
                [attr.aria-label]="messageFor('generateOutput')"
                [attr.aria-disabled]="disabledGenerateButton"
                [svgIcon]="generateButtonSVGIcon"
                [icon]="generateButtonIcon"
                [disabled]="disabledGenerateButton"
              (click)="handleGenerateOutput()">{{messageFor('generateOutput')}}</button>
            </div>
          </div>
        }
        `,
                    standalone: true,
                    imports: [LocalizedMessagesDirective$2, ButtonComponent, AIPromptToolbarFocusableDirective, NgTemplateOutlet, FloatingActionButtonComponent]
                }]
        }], ctorParameters: () => [{ type: i1.LocalizationService }, { type: AIPromptService }, { type: ToolbarNavigationService }, { type: i0.NgZone }, { type: i0.ElementRef }, { type: i0.Renderer2 }], propDecorators: { hostClasses: [{
                type: HostBinding,
                args: ['class.k-prompt']
            }], dirAttr: [{
                type: HostBinding,
                args: ['attr.dir']
            }], fabButton: [{
                type: ViewChild,
                args: ['fabButton']
            }], views: [{
                type: ContentChildren,
                args: [BaseView]
            }], toolbarActionsTemplate: [{
                type: ContentChild,
                args: [AIPromptToolbarActionsDirective]
            }], outputTemplate: [{
                type: ContentChild,
                args: [AIPromptOutputTemplateDirective]
            }], outputBodyTemplate: [{
                type: ContentChild,
                args: [AIPromptOutputBodyTemplateDirective]
            }], activeView: [{
                type: Input
            }], promptCommands: [{
                type: Input
            }], promptSuggestions: [{
                type: Input
            }], promptOutputs: [{
                type: Input
            }], showOutputRating: [{
                type: Input
            }], streaming: [{
                type: Input
            }], speechToTextButton: [{
                type: Input
            }], textAreaSettings: [{
                type: Input
            }], generateButtonSVGIcon: [{
                type: Input
            }], generateButtonIcon: [{
                type: Input
            }], disabledGenerateButton: [{
                type: Input
            }], activeViewChange: [{
                type: Output
            }], promptRequest: [{
                type: Output
            }], commandExecute: [{
                type: Output
            }], outputCopy: [{
                type: Output
            }], outputRatingChange: [{
                type: Output
            }], promptRequestCancel: [{
                type: Output
            }] } });

/**
 * Represents the component that renders the **Command** view of the AIPrompt.
 *
 * @example
 * ```html
 * <kendo-aiprompt-command-view
 *      buttonText="My command view">
 * </kendo-aiprompt-command-view>
 * ```
 */
class CommandViewComponent extends BaseView {
    service;
    constructor(localization, service) {
        super('command', localization);
        this.service = service;
    }
    /**
     * @hidden
     */
    panelBarItems = [];
    ngOnInit() {
        if (this.service.promptCommands) {
            this.panelBarItems = this.getPanelBarItems(this.service.promptCommands);
        }
    }
    /**
     * @hidden
     */
    itemClickHandler(ev) {
        if (ev.item.children) {
            return;
        }
        const selectedCommand = this.service.getFlattenPromptCommands().find(c => c.id == ev.item.id);
        if (selectedCommand) {
            const eventArgs = {
                command: selectedCommand,
                sender: this.service.aiPrompt,
                isRetry: false
            };
            this.service.executeEvent.next(eventArgs);
        }
    }
    getPanelBarItems(commands) {
        return commands.map(c => ({
            title: c.text,
            id: c.id,
            icon: c.icon,
            svgIcon: c.svgIcon,
            children: c.children ? this.getPanelBarItems(c.children) : null
        }));
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CommandViewComponent, deps: [{ token: i1.LocalizationService }, { token: AIPromptService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: CommandViewComponent, isStandalone: true, selector: "kendo-aiprompt-command-view", providers: [{
                provide: BaseView,
                useExisting: forwardRef(() => CommandViewComponent)
            }], usesInheritance: true, ngImport: i0, template: `
        <ng-template #content>
            <kendo-panelbar
                [items]="panelBarItems"
                [animate]="false"
                [selectable]="false"
                (itemClick)="itemClickHandler($event)"
            ></kendo-panelbar>
        </ng-template>
    `, isInline: true, dependencies: [{ kind: "component", type: PanelBarComponent, selector: "kendo-panelbar", inputs: ["expandMode", "selectable", "animate", "height", "keepItemContent", "items"], outputs: ["stateChange", "select", "expand", "collapse", "itemClick"], exportAs: ["kendoPanelbar"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CommandViewComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-aiprompt-command-view',
                    providers: [{
                            provide: BaseView,
                            useExisting: forwardRef(() => CommandViewComponent)
                        }],
                    template: `
        <ng-template #content>
            <kendo-panelbar
                [items]="panelBarItems"
                [animate]="false"
                [selectable]="false"
                (itemClick)="itemClickHandler($event)"
            ></kendo-panelbar>
        </ng-template>
    `,
                    standalone: true,
                    imports: [PanelBarComponent]
                }]
        }], ctorParameters: () => [{ type: i1.LocalizationService }, { type: AIPromptService }] });

/**
 * Represents the custom messages component of the AIPrompt.
 *
 * Use this component to override default messages for the AIPrompt
 * ([see example](slug:globalization_chat#custom-messages)).
 *
 * @example
 * ```html
 * <kendo-aiprompt-messages
 *   promptView="My prompt view"
 *   outputView="My output view">
 * </kendo-aiprompt-messages>
 * ```
 */
class AIPromptCustomMessagesComponent extends Messages$2 {
    service;
    constructor(service) {
        super();
        this.service = service;
    }
    get override() {
        return true;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AIPromptCustomMessagesComponent, deps: [{ token: i1.LocalizationService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: AIPromptCustomMessagesComponent, isStandalone: true, selector: "kendo-aiprompt-messages", providers: [
            {
                provide: Messages$2,
                useExisting: forwardRef(() => AIPromptCustomMessagesComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AIPromptCustomMessagesComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: Messages$2,
                            useExisting: forwardRef(() => AIPromptCustomMessagesComponent)
                        }
                    ],
                    selector: 'kendo-aiprompt-messages',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1.LocalizationService }] });

/**
 * Represents the component that renders a **Custom** view in the AIPrompt.
 *
 * @example
 * ```html
 * <kendo-aiprompt-custom-view [viewTemplate]="customTemplate">
 * </kendo-aiprompt-custom-view>
 *
 * <ng-template #customTemplate>
 *   <div>Custom content here</div>
 * </ng-template>
 * ```
 */
class CustomViewComponent extends BaseView {
    constructor(localization) {
        super('custom', localization);
    }
    /**
     * Sets the content of the Custom view as a template reference.
     */
    viewTemplate;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CustomViewComponent, deps: [{ token: i1.LocalizationService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: CustomViewComponent, isStandalone: true, selector: "kendo-aiprompt-custom-view", inputs: { viewTemplate: "viewTemplate" }, providers: [{
                provide: BaseView,
                useExisting: forwardRef(() => CustomViewComponent)
            }], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CustomViewComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-aiprompt-custom-view',
                    providers: [{
                            provide: BaseView,
                            useExisting: forwardRef(() => CustomViewComponent)
                        }],
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1.LocalizationService }], propDecorators: { viewTemplate: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class AIPromptOutputCardComponent {
    localization;
    service;
    hostClass = true;
    listItemRole = 'listitem';
    tabIndex = 0;
    get ariaDescribedBy() {
        return this.titleId;
    }
    ariaKeyShortcuts = 'Enter';
    promptOutput;
    constructor(localization, service) {
        this.localization = localization;
        this.service = service;
    }
    ngOnInit() {
        if (this.promptOutput?.rating === 'positive') {
            this.positiveRatingIcon = thumbUpIcon;
            this.negativeRatingIcon = thumbDownOutlineIcon;
        }
        else if (this.promptOutput?.rating === 'negative') {
            this.negativeRatingIcon = thumbDownIcon;
            this.positiveRatingIcon = thumbUpOutlineIcon;
        }
    }
    copyIcon = copyIcon;
    retryIcon = arrowRotateCwIcon;
    positiveRatingIcon = thumbUpOutlineIcon;
    negativeRatingIcon = thumbDownOutlineIcon;
    titleId = `k-output-card-${guid()}`;
    messageFor(text) {
        return this.localization.get(text);
    }
    get showRating() {
        return this.service.showOutputRating;
    }
    get outputTitle() {
        if (isPresent(this.promptOutput.title)) {
            return this.promptOutput.title;
        }
        else {
            const titleMessage = this.promptOutput.isRetry ? 'outputRetryTitle' : 'outputTitle';
            return this.messageFor(titleMessage);
        }
    }
    handleRetry() {
        if (this.promptOutput.commandId) {
            const eventArgs = {
                command: this.service.getFlattenPromptCommands().find(c => c.id === this.promptOutput.commandId),
                sender: this.service.aiPrompt,
                isRetry: true
            };
            this.service.executeEvent.next(eventArgs);
        }
        else {
            const eventArgs = {
                prompt: this.promptOutput.prompt,
                sender: this.service.aiPrompt,
                isRetry: true
            };
            this.service.requestEvent.next(eventArgs);
        }
    }
    handleCopy() {
        navigator.clipboard.writeText(this.promptOutput.output);
        this.service.outputCopyEvent.next(this.promptOutput);
    }
    handleRating(ratingType) {
        const eventArgs = {
            promptOutput: this.promptOutput,
            rating: ratingType
        };
        this.service.outputRatingChangeEvent.next(eventArgs);
        if (ratingType === 'positive') {
            this.positiveRatingIcon = thumbUpIcon;
            this.negativeRatingIcon = thumbDownOutlineIcon;
        }
        else {
            this.negativeRatingIcon = thumbDownIcon;
            this.positiveRatingIcon = thumbUpOutlineIcon;
        }
    }
    /**
     * @hidden
     */
    get customBodyTemplate() {
        return this.service.outputBodyTemplate?.templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AIPromptOutputCardComponent, deps: [{ token: i1.LocalizationService }, { token: AIPromptService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: AIPromptOutputCardComponent, isStandalone: true, selector: "[kendoAIPromptOutputCard]", inputs: { promptOutput: "promptOutput" }, host: { properties: { "class.k-card": "this.hostClass", "attr.role": "this.listItemRole", "attr.tabindex": "this.tabIndex", "attr.aria-describedby": "this.ariaDescribedBy", "attr.aria-keyshortcuts": "this.ariaKeyShortcuts" } }, ngImport: i0, template: `
        <div class="k-card-header">
          <div
            class="k-card-title"
            [attr.id]="titleId">{{outputTitle}}
          </div>
          <div class="k-card-subtitle">{{promptOutput.prompt}}</div>
        </div>
        <div class="k-card-body">
          @if (customBodyTemplate) {
            <ng-container *ngTemplateOutlet="customBodyTemplate; context: { $implicit: promptOutput }">
            </ng-container>
          } @else {
            <p>{{promptOutput.output}}</p>
          }
        </div>
        <div class="k-actions k-actions-start k-actions-horizontal k-card-actions">
          <button kendoButton
            fillMode="flat"
            themeColor="primary"
            rounded="full"
            icon="copy"
            [svgIcon]="copyIcon"
            (click)="handleCopy()"
          >{{messageFor('copyOutput')}}</button>
          <button kendoButton
            fillMode="flat"
            rounded="full"
            icon="arrow-rotate-cw"
            [svgIcon]="retryIcon"
            (click)="handleRetry()"
          >{{messageFor('retryGeneration')}}</button>
          @if (showRating) {
            <span class="k-spacer"></span>
            <button kendoButton
              fillMode="flat"
              icon="thumb-up-outline"
              [svgIcon]="positiveRatingIcon"
              (click)="handleRating('positive')">
            </button>
            <button kendoButton
              fillMode="flat"
              icon="thumb-down-outline"
              [svgIcon]="negativeRatingIcon"
              (click)="handleRating('negative')">
            </button>
          }
        </div>
        `, isInline: true, dependencies: [{ kind: "component", type: ButtonComponent, selector: "button[kendoButton]", inputs: ["arrowIcon", "toggleable", "togglable", "selected", "tabIndex", "imageUrl", "iconClass", "icon", "disabled", "size", "rounded", "fillMode", "themeColor", "svgIcon", "primary", "look"], outputs: ["selectedChange", "click"], exportAs: ["kendoButton"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AIPromptOutputCardComponent, decorators: [{
            type: Component,
            args: [{
                    selector: '[kendoAIPromptOutputCard]',
                    template: `
        <div class="k-card-header">
          <div
            class="k-card-title"
            [attr.id]="titleId">{{outputTitle}}
          </div>
          <div class="k-card-subtitle">{{promptOutput.prompt}}</div>
        </div>
        <div class="k-card-body">
          @if (customBodyTemplate) {
            <ng-container *ngTemplateOutlet="customBodyTemplate; context: { $implicit: promptOutput }">
            </ng-container>
          } @else {
            <p>{{promptOutput.output}}</p>
          }
        </div>
        <div class="k-actions k-actions-start k-actions-horizontal k-card-actions">
          <button kendoButton
            fillMode="flat"
            themeColor="primary"
            rounded="full"
            icon="copy"
            [svgIcon]="copyIcon"
            (click)="handleCopy()"
          >{{messageFor('copyOutput')}}</button>
          <button kendoButton
            fillMode="flat"
            rounded="full"
            icon="arrow-rotate-cw"
            [svgIcon]="retryIcon"
            (click)="handleRetry()"
          >{{messageFor('retryGeneration')}}</button>
          @if (showRating) {
            <span class="k-spacer"></span>
            <button kendoButton
              fillMode="flat"
              icon="thumb-up-outline"
              [svgIcon]="positiveRatingIcon"
              (click)="handleRating('positive')">
            </button>
            <button kendoButton
              fillMode="flat"
              icon="thumb-down-outline"
              [svgIcon]="negativeRatingIcon"
              (click)="handleRating('negative')">
            </button>
          }
        </div>
        `,
                    standalone: true,
                    imports: [ButtonComponent, NgTemplateOutlet]
                }]
        }], ctorParameters: () => [{ type: i1.LocalizationService }, { type: AIPromptService }], propDecorators: { hostClass: [{
                type: HostBinding,
                args: ['class.k-card']
            }], listItemRole: [{
                type: HostBinding,
                args: ['attr.role']
            }], tabIndex: [{
                type: HostBinding,
                args: ['attr.tabindex']
            }], ariaDescribedBy: [{
                type: HostBinding,
                args: ['attr.aria-describedby']
            }], ariaKeyShortcuts: [{
                type: HostBinding,
                args: ['attr.aria-keyshortcuts']
            }], promptOutput: [{
                type: Input
            }] } });

/**
 * Represents the component that renders the **Output** view of the AIPrompt.
 *
 * @example
 * ```html
 * <kendo-aiprompt-output-view
 *      buttonText="My output view">
 * </kendo-aiprompt-output-view>
 * ```
 */
class OutputViewComponent extends BaseView {
    service;
    constructor(localization, service) {
        super('output', localization);
        this.service = service;
    }
    /**
     * @hidden
     */
    get promptOutputs() {
        return this.service.promptOutputs;
    }
    /**
     * @hidden
     */
    get customTemplate() {
        return this.service.outputTemplate?.templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: OutputViewComponent, deps: [{ token: i1.LocalizationService }, { token: AIPromptService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: OutputViewComponent, isStandalone: true, selector: "kendo-aiprompt-output-view", providers: [{
                provide: BaseView,
                useExisting: forwardRef(() => OutputViewComponent)
            }], usesInheritance: true, ngImport: i0, template: `
        <ng-template #content>
          <div
            class="k-card-list"
            role="list">
            @for (output of promptOutputs; track output) {
              @if (customTemplate) {
                <ng-container *ngTemplateOutlet="customTemplate; context: { $implicit: output }">
                </ng-container>
              } @else {
                <div kendoAIPromptOutputCard [promptOutput]="output"></div>
              }
            }
          </div>
        </ng-template>
        `, isInline: true, dependencies: [{ kind: "component", type: AIPromptOutputCardComponent, selector: "[kendoAIPromptOutputCard]", inputs: ["promptOutput"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: OutputViewComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-aiprompt-output-view',
                    providers: [{
                            provide: BaseView,
                            useExisting: forwardRef(() => OutputViewComponent)
                        }],
                    template: `
        <ng-template #content>
          <div
            class="k-card-list"
            role="list">
            @for (output of promptOutputs; track output) {
              @if (customTemplate) {
                <ng-container *ngTemplateOutlet="customTemplate; context: { $implicit: output }">
                </ng-container>
              } @else {
                <div kendoAIPromptOutputCard [promptOutput]="output"></div>
              }
            }
          </div>
        </ng-template>
        `,
                    standalone: true,
                    imports: [AIPromptOutputCardComponent, NgTemplateOutlet]
                }]
        }], ctorParameters: () => [{ type: i1.LocalizationService }, { type: AIPromptService }] });

/**
 * Represents the component that renders the **Prompt** view of the AIPrompt.
 *
 * @example
 * ```html
 * <kendo-aiprompt-prompt-view
 *      buttonText="My prompt view">
 * </kendo-aiprompt-prompt-view>
 * ```
 */
class PromptViewComponent extends BaseView {
    service;
    constructor(localization, service) {
        super('prompt', localization);
        this.service = service;
    }
    /**
     * @hidden
     */
    get suggestionsIcons() {
        return this.showSuggestions ?
            { font: 'chevron-up', svg: chevronUpIcon } :
            { font: 'chevron-down', svg: chevronDownIcon };
    }
    /**
     * @hidden
     */
    showSuggestions = true;
    /**
     * @hidden
     */
    contentId = `k-prompt-suggestions-${guid()}`;
    /**
     * @hidden
     */
    get promptSuggestions() {
        return this.service.promptSuggestions;
    }
    /**
     *
     * @hidden
     */
    set textAreaValue(value) {
        this.service.promptValue = value;
    }
    get textAreaValue() {
        return this.service.promptValue;
    }
    /**
     * @hidden
     */
    suggestionClick(suggestion) {
        this.textAreaValue = this.service.promptValue = suggestion;
    }
    /**
     * @hidden
     */
    suggestionKeydown(event, suggestion) {
        if (event.key === 'Enter' || event.key === ' ') {
            this.suggestionClick(suggestion);
        }
    }
    /**
     * @hidden
     */
    get speechToTextButtonSettings() {
        return this.service.speechToTextButton;
    }
    /**
     * @hidden
     */
    get textareaSettings() {
        return this.service.textAreaSettings;
    }
    /**
     * @hidden
     */
    onSpeechToTextResult(event) {
        if (event.alternatives && event.alternatives.length > 0) {
            this.textAreaValue += event.alternatives[0].transcript + ' ';
        }
    }
    /**
     * @hidden
     */
    onSpeechToTextError(event) {
        if (isDevMode()) {
            console.error('Speech to Text error:', event.errorMessage);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PromptViewComponent, deps: [{ token: i1.LocalizationService }, { token: AIPromptService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: PromptViewComponent, isStandalone: true, selector: "kendo-aiprompt-prompt-view", providers: [
            {
                provide: BaseView,
                useExisting: forwardRef(() => PromptViewComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: `
        <ng-template #content>
          <kendo-textarea
            [cols]="textareaSettings?.cols"
            [disabled]="textareaSettings?.disabled"
            [fillMode]="textareaSettings?.fillMode"
            [flow]="textareaSettings?.flow ?? 'vertical'"
            [inputAttributes]="textareaSettings?.inputAttributes"
            [maxlength]="textareaSettings?.maxlength"
            [placeholder]="textareaSettings?.placeholder ?? messageFor('promptPlaceholder')"
            [readonly]="textareaSettings?.readonly"
            [resizable]="textareaSettings?.resizable ?? 'vertical'"
            [rounded]="textareaSettings?.rounded"
            [rows]="textareaSettings?.rows ?? 1"
            [selectOnFocus]="textareaSettings?.selectOnFocus"
            [showSuffixSeparator]="textareaSettings?.showSuffixSeparator ?? true"
            [size]="textareaSettings?.size"
            [tabIndex]="textareaSettings?.tabindex"
            [title]="textareaSettings?.title"
            [(value)]="textAreaValue"
            >
            @if (speechToTextButtonSettings) {
              <kendo-textarea-suffix>
                <button kendoSpeechToTextButton
                  role="button"
                  [continuous]="speechToTextButtonSettings?.continuous"
                  [disabled]="speechToTextButtonSettings?.disabled"
                  [fillMode]="speechToTextButtonSettings?.fillMode ?? 'flat'"
                  [integrationMode]="speechToTextButtonSettings?.integrationMode ?? 'webSpeech'"
                  [interimResults]="speechToTextButtonSettings?.interimResults"
                  [lang]="speechToTextButtonSettings?.lang"
                  [maxAlternatives]="speechToTextButtonSettings?.maxAlternatives"
                  [rounded]="speechToTextButtonSettings?.rounded"
                  [size]="speechToTextButtonSettings?.size"
                  [themeColor]="speechToTextButtonSettings?.themeColor"
                  [attr.aria-label]="messageFor('speechToTextButton')"
                  [attr.title]="messageFor('speechToTextButton')"
                  [attr.aria-disabled]="speechToTextButtonSettings?.disabled"
                  (error)="onSpeechToTextError($event)"
                  (result)="onSpeechToTextResult($event)"
                ></button>
              </kendo-textarea-suffix>
            }
          </kendo-textarea>
          @if (promptSuggestions) {
            <div
              class="k-prompt-expander">
              <button kendoButton
                [attr.aria-controls]="contentId"
                [attr.aria-expanded]="showSuggestions"
                fillMode="flat"
                [icon]="suggestionsIcons.font"
                [svgIcon]="suggestionsIcons.svg"
                type="button"
                (click)="showSuggestions = !showSuggestions">
                {{messageFor('promptSuggestions')}}
              </button>
              @if (showSuggestions) {
                <div
                  class="k-prompt-expander-content"
                  [attr.id]="contentId">
                  <div class="k-suggestion-group" role="group">
                    @for (suggestion of promptSuggestions; track suggestion) {
                      <div
                        class="k-suggestion"
                        role="button"
                        [attr.tabindex]="0"
                        [attr.aria-label]="suggestion"
                        [attr.title]="suggestion"
                        (click)="suggestionClick(suggestion)"
                        (keydown)="suggestionKeydown($event, suggestion)">
                        {{suggestion}}
                      </div>
                    }
                  </div>
                </div>
              }
            </div>
          }
        </ng-template>
        `, isInline: true, dependencies: [{ kind: "component", type: TextAreaComponent, selector: "kendo-textarea", inputs: ["focusableId", "flow", "inputAttributes", "adornmentsOrientation", "rows", "cols", "maxlength", "maxResizableRows", "tabindex", "tabIndex", "resizable", "size", "rounded", "fillMode", "showPrefixSeparator", "showSuffixSeparator"], outputs: ["focus", "blur", "valueChange"], exportAs: ["kendoTextArea"] }, { kind: "component", type: ButtonComponent, selector: "button[kendoButton]", inputs: ["arrowIcon", "toggleable", "togglable", "selected", "tabIndex", "imageUrl", "iconClass", "icon", "disabled", "size", "rounded", "fillMode", "themeColor", "svgIcon", "primary", "look"], outputs: ["selectedChange", "click"], exportAs: ["kendoButton"] }, { kind: "component", type: TextAreaSuffixComponent, selector: "kendo-textarea-suffix", inputs: ["flow", "orientation"], exportAs: ["kendoTextAreaSuffix"] }, { kind: "component", type: SpeechToTextButtonComponent, selector: "button[kendoSpeechToTextButton]", inputs: ["disabled", "size", "rounded", "fillMode", "themeColor", "integrationMode", "lang", "continuous", "interimResults", "maxAlternatives"], outputs: ["start", "end", "result", "error", "click"], exportAs: ["kendoSpeechToTextButton"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PromptViewComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-aiprompt-prompt-view',
                    providers: [
                        {
                            provide: BaseView,
                            useExisting: forwardRef(() => PromptViewComponent)
                        }
                    ],
                    template: `
        <ng-template #content>
          <kendo-textarea
            [cols]="textareaSettings?.cols"
            [disabled]="textareaSettings?.disabled"
            [fillMode]="textareaSettings?.fillMode"
            [flow]="textareaSettings?.flow ?? 'vertical'"
            [inputAttributes]="textareaSettings?.inputAttributes"
            [maxlength]="textareaSettings?.maxlength"
            [placeholder]="textareaSettings?.placeholder ?? messageFor('promptPlaceholder')"
            [readonly]="textareaSettings?.readonly"
            [resizable]="textareaSettings?.resizable ?? 'vertical'"
            [rounded]="textareaSettings?.rounded"
            [rows]="textareaSettings?.rows ?? 1"
            [selectOnFocus]="textareaSettings?.selectOnFocus"
            [showSuffixSeparator]="textareaSettings?.showSuffixSeparator ?? true"
            [size]="textareaSettings?.size"
            [tabIndex]="textareaSettings?.tabindex"
            [title]="textareaSettings?.title"
            [(value)]="textAreaValue"
            >
            @if (speechToTextButtonSettings) {
              <kendo-textarea-suffix>
                <button kendoSpeechToTextButton
                  role="button"
                  [continuous]="speechToTextButtonSettings?.continuous"
                  [disabled]="speechToTextButtonSettings?.disabled"
                  [fillMode]="speechToTextButtonSettings?.fillMode ?? 'flat'"
                  [integrationMode]="speechToTextButtonSettings?.integrationMode ?? 'webSpeech'"
                  [interimResults]="speechToTextButtonSettings?.interimResults"
                  [lang]="speechToTextButtonSettings?.lang"
                  [maxAlternatives]="speechToTextButtonSettings?.maxAlternatives"
                  [rounded]="speechToTextButtonSettings?.rounded"
                  [size]="speechToTextButtonSettings?.size"
                  [themeColor]="speechToTextButtonSettings?.themeColor"
                  [attr.aria-label]="messageFor('speechToTextButton')"
                  [attr.title]="messageFor('speechToTextButton')"
                  [attr.aria-disabled]="speechToTextButtonSettings?.disabled"
                  (error)="onSpeechToTextError($event)"
                  (result)="onSpeechToTextResult($event)"
                ></button>
              </kendo-textarea-suffix>
            }
          </kendo-textarea>
          @if (promptSuggestions) {
            <div
              class="k-prompt-expander">
              <button kendoButton
                [attr.aria-controls]="contentId"
                [attr.aria-expanded]="showSuggestions"
                fillMode="flat"
                [icon]="suggestionsIcons.font"
                [svgIcon]="suggestionsIcons.svg"
                type="button"
                (click)="showSuggestions = !showSuggestions">
                {{messageFor('promptSuggestions')}}
              </button>
              @if (showSuggestions) {
                <div
                  class="k-prompt-expander-content"
                  [attr.id]="contentId">
                  <div class="k-suggestion-group" role="group">
                    @for (suggestion of promptSuggestions; track suggestion) {
                      <div
                        class="k-suggestion"
                        role="button"
                        [attr.tabindex]="0"
                        [attr.aria-label]="suggestion"
                        [attr.title]="suggestion"
                        (click)="suggestionClick(suggestion)"
                        (keydown)="suggestionKeydown($event, suggestion)">
                        {{suggestion}}
                      </div>
                    }
                  </div>
                </div>
              }
            </div>
          }
        </ng-template>
        `,
                    standalone: true,
                    imports: [TextAreaComponent, ButtonComponent, TextAreaSuffixComponent, SpeechToTextButtonComponent]
                }]
        }], ctorParameters: () => [{ type: i1.LocalizationService }, { type: AIPromptService }] });

/**
 * Defines a template for displaying message attachments.
 *
 * To define an attachment template, nest an `<ng-template>` tag with the `kendoChatAttachmentTemplate` attribute inside the `<kendo-chat>` component.
 * The template context is set to the attachment instance.
 * For more information, refer to the article on [message attachments](slug:attachments_chat).
 *
 * You can use the following field:
 * - `attachment`&mdash;The attachment instance.
 * - `message`&mdash;The message instance.
 *
 * @example
 * ```html
 * <kendo-chat>
 *   <ng-template kendoChatAttachmentTemplate let-attachment let-message>
 *     <div>Attachment: {{ attachment.content }}</div>
 *   </ng-template>
 * </kendo-chat>
 * ```
 */
class AttachmentTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AttachmentTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: AttachmentTemplateDirective, isStandalone: true, selector: "[kendoChatAttachmentTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AttachmentTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoChatAttachmentTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }] });

const noop = () => { };
const handlers = {
    'reply': (action, sender) => {
        sender.sendMessage.emit(new SendMessageEvent({
            id: guid(),
            author: { id: sender.authorId },
            text: action.value,
            timestamp: new Date()
        }));
    },
    'call': (action) => {
        window.open('tel:' + action.value);
    },
    'openUrl': (action) => {
        window.open(action.value);
    }
};
/**
 * @hidden
 */
const makeHandler = (action) => handlers[action.type] || noop;

/**
 * Creates a message box area that overrides the default message box of the Chat component.
 *
 * To define a message box template, nest an `<ng-template>` tag with the `kendoChatMessageBoxTemplate` directive inside the `<kendo-chat>` tag.
 * For more information, see [Message Box Template](slug:message_templates_chat#toc-message-box-template).
 *
 * @example
 * ```html
 * <kendo-chat>
 *   <ng-template kendoChatMessageBoxTemplate>
 *     <input type="text" placeholder="Custom message box..." />
 *   </ng-template>
 * </kendo-chat>
 * ```
 */
class ChatMessageBoxTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ChatMessageBoxTemplateDirective, deps: [{ token: i0.TemplateRef }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: ChatMessageBoxTemplateDirective, isStandalone: true, selector: "[kendoChatMessageBoxTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ChatMessageBoxTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoChatMessageBoxTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef }] });

/**
 * @hidden
 */
const defaultModelFields = {
    idField: 'id',
    textField: 'text',
    authorIdField: 'authorId',
    authorNameField: 'authorName',
    authorImageUrlField: 'authorImageUrl',
    authorImageAltTextField: 'authorImageAltText',
    timestampField: 'timestamp',
    statusField: 'status',
    filesField: 'files',
    attachmentsField: 'attachments',
    attachmentLayoutField: 'attachmentLayout',
    suggestedActionsField: 'suggestedActions',
    isPinnedField: 'isPinned',
    replyToIdField: 'replyToId',
    isDeletedField: 'isDeleted',
    typingField: 'typing'
};

/**
 * @hidden
 */
const closest = (node, predicate) => {
    while (node && !predicate(node)) {
        node = node.parentNode;
    }
    return node;
};
/**
 * @hidden
 */
const URL_REGEX = /(https?:\/\/[^\s]+)/g;
/**
 * @hidden
 */
const DOWNLOAD_ALL_SELECTOR = '.k-chat-download-button';
/**
 * @hidden
 */
const FILE_ACTION_BTN_SELECTOR = '.k-menu-button';
/**
 * @hidden
 */
const MENU_ITEM_SELECTOR = '.k-menu-link';
/**
 * @hidden
 * Default settings for the Speech to Text button.
 * These settings can be overridden by the user.
 */
const STB_DEFAULT_SETTINGS = {
    continuous: false,
    disabled: false,
    fillMode: 'clear',
    integrationMode: 'webSpeech',
    interimResults: false,
    lang: 'en-US',
    maxAlternatives: 1,
    rounded: 'medium',
    size: 'medium',
    themeColor: 'base'
};
/**
 * @hidden
 */
const SEND_BTN_DEFAULT_SETTINGS = {
    fillMode: 'solid',
    rounded: 'full',
    size: 'medium',
    themeColor: 'primary',
    icon: 'paper-plane',
    svgIcon: paperPlaneIcon,
    buttonClass: 'k-chat-send'
};
/**
 * @hidden
 */
const FILESELECT_DEFAULT_SETTINGS = {
    multiple: true,
    disabled: false
};
/**
 * @hidden
 */
const SUGGESTIONS_LAYOUT_DEFAULT_SETTINGS = 'scroll';
/**
 * @hidden
 */
const CONTEXT_MENU_ACTIONS = [
    {
        id: 'copy',
        label: 'Copy',
        icon: 'copy',
        svgIcon: copyIcon,
        disabled: false
    }, {
        id: 'reply',
        label: 'Reply',
        icon: 'undo',
        svgIcon: undoIcon,
        disabled: false
    }
];
/**
 * @hidden
 */
const FILE_ACTIONS = [
    {
        id: 'download',
        label: 'Download',
        icon: 'download',
        svgIcon: downloadIcon,
        disabled: false
    }
];
/**
 * @hidden
 */
const processMessages = (messages, fields) => {
    const modelFields = { ...defaultModelFields, ...fields };
    return messages.map((message) => parseMessage(message, modelFields));
};
/**
 * @hidden
 */
const parseMessage = (message, fields) => {
    const modelFields = { ...defaultModelFields, ...fields };
    let author;
    const authorId = getter(modelFields.authorIdField || 'authorId')(message);
    const authorName = getter(modelFields.authorNameField || 'authorName')(message);
    const authorImageUrl = getter(modelFields.authorImageUrlField || 'authorImageUrl')(message);
    const authorImageAltText = getter(modelFields.authorImageAltTextField || 'authorImageAltText')(message);
    if (authorId !== undefined) {
        author = {
            id: authorId,
            ...(authorName && { name: authorName }),
            ...(authorImageUrl && { avatarUrl: authorImageUrl }),
            ...(authorImageAltText && { avatarAltText: authorImageAltText }),
        };
    }
    const timestampValue = getter(modelFields.timestampField)(message);
    const timestamp = timestampValue instanceof Date ? timestampValue : new Date(timestampValue);
    return {
        id: getter(modelFields.idField)(message),
        text: getter(modelFields.textField)(message),
        author: author,
        timestamp: timestamp,
        status: getter(modelFields.statusField)(message),
        files: getter(modelFields.filesField)(message),
        attachments: getter(modelFields.attachmentsField)(message),
        attachmentLayout: getter(modelFields.attachmentLayoutField)(message),
        suggestedActions: getter(modelFields.suggestedActionsField)(message),
        isPinned: getter(modelFields.isPinnedField)(message),
        replyToId: getter(modelFields.replyToIdField)(message),
        isDeleted: getter(modelFields.isDeletedField)(message),
        typing: getter(modelFields.typingField)(message),
        dataItem: message
    };
};
/**
 * @hidden
 */
const transformActions = (actions) => {
    return actions.map(action => ({
        text: action.label,
        icon: action.icon,
        svgIcon: action.svgIcon,
        disabled: action.disabled,
        originalAction: action
    }));
};

/**
 * @hidden
 */
class ChatService {
    authorId;
    messageWidthMode;
    messageToolbarActions = [];
    messageContextMenuActions = [];
    calculatedContextMenuActions = [];
    fileActions = [];
    toggleMessageState = false;
    reply;
    messages = [];
    chatElement;
    messageElementsMap = new Map();
    messagesContextMenu;
    activeMessage;
    activeMessageElement;
    selectOnMenuClose = false;
    active = false;
    messageFilesLayout = 'vertical';
    timestampVisibility = 'focus';
    showUsername = true;
    showAvatar = true;
    _enableSpeechToText = STB_DEFAULT_SETTINGS;
    _enableFileSelect = FILESELECT_DEFAULT_SETTINGS;
    _sendButtonSettings = SEND_BTN_DEFAULT_SETTINGS;
    _suggestionsLayout = SUGGESTIONS_LAYOUT_DEFAULT_SETTINGS;
    _quickActionsLayout = SUGGESTIONS_LAYOUT_DEFAULT_SETTINGS;
    _authorMessageSettings;
    _receiverMessageSettings;
    _allowMessageCollapse;
    subjects = {
        toolbarAction: new Subject(),
        contextMenuAction: new Subject(),
        fileAction: new Subject(),
        fileDownload: new Subject(),
        replyReferenceClick: new Subject(),
        inputValueChange: new Subject(),
        contextMenuVisibilityChange: new Subject(),
        suggestionsLayoutChange: new Subject(),
        quickActionsLayoutChange: new Subject(),
        authorMessageSettingsChange: new Subject(),
        receiverMessageSettingsChange: new Subject(),
        allowMessageCollapseChange: new Subject(),
    };
    toolbarAction$ = this.subjects.toolbarAction.asObservable();
    contextMenuAction$ = this.subjects.contextMenuAction.asObservable();
    fileAction$ = this.subjects.fileAction.asObservable();
    fileDownload$ = this.subjects.fileDownload.asObservable();
    replyReferenceClick$ = this.subjects.replyReferenceClick.asObservable();
    inputValueChange$ = this.subjects.inputValueChange.asObservable();
    contextMenuVisibilityChange$ = this.subjects.contextMenuVisibilityChange.asObservable();
    suggestionsLayoutChange$ = this.subjects.suggestionsLayoutChange.asObservable();
    quickActionsLayoutChange$ = this.subjects.quickActionsLayoutChange.asObservable();
    authorMessageSettingsChange$ = this.subjects.authorMessageSettingsChange.asObservable();
    receiverMessageSettingsChange$ = this.subjects.receiverMessageSettingsChange.asObservable();
    allowMessageCollapseChange$ = this.subjects.allowMessageCollapseChange.asObservable();
    set authorMessageSettings(settings) {
        const previousSettings = this._authorMessageSettings;
        if (JSON.stringify(previousSettings) !== JSON.stringify(settings)) {
            this.updateComponentSettings('_authorMessageSettings', settings, null);
            this.emit('authorMessageSettingsChange', this._authorMessageSettings);
        }
    }
    get authorMessageSettings() {
        return this._authorMessageSettings;
    }
    set receiverMessageSettings(settings) {
        const previousSettings = this._receiverMessageSettings;
        if (JSON.stringify(previousSettings) !== JSON.stringify(settings)) {
            this.updateComponentSettings('_receiverMessageSettings', settings, null);
            this.emit('receiverMessageSettingsChange', this._receiverMessageSettings);
        }
    }
    get receiverMessageSettings() {
        return this._receiverMessageSettings;
    }
    set enableSpeechToText(settings) {
        this.updateComponentSettings('_enableSpeechToText', settings, STB_DEFAULT_SETTINGS);
    }
    get enableSpeechToText() {
        return this._enableSpeechToText;
    }
    set enableFileSelect(settings) {
        this.updateComponentSettings('_enableFileSelect', settings, FILESELECT_DEFAULT_SETTINGS);
    }
    get enableFileSelect() {
        return this._enableFileSelect;
    }
    set sendButtonSettings(settings) {
        this.updateComponentSettings('_sendButtonSettings', settings, SEND_BTN_DEFAULT_SETTINGS);
    }
    get sendButtonSettings() {
        return this._sendButtonSettings;
    }
    set suggestionsLayout(layoutMode) {
        this._suggestionsLayout = layoutMode;
        this.emit('suggestionsLayoutChange', this._suggestionsLayout);
    }
    get suggestionsLayout() {
        return this._suggestionsLayout;
    }
    set quickActionsLayout(layoutMode) {
        this._quickActionsLayout = layoutMode;
        this.emit('quickActionsLayoutChange', this._quickActionsLayout);
    }
    get quickActionsLayout() {
        return this._quickActionsLayout;
    }
    set allowMessageCollapse(value) {
        const previousValue = this._allowMessageCollapse;
        if (previousValue !== value) {
            this._allowMessageCollapse = value;
            this.emit('allowMessageCollapseChange', this._allowMessageCollapse);
        }
    }
    get allowMessageCollapse() {
        return this._allowMessageCollapse;
    }
    calculateContextMenuActions(isOwn) {
        const settings = isOwn ? this.authorMessageSettings : this.receiverMessageSettings;
        if (settings?.messageContextMenuActions) {
            this.calculatedContextMenuActions = settings.messageContextMenuActions;
            return;
        }
        this.calculatedContextMenuActions = this.messageContextMenuActions || [];
    }
    emit(subjectKey, value) {
        (this.subjects[subjectKey]).next(value);
    }
    getMessageById(id) {
        return this.messages.find(message => message.id === id);
    }
    registerMessageElement(messageId, elementRef) {
        this.messageElementsMap.set(messageId, elementRef);
    }
    unregisterMessageElement(messageId) {
        this.messageElementsMap.delete(messageId);
        if (this.reply?.id === messageId) {
            this.reply = null;
        }
    }
    scrollToMessage(messageId) {
        const elementRef = this.messageElementsMap.get(messageId);
        if (elementRef?.nativeElement) {
            elementRef.nativeElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
    }
    focusActiveMessageElement() {
        if (this.activeMessageElement) {
            this.activeMessageElement.element?.nativeElement?.focus();
        }
    }
    updateComponentSettings(property, settings, defaultSettings) {
        if (settings === true) {
            this[property] = defaultSettings;
        }
        else if (settings === false) {
            this[property] = null;
        }
        else {
            this[property] = { ...defaultSettings, ...settings };
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ChatService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ChatService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ChatService, decorators: [{
            type: Injectable
        }] });

/**
 * @hidden
 */
class ChatItem {
    selected;
}

/**
 * Represents the template for a suggestion in the Chat component.
 *
 * You can use the following field:
 * - `suggestion`&mdash;The suggestion instance.
 *
 * @example
 * ```html
 * <kendo-chat>
 *     <ng-template kendoChatSuggestionTemplate let-suggestion>
 *         {{ suggestion.text }}
 *     </ng-template>
 * </kendo-chat>
 * ```
 */
class ChatSuggestionTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ChatSuggestionTemplateDirective, deps: [{ token: i0.TemplateRef }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: ChatSuggestionTemplateDirective, isStandalone: true, selector: "[kendoChatSuggestionTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ChatSuggestionTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoChatSuggestionTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef }] });

const DIRECTION_CLASSES = {
    left: 'chevron-left',
    right: 'chevron-right',
};
/**
 * @hidden
 */
class ChatScrollableButtonComponent {
    host;
    renderer;
    ngZone;
    localization;
    role = 'button';
    prev = false;
    onClick = new EventEmitter();
    get scrollButtonIconClass() {
        const defaultPrevIcon = !this.localization.rtl ? DIRECTION_CLASSES.left : DIRECTION_CLASSES.right;
        const defaultNextIcon = !this.localization.rtl ? DIRECTION_CLASSES.right : DIRECTION_CLASSES.left;
        return this.prev ? defaultPrevIcon : defaultNextIcon;
    }
    get scrollButtonSVGIcon() {
        const defaultPrevSVGIcon = !this.localization.rtl ? this.chevronLeftIcon : this.chevronRightIcon;
        const defaultNextSVGIcon = !this.localization.rtl ? this.chevronRightIcon : this.chevronLeftIcon;
        return this.prev ? defaultPrevSVGIcon : defaultNextSVGIcon;
    }
    chevronLeftIcon = chevronLeftIcon;
    chevronRightIcon = chevronRightIcon;
    subs = new Subscription();
    constructor(host, renderer, ngZone, localization) {
        this.host = host;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.localization = localization;
    }
    ngAfterViewInit() {
        this.ngZone.runOutsideAngular(() => {
            this.subs.add(this.renderer.listen(this.host.nativeElement, 'click', () => this.clickHandler()));
        });
    }
    ngOnDestroy() {
        this.subs.unsubscribe();
    }
    clickHandler() {
        const buttonType = this.prev ? 'prev' : 'next';
        this.onClick.emit(buttonType);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ChatScrollableButtonComponent, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }, { token: i0.NgZone }, { token: i1.LocalizationService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: ChatScrollableButtonComponent, isStandalone: true, selector: "[kendoChatScrollableButton]", inputs: { prev: "prev" }, outputs: { onClick: "onClick" }, host: { properties: { "attr.role": "this.role" } }, ngImport: i0, template: `
        <kendo-icon-wrapper [name]="scrollButtonIconClass" [svgIcon]="scrollButtonSVGIcon" innerCssClass="k-button-icon"> </kendo-icon-wrapper>
    `, isInline: true, dependencies: [{ kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ChatScrollableButtonComponent, decorators: [{
            type: Component,
            args: [{
                    template: `
        <kendo-icon-wrapper [name]="scrollButtonIconClass" [svgIcon]="scrollButtonSVGIcon" innerCssClass="k-button-icon"> </kendo-icon-wrapper>
    `,
                    // eslint-disable-next-line @angular-eslint/component-selector
                    selector: '[kendoChatScrollableButton]',
                    standalone: true,
                    imports: [IconWrapperComponent],
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i0.NgZone }, { type: i1.LocalizationService }], propDecorators: { role: [{
                type: HostBinding,
                args: ['attr.role']
            }], prev: [{
                type: Input
            }], onClick: [{
                type: Output
            }] } });

const DEFAULT_SCROLL_BEHAVIOR = 'smooth';
const DEFAULT_SCROLL_SPEED = 100;
/**
 * @hidden
 */
class SuggestionsScrollService {
    ngZone;
    localization;
    owner;
    position = 0;
    scrollButtonActiveStateChange = new Subject();
    get scrollElement() {
        return this.owner.suggestionsContainer?.nativeElement;
    }
    get scrollContainerOverflowSize() {
        if (!isDocumentAvailable()) {
            return 0;
        }
        if (!this.scrollElement) {
            return 0;
        }
        const overflowSize = Math.floor(this.scrollElement.scrollWidth - this.scrollElement.offsetWidth);
        return overflowSize < 0 ? 0 : overflowSize;
    }
    get suggestionsOverflow() {
        return this.scrollContainerOverflowSize > 0;
    }
    constructor(ngZone, localization) {
        this.ngZone = ngZone;
        this.localization = localization;
    }
    toggleScrollButtonsState() {
        const suggestedActions = this.owner;
        if (!suggestedActions?.hasScrollButtons) {
            return;
        }
        const currentPrevButtonActive = !this.isDisabled('prev');
        const currentNextButtonActive = !this.isDisabled('next');
        const defaultOffset = 1;
        const rtlDelta = this.localization.rtl ? -1 : 1;
        const calculatedPrevButtonActive = (this.position * rtlDelta) > 0 && this.scrollContainerOverflowSize > 0;
        const calculatedNextButtonActive = (this.position * rtlDelta) < this.scrollContainerOverflowSize - defaultOffset && this.scrollContainerOverflowSize > 0;
        if (calculatedPrevButtonActive !== currentPrevButtonActive) {
            this.ngZone.run(() => this.toggleButtonActiveState('prev', calculatedPrevButtonActive));
        }
        if (calculatedNextButtonActive !== currentNextButtonActive) {
            this.ngZone.run(() => this.toggleButtonActiveState('next', calculatedNextButtonActive));
        }
    }
    onScroll(e) {
        this.position = e.target.scrollLeft;
        this.toggleScrollButtonsState();
    }
    scrollSuggestions(direction) {
        this.calculateListPosition(direction, DEFAULT_SCROLL_SPEED);
        if (this.scrollElement) {
            this.scrollElement.scrollTo({ left: this.position, behavior: DEFAULT_SCROLL_BEHAVIOR });
        }
        this.toggleScrollButtonsState();
    }
    updateScrollPosition(element) {
        this.position = element.scrollLeft;
    }
    calculateListPosition(direction, scrollSpeed) {
        if (direction === 'prev') {
            if (!this.localization.rtl) {
                this.position = this.position - scrollSpeed <= 0 ? 0 : this.position - scrollSpeed;
            }
            else {
                this.position = this.position + scrollSpeed >= 0 ? 0 : this.position + scrollSpeed;
            }
        }
        else if (direction === 'next' && this.position < this.scrollContainerOverflowSize) {
            if (this.position + scrollSpeed > this.scrollContainerOverflowSize) {
                if (this.localization.rtl) {
                    this.position = -this.scrollContainerOverflowSize;
                }
                else {
                    this.position = this.scrollContainerOverflowSize;
                }
                return;
            }
            if (this.localization.rtl) {
                this.position -= scrollSpeed;
            }
            else {
                this.position += scrollSpeed;
            }
        }
    }
    toggleButtonActiveState(buttonType, active) {
        this.scrollButtonActiveStateChange.next({ buttonType, active });
    }
    isDisabled = (buttonType) => this.owner[`${buttonType}ScrollButton`]?.nativeElement.classList.contains('k-disabled');
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SuggestionsScrollService, deps: [{ token: i0.NgZone }, { token: i1.LocalizationService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SuggestionsScrollService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SuggestionsScrollService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: i0.NgZone }, { type: i1.LocalizationService }] });

/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/no-empty-function */
/**
 * @hidden
 */
class SuggestedActionsComponent extends ChatItem {
    chatService;
    localization;
    scrollService;
    ngZone;
    renderer;
    get defaultClass() {
        if (this.type === 'suggestion') {
            return this.chatService.suggestionsLayout === 'wrap' || this.chatService.suggestionsLayout === 'scroll';
        }
        else if (this.type === 'action') {
            return this.chatService.quickActionsLayout === 'wrap' || this.chatService.quickActionsLayout === 'scroll';
        }
    }
    get scrollableClass() {
        if (this.type === 'suggestion') {
            return this.chatService.suggestionsLayout === 'scroll';
        }
        else if (this.type === 'action') {
            return this.chatService.quickActionsLayout === 'scroll';
        }
    }
    get scrollButtonsClass() {
        if (this.type === 'suggestion') {
            return this.chatService.suggestionsLayout === 'scrollbuttons';
        }
        else if (this.type === 'action') {
            return this.chatService.quickActionsLayout === 'scrollbuttons';
        }
    }
    get role() {
        if (!this.hasScrollButtons) {
            return 'group';
        }
        return null;
    }
    actions;
    suggestions;
    tabbable;
    type;
    suggestionTemplate;
    dispatchAction = new EventEmitter();
    dispatchSuggestion = new EventEmitter();
    items;
    suggestionsContainer;
    prevScrollButton;
    nextScrollButton;
    selectedIndex = 0;
    activeIndex = -1;
    active = false;
    get hasScrollButtons() {
        return this.type === 'suggestion' ? this.chatService.suggestionsLayout === 'scrollbuttons' : this.chatService.quickActionsLayout === 'scrollbuttons';
    }
    subscriptions = new Subscription();
    resizeObserver = null;
    actionKeyHandlers = {
        [Keys.Tab]: (e) => this.changeSelectedIndex(e),
        [Keys.Enter]: (_, action) => this.actionClick(action),
        [Keys.Space]: (_, action) => this.actionClick(action),
    };
    suggestionKeyHandlers = {
        [Keys.Tab]: (e) => this.changeSelectedIndex(e),
        [Keys.Enter]: (_, suggestion) => this.suggestionClick(suggestion),
        [Keys.Space]: (_, suggestion) => this.suggestionClick(suggestion),
    };
    constructor(chatService, localization, scrollService, ngZone, renderer) {
        super();
        this.chatService = chatService;
        this.localization = localization;
        this.scrollService = scrollService;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.scrollService.owner = this;
    }
    ngAfterViewInit() {
        const layoutChangeObservable = this.type === 'suggestion'
            ? this.chatService.suggestionsLayoutChange$
            : this.chatService.quickActionsLayoutChange$;
        this.subscriptions.add(layoutChangeObservable.subscribe((layoutMode) => {
            if (layoutMode === 'scrollbuttons') {
                this.ngZone.onStable.pipe(take(1)).subscribe(() => {
                    if (this.suggestionsContainer) {
                        this.scrollService.updateScrollPosition(this.suggestionsContainer.nativeElement);
                    }
                    this.scrollService.toggleScrollButtonsState();
                });
            }
        }));
        this.subscriptions.add(this.scrollService.scrollButtonActiveStateChange.subscribe((change) => {
            this.toggleScrollButtonState(change.buttonType, change.active);
        }));
        if (this.hasScrollButtons && this.suggestionsContainer) {
            this.ngZone.runOutsideAngular(() => {
                this.resizeObserver = new ResizeObserver(() => {
                    this.ngZone.run(() => {
                        this.scrollService.toggleScrollButtonsState();
                    });
                });
                this.resizeObserver.observe(this.suggestionsContainer.nativeElement);
            });
        }
        if (this.hasScrollButtons) {
            this.ngZone.onStable.pipe(take(1)).subscribe(() => {
                this.scrollService.toggleScrollButtonsState();
            });
            if (this.suggestionsContainer) {
                this.scrollService.updateScrollPosition(this.suggestionsContainer.nativeElement);
            }
        }
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
        if (this.resizeObserver) {
            this.resizeObserver.disconnect();
            this.resizeObserver = null;
        }
    }
    isSelected(index) {
        return this.selected && this.selectedIndex === index;
    }
    isActive(index) {
        return this.activeIndex === index;
    }
    actionClick(action, index) {
        if (index >= 0) {
            this.selectedIndex = index;
        }
        this.dispatchAction.next(action);
    }
    suggestionClick(suggestion, index) {
        if (index >= 0) {
            this.selectedIndex = index;
        }
        this.dispatchSuggestion.next(suggestion);
    }
    toggleActiveState(apply, index) {
        this.activeIndex = apply ? index : -1;
    }
    actionKeydown(e, action) {
        const handler = this.actionKeyHandlers[normalizeKeys(e)];
        if (handler) {
            handler(e, action);
        }
    }
    suggestionKeydown(e, suggestion) {
        const handler = this.suggestionKeyHandlers[normalizeKeys(e)];
        if (handler) {
            handler(e, suggestion);
        }
    }
    getScrollButtonTitle(direction) {
        let currentButton;
        if (this.localization.rtl) {
            currentButton = direction === 'prev' ? 'nextSuggestionsButtonTitle' : 'previousSuggestionsButtonTitle';
        }
        else {
            currentButton = direction === 'prev' ? 'previousSuggestionsButtonTitle' : 'nextSuggestionsButtonTitle';
        }
        return this.localization.get(currentButton);
    }
    onScroll(event) {
        this.scrollService.onScroll(event);
    }
    scrollSuggestions(direction) {
        this.scrollService.scrollSuggestions(direction);
    }
    focus() { }
    toggleScrollButtonState(buttonType, active) {
        const button = this[`${buttonType}ScrollButton`];
        if (button?.nativeElement) {
            if (active) {
                this.renderer.removeClass(button.nativeElement, 'k-disabled');
            }
            else {
                this.renderer.addClass(button.nativeElement, 'k-disabled');
            }
        }
    }
    changeSelectedIndex(e) {
        const offset = e.shiftKey ? -1 : 1;
        const prevIndex = this.selectedIndex;
        this.selectedIndex = Math.max(0, Math.min(prevIndex + offset, this.items.length - 1));
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SuggestedActionsComponent, deps: [{ token: ChatService }, { token: i1.LocalizationService }, { token: SuggestionsScrollService }, { token: i0.NgZone }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: SuggestedActionsComponent, isStandalone: true, selector: "kendo-chat-suggested-actions", inputs: { actions: "actions", suggestions: "suggestions", tabbable: "tabbable", type: "type", suggestionTemplate: "suggestionTemplate" }, outputs: { dispatchAction: "dispatchAction", dispatchSuggestion: "dispatchSuggestion" }, host: { properties: { "class.k-suggestion-group": "this.defaultClass", "class.k-suggestion-group-scrollable": "this.scrollableClass", "class.k-suggestion-scrollwrap": "this.scrollButtonsClass", "attr.role": "this.role" } }, providers: [{
                provide: ChatItem,
                useExisting: forwardRef(() => SuggestedActionsComponent)
            },
            SuggestionsScrollService
        ], viewQueries: [{ propertyName: "suggestionsContainer", first: true, predicate: ["suggestionsContainer"], descendants: true, read: ElementRef }, { propertyName: "prevScrollButton", first: true, predicate: ["prevScrollButton"], descendants: true, read: ElementRef }, { propertyName: "nextScrollButton", first: true, predicate: ["nextScrollButton"], descendants: true, read: ElementRef }, { propertyName: "items", predicate: ["item"], descendants: true }], usesInheritance: true, ngImport: i0, template: `
        @if (hasScrollButtons) {
          <span
            #prevScrollButton
            kendoChatScrollableButton
            [prev]="true"
            [title]="getScrollButtonTitle('prev')"
            class="k-button k-button-md k-button-solid k-button-solid-base k-rounded-md k-icon-button"
            (onClick)="scrollSuggestions($event)"
            >
          </span>
        }
        @if (hasScrollButtons) {
          <div class="k-suggestion-group"
            #suggestionsContainer
            role="group"
            (scroll)="onScroll($event)">
            <ng-container *ngTemplateOutlet="suggestionsContent"></ng-container>
          </div>
        } @else {
          <ng-container *ngTemplateOutlet="suggestionsContent"></ng-container>
        }
        
        
        <ng-template #suggestionsContent>
          @if (actions) {
            @for (action of actions; track action; let index = $index; let first = $first; let last = $last) {
              <span
                #item
                class="k-suggestion k-suggestion-primary"
                role="button"
                [class.k-selected]="isSelected(index)"
                [class.k-focus]="isSelected(index)"
                [class.k-active]="isActive(index)"
                [attr.tabindex]="0"
                (click)="actionClick(action, index)"
                (keydown)="actionKeydown($event, action)"
                (mousedown)="toggleActiveState(true, index)"
                (mouseup)="toggleActiveState(false, index)"
                >
                {{ action.title || action.value }}
              </span>
            }
          }
        
          @if (suggestions) {
            @if (!suggestionTemplate?.templateRef) {
              @for (suggestion of suggestions; track suggestion; let index = $index; let first = $first; let last = $last) {
                <span
                  #item
                  class="k-suggestion"
                  role="button"
                  [class.k-selected]="isSelected(index)"
                  [class.k-focus]="isSelected(index)"
                  [class.k-active]="isActive(index)"
                  [attr.tabindex]="0"
                  (click)="suggestionClick(suggestion, index)"
                  (keydown)="suggestionKeydown($event, suggestion)"
                  (mousedown)="toggleActiveState(true, index)"
                  (mouseup)="toggleActiveState(false, index)"
                  >
                  {{ suggestion.text }}
                </span>
              }
            }
            @if (suggestionTemplate?.templateRef) {
              @for (suggestion of suggestions; track suggestion) {
                <ng-template
                  [ngTemplateOutlet]="suggestionTemplate.templateRef"
                  [ngTemplateOutletContext]="{ $implicit: suggestion }"
                  >
                </ng-template>
              }
            }
          }
        </ng-template>
        
        @if (hasScrollButtons) {
          <span
            #nextScrollButton
            kendoChatScrollableButton
            [prev]="false"
            [title]="getScrollButtonTitle('next')"
            class="k-button k-button-md k-button-solid k-button-solid-base k-rounded-md k-icon-button"
            (onClick)="scrollSuggestions($event)"
            >
          </span>
        }
        `, isInline: true, dependencies: [{ kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: ChatScrollableButtonComponent, selector: "[kendoChatScrollableButton]", inputs: ["prev"], outputs: ["onClick"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SuggestedActionsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-chat-suggested-actions',
                    providers: [{
                            provide: ChatItem,
                            useExisting: forwardRef(() => SuggestedActionsComponent)
                        },
                        SuggestionsScrollService],
                    template: `
        @if (hasScrollButtons) {
          <span
            #prevScrollButton
            kendoChatScrollableButton
            [prev]="true"
            [title]="getScrollButtonTitle('prev')"
            class="k-button k-button-md k-button-solid k-button-solid-base k-rounded-md k-icon-button"
            (onClick)="scrollSuggestions($event)"
            >
          </span>
        }
        @if (hasScrollButtons) {
          <div class="k-suggestion-group"
            #suggestionsContainer
            role="group"
            (scroll)="onScroll($event)">
            <ng-container *ngTemplateOutlet="suggestionsContent"></ng-container>
          </div>
        } @else {
          <ng-container *ngTemplateOutlet="suggestionsContent"></ng-container>
        }
        
        
        <ng-template #suggestionsContent>
          @if (actions) {
            @for (action of actions; track action; let index = $index; let first = $first; let last = $last) {
              <span
                #item
                class="k-suggestion k-suggestion-primary"
                role="button"
                [class.k-selected]="isSelected(index)"
                [class.k-focus]="isSelected(index)"
                [class.k-active]="isActive(index)"
                [attr.tabindex]="0"
                (click)="actionClick(action, index)"
                (keydown)="actionKeydown($event, action)"
                (mousedown)="toggleActiveState(true, index)"
                (mouseup)="toggleActiveState(false, index)"
                >
                {{ action.title || action.value }}
              </span>
            }
          }
        
          @if (suggestions) {
            @if (!suggestionTemplate?.templateRef) {
              @for (suggestion of suggestions; track suggestion; let index = $index; let first = $first; let last = $last) {
                <span
                  #item
                  class="k-suggestion"
                  role="button"
                  [class.k-selected]="isSelected(index)"
                  [class.k-focus]="isSelected(index)"
                  [class.k-active]="isActive(index)"
                  [attr.tabindex]="0"
                  (click)="suggestionClick(suggestion, index)"
                  (keydown)="suggestionKeydown($event, suggestion)"
                  (mousedown)="toggleActiveState(true, index)"
                  (mouseup)="toggleActiveState(false, index)"
                  >
                  {{ suggestion.text }}
                </span>
              }
            }
            @if (suggestionTemplate?.templateRef) {
              @for (suggestion of suggestions; track suggestion) {
                <ng-template
                  [ngTemplateOutlet]="suggestionTemplate.templateRef"
                  [ngTemplateOutletContext]="{ $implicit: suggestion }"
                  >
                </ng-template>
              }
            }
          }
        </ng-template>
        
        @if (hasScrollButtons) {
          <span
            #nextScrollButton
            kendoChatScrollableButton
            [prev]="false"
            [title]="getScrollButtonTitle('next')"
            class="k-button k-button-md k-button-solid k-button-solid-base k-rounded-md k-icon-button"
            (onClick)="scrollSuggestions($event)"
            >
          </span>
        }
        `,
                    standalone: true,
                    imports: [NgTemplateOutlet, ChatScrollableButtonComponent]
                }]
        }], ctorParameters: () => [{ type: ChatService }, { type: i1.LocalizationService }, { type: SuggestionsScrollService }, { type: i0.NgZone }, { type: i0.Renderer2 }], propDecorators: { defaultClass: [{
                type: HostBinding,
                args: ['class.k-suggestion-group']
            }], scrollableClass: [{
                type: HostBinding,
                args: ['class.k-suggestion-group-scrollable']
            }], scrollButtonsClass: [{
                type: HostBinding,
                args: ['class.k-suggestion-scrollwrap']
            }], role: [{
                type: HostBinding,
                args: ['attr.role']
            }], actions: [{
                type: Input
            }], suggestions: [{
                type: Input
            }], tabbable: [{
                type: Input
            }], type: [{
                type: Input
            }], suggestionTemplate: [{
                type: Input
            }], dispatchAction: [{
                type: Output
            }], dispatchSuggestion: [{
                type: Output
            }], items: [{
                type: ViewChildren,
                args: ['item']
            }], suggestionsContainer: [{
                type: ViewChild,
                args: ['suggestionsContainer', { read: ElementRef, static: false }]
            }], prevScrollButton: [{
                type: ViewChild,
                args: ['prevScrollButton', { read: ElementRef }]
            }], nextScrollButton: [{
                type: ViewChild,
                args: ['nextScrollButton', { read: ElementRef }]
            }] } });

/* eslint-disable @typescript-eslint/no-empty-function */
/**
 * @hidden
 */
class ChatFileComponent extends ChatItem {
    localization;
    chatFile;
    removable = false;
    fileActions;
    remove = new EventEmitter();
    actionClick = new EventEmitter();
    actionsToggle = new EventEmitter();
    actionButtonClick = new EventEmitter();
    deleteIcon = xIcon;
    moreIcon = moreVerticalIcon;
    constructor(localization) {
        super();
        this.localization = localization;
    }
    fileThumbnail(extension) {
        return fileSVGGroupIcon(extension);
    }
    fileGroupClass(extension) {
        return fileGroupClass(extension);
    }
    getTotalFilesSizeMessage(file) {
        return getTotalFilesSizeMessage([file]);
    }
    textFor(key) {
        return this.localization.get(key);
    }
    focus() { }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ChatFileComponent, deps: [{ token: i1.LocalizationService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: ChatFileComponent, isStandalone: true, selector: "li[chatFile]", inputs: { chatFile: "chatFile", removable: "removable", fileActions: "fileActions" }, outputs: { remove: "remove", actionClick: "actionClick", actionsToggle: "actionsToggle", actionButtonClick: "actionButtonClick" }, providers: [{
                provide: ChatItem,
                useExisting: forwardRef(() => ChatFileComponent)
            }], usesInheritance: true, ngImport: i0, template: `
        <kendo-icon-wrapper
          size="xlarge"
          [name]="fileGroupClass(chatFile.extension)"
          [svgIcon]="fileThumbnail(chatFile.extension)"
          >
        </kendo-icon-wrapper>
        <div class="k-chat-file-info">
          <span class="k-chat-file-name">{{chatFile.name}}</span>
          <span class="k-chat-file-size">{{getTotalFilesSizeMessage(chatFile)}}</span>
        </div>
        @if (removable) {
          <button
            kendoButton
            [attr.title]="textFor('removeFileTitle')"
            [svgIcon]="deleteIcon"
            (click)="remove.emit(chatFile)"
            fillMode="flat"
          ></button>
        }
        @if (fileActions && fileActions.length > 0) {
          <kendo-dropdownbutton
            [data]="fileActions"
            [attr.title]="textFor('fileActionsTitle')"
            fillMode="flat"
            icon="more-vertical"
            [svgIcon]="moreIcon"
            (itemClick)="actionClick.emit($event)"
            (click)="$event.preventDefault()"
            (open)="actionsToggle.emit(true)"
            (close)="actionsToggle.emit(false)"
          ></kendo-dropdownbutton>
        }
        `, isInline: true, dependencies: [{ kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "component", type: ButtonComponent, selector: "button[kendoButton]", inputs: ["arrowIcon", "toggleable", "togglable", "selected", "tabIndex", "imageUrl", "iconClass", "icon", "disabled", "size", "rounded", "fillMode", "themeColor", "svgIcon", "primary", "look"], outputs: ["selectedChange", "click"], exportAs: ["kendoButton"] }, { kind: "component", type: DropDownButtonComponent, selector: "kendo-dropdownbutton", inputs: ["arrowIcon", "icon", "svgIcon", "iconClass", "imageUrl", "textField", "data", "size", "rounded", "fillMode", "themeColor", "buttonAttributes"], outputs: ["itemClick", "focus", "blur"], exportAs: ["kendoDropDownButton"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ChatFileComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'li[chatFile]',
                    providers: [{
                            provide: ChatItem,
                            useExisting: forwardRef(() => ChatFileComponent)
                        }],
                    template: `
        <kendo-icon-wrapper
          size="xlarge"
          [name]="fileGroupClass(chatFile.extension)"
          [svgIcon]="fileThumbnail(chatFile.extension)"
          >
        </kendo-icon-wrapper>
        <div class="k-chat-file-info">
          <span class="k-chat-file-name">{{chatFile.name}}</span>
          <span class="k-chat-file-size">{{getTotalFilesSizeMessage(chatFile)}}</span>
        </div>
        @if (removable) {
          <button
            kendoButton
            [attr.title]="textFor('removeFileTitle')"
            [svgIcon]="deleteIcon"
            (click)="remove.emit(chatFile)"
            fillMode="flat"
          ></button>
        }
        @if (fileActions && fileActions.length > 0) {
          <kendo-dropdownbutton
            [data]="fileActions"
            [attr.title]="textFor('fileActionsTitle')"
            fillMode="flat"
            icon="more-vertical"
            [svgIcon]="moreIcon"
            (itemClick)="actionClick.emit($event)"
            (click)="$event.preventDefault()"
            (open)="actionsToggle.emit(true)"
            (close)="actionsToggle.emit(false)"
          ></kendo-dropdownbutton>
        }
        `,
                    standalone: true,
                    imports: [IconWrapperComponent, ButtonComponent, DropDownButtonComponent]
                }]
        }], ctorParameters: () => [{ type: i1.LocalizationService }], propDecorators: { chatFile: [{
                type: Input
            }], removable: [{
                type: Input
            }], fileActions: [{
                type: Input
            }], remove: [{
                type: Output
            }], actionClick: [{
                type: Output
            }], actionsToggle: [{
                type: Output
            }], actionButtonClick: [{
                type: Output
            }] } });

/**
 * @hidden
 */
const isAuthor = (authorId, msg) => msg.author && authorId === msg.author.id;
const last = (arr) => arr[arr.length - 1];
const dateChanged = (curr, prev) => (curr && prev) && (prev.getDate() !== curr.getDate() ||
    prev.getMonth() !== curr.getMonth() ||
    prev.getFullYear() !== curr.getFullYear());
const addDateMarker = (acc, msg) => {
    const timestamp = msg.timestamp;
    const lastItem = last(acc);
    if (!timestamp) {
        return;
    }
    if (!lastItem || dateChanged(timestamp, lastItem.timestamp)) {
        const dateMarker = {
            type: 'date-marker',
            timestamp: timestamp,
            trackBy: timestamp.getTime()
        };
        acc.push(dateMarker);
    }
};
const groupMessages = (acc, msg, isLastMessage) => {
    const lastItem = last(acc);
    let messages;
    if (isDevMode() && !msg.author) {
        throw new Error('Author must be set for message: ' + JSON.stringify(msg));
    }
    if (msg.typing && !isLastMessage) {
        return;
    }
    if (lastItem && lastItem.type === 'message-group') {
        messages = lastItem.messages;
    }
    if (messages && isAuthor(msg.author.id, last(messages))) {
        messages.push(msg);
    }
    else {
        acc.push({
            type: 'message-group',
            messages: [msg],
            author: msg.author,
            timestamp: msg.timestamp,
            trackBy: msg
        });
    }
};
const groupItems = (total) => (acc, msg, index) => {
    const isLastMessage = index === total - 1;
    addDateMarker(acc, msg);
    groupMessages(acc, msg, isLastMessage);
    if (msg.attachments && msg.attachments.length > 1) {
        acc.push({
            type: 'attachment-group',
            attachments: msg.attachments,
            attachmentLayout: msg.attachmentLayout,
            timestamp: msg.timestamp,
            trackBy: 'attachment-group' + msg.id
        });
    }
    if (msg.suggestedActions && isLastMessage) {
        acc.push({
            type: 'action-group',
            actions: msg.suggestedActions,
            timestamp: msg.timestamp,
            trackBy: 'action-group' + msg.id
        });
    }
    return acc;
};
/**
 * @hidden
 */
const chatView = (messages) => messages.reduce(groupItems(messages.length), []);

/* eslint-disable @typescript-eslint/no-empty-function */
/**
 * @hidden
 */
class MessageReferenceComponent extends ChatItem {
    localization;
    chatService;
    hostClass = true;
    message;
    constructor(localization, chatService) {
        super();
        this.localization = localization;
        this.chatService = chatService;
    }
    isOwnMessage(msg) {
        return isAuthor(this.chatService.authorId, msg);
    }
    textFor(key) {
        return this.localization.get(key);
    }
    focus() { }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: MessageReferenceComponent, deps: [{ token: i1.LocalizationService }, { token: ChatService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: MessageReferenceComponent, isStandalone: true, selector: "chat-message-reference-content", inputs: { message: "message" }, host: { properties: { "class.k-message-reference-content": "this.hostClass" } }, providers: [{
                provide: ChatItem,
                useExisting: forwardRef(() => MessageReferenceComponent)
            }], usesInheritance: true, ngImport: i0, template: `
        @if (message.text && !message.isDeleted) {
          {{message.text}}
        }
        @if (!message.text && !message.isDeleted && message.files && message.files.length > 0) {
          <li class="k-chat-file" [chatFile]="message.files[0]">
          </li>
        }
        @if (message.isDeleted && isOwnMessage(message)) {
          {{ textFor('deletedMessageSenderText') }}
        }
        @if (message.isDeleted && !isOwnMessage(message)) {
          {{ textFor('deletedMessageReceiverText') }}
        }
        `, isInline: true, dependencies: [{ kind: "component", type: ChatFileComponent, selector: "li[chatFile]", inputs: ["chatFile", "removable", "fileActions"], outputs: ["remove", "actionClick", "actionsToggle", "actionButtonClick"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: MessageReferenceComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'chat-message-reference-content',
                    providers: [{
                            provide: ChatItem,
                            useExisting: forwardRef(() => MessageReferenceComponent)
                        }],
                    template: `
        @if (message.text && !message.isDeleted) {
          {{message.text}}
        }
        @if (!message.text && !message.isDeleted && message.files && message.files.length > 0) {
          <li class="k-chat-file" [chatFile]="message.files[0]">
          </li>
        }
        @if (message.isDeleted && isOwnMessage(message)) {
          {{ textFor('deletedMessageSenderText') }}
        }
        @if (message.isDeleted && !isOwnMessage(message)) {
          {{ textFor('deletedMessageReceiverText') }}
        }
        `,
                    standalone: true,
                    imports: [ChatFileComponent]
                }]
        }], ctorParameters: () => [{ type: i1.LocalizationService }, { type: ChatService }], propDecorators: { hostClass: [{
                type: HostBinding,
                args: ['class.k-message-reference-content']
            }], message: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class MessageBoxComponent {
    chatService;
    cdr;
    element;
    renderer;
    borderColor = 'inherit';
    messageBoxWrapperClass = true;
    messageBoxInput;
    fileSelectComponent;
    suggestedActionsComponent;
    authorId;
    autoScroll;
    suggestions;
    placeholder;
    inputValue = '';
    localization;
    messageBoxTemplate;
    suggestionTemplate;
    sendMessage = new EventEmitter();
    executeSuggestion = new EventEmitter();
    fileSelect = new EventEmitter();
    fileRemove = new EventEmitter();
    files = [];
    sendIcon = paperPlaneIcon;
    attachmentIcon = paperclipIcon;
    deleteIcon = xIcon;
    fileIcon = fileIcon;
    isListening = false;
    get reply() {
        return this.chatService.reply;
    }
    selectedItem;
    subs = new Subscription();
    constructor(chatService, cdr, element, renderer) {
        this.chatService = chatService;
        this.cdr = cdr;
        this.element = element;
        this.renderer = renderer;
    }
    ngOnInit() {
        const elRef = this.element.nativeElement;
        this.subs.add(this.renderer.listen(elRef, 'focusout', event => this.onBlur(event)));
        this.subs.add(this.chatService.contextMenuAction$.subscribe((action) => {
            if (action.action.id === 'reply') {
                this.messageBoxInput.focus();
            }
        }));
    }
    ngOnDestroy() {
        if (this.subs) {
            this.subs.unsubscribe();
        }
    }
    sendClick() {
        const hasMessage = this.inputValue?.trim() || this.files?.length;
        const isCustomDisabled = isPresent(this.sendButtonSettings?.disabled);
        if (!hasMessage && !isCustomDisabled) {
            return;
        }
        const message = {
            id: guid(),
            text: this.inputValue,
            timestamp: new Date(),
            author: { id: this.authorId },
            ...(this.files && this.files.length > 0 && { files: this.files }),
            ...(this.reply && { replyToId: this.reply.id })
        };
        this.sendMessage.emit(new SendMessageEvent(message));
        this.inputValue = '';
        this.files = [];
        this.chatService.reply = null;
        this.messageBoxInput.focus();
        this.autoScroll = true;
    }
    inputKeydown(e) {
        if (e.code === Keys.Enter || e.code === Keys.NumpadEnter) {
            this.sendClick();
        }
    }
    textAreaKeydown(e) {
        const isEnter = e.code === Keys.Enter || e.code === Keys.NumpadEnter;
        if (!isEnter) {
            return;
        }
        const newLine = (e.metaKey || e.ctrlKey);
        const enterOnly = !(e.shiftKey || e.metaKey || e.ctrlKey);
        if (enterOnly) {
            e.preventDefault();
            this.sendClick();
        }
        if (newLine) {
            this.inputValue += `\r\n`;
        }
    }
    handleSpeechResult(event) {
        if (event.alternatives && event.alternatives.length > 0) {
            if (!isPresent(this.inputValue)) {
                this.inputValue = '';
            }
            const appendedValue = event.alternatives[0].transcript + ' ';
            if (!appendedValue.trim()) {
                return;
            }
            this.inputValue += appendedValue;
            this.chatService.emit('inputValueChange', this.inputValue);
        }
    }
    textFor(key) {
        return this.localization.get(key);
    }
    removeReply() {
        this.chatService.reply = null;
    }
    onReplyReferenceClick(event) {
        event.stopPropagation();
        this.chatService.emit('replyReferenceClick', this.chatService.reply?.id);
    }
    handleFileSelect(event) {
        const processedFiles = event.files.map(currentFile => {
            return {
                id: currentFile.uid,
                name: currentFile.name,
                extension: currentFile.extension,
                size: currentFile.size,
                type: currentFile.rawFile.type,
                rawFile: currentFile.rawFile
            };
        });
        this.files = [...this.files, ...processedFiles];
        this.fileSelect.emit(event);
    }
    selectFiles() {
        if (this.fileSelectComponent?.fileSelectInput) {
            this.fileSelectComponent.fileSelectInput.nativeElement.click();
        }
    }
    removeFile(index) {
        this.files = this.files.filter((_, i) => i !== index);
        const removedFile = this.files[index];
        this.fileRemove.emit(removedFile);
    }
    get speechToTextButtonSettings() {
        return this.chatService.enableSpeechToText;
    }
    get sendButtonSettings() {
        return this.chatService.sendButtonSettings;
    }
    get enableFileSelect() {
        return this.chatService.enableFileSelect;
    }
    get isDisabledSendButton() {
        if (isPresent(this.sendButtonSettings?.disabled)) {
            return this.sendButtonSettings.disabled;
        }
        const isEmptyInput = !this.inputValue?.length || !this.inputValue?.trim();
        const hasFiles = this.files?.length > 0;
        return (isEmptyInput && !hasFiles) || this.isListening;
    }
    select(item, event) {
        if (event) {
            const target = event.target;
            if (!target.classList.contains('k-suggestion')) {
                return;
            }
        }
        if (!this.chatService.toggleMessageState) {
            const prevItem = this.selectedItem;
            if (prevItem) {
                prevItem.selected = false;
            }
            if (item) {
                item.selected = true;
                this.selectedItem = item;
            }
            this.cdr.detectChanges();
        }
        this.chatService.toggleMessageState = false;
    }
    onBlur(args) {
        const next = args.relatedTarget || document.activeElement;
        const outside = !closest$1(next, (node) => node === this.element.nativeElement);
        if (outside) {
            this.select(null);
        }
    }
    onInputValueChange(value) {
        this.inputValue = value;
        this.chatService.emit('inputValueChange', value);
    }
    dispatchSuggestion(suggestion) {
        this.executeSuggestion.emit(suggestion);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: MessageBoxComponent, deps: [{ token: ChatService }, { token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: MessageBoxComponent, isStandalone: true, selector: "kendo-message-box", inputs: { authorId: "authorId", autoScroll: "autoScroll", suggestions: "suggestions", placeholder: "placeholder", inputValue: "inputValue", localization: "localization", messageBoxTemplate: "messageBoxTemplate", suggestionTemplate: "suggestionTemplate" }, outputs: { sendMessage: "sendMessage", executeSuggestion: "executeSuggestion", fileSelect: "fileSelect", fileRemove: "fileRemove" }, host: { properties: { "style.border-color": "this.borderColor", "class.k-message-box-wrapper": "this.messageBoxWrapperClass" } }, viewQueries: [{ propertyName: "messageBoxInput", first: true, predicate: ["messageBoxInput"], descendants: true }, { propertyName: "fileSelectComponent", first: true, predicate: ["fileSelect"], descendants: true }, { propertyName: "suggestedActionsComponent", first: true, predicate: SuggestedActionsComponent, descendants: true }], ngImport: i0, template: `
    @if (suggestions?.length > 0) {
      <kendo-chat-suggested-actions
        #suggestedActions
        [suggestions]="suggestions"
        type="suggestion"
        [suggestionTemplate]="suggestionTemplate"
        [tabbable]="true"
        (dispatchSuggestion)="dispatchSuggestion($event)"
        (click)="select(suggestedActions, $event)"
        (focus)="select(suggestedActions, $event)"
      ></kendo-chat-suggested-actions>
    }
    
    @if (!messageBoxTemplate?.templateRef) {
      <kendo-textarea
        #messageBoxInput
        class="k-message-box"
        resizable="none"
        [rows]="3"
            [inputAttributes]="{
                'aria-label': textFor('messageBoxInputLabel')
            }"
        [placeholder]="placeholder || textFor('messagePlaceholder')"
        [showSuffixSeparator]="false"
        (keydown)="textAreaKeydown($event)"
        [value]="inputValue"
        (valueChange)="onInputValueChange($event)"
        >
        @if (reply || (files && files.length > 0)) {
          <kendo-textarea-prefix>
            @if (reply) {
              <div class="k-message-reference k-message-reference-sender" (click)="onReplyReferenceClick($event)">
                <chat-message-reference-content [message]="reply"></chat-message-reference-content>
                <span class="k-spacer"></span>
                <button
                  kendoButton
                  [attr.title]="textFor('removeReplyTitle')"
                  [svgIcon]="deleteIcon"
                  (click)="removeReply()"
                  fillMode="flat"
                ></button>
              </div>
            }
            <ul class="k-chat-file-wrapper">
              @for (file of files; track file; let i = $index) {
                <li class="k-chat-file"
                  [chatFile]="file"
                  [removable]="true"
                  (remove)="removeFile(i)"
                ></li>
              }
            </ul>
          </kendo-textarea-prefix>
        }
        <kendo-textarea-suffix>
          @if (speechToTextButtonSettings) {
            <button
              kendoSpeechToTextButton
              [attr.title]="textFor('speechToTextButtonTitle')"
              [continuous]="speechToTextButtonSettings?.continuous"
              [disabled]="speechToTextButtonSettings?.disabled"
              [fillMode]="speechToTextButtonSettings?.fillMode ?? 'clear'"
              [integrationMode]="speechToTextButtonSettings?.integrationMode ?? 'webSpeech'"
              [interimResults]="speechToTextButtonSettings?.interimResults"
              [lang]="speechToTextButtonSettings?.lang"
              [maxAlternatives]="speechToTextButtonSettings?.maxAlternatives"
              [rounded]="speechToTextButtonSettings?.rounded"
              [size]="speechToTextButtonSettings?.size"
              [themeColor]="speechToTextButtonSettings?.themeColor"
              (result)="handleSpeechResult($event)"
              (start)="isListening = true"
              (end)="isListening = false"
            ></button>
          }
          @if (enableFileSelect) {
            <button
              kendoButton
              [attr.title]="textFor('fileSelectButtonTitle')"
              [svgIcon]="attachmentIcon"
              icon="attachment"
              fillMode="clear"
              (click)="selectFiles()"
            ></button>
          }
          <kendo-input-spacer></kendo-input-spacer>
          <button
            kendoButton
            [fillMode]="sendButtonSettings?.fillMode"
            [themeColor]="sendButtonSettings?.themeColor"
            [rounded]="sendButtonSettings?.rounded"
            [class]="sendButtonSettings?.buttonClass || 'k-chat-send'"
            [icon]="sendButtonSettings?.icon"
            [svgIcon]="sendButtonSettings?.svgIcon"
            [tabindex]="0"
            [attr.title]="textFor('send')"
            [class.k-disabled]="isDisabledSendButton"
            [attr.aria-disabled]="isDisabledSendButton"
            (click)="sendClick()"
            >
          </button>
        </kendo-textarea-suffix>
      </kendo-textarea>
    }
    
    @if (messageBoxTemplate?.templateRef) {
      <ng-template [ngTemplateOutlet]="messageBoxTemplate?.templateRef"></ng-template>
    }
    
    <kendo-fileselect
      #fileSelect
      class="k-hidden"
      [multiple]="true"
      [showFileList]="false"
      (select)="handleFileSelect($event)"
    ></kendo-fileselect>
    `, isInline: true, dependencies: [{ kind: "component", type: ButtonComponent, selector: "button[kendoButton]", inputs: ["arrowIcon", "toggleable", "togglable", "selected", "tabIndex", "imageUrl", "iconClass", "icon", "disabled", "size", "rounded", "fillMode", "themeColor", "svgIcon", "primary", "look"], outputs: ["selectedChange", "click"], exportAs: ["kendoButton"] }, { kind: "ngmodule", type: FormsModule }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: TextAreaComponent, selector: "kendo-textarea", inputs: ["focusableId", "flow", "inputAttributes", "adornmentsOrientation", "rows", "cols", "maxlength", "maxResizableRows", "tabindex", "tabIndex", "resizable", "size", "rounded", "fillMode", "showPrefixSeparator", "showSuffixSeparator"], outputs: ["focus", "blur", "valueChange"], exportAs: ["kendoTextArea"] }, { kind: "component", type: MessageReferenceComponent, selector: "chat-message-reference-content", inputs: ["message"] }, { kind: "component", type: TextAreaSuffixComponent, selector: "kendo-textarea-suffix", inputs: ["flow", "orientation"], exportAs: ["kendoTextAreaSuffix"] }, { kind: "component", type: TextAreaPrefixComponent, selector: "kendo-textarea-prefix", inputs: ["flow", "orientation"], exportAs: ["kendoTextAreaPrefix"] }, { kind: "component", type: SpeechToTextButtonComponent, selector: "button[kendoSpeechToTextButton]", inputs: ["disabled", "size", "rounded", "fillMode", "themeColor", "integrationMode", "lang", "continuous", "interimResults", "maxAlternatives"], outputs: ["start", "end", "result", "error", "click"], exportAs: ["kendoSpeechToTextButton"] }, { kind: "component", type: InputSpacerComponent, selector: "kendo-input-spacer, kendo-textbox-spacer", inputs: ["width"] }, { kind: "component", type: FileSelectComponent, selector: "kendo-fileselect", inputs: ["name"], outputs: ["valueChange"], exportAs: ["kendoFileSelect"] }, { kind: "component", type: SuggestedActionsComponent, selector: "kendo-chat-suggested-actions", inputs: ["actions", "suggestions", "tabbable", "type", "suggestionTemplate"], outputs: ["dispatchAction", "dispatchSuggestion"] }, { kind: "component", type: ChatFileComponent, selector: "li[chatFile]", inputs: ["chatFile", "removable", "fileActions"], outputs: ["remove", "actionClick", "actionsToggle", "actionButtonClick"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: MessageBoxComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-message-box',
                    template: `
    @if (suggestions?.length > 0) {
      <kendo-chat-suggested-actions
        #suggestedActions
        [suggestions]="suggestions"
        type="suggestion"
        [suggestionTemplate]="suggestionTemplate"
        [tabbable]="true"
        (dispatchSuggestion)="dispatchSuggestion($event)"
        (click)="select(suggestedActions, $event)"
        (focus)="select(suggestedActions, $event)"
      ></kendo-chat-suggested-actions>
    }
    
    @if (!messageBoxTemplate?.templateRef) {
      <kendo-textarea
        #messageBoxInput
        class="k-message-box"
        resizable="none"
        [rows]="3"
            [inputAttributes]="{
                'aria-label': textFor('messageBoxInputLabel')
            }"
        [placeholder]="placeholder || textFor('messagePlaceholder')"
        [showSuffixSeparator]="false"
        (keydown)="textAreaKeydown($event)"
        [value]="inputValue"
        (valueChange)="onInputValueChange($event)"
        >
        @if (reply || (files && files.length > 0)) {
          <kendo-textarea-prefix>
            @if (reply) {
              <div class="k-message-reference k-message-reference-sender" (click)="onReplyReferenceClick($event)">
                <chat-message-reference-content [message]="reply"></chat-message-reference-content>
                <span class="k-spacer"></span>
                <button
                  kendoButton
                  [attr.title]="textFor('removeReplyTitle')"
                  [svgIcon]="deleteIcon"
                  (click)="removeReply()"
                  fillMode="flat"
                ></button>
              </div>
            }
            <ul class="k-chat-file-wrapper">
              @for (file of files; track file; let i = $index) {
                <li class="k-chat-file"
                  [chatFile]="file"
                  [removable]="true"
                  (remove)="removeFile(i)"
                ></li>
              }
            </ul>
          </kendo-textarea-prefix>
        }
        <kendo-textarea-suffix>
          @if (speechToTextButtonSettings) {
            <button
              kendoSpeechToTextButton
              [attr.title]="textFor('speechToTextButtonTitle')"
              [continuous]="speechToTextButtonSettings?.continuous"
              [disabled]="speechToTextButtonSettings?.disabled"
              [fillMode]="speechToTextButtonSettings?.fillMode ?? 'clear'"
              [integrationMode]="speechToTextButtonSettings?.integrationMode ?? 'webSpeech'"
              [interimResults]="speechToTextButtonSettings?.interimResults"
              [lang]="speechToTextButtonSettings?.lang"
              [maxAlternatives]="speechToTextButtonSettings?.maxAlternatives"
              [rounded]="speechToTextButtonSettings?.rounded"
              [size]="speechToTextButtonSettings?.size"
              [themeColor]="speechToTextButtonSettings?.themeColor"
              (result)="handleSpeechResult($event)"
              (start)="isListening = true"
              (end)="isListening = false"
            ></button>
          }
          @if (enableFileSelect) {
            <button
              kendoButton
              [attr.title]="textFor('fileSelectButtonTitle')"
              [svgIcon]="attachmentIcon"
              icon="attachment"
              fillMode="clear"
              (click)="selectFiles()"
            ></button>
          }
          <kendo-input-spacer></kendo-input-spacer>
          <button
            kendoButton
            [fillMode]="sendButtonSettings?.fillMode"
            [themeColor]="sendButtonSettings?.themeColor"
            [rounded]="sendButtonSettings?.rounded"
            [class]="sendButtonSettings?.buttonClass || 'k-chat-send'"
            [icon]="sendButtonSettings?.icon"
            [svgIcon]="sendButtonSettings?.svgIcon"
            [tabindex]="0"
            [attr.title]="textFor('send')"
            [class.k-disabled]="isDisabledSendButton"
            [attr.aria-disabled]="isDisabledSendButton"
            (click)="sendClick()"
            >
          </button>
        </kendo-textarea-suffix>
      </kendo-textarea>
    }
    
    @if (messageBoxTemplate?.templateRef) {
      <ng-template [ngTemplateOutlet]="messageBoxTemplate?.templateRef"></ng-template>
    }
    
    <kendo-fileselect
      #fileSelect
      class="k-hidden"
      [multiple]="true"
      [showFileList]="false"
      (select)="handleFileSelect($event)"
    ></kendo-fileselect>
    `,
                    standalone: true,
                    imports: [ButtonComponent, FormsModule, NgTemplateOutlet, TextAreaComponent, MessageReferenceComponent, TextAreaSuffixComponent, TextAreaPrefixComponent, SpeechToTextButtonComponent, InputSpacerComponent, FileSelectComponent, SuggestedActionsComponent, ChatFileComponent]
                }]
        }], ctorParameters: () => [{ type: ChatService }, { type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.Renderer2 }], propDecorators: { borderColor: [{
                type: HostBinding,
                args: ['style.border-color']
            }], messageBoxWrapperClass: [{
                type: HostBinding,
                args: ['class.k-message-box-wrapper']
            }], messageBoxInput: [{
                type: ViewChild,
                args: ['messageBoxInput']
            }], fileSelectComponent: [{
                type: ViewChild,
                args: ['fileSelect']
            }], suggestedActionsComponent: [{
                type: ViewChild,
                args: [SuggestedActionsComponent]
            }], authorId: [{
                type: Input
            }], autoScroll: [{
                type: Input
            }], suggestions: [{
                type: Input
            }], placeholder: [{
                type: Input
            }], inputValue: [{
                type: Input
            }], localization: [{
                type: Input
            }], messageBoxTemplate: [{
                type: Input
            }], suggestionTemplate: [{
                type: Input
            }], sendMessage: [{
                type: Output
            }], executeSuggestion: [{
                type: Output
            }], fileSelect: [{
                type: Output
            }], fileRemove: [{
                type: Output
            }] } });

/**
 * Defines a template for displaying custom content inside the Chat messages.
 *
 * To define a message template, nest an `<ng-template>` tag with the `kendoChatMessageContentTemplate` directive inside the `<kendo-chat>` component.
 * The template context is set to the `message` instance.
 * For more information, refer to the article on [message templates](slug:message_templates_chat).
 *
 * @example
 * ```html
 * <kendo-chat>
 *   <ng-template kendoChatMessageContentTemplate let-message>
 *     <div>Message: {{ message.text }}</div>
 *   </ng-template>
 * </kendo-chat>
 * ```
 */
class MessageContentTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: MessageContentTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: MessageContentTemplateDirective, isStandalone: true, selector: "[kendoChatMessageContentTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: MessageContentTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoChatMessageContentTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }] });

/**
 * Defines a template for displaying the chat timestamp.
 *
 * To define a timestamp template, nest an `<ng-template>` tag with the `kendoChatTimestampTemplate` directive inside the `<kendo-chat>` component.
 * The template context is set to the current timestamp.
 * For more information, refer to the article on [message templates](slug:message_templates_chat).
 *
 * You can use the following field:
 * - `timestamp`&mdash;The current timestamp.
 *
 * @example
 * ```html
 * <kendo-chat>
 *   <ng-template kendoChatTimestampTemplate let-timestamp>
 *     <div>Message time: {{ timestamp }}</div>
 *   </ng-template>
 * </kendo-chat>
 * ```
 */
class ChatTimestampTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ChatTimestampTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: ChatTimestampTemplateDirective, isStandalone: true, selector: "[kendoChatTimestampTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ChatTimestampTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoChatTimestampTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }] });

/**
 * Represents the template for the status of a message.
 *
 * @example
 * ```html
 * <kendo-chat>
 *     <ng-template kendoChatStatusTemplate let-status>
 *         Current status: {{ status }}
 *     </ng-template>
 * </kendo-chat>
 * ```
 */
class ChatStatusTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ChatStatusTemplateDirective, deps: [{ token: i0.TemplateRef }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: ChatStatusTemplateDirective, isStandalone: true, selector: "[kendoChatStatusTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ChatStatusTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoChatStatusTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef }] });

/**
 * Defines a template for displaying fully custom Chat message bubbles.
 *
 * To define a message template, nest an `<ng-template>` tag with the `kendoChatMessageTemplate` directive inside the `<kendo-chat>` component.
 * The template context is set to the `message` instance.
 * For more information, refer to the article on [message templates](slug:message_templates_chat).
 *
 * @example
 * ```html
 * <kendo-chat>
 *   <ng-template kendoChatMessageTemplate let-message>
 *     <div>Message: {{ message.text }}</div>
 *   </ng-template>
 * </kendo-chat>
 * ```
 */
class MessageTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: MessageTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: MessageTemplateDirective, isStandalone: true, selector: "[kendoChatMessageTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: MessageTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoChatMessageTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }] });

/**
 * Defines a template for displaying custom content inside the current user's messages in the Chat.
 *
 * To define a message template, nest an `<ng-template>` tag with the `kendoChatAuthorMessageContentTemplate` directive inside the `<kendo-chat>` component.
 * The template context is set to the `message` instance.
 * For more information, refer to the article on [message templates](slug:message_templates_chat).
 *
 * @example
 * ```html
 * <kendo-chat>
 *   <ng-template kendoChatAuthorMessageContentTemplate let-message>
 *     <div>Message: {{ message.text }}</div>
 *   </ng-template>
 * </kendo-chat>
 * ```
 */
class AuthorMessageContentTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AuthorMessageContentTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: AuthorMessageContentTemplateDirective, isStandalone: true, selector: "[kendoChatAuthorMessageContentTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AuthorMessageContentTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoChatAuthorMessageContentTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }] });

/**
 * Defines a template for displaying custom content inside the other users' messages in the Chat.
 *
 * To define a message template, nest an `<ng-template>` tag with the `kendoChatReceiverMessageContentTemplate` directive inside the `<kendo-chat>` component.
 * The template context is set to the `message` instance.
 * For more information, refer to the article on [message templates](slug:message_templates_chat).
 *
 * @example
 * ```html
 * <kendo-chat>
 *   <ng-template kendoChatReceiverMessageContentTemplate let-message>
 *     <div>Message: {{ message.text }}</div>
 *   </ng-template>
 * </kendo-chat>
 * ```
 */
class ReceiverMessageContentTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ReceiverMessageContentTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: ReceiverMessageContentTemplateDirective, isStandalone: true, selector: "[kendoChatReceiverMessageContentTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ReceiverMessageContentTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoChatReceiverMessageContentTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }] });

/**
 * Defines a template for displaying fully custom Chat message bubbles for the other users.
 *
 * To define a message template, nest an `<ng-template>` tag with the `kendoChatReceiverMessageTemplate` directive inside the `<kendo-chat>` component.
 * The template context is set to the `message` instance.
 * For more information, refer to the article on [message templates](slug:message_templates_chat).
 *
 * @example
 * ```html
 * <kendo-chat>
 *   <ng-template kendoChatReceiverMessageTemplate let-message>
 *     <div>Message: {{ message.text }}</div>
 *   </ng-template>
 * </kendo-chat>
 * ```
 */
class ReceiverMessageTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ReceiverMessageTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: ReceiverMessageTemplateDirective, isStandalone: true, selector: "[kendoChatReceiverMessageTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ReceiverMessageTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoChatReceiverMessageTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }] });

/**
 * Defines a template for displaying fully custom Chat message bubbles for the current user.
 *
 * To define a message template, nest an `<ng-template>` tag with the `kendoChatAuthorMessageTemplate` directive inside the `<kendo-chat>` component.
 * The template context is set to the `message` instance.
 * For more information, refer to the article on [message templates](slug:message_templates_chat).
 *
 * @example
 * ```html
 * <kendo-chat>
 *   <ng-template kendoChatAuthorMessageTemplate let-message>
 *     <div>Message: {{ message.text }}</div>
 *   </ng-template>
 * </kendo-chat>
 * ```
 */
class AuthorMessageTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AuthorMessageTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: AuthorMessageTemplateDirective, isStandalone: true, selector: "[kendoChatAuthorMessageTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AuthorMessageTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoChatAuthorMessageTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }] });

// eslint-disable no-forward-ref
/**
 * @hidden
 */
class MessageComponent extends ChatItem {
    element;
    intl;
    chatService;
    localization;
    cdr;
    set message(value) {
        this._message = value;
    }
    get message() {
        return this._message;
    }
    tabbable;
    authorMessageContentTemplate;
    receiverMessageContentTemplate;
    messageContentTemplate;
    authorMessageTemplate;
    receiverMessageTemplate;
    messageTemplate;
    statusTemplate;
    showMessageTime = true;
    authorId;
    cssClass = true;
    get removedClass() {
        return this.message.isDeleted;
    }
    onKeyDown(event) {
        if (this.message.isDeleted) {
            return;
        }
        if (!this.chatService.allowMessageCollapse) {
            return;
        }
        this.onExpandableKeydown(event);
    }
    selected;
    get tabIndex() {
        return this.tabbable ? '0' : '-1';
    }
    expandIcon = chevronDownIcon;
    collapseIcon = chevronUpIcon;
    downloadIcon = downloadIcon;
    isMessageExpanded = false;
    showExpandCollapseIcon = false;
    fileActions = [];
    toolbarActions = [];
    parts = [];
    get useCustomBubbleTemplate() {
        return !!(this.getActiveBubbleTemplate());
    }
    get useCustomContentTemplate() {
        return !!(this.getActiveContentTemplate());
    }
    get hasMessageContent() {
        return !!(this.message?.text || this.message?.files?.length > 0);
    }
    get hasFiles() {
        return this.message?.files?.length > 0;
    }
    get hasMultipleFiles() {
        return this.message?.files?.length > 1;
    }
    get isActiveMessage() {
        return this.chatService.active && this.message?.id === this.chatService.activeMessage?.id;
    }
    get isMessageExpandable() {
        const isOwn = this.isOwnMessage(this.message);
        const messageSettings = isOwn
            ? this.chatService.authorMessageSettings
            : this.chatService.receiverMessageSettings;
        if (isPresent(messageSettings?.allowMessageCollapse)) {
            return messageSettings.allowMessageCollapse;
        }
        return this.chatService.allowMessageCollapse || false;
    }
    get showToolbar() {
        if (this.message?.isDeleted) {
            return false;
        }
        const hasComponentActions = this.chatService.messageToolbarActions?.length > 0;
        const hasMessageActions = this.toolbarActions?.length > 0;
        return hasComponentActions || hasMessageActions;
    }
    subs = new Subscription();
    _message;
    constructor(element, intl, chatService, localization, cdr) {
        super();
        this.element = element;
        this.intl = intl;
        this.chatService = chatService;
        this.localization = localization;
        this.cdr = cdr;
    }
    ngOnInit() {
        this.fileActions = this.getFileActions();
        this.toolbarActions = this.getToolbarActions();
        const settingsChange$ = this.isOwnMessage(this.message)
            ? this.chatService.authorMessageSettingsChange$
            : this.chatService.receiverMessageSettingsChange$;
        this.subs.add(settingsChange$.subscribe(() => {
            this.fileActions = this.getFileActions();
            this.toolbarActions = this.getToolbarActions();
            setTimeout(() => {
                this.showExpandCollapseIcon = this.calculateExpandCollapseIconVisibility();
            });
        }));
        this.subs.add(this.chatService.allowMessageCollapseChange$.subscribe(() => {
            setTimeout(() => {
                this.showExpandCollapseIcon = this.calculateExpandCollapseIconVisibility();
            });
        }));
        if (this.message.id) {
            this.chatService.registerMessageElement(this.message.id, this.element);
        }
        this.parts = this.getFormattedTextParts(this.message.text);
    }
    ngAfterViewInit() {
        this.showExpandCollapseIcon = this.calculateExpandCollapseIconVisibility();
        this.cdr.detectChanges();
    }
    ngOnDestroy() {
        if (this.message.id) {
            this.chatService.unregisterMessageElement(this.message.id);
        }
        this.subs.unsubscribe();
    }
    calculateExpandCollapseIconVisibility() {
        if (this.isMessageExpanded) {
            return true;
        }
        const bubbleContent = this.element.nativeElement.querySelector('.k-bubble-content');
        if (!bubbleContent) {
            return false;
        }
        const hasVerticalOverflow = bubbleContent.scrollHeight > bubbleContent.clientHeight;
        const hasHorizontalOverflow = bubbleContent.scrollWidth > bubbleContent.clientWidth;
        if (this.useCustomContentTemplate) {
            return hasVerticalOverflow || hasHorizontalOverflow;
        }
        const messageText = this.element.nativeElement.querySelector('.k-chat-bubble-text');
        const hasTextOverflow = messageText?.scrollWidth > messageText?.clientWidth;
        return hasTextOverflow || hasVerticalOverflow || hasHorizontalOverflow;
    }
    getActiveBubbleTemplate() {
        const isOwn = this.isOwnMessage(this.message);
        if (isOwn && this.authorMessageTemplate) {
            return this.authorMessageTemplate;
        }
        if (!isOwn && this.receiverMessageTemplate) {
            return this.receiverMessageTemplate;
        }
        if (this.messageTemplate) {
            return this.messageTemplate;
        }
        return null;
    }
    getActiveContentTemplate() {
        const isOwn = this.isOwnMessage(this.message);
        if (isOwn && this.authorMessageContentTemplate) {
            return this.authorMessageContentTemplate;
        }
        if (!isOwn && this.receiverMessageContentTemplate) {
            return this.receiverMessageContentTemplate;
        }
        if (this.messageContentTemplate) {
            return this.messageContentTemplate;
        }
        return null;
    }
    getDeletedMessageText() {
        const isOwn = this.isOwnMessage(this.message);
        return isOwn ? this.textFor('deletedMessageSenderText') : this.textFor('deletedMessageReceiverText');
    }
    textFor(key) {
        return this.localization.get(key);
    }
    formatTimeStamp(date) {
        return this.intl.formatDate(date, { datetime: 'short' });
    }
    focus() {
        this.element.nativeElement.focus();
    }
    onDownloadAll() {
        this.chatService.emit('fileDownload', { files: this.message.files, message: this.message });
    }
    toggleMessageState(event) {
        event.stopImmediatePropagation();
        this.isMessageExpanded = !this.isMessageExpanded;
        this.chatService.toggleMessageState = false;
    }
    onExpandableKeydown(event) {
        const key = normalizeKeys(event);
        const isFileActionButton = event.target.closest(FILE_ACTION_BTN_SELECTOR) || event.target.closest(DOWNLOAD_ALL_SELECTOR);
        if (!isFileActionButton && (key === Keys.Enter || key === Keys.Space)) {
            event.preventDefault();
            this.chatService.toggleMessageState = true;
            this.toggleMessageState(event);
        }
    }
    onToolbarAction(event, action, message) {
        event.stopImmediatePropagation();
        this.chatService.emit('toolbarAction', { action, message });
    }
    onFileAction(action, file) {
        if (action.originalAction.id === 'download') {
            this.chatService.emit('fileDownload', { files: [file], message: this.message });
        }
        this.chatService.emit('fileAction', { action: action.originalAction, file });
    }
    getMessageById(id) {
        return this.chatService.getMessageById(id);
    }
    onReplyReferenceClick(event, replyToId) {
        event.stopPropagation();
        this.chatService.emit('replyReferenceClick', replyToId);
    }
    handleMenuClose(event) {
        if (event) {
            const originalEvent = event.originalEvent;
            if (originalEvent) {
                this.onActionButtonClick(originalEvent);
            }
        }
        this.chatService.active = false;
        this.chatService.emit('contextMenuVisibilityChange', false);
        if (this.chatService.selectOnMenuClose) {
            this.selected = true;
            this.focus();
        }
    }
    onActionButtonClick(event) {
        const clickOutsideMessage = event instanceof MouseEvent && !event.target?.closest('.k-chat-bubble');
        const menuItemClick = event instanceof MouseEvent && event.target?.closest(MENU_ITEM_SELECTOR);
        if (clickOutsideMessage && !menuItemClick) {
            this.chatService.selectOnMenuClose = false;
        }
    }
    handleMenuOpen() {
        this.chatService.selectOnMenuClose = this.selected;
        this.chatService.emit('contextMenuVisibilityChange', true);
    }
    onActionPopupChange(expanded) {
        if (expanded) {
            this.chatService.active = true;
            this.handleMenuOpen();
        }
        else {
            this.handleMenuClose();
        }
    }
    isOwnMessage(msg) {
        return isAuthor(this.authorId, msg);
    }
    getFormattedTextParts(text) {
        if (!text) {
            return [];
        }
        const parts = [];
        const urlMatches = Array.from(text.matchAll(URL_REGEX));
        let lastIndex = 0;
        for (const match of urlMatches) {
            const url = match[1];
            const matchStart = match.index;
            if (!isPresent(matchStart)) {
                continue;
            }
            if (matchStart > lastIndex) {
                parts.push({ type: 'text', content: text.substring(lastIndex, matchStart) });
            }
            parts.push({ type: 'link', content: url, href: url });
            lastIndex = matchStart + match[0].length;
        }
        if (lastIndex < text.length) {
            parts.push({ type: 'text', content: text.substring(lastIndex) });
        }
        return parts;
    }
    getMessageSettings() {
        return this.isOwnMessage(this.message)
            ? this.chatService.authorMessageSettings
            : this.chatService.receiverMessageSettings;
    }
    getToolbarActions() {
        const messageSettings = this.getMessageSettings();
        return messageSettings?.messageToolbarActions?.length
            ? messageSettings.messageToolbarActions
            : this.chatService.messageToolbarActions || [];
    }
    getFileActions() {
        const messageSettings = this.getMessageSettings();
        const actions = messageSettings?.fileActions?.length
            ? messageSettings.fileActions
            : this.chatService.fileActions || [];
        return transformActions(actions);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: MessageComponent, deps: [{ token: i0.ElementRef }, { token: i1$1.IntlService }, { token: ChatService }, { token: i1.LocalizationService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: MessageComponent, isStandalone: true, selector: "kendo-chat-message", inputs: { message: "message", tabbable: "tabbable", authorMessageContentTemplate: "authorMessageContentTemplate", receiverMessageContentTemplate: "receiverMessageContentTemplate", messageContentTemplate: "messageContentTemplate", authorMessageTemplate: "authorMessageTemplate", receiverMessageTemplate: "receiverMessageTemplate", messageTemplate: "messageTemplate", statusTemplate: "statusTemplate", showMessageTime: "showMessageTime", authorId: "authorId" }, host: { listeners: { "keydown": "onKeyDown($event)" }, properties: { "class.k-message": "this.cssClass", "class.k-message-removed": "this.removedClass", "attr.tabIndex": "this.tabIndex" } }, providers: [
            {
                provide: ChatItem,
                useExisting: forwardRef(() => MessageComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: `
        @if (useCustomBubbleTemplate) {
          <ng-container *ngTemplateOutlet="getActiveBubbleTemplate()?.templateRef; context: { $implicit: message };"></ng-container>
        }

        @if (!useCustomBubbleTemplate) {
          @if (chatService.timestampVisibility === 'focus' && message.timestamp) {
            <time
              [attr.aria-hidden]="!selected"
              class="k-message-time"
              >
              {{ formatTimeStamp(message.timestamp) }}
            </time>
          }
          @if (message.typing) {
            <div class="k-chat-bubble k-bubble">
              <div class="k-typing-indicator" [attr.tabindex]="'-1'">
                <span></span>
                <span></span>
                <span></span>
              </div>
            </div>
          }
          @if (!message.typing) {
            @if (useCustomContentTemplate) {
              <div
                class="k-chat-bubble k-bubble"
                [attr.tabindex]="0"
                    [ngClass]="{
                        'k-bubble-expandable': isMessageExpandable,
                        'k-expanded': isMessageExpanded,
                        'k-selected': selected,
                        'k-focus': selected,
                        'k-active': isActiveMessage
                    }"
                >
                <div class="k-bubble-content">
                  <ng-container *ngTemplateOutlet="getActiveContentTemplate()?.templateRef; context: { $implicit: message };"></ng-container>
                </div>
                @if (isMessageExpandable && showExpandCollapseIcon) {
                  <span
                    class="k-bubble-expandable-indicator"
                    [attr.tabindex]="'0'"
                    [attr.role]="'button'"
                    [attr.title]="isMessageExpanded ? textFor('collapseTitle') : textFor('expandTitle')"
                    (mousedown)="chatService.toggleMessageState = true"
                    (click)="toggleMessageState($event)"
                    >
                    <kendo-icon-wrapper
                      [name]="isMessageExpanded ? 'chevron-up' : 'chevron-down'"
                      [svgIcon]="isMessageExpanded ? collapseIcon : expandIcon"
                      >
                    </kendo-icon-wrapper>
                  </span>
                }
              </div>
            }
            @if (!useCustomContentTemplate && hasMessageContent) {
              <div
                class="k-chat-bubble k-bubble"
                [attr.tabindex]="0"
                    [ngClass]="{
                        'k-bubble-expandable': isMessageExpandable,
                        'k-expanded': isMessageExpanded,
                        'k-selected': selected,
                        'k-focus': selected,
                        'k-active': isActiveMessage
                    }"
                >
                <div class="k-bubble-content">
                  @if (message.text || message.isDeleted) {
                    @if (message.replyToId && !message.isDeleted) {
                      <div
                        class="k-message-reference k-message-reference-receiver"
                        (click)="onReplyReferenceClick($event, message.replyToId)"
                        >
                        <chat-message-reference-content [message]="getMessageById(message.replyToId)"></chat-message-reference-content>
                      </div>
                    }
                    @if (message.isDeleted) {
                      <span class="k-chat-bubble-text">
                        {{ getDeletedMessageText() }}
                      </span>
                    }
                    @if (!message.isDeleted && parts.length > 0) {
                      <span class="k-chat-bubble-text">
                        @for (part of parts; track part) {
                          @if (part.type === 'text') {{{part.content}}}
                          @if (part.type === 'link') {<a [href]="part.href" target="_blank">{{part.content}}</a>}
                        }
                      </span>
                    }
                  }
                  @if (hasFiles && !message.isDeleted) {
                    <ul
                      class="k-chat-file-wrapper"
                            [ngClass]="{
                                'k-chat-files-wrap': chatService.messageFilesLayout === 'wrap',
                                'k-chat-files-horizontal': chatService.messageFilesLayout === 'horizontal'
                            }"
                      >
                      @for (file of message.files; track file) {
                        <li
                          class="k-chat-file"
                          [chatFile]="file"
                          [fileActions]="fileActions"
                          (actionClick)="onFileAction($event, file)"
                          (actionsToggle)="onActionPopupChange($event)"
                          (actionButtonClick)="onActionButtonClick($event)"
                        ></li>
                      }
                    </ul>
                  }
                  @if (hasMultipleFiles && !message.isDeleted) {
                    <div class="k-chat-download-button-wrapper">
                      <button
                        kendoButton
                        class="k-chat-download-button"
                        fillMode="flat"
                        icon="download"
                        [svgIcon]="downloadIcon"
                        [attr.title]="textFor('downloadAllFilesText')"
                        (click)="onDownloadAll()"
                      >{{ textFor('downloadAllFilesText') }}</button>
                    </div>
                  }
                </div>
                @if (isMessageExpandable && showExpandCollapseIcon) {
                  <span
                    class="k-bubble-expandable-indicator"
                    [attr.tabindex]="'0'"
                    [attr.role]="'button'"
                    [attr.title]="isMessageExpanded ? textFor('collapseTitle') : textFor('expandTitle')"
                    (mousedown)="chatService.toggleMessageState = true"
                    (click)="toggleMessageState($event)"
                    >
                    <kendo-icon-wrapper
                      [name]="isMessageExpanded ? 'chevron-up' : 'chevron-down'"
                      [svgIcon]="isMessageExpanded ? collapseIcon : expandIcon"
                      >
                    </kendo-icon-wrapper>
                  </span>
                }
              </div>
            }
          }
          @if (message.status) {
            <span class="k-message-status">
              @if (statusTemplate?.templateRef) {
                <ng-template
                  [ngTemplateOutlet]="statusTemplate.templateRef"
                  [ngTemplateOutletContext]="{ $implicit: message.status, message }"
                  >
                </ng-template>
              }
              @if (!statusTemplate?.templateRef) {
                {{ message.status }}
              }
            </span>
          }
        }
        @if (showToolbar) {
          <kendo-toolbar class="k-chat-message-toolbar" fillMode="flat">
            @for (action of toolbarActions; track action) {
              <kendo-toolbar-button
                fillMode="flat"
                [icon]="action.icon"
                [svgIcon]="action.svgIcon"
                [disabled]="action.disabled"
                [title]="action.label"
                (click)="onToolbarAction($event, action, message)"
                >
              </kendo-toolbar-button>
            }
          </kendo-toolbar>
        }
        `, isInline: true, dependencies: [{ kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "component", type: i2.ButtonComponent, selector: "button[kendoButton]", inputs: ["arrowIcon", "toggleable", "togglable", "selected", "tabIndex", "imageUrl", "iconClass", "icon", "disabled", "size", "rounded", "fillMode", "themeColor", "svgIcon", "primary", "look"], outputs: ["selectedChange", "click"], exportAs: ["kendoButton"] }, { kind: "component", type: ChatFileComponent, selector: "li[chatFile]", inputs: ["chatFile", "removable", "fileActions"], outputs: ["remove", "actionClick", "actionsToggle", "actionButtonClick"] }, { kind: "component", type: ToolBarComponent, selector: "kendo-toolbar", inputs: ["overflow", "resizable", "popupSettings", "fillMode", "tabindex", "size", "tabIndex", "showIcon", "showText"], outputs: ["open", "close"], exportAs: ["kendoToolBar"] }, { kind: "component", type: ToolBarButtonComponent, selector: "kendo-toolbar-button", inputs: ["showText", "showIcon", "text", "style", "className", "title", "disabled", "toggleable", "look", "togglable", "selected", "fillMode", "rounded", "themeColor", "icon", "iconClass", "svgIcon", "imageUrl"], outputs: ["click", "pointerdown", "selectedChange"], exportAs: ["kendoToolBarButton"] }, { kind: "component", type: MessageReferenceComponent, selector: "chat-message-reference-content", inputs: ["message"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: MessageComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-chat-message',
                    providers: [
                        {
                            provide: ChatItem,
                            useExisting: forwardRef(() => MessageComponent)
                        }
                    ],
                    template: `
        @if (useCustomBubbleTemplate) {
          <ng-container *ngTemplateOutlet="getActiveBubbleTemplate()?.templateRef; context: { $implicit: message };"></ng-container>
        }

        @if (!useCustomBubbleTemplate) {
          @if (chatService.timestampVisibility === 'focus' && message.timestamp) {
            <time
              [attr.aria-hidden]="!selected"
              class="k-message-time"
              >
              {{ formatTimeStamp(message.timestamp) }}
            </time>
          }
          @if (message.typing) {
            <div class="k-chat-bubble k-bubble">
              <div class="k-typing-indicator" [attr.tabindex]="'-1'">
                <span></span>
                <span></span>
                <span></span>
              </div>
            </div>
          }
          @if (!message.typing) {
            @if (useCustomContentTemplate) {
              <div
                class="k-chat-bubble k-bubble"
                [attr.tabindex]="0"
                    [ngClass]="{
                        'k-bubble-expandable': isMessageExpandable,
                        'k-expanded': isMessageExpanded,
                        'k-selected': selected,
                        'k-focus': selected,
                        'k-active': isActiveMessage
                    }"
                >
                <div class="k-bubble-content">
                  <ng-container *ngTemplateOutlet="getActiveContentTemplate()?.templateRef; context: { $implicit: message };"></ng-container>
                </div>
                @if (isMessageExpandable && showExpandCollapseIcon) {
                  <span
                    class="k-bubble-expandable-indicator"
                    [attr.tabindex]="'0'"
                    [attr.role]="'button'"
                    [attr.title]="isMessageExpanded ? textFor('collapseTitle') : textFor('expandTitle')"
                    (mousedown)="chatService.toggleMessageState = true"
                    (click)="toggleMessageState($event)"
                    >
                    <kendo-icon-wrapper
                      [name]="isMessageExpanded ? 'chevron-up' : 'chevron-down'"
                      [svgIcon]="isMessageExpanded ? collapseIcon : expandIcon"
                      >
                    </kendo-icon-wrapper>
                  </span>
                }
              </div>
            }
            @if (!useCustomContentTemplate && hasMessageContent) {
              <div
                class="k-chat-bubble k-bubble"
                [attr.tabindex]="0"
                    [ngClass]="{
                        'k-bubble-expandable': isMessageExpandable,
                        'k-expanded': isMessageExpanded,
                        'k-selected': selected,
                        'k-focus': selected,
                        'k-active': isActiveMessage
                    }"
                >
                <div class="k-bubble-content">
                  @if (message.text || message.isDeleted) {
                    @if (message.replyToId && !message.isDeleted) {
                      <div
                        class="k-message-reference k-message-reference-receiver"
                        (click)="onReplyReferenceClick($event, message.replyToId)"
                        >
                        <chat-message-reference-content [message]="getMessageById(message.replyToId)"></chat-message-reference-content>
                      </div>
                    }
                    @if (message.isDeleted) {
                      <span class="k-chat-bubble-text">
                        {{ getDeletedMessageText() }}
                      </span>
                    }
                    @if (!message.isDeleted && parts.length > 0) {
                      <span class="k-chat-bubble-text">
                        @for (part of parts; track part) {
                          @if (part.type === 'text') {{{part.content}}}
                          @if (part.type === 'link') {<a [href]="part.href" target="_blank">{{part.content}}</a>}
                        }
                      </span>
                    }
                  }
                  @if (hasFiles && !message.isDeleted) {
                    <ul
                      class="k-chat-file-wrapper"
                            [ngClass]="{
                                'k-chat-files-wrap': chatService.messageFilesLayout === 'wrap',
                                'k-chat-files-horizontal': chatService.messageFilesLayout === 'horizontal'
                            }"
                      >
                      @for (file of message.files; track file) {
                        <li
                          class="k-chat-file"
                          [chatFile]="file"
                          [fileActions]="fileActions"
                          (actionClick)="onFileAction($event, file)"
                          (actionsToggle)="onActionPopupChange($event)"
                          (actionButtonClick)="onActionButtonClick($event)"
                        ></li>
                      }
                    </ul>
                  }
                  @if (hasMultipleFiles && !message.isDeleted) {
                    <div class="k-chat-download-button-wrapper">
                      <button
                        kendoButton
                        class="k-chat-download-button"
                        fillMode="flat"
                        icon="download"
                        [svgIcon]="downloadIcon"
                        [attr.title]="textFor('downloadAllFilesText')"
                        (click)="onDownloadAll()"
                      >{{ textFor('downloadAllFilesText') }}</button>
                    </div>
                  }
                </div>
                @if (isMessageExpandable && showExpandCollapseIcon) {
                  <span
                    class="k-bubble-expandable-indicator"
                    [attr.tabindex]="'0'"
                    [attr.role]="'button'"
                    [attr.title]="isMessageExpanded ? textFor('collapseTitle') : textFor('expandTitle')"
                    (mousedown)="chatService.toggleMessageState = true"
                    (click)="toggleMessageState($event)"
                    >
                    <kendo-icon-wrapper
                      [name]="isMessageExpanded ? 'chevron-up' : 'chevron-down'"
                      [svgIcon]="isMessageExpanded ? collapseIcon : expandIcon"
                      >
                    </kendo-icon-wrapper>
                  </span>
                }
              </div>
            }
          }
          @if (message.status) {
            <span class="k-message-status">
              @if (statusTemplate?.templateRef) {
                <ng-template
                  [ngTemplateOutlet]="statusTemplate.templateRef"
                  [ngTemplateOutletContext]="{ $implicit: message.status, message }"
                  >
                </ng-template>
              }
              @if (!statusTemplate?.templateRef) {
                {{ message.status }}
              }
            </span>
          }
        }
        @if (showToolbar) {
          <kendo-toolbar class="k-chat-message-toolbar" fillMode="flat">
            @for (action of toolbarActions; track action) {
              <kendo-toolbar-button
                fillMode="flat"
                [icon]="action.icon"
                [svgIcon]="action.svgIcon"
                [disabled]="action.disabled"
                [title]="action.label"
                (click)="onToolbarAction($event, action, message)"
                >
              </kendo-toolbar-button>
            }
          </kendo-toolbar>
        }
        `,
                    standalone: true,
                    imports: [NgClass, NgTemplateOutlet, IconWrapperComponent, KENDO_BUTTONS, ChatFileComponent, ToolBarComponent, ToolBarButtonComponent, MessageReferenceComponent],
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i1$1.IntlService }, { type: ChatService }, { type: i1.LocalizationService }, { type: i0.ChangeDetectorRef }], propDecorators: { message: [{
                type: Input
            }], tabbable: [{
                type: Input
            }], authorMessageContentTemplate: [{
                type: Input
            }], receiverMessageContentTemplate: [{
                type: Input
            }], messageContentTemplate: [{
                type: Input
            }], authorMessageTemplate: [{
                type: Input
            }], receiverMessageTemplate: [{
                type: Input
            }], messageTemplate: [{
                type: Input
            }], statusTemplate: [{
                type: Input
            }], showMessageTime: [{
                type: Input
            }], authorId: [{
                type: Input
            }], cssClass: [{
                type: HostBinding,
                args: ['class.k-message']
            }], removedClass: [{
                type: HostBinding,
                args: ['class.k-message-removed']
            }], onKeyDown: [{
                type: HostListener,
                args: ['keydown', ['$event']]
            }], tabIndex: [{
                type: HostBinding,
                args: ['attr.tabIndex']
            }] } });

/**
 * @hidden
 */
class AttachmentComponent {
    set attachment(value) {
        this._attachment = value;
        this.context = {
            $implicit: this.attachment
        };
    }
    get attachment() {
        return this._attachment;
    }
    template;
    get image() {
        return this.contentType.startsWith('image/');
    }
    get unknown() {
        return !this.image;
    }
    context;
    get contentType() {
        return this.attachment.contentType || '';
    }
    _attachment;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AttachmentComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: AttachmentComponent, isStandalone: true, selector: "kendo-chat-attachment", inputs: { attachment: "attachment", template: "template" }, ngImport: i0, template: `
        @if (template) {
          <ng-container *ngTemplateOutlet="template.templateRef; context: context;">
          </ng-container>
        }
        
        @if (!template) {
          <div class="k-card">
            <div class="k-card-body">
              @if (attachment.title) {
                <h5 class="k-card-title">
                  {{ attachment.title }}
                </h5>
              }
              @if (attachment.subtitle) {
                <h6 class="k-card-subtitle">
                  {{ attachment.subtitle }}
                </h6>
              }
              @if (image) {
                <img [attr.src]="attachment.content" />
              }
              @if (unknown) {
                {{ attachment.content }}
              }
            </div>
          </div>
        }
        `, isInline: true, dependencies: [{ kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AttachmentComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-chat-attachment',
                    template: `
        @if (template) {
          <ng-container *ngTemplateOutlet="template.templateRef; context: context;">
          </ng-container>
        }
        
        @if (!template) {
          <div class="k-card">
            <div class="k-card-body">
              @if (attachment.title) {
                <h5 class="k-card-title">
                  {{ attachment.title }}
                </h5>
              }
              @if (attachment.subtitle) {
                <h6 class="k-card-subtitle">
                  {{ attachment.subtitle }}
                </h6>
              }
              @if (image) {
                <img [attr.src]="attachment.content" />
              }
              @if (unknown) {
                {{ attachment.content }}
              }
            </div>
          </div>
        }
        `,
                    standalone: true,
                    imports: [NgTemplateOutlet]
                }]
        }], propDecorators: { attachment: [{
                type: Input
            }], template: [{
                type: Input
            }] } });

/* eslint-disable @typescript-eslint/no-explicit-any */
// eslint-disable no-forward-ref
/**
 * @hidden
 */
class MessageAttachmentsComponent extends ChatItem {
    zone;
    localizationService;
    /**
     * @hidden
     */
    chevronLeftIcon = chevronLeftIcon;
    /**
     * @hidden
     */
    chevronRightIcon = chevronRightIcon;
    attachments;
    layout;
    tabbable;
    template;
    localization;
    get carousel() {
        return this.layout !== 'list';
    }
    deck;
    items;
    scrollPosition = 0;
    selectedIndex = 0;
    scrollSubscription;
    direction;
    get showLeftArrow() {
        return this.carousel && (this.direction === 'rtl' ? this.scrollPosition > -1 : this.scrollPosition > 0);
    }
    get showRightArrow() {
        return this.carousel && (this.direction === 'rtl' ? this.scrollPosition < 0 : this.scrollPosition < 1);
    }
    carouselKeyHandlers = {
        [Keys.ArrowLeft]: (e) => this.navigateTo(e, this.direction === 'rtl' ? 1 : -1),
        [Keys.ArrowRight]: (e) => this.navigateTo(e, this.direction === 'rtl' ? -1 : 1)
    };
    listKeyHandlers = {
        [Keys.ArrowUp]: (e) => this.navigateTo(e, -1),
        [Keys.ArrowDown]: (e) => this.navigateTo(e, 1)
    };
    constructor(zone, localizationService) {
        super();
        this.zone = zone;
        this.localizationService = localizationService;
        this.direction = this.localizationService.rtl ? 'rtl' : 'ltr';
    }
    ngAfterViewInit() {
        this.zone.runOutsideAngular(() => {
            const scrollDebounceTime = 100;
            this.scrollSubscription = fromEvent(this.deck.nativeElement, 'scroll')
                .pipe(debounceTime(scrollDebounceTime))
                .subscribe(() => this.onScroll());
        });
    }
    ngOnDestroy() {
        this.scrollSubscription.unsubscribe();
    }
    isSelected(index) {
        return this.selectedIndex === index;
    }
    itemKeydown(e, attachment) {
        const keyHandlers = this.layout === 'list' ?
            this.listKeyHandlers : this.carouselKeyHandlers;
        const code = normalizeKeys(e);
        const handler = keyHandlers[code];
        if (handler) {
            handler(e, attachment);
        }
    }
    itemClick(index) {
        this.select(index);
    }
    focus() {
        this.select(this.selectedIndex);
    }
    scrollTo(dir) {
        const el = this.deck.nativeElement;
        const scrollStep = el.scrollWidth / this.items.length;
        const max = el.scrollWidth - el.offsetWidth;
        const pos = el.scrollLeft + scrollStep * dir;
        el.scrollLeft = this.direction === 'rtl' ? Math.min(0, max, pos) : Math.max(0, Math.min(max, pos));
    }
    select(index) {
        this.selectedIndex = index;
        const item = this.items.toArray()[index];
        if (item) {
            item.nativeElement.focus();
        }
    }
    navigateTo(e, offset) {
        const prevIndex = this.selectedIndex;
        const nextIndex = Math.max(0, Math.min(prevIndex + offset, this.items.length - 1));
        if (nextIndex !== prevIndex) {
            this.select(nextIndex);
            e.preventDefault();
        }
    }
    onScroll() {
        const el = this.deck.nativeElement;
        if (el.scrollWidth === 0) {
            return;
        }
        const pos = el.scrollLeft / (el.scrollWidth - el.offsetWidth);
        if (pos !== this.scrollPosition) {
            this.zone.run(() => {
                this.scrollPosition = pos;
            });
        }
    }
    textFor(key) {
        return this.localization.get(key);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: MessageAttachmentsComponent, deps: [{ token: i0.NgZone }, { token: i1.LocalizationService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: MessageAttachmentsComponent, isStandalone: true, selector: "kendo-chat-message-attachments", inputs: { attachments: "attachments", layout: "layout", tabbable: "tabbable", template: "template", localization: "localization" }, host: { properties: { "class.k-card-deck-scrollwrap": "this.carousel" } }, providers: [{
                provide: ChatItem,
                useExisting: forwardRef(() => MessageAttachmentsComponent)
            }], viewQueries: [{ propertyName: "deck", first: true, predicate: ["deck"], descendants: true, read: ElementRef, static: true }, { propertyName: "items", predicate: ["item"], descendants: true, read: ElementRef }], usesInheritance: true, ngImport: i0, template: `
        @if (showLeftArrow) {
          <button
            (click)="scrollTo(-1)"
            kendoButton
            tabindex="-1"
            [attr.title]="textFor('messageAttachmentLeftArrow')"
            [svgIcon]="chevronLeftIcon"
            icon="chevron-left"
            >
          </button>
        }
        <div
          #deck
          [class.k-card-deck]="carousel"
          [class.k-card-list]="!carousel"
          >
          @for (att of attachments; track att; let index = $index; let first = $first; let last = $last) {
            <kendo-chat-attachment #item
              [attachment]="att"
              [template]="template"
              [class.k-selected]="isSelected(index)"
              [class.k-focus]="isSelected(index)"
              [class.k-card-wrap]="true"
              [class.k-first]="first"
              [class.k-last]="last"
              [attr.tabindex]="tabbable && isSelected(index) ? '0' : '-1'"
              (click)="itemClick(index)"
              (keydown)="itemKeydown($event, att)"
              >
            </kendo-chat-attachment>
          }
        </div>
        @if (showRightArrow) {
          <button
            (click)="scrollTo(1)"
            kendoButton
            tabindex="-1"
            [attr.title]="textFor('messageAttachmentRightArrow')"
            [svgIcon]="chevronRightIcon"
            icon="chevron-right"
            >
          </button>
        }
        `, isInline: true, dependencies: [{ kind: "component", type: ButtonComponent, selector: "button[kendoButton]", inputs: ["arrowIcon", "toggleable", "togglable", "selected", "tabIndex", "imageUrl", "iconClass", "icon", "disabled", "size", "rounded", "fillMode", "themeColor", "svgIcon", "primary", "look"], outputs: ["selectedChange", "click"], exportAs: ["kendoButton"] }, { kind: "component", type: AttachmentComponent, selector: "kendo-chat-attachment", inputs: ["attachment", "template"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: MessageAttachmentsComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [{
                            provide: ChatItem,
                            useExisting: forwardRef(() => MessageAttachmentsComponent)
                        }],
                    selector: 'kendo-chat-message-attachments',
                    template: `
        @if (showLeftArrow) {
          <button
            (click)="scrollTo(-1)"
            kendoButton
            tabindex="-1"
            [attr.title]="textFor('messageAttachmentLeftArrow')"
            [svgIcon]="chevronLeftIcon"
            icon="chevron-left"
            >
          </button>
        }
        <div
          #deck
          [class.k-card-deck]="carousel"
          [class.k-card-list]="!carousel"
          >
          @for (att of attachments; track att; let index = $index; let first = $first; let last = $last) {
            <kendo-chat-attachment #item
              [attachment]="att"
              [template]="template"
              [class.k-selected]="isSelected(index)"
              [class.k-focus]="isSelected(index)"
              [class.k-card-wrap]="true"
              [class.k-first]="first"
              [class.k-last]="last"
              [attr.tabindex]="tabbable && isSelected(index) ? '0' : '-1'"
              (click)="itemClick(index)"
              (keydown)="itemKeydown($event, att)"
              >
            </kendo-chat-attachment>
          }
        </div>
        @if (showRightArrow) {
          <button
            (click)="scrollTo(1)"
            kendoButton
            tabindex="-1"
            [attr.title]="textFor('messageAttachmentRightArrow')"
            [svgIcon]="chevronRightIcon"
            icon="chevron-right"
            >
          </button>
        }
        `,
                    standalone: true,
                    imports: [ButtonComponent, AttachmentComponent]
                }]
        }], ctorParameters: () => [{ type: i0.NgZone }, { type: i1.LocalizationService }], propDecorators: { attachments: [{
                type: Input
            }], layout: [{
                type: Input
            }], tabbable: [{
                type: Input
            }], template: [{
                type: Input
            }], localization: [{
                type: Input
            }], carousel: [{
                type: HostBinding,
                args: ['class.k-card-deck-scrollwrap']
            }], deck: [{
                type: ViewChild,
                args: ['deck', { read: ElementRef, static: true }]
            }], items: [{
                type: ViewChildren,
                args: ['item', { read: ElementRef }]
            }] } });

/**
 * Defines a template for displaying user status in the Chat.
 *
 * To define a user status template, nest an `<ng-template>` tag with the `kendoChatUserStatusTemplate` directive inside the `<kendo-chat>` component.
 * For more information, refer to the article on [message templates](slug:message_templates_chat).
 *
 * @example
 * ```html
 * <kendo-chat>
 *   <ng-template kendoChatUserStatusTemplate let-status>
 *     <div>{{ status }}</div>
 *   </ng-template>
 * </kendo-chat>
 * ```
 */
class ChatUserStatusTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ChatUserStatusTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: ChatUserStatusTemplateDirective, isStandalone: true, selector: "[kendoChatUserStatusTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ChatUserStatusTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoChatUserStatusTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }] });

/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * @hidden
 */
class MessageListComponent {
    element;
    intl;
    renderer;
    chatService;
    cdr;
    set messages(value) {
        const data = value || [];
        this.view = chatView(data);
        this._messages = data;
    }
    get messages() {
        return this._messages;
    }
    attachmentTemplate;
    authorMessageContentTemplate;
    receiverMessageContentTemplate;
    messageContentTemplate;
    authorMessageTemplate;
    receiverMessageTemplate;
    messageTemplate;
    timestampTemplate;
    statusTemplate;
    userStatusTemplate;
    localization;
    authorId;
    executeAction = new EventEmitter();
    navigate = new EventEmitter();
    resize = new EventEmitter();
    items;
    cssClass = true;
    view = [];
    _messages;
    subs = new Subscription();
    selectedItem;
    keyActions = {
        [Keys.Home]: (_) => this.onHomeOrEndKeyDown('home'),
        [Keys.End]: (_) => this.onHomeOrEndKeyDown('end'),
        [Keys.ArrowUp]: (e) => this.navigateTo(e, -1),
        [Keys.ArrowDown]: (e) => this.navigateTo(e, 1),
        [Keys.Tab]: (e) => this.onTabKeyDown(e),
        [Keys.F10]: (e) => e.shiftKey && this.openContextMenu(e),
    };
    constructor(element, intl, renderer, chatService, cdr) {
        this.element = element;
        this.intl = intl;
        this.renderer = renderer;
        this.chatService = chatService;
        this.cdr = cdr;
    }
    ngOnInit() {
        const elRef = this.element.nativeElement;
        this.subs.add(this.renderer.listen(elRef, 'keydown', event => this.onKeydown(event)));
        this.subs.add(this.renderer.listen(elRef, 'focusout', event => this.onBlur(event)));
        this.subs.add(this.renderer.listen(elRef, 'click', event => {
            const messageComponent = this.findMessageComponentFromEvent(event);
            if (messageComponent) {
                this.select(messageComponent, event);
            }
        }));
        this.subs.add(this.renderer.listen(elRef, 'contextmenu', event => {
            event.preventDefault();
            const messageComponent = this.findMessageComponentFromEvent(event);
            if (messageComponent) {
                this.onContextMenuClick(messageComponent.message, event, messageComponent);
            }
        }));
        this.subs.add(this.chatService.replyReferenceClick$.subscribe((messageId) => {
            this.scrollToAndSelectMessage(messageId);
        }));
        this.subs.add(this.chatService.contextMenuVisibilityChange$.subscribe((isVisible) => {
            this.handleMenuClose(isVisible);
        }));
    }
    ngAfterViewInit() {
        this.selectedItem = this.items.last;
    }
    ngOnDestroy() {
        this.subs.unsubscribe();
    }
    onResize() {
        this.resize.emit();
    }
    onClick(message, event) {
        this.select(message, event);
    }
    onContextMenuClick(message, event, messageElement) {
        this.chatService.calculateContextMenuActions(this.isOwnMessage(message));
        if (this.chatService.calculatedContextMenuActions.length > 0) {
            this.chatService.messagesContextMenu.show({
                left: event.pageX,
                top: event.pageY,
            });
            this.chatService.activeMessageElement = messageElement;
            this.chatService.activeMessage = message;
            this.chatService.active = true;
            this.chatService.selectOnMenuClose = this.chatService.activeMessageElement?.selected;
            this.chatService.emit('contextMenuVisibilityChange', true);
        }
    }
    formatTimeStamp(date) {
        return this.intl.formatDate(date, { date: 'full' });
    }
    calculateMessageWidthMode(message) {
        const isOwn = this.isOwnMessage(message);
        const messageSettings = isOwn ? this.chatService.authorMessageSettings : this.chatService.receiverMessageSettings;
        if (messageSettings?.messageWidthMode) {
            return messageSettings.messageWidthMode === 'full';
        }
        return this.chatService.messageWidthMode === 'full';
    }
    onKeydown(e) {
        // On some keyboards Numpad keys are used for Home/End/PageUp/PageDown.
        const code = normalizeKeys(e);
        const action = this.keyActions[code];
        if (action) {
            action(e);
        }
    }
    onBlur(args) {
        const next = args.relatedTarget || document.activeElement;
        const outside = !closest(next, (node) => node === this.element.nativeElement);
        const isActionClick = closest(next, (node) => node?.classList?.contains('k-context-menu-popup')) || closest(next, (node) => node?.classList?.contains('k-menu-popup'));
        if (outside && !isActionClick) {
            this.select(null);
        }
    }
    isOwnMessage(msg) {
        return isAuthor(this.authorId, msg);
    }
    showGroupAuthor(group) {
        const messageSettings = this.isOwnMessage(group.messages[0]) ?
            this.chatService.authorMessageSettings : this.chatService.receiverMessageSettings;
        if (isPresent(messageSettings?.showUsername)) {
            return messageSettings.showUsername && group.author.name;
        }
        return this.chatService.showUsername && group.author.name;
    }
    showGroupAvatar(group) {
        const messageSettings = this.isOwnMessage(group.messages[0]) ?
            this.chatService.authorMessageSettings : this.chatService.receiverMessageSettings;
        if (isPresent(messageSettings?.showAvatar)) {
            return messageSettings.showAvatar && group.author.avatarUrl;
        }
        return this.chatService.showAvatar && group.author.avatarUrl;
    }
    dispatchAction(action, message) {
        const args = new ExecuteActionEvent(action, message);
        this.executeAction.emit(args);
    }
    trackGroup(_index, item) {
        return item.trackBy;
    }
    select(item, event) {
        if (event) {
            const target = event.target;
            if (target.classList.contains('k-suggestion') || target.closest(DOWNLOAD_ALL_SELECTOR) || target.closest(FILE_ACTION_BTN_SELECTOR)) {
                return;
            }
        }
        if (!this.chatService.toggleMessageState) {
            const prevItem = this.selectedItem;
            if (prevItem) {
                prevItem.selected = false;
            }
            if (item) {
                item.selected = true;
                this.selectedItem = item;
            }
            this.cdr.detectChanges();
        }
        this.chatService.toggleMessageState = false;
    }
    last(items) {
        if (!items || items.length === 0) {
            return;
        }
        const messageGroups = items.filter((item) => item.type === 'message-group');
        const lastMessageGroup = messageGroups[messageGroups.length - 1].messages;
        return lastMessageGroup[lastMessageGroup.length - 1];
    }
    handleMenuClose(state) {
        if (!state) {
            this.select(null);
        }
    }
    textFor(key) {
        return this.localization.get(key);
    }
    onHomeOrEndKeyDown(key) {
        const items = this.items.toArray();
        if (key === 'home') {
            items[0].focus();
        }
        else {
            items[items.length - 1].focus();
        }
    }
    onTabKeyDown(event) {
        const item = this.items.toArray()[this.items.length - 1];
        const isLastItemQuickReply = item instanceof SuggestedActionsComponent;
        const isLastItemMessage = item instanceof MessageComponent;
        event.target.blur();
        if (isLastItemQuickReply || isLastItemMessage) {
            this.select(item);
            item.focus();
            this.navigate.emit();
        }
    }
    navigateTo(e, offset) {
        const items = this.items.toArray();
        const prevItem = this.selectedItem;
        const prevIndex = items.indexOf(prevItem);
        const nextIndex = Math.max(0, Math.min(prevIndex + offset, this.items.length - 1));
        const nextItem = items[nextIndex];
        const isNextItemQuickReply = nextItem instanceof SuggestedActionsComponent;
        if (nextItem !== prevItem) {
            if (isNextItemQuickReply) {
                nextItem.items.toArray()[0]?.nativeElement.focus();
            }
            this.select(nextItem);
            nextItem.focus();
            this.navigate.emit();
            e.preventDefault();
        }
    }
    scrollToAndSelectMessage(messageId) {
        this.chatService.scrollToMessage(messageId);
        const message = this.chatService.getMessageById(messageId);
        const chatItem = this.items.find(item => item instanceof MessageComponent &&
            item.message === message);
        if (chatItem) {
            this.select(chatItem);
        }
    }
    openContextMenu(event) {
        event.preventDefault();
        const messageComponent = this.findMessageComponentFromActiveElement();
        if (messageComponent) {
            const messageContentElement = messageComponent.element.nativeElement.querySelector('.k-chat-bubble');
            if (messageContentElement) {
                const rect = messageContentElement?.getBoundingClientRect();
                this.onContextMenuClick(messageComponent.message, {
                    pageX: rect.left + (rect.width / 2) + window.scrollX,
                    pageY: rect.top + (rect.height / 2) + window.scrollY
                }, messageComponent);
            }
            else {
                const messageElement = messageComponent.element.nativeElement;
                const rect = messageElement?.getBoundingClientRect();
                this.onContextMenuClick(messageComponent.message, {
                    pageX: rect.left + (rect.width / 2) + window.scrollX,
                    pageY: rect.top + (rect.height / 2) + window.scrollY
                }, messageComponent);
            }
        }
    }
    findMessageComponentFromActiveElement() {
        const activeElement = document.activeElement;
        const messageComponents = this.items.filter(item => item instanceof MessageComponent);
        return messageComponents.find(component => {
            const componentElement = component.element?.nativeElement;
            return componentElement && (componentElement === activeElement || componentElement.contains(activeElement));
        });
    }
    findMessageComponentFromEvent(event) {
        const target = event.target;
        const clickedElement = target?.closest('.k-message');
        if (!clickedElement)
            return undefined;
        const messageComponents = this.items.filter(item => item instanceof MessageComponent);
        return messageComponents.find(component => {
            const componentElement = component.element?.nativeElement;
            return componentElement && (componentElement === clickedElement || componentElement.contains(clickedElement));
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: MessageListComponent, deps: [{ token: i0.ElementRef }, { token: i1$1.IntlService }, { token: i0.Renderer2 }, { token: ChatService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: MessageListComponent, isStandalone: true, selector: "kendo-chat-message-list", inputs: { messages: "messages", attachmentTemplate: "attachmentTemplate", authorMessageContentTemplate: "authorMessageContentTemplate", receiverMessageContentTemplate: "receiverMessageContentTemplate", messageContentTemplate: "messageContentTemplate", authorMessageTemplate: "authorMessageTemplate", receiverMessageTemplate: "receiverMessageTemplate", messageTemplate: "messageTemplate", timestampTemplate: "timestampTemplate", statusTemplate: "statusTemplate", userStatusTemplate: "userStatusTemplate", localization: "localization", authorId: "authorId" }, outputs: { executeAction: "executeAction", navigate: "navigate", resize: "resize" }, host: { properties: { "class.k-message-list-content": "this.cssClass" } }, viewQueries: [{ propertyName: "items", predicate: ChatItem, descendants: true }], ngImport: i0, template: `
        @for (group of view; track trackGroup($index, group); let lastGroup = $last) {
          @switch (group.type) {
            @case ('date-marker') {
              <div
                class="k-timestamp"
                >
                @if (timestampTemplate?.templateRef) {
                  <ng-container
                    [ngTemplateOutlet]="timestampTemplate.templateRef"
                    [ngTemplateOutletContext]="{ $implicit: group.timestamp }"
                    >
                  </ng-container>
                }
                @if (!timestampTemplate?.templateRef) {
                  {{ formatTimeStamp(group.timestamp) }}
                }
              </div>
            }
            @case ('message-group') {
              <div
                class="k-message-group"
                [class.k-message-group-sender]="isOwnMessage(group.messages[0])"
                [class.k-message-group-receiver]="!isOwnMessage(group.messages[0])"
                [class.k-no-avatar]="!showGroupAvatar(group)"
                [class.k-message-group-full-width]="calculateMessageWidthMode(group.messages[0])"
                >
                @if (!userStatusTemplate?.templateRef && showGroupAvatar(group)) {
                  <div
                    class="k-avatar k-avatar-md k-avatar-solid k-avatar-solid-primary k-rounded-full"
                    >
                    <span class="k-avatar-image">
                      <img
                        [attr.src]="group.author.avatarUrl"
                        [alt]="group.author.avatarAltText"
                        />
                    </span>
                  </div>
                }
                @if (showGroupAvatar(group) && userStatusTemplate?.templateRef) {
                  <div class="k-chat-user-status-wrapper">
                    <div
                      class="k-avatar k-avatar-md k-avatar-solid k-avatar-solid-primary k-rounded-full"
                      >
                      <span class="k-avatar-image">
                        <img
                          [attr.src]="group.author.avatarUrl"
                          [alt]="group.author.avatarAltText"
                          />
                      </span>
                    </div>
                    @if (userStatusTemplate?.templateRef) {
                      <div class="k-chat-user-status">
                        <ng-template
                          [ngTemplateOutlet]="userStatusTemplate.templateRef"
                          [ngTemplateOutletContext]="{ $implicit: group.messages.at(-1) }"
                          >
                        </ng-template>
                      </div>
                    }
                  </div>
                }
                <div class="k-message-group-content">
                  @if (showGroupAuthor(group)) {
                    <p class="k-message-author">{{ group.author.name }}</p>
                  }
                  @for (msg of group.messages; track msg; let firstMessage = $first; let lastMessage = $last) {
                    @if (msg.user?.avatarUrl) {
                      <div
                        class="k-avatar k-avatar-md k-avatar-solid k-avatar-solid-primary k-rounded-full"
                        >
                        <span class="k-avatar-image">
                          <img [src]="msg.user?.avatarUrl">
                        </span>
                      </div>
                    }
                    <kendo-chat-message #message
                      [message]="msg"
                      [tabbable]="lastGroup && lastMessage"
                      [authorMessageContentTemplate]="authorMessageContentTemplate"
                      [receiverMessageContentTemplate]="receiverMessageContentTemplate"
                      [messageContentTemplate]="messageContentTemplate"
                      [authorMessageTemplate]="authorMessageTemplate"
                      [receiverMessageTemplate]="receiverMessageTemplate"
                      [messageTemplate]="messageTemplate"
                      [statusTemplate]="statusTemplate"
                      [authorId]="authorId"
                      >
                    </kendo-chat-message>
                    @if (msg.attachments && msg.attachments.length === 1) {
                      <kendo-chat-attachment
                        [attachment]="msg.attachments[0]"
                        [template]="attachmentTemplate"
                        >
                      </kendo-chat-attachment>
                    }
                  }
                </div>
              </div>
            }
            @case ('attachment-group') {
              <kendo-chat-message-attachments #attachments
                [attachments]="group.attachments"
                [layout]="group.attachmentLayout"
                [localization]="localization"
                [tabbable]="lastGroup"
                [template]="attachmentTemplate"
                (click)="select(attachments)"
                (focus)="select(attachments)"
                >
              </kendo-chat-message-attachments>
            }
            @case ('action-group') {
              <kendo-chat-suggested-actions #actions
                [actions]="group.actions"
                type="action"
                [tabbable]="lastGroup"
                (dispatchAction)="dispatchAction($event, last(view))"
                (click)="select(actions, $event)"
                (focus)="select(actions, $event)"
                >
              </kendo-chat-suggested-actions>
            }
          }
        }
        <kendo-resize-sensor (resize)="onResize()">
        </kendo-resize-sensor>
        `, isInline: true, dependencies: [{ kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: MessageComponent, selector: "kendo-chat-message", inputs: ["message", "tabbable", "authorMessageContentTemplate", "receiverMessageContentTemplate", "messageContentTemplate", "authorMessageTemplate", "receiverMessageTemplate", "messageTemplate", "statusTemplate", "showMessageTime", "authorId"] }, { kind: "component", type: AttachmentComponent, selector: "kendo-chat-attachment", inputs: ["attachment", "template"] }, { kind: "component", type: MessageAttachmentsComponent, selector: "kendo-chat-message-attachments", inputs: ["attachments", "layout", "tabbable", "template", "localization"] }, { kind: "component", type: SuggestedActionsComponent, selector: "kendo-chat-suggested-actions", inputs: ["actions", "suggestions", "tabbable", "type", "suggestionTemplate"], outputs: ["dispatchAction", "dispatchSuggestion"] }, { kind: "component", type: ResizeSensorComponent, selector: "kendo-resize-sensor", inputs: ["rateLimit"], outputs: ["resize"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: MessageListComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-chat-message-list',
                    template: `
        @for (group of view; track trackGroup($index, group); let lastGroup = $last) {
          @switch (group.type) {
            @case ('date-marker') {
              <div
                class="k-timestamp"
                >
                @if (timestampTemplate?.templateRef) {
                  <ng-container
                    [ngTemplateOutlet]="timestampTemplate.templateRef"
                    [ngTemplateOutletContext]="{ $implicit: group.timestamp }"
                    >
                  </ng-container>
                }
                @if (!timestampTemplate?.templateRef) {
                  {{ formatTimeStamp(group.timestamp) }}
                }
              </div>
            }
            @case ('message-group') {
              <div
                class="k-message-group"
                [class.k-message-group-sender]="isOwnMessage(group.messages[0])"
                [class.k-message-group-receiver]="!isOwnMessage(group.messages[0])"
                [class.k-no-avatar]="!showGroupAvatar(group)"
                [class.k-message-group-full-width]="calculateMessageWidthMode(group.messages[0])"
                >
                @if (!userStatusTemplate?.templateRef && showGroupAvatar(group)) {
                  <div
                    class="k-avatar k-avatar-md k-avatar-solid k-avatar-solid-primary k-rounded-full"
                    >
                    <span class="k-avatar-image">
                      <img
                        [attr.src]="group.author.avatarUrl"
                        [alt]="group.author.avatarAltText"
                        />
                    </span>
                  </div>
                }
                @if (showGroupAvatar(group) && userStatusTemplate?.templateRef) {
                  <div class="k-chat-user-status-wrapper">
                    <div
                      class="k-avatar k-avatar-md k-avatar-solid k-avatar-solid-primary k-rounded-full"
                      >
                      <span class="k-avatar-image">
                        <img
                          [attr.src]="group.author.avatarUrl"
                          [alt]="group.author.avatarAltText"
                          />
                      </span>
                    </div>
                    @if (userStatusTemplate?.templateRef) {
                      <div class="k-chat-user-status">
                        <ng-template
                          [ngTemplateOutlet]="userStatusTemplate.templateRef"
                          [ngTemplateOutletContext]="{ $implicit: group.messages.at(-1) }"
                          >
                        </ng-template>
                      </div>
                    }
                  </div>
                }
                <div class="k-message-group-content">
                  @if (showGroupAuthor(group)) {
                    <p class="k-message-author">{{ group.author.name }}</p>
                  }
                  @for (msg of group.messages; track msg; let firstMessage = $first; let lastMessage = $last) {
                    @if (msg.user?.avatarUrl) {
                      <div
                        class="k-avatar k-avatar-md k-avatar-solid k-avatar-solid-primary k-rounded-full"
                        >
                        <span class="k-avatar-image">
                          <img [src]="msg.user?.avatarUrl">
                        </span>
                      </div>
                    }
                    <kendo-chat-message #message
                      [message]="msg"
                      [tabbable]="lastGroup && lastMessage"
                      [authorMessageContentTemplate]="authorMessageContentTemplate"
                      [receiverMessageContentTemplate]="receiverMessageContentTemplate"
                      [messageContentTemplate]="messageContentTemplate"
                      [authorMessageTemplate]="authorMessageTemplate"
                      [receiverMessageTemplate]="receiverMessageTemplate"
                      [messageTemplate]="messageTemplate"
                      [statusTemplate]="statusTemplate"
                      [authorId]="authorId"
                      >
                    </kendo-chat-message>
                    @if (msg.attachments && msg.attachments.length === 1) {
                      <kendo-chat-attachment
                        [attachment]="msg.attachments[0]"
                        [template]="attachmentTemplate"
                        >
                      </kendo-chat-attachment>
                    }
                  }
                </div>
              </div>
            }
            @case ('attachment-group') {
              <kendo-chat-message-attachments #attachments
                [attachments]="group.attachments"
                [layout]="group.attachmentLayout"
                [localization]="localization"
                [tabbable]="lastGroup"
                [template]="attachmentTemplate"
                (click)="select(attachments)"
                (focus)="select(attachments)"
                >
              </kendo-chat-message-attachments>
            }
            @case ('action-group') {
              <kendo-chat-suggested-actions #actions
                [actions]="group.actions"
                type="action"
                [tabbable]="lastGroup"
                (dispatchAction)="dispatchAction($event, last(view))"
                (click)="select(actions, $event)"
                (focus)="select(actions, $event)"
                >
              </kendo-chat-suggested-actions>
            }
          }
        }
        <kendo-resize-sensor (resize)="onResize()">
        </kendo-resize-sensor>
        `,
                    standalone: true,
                    imports: [NgTemplateOutlet, MessageComponent, AttachmentComponent, MessageAttachmentsComponent, SuggestedActionsComponent, ResizeSensorComponent]
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i1$1.IntlService }, { type: i0.Renderer2 }, { type: ChatService }, { type: i0.ChangeDetectorRef }], propDecorators: { messages: [{
                type: Input
            }], attachmentTemplate: [{
                type: Input
            }], authorMessageContentTemplate: [{
                type: Input
            }], receiverMessageContentTemplate: [{
                type: Input
            }], messageContentTemplate: [{
                type: Input
            }], authorMessageTemplate: [{
                type: Input
            }], receiverMessageTemplate: [{
                type: Input
            }], messageTemplate: [{
                type: Input
            }], timestampTemplate: [{
                type: Input
            }], statusTemplate: [{
                type: Input
            }], userStatusTemplate: [{
                type: Input
            }], localization: [{
                type: Input
            }], authorId: [{
                type: Input
            }], executeAction: [{
                type: Output
            }], navigate: [{
                type: Output
            }], resize: [{
                type: Output
            }], items: [{
                type: ViewChildren,
                args: [ChatItem]
            }], cssClass: [{
                type: HostBinding,
                args: ['class.k-message-list-content']
            }] } });

// Consider scroll to be at the bottom when within this number of pixels from the container height.
const maxDelta = 2;
/**
 * @hidden
 */
class ScrollAnchorDirective {
    element;
    zone;
    renderer;
    autoScroll = true;
    autoScrollChange = new EventEmitter();
    overflowAnchor = 'none';
    scrolling = false;
    unsubscribe;
    constructor(element, zone, renderer) {
        this.element = element;
        this.zone = zone;
        this.renderer = renderer;
    }
    ngOnInit() {
        this.zone.runOutsideAngular(() => {
            this.unsubscribe = this.renderer.listen(this.element.nativeElement, 'scroll', () => this.onScroll());
        });
    }
    ngAfterViewInit() {
        this.scrollToBottom();
    }
    ngOnDestroy() {
        if (this.unsubscribe) {
            this.unsubscribe();
        }
    }
    onScroll() {
        if (this.scrolling) {
            return;
        }
        const el = this.element.nativeElement;
        const bottom = el.scrollTop + el.offsetHeight;
        const height = el.scrollHeight;
        const atBottom = height - bottom < maxDelta;
        if (this.autoScroll !== atBottom) {
            this.zone.run(() => {
                this.autoScroll = atBottom;
                this.autoScrollChange.emit(this.autoScroll);
            });
        }
    }
    scrollToBottom() {
        if (!this.autoScroll) {
            return;
        }
        const el = this.element.nativeElement;
        el.scrollTop = el.scrollHeight - el.clientHeight;
        this.scrolling = true;
        this.zone.runOutsideAngular(() => setTimeout(() => this.scrolling = false, 1000));
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ScrollAnchorDirective, deps: [{ token: i0.ElementRef }, { token: i0.NgZone }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: ScrollAnchorDirective, isStandalone: true, selector: "[kendoChatScrollAnchor]", inputs: { autoScroll: "autoScroll" }, outputs: { autoScrollChange: "autoScrollChange" }, host: { properties: { "style.overflow-anchor": "this.overflowAnchor" } }, exportAs: ["scrollAnchor"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ScrollAnchorDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoChatScrollAnchor]',
                    exportAs: 'scrollAnchor',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.NgZone }, { type: i0.Renderer2 }], propDecorators: { autoScroll: [{
                type: Input
            }], autoScrollChange: [{
                type: Output
            }], overflowAnchor: [{
                type: HostBinding,
                args: ['style.overflow-anchor']
            }] } });

/**
 * @hidden
 */
let Messages$1 = class Messages extends ComponentMessages {
    /**
     * Sets the text that displays when the sender deletes a message.
     */
    deletedMessageSenderText;
    /**
     * Sets the text that displays when the receiver deletes a message.
     */
    deletedMessageReceiverText;
    /**
     * Sets the text that displays in the download section of the message.
     * This message displays below all files in the message.
     */
    downloadAllFilesText;
    /**
     * Sets the placeholder text for the message text input.
     */
    messagePlaceholder;
    /**
     * Sets the text for the **Send** button.
     */
    send;
    /**
     * Sets the label for the message list.
     */
    messageListLabel;
    /**
     * Sets the label for the message input box.
     */
    messageBoxInputLabel;
    /**
     * Sets the text for the left arrow of the message attachments.
     */
    messageAttachmentLeftArrow;
    /**
     * Sets the text for the right arrow of the message attachments.
     */
    messageAttachmentRightArrow;
    /**
     * Sets the Speech to Text button title.
     */
    speechToTextButtonTitle;
    /**
     * Sets the File Select button title.
     */
    fileSelectButtonTitle;
    /**
     * Sets the title of the icon that removes the reply reference in the Message Box.
     */
    removeReplyTitle;
    /**
     * Sets the title of the icon that removes a selected file in the Message Box.
     */
    removeFileTitle;
    /**
     * Sets the title of the icon that shows the message can expand.
     */
    expandTitle;
    /**
     * Sets the title of the icon that shows the message can collapse.
     */
    collapseTitle;
    /**
     * Sets the title of the DropDownButton that opens the File actions.
     */
    fileActionsTitle;
    /**
     * Sets the title of the button that shows the **Scroll right** when the suggestions list is scrollable with buttons.
     */
    nextSuggestionsButtonTitle;
    /**
     * Sets the title of the button that shows the **Scroll left** when the suggestions list is scrollable with buttons.
     */
    previousSuggestionsButtonTitle;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: Messages, deps: null, target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: Messages, isStandalone: true, selector: "kendoConversationalUIMessages", inputs: { deletedMessageSenderText: "deletedMessageSenderText", deletedMessageReceiverText: "deletedMessageReceiverText", downloadAllFilesText: "downloadAllFilesText", messagePlaceholder: "messagePlaceholder", send: "send", messageListLabel: "messageListLabel", messageBoxInputLabel: "messageBoxInputLabel", messageAttachmentLeftArrow: "messageAttachmentLeftArrow", messageAttachmentRightArrow: "messageAttachmentRightArrow", speechToTextButtonTitle: "speechToTextButtonTitle", fileSelectButtonTitle: "fileSelectButtonTitle", removeReplyTitle: "removeReplyTitle", removeFileTitle: "removeFileTitle", expandTitle: "expandTitle", collapseTitle: "collapseTitle", fileActionsTitle: "fileActionsTitle", nextSuggestionsButtonTitle: "nextSuggestionsButtonTitle", previousSuggestionsButtonTitle: "previousSuggestionsButtonTitle" }, usesInheritance: true, ngImport: i0 });
};
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: Messages$1, decorators: [{
            type: Directive,
            args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: 'kendoConversationalUIMessages'
                }]
        }], propDecorators: { deletedMessageSenderText: [{
                type: Input
            }], deletedMessageReceiverText: [{
                type: Input
            }], downloadAllFilesText: [{
                type: Input
            }], messagePlaceholder: [{
                type: Input
            }], send: [{
                type: Input
            }], messageListLabel: [{
                type: Input
            }], messageBoxInputLabel: [{
                type: Input
            }], messageAttachmentLeftArrow: [{
                type: Input
            }], messageAttachmentRightArrow: [{
                type: Input
            }], speechToTextButtonTitle: [{
                type: Input
            }], fileSelectButtonTitle: [{
                type: Input
            }], removeReplyTitle: [{
                type: Input
            }], removeFileTitle: [{
                type: Input
            }], expandTitle: [{
                type: Input
            }], collapseTitle: [{
                type: Input
            }], fileActionsTitle: [{
                type: Input
            }], nextSuggestionsButtonTitle: [{
                type: Input
            }], previousSuggestionsButtonTitle: [{
                type: Input
            }] } });

// eslint-disable no-forward-ref
/**
 * @hidden
 */
let LocalizedMessagesDirective$1 = class LocalizedMessagesDirective extends Messages$1 {
    service;
    constructor(service) {
        super();
        this.service = service;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: LocalizedMessagesDirective, deps: [{ token: i1.LocalizationService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: LocalizedMessagesDirective, isStandalone: true, selector: "[kendoChatLocalizedMessages]", providers: [
            {
                provide: Messages$1,
                useExisting: forwardRef(() => LocalizedMessagesDirective)
            }
        ], usesInheritance: true, ngImport: i0 });
};
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: LocalizedMessagesDirective$1, decorators: [{
            type: Directive,
            args: [{
                    providers: [
                        {
                            provide: Messages$1,
                            useExisting: forwardRef(() => LocalizedMessagesDirective$1)
                        }
                    ],
                    selector: '[kendoChatLocalizedMessages]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1.LocalizationService }] });

/**
 * Represents the template for the header of the Chat component.
 *
 * @example
 * ```html
 * <kendo-chat>
 *     <ng-template kendoChatHeaderTemplate>
 *         Chat Title
 *     </ng-template>
 * </kendo-chat>
 * ```
 */
class ChatHeaderTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ChatHeaderTemplateDirective, deps: [{ token: i0.TemplateRef }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: ChatHeaderTemplateDirective, isStandalone: true, selector: "[kendoChatHeaderTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ChatHeaderTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoChatHeaderTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef }] });

/**
 * Defines a template for displaying custom content when there are no messages in the Chat.
 *
 * To define an empty Chat template, nest an `<ng-template>` tag with the `kendoChatNoDataTemplate` directive inside the `<kendo-chat>` component.
 * For more information, refer to the article on [message templates](slug:message_templates_chat).
 *
 * @example
 * ```html
 * <kendo-chat>
 *   <ng-template kendoChatNoDataTemplate>
 *     <div>No messages.</div>
 *   </ng-template>
 * </kendo-chat>
 * ```
 */
class NoDataTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: NoDataTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: NoDataTemplateDirective, isStandalone: true, selector: "[kendoChatNoDataTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: NoDataTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoChatNoDataTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }] });

/**
 * Represents the [Kendo UI Chat component for Angular](slug:overview_convui).
 *
 * Provides a conversational UI for chat-based applications.
 * Supports message templates, attachments, localization, and user actions.
 *
 * @example
 * ```html
 * <kendo-chat
 *   [messages]="messages"
 *   [authorId]="authorId"
 *   (sendMessage)="onSendMessage($event)"
 *   (executeAction)="onExecuteAction($event)">
 * </kendo-chat>
 * ```
 *
 * @remarks
 * Supported children components are: {@link CustomMessagesComponent}, {@link HeroCardComponent}, {@link AttachmentTemplateDirective}, {@link ChatHeaderTemplateDirective}, {@link ChatMessageBoxTemplateDirective}, {@link MessageContentTemplateDirective}, {@link MessageTemplateDirective},{@link ChatStatusTemplateDirective}, {@link ChatSuggestionTemplateDirective}, {@link ChatTimestampTemplateDirective}, {@link ChatNoDataTemplateDirective}, {@link ChatUserStatusTemplateDirective}, {@link AuthorMessageContentTemplateDirective}, {@link ReceiverMessageContentTemplateDirective}, {@link ReceiverMessageTemplateDirective}, {@link AuthorMessageTemplateDirective}.
 */
class ChatComponent {
    localization;
    zone;
    renderer;
    element;
    chatService;
    /**
     * Sets the Chat messages.
     * Accepts an array of `Message` objects, but can also accept custom data types.
     * For more information, check [Data Binding](slug:databinding_chat) section in the documentation.
     */
    messages;
    /**
     * Sets the ID that represents the local user.
     */
    authorId;
    /**
     * Determines the type of input used in the message box.
     * ([see example](slug:message_chat)).
     * @default 'textarea'
     *
     * @hidden
     */
    messageBoxType = 'textarea';
    /**
     * Sets the height of the Chat component.
     * Accepts a string with CSS units (for example, `'400px'`, `'50%'`) or a number (interpreted as pixels).
     * The minimum height is `600px`.
     */
    height;
    /**
     * Sets the width of the Chat component.
     * Accepts a string with CSS units (for example, `'400px'`, `'50%'`) or a number (interpreted as pixels).
     * The minimum width is `320px`.
     */
    width;
    /**
     * Sets the placeholder text for the message input box.
     */
    placeholder;
    /**
     * Controls the width of the message between the predefined options.
     *
     * @default 'standard'
     */
    messageWidthMode = 'standard';
    /**
     * Controls the visibility of timestamps in messages.
     *
     * @default 'focus'
     */
    timestampVisibility = 'focus';
    /**
     * Controls the visibility of usernames in messages.
     * When set to `true`, the username displays above each message bubble.
     *
     * @default true
     */
    showUsername = true;
    /**
     * Controls the avatar visibility for the messages.
     * When set to `true`, the user avatar displays next to each message bubble.
     *
     * @default true
     */
    showAvatar = true;
    /**
     * Enables the expand or collapse functionality for messages.
     *
     * @default false
     */
    allowMessageCollapse = false;
    /**
     * Sets the Speech to Text button settings.
     *
     * @default true
     */
    enableSpeechToText = true;
    /**
     * Sets the File Select settings.
     *
     * @default true
     */
    enableFileSelect = true;
    /**
     * Sets the actions of the message toolbar.
     * These actions display in the message toolbar and let you perform specific operations on the message.
     *
     * @default []
     */
    messageToolbarActions = [];
    /**
     * Sets the value of the Message Box.
     *
     * @default ''
     */
    inputValue = '';
    /**
     * Sets the settings for the author's messages.
     */
    authorMessageSettings;
    /**
     * Sets the settings for the receivers' messages.
     */
    receiverMessageSettings;
    /**
     * Sets the default actions that display in the message context menu.
     *
     * @default [{ id: 'copy', label: 'Copy', icon: 'copy', svgIcon: copyIcon, disabled: false }, { id: 'reply', label: 'Reply', icon: 'undo', svgIcon: undoIcon, disabled: false }]
     */
    defaultContextMenuActions = CONTEXT_MENU_ACTIONS;
    /**
     * Sets the actions that display in the message as a context menu.
     * These actions display as menu items and let you perform specific operations on the message.
     * The default actions are `copy` and `reply` and are defined by their `id`.
     */
    set messageContextMenuActions(actions) {
        this._messageContextMenuActions = this.mergeWithDefaultActions(actions, CONTEXT_MENU_ACTIONS);
    }
    get messageContextMenuActions() {
        return this._messageContextMenuActions;
    }
    /**
     * Sets the default actions that display in the file actions DropDownButton.
     *
     * @default [{ id: 'download', label: 'Download', icon: 'download', svgIcon: downloadIcon, disabled: false }]
     */
    defaultFileActions = FILE_ACTIONS;
    /**
     * Sets the actions that display in the file as items of a DropDownButton.
     * These actions display when you click the file DropDownButton and let you perform specific operations on the file.
     * The default action is `download` and is defined by its `id`.
     *
     * @default [{ id: 'download', label: 'Download', icon: 'download', svgIcon: downloadIcon, disabled: false }]
     */
    set fileActions(actions) {
        this._fileActions = this.mergeWithDefaultActions(actions, FILE_ACTIONS);
    }
    get fileActions() {
        return this._fileActions;
    }
    /**
     * Sets the layout of the files in the message bubble.
     *
     * @default 'vertical'
     */
    set messageFilesLayout(layout) {
        this.chatService.messageFilesLayout = layout;
    }
    /**
     * Sets the layout of the suggestions above the message input box.
     *
     * @default 'scroll'
     */
    set suggestionsLayout(layoutMode) {
        if (layoutMode) {
            this.chatService.suggestionsLayout = layoutMode;
        }
    }
    /**
     * Sets the layout of the quick actions suggested below the messages.
     *
     * @default 'scroll'
     */
    set quickActionsLayout(layoutMode) {
        if (layoutMode) {
            this.chatService.quickActionsLayout = layoutMode;
        }
    }
    /**
     * Sets the suggestions that display in the message input box.
     * Suggestions display as a list of clickable items that let you quickly insert predefined text into the message input.
     *
     * @default []
     */
    suggestions = [];
    /**
     * Sets the send button settings for the Chat component.
     * Allows customization of the send button appearance, icons and disabled state.
     *
     * @default { fillMode: 'solid', rounded: 'full', size: 'medium', themeColor: 'primary', icon: 'paper-plane', svgIcon: paperPlaneIcon}
     */
    sendButtonSettings = SEND_BTN_DEFAULT_SETTINGS;
    /**
     * Sets the names of the model fields from which the Chat reads its data.
     * Lets you map custom data types to the expected `Message` format.
     */
    set modelFields(value) {
        this._modelFields = { ...defaultModelFields, ...value };
    }
    get modelFields() {
        return this._modelFields;
    }
    /**
     * Fires when the user sends a message by clicking the **Send** button or pressing **Enter**.
     *
     * The message is not automatically added to the `messages` array.
     */
    sendMessage = new EventEmitter();
    /**
     * Fires when the user clicks a quick action button in the message toolbar.
     */
    toolbarActionClick = new EventEmitter();
    /**
     * Fires when the user clicks an action in the message context menu.
     */
    contextMenuActionClick = new EventEmitter();
    /**
     * Fires when the user clicks an action in the file context menu.
     */
    fileActionClick = new EventEmitter();
    /**
     * Fires when the user clicks an action in the file context menu.
     */
    download = new EventEmitter();
    /**
     * Fires when the user clicks a quick action button.
     * The Chat internally handles [known actions](slug:api_conversational-ui_actiontype) such as `reply`, `openUrl`, and `call`.
     *
     * The event is preventable. Calling [`preventDefault`](https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault) suppresses the built-in action.
     */
    executeAction = new EventEmitter();
    /**
     * Fires when the user clicks a suggestion in the message input box.
     */
    suggestionExecute = new EventEmitter();
    /**
     * Fires when the user selects a file in the message input box.
     */
    fileSelect = new EventEmitter();
    /**
     * Fires when the user removes a file from the message input box.
     */
    fileRemove = new EventEmitter();
    /**
     * Fires when the user unpins the pinned message.
     * This event triggers when the user clicks the delete button on the pinned message.
     */
    unpin = new EventEmitter();
    /**
     * Fires when the user types in the message input box.
     */
    inputValueChange = new EventEmitter();
    get className() {
        return 'k-chat';
    }
    get dirAttr() {
        return this.direction;
    }
    set messagesContextMenu(contextMenu) {
        this.chatService.messagesContextMenu = contextMenu;
    }
    attachmentTemplate;
    chatHeaderTemplate;
    chatNoDataTemplate;
    authorMessageContentTemplate;
    receiverMessageContentTemplate;
    messageContentTemplate;
    authorMessageTemplate;
    receiverMessageTemplate;
    messageTemplate;
    timestampTemplate;
    suggestionTemplate;
    statusTemplate;
    messageBoxTemplate;
    userStatusTemplate;
    messageBox;
    /**
     * @hidden
     */
    messageList;
    /**
     * @hidden
     * Returns processed messages when model fields are used, otherwise returns original messages.
     */
    get processedMessages() {
        if (!this.messages || this.messages.length === 0) {
            return [];
        }
        if (this._modelFields && Object.keys(this._modelFields).some(key => this._modelFields[key] !== defaultModelFields[key])) {
            if (this.messages !== this._lastMessagesReference || this._modelFields !== this._lastModelFields) {
                this._cachedProcessedMessages = processMessages(this.messages, this._modelFields);
                this._lastMessagesReference = this.messages;
                this._lastModelFields = this._modelFields;
            }
            return this._cachedProcessedMessages;
        }
        return this.messages;
    }
    /**
     * Gets the actions available in the message context menu.
     *
     * @hidden
     */
    get contextMenuActions() {
        const currentActions = this.chatService.calculatedContextMenuActions;
        if (currentActions !== this._lastContextMenuActionsReference) {
            this._cachedContextMenuActions = transformActions(currentActions);
            this._lastContextMenuActionsReference = currentActions;
        }
        return this._cachedContextMenuActions;
    }
    /**
     * @hidden
     */
    get localizationText() {
        return this.localization;
    }
    /**
     * @hidden
     */
    autoScroll = true;
    /**
     * @hidden
     */
    pinIcon = pinIcon;
    /**
     * @hidden
     */
    deleteIcon = xIcon;
    /**
     * @hidden
     */
    pinnedMessage;
    direction;
    subs = new Subscription();
    _modelFields = defaultModelFields;
    _messageContextMenuActions = CONTEXT_MENU_ACTIONS;
    _fileActions = FILE_ACTIONS;
    _cachedProcessedMessages = [];
    _lastMessagesReference = null;
    _lastModelFields = null;
    _cachedContextMenuActions = [];
    _lastContextMenuActionsReference = null;
    constructor(localization, zone, renderer, element, chatService) {
        this.localization = localization;
        this.zone = zone;
        this.renderer = renderer;
        this.element = element;
        this.chatService = chatService;
        validatePackage(packageMetadata);
        this.direction = localization.rtl ? 'rtl' : 'ltr';
        this.subs.add(localization.changes.subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
        }));
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this.chatService.messageWidthMode = this.messageWidthMode;
        this.chatService.timestampVisibility = this.timestampVisibility;
        this.chatService.showUsername = this.showUsername;
        this.chatService.showAvatar = this.showAvatar;
        this.chatService.allowMessageCollapse = this.allowMessageCollapse;
        this.chatService.enableSpeechToText = this.enableSpeechToText;
        this.chatService.sendButtonSettings = this.sendButtonSettings;
        this.chatService.enableFileSelect = this.enableFileSelect;
        this.chatService.messageToolbarActions = this.messageToolbarActions;
        this.chatService.messageContextMenuActions = this.messageContextMenuActions;
        this.chatService.fileActions = this.fileActions;
        this.chatService.authorMessageSettings = this.authorMessageSettings;
        this.chatService.receiverMessageSettings = this.receiverMessageSettings;
        this.chatService.messages = this.processedMessages || [];
        this.chatService.chatElement = this.messageList;
        this.subs.add(this.chatService.toolbarAction$.subscribe((actionEvent) => {
            this.toolbarActionClick.emit(actionEvent);
        }));
        this.subs.add(this.chatService.contextMenuAction$.subscribe((actionEvent) => {
            this.contextMenuActionClick.emit(actionEvent);
        }));
        this.subs.add(this.chatService.fileAction$.subscribe((actionEvent) => {
            this.fileActionClick.emit(actionEvent);
        }));
        this.subs.add(this.chatService.fileDownload$.subscribe((actionEvent) => {
            this.download.emit(actionEvent);
        }));
        this.subs.add(this.chatService.inputValueChange$.subscribe((value) => {
            this.inputValueChange.emit(value);
        }));
        this.pinnedMessage = this.findLastPinnedMessage();
        this.chatService.authorId = this.authorId;
    }
    /**
     * @hidden
     */
    ngOnChanges(changes) {
        this.zone.runOutsideAngular(() => setTimeout(() => {
            this.messageList.element.nativeElement.style.flex = '1 1 auto';
        }));
        if (isChanged('messages', changes, false)) {
            this.pinnedMessage = this.findLastPinnedMessage();
            this.chatService.messages = this.processedMessages;
        }
        if (isChanged('height', changes, false)) {
            this.renderer.setStyle(this.element.nativeElement, 'height', `${processCssValue(this.height)}`);
        }
        if (isChanged('width', changes, false)) {
            this.renderer.setStyle(this.element.nativeElement, 'width', `${processCssValue(this.width)}`);
        }
        this.updateChatServiceProperties([
            'authorId',
            'messageWidthMode',
            'timestampVisibility',
            'showUsername',
            'showAvatar',
            'allowMessageCollapse',
            'enableSpeechToText',
            'sendButtonSettings',
            'enableFileSelect',
            'messageToolbarActions',
            'messageContextMenuActions',
            'fileActions',
            'authorMessageSettings',
            'receiverMessageSettings'
        ], changes);
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        if (!isDevMode()) {
            return;
        }
        if (!isPresent(this.authorId)) {
            throw new Error('AuthorId must be set.');
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        if (this.subs) {
            this.subs.unsubscribe();
        }
    }
    /**
     * @hidden
     */
    dispatchAction(e) {
        this.executeAction.emit(e);
        if (!e.isDefaultPrevented()) {
            const handler = makeHandler(e.action);
            handler(e.action, this);
            if (!this.messageBoxTemplate) {
                this.messageBox.messageBoxInput.focus();
            }
        }
    }
    /**
     * @hidden
     */
    textFor(key) {
        return this.localization.get(key);
    }
    /**
     * @hidden
     */
    scrollToPinnedMessage() {
        if (this.pinnedMessage) {
            this.chatService.scrollToMessage(this.pinnedMessage?.id);
        }
    }
    /**
     * @hidden
     */
    onContextMenuAction(action) {
        if (action.id === 'reply') {
            this.chatService.reply = this.chatService.activeMessage;
        }
        if (action.id === 'copy') {
            navigator.clipboard.writeText(this.chatService.activeMessage.text);
        }
        this.chatService.emit('contextMenuAction', { action, message: this.chatService.activeMessage });
    }
    /**
     * @hidden
     */
    handleMenuClose(event) {
        if (event) {
            const originalEvent = event.originalEvent;
            originalEvent && this.onActionButtonClick(originalEvent);
        }
        this.chatService.activeMessage = null;
        this.chatService.emit('contextMenuVisibilityChange', false);
        if (this.chatService.selectOnMenuClose) {
            this.chatService.activeMessageElement.selected = true;
            this.chatService.focusActiveMessageElement();
        }
    }
    /**
     * @hidden
     */
    onActionButtonClick(event) {
        const clickOutsideMessage = event instanceof MouseEvent && !event.target?.closest('.k-chat-bubble');
        const menuItemClick = event instanceof MouseEvent && event.target?.closest(MENU_ITEM_SELECTOR);
        if (clickOutsideMessage && !menuItemClick) {
            this.chatService.selectOnMenuClose = false;
        }
    }
    findLastPinnedMessage() {
        return [...this.processedMessages].reverse().find((message) => message.isPinned);
    }
    updateChatServiceProperties(propNames, changes) {
        propNames.forEach(propName => {
            if (isChanged(propName, changes, false)) {
                this.chatService[propName] = this[propName];
            }
        });
    }
    mergeWithDefaultActions(actions, defaultActions) {
        if (!actions || actions.length === 0) {
            return [];
        }
        return actions.map(userAction => {
            const defaultAction = defaultActions.find(action => action.id === userAction?.id);
            if (defaultAction) {
                return { ...defaultAction, ...userAction };
            }
            return userAction;
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ChatComponent, deps: [{ token: i1.LocalizationService }, { token: i0.NgZone }, { token: i0.Renderer2 }, { token: i0.ElementRef }, { token: ChatService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: ChatComponent, isStandalone: true, selector: "kendo-chat", inputs: { messages: "messages", authorId: "authorId", messageBoxType: "messageBoxType", height: "height", width: "width", placeholder: "placeholder", messageWidthMode: "messageWidthMode", timestampVisibility: "timestampVisibility", showUsername: "showUsername", showAvatar: "showAvatar", allowMessageCollapse: "allowMessageCollapse", enableSpeechToText: "enableSpeechToText", enableFileSelect: "enableFileSelect", messageToolbarActions: "messageToolbarActions", inputValue: "inputValue", authorMessageSettings: "authorMessageSettings", receiverMessageSettings: "receiverMessageSettings", messageContextMenuActions: "messageContextMenuActions", fileActions: "fileActions", messageFilesLayout: "messageFilesLayout", suggestionsLayout: "suggestionsLayout", quickActionsLayout: "quickActionsLayout", suggestions: "suggestions", sendButtonSettings: "sendButtonSettings", modelFields: "modelFields" }, outputs: { sendMessage: "sendMessage", toolbarActionClick: "toolbarActionClick", contextMenuActionClick: "contextMenuActionClick", fileActionClick: "fileActionClick", download: "download", executeAction: "executeAction", suggestionExecute: "suggestionExecute", fileSelect: "fileSelect", fileRemove: "fileRemove", unpin: "unpin", inputValueChange: "inputValueChange" }, host: { properties: { "class": "this.className", "attr.dir": "this.dirAttr" } }, providers: [
            LocalizationService,
            ChatService,
            SuggestionsScrollService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.chat'
            }
        ], queries: [{ propertyName: "attachmentTemplate", first: true, predicate: AttachmentTemplateDirective, descendants: true }, { propertyName: "chatHeaderTemplate", first: true, predicate: ChatHeaderTemplateDirective, descendants: true }, { propertyName: "chatNoDataTemplate", first: true, predicate: NoDataTemplateDirective, descendants: true }, { propertyName: "authorMessageContentTemplate", first: true, predicate: AuthorMessageContentTemplateDirective, descendants: true }, { propertyName: "receiverMessageContentTemplate", first: true, predicate: ReceiverMessageContentTemplateDirective, descendants: true }, { propertyName: "messageContentTemplate", first: true, predicate: MessageContentTemplateDirective, descendants: true }, { propertyName: "authorMessageTemplate", first: true, predicate: AuthorMessageTemplateDirective, descendants: true }, { propertyName: "receiverMessageTemplate", first: true, predicate: ReceiverMessageTemplateDirective, descendants: true }, { propertyName: "messageTemplate", first: true, predicate: MessageTemplateDirective, descendants: true }, { propertyName: "timestampTemplate", first: true, predicate: ChatTimestampTemplateDirective, descendants: true }, { propertyName: "suggestionTemplate", first: true, predicate: ChatSuggestionTemplateDirective, descendants: true }, { propertyName: "statusTemplate", first: true, predicate: ChatStatusTemplateDirective, descendants: true }, { propertyName: "messageBoxTemplate", first: true, predicate: ChatMessageBoxTemplateDirective, descendants: true }, { propertyName: "userStatusTemplate", first: true, predicate: ChatUserStatusTemplateDirective, descendants: true }], viewQueries: [{ propertyName: "messagesContextMenu", first: true, predicate: ["messagesContextMenu"], descendants: true }, { propertyName: "messageBox", first: true, predicate: ["messageBox"], descendants: true }, { propertyName: "messageList", first: true, predicate: ["messageList"], descendants: true, read: ViewContainerRef, static: true }], usesOnChanges: true, ngImport: i0, template: `
        <ng-container kendoChatLocalizedMessages
          i18n-deletedMessageSenderText="kendo.chat.deletedMessageSenderText|The text that is displayed when the sender deletes a message"
          deletedMessageSenderText="You removed this message."
        
          i18n-deletedMessageReceiverText="kendo.chat.deletedMessageReceiverText|The text that is displayed when the receiver deletes a message"
          deletedMessageReceiverText="This message was removed by its sender."
        
          i18n-messagePlaceholder="kendo.chat.messagePlaceholder|The placholder text of the message text input"
          messagePlaceholder="Type a message..."
        
          i18n-send="kendo.chat.send|The text for the Send button"
          send="Send..."
        
          i18n-messageListLabel="kendo.chat.messageListLabel|The label text for the Message list"
          messageListLabel="Message list"
        
          i18n-messageBoxInputLabel="kendo.chat.messageBoxInputLabel|The label text for the Message input box"
          messageBoxInputLabel="Message"
        
          i18n-messageAttachmentLeftArrow="kendo.chat.messageAttachmentLeftArrow|The text for the left arrow of the message attachments"
          messageAttachmentLeftArrow="Previous item"
        
          i18n-messageAttachmentRightArrow="kendo.chat.messageAttachmentRightArrow|The text for the right arrow of the message attachments"
          messageAttachmentRightArrow="Next item"
        
          i18n-speechToTextButtonTitle="kendo.chat.speechToTextButtonTitle|Sets the Speech to Text button title."
          speechToTextButtonTitle="Speech to Text"
        
          i18n-fileSelectButtonTitle="kendo.chat.fileSelectButtonTitle|Sets the File Select button title."
          fileSelectButtonTitle="Select files"
        
          i18n-removeReplyTitle="kendo.chat.removeReplyTitle|Sets the title of the icon which removes the reply reference in the Message Box."
          removeReplyTitle="Remove reply"
        
          i18n-removeFileTitle="kendo.chat.removeFileTitle|Sets the title of the icon which removes a selected file in the Message Box."
          removeFileTitle="Remove file"
        
          i18n-expandTitle="kendo.chat.expandTitle|Sets the title of the icon which demonstrates that the message can be expanded."
          expandTitle="Expand message"
        
          i18n-collapseTitle="kendo.chat.collapseTitle|Sets the title of the icon which demonstrates that the message can be collapsed."
          collapseTitle="Collapse message"
        
          i18n-fileActionsTitle="kendo.chat.fileActionsTitle|Sets the title of the DropDownButton which opens the File actions."
          fileActionsTitle="File actions"
        
          i18n-downloadAllFilesText="kendo.chat.downloadAllFilesText|Sets the text that is displayed in the download section of the message."
          downloadAllFilesText="Download all"
        
          i18n-previousSuggestionsButtonTitle="kendo.chat.previousSuggestionsButtonTitle|The title of the button that scrolls to the previous suggestions"
          previousSuggestionsButtonTitle="Scroll left"
        
          i18n-nextSuggestionsButtonTitle="kendo.chat.nextSuggestionsButtonTitle|The title of the button that scrolls to the next suggestions"
          nextSuggestionsButtonTitle="Scroll right"
          >
        </ng-container>
        
        @if (chatHeaderTemplate) {
          <kendo-appbar class="k-chat-header" positionMode="sticky" themeColor="inherit">
            <ng-container *ngTemplateOutlet="chatHeaderTemplate.templateRef"></ng-container>
          </kendo-appbar>
        }
        @if (pinnedMessage) {
          <div class="k-message-reference k-message-reference-receiver k-message-pinned" (click)="scrollToPinnedMessage()">
            <kendo-icon-wrapper
              size="xlarge"
              name="pin"
              [svgIcon]="pinIcon"
              >
            </kendo-icon-wrapper>
            <chat-message-reference-content [message]="pinnedMessage"></chat-message-reference-content>
            <span class="k-spacer"></span>
            <button kendoButton [svgIcon]="deleteIcon" (click)="unpin.emit(pinnedMessage)" fillMode="flat"></button>
          </div>
        }
        <div
          #messageList
          class="k-message-list"
          aria-live="polite"
          role="log"
          kendoChatScrollAnchor
          [attr.aria-label]="textFor('messageListLabel')"
          #anchor="scrollAnchor"
          [(autoScroll)]="autoScroll"
          >
          @if (processedMessages && processedMessages.length === 0) {
            <div class="k-message-list-content k-message-list-content-empty">
              <ng-template
                [ngTemplateOutlet]="chatNoDataTemplate?.templateRef">
              </ng-template>
            </div>
          } @else {
            <kendo-chat-message-list
              [messages]="processedMessages"
              [authorMessageContentTemplate]="authorMessageContentTemplate"
              [receiverMessageContentTemplate]="receiverMessageContentTemplate"
              [messageContentTemplate]="messageContentTemplate"
              [authorMessageTemplate]="authorMessageTemplate"
              [receiverMessageTemplate]="receiverMessageTemplate"
              [messageTemplate]="messageTemplate"
              [timestampTemplate]="timestampTemplate"
              [statusTemplate]="statusTemplate"
              [userStatusTemplate]="userStatusTemplate"
              [localization]="localizationText"
              [attachmentTemplate]="attachmentTemplate"
              [authorId]="authorId"
              (executeAction)="dispatchAction($event)"
              (resize)="anchor.scrollToBottom()"
              (navigate)="this.autoScroll = false"
              >
            </kendo-chat-message-list>
          }
        </div>
        <kendo-message-box
          #messageBox
          [messageBoxTemplate]="messageBoxTemplate"
          [suggestionTemplate]="suggestionTemplate"
          [suggestions]="suggestions"
          [placeholder]="placeholder"
          [authorId]="authorId"
          [autoScroll]="autoScroll"
          [inputValue]="inputValue"
          [localization]="localizationText"
          (sendMessage)="sendMessage.emit($event)"
          (executeSuggestion)="suggestionExecute.emit($event)"
          (fileSelect)="fileSelect.emit($event)"
          (fileRemove)="fileRemove.emit($event)"
          >
        </kendo-message-box>
        
        <kendo-contextmenu
          #messagesContextMenu
          [items]="contextMenuActions"
          [popupAlign]="{ horizontal: 'right', vertical: 'top' }"
          [collision]="{ horizontal: 'flip', vertical: 'flip'}"
          (popupClose)="handleMenuClose($event)"
          (select)="onContextMenuAction($event.item.originalAction)"
        ></kendo-contextmenu>
        `, isInline: true, dependencies: [{ kind: "directive", type: LocalizedMessagesDirective$1, selector: "[kendoChatLocalizedMessages]" }, { kind: "directive", type: ScrollAnchorDirective, selector: "[kendoChatScrollAnchor]", inputs: ["autoScroll"], outputs: ["autoScrollChange"], exportAs: ["scrollAnchor"] }, { kind: "component", type: MessageListComponent, selector: "kendo-chat-message-list", inputs: ["messages", "attachmentTemplate", "authorMessageContentTemplate", "receiverMessageContentTemplate", "messageContentTemplate", "authorMessageTemplate", "receiverMessageTemplate", "messageTemplate", "timestampTemplate", "statusTemplate", "userStatusTemplate", "localization", "authorId"], outputs: ["executeAction", "navigate", "resize"] }, { kind: "component", type: MessageBoxComponent, selector: "kendo-message-box", inputs: ["authorId", "autoScroll", "suggestions", "placeholder", "inputValue", "localization", "messageBoxTemplate", "suggestionTemplate"], outputs: ["sendMessage", "executeSuggestion", "fileSelect", "fileRemove"] }, { kind: "component", type: MessageReferenceComponent, selector: "chat-message-reference-content", inputs: ["message"] }, { kind: "component", type: AppBarComponent, selector: "kendo-appbar", inputs: ["position", "positionMode", "themeColor"], exportAs: ["kendoAppBar"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "component", type: i2.ButtonComponent, selector: "button[kendoButton]", inputs: ["arrowIcon", "toggleable", "togglable", "selected", "tabIndex", "imageUrl", "iconClass", "icon", "disabled", "size", "rounded", "fillMode", "themeColor", "svgIcon", "primary", "look"], outputs: ["selectedChange", "click"], exportAs: ["kendoButton"] }, { kind: "component", type: ContextMenuComponent, selector: "kendo-contextmenu", inputs: ["showOn", "target", "filter", "alignToAnchor", "vertical", "popupAnimate", "popupAlign", "anchorAlign", "collision", "appendTo", "ariaLabel"], outputs: ["popupOpen", "popupClose", "select", "open", "close"], exportAs: ["kendoContextMenu"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ChatComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        LocalizationService,
                        ChatService,
                        SuggestionsScrollService,
                        {
                            provide: L10N_PREFIX,
                            useValue: 'kendo.chat'
                        }
                    ],
                    selector: 'kendo-chat',
                    template: `
        <ng-container kendoChatLocalizedMessages
          i18n-deletedMessageSenderText="kendo.chat.deletedMessageSenderText|The text that is displayed when the sender deletes a message"
          deletedMessageSenderText="You removed this message."
        
          i18n-deletedMessageReceiverText="kendo.chat.deletedMessageReceiverText|The text that is displayed when the receiver deletes a message"
          deletedMessageReceiverText="This message was removed by its sender."
        
          i18n-messagePlaceholder="kendo.chat.messagePlaceholder|The placholder text of the message text input"
          messagePlaceholder="Type a message..."
        
          i18n-send="kendo.chat.send|The text for the Send button"
          send="Send..."
        
          i18n-messageListLabel="kendo.chat.messageListLabel|The label text for the Message list"
          messageListLabel="Message list"
        
          i18n-messageBoxInputLabel="kendo.chat.messageBoxInputLabel|The label text for the Message input box"
          messageBoxInputLabel="Message"
        
          i18n-messageAttachmentLeftArrow="kendo.chat.messageAttachmentLeftArrow|The text for the left arrow of the message attachments"
          messageAttachmentLeftArrow="Previous item"
        
          i18n-messageAttachmentRightArrow="kendo.chat.messageAttachmentRightArrow|The text for the right arrow of the message attachments"
          messageAttachmentRightArrow="Next item"
        
          i18n-speechToTextButtonTitle="kendo.chat.speechToTextButtonTitle|Sets the Speech to Text button title."
          speechToTextButtonTitle="Speech to Text"
        
          i18n-fileSelectButtonTitle="kendo.chat.fileSelectButtonTitle|Sets the File Select button title."
          fileSelectButtonTitle="Select files"
        
          i18n-removeReplyTitle="kendo.chat.removeReplyTitle|Sets the title of the icon which removes the reply reference in the Message Box."
          removeReplyTitle="Remove reply"
        
          i18n-removeFileTitle="kendo.chat.removeFileTitle|Sets the title of the icon which removes a selected file in the Message Box."
          removeFileTitle="Remove file"
        
          i18n-expandTitle="kendo.chat.expandTitle|Sets the title of the icon which demonstrates that the message can be expanded."
          expandTitle="Expand message"
        
          i18n-collapseTitle="kendo.chat.collapseTitle|Sets the title of the icon which demonstrates that the message can be collapsed."
          collapseTitle="Collapse message"
        
          i18n-fileActionsTitle="kendo.chat.fileActionsTitle|Sets the title of the DropDownButton which opens the File actions."
          fileActionsTitle="File actions"
        
          i18n-downloadAllFilesText="kendo.chat.downloadAllFilesText|Sets the text that is displayed in the download section of the message."
          downloadAllFilesText="Download all"
        
          i18n-previousSuggestionsButtonTitle="kendo.chat.previousSuggestionsButtonTitle|The title of the button that scrolls to the previous suggestions"
          previousSuggestionsButtonTitle="Scroll left"
        
          i18n-nextSuggestionsButtonTitle="kendo.chat.nextSuggestionsButtonTitle|The title of the button that scrolls to the next suggestions"
          nextSuggestionsButtonTitle="Scroll right"
          >
        </ng-container>
        
        @if (chatHeaderTemplate) {
          <kendo-appbar class="k-chat-header" positionMode="sticky" themeColor="inherit">
            <ng-container *ngTemplateOutlet="chatHeaderTemplate.templateRef"></ng-container>
          </kendo-appbar>
        }
        @if (pinnedMessage) {
          <div class="k-message-reference k-message-reference-receiver k-message-pinned" (click)="scrollToPinnedMessage()">
            <kendo-icon-wrapper
              size="xlarge"
              name="pin"
              [svgIcon]="pinIcon"
              >
            </kendo-icon-wrapper>
            <chat-message-reference-content [message]="pinnedMessage"></chat-message-reference-content>
            <span class="k-spacer"></span>
            <button kendoButton [svgIcon]="deleteIcon" (click)="unpin.emit(pinnedMessage)" fillMode="flat"></button>
          </div>
        }
        <div
          #messageList
          class="k-message-list"
          aria-live="polite"
          role="log"
          kendoChatScrollAnchor
          [attr.aria-label]="textFor('messageListLabel')"
          #anchor="scrollAnchor"
          [(autoScroll)]="autoScroll"
          >
          @if (processedMessages && processedMessages.length === 0) {
            <div class="k-message-list-content k-message-list-content-empty">
              <ng-template
                [ngTemplateOutlet]="chatNoDataTemplate?.templateRef">
              </ng-template>
            </div>
          } @else {
            <kendo-chat-message-list
              [messages]="processedMessages"
              [authorMessageContentTemplate]="authorMessageContentTemplate"
              [receiverMessageContentTemplate]="receiverMessageContentTemplate"
              [messageContentTemplate]="messageContentTemplate"
              [authorMessageTemplate]="authorMessageTemplate"
              [receiverMessageTemplate]="receiverMessageTemplate"
              [messageTemplate]="messageTemplate"
              [timestampTemplate]="timestampTemplate"
              [statusTemplate]="statusTemplate"
              [userStatusTemplate]="userStatusTemplate"
              [localization]="localizationText"
              [attachmentTemplate]="attachmentTemplate"
              [authorId]="authorId"
              (executeAction)="dispatchAction($event)"
              (resize)="anchor.scrollToBottom()"
              (navigate)="this.autoScroll = false"
              >
            </kendo-chat-message-list>
          }
        </div>
        <kendo-message-box
          #messageBox
          [messageBoxTemplate]="messageBoxTemplate"
          [suggestionTemplate]="suggestionTemplate"
          [suggestions]="suggestions"
          [placeholder]="placeholder"
          [authorId]="authorId"
          [autoScroll]="autoScroll"
          [inputValue]="inputValue"
          [localization]="localizationText"
          (sendMessage)="sendMessage.emit($event)"
          (executeSuggestion)="suggestionExecute.emit($event)"
          (fileSelect)="fileSelect.emit($event)"
          (fileRemove)="fileRemove.emit($event)"
          >
        </kendo-message-box>
        
        <kendo-contextmenu
          #messagesContextMenu
          [items]="contextMenuActions"
          [popupAlign]="{ horizontal: 'right', vertical: 'top' }"
          [collision]="{ horizontal: 'flip', vertical: 'flip'}"
          (popupClose)="handleMenuClose($event)"
          (select)="onContextMenuAction($event.item.originalAction)"
        ></kendo-contextmenu>
        `,
                    standalone: true,
                    imports: [LocalizedMessagesDirective$1, ScrollAnchorDirective, MessageListComponent, MessageBoxComponent, MessageReferenceComponent, AppBarComponent, NgTemplateOutlet, IconWrapperComponent, KENDO_BUTTON, ContextMenuComponent]
                }]
        }], ctorParameters: () => [{ type: i1.LocalizationService }, { type: i0.NgZone }, { type: i0.Renderer2 }, { type: i0.ElementRef }, { type: ChatService }], propDecorators: { messages: [{
                type: Input
            }], authorId: [{
                type: Input
            }], messageBoxType: [{
                type: Input
            }], height: [{
                type: Input
            }], width: [{
                type: Input
            }], placeholder: [{
                type: Input
            }], messageWidthMode: [{
                type: Input
            }], timestampVisibility: [{
                type: Input
            }], showUsername: [{
                type: Input
            }], showAvatar: [{
                type: Input
            }], allowMessageCollapse: [{
                type: Input
            }], enableSpeechToText: [{
                type: Input
            }], enableFileSelect: [{
                type: Input
            }], messageToolbarActions: [{
                type: Input
            }], inputValue: [{
                type: Input
            }], authorMessageSettings: [{
                type: Input
            }], receiverMessageSettings: [{
                type: Input
            }], messageContextMenuActions: [{
                type: Input
            }], fileActions: [{
                type: Input
            }], messageFilesLayout: [{
                type: Input
            }], suggestionsLayout: [{
                type: Input
            }], quickActionsLayout: [{
                type: Input
            }], suggestions: [{
                type: Input
            }], sendButtonSettings: [{
                type: Input
            }], modelFields: [{
                type: Input
            }], sendMessage: [{
                type: Output
            }], toolbarActionClick: [{
                type: Output
            }], contextMenuActionClick: [{
                type: Output
            }], fileActionClick: [{
                type: Output
            }], download: [{
                type: Output
            }], executeAction: [{
                type: Output
            }], suggestionExecute: [{
                type: Output
            }], fileSelect: [{
                type: Output
            }], fileRemove: [{
                type: Output
            }], unpin: [{
                type: Output
            }], inputValueChange: [{
                type: Output
            }], className: [{
                type: HostBinding,
                args: ['class']
            }], dirAttr: [{
                type: HostBinding,
                args: ['attr.dir']
            }], messagesContextMenu: [{
                type: ViewChild,
                args: ['messagesContextMenu']
            }], attachmentTemplate: [{
                type: ContentChild,
                args: [AttachmentTemplateDirective]
            }], chatHeaderTemplate: [{
                type: ContentChild,
                args: [ChatHeaderTemplateDirective]
            }], chatNoDataTemplate: [{
                type: ContentChild,
                args: [NoDataTemplateDirective]
            }], authorMessageContentTemplate: [{
                type: ContentChild,
                args: [AuthorMessageContentTemplateDirective]
            }], receiverMessageContentTemplate: [{
                type: ContentChild,
                args: [ReceiverMessageContentTemplateDirective]
            }], messageContentTemplate: [{
                type: ContentChild,
                args: [MessageContentTemplateDirective]
            }], authorMessageTemplate: [{
                type: ContentChild,
                args: [AuthorMessageTemplateDirective]
            }], receiverMessageTemplate: [{
                type: ContentChild,
                args: [ReceiverMessageTemplateDirective]
            }], messageTemplate: [{
                type: ContentChild,
                args: [MessageTemplateDirective]
            }], timestampTemplate: [{
                type: ContentChild,
                args: [ChatTimestampTemplateDirective]
            }], suggestionTemplate: [{
                type: ContentChild,
                args: [ChatSuggestionTemplateDirective]
            }], statusTemplate: [{
                type: ContentChild,
                args: [ChatStatusTemplateDirective]
            }], messageBoxTemplate: [{
                type: ContentChild,
                args: [ChatMessageBoxTemplateDirective]
            }], userStatusTemplate: [{
                type: ContentChild,
                args: [ChatUserStatusTemplateDirective]
            }], messageBox: [{
                type: ViewChild,
                args: ['messageBox']
            }], messageList: [{
                type: ViewChild,
                args: ['messageList', { static: true, read: ViewContainerRef }]
            }] } });

// eslint-disable no-forward-ref
/**
 * Represents the custom messages component of the Chat.
 *
 * Use this component to override default messages for the Chat
 * ([see example](slug:globalization_chat#custom-messages)).
 *
 * @example
 * ```html
 * <kendo-chat-messages
 *   send="Send Message"
 *   messagePlaceholder="Type here...">
 * </kendo-chat-messages>
 * ```
 */
class CustomMessagesComponent extends Messages$1 {
    service;
    constructor(service) {
        super();
        this.service = service;
    }
    get override() {
        return true;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CustomMessagesComponent, deps: [{ token: i1.LocalizationService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: CustomMessagesComponent, isStandalone: true, selector: "kendo-chat-messages", providers: [
            {
                provide: Messages$1,
                useExisting: forwardRef(() => CustomMessagesComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CustomMessagesComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: Messages$1,
                            useExisting: forwardRef(() => CustomMessagesComponent)
                        }
                    ],
                    selector: 'kendo-chat-messages',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1.LocalizationService }] });

/**
 * Represents a Hero Card component.
 * Hero cards display a single large image and action buttons with text content.
 *
 * @example
 * ```html
 * <kendo-chat-hero-card
 *   title="Card Title"
 *   subtitle="Card Subtitle"
 *   [actions]="actions">
 * </kendo-chat-hero-card>
 * ```
 */
class HeroCardComponent {
    /**
     * Sets the URL of the hero card image.
     */
    imageUrl;
    /**
     * Sets the title of the hero card.
     */
    title;
    /**
     * Sets the subtitle of the hero card.
     */
    subtitle;
    /**
     * Sets the array of quick actions for this hero card.
     */
    actions;
    cssClass = true;
    /**
     * Fires when the user clicks a button.
     */
    executeAction = new EventEmitter();
    /**
     * Emits the `executeAction` event when the user clicks an action button.
     */
    onClick(action) {
        this.executeAction.next(action);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: HeroCardComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: HeroCardComponent, isStandalone: true, selector: "kendo-chat-hero-card", inputs: { imageUrl: "imageUrl", title: "title", subtitle: "subtitle", actions: "actions" }, outputs: { executeAction: "executeAction" }, host: { properties: { "class.k-card": "this.cssClass" } }, ngImport: i0, template: `
        @if (imageUrl) {
          <img class="k-card-image" [src]="imageUrl" />
        }
        <div class="k-card-body">
          @if (title) {
            <h5 class="k-card-title">
              {{ title }}
            </h5>
          }
          @if (subtitle) {
            <h6 class="k-card-subtitle">
              {{ subtitle }}
            </h6>
          }
        </div>
        <div class="k-card-actions k-card-actions-vertical">
          @for (act of actions; track act) {
            <span class="k-card-action"
              >
              <button
                kendoButton fillMode="flat"
                (click)="onClick(act)"
                >
                {{ act.title }}
              </button>
            </span>
          }
        </div>
        `, isInline: true, dependencies: [{ kind: "component", type: ButtonComponent, selector: "button[kendoButton]", inputs: ["arrowIcon", "toggleable", "togglable", "selected", "tabIndex", "imageUrl", "iconClass", "icon", "disabled", "size", "rounded", "fillMode", "themeColor", "svgIcon", "primary", "look"], outputs: ["selectedChange", "click"], exportAs: ["kendoButton"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: HeroCardComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-chat-hero-card',
                    template: `
        @if (imageUrl) {
          <img class="k-card-image" [src]="imageUrl" />
        }
        <div class="k-card-body">
          @if (title) {
            <h5 class="k-card-title">
              {{ title }}
            </h5>
          }
          @if (subtitle) {
            <h6 class="k-card-subtitle">
              {{ subtitle }}
            </h6>
          }
        </div>
        <div class="k-card-actions k-card-actions-vertical">
          @for (act of actions; track act) {
            <span class="k-card-action"
              >
              <button
                kendoButton fillMode="flat"
                (click)="onClick(act)"
                >
                {{ act.title }}
              </button>
            </span>
          }
        </div>
        `,
                    standalone: true,
                    imports: [ButtonComponent]
                }]
        }], propDecorators: { imageUrl: [{
                type: Input
            }], title: [{
                type: Input
            }], subtitle: [{
                type: Input
            }], actions: [{
                type: Input
            }], cssClass: [{
                type: HostBinding,
                args: ['class.k-card']
            }], executeAction: [{
                type: Output
            }] } });

/**
 * @hidden
 */
class Messages extends ComponentMessages {
    /**
     * The title for the Commands button.
     */
    commandsButtonTitle;
    /**
     * The title for the Generate button.
     */
    generateButtonTitle;
    /**
     * The title for the Speech to Text button.
     */
    speechToTextButtonTitle;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: Messages, deps: null, target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: Messages, isStandalone: true, inputs: { commandsButtonTitle: "commandsButtonTitle", generateButtonTitle: "generateButtonTitle", speechToTextButtonTitle: "speechToTextButtonTitle" }, usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: Messages, decorators: [{
            type: Directive
        }], propDecorators: { commandsButtonTitle: [{
                type: Input
            }], generateButtonTitle: [{
                type: Input
            }], speechToTextButtonTitle: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class LocalizedMessagesDirective extends Messages {
    service;
    constructor(service) {
        super();
        this.service = service;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: LocalizedMessagesDirective, deps: [{ token: i1.LocalizationService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: LocalizedMessagesDirective, isStandalone: true, selector: "[kendoInlineAIPromptLocalizedMessages]", providers: [
            {
                provide: Messages,
                useExisting: forwardRef(() => LocalizedMessagesDirective)
            }
        ], usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: LocalizedMessagesDirective, decorators: [{
            type: Directive,
            args: [{
                    providers: [
                        {
                            provide: Messages,
                            useExisting: forwardRef(() => LocalizedMessagesDirective)
                        }
                    ],
                    selector: '[kendoInlineAIPromptLocalizedMessages]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1.LocalizationService }] });

/**
 * @hidden
 */
const defaultPopupSettings = {
    popupAlign: { vertical: 'top', horizontal: 'left' },
    anchorAlign: { horizontal: "left", vertical: "bottom" },
    positionMode: 'absolute',
    collision: { horizontal: 'fit', vertical: 'flip' },
    animate: true,
    offset: { top: 0, left: 0 },
    margin: { horizontal: 0, vertical: 0 },
};
/**
 * @hidden
 */
const calculateMeasurement = (value) => {
    return value + (typeof value === 'number' ? 'px' : '');
};
/**
 * @hidden
 */
const defaultOutputActions = [{
        name: 'copy',
        type: 'button',
        icon: 'copy',
        svgIcon: copyIcon,
        text: 'Copy',
        fillMode: 'flat',
        themeColor: 'primary',
        rounded: 'medium',
    },
    {
        name: 'retry',
        type: 'button',
        icon: 'arrow-rotate-cw',
        svgIcon: arrowRotateCwIcon,
        text: 'Retry',
        fillMode: 'flat',
        themeColor: 'primary',
        rounded: 'medium',
    },
    {
        name: 'discard',
        type: 'button',
        icon: 'cancel-outline',
        svgIcon: cancelOutlineIcon,
        text: 'Discard',
        fillMode: 'flat',
        themeColor: 'base',
        rounded: 'medium',
    }
];

const TEXTAREA_MAX_ROWS = 5;
const TEXTAREA_INITIAL_ROWS = 1;
/**
 * @hidden
 */
class InlineAIPromptContentComponent {
    ngZone;
    renderer;
    element;
    localization;
    className = true;
    get dirAttr() {
        return this.direction;
    }
    get maxHeightStyle() {
        return this.calculateMeasurement(this.maxHeight);
    }
    get widthStyle() {
        return this.calculateMeasurement(this.width);
    }
    popupElement;
    promptValue = "";
    placeholder;
    promptOutput;
    enableSpeechToText = true;
    streaming = false;
    width = 550;
    maxHeight;
    appendTo;
    defaultOutputActions = defaultOutputActions;
    set outputActions(actions) {
        this._outputActions = this.mergeWithDefaultActions(actions);
    }
    get outputActions() {
        return this._outputActions;
    }
    set promptCommands(commands) {
        this._promptCommands = commands || [];
        this.commandMenuItems = this.transformCommands(commands || []);
    }
    get promptCommands() {
        return this._promptCommands;
    }
    outputTemplate;
    promptRequest = new EventEmitter();
    commandExecute = new EventEmitter();
    outputActionClick = new EventEmitter();
    promptRequestCancel = new EventEmitter();
    close = new EventEmitter();
    promptValueChange = new EventEmitter();
    onEscapeKey(event) {
        if (event.key === 'Escape') {
            if (this.streaming) {
                event.stopPropagation();
                this.promptRequestCancel.emit();
            }
            else {
                this.close.emit();
            }
        }
    }
    textArea;
    contextMenu;
    calculateMeasurement = calculateMeasurement;
    commandMenuIcon = menuIcon;
    sendIcon = paperPlaneIcon;
    stopGenerationIcon = stopSmIcon;
    isListening = false;
    commandMenuItems = [];
    messages = {};
    maxRows = TEXTAREA_MAX_ROWS;
    initialRows = TEXTAREA_INITIAL_ROWS;
    _outputActions = this.defaultOutputActions;
    _promptCommands = [];
    direction;
    localizationSubs = new Subscription();
    subs = new Subscription();
    constructor(ngZone, renderer, element, localization) {
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.element = element;
        this.localization = localization;
        validatePackage(packageMetadata);
        if (!this.localization) {
            this.localization = inject(LocalizationService);
        }
        this.direction = this.localization?.rtl ? 'rtl' : 'ltr';
        this.localizationSubs.add(this.localization.changes.subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
        }));
    }
    ngAfterViewInit() {
        this.ngZone.runOutsideAngular(() => {
            if (!isDocumentAvailable()) {
                return;
            }
            // add a delay to avoid catching the same click event that triggered the component opening
            setTimeout(() => {
                this.subs.add(this.renderer.listen('document', 'click', (e) => {
                    this.outsideClickClose(e);
                }));
            });
        });
    }
    ngOnDestroy() {
        this.subs.unsubscribe();
        this.localizationSubs.unsubscribe();
        this.contextMenu?.hide();
    }
    focus() {
        if (this.textArea) {
            this.textArea.focus();
        }
    }
    onActionClick(event) {
        const eventArgs = {
            action: event,
            output: this.promptOutput,
        };
        this.outputActionClick.emit(eventArgs);
        this.handleDefaultActions(event);
    }
    handleDefaultActions(event) {
        switch (event.name) {
            case 'copy':
                navigator.clipboard.writeText(this.promptOutput.output);
                break;
            case 'retry':
                this.promptRequest.emit({
                    prompt: this.promptOutput?.prompt,
                    isRetry: true
                });
                break;
            case 'discard':
                this.close.emit();
                break;
        }
    }
    handleSpeechResult(event) {
        if (event.alternatives && event.alternatives.length > 0) {
            if (!isPresent(this.promptValue)) {
                this.promptValue = '';
            }
            this.promptValue += event.alternatives[0].transcript + ' ';
        }
    }
    onClick(action) {
        this.commandExecute.next(action);
    }
    handlePromptValueChange(value) {
        this.promptValue = value;
        this.promptValueChange.emit(value);
    }
    handleTextAreaKeydown(event) {
        if (event.key === 'Enter' && !event.shiftKey && !this.streaming) {
            event.preventDefault();
            this.handlePromptRequest();
        }
    }
    onCommandButtonClick(event) {
        event.preventDefault();
        event.stopPropagation();
        if (this.contextMenu) {
            this.contextMenu.show(this.popupElement);
        }
    }
    onCommandClick(event) {
        // avoid triggering the document click listener to keep the popup open
        if (event.originalEvent) {
            event.originalEvent.stopPropagation();
            event.originalEvent.preventDefault();
        }
        const eventArgs = {
            ...event.item.originalCommand
        };
        this.commandExecute.emit(eventArgs);
    }
    messageFor(text) {
        if (this.messages?.[text]) {
            return this.messages[text];
        }
        return this.localization?.get(text);
    }
    handlePromptRequest() {
        if (this.streaming) {
            this.promptRequestCancel.emit();
            return;
        }
        if (!this.promptValue) {
            return;
        }
        const eventArgs = {
            prompt: this.promptValue
        };
        this.promptRequest.emit(eventArgs);
    }
    mergeWithDefaultActions(userActions) {
        if (!userActions || userActions.length === 0) {
            return [];
        }
        return userActions.map(userAction => {
            const defaultAction = defaultOutputActions.find(action => action.name === userAction?.name);
            if (defaultAction) {
                return { ...defaultAction, ...userAction };
            }
            return userAction;
        });
    }
    transformCommands = (commands) => commands.map(command => ({
        text: command.text,
        icon: command.icon,
        svgIcon: command.svgIcon,
        disabled: command.disabled,
        originalCommand: command,
        items: command.children ? this.transformCommands(command.children) : undefined
    }));
    outsideClickClose(e) {
        if (!this.element.nativeElement.contains(e.target)) {
            this.ngZone.run(() => {
                this.close.emit();
            });
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: InlineAIPromptContentComponent, deps: [{ token: i0.NgZone }, { token: i0.Renderer2 }, { token: i0.ElementRef }, { token: i1.LocalizationService, optional: true, skipSelf: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: InlineAIPromptContentComponent, isStandalone: true, selector: "kendo-inlineaiprompt-content", inputs: { popupElement: "popupElement", promptValue: "promptValue", placeholder: "placeholder", promptOutput: "promptOutput", enableSpeechToText: "enableSpeechToText", streaming: "streaming", width: "width", maxHeight: "maxHeight", appendTo: "appendTo", outputActions: "outputActions", promptCommands: "promptCommands", outputTemplate: "outputTemplate" }, outputs: { promptRequest: "promptRequest", commandExecute: "commandExecute", outputActionClick: "outputActionClick", promptRequestCancel: "promptRequestCancel", close: "close", promptValueChange: "promptValueChange" }, host: { listeners: { "keydown": "onEscapeKey($event)" }, properties: { "class.k-prompt": "this.className", "attr.dir": "this.dirAttr", "style.max-height": "this.maxHeightStyle", "style.width": "this.widthStyle" } }, providers: [
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.inlineaiprompt',
            },
        ], viewQueries: [{ propertyName: "textArea", first: true, predicate: TextAreaComponent, descendants: true }, { propertyName: "contextMenu", first: true, predicate: ["kendoContextMenu"], descendants: true }], exportAs: ["kendoInlineAIPromptContent"], ngImport: i0, template: `
        <ng-container kendoInlineAIPromptLocalizedMessages
          i18n-commandsButtonTitle="kendo.inlineaiprompt.commandsButtonTitle|Sets the Commands button title."
          commandsButtonTitle="Command Menu"
          i18n-generateButtonTitle="kendo.inlineaiprompt.generateButtonTitle|Sets the Generate button title."
          generateButtonTitle="Generate"
          i18n-speechToTextButtonTitle="kendo.inlineaiprompt.speechToTextButtonTitle|Sets the Speech to Text button title."
          speechToTextButtonTitle="Speech to Text"
          >
        </ng-container>
        <div class="k-prompt-content">
          <div class="k-prompt-view">
            @if (promptOutput) {
              <kendo-card width="100%">
                <kendo-card-body>
                  @if (outputTemplate) {
                    <ng-container
                      [ngTemplateOutlet]="outputTemplate"
                      [ngTemplateOutletContext]="{ $implicit: promptOutput }"
                      >
                    </ng-container>
                  }
                  @if (!outputTemplate) {
                    {{promptOutput.output}}
                  }
                </kendo-card-body>
                @if (outputActions && outputActions.length > 0) {
                  <kendo-card-actions>
                    @for (action of outputActions; track action) {
                      @if (action.type === 'button') {
                        <button kendoButton
                          [attr.title]="action?.title"
                          [fillMode]="action?.fillMode"
                          [themeColor]="action?.themeColor"
                          [rounded]="action?.rounded"
                          [icon]="action?.icon"
                          [svgIcon]="action?.svgIcon"
                          (click)="onActionClick(action)"
                        >{{action?.text}}</button>
                      }
                      @if (action.type === 'spacer') {
                        <div class="k-spacer"></div>
                      }
                    }
                  </kendo-card-actions>
                }
              </kendo-card>
            }
            <kendo-textarea
              [value]="promptValue ? promptValue : null"
              (valueChange)="handlePromptValueChange($event)"
              [rows]="initialRows"
              resizable="auto"
              flow="horizontal"
              [placeholder]="placeholder"
              [showPrefixSeparator]="true"
              [selectOnFocus]="true"
              [maxResizableRows]="maxRows"
              (keydown)="handleTextAreaKeydown($event)"
              >
              <kendo-textarea-prefix>
                @if (promptCommands && promptCommands.length > 0) {
                  <button
                    kendoButton
                    #commandMenuButton
                    [attr.title]="messageFor('commandsButtonTitle')"
                    fillMode="flat"
                    icon="menu"
                    [svgIcon]="commandMenuIcon"
                    (click)="onCommandButtonClick($event)"
                  ></button>
                }
                @if (enableSpeechToText) {
                  <button
                    kendoSpeechToTextButton
                    [attr.title]="messageFor('speechToTextButtonTitle')"
                    fillMode="flat"
                    (result)="handleSpeechResult($event)"
                    (start)="isListening = true"
                    (end)="isListening = false"
                  ></button>
                }
              </kendo-textarea-prefix>
              <kendo-textarea-suffix>
                <button
                  kendoButton
                  [attr.title]="messageFor('generateButtonTitle')"
                  fillMode="flat"
                  class="k-prompt-send"
                  [ngClass]="{ 'k-generating': streaming, 'k-active': streaming }"
                  (click)="handlePromptRequest()"
                  [disabled]="!streaming && (!promptValue?.trim() || isListening)"
                  [svgIcon]="streaming ? stopGenerationIcon : sendIcon"
                  [icon]="streaming ? 'stop-sm' : 'paper-plane'"
                ></button>
              </kendo-textarea-suffix>
            </kendo-textarea>
          </div>
        </div>
        <kendo-contextmenu
          #kendoContextMenu
          [alignToAnchor]="true"
          [items]="commandMenuItems"
          [appendTo]="appendTo"
          class="k-hidden"
          (select)="onCommandClick($event)">
        </kendo-contextmenu>
        `, isInline: true, dependencies: [{ kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: LocalizedMessagesDirective, selector: "[kendoInlineAIPromptLocalizedMessages]" }, { kind: "component", type: i2.ButtonComponent, selector: "button[kendoButton]", inputs: ["arrowIcon", "toggleable", "togglable", "selected", "tabIndex", "imageUrl", "iconClass", "icon", "disabled", "size", "rounded", "fillMode", "themeColor", "svgIcon", "primary", "look"], outputs: ["selectedChange", "click"], exportAs: ["kendoButton"] }, { kind: "component", type: i2.SpeechToTextButtonComponent, selector: "button[kendoSpeechToTextButton]", inputs: ["disabled", "size", "rounded", "fillMode", "themeColor", "integrationMode", "lang", "continuous", "interimResults", "maxAlternatives"], outputs: ["start", "end", "result", "error", "click"], exportAs: ["kendoSpeechToTextButton"] }, { kind: "component", type: i3.TextAreaComponent, selector: "kendo-textarea", inputs: ["focusableId", "flow", "inputAttributes", "adornmentsOrientation", "rows", "cols", "maxlength", "maxResizableRows", "tabindex", "tabIndex", "resizable", "size", "rounded", "fillMode", "showPrefixSeparator", "showSuffixSeparator"], outputs: ["focus", "blur", "valueChange"], exportAs: ["kendoTextArea"] }, { kind: "component", type: i3.TextAreaPrefixComponent, selector: "kendo-textarea-prefix", inputs: ["flow", "orientation"], exportAs: ["kendoTextAreaPrefix"] }, { kind: "component", type: i3.TextAreaSuffixComponent, selector: "kendo-textarea-suffix", inputs: ["flow", "orientation"], exportAs: ["kendoTextAreaSuffix"] }, { kind: "component", type: i4.ContextMenuComponent, selector: "kendo-contextmenu", inputs: ["showOn", "target", "filter", "alignToAnchor", "vertical", "popupAnimate", "popupAlign", "anchorAlign", "collision", "appendTo", "ariaLabel"], outputs: ["popupOpen", "popupClose", "select", "open", "close"], exportAs: ["kendoContextMenu"] }, { kind: "component", type: i5.CardComponent, selector: "kendo-card", inputs: ["orientation", "width"] }, { kind: "component", type: i5.CardActionsComponent, selector: "kendo-card-actions", inputs: ["orientation", "layout", "actions"], outputs: ["action"] }, { kind: "component", type: i5.CardBodyComponent, selector: "kendo-card-body" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: InlineAIPromptContentComponent, decorators: [{
            type: Component,
            args: [{
                    exportAs: 'kendoInlineAIPromptContent',
                    selector: 'kendo-inlineaiprompt-content',
                    providers: [
                        LocalizationService,
                        {
                            provide: L10N_PREFIX,
                            useValue: 'kendo.inlineaiprompt',
                        },
                    ],
                    template: `
        <ng-container kendoInlineAIPromptLocalizedMessages
          i18n-commandsButtonTitle="kendo.inlineaiprompt.commandsButtonTitle|Sets the Commands button title."
          commandsButtonTitle="Command Menu"
          i18n-generateButtonTitle="kendo.inlineaiprompt.generateButtonTitle|Sets the Generate button title."
          generateButtonTitle="Generate"
          i18n-speechToTextButtonTitle="kendo.inlineaiprompt.speechToTextButtonTitle|Sets the Speech to Text button title."
          speechToTextButtonTitle="Speech to Text"
          >
        </ng-container>
        <div class="k-prompt-content">
          <div class="k-prompt-view">
            @if (promptOutput) {
              <kendo-card width="100%">
                <kendo-card-body>
                  @if (outputTemplate) {
                    <ng-container
                      [ngTemplateOutlet]="outputTemplate"
                      [ngTemplateOutletContext]="{ $implicit: promptOutput }"
                      >
                    </ng-container>
                  }
                  @if (!outputTemplate) {
                    {{promptOutput.output}}
                  }
                </kendo-card-body>
                @if (outputActions && outputActions.length > 0) {
                  <kendo-card-actions>
                    @for (action of outputActions; track action) {
                      @if (action.type === 'button') {
                        <button kendoButton
                          [attr.title]="action?.title"
                          [fillMode]="action?.fillMode"
                          [themeColor]="action?.themeColor"
                          [rounded]="action?.rounded"
                          [icon]="action?.icon"
                          [svgIcon]="action?.svgIcon"
                          (click)="onActionClick(action)"
                        >{{action?.text}}</button>
                      }
                      @if (action.type === 'spacer') {
                        <div class="k-spacer"></div>
                      }
                    }
                  </kendo-card-actions>
                }
              </kendo-card>
            }
            <kendo-textarea
              [value]="promptValue ? promptValue : null"
              (valueChange)="handlePromptValueChange($event)"
              [rows]="initialRows"
              resizable="auto"
              flow="horizontal"
              [placeholder]="placeholder"
              [showPrefixSeparator]="true"
              [selectOnFocus]="true"
              [maxResizableRows]="maxRows"
              (keydown)="handleTextAreaKeydown($event)"
              >
              <kendo-textarea-prefix>
                @if (promptCommands && promptCommands.length > 0) {
                  <button
                    kendoButton
                    #commandMenuButton
                    [attr.title]="messageFor('commandsButtonTitle')"
                    fillMode="flat"
                    icon="menu"
                    [svgIcon]="commandMenuIcon"
                    (click)="onCommandButtonClick($event)"
                  ></button>
                }
                @if (enableSpeechToText) {
                  <button
                    kendoSpeechToTextButton
                    [attr.title]="messageFor('speechToTextButtonTitle')"
                    fillMode="flat"
                    (result)="handleSpeechResult($event)"
                    (start)="isListening = true"
                    (end)="isListening = false"
                  ></button>
                }
              </kendo-textarea-prefix>
              <kendo-textarea-suffix>
                <button
                  kendoButton
                  [attr.title]="messageFor('generateButtonTitle')"
                  fillMode="flat"
                  class="k-prompt-send"
                  [ngClass]="{ 'k-generating': streaming, 'k-active': streaming }"
                  (click)="handlePromptRequest()"
                  [disabled]="!streaming && (!promptValue?.trim() || isListening)"
                  [svgIcon]="streaming ? stopGenerationIcon : sendIcon"
                  [icon]="streaming ? 'stop-sm' : 'paper-plane'"
                ></button>
              </kendo-textarea-suffix>
            </kendo-textarea>
          </div>
        </div>
        <kendo-contextmenu
          #kendoContextMenu
          [alignToAnchor]="true"
          [items]="commandMenuItems"
          [appendTo]="appendTo"
          class="k-hidden"
          (select)="onCommandClick($event)">
        </kendo-contextmenu>
        `,
                    standalone: true,
                    imports: [NgClass, NgTemplateOutlet, LocalizedMessagesDirective, KENDO_BUTTONS, KENDO_TEXTAREA, KENDO_CONTEXTMENU, KENDO_CARD],
                }]
        }], ctorParameters: () => [{ type: i0.NgZone }, { type: i0.Renderer2 }, { type: i0.ElementRef }, { type: i1.LocalizationService, decorators: [{
                    type: Optional
                }, {
                    type: SkipSelf
                }] }], propDecorators: { className: [{
                type: HostBinding,
                args: ['class.k-prompt']
            }], dirAttr: [{
                type: HostBinding,
                args: ['attr.dir']
            }], maxHeightStyle: [{
                type: HostBinding,
                args: ['style.max-height']
            }], widthStyle: [{
                type: HostBinding,
                args: ['style.width']
            }], popupElement: [{
                type: Input
            }], promptValue: [{
                type: Input
            }], placeholder: [{
                type: Input
            }], promptOutput: [{
                type: Input
            }], enableSpeechToText: [{
                type: Input
            }], streaming: [{
                type: Input
            }], width: [{
                type: Input
            }], maxHeight: [{
                type: Input
            }], appendTo: [{
                type: Input
            }], outputActions: [{
                type: Input
            }], promptCommands: [{
                type: Input
            }], outputTemplate: [{
                type: Input
            }], promptRequest: [{
                type: Output
            }], commandExecute: [{
                type: Output
            }], outputActionClick: [{
                type: Output
            }], promptRequestCancel: [{
                type: Output
            }], close: [{
                type: Output
            }], promptValueChange: [{
                type: Output
            }], onEscapeKey: [{
                type: HostListener,
                args: ['keydown', ['$event']]
            }], textArea: [{
                type: ViewChild,
                args: [TextAreaComponent]
            }], contextMenu: [{
                type: ViewChild,
                args: ['kendoContextMenu']
            }] } });

/**
 * Defines a template for displaying the output of the Inline AI Prompt.
 *
 * @example
 * ```html
 * <kendo-inlineaiprompt>
 *   <ng-template kendoInlineAIPromptOutputTemplate let-output>
 *     <div class="custom-output">
 *       <h4>AI Response:</h4>
 *       <p>{{ output.output }}</p>
 *     </div>
 *   </ng-template>
 * </kendo-inlineaiprompt>
 * ```
 */
class InlineAIPromptOutputTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: InlineAIPromptOutputTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: InlineAIPromptOutputTemplateDirective, isStandalone: true, selector: "[kendoInlineAIPromptOutputTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: InlineAIPromptOutputTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoInlineAIPromptOutputTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }] });

/**
 * Represents the Kendo UI InlineAIPrompt component for Angular.
 *
 * @remarks
 * Supported children components are: {@link InlineAIPromptCustomMessagesComponent}
 *
 * @example
 * ```html
 * <kendo-inlineaiprompt
 *   placeholder="Enter your prompt..."
 *   [promptOutput]="promptOutput"
 *   (promptRequest)="onPromptRequest($event)">
 * </kendo-inlineaiprompt>
 * ```
 */
class InlineAIPromptComponent {
    ngZone;
    element;
    /**
     * Sets the TextArea value.
     *
     * @default ""
     */
    promptValue = "";
    /**
     * Sets the placeholder text that appears in the text area when it is empty.
     */
    placeholder;
    /**
     * Sets the output data for the prompt.
     * The output displays as a card above the text area.
     */
    promptOutput;
    /**
     * Controls the visibility and settings of the Speech to Text button.
     *
     * @default true
     */
    enableSpeechToText = true;
    /**
     * When set to `true`, the **Send** button displays a generating state and the component emits a `promptRequestCancel` event when you click it.
     *
     * @default false
     */
    streaming = false;
    /**
     * Sets the width of the component.
     * Accepts a number for pixels or a string for other units.
     *
     * @default 550
     */
    width = 550;
    /**
     * Sets the maximum height of the component.
     * Accepts a number for pixels or a string for other units.
     */
    maxHeight;
    /**
     * Represents the configuration of the default output actions.
     * The default actions are `copy`, `retry`, and `discard`.
     */
    defaultOutputActions = defaultOutputActions;
    /**
     * Sets the output actions that display in the output card.
     * The default actions are `copy`, `retry`, and `discard`.
     * To customize the appearance and order of the default actions, define them with the same `name`.
     *
     * @default [{ name: 'copy', type: 'button', icon: 'copy', svgIcon: copyIcon, text: 'Copy', fillMode: 'flat', themeColor: 'primary', rounded: 'medium'}, { name: 'retry', type: 'button', icon: 'arrow-rotate-cw', svgIcon: arrowRotateCwIcon, text: 'Retry', fillMode: 'flat', themeColor: 'primary', rounded: 'medium'}, { name: 'discard', type: 'button', icon: 'cancel-outline', svgIcon: cancelOutlineIcon, text: 'Discard', fillMode: 'flat', themeColor: 'base', rounded: 'medium'}]
     */
    outputActions = defaultOutputActions;
    /**
     * Sets the available prompt commands.
     */
    promptCommands;
    /**
     * Sets the Popup settings.
     *
     */
    set popupSettings(settings) {
        this._popupSettings = { ...defaultPopupSettings, ...settings };
    }
    get popupSettings() {
        return this._popupSettings;
    }
    /**
     * Fires when the send button is clicked.
     */
    promptRequest = new EventEmitter();
    /**
     * Fires when a command is executed.
     */
    commandExecute = new EventEmitter();
    /**
     * Fires when an output action button is clicked.
     */
    outputActionClick = new EventEmitter();
    /**
     * Fires when the stop button is clicked during streaming.
     */
    promptRequestCancel = new EventEmitter();
    /**
     * Fires when the component closes (Escape key, Discard action or outside click).
     */
    close = new EventEmitter();
    /**
     * Fires when the TextArea value changes.
     */
    promptValueChange = new EventEmitter();
    popupElement;
    popupViewContainer;
    contentComponent;
    outputTemplate;
    /**
     * @hidden
     */
    calculateMeasurement = calculateMeasurement;
    _popupSettings = defaultPopupSettings;
    subs = new Subscription();
    constructor(ngZone, element) {
        this.ngZone = ngZone;
        this.element = element;
        validatePackage(packageMetadata);
    }
    ngAfterViewInit() {
        if (this.contentComponent && this.popupElement) {
            this.contentComponent.popupElement = this.popupElement;
        }
        this.ngZone.onStable.pipe(take(1)).subscribe(() => {
            if (this.contentComponent && this.popupViewContainer) {
                this.contentComponent.appendTo = this.popupViewContainer;
            }
        });
    }
    ngOnDestroy() {
        this.subs.unsubscribe();
    }
    /**
     * Focus the TextArea.
     */
    focus() {
        if (this.contentComponent?.textArea) {
            this.contentComponent.textArea.focus();
        }
    }
    /**
     * @hidden
     */
    onPromptRequest(event) {
        this.promptRequest.emit(event);
    }
    /**
     * @hidden
     */
    onCommandExecute(event) {
        this.commandExecute.emit(event);
    }
    /**
     * @hidden
     */
    onOutputActionClick(event) {
        this.outputActionClick.emit(event);
    }
    /**
     * @hidden
     */
    onPromptRequestCancel() {
        this.promptRequestCancel.emit();
    }
    /**
     * @hidden
     */
    onClose() {
        this.close.emit();
    }
    /**
     * @hidden
     */
    onPromptValueChange(value) {
        this.promptValueChange.emit(value);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: InlineAIPromptComponent, deps: [{ token: i0.NgZone }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: InlineAIPromptComponent, isStandalone: true, selector: "kendo-inlineaiprompt", inputs: { promptValue: "promptValue", placeholder: "placeholder", promptOutput: "promptOutput", enableSpeechToText: "enableSpeechToText", streaming: "streaming", width: "width", maxHeight: "maxHeight", outputActions: "outputActions", promptCommands: "promptCommands", popupSettings: "popupSettings" }, outputs: { promptRequest: "promptRequest", commandExecute: "commandExecute", outputActionClick: "outputActionClick", promptRequestCancel: "promptRequestCancel", close: "close", promptValueChange: "promptValueChange" }, providers: [
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.inlineaiprompt',
            },
        ], queries: [{ propertyName: "outputTemplate", first: true, predicate: InlineAIPromptOutputTemplateDirective, descendants: true }], viewQueries: [{ propertyName: "popupElement", first: true, predicate: PopupComponent, descendants: true, read: ElementRef }, { propertyName: "popupViewContainer", first: true, predicate: PopupComponent, descendants: true, read: ViewContainerRef }, { propertyName: "contentComponent", first: true, predicate: InlineAIPromptContentComponent, descendants: true }], exportAs: ["kendoInlineAIPrompt"], ngImport: i0, template: `
        <ng-container kendoInlineAIPromptLocalizedMessages
            i18n-commandsButtonTitle="kendo.inlineaiprompt.commandsButtonTitle|Sets the Commands button title."
            commandsButtonTitle="Command Menu"
            i18n-generateButtonTitle="kendo.inlineaiprompt.generateButtonTitle|Sets the Generate button title."
            generateButtonTitle="Generate"
            i18n-speechToTextButtonTitle="kendo.inlineaiprompt.speechToTextButtonTitle|Sets the Speech to Text button title."
            speechToTextButtonTitle="Speech to Text"
        >
        </ng-container>
        <kendo-popup
            [style.width]="calculateMeasurement(width)"
            [anchor]="popupSettings?.anchor"
            [anchorAlign]="popupSettings?.anchorAlign"
            [offset]="popupSettings?.offset"
            [popupAlign]="popupSettings?.popupAlign"
            [animate]="popupSettings?.animate"
            [collision]="popupSettings?.collision"
            [positionMode]="popupSettings?.positionMode"
            [margin]="popupSettings?.margin"
            [popupClass]="popupSettings?.popupClass || 'k-prompt-popup'"
        >
            <kendo-inlineaiprompt-content
                [style.width]="width"
                [promptValue]="promptValue"
                [placeholder]="placeholder"
                [promptOutput]="promptOutput"
                [enableSpeechToText]="enableSpeechToText"
                [streaming]="streaming"
                [maxHeight]="maxHeight"
                [outputActions]="outputActions"
                [promptCommands]="promptCommands"
                [outputTemplate]="outputTemplate?.templateRef"
                (promptRequest)="onPromptRequest($event)"
                (commandExecute)="onCommandExecute($event)"
                (outputActionClick)="onOutputActionClick($event)"
                (promptRequestCancel)="onPromptRequestCancel()"
                (close)="onClose()"
                (promptValueChange)="onPromptValueChange($event)"
            >
            </kendo-inlineaiprompt-content>
        </kendo-popup>
    `, isInline: true, dependencies: [{ kind: "component", type: i1$2.PopupComponent, selector: "kendo-popup", inputs: ["animate", "anchor", "anchorAlign", "collision", "popupAlign", "copyAnchorStyles", "popupClass", "positionMode", "offset", "margin"], outputs: ["anchorViewportLeave", "close", "open", "positionChange"], exportAs: ["kendo-popup"] }, { kind: "component", type: InlineAIPromptContentComponent, selector: "kendo-inlineaiprompt-content", inputs: ["popupElement", "promptValue", "placeholder", "promptOutput", "enableSpeechToText", "streaming", "width", "maxHeight", "appendTo", "outputActions", "promptCommands", "outputTemplate"], outputs: ["promptRequest", "commandExecute", "outputActionClick", "promptRequestCancel", "close", "promptValueChange"], exportAs: ["kendoInlineAIPromptContent"] }, { kind: "directive", type: LocalizedMessagesDirective, selector: "[kendoInlineAIPromptLocalizedMessages]" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: InlineAIPromptComponent, decorators: [{
            type: Component,
            args: [{
                    exportAs: 'kendoInlineAIPrompt',
                    selector: 'kendo-inlineaiprompt',
                    providers: [
                        LocalizationService,
                        {
                            provide: L10N_PREFIX,
                            useValue: 'kendo.inlineaiprompt',
                        },
                    ],
                    template: `
        <ng-container kendoInlineAIPromptLocalizedMessages
            i18n-commandsButtonTitle="kendo.inlineaiprompt.commandsButtonTitle|Sets the Commands button title."
            commandsButtonTitle="Command Menu"
            i18n-generateButtonTitle="kendo.inlineaiprompt.generateButtonTitle|Sets the Generate button title."
            generateButtonTitle="Generate"
            i18n-speechToTextButtonTitle="kendo.inlineaiprompt.speechToTextButtonTitle|Sets the Speech to Text button title."
            speechToTextButtonTitle="Speech to Text"
        >
        </ng-container>
        <kendo-popup
            [style.width]="calculateMeasurement(width)"
            [anchor]="popupSettings?.anchor"
            [anchorAlign]="popupSettings?.anchorAlign"
            [offset]="popupSettings?.offset"
            [popupAlign]="popupSettings?.popupAlign"
            [animate]="popupSettings?.animate"
            [collision]="popupSettings?.collision"
            [positionMode]="popupSettings?.positionMode"
            [margin]="popupSettings?.margin"
            [popupClass]="popupSettings?.popupClass || 'k-prompt-popup'"
        >
            <kendo-inlineaiprompt-content
                [style.width]="width"
                [promptValue]="promptValue"
                [placeholder]="placeholder"
                [promptOutput]="promptOutput"
                [enableSpeechToText]="enableSpeechToText"
                [streaming]="streaming"
                [maxHeight]="maxHeight"
                [outputActions]="outputActions"
                [promptCommands]="promptCommands"
                [outputTemplate]="outputTemplate?.templateRef"
                (promptRequest)="onPromptRequest($event)"
                (commandExecute)="onCommandExecute($event)"
                (outputActionClick)="onOutputActionClick($event)"
                (promptRequestCancel)="onPromptRequestCancel()"
                (close)="onClose()"
                (promptValueChange)="onPromptValueChange($event)"
            >
            </kendo-inlineaiprompt-content>
        </kendo-popup>
    `,
                    standalone: true,
                    imports: [KENDO_POPUP, InlineAIPromptContentComponent, LocalizedMessagesDirective],
                }]
        }], ctorParameters: () => [{ type: i0.NgZone }, { type: i0.ElementRef }], propDecorators: { promptValue: [{
                type: Input
            }], placeholder: [{
                type: Input
            }], promptOutput: [{
                type: Input
            }], enableSpeechToText: [{
                type: Input
            }], streaming: [{
                type: Input
            }], width: [{
                type: Input
            }], maxHeight: [{
                type: Input
            }], outputActions: [{
                type: Input
            }], promptCommands: [{
                type: Input
            }], popupSettings: [{
                type: Input
            }], promptRequest: [{
                type: Output
            }], commandExecute: [{
                type: Output
            }], outputActionClick: [{
                type: Output
            }], promptRequestCancel: [{
                type: Output
            }], close: [{
                type: Output
            }], promptValueChange: [{
                type: Output
            }], popupElement: [{
                type: ViewChild,
                args: [PopupComponent, { read: ElementRef }]
            }], popupViewContainer: [{
                type: ViewChild,
                args: [PopupComponent, { read: ViewContainerRef }]
            }], contentComponent: [{
                type: ViewChild,
                args: [InlineAIPromptContentComponent]
            }], outputTemplate: [{
                type: ContentChild,
                args: [InlineAIPromptOutputTemplateDirective]
            }] } });

/**
 * Provides a component for customizing messages in the Inline AI Prompt. [See example](slug:globalization_chat#custom-messages).
 *
 * @example
 * ```html
 * <kendo-inlineaiprompt-messages
 *   commandsButtonTitle="Commands Menu"
 *   generateButtonTitle="Generate">
 * </kendo-inlineaiprompt-messages>
 * ```
 */
class InlineAIPromptCustomMessagesComponent extends Messages {
    service;
    constructor(service) {
        super();
        this.service = service;
    }
    get override() {
        return true;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: InlineAIPromptCustomMessagesComponent, deps: [{ token: i1.LocalizationService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: InlineAIPromptCustomMessagesComponent, isStandalone: true, selector: "kendo-inlineaiprompt-messages", providers: [
            {
                provide: Messages,
                useExisting: forwardRef(() => InlineAIPromptCustomMessagesComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: InlineAIPromptCustomMessagesComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: Messages,
                            useExisting: forwardRef(() => InlineAIPromptCustomMessagesComponent)
                        }
                    ],
                    selector: 'kendo-inlineaiprompt-messages',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1.LocalizationService }] });

/**
 * Utility array that contains all AIPrompt related components and directives.
 *
 * @example
 * ```ts
 * import { Component } from '@angular/core';
 * import { KENDO_AIPROMPT } from '@progress/kendo-angular-conversational-ui';
 *
 * @Component({
 *   standalone: true,
 *   imports: [KENDO_AIPROMPT],
 *   selector: 'my-app',
 *   template: `<kendo-aiprompt></kendo-aiprompt>`
 * })
 * export class AppComponent {}
 * ```
 */
const KENDO_AIPROMPT = [
    AIPromptComponent,
    PromptViewComponent,
    OutputViewComponent,
    CommandViewComponent,
    CustomViewComponent,
    AIPromptCustomMessagesComponent,
    AIPromptToolbarActionsDirective,
    AIPromptToolbarFocusableDirective,
    AIPromptOutputTemplateDirective,
    AIPromptOutputBodyTemplateDirective,
];
/**
 * Utility array that contains all Chat related components and directives.
 *
 * @example
 * ```ts
 * import { Component } from '@angular/core';
 * import { KENDO_CHAT } from '@progress/kendo-angular-conversational-ui';
 *
 * @Component({
 *   standalone: true,
 *   imports: [KENDO_CHAT],
 *   selector: 'my-app',
 *   template: `<kendo-chat></kendo-chat>`
 * })
 * export class AppComponent {}
 * ```
 */
const KENDO_CHAT = [
    ChatComponent,
    CustomMessagesComponent,
    AttachmentTemplateDirective,
    AuthorMessageContentTemplateDirective,
    ReceiverMessageContentTemplateDirective,
    MessageContentTemplateDirective,
    AuthorMessageTemplateDirective,
    ReceiverMessageTemplateDirective,
    MessageTemplateDirective,
    HeroCardComponent,
    ChatMessageBoxTemplateDirective,
    ChatHeaderTemplateDirective,
    NoDataTemplateDirective,
    ChatTimestampTemplateDirective,
    ChatStatusTemplateDirective,
    ChatSuggestionTemplateDirective,
    ChatUserStatusTemplateDirective
];
/**
 * Utility array that contains all InlineAIPrompt related components and directives.
 *
 * @example
 * ```ts
 * import { Component } from '@angular/core';
 * import { KENDO_INLINEAIPROMPT } from '@progress/kendo-angular-conversational-ui';
 *
 * @Component({
 *   standalone: true,
 *   imports: [KENDO_INLINEAIPROMPT],
 *   selector: 'my-app',
 *   template: `<kendo-inlineaiprompt></kendo-inlineaiprompt>`
 * })
 * export class AppComponent {}
 * ```
 */
const KENDO_INLINEAIPROMPT = [
    InlineAIPromptComponent,
    InlineAIPromptOutputTemplateDirective,
    InlineAIPromptCustomMessagesComponent
];
/**
 * Utility array that contains all `@progress/kendo-angular-conversational-ui` related components and directives.
 *
 * @example
 * ```ts
 * import { Component } from '@angular/core';
 * import { KENDO_CONVERSATIONALUI } from '@progress/kendo-angular-conversational-ui';
 *
 * @Component({
 *   standalone: true,
 *   imports: [KENDO_CONVERSATIONALUI],
 *   selector: 'my-app',
 *   template: `
 *     <kendo-aiprompt></kendo-aiprompt>
 *     <kendo-chat></kendo-chat>
 *   `
 * })
 * export class AppComponent {}
 * ```
 */
const KENDO_CONVERSATIONALUI = [
    ...KENDO_AIPROMPT,
    ...KENDO_CHAT,
    ...KENDO_INLINEAIPROMPT
];

// IMPORTANT: NgModule export kept for backwards compatibility
/**
 * Represents the [`NgModule`](link:site.data.urls.angular['ngmodules']) for the AIPrompt component.
 *
 * @example
 * ```ts
 * import { NgModule } from '@angular/core';
 * import { BrowserModule } from '@angular/platform-browser';
 * import { AIPromptModule } from '@progress/kendo-angular-conversational-ui';
 * import { AppComponent } from './app.component';
 *
 * @NgModule({
 *   imports: [BrowserModule, AIPromptModule],
 *   declarations: [AppComponent],
 *   bootstrap: [AppComponent]
 * })
 * export class AppModule {}
 * ```
 */
class AIPromptModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AIPromptModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.18", ngImport: i0, type: AIPromptModule, imports: [AIPromptComponent, PromptViewComponent, OutputViewComponent, CommandViewComponent, CustomViewComponent, AIPromptCustomMessagesComponent, AIPromptToolbarActionsDirective, AIPromptToolbarFocusableDirective, AIPromptOutputTemplateDirective, AIPromptOutputBodyTemplateDirective], exports: [AIPromptComponent, PromptViewComponent, OutputViewComponent, CommandViewComponent, CustomViewComponent, AIPromptCustomMessagesComponent, AIPromptToolbarActionsDirective, AIPromptToolbarFocusableDirective, AIPromptOutputTemplateDirective, AIPromptOutputBodyTemplateDirective] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AIPromptModule, providers: [IconsService, PopupService, ResizeBatchService, DialogContainerService, DialogService, WindowService, WindowContainerService], imports: [AIPromptComponent, PromptViewComponent, OutputViewComponent, CommandViewComponent] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AIPromptModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [...KENDO_AIPROMPT],
                    imports: [...KENDO_AIPROMPT],
                    providers: [IconsService, PopupService, ResizeBatchService, DialogContainerService, DialogService, WindowService, WindowContainerService]
                }]
        }] });

// IMPORTANT: NgModule export kept for backwards compatibility
/**
 * Represents the [`NgModule`](link:site.data.urls.angular['ngmodules']) for the Chat component.
 *
 * @example
 * ```ts-no-run
 * import { NgModule } from '@angular/core';
 * import { Component } from '@angular/core';
 * import { BrowserModule } from '@angular/platform-browser';
 *
 * import { ChatModule } from '@progress/kendo-angular-conversational-ui';
 * import { AppComponent } from './app.component';
 *
 * _@NgModule({
 *   imports: [BrowserModule, ChatModule],
 *   declarations: [AppComponent],
 *   bootstrap: [AppComponent]
 * })
 *
 * export class AppModule { }
 * ```
 */
class ChatModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ChatModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.18", ngImport: i0, type: ChatModule, imports: [ChatComponent, CustomMessagesComponent, AttachmentTemplateDirective, AuthorMessageContentTemplateDirective, ReceiverMessageContentTemplateDirective, MessageContentTemplateDirective, AuthorMessageTemplateDirective, ReceiverMessageTemplateDirective, MessageTemplateDirective, HeroCardComponent, ChatMessageBoxTemplateDirective, ChatHeaderTemplateDirective, NoDataTemplateDirective, ChatTimestampTemplateDirective, ChatStatusTemplateDirective, ChatSuggestionTemplateDirective, ChatUserStatusTemplateDirective], exports: [ChatComponent, CustomMessagesComponent, AttachmentTemplateDirective, AuthorMessageContentTemplateDirective, ReceiverMessageContentTemplateDirective, MessageContentTemplateDirective, AuthorMessageTemplateDirective, ReceiverMessageTemplateDirective, MessageTemplateDirective, HeroCardComponent, ChatMessageBoxTemplateDirective, ChatHeaderTemplateDirective, NoDataTemplateDirective, ChatTimestampTemplateDirective, ChatStatusTemplateDirective, ChatSuggestionTemplateDirective, ChatUserStatusTemplateDirective] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ChatModule, providers: [IconsService, ResizeBatchService], imports: [ChatComponent, HeroCardComponent] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ChatModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [...KENDO_CHAT],
                    imports: [...KENDO_CHAT],
                    providers: [IconsService, ResizeBatchService]
                }]
        }] });

// IMPORTANT: NgModule export kept for backwards compatibility
/**
 * Represents the [`NgModule`](link:site.data.urls.angular['ngmodules']) for the Conversational UI components.
 *
 * @example
 * ```ts
 * import { NgModule } from '@angular/core';
 * import { BrowserModule } from '@angular/platform-browser';
 * import { ConversationalUIModule } from '@progress/kendo-angular-conversational-ui';
 * import { AppComponent } from './app.component';
 *
 * @NgModule({
 *   declarations: [AppComponent],
 *   imports: [BrowserModule, ConversationalUIModule],
 *   bootstrap: [AppComponent]
 * })
 * export class AppModule {}
 * ```
 */
class ConversationalUIModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ConversationalUIModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.18", ngImport: i0, type: ConversationalUIModule, imports: [AIPromptComponent, PromptViewComponent, OutputViewComponent, CommandViewComponent, CustomViewComponent, AIPromptCustomMessagesComponent, AIPromptToolbarActionsDirective, AIPromptToolbarFocusableDirective, AIPromptOutputTemplateDirective, AIPromptOutputBodyTemplateDirective, ChatComponent, CustomMessagesComponent, AttachmentTemplateDirective, AuthorMessageContentTemplateDirective, ReceiverMessageContentTemplateDirective, MessageContentTemplateDirective, AuthorMessageTemplateDirective, ReceiverMessageTemplateDirective, MessageTemplateDirective, HeroCardComponent, ChatMessageBoxTemplateDirective, ChatHeaderTemplateDirective, NoDataTemplateDirective, ChatTimestampTemplateDirective, ChatStatusTemplateDirective, ChatSuggestionTemplateDirective, ChatUserStatusTemplateDirective, InlineAIPromptComponent, InlineAIPromptOutputTemplateDirective, InlineAIPromptCustomMessagesComponent], exports: [AIPromptComponent, PromptViewComponent, OutputViewComponent, CommandViewComponent, CustomViewComponent, AIPromptCustomMessagesComponent, AIPromptToolbarActionsDirective, AIPromptToolbarFocusableDirective, AIPromptOutputTemplateDirective, AIPromptOutputBodyTemplateDirective, ChatComponent, CustomMessagesComponent, AttachmentTemplateDirective, AuthorMessageContentTemplateDirective, ReceiverMessageContentTemplateDirective, MessageContentTemplateDirective, AuthorMessageTemplateDirective, ReceiverMessageTemplateDirective, MessageTemplateDirective, HeroCardComponent, ChatMessageBoxTemplateDirective, ChatHeaderTemplateDirective, NoDataTemplateDirective, ChatTimestampTemplateDirective, ChatStatusTemplateDirective, ChatSuggestionTemplateDirective, ChatUserStatusTemplateDirective, InlineAIPromptComponent, InlineAIPromptOutputTemplateDirective, InlineAIPromptCustomMessagesComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ConversationalUIModule, providers: [IconsService, PopupService, ResizeBatchService, DialogContainerService, DialogService, WindowService, WindowContainerService], imports: [AIPromptComponent, PromptViewComponent, OutputViewComponent, CommandViewComponent, ChatComponent, HeroCardComponent, InlineAIPromptComponent] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ConversationalUIModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [...KENDO_CONVERSATIONALUI],
                    imports: [...KENDO_CONVERSATIONALUI],
                    providers: [IconsService, PopupService, ResizeBatchService, DialogContainerService, DialogService, WindowService, WindowContainerService]
                }]
        }] });

// IMPORTANT: NgModule export kept for backwards compatibility
/**
 * Represents the [`NgModule`](link:site.data.urls.angular['ngmodules']) for the InlineAIPrompt component.
 *
 * @example
 * ```ts
 * import { NgModule } from '@angular/core';
 * import { BrowserModule } from '@angular/platform-browser';
 * import { InlineAIPromptModule } from '@progress/kendo-angular-conversational-ui';
 * import { AppComponent } from './app.component';
 *
 * @NgModule({
 *   imports: [BrowserModule, InlineAIPromptModule],
 *   declarations: [AppComponent],
 *   bootstrap: [AppComponent]
 * })
 * export class AppModule {}
 * ```
 */
class InlineAIPromptModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: InlineAIPromptModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.18", ngImport: i0, type: InlineAIPromptModule, imports: [InlineAIPromptComponent, InlineAIPromptOutputTemplateDirective, InlineAIPromptCustomMessagesComponent], exports: [InlineAIPromptComponent, InlineAIPromptOutputTemplateDirective, InlineAIPromptCustomMessagesComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: InlineAIPromptModule, providers: [IconsService, PopupService, ResizeBatchService, DialogContainerService, DialogService, WindowService, WindowContainerService], imports: [InlineAIPromptComponent] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: InlineAIPromptModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [...KENDO_INLINEAIPROMPT],
                    imports: [...KENDO_INLINEAIPROMPT],
                    providers: [IconsService, PopupService, ResizeBatchService, DialogContainerService, DialogService, WindowService, WindowContainerService]
                }]
        }] });

/**
 * Provides a service for opening and configuring the Inline AI Prompt component dynamically.
 *
 * @example
 * ```ts
 * export class DemoComponent {
 *   @ViewChild('anchor', { read: ElementRef }) anchor: ElementRef;
 *   constructor(private promptService: InlineAIPromptService) {}
 *
 *   open(): void {
 *     this.promptService.open({
 *       popupSettings: { anchor: this.anchor },
 *       placeholder: 'Enter your prompt...'
 *     });
 *   }
 * }
 * ```
 * ```html
 * <button #anchor (click)="open()">Ask AI</button>
 * ```
 */
class InlineAIPromptService {
    popupService;
    /**
     * @hidden
     */
    constructor(popupService) {
        this.popupService = popupService;
    }
    /**
     * Opens an Inline AI Prompt component in a popup. The popup appears near the specified anchor element or at the provided offset coordinates.
     *
     * @param {InlineAIPromptSettings} options The options for the InlineAIPromptComponent.
     * @returns {PopupRef} A reference to the popup.
     */
    open(options) {
        const popupSettings = { ...defaultPopupSettings, ...options?.popupSettings };
        const popupRef = this.popupService.open({
            ...(options?.popupSettings?.anchor && { anchor: options.popupSettings.anchor }),
            popupClass: 'k-prompt-popup',
            ...popupSettings,
            content: InlineAIPromptContentComponent,
        });
        const promptInstance = popupRef.content?.instance;
        if (promptInstance) {
            const popupViewContainer = popupRef.popup.injector.get(ViewContainerRef);
            promptInstance.appendTo = popupViewContainer;
            promptInstance.popupElement = popupRef.popupElement;
            this.projectComponentInputs(promptInstance, options);
            if (promptInstance.close) {
                promptInstance.close.subscribe(() => {
                    popupRef.close();
                });
            }
            if (popupRef.content.changeDetectorRef) {
                popupRef.content.changeDetectorRef.detectChanges();
            }
        }
        return popupRef;
    }
    /**
     * Projects the input options onto the component instance.
     */
    projectComponentInputs(component, options) {
        if (!options) {
            return component;
        }
        Object.getOwnPropertyNames(options)
            .forEach((prop) => {
            component[prop] = options[prop];
        });
        return component;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: InlineAIPromptService, deps: [{ token: i1$2.PopupService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: InlineAIPromptService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: InlineAIPromptService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: () => [{ type: i1$2.PopupService }] });

/**
 * Defines the settings for opening an Inline AI Prompt through the `InlineAIPromptService`.
 */
class InlineAIPromptSettings {
    /**
     * The settings for the Inline AI Prompt Popup.
     */
    popupSettings;
    /**
     * Sets the width of the component.
     * Accepts a number for pixels or a string for other units, for example, `50%`.
     */
    width;
    /**
     * Sets the maximum height of the component.
     * Accepts a number for pixels or a string for other units, for example, `50%`.
     */
    maxHeight;
    /**
     * Sets the value of the Inline AI Prompt TextArea.
     */
    promptValue;
    /**
     * Sets the placeholder text for the Inline AI Prompt TextArea.
     */
    placeholder;
    /**
     * Sets the action buttons for the output card.
     */
    outputActions;
    /**
     * Sets the commands for the Inline AI Prompt TextArea prefix.
     */
    promptCommands;
    /**
     * Sets the prompt output to display.
     */
    promptOutput;
    /**
     * Controls the visibility and configuration of the Speech to Text button.
     */
    enableSpeechToTextButton;
    /**
     * Sets the template for the output content. If not provided, uses the default output template.
     */
    outputTemplate;
    /**
     * If `true`, the send button turns into a stop button.
     */
    streaming;
    /**
     * Sets the titles of the buttons shown in the Inline AI Prompt. Use for localization.
     */
    messages;
}

/**
 * Generated bundle index. Do not edit.
 */

export { AIPromptComponent, AIPromptCustomMessagesComponent, AIPromptModule, AIPromptOutputBodyTemplateDirective, AIPromptOutputTemplateDirective, AIPromptToolbarActionsDirective, AIPromptToolbarFocusableDirective, AttachmentTemplateDirective, AuthorMessageContentTemplateDirective, AuthorMessageTemplateDirective, ChatComponent, ChatHeaderTemplateDirective, ChatMessageBoxTemplateDirective, ChatModule, ChatStatusTemplateDirective, ChatSuggestionTemplateDirective, ChatTimestampTemplateDirective, ChatUserStatusTemplateDirective, CommandViewComponent, ConversationalUIModule, CustomMessagesComponent, CustomViewComponent, ExecuteActionEvent, HeroCardComponent, InlineAIPromptComponent, InlineAIPromptCustomMessagesComponent, InlineAIPromptModule, InlineAIPromptOutputTemplateDirective, InlineAIPromptService, InlineAIPromptSettings, KENDO_AIPROMPT, KENDO_CHAT, KENDO_CONVERSATIONALUI, KENDO_INLINEAIPROMPT, MessageContentTemplateDirective, MessageTemplateDirective, NoDataTemplateDirective, OutputViewComponent, PromptViewComponent, ReceiverMessageContentTemplateDirective, ReceiverMessageTemplateDirective, SendMessageEvent };

