/**-----------------------------------------------------------------------------------------
* Copyright © 2026 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import * as i0 from '@angular/core';
import { EventEmitter, Injectable, SecurityContext, InjectionToken, Optional, Inject, Input, SkipSelf, Directive, isDevMode, QueryList, ContentChildren, ContentChild, Component, forwardRef, Host, Output, HostBinding, Pipe, TemplateRef, ViewChild, ViewChildren, ChangeDetectionStrategy, Self, NgZone, HostListener, ElementRef, ViewContainerRef, ViewEncapsulation, inject, Injector, NgModule } from '@angular/core';
import { merge, of, Subject, zip as zip$1, from, Subscription, interval, fromEvent, Observable, BehaviorSubject } from 'rxjs';
import * as i1$3 from '@progress/kendo-angular-common';
import { isDocumentAvailable, Keys, hasClasses as hasClasses$1, isPresent as isPresent$1, normalizeKeys, anyChanged, TemplateContextDirective, DraggableDirective, EventsOutsideAngularDirective, replaceMessagePlaceholder, isChanged as isChanged$1, KendoInput, guid, areObjectsEqual, PrefixTemplateDirective, closest as closest$1, hasObservers, ResizeSensorComponent, isFirefox, firefoxMaxHeight, closestInScope as closestInScope$1, isFocusable as isFocusable$1, getLicenseMessage, shouldShowValidationUI, WatermarkOverlayComponent, PreventableEvent as PreventableEvent$1, ResizeBatchService } from '@progress/kendo-angular-common';
import * as i1 from '@angular/platform-browser';
import * as i1$1 from '@progress/kendo-angular-icons';
import { IconWrapperComponent, IconsService, KENDO_ICONS } from '@progress/kendo-angular-icons';
import { plusIcon, cancelIcon, lockIcon, unlockIcon, caretAltDownIcon, caretAltRightIcon, caretAltLeftIcon, arrowLeftIcon, arrowRightIcon, sortDescSmallIcon, sortAscSmallIcon, filterClearIcon, filterIcon, searchIcon, checkIcon, arrowRotateCcwIcon, columnsIcon, sparklesIcon, filePdfIcon, fileExcelIcon, trashIcon, saveIcon, pencilIcon, chevronUpIcon, chevronDownIcon, chevronRightIcon, displayInlineFlexIcon, maxWidthIcon, stickIcon, unstickIcon, setColumnPositionIcon, slidersIcon, moreVerticalIcon, reorderIcon, minusIcon, insertMiddleIcon, xIcon, xCircleIcon, plusCircleIcon, chevronLeftIcon, undoIcon, redoIcon, arrowsSwapIcon, groupIcon, tableWizardIcon } from '@progress/kendo-svg-icons';
import { switchMap, take, map, filter, takeUntil, switchMapTo, delay, tap, throttleTime, debounceTime, distinctUntilChanged, skip, auditTime, bufferCount, flatMap } from 'rxjs/operators';
import * as i1$2 from '@progress/kendo-angular-l10n';
import { ComponentMessages, LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';
import * as i53 from '@progress/kendo-angular-pager';
import { PagerTemplateDirective, PagerContextService, PagerNavigationService, KENDO_PAGER } from '@progress/kendo-angular-pager';
import { orderBy, isCompositeFilterDescriptor, filterBy, groupBy, process } from '@progress/kendo-data-query';
import { NgTemplateOutlet, NgClass, NgStyle, KeyValuePipe } from '@angular/common';
import { getter } from '@progress/kendo-common';
import * as i1$4 from '@progress/kendo-angular-intl';
import { parseDate } from '@progress/kendo-angular-intl';
import * as i2 from '@progress/kendo-angular-popup';
import { PopupService } from '@progress/kendo-angular-popup';
import * as i1$6 from '@progress/kendo-angular-buttons';
import { ChipListComponent, ChipComponent, ButtonComponent, Button, KENDO_BUTTON, ButtonDirective } from '@progress/kendo-angular-buttons';
import * as i1$5 from '@progress/kendo-angular-dropdowns';
import { DropDownListComponent, AutoCompleteComponent } from '@progress/kendo-angular-dropdowns';
import * as i2$2 from '@angular/forms';
import { NG_VALUE_ACCESSOR, FormsModule, ReactiveFormsModule, FormControl, FormGroup } from '@angular/forms';
import * as i2$1 from '@progress/kendo-angular-utils';
import { DragTargetContainerDirective, DropTargetContainerDirective } from '@progress/kendo-angular-utils';
import * as i4 from '@progress/kendo-angular-inputs';
import { TextBoxComponent, NumericTextBoxComponent, NumericTextBoxCustomMessagesComponent, RadioButtonComponent, CheckBoxComponent, TextBoxPrefixTemplateDirective, KENDO_FORMFIELD, KENDO_TEXTBOX, KENDO_NUMERICTEXTBOX, KENDO_CHECKBOX } from '@progress/kendo-angular-inputs';
import * as i5 from '@progress/kendo-angular-dateinputs';
import { DatePickerComponent, DatePickerCustomMessagesComponent, KENDO_DATEPICKER, CalendarDOMService, CenturyViewService, DecadeViewService, MonthViewService, YearViewService, NavigationService as NavigationService$1 } from '@progress/kendo-angular-dateinputs';
import * as i54 from '@progress/kendo-angular-toolbar';
import { ToolBarToolComponent, KENDO_TOOLBAR } from '@progress/kendo-angular-toolbar';
import { trigger, state, transition, style, animate } from '@angular/animations';
import { TabStripComponent, TabStripTabComponent, TabTitleDirective, TabContentDirective } from '@progress/kendo-angular-layout';
import { saveAs } from '@progress/kendo-file-saver';
import * as i5$1 from '@progress/kendo-angular-excel-export';
import { workbookOptions, toDataURL, ColumnBase as ColumnBase$1, ColumnComponent as ColumnComponent$1, ColumnGroupComponent as ColumnGroupComponent$1, FooterTemplateDirective as FooterTemplateDirective$1, GroupFooterTemplateDirective as GroupFooterTemplateDirective$1, GroupHeaderColumnTemplateDirective as GroupHeaderColumnTemplateDirective$1, GroupHeaderTemplateDirective as GroupHeaderTemplateDirective$1 } from '@progress/kendo-angular-excel-export';
import { PDFExportMarginComponent, PDFExportTemplateDirective, PDFExportComponent } from '@progress/kendo-angular-pdf-export';
import { validatePackage } from '@progress/kendo-licensing';
import { ActionSheetComponent, ActionSheetViewComponent, ActionSheetHeaderTemplateDirective, ActionSheetContentTemplateDirective, ActionSheetFooterTemplateDirective } from '@progress/kendo-angular-navigation';
import * as i3 from '@progress/kendo-angular-label';
import { KENDO_LABELS, LabelDirective } from '@progress/kendo-angular-label';
import * as i1$7 from '@progress/kendo-angular-dialog';
import { DialogContentBase, DialogActionsComponent, DialogService, DialogContainerService, WindowService, WindowContainerService } from '@progress/kendo-angular-dialog';
import { AIPromptComponent, AIPromptCustomMessagesComponent, PromptViewComponent, OutputViewComponent, AIPromptOutputTemplateDirective, AIPromptOutputBodyTemplateDirective } from '@progress/kendo-angular-conversational-ui';
import * as i1$8 from '@angular/common/http';
import { HttpHeaders, HttpRequest } from '@angular/common/http';

/* eslint-disable  no-bitwise */
/**
 * @hidden
 */
const append = (element) => {
    if (!isDocumentAvailable()) {
        return;
    }
    let appended = false;
    return () => {
        if (!appended) {
            document.body.appendChild(element);
            appended = true;
        }
        return element;
    };
};
/**
 * @hidden
 */
const getDocument$1 = element => element.ownerDocument.documentElement;
/**
 * @hidden
 */
const getWindow$1 = element => element.ownerDocument.defaultView;
/**
 * @hidden
 */
const offset = element => {
    const { clientTop, clientLeft } = getDocument$1(element);
    const { pageYOffset, pageXOffset } = getWindow$1(element);
    const { top, left } = element.getBoundingClientRect();
    return {
        top: top + pageYOffset - clientTop,
        left: left + pageXOffset - clientLeft
    };
};
/**
 * @hidden
 * If the target is before the draggable element, returns `true`.
 *
 * DOCUMENT_POSITION_FOLLOWING = 4
 */
const isTargetBefore = (draggable, target) => (target.compareDocumentPosition(draggable) & 4) !== 0;
/**
 * @hidden
 * If the container and the element are the same
 * or if the container holds (contains) the element, returns `true`.
 *
 * DOCUMENT_POSITION_CONTAINED_BY = 16
 */
const contains$2 = (element, container) => element === container ||
    (container.compareDocumentPosition(element) & 16) !== 0;
/**
 * @hidden
 */
const position = (target, before) => {
    const targetRect = offset(target);
    const { offsetWidth, offsetHeight } = target;
    const left = targetRect.left + (before ? 0 : offsetWidth);
    const top = targetRect.top;
    const height = offsetHeight;
    return { left, top, height };
};

/**
 * @hidden
 */
class DragAndDropService {
    changes = new EventEmitter();
    register = [];
    lastTarget = null;
    add(target) {
        this.register.push(target);
    }
    remove(target) {
        this.register = this.register.filter(current => current !== target);
    }
    notifyDrag(draggable, element, mouseEvent) {
        const target = this.targetFor(element);
        if (this.lastTarget === target) {
            return;
        }
        this.changes.next({
            draggable,
            mouseEvent,
            target: this.lastTarget,
            type: 'leave'
        });
        if (target) {
            this.changes.next({
                draggable,
                mouseEvent,
                target,
                type: 'enter'
            });
        }
        this.lastTarget = target;
    }
    notifyDrop(draggable, mouseEvent) {
        const target = draggable && draggable.element && this.targetFor(draggable.element.nativeElement);
        if (target && this.lastTarget === target) {
            this.lastTarget = null;
            return;
        }
        this.changes.next({
            draggable,
            mouseEvent,
            target: this.lastTarget,
            type: 'drop'
        });
        this.lastTarget = null;
    }
    targetFor(element) {
        const comparer = contains$2.bind(null, element);
        return this.register.find(({ element: { nativeElement } }) => comparer(nativeElement));
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DragAndDropService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DragAndDropService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DragAndDropService, decorators: [{
            type: Injectable
        }] });

const updateClass = (element, valid, svg) => {
    const icon = element.querySelector('.k-icon');
    if (svg) {
        const svg = icon.firstElementChild;
        svg.removeChild(svg.firstElementChild);
        const path = valid ? plusIcon.content : cancelIcon.content;
        icon.firstElementChild.innerHTML = path + icon.firstElementChild.innerHTML;
    }
    icon.setAttribute('class', icon.getAttribute('class').replace(/(plus|cancel)/, valid ? 'plus' : 'cancel'));
};
const updateLock = (element, locked = null, svg) => {
    const icon = element.querySelectorAll('.k-icon')[1];
    const value = locked === null ? '' : (locked ? `k${svg ? '-svg' : ''}-i-lock` : `k${svg ? '-svg' : ''}-i-unlock`);
    if (svg) {
        icon.setAttribute('class', icon.getAttribute('class').replace(/(k-svg-i-unlock|k-svg-i-lock)/, '').trim() + ` ${value}`);
        icon.firstElementChild.innerHTML = locked ? lockIcon.content : unlockIcon.content;
    }
    else {
        icon.setAttribute('class', icon.getAttribute('class').replace(/(k-i-unlock|k-i-lock)/, '').trim() + ` ${value}`);
    }
};
const decorate = (element) => {
    element.className = 'k-header k-drag-clue';
    element.style.position = 'absolute';
    element.style.zIndex = '20000';
};
const svgIconsMarkup = (viewBox, content, safeTitle) => `
    <span class="k-icon k-svg-icon k-drag-status k-svg-i-cancel">
        <svg
            xmlns="http://www.w3.org/2000/svg"
            xmlns:xlink="http://www.w3.org/1999/xlink"
            viewBox="${viewBox}"
            aria-hidden="true">
            ${content}
        </svg>
        <span class="k-icon k-svg-icon k-icon-modifier">
            <svg
                xmlns="http://www.w3.org/2000/svg"
                xmlns:xlink="http://www.w3.org/1999/xlink"
                viewBox="${viewBox}"
                aria-hidden="true">
            </svg>
        </span>
    </span>
    ${safeTitle}`;
const fontIconsMarkup = (safeTitle) => `
    <span class="k-icon k-font-icon k-drag-status k-i-cancel">
        <span class="k-icon k-font-icon k-icon-modifier"></span>
    </span>
    ${safeTitle}`;
/**
 * @hidden
 */
class DragHintService {
    sanitizer;
    iconsService;
    dom;
    cancelIcon = cancelIcon;
    constructor(sanitizer, iconsService) {
        this.sanitizer = sanitizer;
        this.iconsService = iconsService;
    }
    ngOnDestroy() {
        this.remove();
    }
    create(title) {
        if (!isDocumentAvailable()) {
            return;
        }
        this.dom = document.createElement("div");
        decorate(this.dom);
        const sanitized = this.sanitizer.sanitize(SecurityContext.HTML, title);
        const safeTitle = sanitized?.replace(/<[^>]*>/g, '');
        const innerHtml = this.isSVG ?
            svgIconsMarkup(this.cancelIcon.viewBox, this.cancelIcon.content, safeTitle) :
            fontIconsMarkup(safeTitle);
        this.dom.innerHTML = innerHtml;
    }
    attach() {
        return append(this.dom);
    }
    remove() {
        if (this.dom && this.dom.parentNode) {
            (function (el) {
                setTimeout(() => {
                    if (isDocumentAvailable()) {
                        document.body.removeChild(el);
                    }
                });
            })(this.dom); // hack for IE + pointer events!
            this.dom = null;
        }
    }
    show() {
        this.dom.style.display = "";
    }
    hide() {
        this.dom.style.display = "none";
    }
    enable() {
        updateClass(this.dom, true, this.isSVG);
    }
    disable() {
        updateClass(this.dom, false, this.isSVG);
    }
    removeLock() {
        updateLock(this.dom, false, this.isSVG);
    }
    toggleLock(locked) {
        updateLock(this.dom, locked, this.isSVG);
    }
    move(move) {
        this.dom.style.top = move.pageY + 'px';
        this.dom.style.left = move.pageX + 'px';
    }
    get isSVG() {
        return (this.iconsService.iconSettings?.type || this.iconsService.changes.value.type) === 'svg';
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DragHintService, deps: [{ token: i1.DomSanitizer }, { token: i1$1.IconsService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DragHintService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DragHintService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: i1.DomSanitizer }, { type: i1$1.IconsService }] });

/**
 * @hidden
 */
class DropCueService {
    dom;
    create() {
        if (!isDocumentAvailable()) {
            return;
        }
        this.dom = document.createElement("div");
        this.dom.className = 'k-grouping-dropclue';
        this.hide();
    }
    attach() {
        return append(this.dom);
    }
    remove() {
        if (this.dom && this.dom.parentElement) {
            document.body.removeChild(this.dom);
            this.dom = null;
        }
    }
    hide() {
        this.dom.style.display = "none";
    }
    position({ left, top, height }) {
        this.dom.style.display = 'block';
        this.dom.style.height = height + 'px';
        this.dom.style.top = top + 'px';
        const width = this.dom.offsetWidth / 2;
        this.dom.style.left = left - width + 'px';
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DropCueService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DropCueService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DropCueService, decorators: [{
            type: Injectable
        }] });

const EMPTY_REGEX = /^\s*$/;
/**
 * @hidden
 */
const isPresent = (value) => value !== null && value !== undefined;
/**
 * @hidden
 */
const isBlank = (value) => value === null || value === undefined;
/**
 * @hidden
 */
const isArray = (value) => Array.isArray(value);
/**
 * @hidden
 */
const isTruthy = (value) => !!value;
/**
 * @hidden
 */
const isNullOrEmptyString = (value) => isBlank(value) || EMPTY_REGEX.test(value);
/**
 * @hidden
 */
const observe = (list) => merge(of(list), list.changes);
/**
 * @hidden
 */
const isUniversal = () => typeof document === 'undefined';
/**
 * @hidden
 */
const isString = (value) => typeof value === 'string';
/**
 * @hidden
 */
const isNumber = (value) => typeof value === "number" && !isNaN(value);
/**
 * @hidden
 */
const extractFormat = (format) => {
    if (isString(format) && !isNullOrEmptyString(format) && format.startsWith('{0:')) {
        return format.slice(3, format.length - 1);
    }
    return format;
};
/**
 * @hidden
 */
const not = (fn) => (...args) => !fn(...args);
/**
 * @hidden
 */
const or = (...conditions) => (value) => conditions.reduce((acc, x) => acc || x(value), false);
/**
 * @hidden
 */
const and = (...conditions) => (value) => conditions.reduce((acc, x) => acc && x(value), true);
/**
 * @hidden
 */
const Skip = new InjectionToken("Skip");
/**
 * @hidden
 */
const createPromise = () => {
    let resolveFn, rejectFn;
    const promise = new Promise((resolve, reject) => {
        resolveFn = (data) => {
            resolve(data);
            return promise;
        };
        rejectFn = (data) => {
            reject(data);
            return promise;
        };
    });
    promise.resolve = resolveFn;
    promise.reject = rejectFn;
    return promise;
};
/** @hidden */
const iterator = getIterator$1();
// TODO: Move to kendo-common
function getIterator$1() {
    if (typeof Symbol === 'function' && Symbol.iterator) {
        return Symbol.iterator;
    }
    const keys = Object.getOwnPropertyNames(Map.prototype);
    const proto = Map.prototype;
    for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (key !== 'entries' && key !== 'size' && proto[key] === proto.entries) {
            return key;
        }
    }
}
const FRAME_DURATION = 1000 / 60;
const wnd = typeof window !== 'undefined' ? window : {};
/** @hidden */
const requestAnimationFrame = wnd.requestAnimationFrame || wnd.msRequestAnimationFrame || (callback => setTimeout(callback, FRAME_DURATION));
/** @hidden */
const cancelAnimationFrame = wnd.cancelAnimationFrame || wnd.msCancelRequestAnimationFrame || clearTimeout;
/**
 * @hidden
 */
const nodesToArray = (nodes) => [].slice.call(nodes);
/**
 * @hidden
 */
const recursiveFlatMap = (item) => isGroupResult(item) ? item.items.flatMap(recursiveFlatMap) : [{ ...item }];
const mapColumnItemState = (c) => ({ id: c.id, width: c.width, hidden: c.hidden, locked: c.locked, sticky: c.sticky, orderIndex: c.orderIndex });
/**
 * @hidden
 */
const updateColumnFromState = (columnState, c) => {
    Object.keys(columnState).forEach((key) => c[key] = columnState[key]);
};
/**
 * @hidden
 */
const recursiveColumnsFlatMap = (item) => (item.isColumnGroup || item.isSpanColumn) ?
    [mapColumnItemState(item), ...item.children.toArray().flatMap(recursiveColumnsFlatMap)] :
    [mapColumnItemState(item)];
/**
 * @hidden
 */
const isGroupResult = (obj) => {
    return 'aggregates' in obj && 'items' in obj && 'field' in obj && 'value' in obj;
};
/**
 * @hidden
 */
const roundDown = (value) => Math.floor(value * 100) / 100;
/**
 * @hidden
 */
const defaultCellRowSpan = (row, column, data) => {
    const field = column.field;
    let rowspan = 1;
    const rowIndex = row.index;
    if (!data[0].items) {
        //If no groups are present.
        rowspan = findRowSpan(data, rowIndex, field);
    }
    else {
        // If groups are present.
        const group = row.dataItem.group;
        if (field === group.data.field) {
            // Set the rowspan to the number of data items in the same group if the column containing the current row matches the grouping field.
            rowspan = group.data.items.length;
        }
        else {
            //The index of the current row in the group.
            const rowIndex = row.dataItem.group.data.items.indexOf(row.dataItem.data);
            const groupItems = row.dataItem.group.data.items;
            rowspan = findRowSpan(groupItems, rowIndex, field);
        }
    }
    return rowspan;
};
/**
 * @hidden
 * Returns the rowspan number based on the provided data array, index of the item, and field that is checked.
 */
const findRowSpan = (data, index, field) => {
    let rowspan = 1;
    if (typeof data[index][field]?.getTime === 'function') {
        while (data[index][field].getTime() === data[index + 1]?.[field].getTime()) {
            rowspan++;
            index++;
        }
    }
    else {
        while (data[index][field] === data[index + 1]?.[field]) {
            rowspan++;
            index++;
        }
    }
    return rowspan;
};
/**
 * @hidden
 * Determines whether selection of multiple ranges is enabled in the selectable settings.
 */
const isMultipleRangesEnabled = (selectableSettings) => {
    return selectableSettings &&
        typeof selectableSettings === 'object' &&
        selectableSettings.selectable.multipleRanges;
};
/**
 * @hidden
 * Calculates the height of a table row by inserting a temporary row into the table body when the `rowHeight` option is not set.
 */
const calcRowHeight = (tableBody) => {
    let result = 0;
    if (!isDocumentAvailable()) {
        return result;
    }
    if (tableBody) {
        const row = tableBody.insertRow(0);
        const cell = row.insertCell(0);
        cell.textContent = '&nbsp;';
        result = row.getBoundingClientRect().height;
        tableBody.deleteRow(0);
    }
    return result;
};

/**
 * @hidden
 */
const FOCUS_ROOT_ACTIVE = new InjectionToken('focus-root-initial-active-state');
/**
 * @hidden
 */
class FocusRoot {
    active;
    groups = new Set();
    constructor(active = false) {
        this.active = active;
    }
    registerGroup(group) {
        if (this.active) {
            this.groups.add(group);
        }
    }
    unregisterGroup(group) {
        if (this.active) {
            this.groups.delete(group);
        }
    }
    activate() {
        if (this.active) {
            this.groups.forEach(f => f.activate());
        }
    }
    deactivate() {
        if (this.active) {
            this.groups.forEach(f => f.deactivate());
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FocusRoot, deps: [{ token: FOCUS_ROOT_ACTIVE, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FocusRoot });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FocusRoot, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [FOCUS_ROOT_ACTIVE]
                }] }] });

const focusableRegex = /^(?:a|input|select|option|textarea|button|object)$/i;
const NODE_NAME_PREDICATES = {};
const toClassList = (classNames) => String(classNames).trim().split(' ');
/**
 * @hidden
 */
const hasClasses = (element, classNames) => {
    const namesList = toClassList(classNames);
    return Boolean(toClassList(element.className).find((className) => namesList.indexOf(className) >= 0));
};
/**
 * @hidden
 */
const matchesClasses = (classNames) => (element) => hasClasses(element, classNames);
/**
 * @hidden
 */
const matchesNodeName = (nodeName) => {
    if (!NODE_NAME_PREDICATES[nodeName]) {
        NODE_NAME_PREDICATES[nodeName] = (element) => String(element.nodeName).toLowerCase() === nodeName.toLowerCase();
    }
    return NODE_NAME_PREDICATES[nodeName];
};
/**
 * @hidden
 */
const closest = (node, predicate) => {
    while (node && !predicate(node)) {
        node = node.parentNode;
    }
    return node;
};
/**
 * @hidden
 */
const closestInScope = (node, predicate, scope) => {
    while (node && node !== scope && !predicate(node)) {
        node = node.parentNode;
    }
    if (node !== scope) {
        return node;
    }
};
/**
 * @hidden
 */
const contains$1 = (parent, node, matchSelf = false) => {
    const outside = !closest(node, (child) => child === parent);
    if (outside) {
        return false;
    }
    const el = closest(node, (child) => child === node);
    return el && (matchSelf || el !== parent);
};
/**
 * @hidden
 */
const isVisible = (element) => {
    if (!isDocumentAvailable()) {
        return;
    }
    const rect = element.getBoundingClientRect();
    const hasSize = rect.width > 0 && rect.height > 0;
    const hasPosition = rect.x !== 0 && rect.y !== 0;
    // Elements can have zero size due to styling, but they will still count as visible.
    // For example, the selection checkbox has no size, but is made visible through styling.
    return (hasSize || hasPosition) && window.getComputedStyle(element).visibility !== 'hidden';
};
/**
 * @hidden
 */
const isFocusable = (element) => {
    if (!element.tagName) {
        return false;
    }
    const tagName = element.tagName.toLowerCase();
    const hasTabIndex = Boolean(element.getAttribute('tabIndex'));
    const focusable = !element.disabled && focusableRegex.test(tagName);
    return focusable || hasTabIndex;
};
/**
 * @hidden
 */
const isFocusableWithTabKey = (element, checkVisibility = true) => {
    if (!isFocusable(element)) {
        return false;
    }
    const visible = !checkVisibility || isVisible(element);
    const ariaHidden = element.getAttribute('aria-hidden') === 'true';
    const tabIndex = element.getAttribute('tabIndex');
    return visible && !ariaHidden && tabIndex !== '-1';
};
/**
 * @hidden
 */
const findElement = (node, predicate, matchSelf = true) => {
    if (!node) {
        return;
    }
    if (matchSelf && predicate(node)) {
        return node;
    }
    node = node.firstChild;
    while (node) {
        if (node.nodeType === 1) {
            const element = findElement(node, predicate);
            if (element) {
                return element;
            }
        }
        node = node.nextSibling;
    }
};
/**
 * @hidden
 */
const findLastElement = (node, predicate, matchSelf = true) => {
    let last = null;
    findElement(node, (node) => {
        if (predicate(node)) {
            last = node;
        }
        return false;
    }, matchSelf);
    return last;
};
/**
 * @hidden
 */
const findFocusable = (element, checkVisibility = true) => {
    return findElement(element, (node) => isFocusableWithTabKey(node, checkVisibility));
};
/**
 * @hidden
 */
const findFocusableChild = (element, checkVisibility = true) => {
    return findElement(element, (node) => isFocusableWithTabKey(node, checkVisibility), false);
};
/**
 * @hidden
 */
const findLastFocusableChild = (element, checkVisibility = true) => {
    return findLastElement(element, (node) => isFocusableWithTabKey(node, checkVisibility), false);
};
/**
 * @hidden
 */
function rtlScrollPosition(position, element, initial) {
    let result = position;
    if (initial < 0) {
        result = -position;
    }
    else if (initial > 0) {
        result = element.scrollWidth - element.offsetWidth - position;
    }
    return result;
}

const isButton = matchesNodeName('button');
const isInputTag = matchesNodeName('input');
const isKendoInputTag = matchesNodeName('kendo-checkbox') || matchesNodeName('kendo-textbox');
const isAnchorTag = matchesNodeName('a');
const navigableRegex = /(button|checkbox|color|file|radio|reset|submit)/i;
const isNavigableInput = element => isInputTag(element) && navigableRegex.test(element.type);
const isAnchor = element => isAnchorTag(element) && element.hasAttribute('href');
const isNavigable = element => !element.disabled && (isButton(element) || isNavigableInput(element) || isKendoInputTag(element) || isAnchor(element));
/**
 * @hidden
 */
class DefaultFocusableElement {
    renderer;
    get enabled() {
        return this.focusable && !this.focusable.disabled;
    }
    get visible() {
        return this.focusable && isVisible(this.focusable);
    }
    element;
    focusable;
    constructor(host, renderer) {
        this.renderer = renderer;
        this.element = host.nativeElement;
        this.focusable = findFocusable(this.element, false) || this.element;
    }
    isNavigable() {
        return this.canFocus() && isNavigable(this.element);
    }
    toggle(active) {
        this.renderer.setAttribute(this.focusable, 'tabIndex', active ? '0' : '-1');
    }
    focus() {
        if (this.focusable) {
            this.focusable.focus();
        }
    }
    canFocus() {
        return this.visible && this.enabled;
    }
    hasFocus() {
        return isDocumentAvailable() && document.activeElement !== this.element && closest(document.activeElement, e => e === this.element);
    }
}

/**
 * @hidden
 */
const CELL_CONTEXT = new InjectionToken('grid-cell-context');
/**
 * @hidden
 */
const EMPTY_CELL_CONTEXT = {};

/**
 * @hidden
 */
class GridToolbarNavigationService {
    renderer;
    toolbarElement;
    navigableElements = [];
    currentActiveIndex = 0;
    defaultFocusableSelector = `
        [kendogridtoolbarfocusable],
        [kendogridaddcommand],
        [kendogridcancelcommand],
        [kendogrideditcommand],
        [kendogridremovecommand],
        [kendogridsavecommand],
        [kendogridexcelcommand],
        [kendogridpdfcommand]
    `;
    constructor(renderer) {
        this.renderer = renderer;
    }
    notify() {
        // ensure focusable elements are in the same order as in the DOM
        this.navigableElements = this.findNavigableElements();
        this.currentActiveIndex = 0;
        this.updateFocus();
    }
    findNavigableElements() {
        return Array.from(this.toolbarElement.querySelectorAll(this.defaultFocusableSelector) || []);
    }
    focus() {
        this.navigableElements[this.currentActiveIndex]?.focus();
    }
    updateFocus() {
        if (!this.navigableElements.length) {
            return;
        }
        this.navigableElements.forEach(el => {
            this.renderer.setAttribute(el, 'tabindex', '-1');
        });
        this.renderer.setAttribute(this.navigableElements[this.currentActiveIndex], 'tabindex', '0');
        if (isDocumentAvailable() && document.activeElement.closest('.k-toolbar')) {
            this.navigableElements[this.currentActiveIndex].focus();
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GridToolbarNavigationService, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GridToolbarNavigationService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GridToolbarNavigationService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: i0.Renderer2 }] });

/**
 * @hidden
 *
 * The Context service is used to provide common
 * services and DI tokens for a Grid instance.
 *
 * This keeps the constructor parameters stable
 * and a avoids dependency cycles between components.
 */
class ContextService {
    renderer;
    localization;
    grid;
    topToolbarNavigation;
    bottomToolbarNavigation;
    navigable;
    scroller;
    dataBindingDirective;
    highlightDirective;
    excelComponent;
    pdfComponent;
    constructor(renderer, localization) {
        this.renderer = renderer;
        this.localization = localization;
        this.topToolbarNavigation = new GridToolbarNavigationService(this.renderer);
        this.bottomToolbarNavigation = new GridToolbarNavigationService(this.renderer);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ContextService, deps: [{ token: i0.Renderer2 }, { token: i1$2.LocalizationService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ContextService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ContextService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: i0.Renderer2 }, { type: i1$2.LocalizationService }] });

/**
 * A directive that controls how focusable elements receive
 * focus in a navigable Grid. [See example]({% slug keyboard_navigation_grid %}).
 *
 * @example
 * ```html
 * <kendo-grid [data]="data" [navigable]="true">
 *    <kendo-grid-column>
 *       <ng-template kendoGridCellTemplate let-dataItem>
 *          <!-- The first focusable element is focused when you press Enter on the cell. -->
 *          <input type="text" kendoGridFocusable [value]="dataItem.ProductName" style="margin-right: 8px;" />
 *          <button kendoGridFocusable>Update</button>
 *       </ng-template>
 *    </kendo-grid-column>
 * </kendo-grid>
 * ```
 * @remarks
 * Applied to: {@link ButtonComponent}, {@link TextBoxComponent}, {@link NumericTextBoxComponent}, {@link DateInputComponent}, {@link DatePickerComponent}, {@link DateTimePicker}, {@link TextAreaComponent}, {@link ColorPickerComponent}, {@link DropDownListComponent}, {@link ComboBoxComponent}, {@link AutoCompleteComponent}.
 */
class FocusableDirective {
    cellContext;
    hostElement;
    renderer;
    ctx;
    active = true;
    group;
    element;
    _enabled = true;
    /**
     * @hidden
     */
    set enabled(value) {
        if (value === '') {
            value = true;
        }
        else {
            value = Boolean(value);
        }
        if (value !== this.enabled) {
            this._enabled = value;
            if (this.element) {
                this.element.toggle(this.active && value);
            }
        }
    }
    get enabled() {
        return this._enabled;
    }
    constructor(cellContext, hostElement, renderer, ctx) {
        this.cellContext = cellContext;
        this.hostElement = hostElement;
        this.renderer = renderer;
        this.ctx = ctx;
        if (this.cellContext) {
            this.group = this.cellContext.focusGroup;
        }
        if (this.group) {
            this.group.registerElement(this);
        }
    }
    ngAfterViewInit() {
        if (!this.element && this.ctx.navigable) {
            this.element = new DefaultFocusableElement(this.hostElement, this.renderer);
        }
        if (this.group && this.element) {
            this.toggle(this.group.isActive);
        }
    }
    ngOnDestroy() {
        if (this.group) {
            this.group.unregisterElement(this);
        }
    }
    /**
     * @hidden
     */
    toggle(active) {
        if (this.element && active !== this.active) {
            this.element.toggle(this.enabled && active);
            this.active = active;
        }
    }
    /**
     * @hidden
     */
    canFocus() {
        return this.enabled && this.element && this.element.canFocus();
    }
    /**
     * @hidden
     */
    isNavigable() {
        return this.enabled && this.element && this.element.isNavigable();
    }
    /**
     * @hidden
     */
    focus() {
        if (this.enabled && this.element) {
            this.element.focus();
        }
    }
    /**
     * @hidden
     */
    hasFocus() {
        return this.enabled && this.element && this.element.hasFocus();
    }
    /**
     * @hidden
     */
    registerElement(element) {
        this.element = element;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FocusableDirective, deps: [{ token: CELL_CONTEXT, optional: true, skipSelf: true }, { token: i0.ElementRef }, { token: i0.Renderer2 }, { token: ContextService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: FocusableDirective, isStandalone: true, selector: "[kendoGridFocusable],\n        [kendoGridEditCommand],\n        [kendoGridRemoveCommand],\n        [kendoGridSaveCommand],\n        [kendoGridCancelCommand],\n        [kendoGridSelectionCheckbox]\n    ", inputs: { enabled: ["kendoGridFocusable", "enabled"] }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FocusableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridFocusable]' + `,
        [kendoGridEditCommand],
        [kendoGridRemoveCommand],
        [kendoGridSaveCommand],
        [kendoGridCancelCommand],
        [kendoGridSelectionCheckbox]
    `,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [CELL_CONTEXT]
                }, {
                    type: SkipSelf
                }] }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: ContextService }], propDecorators: { enabled: [{
                type: Input,
                args: ['kendoGridFocusable']
            }] } });

/**
 * @hidden
 */
class GridFocusableElement {
    navigationService;
    constructor(navigationService) {
        this.navigationService = navigationService;
    }
    focus() {
        this.navigationService.focusCell();
    }
    toggle(active) {
        this.navigationService.toggle(active);
    }
    canFocus() {
        return true;
    }
    hasFocus() {
        return this.navigationService.hasFocus();
    }
    isNavigable() {
        return false;
    }
}

/**
 * @hidden
 */
class NavigationCursor {
    model;
    changes = new Subject();
    set metadata(value) {
        this._metadata = value;
        if (isPresent(value)) {
            const newActiveCol = value.hasDetailTemplate && !this.metadata.isStacked ? 1 : 0;
            const shouldChange = this.activeRow < value.headerRows && this.activeCol === 0;
            if (shouldChange && newActiveCol !== this.activeCol) {
                this.activeCol = newActiveCol;
                this.reset();
            }
        }
    }
    get metadata() {
        return this._metadata;
    }
    activeRow = 0;
    activeCol = 0;
    virtualCol = 0;
    virtualRow = 0;
    _metadata;
    get row() {
        return this.model.findRow(this.activeRow);
    }
    get cell() {
        const row = this.row;
        if (row) {
            return this.model.findCell(this.activeCol, row);
        }
    }
    get dataRowIndex() {
        const row = this.row;
        if (row) {
            return row.dataRowIndex;
        }
        return -1;
    }
    constructor(model) {
        this.model = model;
    }
    /**
     * Assumes and announces a new cursor position.
     */
    reset(rowIndex = this.activeRow, colIndex = this.activeCol, force = true) {
        if (this.activate(rowIndex, colIndex, force)) {
            this.virtualRow = rowIndex;
            this.virtualCol = colIndex;
        }
    }
    activate(rowIndex, colIndex, force) {
        if (!force && this.isActiveRange(rowIndex, colIndex)) {
            return false;
        }
        const prevColIndex = this.activeCol;
        const prevRowIndex = this.activeRow;
        this.activeCol = colIndex;
        this.activeRow = rowIndex;
        this.changes.next({
            colIndex,
            prevColIndex,
            prevRowIndex,
            rowIndex
        });
        return true;
    }
    isActiveRange(rowIndex, colIndex) {
        if (this.activeRow !== rowIndex) {
            return false;
        }
        const cell = this.cell;
        const { start, end } = this.model.cellRange(cell);
        return !cell || (start <= colIndex && colIndex <= end);
    }
    /**
     * Assumes a new cursor position without announcing it.
     */
    assume(rowIndex = this.activeRow, colIndex = this.activeCol) {
        this.virtualRow = rowIndex;
        this.virtualCol = colIndex;
        this.activeCol = colIndex;
        this.activeRow = rowIndex;
    }
    /**
     * Announces a current cursor position to subscribers.
     */
    announce() {
        this.changes.next({
            colIndex: this.activeCol,
            prevColIndex: this.activeCol,
            prevRowIndex: this.activeRow,
            rowIndex: this.activeRow
        });
    }
    activateVirtualCell(cell) {
        const rowRange = this.model.rowRange(cell);
        const cellRange = this.model.cellRange(cell);
        const activeCol = this.activeCol;
        const activeRow = this.activeRow;
        if (rowRange.start <= activeRow && activeRow <= rowRange.end &&
            cellRange.start <= activeCol && activeCol <= cellRange.end) {
            this.activeRow = cell.rowIndex;
            this.activeCol = cell.colIndex;
            return true;
        }
    }
    isActive(rowIndex, colIndex) {
        return this.activeCol === colIndex && this.activeRow === rowIndex;
    }
    moveUp(offset = 1) {
        return this.offsetRow(-offset);
    }
    moveDown(offset = 1) {
        return this.offsetRow(offset);
    }
    moveLeft(offset = 1) {
        return this.offsetCol(-offset);
    }
    moveRight(offset = 1) {
        return this.offsetCol(offset);
    }
    lastCellIndex(row) {
        return this.metadata.columns.leafColumnsToRender.length - 1 +
            (this.metadata.hasDetailTemplate && (!row || !row.groupItem) ? 1 : 0);
    }
    offsetCol(offset) {
        if (this.metadata.isStacked) {
            return false;
        }
        const prevRow = this.model.findRow(this.virtualRow);
        const lastIndex = this.lastCellIndex(prevRow);
        const virtualCol = this.virtualCol;
        this.virtualCol = Math.max(0, Math.min(virtualCol + offset, lastIndex));
        let nextColIndex = this.virtualCol;
        const nextRowIndex = this.virtualRow;
        let cell = this.model.findCell(this.virtualCol, prevRow);
        if (!cell && this.metadata.virtualColumns) {
            return this.activate(nextRowIndex, nextColIndex);
        }
        if (!cell && this.metadata.hasDetailTemplate) {
            this.virtualCol += 1;
            return false;
        }
        if (cell.colSpan > 1 && cell.colIndex <= virtualCol && virtualCol < cell.colIndex + cell.colSpan) {
            nextColIndex = offset > 0 ? Math.min(cell.colIndex + cell.colSpan, lastIndex) : Math.max(0, cell.colIndex + offset);
            const nextCell = this.model.findCell(nextColIndex, prevRow);
            if (!nextCell) {
                this.virtualCol = nextColIndex;
                return this.activate(cell.rowIndex, nextColIndex);
            }
            if (cell !== nextCell) {
                cell = nextCell;
                this.virtualCol = cell.colIndex;
            }
            else {
                this.virtualCol = virtualCol;
            }
            return this.activate(cell.rowIndex, this.virtualCol);
        }
        this.virtualCol = cell.colIndex;
        return this.activate(cell.rowIndex, cell.colIndex);
    }
    offsetRow(offset) {
        let nextColIndex = this.virtualCol;
        if (this.metadata && this.metadata.isVirtual) {
            const maxIndex = this.metadata.maxLogicalRowIndex;
            let nextIndex = Math.max(0, Math.min(this.activeRow + offset, maxIndex));
            if (this.metadata.hasDetailTemplate && !this.model.findRow(nextIndex)) {
                nextIndex = offset > 0 ? nextIndex + 1 : nextIndex - 1;
                nextIndex = Math.max(0, Math.min(nextIndex, maxIndex));
            }
            if (this.metadata.hasDetailTemplate && nextIndex === maxIndex) {
                if (this.model.lastRow.index !== maxIndex) {
                    // Don't attempt to navigate past the last collapsed row.
                    nextIndex--;
                }
            }
            const nextRow = this.model.findRow(nextIndex);
            if (nextRow) {
                // remove duplication
                let cell = this.model.findCell(this.virtualCol, nextRow);
                if (!cell) {
                    return;
                }
                if (cell.rowIndex <= this.virtualRow && offset > 0 && cell.rowSpan > 1) {
                    cell = this.model.findCell(this.virtualCol, this.model.findRow(cell.rowIndex + cell.rowSpan - 1 + offset));
                    if (!cell) {
                        return;
                    }
                }
                nextIndex = cell.rowIndex;
                nextColIndex = cell.colIndex;
            }
            this.virtualRow = nextIndex;
            return this.activate(nextIndex, nextColIndex);
        }
        const nextRow = this.model.findRow(this.virtualRow + offset) || this.model.nextRow(this.virtualRow, offset);
        if (!nextRow) {
            return false;
        }
        let cell = this.model.findCell(this.virtualCol, nextRow);
        if (cell && cell.rowIndex <= this.virtualRow && offset > 0 && cell.rowSpan > 1) { // spanned cell go to next
            const nextPos = cell.rowIndex + cell.rowSpan - 1 + offset;
            cell = this.model.findCell(this.virtualCol, this.model.findRow(nextPos));
        }
        if (!cell && (this.metadata.virtualColumns || this.metadata.hasDetailTemplate)) {
            return this.activate(this.virtualRow + offset, this.virtualCol);
        }
        if (!cell) {
            return false;
        }
        this.virtualRow = cell.rowIndex;
        return this.activate(this.virtualRow, cell.colIndex);
    }
}

/**
 * @hidden
 */
class ItemMap {
    count = 0;
    items = {};
    get first() {
        if (this.count > 0) {
            let result;
            this.forEach(item => {
                result = item;
                return true;
            });
            return result;
        }
    }
    get last() {
        if (this.count > 0) {
            const keys = Object.keys(this.items);
            return this.items[keys[keys.length - 1]];
        }
    }
    removeItem(key) {
        if (this.items[key]) {
            delete this.items[key];
            this.count--;
        }
    }
    setItem(key, item) {
        if (!this.items[key]) {
            this.count++;
        }
        this.items[key] = item;
    }
    getItem(key) {
        return this.items[key];
    }
    toArray() {
        const result = [];
        this.forEach(item => {
            result.push(item);
        });
        return result;
    }
    forEach(callback) {
        for (const key in this.items) {
            if (this.items.hasOwnProperty(key) && callback(this.items[key])) {
                return this.items[key];
            }
        }
    }
    find(callback) {
        return this.forEach(callback);
    }
}

/**
 * @hidden
 *
 * Contains information for the currently rendered rows and cells.
 */
class NavigationModel {
    rows = new ItemMap();
    get firstRow() {
        return this.rows.first;
    }
    get lastRow() {
        return this.rows.last;
    }
    registerCell(cell) {
        const row = this.rows.getItem(cell.logicalRowIndex);
        if (!row) {
            return;
        }
        const colIndex = cell.logicalColIndex;
        const modelCell = {
            uid: cell.uid,
            colIndex,
            rowIndex: row.index,
            colSpan: cell.colSpan,
            rowSpan: cell.rowSpan,
            detailExpandCell: cell.detailExpandCell,
            dataItem: row.dataItem,
            dataRowIndex: row.dataRowIndex,
            focusGroup: cell.focusGroup
        };
        row.cells.setItem(colIndex, modelCell);
        if (cell.groupItem) {
            row.groupItem = cell.groupItem;
        }
        return modelCell;
    }
    unregisterCell(index, rowIndex, cell) {
        const row = this.rows.getItem(rowIndex);
        if (row) {
            const match = row.cells.getItem(index);
            if (match && match.uid === cell.uid) {
                row.cells.removeItem(index);
            }
        }
    }
    registerRow(row) {
        const modelRow = {
            uid: row.uid,
            index: row.logicalRowIndex,
            dataItem: row.dataItem,
            dataRowIndex: row.dataRowIndex,
            cells: new ItemMap()
        };
        this.rows.setItem(row.logicalRowIndex, modelRow);
    }
    updateRow(row) {
        const current = this.rows.getItem(row.logicalRowIndex);
        if (current) {
            Object.assign(current, {
                dataItem: row.dataItem,
                dataRowIndex: row.dataRowIndex
            });
        }
    }
    unregisterRow(index, row) {
        const match = this.rows.getItem(index);
        if (match && match.uid === row.uid) {
            this.rows.removeItem(index);
        }
    }
    cellRange(cell) {
        if (cell) {
            const start = cell.colIndex;
            const end = cell.colIndex + (cell.colSpan || 1) - 1;
            return {
                start,
                end
            };
        }
        return {};
    }
    rowRange(cell) {
        if (cell) {
            const start = cell.rowIndex;
            const end = cell.rowIndex + (cell.rowSpan || 1) - 1;
            return {
                start,
                end
            };
        }
        return {};
    }
    nextRow(rowIndex, offset) {
        const rows = this.rows.toArray();
        const row = this.rows.getItem(rowIndex);
        const position = rows.indexOf(row);
        const next = rows[position + offset];
        return next;
    }
    findRow(index) {
        return this.rows.getItem(index);
    }
    findCell(index, row) {
        if (!row) {
            return;
        }
        const rowIndex = row.index;
        let cell = row.cells.getItem(index);
        let currentIndex = rowIndex;
        while (!cell && row) {
            row = this.rows.getItem(currentIndex);
            cell = this.rowCell(index, row);
            currentIndex--;
        }
        if (cell && rowIndex <= row.index + (cell.rowSpan || 1) - 1) {
            return cell;
        }
    }
    rowCell(index, row) {
        if (!row || !row.cells.count) {
            return;
        }
        const firstCell = row.cells.first;
        let cell, currentIndex = index;
        while (!cell && currentIndex >= firstCell.colIndex) {
            cell = row.cells.getItem(currentIndex);
            currentIndex--;
        }
        if (cell && index <= cell.colIndex + (cell.colSpan || 1) - 1) {
            return cell;
        }
    }
}

/**
 * @hidden
 */
class DomEventsService {
    cellClick = new EventEmitter();
    cellMousedown = new EventEmitter();
    cellMouseup = new EventEmitter();
    click = new EventEmitter();
    keydown = new EventEmitter();
    shiftKeyup = new EventEmitter();
    focus = new EventEmitter();
    focusIn = new EventEmitter();
    focusOut = new EventEmitter();
    windowBlur = new EventEmitter();
    paste = new EventEmitter();
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DomEventsService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DomEventsService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DomEventsService, decorators: [{
            type: Injectable
        }] });

/**
 * @hidden
 */
class PreventableEvent {
    prevented = false;
    /**
     * Prevents the default action for a specified event.
     * In this way, the source component suppresses the built-in behavior that follows the event.
     */
    preventDefault() {
        this.prevented = true;
    }
    /**
     * Returns whether the default action for a specified event was prevented.
     * @returns `true` if the default action was prevented. Otherwise, returns `false`.
     */
    isDefaultPrevented() {
        return this.prevented;
    }
}

/**
 * Arguments for the [`cellClose`](slug:api_grid_gridcomponent#toc-cellclose) event.
 */
class CellCloseEvent extends PreventableEvent {
    isNew;
    dataItem;
    rowIndex;
    sender;
    /**
     * @hidden
     */
    action = 'cellClose';
    /**
     * The Grid column that will be closed.
     */
    column;
    /**
     * The [FormGroup](link:site.data.urls.angular['formgroupapi']) used to edit the cell.
     */
    formGroup;
    /**
     * The DOM event that triggered the `cellClose` event.
     * May be undefined if the event was triggered programmatically.
     */
    originalEvent;
    /**
     * @hidden
     */
    constructor(options) {
        super();
        Object.assign(this, options);
    }
}

/**
 * @hidden
 */
const isEqual = (index) => (item) => item.index === index;
/**
 * @hidden
 */
const isNotEqual = (index) => (item) => item.index !== index;
/**
 * @hidden
 */
const isNewRow = (index) => index === -1 || index === undefined;
/**
 * @hidden
 */
class EditService {
    ngZone;
    changes = new EventEmitter();
    changed;
    editedIndices = [];
    newItemGroup;
    keepEditCell = false;
    keepCellTimeout;
    column;
    closingCell = false;
    changedSource = new Subject();
    constructor(ngZone) {
        this.ngZone = ngZone;
        this.changed = this.changedSource.asObservable().pipe(switchMap(() => this.ngZone.onStable.asObservable().pipe(take(1))));
    }
    editRow(index, group = undefined) {
        this.editedIndices.push({ index, group });
        this.onChanged();
    }
    addRow(group) {
        this.newItemGroup = { group };
        this.onChanged();
    }
    editCell(rowIndex, column, group) {
        if (isNewRow(rowIndex) || column.editable === false || !(column.editTemplate || column.field)) {
            return;
        }
        this.preventCellClose();
        if (!this.closeCell()) {
            this.editRow(rowIndex, group);
            this.column = column;
            this.onChanged();
        }
    }
    isEditing() {
        return this.editedIndices.length > 0;
    }
    isEditingCell() {
        return this.isEditing() && this.column !== undefined;
    }
    get hasNewItem() {
        return isPresent(this.newItemGroup);
    }
    get newDataItem() {
        if (this.hasNewItem) {
            return this.newItemGroup.group.value;
        }
        return {};
    }
    close(index) {
        if (isNewRow(index)) {
            this.newItemGroup = undefined;
            return;
        }
        this.editedIndices = this.editedIndices.filter(isNotEqual(index));
        delete this.column;
        this.onChanged();
    }
    closeCell(originalEvent) {
        if (this.column && !this.closingCell) {
            return this.ngZone.run(() => {
                const { index, group } = this.editedIndices[0];
                const args = new CellCloseEvent({
                    column: this.column,
                    formGroup: group,
                    originalEvent: originalEvent,
                    rowIndex: index
                });
                this.closingCell = true;
                this.changes.emit(args);
                this.closingCell = false;
                if (!args.isDefaultPrevented()) {
                    this.cancelCell();
                }
                return args.isDefaultPrevented();
            });
        }
    }
    cancelCell() {
        if (this.column) {
            this.editedIndices = [];
            delete this.column;
            this.onChanged();
        }
    }
    shouldCloseCell() {
        return this.column && !this.keepEditCell;
    }
    preventCellClose() {
        this.ngZone.runOutsideAngular(() => {
            window.clearTimeout(this.keepCellTimeout);
            this.keepEditCell = true;
            this.keepCellTimeout = window.setTimeout(() => {
                this.keepEditCell = false;
            }, 0);
        });
    }
    context(index) {
        if (isNewRow(index)) {
            return this.newItemGroup;
        }
        return this.findByIndex(index);
    }
    columnContext(index, column) {
        if (isNewRow(index)) {
            return this.newItemGroup;
        }
        if (!this.column || column === this.column) {
            return this.findByIndex(index);
        }
    }
    isEdited(index) {
        if (isNewRow(index) && isPresent(this.newItemGroup)) {
            return true;
        }
        return !this.column && isPresent(this.findByIndex(index));
    }
    hasEdited(index) {
        return isPresent(this.context(index));
    }
    isEditedColumn(index, column) {
        if (this.column && this.column === column) {
            return isPresent(this.findByIndex(index));
        }
        return false;
    }
    beginEdit(rowIndex) {
        this.changes.emit({ action: 'edit', rowIndex });
    }
    beginAdd() {
        this.changes.emit({ action: 'add', isNew: true });
    }
    endEdit(rowIndex) {
        const { group: formGroup } = this.context(rowIndex);
        this.changes.emit({ action: 'cancel', rowIndex, formGroup, isNew: isNewRow(rowIndex) });
    }
    save(rowIndex) {
        const { group: formGroup } = this.context(rowIndex);
        this.changes.emit({ action: 'save', rowIndex, formGroup, isNew: isNewRow(rowIndex) });
    }
    remove(rowIndex) {
        this.changes.emit({ action: 'remove', rowIndex });
    }
    findByIndex(index) {
        return this.editedIndices.find(isEqual(index));
    }
    onChanged() {
        this.ngZone.runOutsideAngular(() => {
            this.changedSource.next(undefined);
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: EditService, deps: [{ token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: EditService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: EditService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: i0.NgZone }] });

/**
 * @hidden
 */
const getGroupRowArgs = (groupItem) => {
    if (!isPresent(groupItem)) {
        return null;
    }
    return { group: groupItem.data, groupIndex: groupItem.index, parentGroup: getGroupRowArgs(groupItem.parentGroup) };
};

const isChildIndex = (targetIndex, parentIndex) => {
    const sameIndex = parentIndex === targetIndex;
    const lastSeparatorIndex = targetIndex.lastIndexOf('_');
    const sameSubGroupIndex = targetIndex.substring(0, lastSeparatorIndex) === parentIndex;
    return !sameIndex && sameSubGroupIndex;
};
/**
 * @hidden
 */
class GroupsService {
    changes = new Subject();
    userCallback;
    rowState = new Set();
    reset() {
        this.rowState.clear();
    }
    ngOnDestroy() {
        this.reset();
    }
    isExpanded(groupArgs) {
        if (this.userCallback) {
            return this.userCallback(groupArgs);
        }
        return !this.rowState.has(groupArgs.groupIndex);
    }
    isInExpandedGroup(groupItem) {
        let expanded = true;
        while (groupItem && expanded) {
            expanded = this.isExpanded({
                group: groupItem.data,
                groupIndex: groupItem.index,
                parentGroup: getGroupRowArgs(groupItem.parentGroup)
            });
            groupItem = groupItem.parentGroup;
        }
        return expanded;
    }
    toggleRow(groupItem, emit = true) {
        const parentGroup = getGroupRowArgs(groupItem.parentGroup);
        const expand = !this.isExpanded({ group: groupItem.data, groupIndex: groupItem.index, parentGroup });
        this.changes.next({ group: groupItem.data, expand, groupIndex: groupItem.index, parentGroup, emit });
        // if usercallback is given, the rowState should be ignored
        if (this.userCallback) {
            return;
        }
        if (expand) {
            this.rowState.delete(groupItem.index);
        }
        else {
            this.rowState.add(groupItem.index);
        }
    }
    expandChildren(parentIndex) {
        this.rowState.forEach(index => isChildIndex(index, parentIndex) && this.rowState.delete(index));
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GroupsService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GroupsService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GroupsService, decorators: [{
            type: Injectable
        }] });

/**
 * Provides the arguments for the `detailCollapse` event.
 *
 * The event fires when a detail row collapses.
 */
class DetailCollapseEvent extends PreventableEvent {
    /**
     * The `dataItem` for the collapsed row.
     */
    dataItem;
    /**
     * The index of the collapsed row.
     */
    index;
    /**
     * @hidden
     */
    constructor(args) {
        super();
        Object.assign(this, args);
    }
}

/**
 * Provides the arguments for the `detailExpand` event.
 *
 * The event fires when a detail row expands.
 */
class DetailExpandEvent extends PreventableEvent {
    /**
     * Represents the `dataItem` for the expanded row.
     */
    dataItem;
    /**
     * Represents the index of the expanded row.
     */
    index;
    /**
     * @hidden
     */
    constructor(args) {
        super();
        Object.assign(this, args);
    }
}

/**
 * @hidden
 */
class DetailsService {
    userCallback;
    changes = new Subject();
    rowState = new Set();
    ngOnDestroy() {
        this.rowState.clear();
    }
    isExpanded(index, dataItem) {
        if (this.userCallback) {
            return this.userCallback({ index, dataItem });
        }
        return this.rowState.has(index);
    }
    toggleRow(index, dataItem) {
        if (this.isExpanded(index, dataItem)) {
            this.collapseRow(index, dataItem);
        }
        else {
            this.expandRow(index, dataItem);
        }
    }
    expandRow(index, dataItem) {
        const prevented = this.emitEvent({ dataItem, index, expand: true });
        if (!prevented && !this.userCallback) {
            this.rowState.add(index);
        }
    }
    collapseRow(index, dataItem) {
        const prevented = this.emitEvent({ dataItem, index, expand: false });
        if (!prevented && !this.userCallback) {
            this.rowState.delete(index);
        }
    }
    emitEvent(args) {
        const eventArg = new (args.expand ? DetailExpandEvent : DetailCollapseEvent)(args);
        this.changes.next(eventArg);
        return eventArg.isDefaultPrevented();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DetailsService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DetailsService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DetailsService, decorators: [{
            type: Injectable
        }] });

/**
 * @hidden
 */
class ScrollRequestService {
    requests = new Subject();
    scrollTo(request, adjustIndex = true) {
        this.requests.next({ request, adjustIndex });
    }
    scrollToItem(request) {
        this.requests.next({ request });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ScrollRequestService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ScrollRequestService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ScrollRequestService, decorators: [{
            type: Injectable
        }] });

/**
 * Lets you customize the content of Grid cells.
 * Place an `<ng-template>` tag with the `kendoGridCellTemplate` directive inside a `<kendo-grid-column>` tag to define the cell template. ([See example](slug:templates_columns_grid#toc-cell-template)).
 *
 * The template context is set to the current data item. You can use these fields:
 * - `columnIndex`&mdash;The current column index. Use `let-columnIndex="columnIndex"` in your template.
 * - `rowIndex`&mdash;The current data row index. Use `let-rowIndex="rowIndex"` in your template.
 * - `dataItem`&mdash;The current data item. This is the default context for any template variable that uses the `let-x` syntax, such as `let-dataItem`.
 * - `column`&mdash;The current column instance. Use `let-column="column"` in your template.
 *
 * @example
 * ```html
 * <kendo-grid [data]="gridData" ...>
 *   <kendo-grid-column field="ProductName">
 *     <ng-template kendoGridCellTemplate let-dataItem let-rowIndex="rowIndex" let-column="column">
 *       Data Row: {{rowIndex}}
 *     </ng-template>
 *   </kendo-grid-column>
 * </kendo-grid>
 * ```
 */
class CellTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CellTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: CellTemplateDirective, isStandalone: true, selector: "[kendoGridCellTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CellTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridCellTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }] });

/**
 * Lets you customize the content of edited cells by providing a column edit-cell template for the Grid ([see example](slug:custom_editors_grid#setting-up-custom-editors)).
 * Place an `<ng-template>` tag with the `kendoGridEditTemplate` directive inside a `<kendo-grid-column>` tag to define the template.
 *
 * The template context includes:
 * - `formGroup`&mdash;The current [FormGroup](link:site.data.urls.angular['formgroupapi']). This is the default context for template variables using `let-x`, such as `let-formGroup`. If you use the Grid in [Template-Driven Forms](link:site.data.urls.angular['forms']), this is `undefined`.
 * - `rowIndex`&mdash;The current data row index. For a new item row, `rowIndex` is `-1`. Use `let-rowIndex="rowIndex"` to access it.
 * - `dataItem`&mdash;The current data item. Use `let-dataItem="dataItem"` to access it.
 * - `column`&mdash;The current column instance. Use `let-column="column"` to access it.
 * - `isNew`&mdash;The state of the current item. Use `let-isNew="isNew"` to access it.
 *
 * @example
 * ```html
 * <kendo-grid-column>
 *   <ng-template kendoGridEditTemplate let-formGroup="formGroup" let-dataItem="dataItem">
 *     <kendo-textbox [formControl]="formGroup.get('field')"></kendo-textbox>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 */
class EditTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: EditTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: EditTemplateDirective, isStandalone: true, selector: "[kendoGridEditTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: EditTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridEditTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }] });

/**
 * Represents the column header cell template of the Grid
 * ([more information and example]({% slug templates_columns_grid %}#toc-header-template)).
 * Use this directive to customize the table header cell for a column.
 * To define a header template, nest an `<ng-template>` tag with the
 * `kendoGridHeaderTemplate` directive inside the `<kendo-grid-column>` tag.
 *
 * The template context is set to the current column. The following additional fields are available:
 * * `column`&mdash;An instance of the [`ColumnComponent`]({% slug api_grid_columncomponent %}) option.
 * * `columnIndex`&mdash;The current column index.
 *
 * @example
 * ```typescript
 * <kendo-grid>
 *   <kendo-grid-column field="ProductName" title="Product Name">
 *     <ng-template kendoGridHeaderTemplate let-column let-columnIndex="columnIndex">
 *       Header for {{ column.field }} (index: {{ columnIndex }})
 *     </ng-template>
 *   </kendo-grid-column>
 * </kendo-grid>
 * ```
 */
class HeaderTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: HeaderTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: HeaderTemplateDirective, isStandalone: true, selector: "[kendoGridHeaderTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: HeaderTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridHeaderTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }] });

/**
 * Represents the column footer cell template of the Grid
 * ([more information and example]({% slug templates_columns_grid %}#toc-footer-template)).
 * Use this directive to customize the table footer cell for a column.
 * To define a footer template, nest an `<ng-template>` tag with the
 * [`kendoGridFooterTemplate`]({% slug api_grid_footertemplatedirective %}) directive inside the `<kendo-grid-column>` tag.
 *
 * The template context is set to the current column. The following additional fields are available:
 * * `column`&mdash;An instance of the [`ColumnComponent`]({% slug api_grid_columncomponent %}) option.
 * * `columnIndex`&mdash;The current column index.
 *
 * For more information about displaying aggregates in the footer of the Grid,
 * see the article on [aggregates]({% slug groupable_grid_with_aggregates %}).
 *
 * @example
 * ```html
 * <kendo-grid [data]="gridData" scrollable="none">
 *    <kendo-grid-column field="ProductName">
 *       <ng-template kendoGridFooterTemplate let-column let-columnIndex="columnIndex">
 *          {{column.field}}({{columnIndex}})
 *       </ng-template>
 *    </kendo-grid-column>
 * </kendo-grid>
 * ```
 */
class FooterTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FooterTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: FooterTemplateDirective, isStandalone: true, selector: "[kendoGridFooterTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FooterTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridFooterTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }] });

/**
 * Defines a template for the column menu in the Grid. Use this directive to customize the column menu content for all columns or for specific columns.
 * Place an `<ng-template>` tag with the `kendoGridColumnMenuTemplate` directive inside the `<kendo-grid>` or `<kendo-grid-column>` component to set the template.
 *
 * The template context provides these fields:
 * - `service`&mdash;The [`ColumnMenuService`]({% slug api_grid_columnmenuservice %}).
 * - `column`&mdash;The Grid column.
 *
 * @example
 * ```html
 * <kendo-grid [kendoGridBinding]="data" [sortable]="true" [columnMenu]="true">
 *   <ng-template kendoGridColumnMenuTemplate let-service="service">
 *     <kendo-grid-columnmenu-sort [service]="service"></kendo-grid-columnmenu-sort>
 *   </ng-template>
 *   <kendo-grid-column field="Field1">
 *     <ng-template kendoGridColumnMenuTemplate let-service="service">
 *       <kendo-grid-columnmenu-lock [service]="service"></kendo-grid-columnmenu-lock>
 *       <kendo-grid-columnmenu-sort [service]="service"></kendo-grid-columnmenu-sort>
 *     </ng-template>
 *   </kendo-grid-column>
 *   <kendo-grid-column field="Field2"></kendo-grid-column>
 * </kendo-grid>
 * ```
 */
class ColumnMenuTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnMenuTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: ColumnMenuTemplateDirective, isStandalone: true, selector: "[kendoGridColumnMenuTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnMenuTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridColumnMenuTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }] });

// Registry to track active Grid instances and their indices
const activeGridIndices = new Set();
// Get the next available grid index (reuses freed indices)
function getNextGridIndex() {
    let index = 0;
    while (activeGridIndices.has(index)) {
        index++;
    }
    activeGridIndices.add(index);
    return index;
}
// Release a grid index when the Grid is destroyed
function releaseGridIndex(index) {
    activeGridIndices.delete(index);
}
/**
 * @hidden
 */
class IdService {
    prefix;
    gridIndex;
    columnCounter = 0;
    constructor() {
        this.gridIndex = getNextGridIndex();
        this.prefix = `k-grid${this.gridIndex}`;
    }
    ngOnDestroy() {
        releaseGridIndex(this.gridIndex);
    }
    gridId() {
        return this.prefix;
    }
    cellId(rowIndex, colIndex) {
        return `${this.prefix}-r${rowIndex}c${colIndex}`;
    }
    selectionCheckboxId(itemIndex) {
        return `${this.prefix}-checkbox${itemIndex}`;
    }
    selectAllCheckboxId() {
        return `${this.prefix}-select-all`;
    }
    columnId(colIndex) {
        return `${this.prefix}-col${colIndex}`;
    }
    nextColumnId() {
        return `${this.prefix}-col${this.columnCounter++}`;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: IdService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: IdService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: IdService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [] });

/**
 * @hidden
 */
const ColumnMenuErrorMessages = {
    autoSizeColumn: `The auto size column does not work with enabled virtual columns.
    See https://www.telerik.com/kendo-angular-ui/components/grid/accessories/column-menu/#toc-autosize-column-item.`,
    autoSizeAllColumns: `The auto size all columns does not work with enabled virtual columns.
    See https://www.telerik.com/kendo-angular-ui/components/grid/accessories/column-menu/#toc-autosize-all-columns-item.`,
    serviceInput: `The service input of the predefined column menu components is mandatory.
    See https://www.telerik.com/kendo-angular-ui/components/grid/accessories/column-menu/#toc-customizing-the-content.`
};
/**
 * @hidden
 */
const ClipboardErrorMessages = {
    activeCellNavigable: `Grid must be navigable to use "activeCell" as clipboard target type.
    See https://www.telerik.com/kendo-angular-ui/components/grid/accessories/clipboard/#toc-active-cell.`,
    selectionSelectable: `Grid must be selectable to use "selection" as clipboard target type.
    See https://www.telerik.com/kendo-angular-ui/components/grid/accessories/clipboard/#toc-current-selection.`
};
/**
 * @hidden
 */
const ColumnConfigurationErrorMessages = {
    fieldName: (field) => `Grid column field name '${field}' does not look like a valid JavaScript identifier.
        Identifiers can contain only alphanumeric characters (including "$" or "_"), and may not start with a digit.
        Please use only valid identifier names to ensure error-free operation.`,
    width: (value, parsedValue) => `Expected numeric value for column width, but got a string "${value}". Treating as ${parsedValue}px.`,
    invalidColumn: (column) => `Invalid column ${column}.`,
    requiredWidth: (columnType) => `${columnType} columns feature requires all columns to have set width.
    See https://www.telerik.com/kendo-angular-ui/components/grid/columns/${columnType.toLowerCase()}.`,
    requiredScroll: (columnType) => `${columnType} columns are only supported when scrolling is enabled.
    See https://www.telerik.com/kendo-angular-ui/components/grid/columns/${columnType.toLowerCase()}/`,
    groupColumnContent: 'ColumnGroupComponent should contain ColumnComponent or CommandColumnComponent.',
    lockedParent: 'Locked child columns require their parent columns to be locked.',
    columnNested: 'Columns can be nested only inside ColumnGroupComponent',
    nestedInside: (nestedColumnNameType, parentColumnType) => `${nestedColumnNameType} cannot be nested inside ${parentColumnType}.`,
    cellRowspanNonBoundColumns: 'cellRowspan must be a function for non-bound columns.',
    cellRowspanSpanGroupedColumns: 'cellRowspan is not supported for SpanColumn and GroupColumn.',
    cellRowspan: `cellRowspan must be a function or boolean.`
};
/**
 * @hidden
 */
const GridConfigurationErrorMessages = {
    functionType: (propName, fn) => `${propName} must be a function, but received ${JSON.stringify(fn)}.`,
    incompatibleFeatures: (feat1Name, feat2Name) => `'Having both ${feat1Name} and ${feat2Name} is not supported.'`,
    nonLockedColumnPresent: 'There should be at least one non-locked column. See https://www.telerik.com/kendo-angular-ui/components/grid/columns/locked/#toc-known-limitations',
    focusNavigable: 'The Grid should be configured as navigable to control focus. See https://www.telerik.com/kendo-angular-ui/components/grid/keyboard-navigation/.',
    expandCollapseMethods: (expandMethodName, collapseMethodName, directiveName, callbackName) => `The ${expandMethodName} and ${collapseMethodName} methods should not be called
        when using the ${directiveName} directive or the ${callbackName} callback.
        These methods are provided only for backwards compatibility with legacy versions.`,
    requiredEditService: `The default edit service of the editing directives works only when binding to plain array.
        Please provide an editService. See https://www.telerik.com/kendo-angular-ui/components/grid/editing/editing-directives/#toc-custom-editing-service.`,
    requiredModule: (exportedType, moduleName, componentSelector) => `Creating ${exportedType} requires including the ${moduleName} and adding the ${componentSelector} component.`,
    unsupportedMethod: (methodName, suggestedMethodName) => `Using ${methodName} in this context is not supported. Use ${suggestedMethodName} instead.`,
    unsupportedToolbarConfig: `
        Defining both a toolbar template and a ToolBarComponent within the Grid is not supported.
        Please use either the ToolBarComponent or a custom template.`
};

/**
 * @hidden
 */
const isSpanColumn = column => column?.isSpanColumn;
/**
 * @hidden
 */
const isCheckboxColumn = column => column?.isCheckboxColumn;
/**
 * @hidden
 */
const isRowReorderColumn = column => column?.isRowReorderColumn;
const isColumnContainer = column => column?.isColumnGroup || isSpanColumn(column);
/**
 * The base class for the column components of the Grid.
 *
 * Use this class as a foundation for custom column implementations.
 */
class ColumnBase {
    parent;
    /**
     * @hidden
     */
    isReordered;
    /**
     * @hidden
     */
    initialMaxResizableWidth;
    /**
     * @hidden
     */
    initialMinResizableWidth;
    /**
     * @hidden
     */
    initiallyChecked;
    /**
     * @hidden
     */
    currentlyChecked;
    /**
     * @hidden
     */
    matchesMedia = true;
    /**
     * Gets the column index after reordering. The `orderIndex` property is read-only. Setting this field does not change the column order.
     *
     * @default 0
     */
    orderIndex = 0;
    /**
     * @hidden
     */
    set leafIndex(value) {
        this._leafIndex = value;
    }
    /**
     * @hidden
     */
    get leafIndex() {
        return this._leafIndex;
    }
    _leafIndex;
    /**
     * @hidden
     */
    isColumnGroup = false;
    /**
     * @hidden
     */
    isSpanColumn = false;
    /**
     * Specifies if the column is resizable.
     * @default true
     */
    resizable = true;
    /**
     * Specifies if the column is reorderable.
     * @default true
     */
    reorderable = true;
    /**
     * Sets the minimum width (in pixels) for resizing the column by using the UI ([see example]({% slug resizing_columns_grid %}#toc-limiting-the-resizing)).
     * The `autoFitColumn` and `autoFitColumns` methods have higher priority.
     * @default 10
     */
    minResizableWidth = 10;
    /**
     * Sets the maximum width (in pixels) for resizing the column by using the UI ([see example]({% slug resizing_columns_grid %}#toc-limiting-the-resizing)).
     * By default, the maximum width is not restricted.
     * The `autoFitColumn` and `autoFitColumns` methods have higher priority.
     */
    maxResizableWidth;
    /**
     * Sets the column title.
     */
    title;
    /**
     * Sets the column width (in pixels).
     */
    set width(value) {
        if (typeof value === 'string') {
            const parsedValue = this._width = parseInt(value, 10);
            if (isDevMode()) {
                console.warn(ColumnConfigurationErrorMessages.width(value, parsedValue));
            }
        }
        else {
            this._width = value;
        }
    }
    get width() { return this._width; }
    /**
     * Specifies if the column is automatically resized during initialization to fit its header and row content.
     */
    autoSize;
    /**
     * Toggles the locked (frozen) state of the column ([more information and example]({% slug locked_columns_grid %})).
     *
     * @default false
     */
    set locked(value) {
        this._locked = value;
    }
    get locked() {
        return this._locked;
    }
    _locked = false;
    /**
     * Specifies if the column is always visible when scrolling the Grid horizontally.
     *
     * @default false
     */
    sticky = false;
    /**
     * Sets the visibility of the column ([see example](slug:hidden_columns_grid#toc-using-the-built-in-options)).
     *
     * @default false
     */
    hidden;
    /**
     * Sets the condition for the column to remain visible ([see example]({% slug styling_responsive_grid %}#toc-columns)).
     * If you set the `hidden` property, `media` is ignored.
     *
     * Accepts device identifiers from [Bootstrap 4](https://v4-alpha.getbootstrap.com/layout/grid/#grid-options)
     * ([see example](slug:styling_responsive_grid)).
     */
    media;
    /**
     * Specifies if the column can be locked or unlocked from the column menu or by reordering.
     * @default true
     */
    lockable = true;
    /**
     * Specifies if the column can be stuck or unstuck from the column menu.
     * @default true
     */
    stickable = true;
    /**
     * Specifies if the column menu is shown for the column.
     * @default true
     */
    columnMenu = true;
    /**
     * Specifies if the column is included in the column-chooser list.
     * @default true
     */
    includeInChooser = true;
    /**
     * Sets the `role` attribute for the table cells (excluding footer and header) of the column.
     * @default "gridcell"
     */
    tableCellsRole = 'gridcell';
    /**
     * Sets custom styles for the table cells (excluding footer and header) of the column.
     * Uses the [`NgStyle`](link:site.data.urls.angular['ngstyleapi']) directive. [See example](slug:styling_grid_columns#toc-customizing-column-cells).
     */
    style;
    /**
     * Sets custom styles for the header cell of the column.
     * Uses the [`NgStyle`](link:site.data.urls.angular['ngstyleapi']) directive. [See example](slug:styling_grid_columns#toc-customizing-column-header).
     */
    headerStyle;
    /**
     * Sets custom styles for the filter row cell.
     * Uses the [`NgStyle`](link:site.data.urls.angular['ngstyleapi']) directive. [See example](slug:styling_grid_columns#toc-customizing-filter-row-cells).
     */
    filterStyle;
    /**
     * Sets custom styles for the footer cell of the column.
     * Uses the [`NgStyle`](link:site.data.urls.angular['ngstyleapi']) directive. [See example](slug:styling_grid_columns#toc-customizing-column-footer).
     */
    footerStyle;
    /**
     * Sets custom CSS classes to the column cells.
     * Uses the [`NgClass`](link:site.data.urls.angular['ngclassapi']) directive. [See example](slug:styling_grid_columns#toc-customizing-column-cells).
     * To customize header and footer column cells, use the [headerClass]({% slug api_grid_columncomponent %}#toc-headerclass)
     * and [footerClass]({% slug api_grid_columncomponent %}#toc-footerclass) inputs.
     */
    cssClass;
    /**
     * Sets custom CSS classes to the column header cell.
     * Uses the [`NgClass`](link:site.data.urls.angular['ngclassapi']) directive. [See example](slug:styling_grid_columns#toc-customizing-column-header).
     */
    headerClass;
    /**
     * Sets custom CSS classes to the filter row cell.
     * Uses the [`NgClass`](link:site.data.urls.angular['ngclassapi']) directive. [See example](slug:styling_grid_columns#toc-customizing-filter-row-cells).
     */
    filterClass;
    /**
     * Sets custom CSS classes to the column footer cell.
     * Uses the [`NgClass`](link:site.data.urls.angular['ngclassapi']) directive. [See example](slug:styling_grid_columns#toc-customizing-column-footer).
     */
    footerClass;
    /**
     * Defines a function to determine the rowspan of each column cell.
     * If you set this to `true`, a default function is used that spans adjacent cells with equal values.
     * Cells have equal values when their data items' values for the respective field are equal.
     */
    set cellRowspan(cellRowspan) {
        if (isDevMode() && (this.isSpanColumn || this.isColumnGroup)) {
            throw new Error(ColumnConfigurationErrorMessages.cellRowspanSpanGroupedColumns);
        }
        if (cellRowspan) {
            const isFunction = typeof cellRowspan === 'function';
            const isBoolean = typeof cellRowspan === 'boolean';
            if (isDevMode() && !this.field && !isFunction) {
                throw new Error(ColumnConfigurationErrorMessages.cellRowspanNonBoundColumns);
            }
            if (isDevMode() && !(isBoolean || isFunction)) {
                throw new Error(ColumnConfigurationErrorMessages.cellRowspan);
            }
            this._cellRowspan = isBoolean ? defaultCellRowSpan : cellRowspan;
        }
    }
    get cellRowspan() {
        return this._cellRowspan;
    }
    /**
     * @hidden
     */
    headerTemplates = new QueryList();
    /**
     * @hidden
     */
    footerTemplate;
    /**
     * @hidden
     */
    columnMenuTemplates = new QueryList();
    /**
     * @hidden
     */
    resizeStartWidth;
    /**
     * @hidden
     */
    idService;
    /**
     * @hidden
     */
    _cellRowspan;
    /**
     * @hidden
     */
    implicitWidth;
    /**
     * @hidden
     */
    get level() {
        if (this.parent && isSpanColumn(this.parent)) {
            return this.parent.level;
        }
        return this.parent ? this.parent.level + 1 : 0;
    }
    /**
     * @hidden
     */
    get isLocked() {
        return this.parent ? this.parent.isLocked : this.locked;
    }
    _width;
    /**
     * @hidden
     */
    get id() {
        return this._id;
    }
    /**
     * @hidden
     */
    get colspan() {
        return 1;
    }
    /**
     * @hidden
     */
    rowspan(totalColumnLevels) {
        return this.level < totalColumnLevels ? (totalColumnLevels - this.level) + 1 : 1;
    }
    /**
     * @hidden
     */
    get headerTemplateRef() {
        const template = this.headerTemplates.first;
        return template ? template.templateRef : undefined;
    }
    /**
     * @hidden
     */
    get footerTemplateRef() {
        return this.footerTemplate ? this.footerTemplate.templateRef : undefined;
    }
    /**
     * @hidden
     */
    get columnMenuTemplateRef() {
        const template = this.columnMenuTemplates.first;
        return template ? template.templateRef : null;
    }
    /**
     * @hidden
     */
    get displayTitle() {
        return this.title;
    }
    /**
     * @hidden
     */
    get isVisible() {
        return !this.hidden && this.matchesMedia;
    }
    _id;
    /**
     * @hidden
     */
    constructor(parent, idService) {
        this.parent = parent;
        this.idService = idService;
        if (parent && idService && parent.idService.gridId() === idService.gridId() && !isColumnContainer(parent)) {
            throw new Error(ColumnConfigurationErrorMessages.columnNested);
        }
        this._id = this.idService?.nextColumnId();
    }
    ngAfterViewInit() {
        this.initialMinResizableWidth = this.minResizableWidth || 10;
        this.initialMaxResizableWidth = this.maxResizableWidth || Number.MAX_SAFE_INTEGER;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnBase, deps: [{ token: ColumnBase }, { token: IdService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: ColumnBase, isStandalone: true, selector: "kendo-grid-column-base", inputs: { resizable: "resizable", reorderable: "reorderable", minResizableWidth: "minResizableWidth", maxResizableWidth: "maxResizableWidth", title: "title", width: "width", autoSize: "autoSize", locked: "locked", sticky: "sticky", hidden: "hidden", media: "media", lockable: "lockable", stickable: "stickable", columnMenu: "columnMenu", includeInChooser: "includeInChooser", tableCellsRole: "tableCellsRole", style: "style", headerStyle: "headerStyle", filterStyle: "filterStyle", footerStyle: "footerStyle", cssClass: ["class", "cssClass"], headerClass: "headerClass", filterClass: "filterClass", footerClass: "footerClass", cellRowspan: "cellRowspan" }, queries: [{ propertyName: "footerTemplate", first: true, predicate: FooterTemplateDirective, descendants: true }, { propertyName: "headerTemplates", predicate: HeaderTemplateDirective }, { propertyName: "columnMenuTemplates", predicate: ColumnMenuTemplateDirective }], ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnBase, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-column-base',
                    template: ``
                }]
        }], ctorParameters: () => [{ type: ColumnBase }, { type: IdService }], propDecorators: { resizable: [{
                type: Input
            }], reorderable: [{
                type: Input
            }], minResizableWidth: [{
                type: Input
            }], maxResizableWidth: [{
                type: Input
            }], title: [{
                type: Input
            }], width: [{
                type: Input
            }], autoSize: [{
                type: Input
            }], locked: [{
                type: Input
            }], sticky: [{
                type: Input
            }], hidden: [{
                type: Input
            }], media: [{
                type: Input
            }], lockable: [{
                type: Input
            }], stickable: [{
                type: Input
            }], columnMenu: [{
                type: Input
            }], includeInChooser: [{
                type: Input
            }], tableCellsRole: [{
                type: Input
            }], style: [{
                type: Input
            }], headerStyle: [{
                type: Input
            }], filterStyle: [{
                type: Input
            }], footerStyle: [{
                type: Input
            }], cssClass: [{
                type: Input,
                args: ['class']
            }], headerClass: [{
                type: Input
            }], filterClass: [{
                type: Input
            }], footerClass: [{
                type: Input
            }], cellRowspan: [{
                type: Input
            }], headerTemplates: [{
                type: ContentChildren,
                args: [HeaderTemplateDirective, { descendants: false }]
            }], footerTemplate: [{
                type: ContentChild,
                args: [FooterTemplateDirective, { static: false }]
            }], columnMenuTemplates: [{
                type: ContentChildren,
                args: [ColumnMenuTemplateDirective]
            }] } });

/**
 * The directive allows customizing the content of the group header cell in the Grid.
 * Place an `<ng-template>` with the `kendoGridGroupHeaderTemplate` directive inside `<kendo-grid-column>` to set the group header template. ([See example](slug:grouping_grid_templates#toc-header-template)).
 *
 * The template context uses the current data item and provides these fields:
 * - `group`&mdash;The current group item.
 * - `field`&mdash;The field name used for grouping.
 * - `value`&mdash;The current group value.
 * - `aggregates`&mdash;All aggregate values for the current group.
 * - `index`&mdash;The index of the current group.
 * - `expanded`&mdash;A boolean that shows if the group is expanded.
 *
 * @example
 * ```html
 * <kendo-grid [data]="gridData" [group]="groups">
 *    <kendo-grid-column field="ProductName">
 *       <ng-template kendoGridGroupHeaderTemplate let-group let-field="field" let-value="value">
 *          <strong>{{field}}</strong>: {{value}}
 *       </ng-template>
 *    </kendo-grid-column>
 * </kendo-grid>
 * ```
 */
class GroupHeaderTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GroupHeaderTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: GroupHeaderTemplateDirective, isStandalone: true, selector: "[kendoGridGroupHeaderTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GroupHeaderTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridGroupHeaderTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }] });

/**
 * Represents the group-header column template of the Grid, allowing customization of group header content.
 * To define the group header template, nest an `<ng-template>` tag with the `kendoGridGroupHeaderColumnTemplate`
 * directive inside a `<kendo-grid-column>`. [See example](slug:grouping_grid_templates#toc-header-column-template).
 *
 * The template context is set to the current data item and provides the following fields:
 * - `group`&mdash;The current group item.
 * - `field`&mdash;The name of the field used for grouping.
 * - `value`&mdash;The current group value.
 * - `aggregates`&mdash;Aggregate values for the current group.
 *
 * @example
 * ```html
 * <kendo-grid-column field="ProductName" title="Product Name">
 *     <ng-template kendoGridGroupHeaderColumnTemplate let-group="group" let-aggregates="aggregates">
 *         <span title="Group Header Column Template for ProductName">
 *             Count: {{ aggregates.Discontinued.count }}
 *         </span>
 *     </ng-template>
 * </kendo-grid-column>
 * ```
 */
class GroupHeaderColumnTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GroupHeaderColumnTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: GroupHeaderColumnTemplateDirective, isStandalone: true, selector: "[kendoGridGroupHeaderColumnTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GroupHeaderColumnTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridGroupHeaderColumnTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }] });

/**
 * The directive allows customizing the group footer cell for a column in the Grid.
 * To set the group footer template, nest an `<ng-template>` tag with the `kendoGridGroupFooterTemplate` directive inside `<kendo-grid-column>`.
 *
 * The template context uses the current data item and provides these fields:
 * - `column`&mdash;An instance of the `ColumnComponent` option.
 * - `field`&mdash;The current column field name.
 * - `group`&mdash;The current group data item.
 * - `aggregates`&mdash;All aggregate values for the current group.
 *
 * @example
 * ```html
 * <kendo-grid [data]="gridData" [group]="groups">
 *    <kendo-grid-column field="ProductName" title="Product Name">
 *       <ng-template kendoGridGroupFooterTemplate let-aggregates let-field="field">
 *          Count: {{aggregates[field].count}}
 *       </ng-template>
 *    </kendo-grid-column>
 * </kendo-grid>
 * ```
 */
class GroupFooterTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GroupFooterTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: GroupFooterTemplateDirective, isStandalone: true, selector: "[kendoGridGroupFooterTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GroupFooterTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridGroupFooterTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }] });

/**
 * Represents the filter-cell template directive.
 * Use this directive to customize the content of the filter cell.
 * To define the filter cell template, nest an `<ng-template>` tag with the
 * `kendoGridFilterCellTemplate` directive inside a `<kendo-grid-column>` tag ([see example]({% slug filter_row %}#toc-custom-filters)).
 *
 * The template context is set to the current data item and the following additional fields are passed:
 * - `column`&mdash;Defines an instance of the [`ColumnComponent`]({% slug api_grid_columncomponent %}) option. Use it as an alias for a template variable by utilizing the `let-column="column"` syntax.
 * - `filter`&mdash;The provided filter descriptors. Use it as an alias for a template variable by utilizing the `let-filter="filter"` syntax.
 *
 * @example
 * ```html
 * <kendo-grid-column field="CategoryID" title="Category">
 *     <ng-template kendoGridFilterCellTemplate
 *         let-column="column"
 *         let-filter="filter"
 *         >
 *         ...
 *    </ng-template>
 *    ...
 * </kendo-grid-column>
 * ```
 */
class FilterCellTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FilterCellTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: FilterCellTemplateDirective, isStandalone: true, selector: "[kendoGridFilterCellTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FilterCellTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridFilterCellTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }] });

/**
 * Represents the filter-menu template.
 * Use this directive to customize the content of the filter menu.
 * To define the filter menu template, nest an `<ng-template>` tag with the
 * `kendoGridFilterMenuTemplate` directive inside a `<kendo-grid-column>` tag.
 * [See example]({% slug filter_menu %}#toc-custom-filters).
 *
 * The template context is set to the current data item and provides these additional fields:
 * - `column`&mdash;Defines an instance of the `ColumnComponent` option. Use it as an alias for a template variable by using the `let-column="column"` syntax.
 * - `filter`&mdash;The provided filter descriptors. Use it as an alias for a template variable by using the `let-filter="filter"` syntax.
 * - `filterService`&mdash;Represents the `FilterService`. Use it as an alias for a template variable by using the `let-filterService="filterService"` syntax.
 *
 * @example
 * ```html
 * <kendo-grid-column field="CategoryID" title="Category">
 *     <ng-template kendoGridFilterMenuTemplate
 *         let-column="column"
 *         let-filter="filter"
 *         let-filterService="filterService"
 *         >
 *         ...
 *    </ng-template>
 * </kendo-grid-column>
 * ```
 */
class FilterMenuTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FilterMenuTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: FilterMenuTemplateDirective, isStandalone: true, selector: "[kendoGridFilterMenuTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FilterMenuTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridFilterMenuTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }] });

/**
 * @hidden
 */
function isColumnComponent(column) {
    return isPresent(column?.field);
}
/**
 * Represents a column in the Grid.
 *
 * Use the `kendo-grid-column` component to define columns in the Grid.
 *
 * @example
 * ```html
 * <kendo-grid [data]="gridData">
 *   <kendo-grid-column field="ProductID" title="Product ID"></kendo-grid-column>
 *   <kendo-grid-column field="ProductName" title="Product Name"></kendo-grid-column>
 *   <kendo-grid-column field="UnitPrice" title="Unit Price"></kendo-grid-column>
 * </kendo-grid>
 * ```
 * @remarks
 * Supported children components are: {@link StringFilterCellComponent}, {@link NumericFilterCellComponent}, {@link BooleanFilterCellComponent}, {@link DateFilterCellComponent}, {@link StringFilterMenuComponent}, {@link NumericFilterMenuComponent}, {@link BooleanFilterMenuComponent}, {@link DateFilterMenuComponent}, {@link FilterCellOperatorsComponent}, {@link ColumnMenuAutoSizeAllColumnsComponent}, {@link ColumnMenuAutoSizeColumnComponent}, {@link ColumnMenuChooserComponent}, {@link ColumnMenuComponent}, {@link ColumnMenuFilterComponent}, {@link ColumnMenuItemComponent}, {@link ColumnMenuLockComponent}, {@link ColumnMenuPositionComponent}, {@link ColumnMenuSortComponent}, {@link ColumnMenuStickComponent}.
 */
class ColumnComponent extends ColumnBase {
    /**
     * Sets the field that the column binds to.
     */
    field;
    /**
     * Sets the format for displaying the column value.
     * For supported date and number formats, see the [Column Formats](slug:formats_columns_grid) article.
     */
    format;
    /**
     * Enables sorting when the user clicks the column header. [See example](slug:sorting_grid).
     * Emits the `sortChange` event.
     *
     * @default true
     */
    sortable = true;
    /**
     * Allows dragging the column to the group panel.
     * Set to `false` to group by this column only through the Grid API.
     *
     * @default true
     */
    groupable = true;
    /**
     * Sets the editor type for the column. [See example](slug:inline_editing_grid#toc-using-reactive-forms).
     * Used when the column enters edit mode.
     *
     * @default 'text'
     */
    editor = 'text';
    /**
     * Sets the filter type for the filter row UI. [See example](slug:filtering_grid#toc-filter-data-types).
     *
     * @default 'text'
     */
    filter = 'text';
    /**
     * Specifies the filter type for the filter menu UI.
     *
     * @default 'default'
     */
    filterVariant = 'default';
    /**
     * Shows or hides the filter UI for this column. [See example](slug:filtering_grid).
     *
     * @default true
     */
    filterable = true;
    /**
     * Sets whether the column is editable. [See example](slug:make_fields_uneditable_grid).
     *
     * @default true
     */
    editable = true;
    template;
    groupHeaderTemplate;
    groupHeaderColumnTemplate;
    groupFooterTemplate;
    editTemplate;
    filterCellTemplate;
    filterMenuTemplate;
    constructor(parent, idService) {
        super(parent, idService);
    }
    get templateRef() {
        return this.template ? this.template.templateRef : undefined;
    }
    get groupHeaderTemplateRef() {
        return this.groupHeaderTemplate ? this.groupHeaderTemplate.templateRef : undefined;
    }
    get groupHeaderColumnTemplateRef() {
        return this.groupHeaderColumnTemplate ? this.groupHeaderColumnTemplate.templateRef : undefined;
    }
    get groupFooterTemplateRef() {
        return this.groupFooterTemplate ? this.groupFooterTemplate.templateRef : undefined;
    }
    get editTemplateRef() {
        return this.editTemplate ? this.editTemplate.templateRef : undefined;
    }
    get filterCellTemplateRef() {
        return this.filterCellTemplate ? this.filterCellTemplate.templateRef : undefined;
    }
    get filterMenuTemplateRef() {
        return this.filterMenuTemplate ? this.filterMenuTemplate.templateRef : undefined;
    }
    get displayTitle() {
        return this.title === undefined ? this.field : this.title;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnComponent, deps: [{ token: ColumnBase, host: true, optional: true, skipSelf: true }, { token: IdService, optional: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: ColumnComponent, isStandalone: true, selector: "kendo-grid-column", inputs: { field: "field", format: "format", sortable: "sortable", groupable: "groupable", editor: "editor", filter: "filter", filterVariant: "filterVariant", filterable: "filterable", editable: "editable" }, providers: [
            {
                provide: ColumnBase,
                useExisting: forwardRef(() => ColumnComponent)
            }
        ], queries: [{ propertyName: "template", first: true, predicate: CellTemplateDirective, descendants: true }, { propertyName: "groupHeaderTemplate", first: true, predicate: GroupHeaderTemplateDirective, descendants: true }, { propertyName: "groupHeaderColumnTemplate", first: true, predicate: GroupHeaderColumnTemplateDirective, descendants: true }, { propertyName: "groupFooterTemplate", first: true, predicate: GroupFooterTemplateDirective, descendants: true }, { propertyName: "editTemplate", first: true, predicate: EditTemplateDirective, descendants: true }, { propertyName: "filterCellTemplate", first: true, predicate: FilterCellTemplateDirective, descendants: true }, { propertyName: "filterMenuTemplate", first: true, predicate: FilterMenuTemplateDirective, descendants: true }], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: ColumnBase,
                            useExisting: forwardRef(() => ColumnComponent)
                        }
                    ],
                    selector: 'kendo-grid-column',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: ColumnBase, decorators: [{
                    type: SkipSelf
                }, {
                    type: Host
                }, {
                    type: Optional
                }] }, { type: IdService, decorators: [{
                    type: Optional
                }] }], propDecorators: { field: [{
                type: Input
            }], format: [{
                type: Input
            }], sortable: [{
                type: Input
            }], groupable: [{
                type: Input
            }], editor: [{
                type: Input
            }], filter: [{
                type: Input
            }], filterVariant: [{
                type: Input
            }], filterable: [{
                type: Input
            }], editable: [{
                type: Input
            }], template: [{
                type: ContentChild,
                args: [CellTemplateDirective, { static: false }]
            }], groupHeaderTemplate: [{
                type: ContentChild,
                args: [GroupHeaderTemplateDirective, { static: false }]
            }], groupHeaderColumnTemplate: [{
                type: ContentChild,
                args: [GroupHeaderColumnTemplateDirective, { static: false }]
            }], groupFooterTemplate: [{
                type: ContentChild,
                args: [GroupFooterTemplateDirective, { static: false }]
            }], editTemplate: [{
                type: ContentChild,
                args: [EditTemplateDirective, { static: false }]
            }], filterCellTemplate: [{
                type: ContentChild,
                args: [FilterCellTemplateDirective, { static: false }]
            }], filterMenuTemplate: [{
                type: ContentChild,
                args: [FilterMenuTemplateDirective, { static: false }]
            }] } });

/**
 * @hidden
 */
function isSpanColumnComponent(column) {
    return column.isSpanColumn;
}
/**
 * Represents a column that spans multiple data cells while keeping the individual
 * header and footer cells ([see example]({% slug spanned_columns_grid %})).
 * Use this column to create flexible layouts and keep built-in UI for
 * [sorting]({% slug sorting_grid %}), [filtering]({% slug filtering_grid %}), and
 * [grouping]({% slug grouping_grid %}). Wrap the columns you want to merge inside the `<kendo-grid-span-column>` tag.
 *
 * @example
 * ```html
 * <kendo-grid-span-column>
 *   <kendo-grid-column field="ID"></kendo-grid-column>
 *   <kendo-grid-column field="Name"></kendo-grid-column>
 *   <ng-template kendoGridCellTemplate let-dataItem>
 *     <p>{{ dataItem.ID }}</p>
 *     <p>{{ dataItem.Name }}</p>
 *   </ng-template>
 * </kendo-grid-span-column>
 * ```
 */
class SpanColumnComponent extends ColumnBase {
    /*
     * @hidden
     */
    isSpanColumn = true;
    template = new QueryList();
    editTemplate = new QueryList();
    /**
     * @hidden
     */
    children = new QueryList();
    /**
     * @hidden
     */
    title;
    /**
     * @hidden
     */
    headerStyle;
    /**
     * @hidden
     */
    footerStyle;
    /**
     * @hidden
     */
    headerClass;
    /**
     * @hidden
     */
    footerClass;
    /**
     * @hidden
     */
    includeInChooser = false;
    /**
     * Sets whether the edit template of the column is rendered.
     * To enable editing for a spanned column, set an edit template for it ([see example](slug:custom_editors_grid#setting-up-custom-editors)).
     * @default false
     */
    set editable(value) {
        this._editable = value;
    }
    get editable() {
        return isPresent(this.editTemplateRef) && this._editable;
    }
    /**
     * @hidden
     * added for backwards compitability
     */
    set width(_value) {
    }
    get width() {
        return this.children.reduce((total, column) => total + column.width, 0);
    }
    /**
     * @hidden
     */
    get leafIndex() {
        return this.children.first.leafIndex;
    }
    _editable = true;
    constructor(parent, idService) {
        super(parent, idService);
        if (parent && parent.isSpanColumn) {
            throw new Error(ColumnConfigurationErrorMessages.nestedInside('SpanColumnComponent', 'SpanColumnComponent'));
        }
    }
    /**
     * @hidden
     */
    get templateRef() {
        const template = this.template.first;
        return template ? template.templateRef : undefined;
    }
    /**
     * @hidden
     */
    get editTemplateRef() {
        const editTemplate = this.editTemplate.first;
        return editTemplate ? editTemplate.templateRef : undefined;
    }
    /**
     * @hidden
     */
    get colspan() {
        return this.children.filter(c => c.isVisible).length;
    }
    /**
     * Toggles the locked (frozen) state of the columns ([see example](slug:locked_columns_grid)).
     * @default false
     */
    set locked(value) {
        this._locked = value;
    }
    get locked() {
        return this._locked || this.children.some(c => c.locked);
    }
    get childrenArray() {
        return this.children.toArray();
    }
    get hasChildren() {
        return this.children.length > 0;
    }
    /**
     * @hidden
     *
     * Used to hide the cellRowspan property from the public API.
     */
    set cellRowspan(cellRowSpan) {
        super.cellRowspan = cellRowSpan;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SpanColumnComponent, deps: [{ token: ColumnBase, host: true, optional: true, skipSelf: true }, { token: IdService, optional: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: SpanColumnComponent, isStandalone: true, selector: "kendo-grid-span-column", inputs: { editable: "editable", locked: "locked" }, providers: [
            {
                provide: ColumnBase,
                useExisting: forwardRef(() => SpanColumnComponent)
            }
        ], queries: [{ propertyName: "template", predicate: CellTemplateDirective }, { propertyName: "editTemplate", predicate: EditTemplateDirective }, { propertyName: "children", predicate: ColumnComponent }], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SpanColumnComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: ColumnBase,
                            useExisting: forwardRef(() => SpanColumnComponent)
                        }
                    ],
                    selector: 'kendo-grid-span-column',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: ColumnBase, decorators: [{
                    type: SkipSelf
                }, {
                    type: Host
                }, {
                    type: Optional
                }] }, { type: IdService, decorators: [{
                    type: Optional
                }] }], propDecorators: { template: [{
                type: ContentChildren,
                args: [CellTemplateDirective, { descendants: false }]
            }], editTemplate: [{
                type: ContentChildren,
                args: [EditTemplateDirective, { descendants: false }]
            }], children: [{
                type: ContentChildren,
                args: [ColumnComponent]
            }], editable: [{
                type: Input
            }], locked: [{
                type: Input
            }] } });

/**
 * @hidden
 */
const expandColumns = (columns) => (columns.reduce((acc, column) => acc.concat(isSpanColumnComponent(column) ? column.childrenArray : [column]), []));
/**
 * @hidden
 */
const expandColumnsWithSpan = (columns) => (columns.reduce((acc, column) => acc.concat(isSpanColumnComponent(column) ?
    [column].concat(column.childrenArray) :
    [column]), []));
/**
 * @hidden
 */
const columnsToRender = (columns) => (expandColumns(columns).filter(x => x.isVisible));
const sumProp = (prop) => (array) => (array || []).reduce((prev, curr) => prev + (curr[prop] || 0), 0);
/**
 * @hidden
 */
const sumColumnWidths = sumProp('width');
/**
 * @hidden
 */
const columnsSpan = sumProp('colspan');
const validField = new RegExp(`^[$A-Z\_a-z][$A-Z\_a-z0-9\\.]*$`);
/**
 * @hidden
 */
const isValidFieldName = (fieldName) => !isNullOrEmptyString(fieldName) && validField.test(fieldName) &&
    fieldName[0] !== "." && fieldName[fieldName.length - 1] !== ".";
/**
 * @hidden
 */
const children = column => column.children.filter(child => child !== column);
/**
 * @hidden
 */
const leafColumns = columns => {
    return columns.reduce((acc, column) => {
        if (column.isColumnGroup) {
            acc = acc.concat(leafColumns(children(column)));
        }
        else if (column.isSpanColumn) {
            acc = acc.concat(column.childrenArray);
        }
        else {
            acc.push(column);
        }
        return acc;
    }, []).filter(x => x.isVisible);
};
/**
 * @hidden
 */
const someLeafColumn = (callback, ...columns) => leafColumns(columns).some(callback);
/**
 * @hidden
 */
const resizableColumns = columns => columns.filter(column => isTruthy(column.resizable) && column.isVisible);
/**
 * @hidden
 */
const sortColumns = (columns) => orderBy(columns, [{ field: 'orderIndex', dir: 'asc' }]);
/**
 * @hidden
 */
const isInSpanColumn$1 = (column) => isTruthy(column.parent) && isSpanColumnComponent(column.parent);

/**
 * @hidden
 */
const isLocked = column => column.parent ? isLocked(column.parent) : !!column.locked;
/**
 * @hidden
 */
const resizeArgs = (column, extra) => Object.assign({
    columns: leafColumns([column]),
    locked: isLocked(column)
}, extra);
/**
 * @hidden
 */
const measure = (col, gridEl) => {
    const rowIndex = col.level + 1;
    const selector = `tr[aria-rowindex="${rowIndex}"] > th[aria-colindex="${col.leafIndex + 1}"], tr[aria-rowindex="${rowIndex}"] > th[data-kendo-grid-column-index="${col.leafIndex}"]`;
    const headerCell = gridEl.querySelector(selector);
    if (headerCell) {
        const headerCellWidth = headerCell.offsetWidth;
        if (headerCellWidth > 0) {
            return headerCellWidth;
        }
    }
    return 0;
};
/**
 * @hidden
 */
class ColumnResizingService {
    changes = new EventEmitter();
    adjacentColumn;
    areColumnsReordered = false;
    isShiftPressed = false;
    originalWidth;
    draggedGroupColumn;
    resizedColumns;
    autoFitResize = false;
    column;
    tables = [];
    batch = null;
    start(column) {
        this.trackColumns(column);
        const columns = (this.column.isColumnGroup ? [column] : [])
            .concat(leafColumns([column]));
        this.changes.emit({
            columns: columns,
            locked: isLocked(this.column),
            type: 'start'
        });
    }
    resizeColumns(deltaPercent) {
        const action = resizeArgs(this.column, {
            deltaPercent,
            type: 'resizeColumn'
        });
        this.changes.emit(action);
    }
    resizeTable(column, delta) {
        const action = resizeArgs(column, {
            delta,
            type: 'resizeTable'
        });
        this.changes.emit(action);
    }
    resizedColumn(state) {
        this.resizedColumns.push(state);
    }
    end() {
        this.changes.emit({
            columns: [],
            resizedColumns: this.resizedColumns,
            type: 'end'
        });
        this.restoreInitialMaxMinWidths();
        this.adjacentColumn = null;
        this.draggedGroupColumn = null;
        this.autoFitResize = false;
    }
    registerTable(tableMetadata) {
        this.tables.push(tableMetadata);
        const unregisterTable = () => {
            this.tables.splice(this.tables.indexOf(tableMetadata), 1);
        };
        return unregisterTable;
    }
    measureColumns(info) {
        if (this.batch !== null) {
            this.batch.push(...info);
        }
        else {
            this.autoFitBatch(info, () => this.end());
        }
    }
    autoFit(...columns) {
        const nonLockedColumns = columns.filter(column => !column.isLocked);
        this.autoFitStart(nonLockedColumns);
        this.autoFitBatch(this.batch, () => {
            if (nonLockedColumns.length < columns.length) {
                const lockedColumns = columns.filter(column => column.isLocked);
                this.autoFitStart(lockedColumns);
                this.autoFitBatch(this.batch, () => this.end());
            }
            else {
                this.end();
            }
        });
    }
    autoFitToGrid(gridEl, scrollbarWidth, ...columns) {
        const gridWidth = gridEl.clientWidth - scrollbarWidth - 1;
        if (gridWidth <= 0) {
            return;
        }
        const columnsWidths = columns.map(c => measure(c, gridEl));
        const totalColumnsWidth = columnsWidths.reduce((sum, w) => sum + w, 0);
        if (totalColumnsWidth === 0 || Math.abs(totalColumnsWidth - gridWidth) <= 1) {
            return;
        }
        this.start(columns[0]);
        const calculateNewWidths = (columnsWidths) => {
            const totalWidth = columnsWidths.reduce((s, w) => s + w, 0);
            const nonZeroColumns = columnsWidths.filter(w => w > 0).length;
            const diff = (gridWidth - totalWidth) / nonZeroColumns;
            const newWidths = columnsWidths.slice();
            newWidths.forEach((w, i) => {
                newWidths[i] = Math.max(0, w + diff);
            });
            return newWidths;
        };
        let newWidths = calculateNewWidths(columnsWidths);
        const newTotal = newWidths.reduce((s, w) => s + w, 0);
        if (newTotal !== gridWidth) {
            newWidths = calculateNewWidths(newWidths);
        }
        columns.forEach((col, idx) => {
            const oldWidth = columnsWidths[idx];
            const newWidth = newWidths[idx];
            col.width = newWidth;
            this.resizedColumn({ column: col, oldWidth, newWidth });
        });
        const totalNew = newWidths.reduce((s, w) => s + w, 0);
        const tableDelta = totalNew - totalColumnsWidth;
        if (tableDelta < 0) {
            this.resizeTable(columns[0], tableDelta);
        }
        this.end();
    }
    trackColumns(column) {
        this.resizedColumns = [];
        this.column = column;
    }
    autoFitStart(columns) {
        this.batch = [];
        this.resizedColumns = [];
        if (columns.length === 0) {
            return;
        }
        const locked = columns[0].isLocked;
        this.changes.emit({
            type: 'start',
            columns,
            locked
        });
        this.changes.emit({
            type: 'triggerAutoFit',
            columns,
            locked
        });
    }
    autoFitBatch(info, onComplete) {
        const locked = info.length > 0 ? info[0].column.isLocked : false;
        const observables = this.tables
            .filter(table => table.locked === locked)
            .map(table => table.autoFit(info));
        zip$1(...observables)
            .pipe(take(1))
            .subscribe(widths => {
            this.changes.emit({
                columns: info.map(i => i.column),
                type: 'autoFitComplete',
                widths,
                locked
            });
            if (onComplete) {
                onComplete();
            }
        });
        this.batch = null;
    }
    restoreInitialMaxMinWidths() {
        if (this.adjacentColumn) {
            this.adjacentColumn.maxResizableWidth = this.adjacentColumn.initialMaxResizableWidth;
            this.adjacentColumn.minResizableWidth = this.adjacentColumn.initialMinResizableWidth;
        }
        if (this.column) {
            this.column.maxResizableWidth = this.column.initialMaxResizableWidth;
            this.column.minResizableWidth = this.column.initialMinResizableWidth;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnResizingService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnResizingService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnResizingService, decorators: [{
            type: Injectable
        }] });

const isInSameGrid = (element, gridElement) => closest(element, matchesNodeName('kendo-grid')) === gridElement;
const matchHeaderCell = matchesNodeName('th');
const matchDataCell = matchesNodeName('td');
const matchFooterCell = matchesNodeName('.k-grid-footer td');
const matchCell = (element) => matchDataCell(element) || matchHeaderCell(element) || matchFooterCell(element);
const gridCell = (element, gridElement) => {
    let target = closest(element, matchCell);
    while (target && !isInSameGrid(target, gridElement)) {
        target = closest(target.parentElement, matchCell);
    }
    return target;
};
const targetCell = (target, gridElement) => {
    const cell = gridCell(target, gridElement);
    const row = closest(cell, matchesNodeName('tr'));
    if (cell && row) {
        let rowIndex = row.getAttribute('aria-rowindex') || row.getAttribute('data-kendo-grid-row-index');
        rowIndex = rowIndex ? parseInt(rowIndex, 10) - 1 : null;
        let colIndex = cell.getAttribute('aria-colindex');
        colIndex = colIndex ? parseInt(colIndex, 10) - 1 : null;
        if (rowIndex !== null && colIndex !== null) {
            return { colIndex, rowIndex, element: cell };
        }
    }
};
const isArrowKey = keyCode => keyCode === Keys.ArrowLeft || keyCode === Keys.ArrowRight ||
    keyCode === Keys.ArrowUp || keyCode === Keys.ArrowDown;
const isNavigationKey = keyCode => isArrowKey(keyCode) ||
    keyCode === Keys.PageUp || keyCode === Keys.PageDown ||
    keyCode === Keys.Home || keyCode === Keys.End;
const isInput = matchesNodeName('input');
const isTextInput = element => element && isInput(element) && element.type.toLowerCase() === 'text';
const isPrintableCharacter = (str) => str.length === 1 && str.match(/\S/);
const resizeStep = 10;
/**
 * @hidden
 */
class NavigationViewport {
    firstItemIndex;
    lastItemIndex;
    constructor(firstItemIndex, lastItemIndex) {
        this.firstItemIndex = firstItemIndex;
        this.lastItemIndex = lastItemIndex;
    }
    containsRow(dataRowIndex) {
        const headerRow = dataRowIndex < 0;
        return headerRow || (dataRowIndex >= this.firstItemIndex && dataRowIndex <= this.lastItemIndex);
    }
    intersects(start, end) {
        return (start <= this.firstItemIndex && this.lastItemIndex <= end) ||
            (this.firstItemIndex <= start && start <= this.lastItemIndex) ||
            (this.firstItemIndex <= end && end <= this.lastItemIndex);
    }
}
/**
 * @hidden
 */
class NavigationService {
    zone;
    domEvents;
    pagerContextService;
    scrollRequestService;
    groupsService;
    detailsService;
    focusRoot;
    editService;
    cd;
    ctx;
    resizeService;
    focusableParent;
    changes;
    cellKeydown = new EventEmitter();
    set metadata(value) {
        this.meta = value;
        this.cursor.metadata = value;
    }
    get metadata() {
        return this.meta;
    }
    get enabled() {
        return this.alive;
    }
    get pagerEnabled() {
        return this.alive && this.pagerIsNavigable;
    }
    get tableEnabled() {
        return this.alive && this.tableIsNavigable;
    }
    get toolbarEnabled() {
        return this.alive && this.toolbarIsNavigable;
    }
    get activeCell() {
        if (this.mode !== 0 /* NavigationMode.Standby */) {
            return this.cursor.cell;
        }
    }
    get activeRow() {
        if (this.mode !== 0 /* NavigationMode.Standby */) {
            return Object.assign({}, this.cursor.row, {
                cells: this.cursor.row?.cells.toArray()
            });
        }
    }
    get isColumnResizable() {
        const allColumns = Array.from(this.ctx.grid.columnsContainer.allColumns);
        const column = allColumns.find((col) => col.level === this.activeCell.rowIndex && col.leafIndex === this.activeCell.colIndex);
        if (!column.parent) {
            if (column.isColumnGroup) {
                return this.activeCell.colIndex + this.activeCell.colSpan !== this.ctx.grid.columnsContainer.leafColumnsToRender.length;
            }
            else {
                return this.activeCell.colIndex !== this.ctx.grid.columnsContainer.leafColumnsToRender.length - 1;
            }
        }
        else {
            const columnGroup = column.parent;
            const columnGroupChildren = Array.from(columnGroup.children).sort((a, b) => a.orderIndex - b.orderIndex);
            const columnIndexInsideGroup = columnGroupChildren.indexOf(column);
            if (column.isReordered || column.orderIndex > 0 || (column.isReordered && column.orderIndex === 0)) {
                return (column.orderIndex - columnGroupChildren[0]['orderIndex']) !== columnGroupChildren.length - 1;
            }
            return columnIndexInsideGroup !== columnGroupChildren.length - 1;
        }
    }
    preventScroll = false;
    viewport;
    columnViewport;
    activeRowIndex = 0;
    alive = false;
    active = true;
    mode = 0 /* NavigationMode.Standby */;
    model = new NavigationModel();
    cursor = new NavigationCursor(this.model);
    meta;
    subs;
    pendingRowIndex;
    virtualCell;
    pagerIsNavigable = false;
    tableIsNavigable = false;
    toolbarIsNavigable = false;
    lastCellRowIndex;
    isShiftPressed = false;
    currentSelection = [];
    get activeDataRow() {
        return Math.min(Math.max(0, this.activeRowIndex - this.meta.headerRows), this.meta.maxLogicalRowIndex);
    }
    constructor(zone, domEvents, pagerContextService, scrollRequestService, groupsService, detailsService, focusRoot, editService, cd, ctx, resizeService, focusableParent) {
        this.zone = zone;
        this.domEvents = domEvents;
        this.pagerContextService = pagerContextService;
        this.scrollRequestService = scrollRequestService;
        this.groupsService = groupsService;
        this.detailsService = detailsService;
        this.focusRoot = focusRoot;
        this.editService = editService;
        this.cd = cd;
        this.ctx = ctx;
        this.resizeService = resizeService;
        this.focusableParent = focusableParent;
        this.changes = this.cursor.changes;
    }
    init(meta, navigableOptions) {
        this.setActiveSections(navigableOptions);
        this.alive = true;
        this.focusRoot.active = true;
        this.metadata = meta;
        const onStableSubscriber = (...operators) => (args) => this.zone.isStable ?
            from([true]).pipe(map(() => args)) :
            this.zone.onStable.pipe(take(1), map(() => args), ...operators);
        const onStable = onStableSubscriber();
        this.subs = new Subscription();
        this.subs.add(this.cursor.changes.subscribe(args => this.onCursorChanges(args)));
        this.subs.add(this.domEvents.focus.pipe(switchMap(onStable))
            .subscribe((args) => this.navigateTo(args.target)));
        this.subs.add(this.domEvents.focusOut.pipe(filter(() => this.mode !== 0 /* NavigationMode.Standby */), switchMap(onStableSubscriber(takeUntil(this.domEvents.focus))))
            .subscribe(args => this.onFocusOut(args)));
        this.subs.add(this.domEvents.windowBlur.pipe(filter(() => this.mode !== 0 /* NavigationMode.Standby */))
            .subscribe(() => this.onWindowBlur()));
        this.subs.add(
        // Closing the editor will not always trigger focusout in Firefox.
        // To get around this, we ensure that the cell is closed after editing.
        this.editService.changes.pipe(filter(e => e.action !== 'edit' && this.mode === 2 /* NavigationMode.Content */), filter((e) => e.action === 'cellClose' && !e.prevented), switchMap(onStable))
            .subscribe((e) => {
            const isInStackedCell = closest(e.originalEvent?.target, (el) => hasClasses$1(el, 'k-grid-stack-content'));
            if (!isInStackedCell) {
                this.leaveCell();
            }
        }));
        this.subs.add(this.pagerContextService.pageChange
            .subscribe(() => this.cursor.reset(0, 0)));
        this.subs.add(this.domEvents.keydown
            .subscribe(args => this.onKeydown(args)));
        this.subs.add(this.domEvents.shiftKeyup
            .subscribe(() => {
            this.isShiftPressed = false;
        }));
        this.subs.add(this.domEvents.keydown.pipe(filter(args => args.code === Keys.Tab && this.mode === 2 /* NavigationMode.Content */), switchMapTo(this.domEvents.focusOut.pipe(takeUntil(
        // Timeout if focusOut doesn't fire very soon
        interval(0).pipe(take(1))))))
            .subscribe(() => this.onTabout()));
        this.subs.add(this.domEvents.cellClick
            .subscribe(() => {
            if (this.isStackedMode) {
                const stackedCells = this.activeCell?.focusGroup?.focusableChildren;
                if (!isPresent$1(stackedCells) || stackedCells.length === 0) {
                    return;
                }
                const currFocusedIndex = stackedCells.findIndex(el => el.hasFocus() || el.hostElement?.nativeElement === document.activeElement);
                currFocusedIndex > -1 && (this.stackedFocusedCellIndex = currFocusedIndex);
            }
        }));
        if (this.focusableParent) {
            const element = new GridFocusableElement(this);
            this.focusableParent.registerElement(element);
        }
        this.deactivateElements();
    }
    ngOnDestroy() {
        if (this.subs) {
            this.subs.unsubscribe();
        }
        this.alive = false;
    }
    registerCell(cell) {
        if (cell.logicalRowIndex !== this.pendingRowIndex) {
            const modelCell = this.model.registerCell(cell);
            if (this.virtualCell && this.cursor.activateVirtualCell(modelCell)) {
                this.virtualCell = false;
            }
        }
    }
    registerCellOnCurrentRow(cell) {
        if (cell.logicalRowIndex === this.pendingRowIndex) {
            this.model.registerCell(cell);
        }
    }
    unregisterCell(index, rowIndex, cell) {
        this.model.unregisterCell(index, rowIndex, cell);
    }
    registerRow(row) {
        this.model.registerRow(row);
        this.pendingRowIndex = row.logicalRowIndex;
    }
    updateRow(row) {
        this.model.updateRow(row);
    }
    unregisterRow(index, row) {
        this.model.unregisterRow(index, row);
        const lastRow = this.model.lastRow;
        if (lastRow && this.mode === 0 /* NavigationMode.Standby */) {
            const maxIndex = (this.needsViewport() && this.viewport) ? this.viewport.lastItemIndex : lastRow.index;
            if (this.activeRowIndex > maxIndex) {
                this.cursor.reset(0, 0);
            }
        }
    }
    isCellFocusable(cell) {
        return this.alive &&
            this.active &&
            this.mode !== 2 /* NavigationMode.Content */ &&
            this.cursor.isActive(cell.logicalRowIndex, cell.logicalColIndex);
    }
    isCellFocused(cell) {
        return this.mode === 1 /* NavigationMode.Cursor */ && this.isCellFocusable(cell);
    }
    navigateTo(el) {
        if (!this.alive || !isDocumentAvailable()) {
            return;
        }
        const cell = targetCell(el, this.meta.gridElement.nativeElement);
        if (!cell) {
            return;
        }
        const oldMode = this.mode;
        const focusInCell = contains$1(cell.element, document.activeElement);
        const focusInActiveRowContent = this.mode === 2 /* NavigationMode.Content */ &&
            this.activeRowIndex === cell.rowIndex &&
            el !== cell.element;
        if (focusInCell) {
            this.mode = 2 /* NavigationMode.Content */;
            this.cursor.reset(cell.rowIndex, cell.colIndex);
            this.activateRow();
        }
        else if (!focusInActiveRowContent) {
            this.mode = 1 /* NavigationMode.Cursor */;
            this.deactivateElements();
            const alreadyActive = this.cursor.isActive(cell.rowIndex, cell.colIndex);
            const isCursor = oldMode === 1 /* NavigationMode.Cursor */ && alreadyActive;
            if (!isCursor) {
                this.cursor.reset(cell.rowIndex, cell.colIndex);
            }
        }
    }
    tryFocus(el) {
        this.activateElements();
        const focusable = findFocusableChild(el);
        if (focusable) {
            const cell = targetCell(focusable, this.meta.gridElement.nativeElement);
            if (cell) {
                this.cursor.reset(cell.rowIndex, cell.colIndex);
                this.deactivateElements();
                this.enterCell();
            }
            this.zone.runOutsideAngular(() => {
                setTimeout(() => {
                    focusable.focus();
                });
            });
        }
        else {
            this.deactivateElements();
        }
        return !!focusable;
    }
    needsViewport() {
        return this.meta && this.meta.isVirtual;
    }
    setViewport(firstItemIndex, lastItemIndex) {
        this.viewport = new NavigationViewport(firstItemIndex, lastItemIndex);
        if (this.meta && this.meta.isVirtual && this.activeDataRow > -1) {
            const dataRowIndex = this.activeDataRow;
            const ahead = firstItemIndex - dataRowIndex;
            const behind = dataRowIndex - lastItemIndex;
            if (ahead > 0) {
                this.cursor.reset(firstItemIndex + this.meta.headerRows);
            }
            else if (behind > 0) {
                this.cursor.reset(lastItemIndex - this.meta.headerRows);
            }
        }
    }
    setColumnViewport(firstItemIndex, lastItemIndex) {
        this.columnViewport = new NavigationViewport(firstItemIndex, lastItemIndex);
        if (this.meta && this.meta.isVirtual && this.activeDataRow > -1) {
            const activeColumnIndex = this.cursor.cell ? this.cursor.cell.colIndex : 0;
            const ahead = firstItemIndex - activeColumnIndex;
            const behind = activeColumnIndex - lastItemIndex;
            if (ahead > 0) {
                this.cursor.reset(undefined, firstItemIndex, false);
            }
            else if (behind > 0) {
                this.cursor.reset(undefined, lastItemIndex, false);
            }
        }
    }
    focusCell(rowIndex = undefined, colIndex = undefined) {
        this.mode = 1 /* NavigationMode.Cursor */;
        this.cursor.reset(rowIndex, colIndex);
        return this.activeCell;
    }
    focusCellByElement(el) {
        const cell = targetCell(el, this.meta.gridElement.nativeElement);
        if (cell) {
            return this.focusCell(cell.rowIndex, cell.colIndex);
        }
    }
    focusNextCell(wrap = true) {
        return this.focusAdjacentCell(true, wrap);
    }
    focusPrevCell(wrap = true) {
        return this.focusAdjacentCell(false, wrap);
    }
    toggle(active) {
        this.active = active;
        this.cursor.announce();
    }
    hasFocus() {
        return this.mode === 1 /* NavigationMode.Cursor */ || this.mode === 2 /* NavigationMode.Content */;
    }
    autoFocusCell(start, end) {
        return !this.meta.virtualColumns || end < this.meta.columns.lockedLeafColumns.length || this.columnViewport.intersects(start, end);
    }
    setActiveSections(navigableOptions) {
        this.pagerIsNavigable = navigableOptions.includes('pager');
        this.tableIsNavigable = navigableOptions.includes('table');
        this.toolbarIsNavigable = navigableOptions.includes('toolbar');
    }
    focusAdjacentCell(fwd, wrap) {
        this.focusCell();
        let success = fwd ? this.moveCursorFwd() : this.moveCursorBwd();
        if (wrap && !success) {
            success = fwd ? this.cursor.moveDown(1) : this.cursor.moveUp(1);
            if (success) {
                const row = this.cursor.row;
                const colIdx = fwd || this.isStackedMode ? 0 : this.cursor.lastCellIndex(row);
                this.cursor.reset(row.index, colIdx);
            }
        }
        if (success) {
            return this.activeCell;
        }
        else {
            this.mode = 0 /* NavigationMode.Standby */;
            this.cursor.announce();
        }
        return null;
    }
    enterCell() {
        const cell = this.cursor.cell;
        if (!cell) {
            return;
        }
        if (this.tableCellEntered && this.isStackedMode) {
            this.stackedCellEntered = true;
        }
        else {
            this.tableCellEntered = true;
        }
        const group = cell.focusGroup;
        const focusable = group && group.canFocus();
        this.mode = focusable ? 2 /* NavigationMode.Content */ : 1 /* NavigationMode.Cursor */;
        this.cursor.announce();
        if (focusable) {
            this.activateRow();
            group.focus();
            if (this.isStackedMode && this.stackedFocusedCellIndex === -1) {
                this.stackedFocusedCellIndex = 0;
            }
        }
    }
    leaveCell() {
        const cell = this.cursor.cell;
        if (!cell) {
            return;
        }
        if (this.tableCellEntered) {
            if (this.stackedCellEntered) {
                this.stackedCellEntered = false;
            }
            else {
                this.tableCellEntered = false;
            }
        }
        const group = cell.focusGroup;
        const focusable = group && group.canFocus();
        if (!focusable) {
            this.deactivateElements();
        }
        if (this.isStackedMode && this.stackedFocusedCellIndex > -1) {
            this.stackedFocusedCellIndex = -1;
        }
        this.mode = 1 /* NavigationMode.Cursor */;
        this.cursor.announce();
    }
    activateElements() {
        this.focusRoot.activate();
    }
    deactivateElements() {
        this.focusRoot.deactivate();
    }
    activateRow() {
        this.cursor.row.cells
            .forEach(cell => cell.focusGroup && cell.focusGroup.activate());
    }
    moveCursorFwd() {
        this.lastCellRowIndex = this.activeCell?.rowIndex;
        return this.ctx.localization.rtl ? this.cursor.moveLeft() : this.cursor.moveRight();
    }
    moveCursorBwd() {
        this.lastCellRowIndex = this.activeCell?.rowIndex;
        return this.ctx.localization.rtl ? this.cursor.moveRight() : this.cursor.moveLeft();
    }
    onCursorKeydown(args) {
        let preventDefault = false;
        const modifier = args.ctrlKey || args.metaKey;
        let step = modifier ? 5 : 1;
        const rowspan = +args.target?.getAttribute('rowspan');
        let rowspanOffset = 0;
        let startNewSelection = false;
        const allowMultipleRanges = (this.ctx.grid.selectionService.active && this.ctx.grid.selectableSettings?.multipleRanges) ||
            (this.ctx.grid.cellSelectionService.active && this.ctx.grid.cellSelectionService?.options?.multipleRanges);
        if (!allowMultipleRanges) {
            this.currentSelection = [];
        }
        if (!this.onCellKeydown(args)) {
            return;
        }
        const row = this.cursor.row;
        // on some keyboards arrow keys, PageUp/Down, and Home/End are mapped to Numpad keys
        const code = normalizeKeys(args);
        // Handle row reordering keyboard shortcuts (Ctrl/Cmd + Shift + Up/Down Arrow)
        if (modifier && args.shiftKey && (code === Keys.ArrowUp || code === Keys.ArrowDown)) {
            if (this.handleRowReorderKeyboard(args, code, row)) {
                args.preventDefault();
                return;
            }
        }
        const dir = code === Keys.ArrowDown ? 'Down' : 'Up';
        const right = code === Keys.ArrowRight;
        const isArrowKey = code === Keys.ArrowDown || code === Keys.ArrowUp || code === Keys.ArrowLeft || code === Keys.ArrowRight;
        if (!this.isShiftPressed && args.shiftKey && isArrowKey) {
            startNewSelection = true;
            this.isShiftPressed = true;
        }
        const cellElement = args.target;
        const isDragCell = cellElement ? closest(cellElement, (el) => hasClasses$1(el, 'k-drag-cell')) : false;
        const isRowReorderable = this.ctx.grid.rowReorderable;
        switch (code) {
            case Keys.ArrowDown:
            case Keys.ArrowUp:
                if (rowspan > 1) {
                    rowspanOffset = this.calculateRowspanOffset(dir, rowspan);
                    step += rowspanOffset;
                }
                if (args.shiftKey && !(isDragCell && isRowReorderable)) {
                    if (this.ctx.grid.blockArrowSelection) {
                        return;
                    }
                    preventDefault = this.cursor[`move${dir}`](step);
                    const preserveCurrentSelection = startNewSelection && allowMultipleRanges;
                    if (this.activeRow?.dataItem) {
                        const sign = dir === 'Down' ? 1 : -1;
                        this.handleVerticalArrowSelection(sign * step, preserveCurrentSelection);
                    }
                }
                else {
                    preventDefault = this.cursor[`move${dir}`](step);
                }
                this.lastCellRowIndex = this.activeRowIndex;
                break;
            case Keys.ArrowRight:
            case Keys.ArrowLeft:
                if (args.altKey && this.ctx.grid.resizable && this.isColumnResizable) {
                    this.columnResize(right);
                    break;
                }
                if (args.shiftKey) {
                    if (this.ctx.grid.blockArrowSelection) {
                        return;
                    }
                    preventDefault = this[`moveCursor${right ? 'Fwd' : 'Bwd'}`]();
                    const preserveCurrentSelection = startNewSelection && allowMultipleRanges;
                    this.handleHorizontalArrowSelection(args, preserveCurrentSelection);
                }
                else {
                    preventDefault = this[`moveCursor${right ? 'Fwd' : 'Bwd'}`]();
                }
                break;
            case Keys.PageDown:
                if (this.metadata.isVirtual && this.viewport) {
                    let nextItemIndex = this.meta.headerRows + this.viewport.lastItemIndex + 1;
                    if (this.metadata.hasDetailTemplate) {
                        nextItemIndex++;
                    }
                    nextItemIndex = Math.min(this.meta.maxLogicalRowIndex, nextItemIndex);
                    this.cursor.reset(nextItemIndex);
                    preventDefault = true;
                }
                else if (this.metadata.hasPager) {
                    this.zone.run(() => this.pagerContextService.nextPage());
                    preventDefault = true;
                }
                break;
            case Keys.PageUp:
                if (this.metadata.isVirtual && this.viewport) {
                    const viewportSize = this.viewport.lastItemIndex - this.viewport.firstItemIndex;
                    const firstItemIndex = this.viewport.firstItemIndex;
                    const nextItemIndex = Math.max(this.meta.headerRows, firstItemIndex - viewportSize - 1);
                    this.cursor.reset(nextItemIndex);
                    preventDefault = true;
                }
                else if (this.metadata.hasPager) {
                    this.zone.run(() => this.pagerContextService.prevPage());
                    preventDefault = true;
                }
                break;
            case Keys.Home:
                if (modifier) {
                    if (this.meta.isVirtual) {
                        this.cursor.reset(this.meta.headerRows, 0, false);
                    }
                    else {
                        this.cursor.reset(this.model.firstRow.index, 0, false);
                    }
                }
                else {
                    let firstColumnIndex = 0;
                    if (this.meta.hasDetailTemplate && row.index < this.meta.headerRows) {
                        firstColumnIndex = 1;
                    }
                    this.cursor.reset(row.index, firstColumnIndex, false);
                }
                preventDefault = true;
                break;
            case Keys.End:
                if (modifier) {
                    if (this.meta.isVirtual) {
                        let lastRowIndex = this.meta.maxLogicalRowIndex;
                        if (this.meta.hasDetailTemplate) {
                            lastRowIndex--;
                        }
                        this.cursor.reset(lastRowIndex, this.cursor.lastCellIndex(), false);
                    }
                    else {
                        this.cursor.reset(this.model.lastRow.index, this.cursor.lastCellIndex(this.model.lastRow), false);
                    }
                }
                else {
                    const lastIndex = this.cursor.lastCellIndex(row);
                    const cell = this.model.findCell(lastIndex, row);
                    if (cell) {
                        this.cursor.reset(cell.rowIndex, cell.colIndex);
                    }
                    else {
                        this.cursor.reset(row.index, lastIndex);
                    }
                }
                preventDefault = true;
                break;
            case Keys.Enter:
            case Keys.F2: {
                if (this.stackedCellEntered) {
                    if (code === Keys.F2 && row.dataRowIndex > -1) {
                        this.zone.run(() => {
                            this.editService.beginEdit(row.dataRowIndex);
                        });
                        this.enterCell();
                    }
                    break;
                }
                const groupItem = row.groupItem;
                if (groupItem) {
                    this.zone.run(() => this.groupsService.toggleRow(groupItem));
                }
                else if (this.cursor.cell.detailExpandCell) {
                    this.zone.run(() => this.detailsService.toggleRow(row.dataRowIndex, row.dataItem));
                }
                else {
                    if (code === Keys.F2 && row.dataRowIndex > -1) {
                        this.zone.run(() => {
                            this.editService.beginEdit(row.dataRowIndex);
                        });
                    }
                    this.enterCell();
                    if (!this.cursor.cell.focusGroup.isNavigable()) {
                        preventDefault = true;
                    }
                }
                break;
            }
            case Keys.Backspace:
            case Keys.Delete:
                if (this.activeRow && this.activeRow.dataRowIndex >= 0 && this.activeRow.dataItem) {
                    if (!row.groupItem && !this.cursor.cell.detailExpandCell) {
                        this.zone.run(() => {
                            this.editService.remove(this.activeRow.dataRowIndex);
                        });
                        preventDefault = true;
                    }
                }
                break;
            default:
                if (!args.ctrlKey && !args.altKey && isPrintableCharacter(args.key)) {
                    this.enterCell();
                }
        }
        if (preventDefault) {
            args.preventDefault();
        }
    }
    columnResize(onRightArrow) {
        const column = this.ctx.grid.columnsContainer.allColumns.find((col) => col.level === this.activeCell.rowIndex && col.leafIndex === this.activeCell.colIndex);
        this.resizeService.start(column);
        this.resizeService.resizeColumns(onRightArrow ? resizeStep : -1 * resizeStep);
        if (this.resizeService.resizeColumns.length > 0) {
            this.resizeService.end();
        }
    }
    onContentKeydown(args) {
        if (!this.onCellKeydown(args)) {
            return;
        }
        // on some keyboards arrow keys, PageUp/Down, and Home/End are mapped to Numpad keys
        const code = normalizeKeys(args);
        const confirm = !args.defaultPrevented && code === Keys.Enter && isTextInput(args.target);
        if (code === Keys.Escape || code === Keys.F2 || confirm) {
            if (this.tableCellEntered && code === Keys.F2 && this.activeRow.dataRowIndex > -1) {
                this.zone.run(() => {
                    this.editService.beginEdit(this.activeRow.dataRowIndex);
                });
                this.enterCell();
                return;
            }
            this.leaveCell();
            this.cursor.reset();
            args.stopPropagation();
        }
        else if (isNavigationKey(code) && this.cursor.cell.focusGroup.isNavigable()) {
            this.onCursorKeydown(args);
            if (args.defaultPrevented) {
                this.leaveCell();
            }
        }
    }
    onCellKeydown(args) {
        if (this.editService.isEditingCell()) {
            // on some keyboards arrow keys, PageUp/Down, and Home/End are mapped to Numpad keys
            const code = normalizeKeys(args);
            const confirm = code === Keys.Enter;
            const cancel = code === Keys.Escape;
            const navigate = isNavigationKey(code);
            if (confirm) {
                this.editService.closeCell(args);
            }
            else if (cancel) {
                this.editService.closeCell(args);
                this.cd.detectChanges();
            }
            else if (navigate) {
                return false;
            }
        }
        this.cellKeydown.emit(args);
        return true;
    }
    onCursorChanges(args) {
        this.activeRowIndex = args.rowIndex;
        const dataRowIndex = this.activeDataRow;
        if (this.meta && (this.meta.isVirtual &&
            args.rowIndex >= this.meta.headerRows &&
            args.rowIndex <= this.meta.maxLogicalRowIndex - this.meta.footerRow &&
            this.viewport &&
            !this.viewport.containsRow(dataRowIndex) &&
            dataRowIndex > -1)) {
            this.scrollRequestService.scrollTo({ row: dataRowIndex });
        }
        if (this.meta.virtualColumns && args.colIndex >= this.meta.columns.lockedLeafColumns.length) {
            const cell = this.activeCell;
            const { start, end } = this.model.cellRange(cell);
            if (!cell) {
                this.virtualCell = true;
            }
            if ((!cell && this.mode !== 0 /* NavigationMode.Standby */) || (cell && !this.columnViewport.intersects(start, end))) {
                this.scrollRequestService.scrollTo({ column: args.colIndex - (this.metadata.hasDetailTemplate ? 1 : 0) });
            }
        }
    }
    onFocusOut(args) {
        if (isVisible(args.target)) {
            this.mode = 0 /* NavigationMode.Standby */;
        }
        else {
            // Focused target is no longer visible,
            // reset to cursor mode and recapture focus.
            this.mode = 1 /* NavigationMode.Cursor */;
        }
        this.deactivateElements();
        this.cursor.announce();
    }
    onWindowBlur() {
        this.mode = 0 /* NavigationMode.Standby */;
        this.deactivateElements();
        this.cursor.announce();
    }
    onKeydown(args) {
        if (this.isStackedMode) {
            this.handleStackedKeydown(args);
            if (args.defaultPrevented) {
                return;
            }
        }
        if (this.mode === 1 /* NavigationMode.Cursor */) {
            this.onCursorKeydown(args);
        }
        else if (this.mode === 2 /* NavigationMode.Content */) {
            this.onContentKeydown(args);
        }
    }
    onTabout() {
        // Tabbed out of the last focusable content element
        // reset to cursor mode and recapture focus.
        if (this.cursor.cell?.focusGroup.isNavigable()) {
            // Unless the cell has a single focusable element,
            // otherwise we'd return to Content mode and enter an endless loop
            return;
        }
        this.leaveCell();
        this.cursor.reset();
    }
    handleVerticalArrowSelection(args, preserveSelection) {
        const cellSelectionEnabled = this.ctx.grid.cellSelectionService.active;
        const rowSelectionEnabled = this.ctx.grid.selectionService.active && !this.ctx.grid.selectableSettings.checkboxOnly;
        if (cellSelectionEnabled || rowSelectionEnabled) {
            const selectionService = this.ctx.grid[cellSelectionEnabled ? 'cellSelectionService' : 'selectionService'];
            const colIdx = this.cursor.cell ? this.cursor.cell.colIndex : 0;
            const rowIdx = this.activeRow.dataRowIndex - this.ctx.grid.skip;
            const dataItem = selectionService.settings.view.at(rowIdx);
            const item = { index: this.activeRow.dataRowIndex, data: dataItem, column: this.ctx.grid.columnsContainer.leafColumnsToRender[colIdx] };
            if (selectionService.options.mode === 'multiple') {
                const startRowIndex = this.activeRow.dataRowIndex - args;
                cellSelectionEnabled ? this.handleMultipleArrowCellSelection(item, preserveSelection, startRowIndex, colIdx) : this.handleMultipleArrowRowSelection(item, preserveSelection, startRowIndex);
            }
            else {
                selectionService.handleClick(item, args);
            }
        }
    }
    handleHorizontalArrowSelection(args, preserveSelection) {
        const cellSelectionEnabled = this.ctx.grid.cellSelectionService.active;
        if (cellSelectionEnabled) {
            const selectionService = this.ctx.grid[cellSelectionEnabled ? 'cellSelectionService' : 'selectionService'];
            const row = this.activeRow;
            const colIdx = this.cursor.cell ? this.cursor.cell.colIndex : 0;
            const dataItem = selectionService.settings.view.at(row.dataRowIndex - this.ctx.grid.skip);
            const item = { index: row.dataRowIndex, data: dataItem, column: this.ctx.grid.columnsContainer.leafColumnsToRender[colIdx] };
            if (!isPresent$1(dataItem) || !isPresent$1(item.column)) {
                return;
            }
            if (selectionService.options.mode === 'multiple') {
                const startColumnIndex = args.key === 'ArrowRight' ? colIdx - 1 : colIdx + 1;
                this.handleMultipleArrowCellSelection(item, preserveSelection, row.dataRowIndex, startColumnIndex);
            }
            else {
                selectionService.handleClick(item, args);
            }
        }
    }
    handleMultipleArrowCellSelection(item, preserveSelection, startRow, startColumn) {
        const cellSelectionService = this.ctx.grid.cellSelectionService;
        const startRowIndex = preserveSelection ? startRow : Math.min(cellSelectionService.lastSelectionItemRowIndex, item.index);
        const startColIndex = preserveSelection ? startColumn : Math.min(cellSelectionService.lastSelectionItemColIndex, item.column.leafIndex);
        const endRowIndex = preserveSelection ? item.index : Math.max(cellSelectionService.lastSelectionItemRowIndex, item.index);
        const endColIndex = preserveSelection ? item.column.leafIndex : Math.max(cellSelectionService.lastSelectionItemColIndex, item.column.leafIndex);
        if (preserveSelection) {
            cellSelectionService.lastSelectionItemRowIndex = startRow;
            cellSelectionService.lastSelectionItemColIndex = startColumn;
            this.currentSelection = cellSelectionService.currentSelection;
        }
        const ev = cellSelectionService.selectRange(startRowIndex, startColIndex, endRowIndex, endColIndex, preserveSelection, this.currentSelection);
        cellSelectionService.changes.emit(ev);
    }
    handleMultipleArrowRowSelection(item, preserveSelection, startRow) {
        const rowSelectionService = this.ctx.grid.selectionService;
        const startRowIndex = preserveSelection ? startRow : Math.min(rowSelectionService.lastSelectionStartIndex, item.index);
        const endRowIndex = preserveSelection ? item.index : Math.max(rowSelectionService.lastSelectionStartIndex, item.index);
        if (preserveSelection) {
            rowSelectionService.lastSelectionStartIndex = startRow;
            this.currentSelection = rowSelectionService.currentSelection;
        }
        const ev = rowSelectionService.selectRange(startRowIndex, endRowIndex, preserveSelection, this.currentSelection);
        rowSelectionService.changes.emit(ev);
    }
    calculateRowspanOffset(direction, cellRowspan) {
        if (!isPresent$1(this.lastCellRowIndex)) {
            return 0;
        }
        const offset = direction === 'Up' ? Math.abs(this.lastCellRowIndex - this.activeRowIndex) : (this.activeRowIndex + cellRowspan - this.lastCellRowIndex - 1);
        return offset;
    }
    get isStackedMode() {
        return this.ctx?.grid?.isStacked;
    }
    handleRowReorderKeyboard(args, code, row) {
        if (!this.ctx.grid.rowReorderable || !this.activeCell) {
            return false;
        }
        const cell = this.activeCell;
        const cellElement = args.target;
        if (!cellElement) {
            return false;
        }
        const dragCell = closest(cellElement, (el) => hasClasses$1(el, 'k-drag-cell'));
        if (!dragCell || row.dataRowIndex < 0 || !row.dataItem) {
            return false;
        }
        const isUpArrow = code === Keys.ArrowUp;
        const currentRowIndex = row.dataRowIndex;
        const data = this.ctx.grid.flatData;
        if (!data || data.length === 0) {
            return false;
        }
        const targetRowIndex = currentRowIndex + (isUpArrow ? -1 : 1);
        if (targetRowIndex < 0 || targetRowIndex >= data.length) {
            return false;
        }
        const dropPosition = isUpArrow ? 'before' : 'after';
        this.zone.run(() => {
            const skip = this.ctx.grid.skip || 0;
            this.ctx.grid.rowReorderService.reorderViaKeyboard(currentRowIndex + skip, targetRowIndex + skip, dropPosition, data);
            // Move focus to follow the reordered row
            // After reordering, the row will be at the target position
            this.zone.onStable.pipe(take(1)).subscribe(() => {
                const newRowIndex = this.meta.headerRows + targetRowIndex;
                this.cursor.reset(newRowIndex, cell.colIndex);
            });
        });
        return true;
    }
    handleStackedKeydown(args) {
        const target = args.target;
        const stackedCell = closest(target, (el) => hasClasses$1(el, 'k-grid-stack-cell'));
        const tableCell = closest(target, (el) => hasClasses$1(el, 'k-table-td'));
        const isInStackedCell = closest(target, (el) => hasClasses$1(el, 'k-grid-stack-content'));
        const isInCommandCell = closest(target, (el) => hasClasses$1(el, 'k-command-cell'));
        if (!stackedCell || !tableCell) {
            return;
        }
        if (args.code === Keys.Tab) {
            this.handleStackedTabNavigation(args);
        }
        else if (args.code === Keys.Backspace || args.code === Keys.Delete) {
            if (this.stackedCellEntered || this.editService.isEditing()) {
                return;
            }
            if (this.activeRow && this.activeRow.dataRowIndex >= 0 && this.activeRow.dataItem) {
                const row = this.cursor.row;
                if (!row.groupItem && !this.cursor.cell.detailExpandCell) {
                    this.zone.run(() => {
                        this.editService.remove(this.activeRow.dataRowIndex);
                    });
                    args.preventDefault();
                }
            }
        }
        else if (isInStackedCell && (args.code === Keys.Enter || args.code === Keys.NumpadEnter || args.code === Keys.Escape)) {
            this.editService.closeCell(args);
            this.activeCell.focusGroup.activate();
            this.activeCell.focusGroup.focusableChildren[this.stackedFocusedCellIndex]?.focus();
            if (!isInCommandCell) {
                args.preventDefault();
            }
        }
    }
    stackedFocusedCellIndex = -1;
    tableCellEntered = false;
    stackedCellEntered = false;
    handleStackedTabNavigation(args) {
        if (!isPresent$1(this.activeCell?.focusGroup)) {
            return;
        }
        if (this.stackedFocusedCellIndex === -1) {
            return;
        }
        const stackedCells = this.activeCell?.focusGroup?.focusableChildren;
        if (!isPresent$1(stackedCells) || stackedCells.length === 0) {
            return;
        }
        const currFocusedIndex = stackedCells.findIndex(el => el.hasFocus() || el.hostElement?.nativeElement === document.activeElement);
        if (args.shiftKey) {
            if (currFocusedIndex === 0) {
                args.stopImmediatePropagation();
                args.preventDefault();
            }
            else {
                this.stackedFocusedCellIndex = currFocusedIndex - 1;
            }
        }
        else {
            if (currFocusedIndex === stackedCells.length - 1) {
                args.stopImmediatePropagation();
                args.preventDefault();
            }
            else {
                this.stackedFocusedCellIndex = currFocusedIndex + 1;
            }
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: NavigationService, deps: [{ token: i0.NgZone }, { token: DomEventsService }, { token: i53.PagerContextService }, { token: ScrollRequestService }, { token: GroupsService }, { token: DetailsService }, { token: FocusRoot }, { token: EditService }, { token: i0.ChangeDetectorRef }, { token: ContextService }, { token: ColumnResizingService }, { token: FocusableDirective, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: NavigationService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: NavigationService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: i0.NgZone }, { type: DomEventsService }, { type: i53.PagerContextService }, { type: ScrollRequestService }, { type: GroupsService }, { type: DetailsService }, { type: FocusRoot }, { type: EditService }, { type: i0.ChangeDetectorRef }, { type: ContextService }, { type: ColumnResizingService }, { type: FocusableDirective, decorators: [{
                    type: Optional
                }] }] });

/**
 * @hidden
 */
const preventOnDblClick$1 = release => mouseDown => of(mouseDown).pipe(delay(150), takeUntil(release));
const hasClass = className => el => new RegExp(`(^| )${className}( |$)`).test(el.className);
const isDeleteButton = or(hasClass('k-i-x'), hasClass('k-svg-i-x'), hasClass('k-icon-button'));
const isSortIcon = or(hasClass('k-i-sort-asc-small'), hasClass('k-i-sort-desc-small'), hasClass('k-svg-i-sort-asc-small'), hasClass('k-svg-i-sort-desc-small'));
const skipButtons = and(not(isDeleteButton), not(isSortIcon), not(isFocusableWithTabKey), not(matchesNodeName('label')));
const elementUnderCursor = ({ clientX, clientY }) => isDocumentAvailable() && document.elementFromPoint(clientX, clientY);
const hideThenShow = (element, cont) => {
    element.style.display = 'none';
    const result = cont();
    element.style.display = 'block';
    return result;
};
/**
 * @hidden
 */
class DraggableColumnDirective {
    draggable;
    element;
    zone;
    service;
    hint;
    cue;
    nav;
    renderer;
    context = {};
    set enableDrag(enabled) {
        this.enabled = enabled;
        this.updateTouchAction();
    }
    drag = new EventEmitter();
    subscriptions = new Subscription();
    enabled;
    constructor(draggable, element, zone, service, hint, cue, nav, renderer) {
        this.draggable = draggable;
        this.element = element;
        this.zone = zone;
        this.service = service;
        this.hint = hint;
        this.cue = cue;
        this.nav = nav;
        this.renderer = renderer;
    }
    ngOnInit() {
        this.subscriptions.add(this.zone.runOutsideAngular(() => this.draggable.kendoPress.pipe(filter(() => this.enabled), filter(({ originalEvent: { target } }) => target === this.element.nativeElement || skipButtons(target)), tap((e) => {
            const originalEvent = e.originalEvent;
            if (!e.isTouch) {
                originalEvent.preventDefault();
            }
            this.nav.navigateTo(originalEvent.target);
        }), switchMap(preventOnDblClick$1(this.draggable.kendoRelease)), tap(() => {
            this.hint.create(this.context.hint);
            this.cue.create();
        }), switchMap(down => this.draggable.kendoDrag.pipe(tap((e) => {
            if (e.isTouch) {
                e.originalEvent.preventDefault();
            }
        }), tap(this.hint.attach()), tap(this.cue.attach()), takeUntil(this.draggable.kendoRelease), map(move => ({ move, down })))), tap(this.performDrag.bind(this)), switchMapTo(this.draggable.kendoRelease)).subscribe(this.drop.bind(this))));
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    }
    drop(upEvent) {
        this.hint.remove();
        this.cue.remove();
        this.service.notifyDrop(this, upEvent);
    }
    performDrag({ move }) {
        this.hint.move(move);
        const cursorElement = this.elementUnderCursor(move);
        if (cursorElement) {
            this.service.notifyDrag(this, cursorElement, move);
        }
        this.drag.emit({
            draggable: this,
            mouseEvent: move
        });
    }
    elementUnderCursor(mouseEvent) {
        this.hint.hide();
        let target = elementUnderCursor(mouseEvent);
        if (target && /k-grouping-dropclue/.test(target.className)) {
            target = hideThenShow(target, elementUnderCursor.bind(this, mouseEvent));
        }
        this.hint.show();
        return target;
    }
    updateTouchAction() {
        if (!this.element) {
            return;
        }
        // eslint-disable-next-line no-unused-expressions
        this.enabled ? this.renderer.addClass(this.element.nativeElement, 'k-touch-action-none') :
            this.renderer.removeClass(this.element.nativeElement, 'k-touch-action-none');
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DraggableColumnDirective, deps: [{ token: i1$3.DraggableDirective, host: true }, { token: i0.ElementRef }, { token: i0.NgZone }, { token: DragAndDropService }, { token: DragHintService }, { token: DropCueService }, { token: NavigationService }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: DraggableColumnDirective, isStandalone: true, selector: "[kendoDraggableColumn]", inputs: { context: "context", enableDrag: "enableDrag" }, outputs: { drag: "drag" }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DraggableColumnDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoDraggableColumn]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1$3.DraggableDirective, decorators: [{
                    type: Host
                }] }, { type: i0.ElementRef }, { type: i0.NgZone }, { type: DragAndDropService }, { type: DragHintService }, { type: DropCueService }, { type: NavigationService }, { type: i0.Renderer2 }], propDecorators: { context: [{
                type: Input
            }], enableDrag: [{
                type: Input
            }], drag: [{
                type: Output
            }] } });

/**
 * @hidden
 */
class DropTargetDirective {
    element;
    service;
    context = {};
    enter = new EventEmitter();
    leave = new EventEmitter();
    drop = new EventEmitter();
    subscriptions = new Subscription();
    constructor(element, service) {
        this.element = element;
        this.service = service;
    }
    ngOnInit() {
        this.service.add(this);
        const changes = this.service.changes.pipe(filter(({ target }) => target === this));
        this.subscriptions.add(changes.pipe(filter(({ type }) => type === 'leave'))
            .subscribe(e => {
            this.leave.next(this.eventArgs(e));
        }));
        this.subscriptions.add(changes.pipe(filter(({ type }) => type === 'enter'))
            .subscribe(e => {
            this.enter.next(this.eventArgs(e));
        }));
        this.subscriptions.add(changes.pipe(filter(({ type }) => type === 'drop'))
            .subscribe(e => {
            this.drop.next(this.eventArgs(e));
        }));
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    }
    eventArgs(e) {
        return {
            target: this,
            mouseEvent: e.mouseEvent,
            draggable: e.draggable
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DropTargetDirective, deps: [{ token: i0.ElementRef }, { token: DragAndDropService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: DropTargetDirective, isStandalone: true, selector: "[kendoDropTarget]", inputs: { context: "context" }, outputs: { enter: "enter", leave: "leave", drop: "drop" }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DropTargetDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoDropTarget]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: DragAndDropService }], propDecorators: { context: [{
                type: Input
            }], enter: [{
                type: Output
            }], leave: [{
                type: Output
            }], drop: [{
                type: Output
            }] } });

/**
 * @hidden
 */
function isColumnGroupComponent(column) {
    return column.isColumnGroup;
}
/**
 * Represents the column group header of the Grid ([more information and examples](slug:multicolumnheaders_columns_grid)).
 *
 * Use this component to group columns under a common header.
 *
 * @example
 * ```html
 * <kendo-grid [data]="gridData">
 *   <kendo-grid-column-group title="Product Info">
 *     <kendo-grid-column field="ProductID"></kendo-grid-column>
 *     <kendo-grid-column field="ProductName"></kendo-grid-column>
 *   </kendo-grid-column-group>
 *   <kendo-grid-column field="UnitPrice"></kendo-grid-column>
 * </kendo-grid>
 * ```
 */
class ColumnGroupComponent extends ColumnBase {
    parent;
    /**
     * @hidden
     */
    includeInChooser = false;
    /**
     * @hidden
     */
    isColumnGroup = true;
    /**
     * @hidden
     */
    minResizableWidth = 10;
    /**
     * @hidden
     */
    maxResizableWidth;
    /**
     * @hidden
     */
    children;
    constructor(parent, idService) {
        super(parent, idService);
        this.parent = parent;
        if (parent && parent.isSpanColumn) {
            throw new Error(ColumnConfigurationErrorMessages.nestedInside('ColumnGroupComponent', 'SpanColumnComponent'));
        }
    }
    /**
     * @hidden
     */
    rowspan() {
        return 1;
    }
    /**
     * @hidden
     *
     * Used to hide the cellRowspan property from the public API.
     */
    set cellRowspan(cellRowSpan) {
        super.cellRowspan = cellRowSpan;
    }
    /**
     * @hidden
     */
    get colspan() {
        if (!this.children) {
            return 1;
        }
        return columnsSpan(this.children
            .filter(child => child !== this && child.isVisible));
    }
    /**
     * @hidden
     */
    get leafIndex() {
        return this.children ? (this.firstChild || {}).leafIndex : -1;
    }
    get childrenArray() {
        return this.children.filter(c => c !== this);
    }
    get hasChildren() {
        return Boolean(this.firstChild);
    }
    get firstChild() {
        return this.children.find(column => column !== this);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnGroupComponent, deps: [{ token: ColumnBase, host: true, optional: true, skipSelf: true }, { token: IdService, optional: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: ColumnGroupComponent, isStandalone: true, selector: "kendo-grid-column-group", providers: [
            {
                provide: ColumnBase,
                useExisting: forwardRef(() => ColumnGroupComponent)
            }
        ], queries: [{ propertyName: "children", predicate: ColumnBase }], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnGroupComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: ColumnBase,
                            useExisting: forwardRef(() => ColumnGroupComponent)
                        }
                    ],
                    selector: 'kendo-grid-column-group',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: ColumnBase, decorators: [{
                    type: SkipSelf
                }, {
                    type: Host
                }, {
                    type: Optional
                }] }, { type: IdService, decorators: [{
                    type: Optional
                }] }], propDecorators: { children: [{
                type: ContentChildren,
                args: [ColumnBase]
            }] } });

/**
 * Represents the detail template of the Grid ([more information and examples]({% slug detailrowtemplate_grid %})).
 * Nest an `<ng-template>` tag with the `kendoGridDetailTemplate` directive inside a `<kendo-grid>` tag to define the detail template.
 *
 * @example
 * ```html
 * <kendo-grid [data]="data" selectable="true" style="height: 160px">
 *    <kendo-grid-column field="ProductName"></kendo-grid-column>
 *    <ng-template kendoGridDetailTemplate let-dataItem>
 *       @if (dataItem.Category) {
 *         <div>
 *            <header>{{dataItem.Category?.CategoryName}}</header>
 *            <span>{{dataItem.Category?.Description}}</span>
 *         </div>
 *       }
 *    </ng-template>
 * </kendo-grid>
 * ```
 *
 */
class DetailTemplateDirective {
    templateRef;
    /**
     * Sets a function to decide if the detail row and the **Expand** or **Collapse** button display for a data item.
     * The function receives the data item and its index.
     */
    set showIf(fn) {
        if (typeof fn !== 'function') {
            throw new Error(GridConfigurationErrorMessages.functionType('showIf', fn));
        }
        this._condition = fn;
    }
    get showIf() {
        return this._condition;
    }
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    _condition = () => true;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DetailTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: DetailTemplateDirective, isStandalone: true, selector: "[kendoGridDetailTemplate]", inputs: { showIf: ["kendoGridDetailTemplateShowIf", "showIf"] }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DetailTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridDetailTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }], propDecorators: { showIf: [{
                type: Input,
                args: ["kendoGridDetailTemplateShowIf"]
            }] } });

/**
 * @hidden
 */
class ColGroupComponent {
    ctx;
    columns = [];
    groups = [];
    detailTemplate;
    sort = new Array();
    constructor(ctx) {
        this.ctx = ctx;
    }
    getColumnWidth(column) {
        const columnWidth = isPresent$1(column.width) ? `${column.width}px` : undefined;
        return this.isStacked ? '100%' : columnWidth;
    }
    get columnsToRender() {
        return this.isStacked ? [new ColumnBase()] : columnsToRender(this.columns);
    }
    get isStacked() {
        return this.ctx.grid?.isStacked;
    }
    trackBy(index) {
        return index;
    }
    isSorted(column) {
        const state = this.sortDescriptor(column.field);
        return this.isSortable(column) && (state.dir === 'asc' || state.dir === 'desc');
    }
    getColumnComponent(column) {
        return column;
    }
    isSortable(column) {
        return !isNullOrEmptyString(column.field) && isTruthy(column.sortable);
    }
    sortDescriptor(field) {
        return this.sort.find(item => item.field === field) || { field };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColGroupComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: ColGroupComponent, isStandalone: true, selector: "[kendoGridColGroup]", inputs: { columns: "columns", groups: "groups", detailTemplate: "detailTemplate", sort: "sort" }, ngImport: i0, template: `
    <ng-container>
      @for (g of groups; track g) {
        <col [class.k-group-col]="true" />
      }
      @if (detailTemplate?.templateRef && !isStacked) {
        <col [class.k-hierarchy-col]="true"/>
      }
      @for (column of columnsToRender; track $index) {
        <col
          [style.width]="getColumnWidth(column)"
          [class.k-sorted]="isSorted(getColumnComponent(column))"/>
      }
    </ng-container>
    `, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColGroupComponent, decorators: [{
            type: Component,
            args: [{
                    selector: '[kendoGridColGroup]',
                    template: `
    <ng-container>
      @for (g of groups; track g) {
        <col [class.k-group-col]="true" />
      }
      @if (detailTemplate?.templateRef && !isStacked) {
        <col [class.k-hierarchy-col]="true"/>
      }
      @for (column of columnsToRender; track $index) {
        <col
          [style.width]="getColumnWidth(column)"
          [class.k-sorted]="isSorted(getColumnComponent(column))"/>
      }
    </ng-container>
    `,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: ContextService }], propDecorators: { columns: [{
                type: Input
            }], groups: [{
                type: Input
            }], detailTemplate: [{
                type: Input
            }], sort: [{
                type: Input
            }] } });

/**
 * Lets you override the default loading indicator of the Grid.
 * Place an `<ng-template>` tag with the `kendoGridLoadingTemplate` directive inside `<kendo-grid>` to define a loading template. ([See example](slug:loadingtemplate_grid)).
 *
 * @example
 * ```html
 * <kendo-grid [data]="gridData" [loading]="true">
 *   <ng-template kendoGridLoadingTemplate>
 *     <div class="custom-loading-indicator">
 *       Loading data, please wait...
 *     </div>
 *   </ng-template>
 *   <kendo-grid-column field="ProductName"></kendo-grid-column>
 *   <kendo-grid-column field="UnitPrice"></kendo-grid-column>
 * </kendo-grid>
 * ```
 */
class LoadingTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: LoadingTemplateDirective, deps: [{ token: i0.TemplateRef }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: LoadingTemplateDirective, isStandalone: true, selector: "[kendoGridLoadingTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: LoadingTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridLoadingTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef }] });

/**
 * @hidden
 */
class LoadingComponent {
    ctx;
    hostClass = true;
    loadingTemplate;
    get loadingText() {
        return this.ctx.localization.get('loading');
    }
    constructor(ctx) {
        this.ctx = ctx;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: LoadingComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: LoadingComponent, isStandalone: true, selector: "[kendoGridLoading]", inputs: { loadingTemplate: "loadingTemplate" }, host: { properties: { "class.k-loading-mask": "this.hostClass" } }, ngImport: i0, template: `
        @if (!loadingTemplate) {
          <span class="k-loading-text">{{ loadingText }}</span>
          <div class="k-loading-image"></div>
          <div class="k-loading-color"></div>
        }
        @if (loadingTemplate) {
          <ng-template [ngTemplateOutlet]="loadingTemplate?.templateRef">
          </ng-template>
        }
        `, isInline: true, dependencies: [{ kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: LoadingComponent, decorators: [{
            type: Component,
            args: [{
                    selector: '[kendoGridLoading]',
                    template: `
        @if (!loadingTemplate) {
          <span class="k-loading-text">{{ loadingText }}</span>
          <div class="k-loading-image"></div>
          <div class="k-loading-color"></div>
        }
        @if (loadingTemplate) {
          <ng-template [ngTemplateOutlet]="loadingTemplate?.templateRef">
          </ng-template>
        }
        `,
                    standalone: true,
                    imports: [NgTemplateOutlet]
                }]
        }], ctorParameters: () => [{ type: ContextService }], propDecorators: { hostClass: [{
                type: HostBinding,
                args: ['class.k-loading-mask']
            }], loadingTemplate: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class ResizeService {
    resizeSubscription = new Subscription(() => { });
    dispatcher = new Subject();
    changes = this.dispatcher.asObservable().pipe(throttleTime(100));
    connect(resizes) {
        this.resizeSubscription.add(resizes.subscribe(this.dispatcher));
    }
    destroy() {
        if (this.resizeSubscription) {
            this.resizeSubscription.unsubscribe();
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ResizeService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ResizeService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ResizeService, decorators: [{
            type: Injectable
        }] });

/**
 * @hidden
 */
class ResizableContainerDirective {
    el;
    renderer;
    resizeService;
    ctx;
    _lockedWidth;
    set lockedWidth(value) {
        this._lockedWidth = value;
        if (this.enabled) {
            this.attachResize();
            this.resize();
        }
    }
    set kendoGridResizableContainer(enabled) {
        const refresh = enabled !== this.enabled;
        this.enabled = enabled;
        if (refresh) {
            this.attachResize();
            this.resize();
        }
    }
    enabled = false;
    resizeSubscription;
    constructor(el, renderer, resizeService, ctx) {
        this.el = el;
        this.renderer = renderer;
        this.resizeService = resizeService;
        this.ctx = ctx;
    }
    ngOnDestroy() {
        if (this.resizeSubscription) {
            this.resizeSubscription.unsubscribe();
        }
    }
    attachResize() {
        if (this.resizeSubscription && !this.enabled) {
            this.resizeSubscription.unsubscribe();
            this.resizeSubscription = null;
        }
        if (!this.resizeSubscription && this.enabled) {
            this.resizeSubscription = this.resizeService.changes.subscribe(this.resize.bind(this));
        }
    }
    resize() {
        if (this.ctx.grid && this.ctx.grid.wrapper) {
            const containerElement = this.ctx.grid.wrapper.nativeElement;
            const width = Math.max(containerElement.clientWidth - this._lockedWidth, 0);
            if (this.enabled && width > 0) {
                this.renderer.setStyle(this.el.nativeElement, "width", width + "px");
            }
            else {
                this.renderer.setStyle(this.el.nativeElement, "width", "");
            }
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ResizableContainerDirective, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }, { token: ResizeService }, { token: ContextService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: ResizableContainerDirective, isStandalone: true, selector: "[kendoGridResizableContainer]", inputs: { lockedWidth: "lockedWidth", kendoGridResizableContainer: "kendoGridResizableContainer" }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ResizableContainerDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridResizableContainer]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: ResizeService }, { type: ContextService }], propDecorators: { lockedWidth: [{
                type: Input,
                args: ['lockedWidth']
            }], kendoGridResizableContainer: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class FocusGroup {
    root;
    active = true;
    children = [];
    get focusableChildren() {
        return this.children.filter(el => el.canFocus());
    }
    get isActive() {
        return this.active;
    }
    constructor(root) {
        this.root = root;
        this.root.registerGroup(this);
    }
    ngOnDestroy() {
        this.root.unregisterGroup(this);
        this.active = true;
    }
    registerElement(element) {
        this.unregisterElement(element);
        this.children.push(element);
    }
    unregisterElement(element) {
        this.children = this.children.filter(f => f !== element);
    }
    /**
     * Returns `true` if the group receives focus when the cell is focused.
     * The group must have a single simple focusable element, like a button or checkbox.
     */
    isNavigable() {
        const focusable = this.focusableChildren;
        return focusable.length === 1 && focusable[0].isNavigable();
    }
    canFocus() {
        return this.focusableChildren.length > 0;
    }
    focus() {
        if (this.canFocus() && !this.hasFocus()) {
            this.focusableChildren[0].focus();
        }
    }
    activate() {
        this.toggleState(true);
    }
    deactivate() {
        this.toggleState(false);
    }
    hasFocus() {
        return this.children.reduce((focused, element) => focused || element.hasFocus(), false);
    }
    toggleState(active) {
        if (this.active !== active) {
            this.active = active;
            this.children.forEach(f => f.toggle(active));
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FocusGroup, deps: [{ token: FocusRoot }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FocusGroup });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FocusGroup, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: FocusRoot }] });

const reset = (...lists) => {
    let diff = false;
    for (let idx = 0; idx < lists.length; idx++) {
        const [list, columns] = lists[idx];
        diff = diff || list.length !== columns.length;
        list.reset(columns);
    }
    return diff;
};
/**
 * @hidden
 */
class ColumnsContainer {
    columns;
    allColumns = new QueryList();
    leafColumns = new QueryList();
    lockedColumns = new QueryList();
    nonLockedColumns = new QueryList();
    lockedLeafColumns = new QueryList();
    nonLockedLeafColumns = new QueryList();
    totalLevels = 0;
    isStacked = false;
    changes = new EventEmitter();
    leafColumnsToRender = [];
    lockedColumnsToRender = [];
    nonLockedColumnsToRender = [];
    hasGroupHeaderColumn = false;
    hasGroupFooter = false;
    hasFooter = false;
    unlockedWidth = 0;
    totalColumnsWidth = 0;
    constructor(columns) {
        this.columns = columns;
    }
    refresh() {
        const currentLevels = this.totalLevels;
        const leafColumns = new Array();
        const lockedLeafColumns = new Array();
        const nonLockedLeafColumns = new Array();
        const lockedColumns = new Array();
        const nonLockedColumns = new Array();
        const allColumns = new Array();
        const leafColumnsToRender = new Array();
        const lockedColumnsToRender = new Array();
        const nonLockedColumnsToRender = new Array();
        let hasGroupHeaderColumn = false;
        let hasGroupFooter = false;
        let hasFooter = false;
        let unlockedWidth = 0;
        let leafIndex = 0;
        this.totalLevels = 0;
        this.columns().forEach(column => {
            const containerLeafColumns = column.isLocked === true ? lockedLeafColumns : nonLockedLeafColumns;
            const containerColumns = column.isLocked === true ? lockedColumns : nonLockedColumns;
            const toRenderContainer = column.isLocked === true ? lockedColumnsToRender : nonLockedColumnsToRender;
            if (!isColumnGroupComponent(column)) {
                containerLeafColumns.push(column);
                leafColumns.push(column);
                leafColumnsToRender.push(...columnsToRender([column]));
                toRenderContainer.push(...columnsToRender([column]));
                hasGroupHeaderColumn = hasGroupHeaderColumn || someLeafColumn(leaf => Boolean(leaf.groupHeaderColumnTemplateRef), column);
                hasGroupFooter = hasGroupFooter || someLeafColumn(leaf => Boolean(leaf.groupFooterTemplateRef), column);
                hasFooter = hasFooter || someLeafColumn(leaf => Boolean(leaf.footerTemplateRef), column);
                if (!column.isLocked) {
                    unlockedWidth += column.width || 0;
                }
                if (column.isSpanColumn) {
                    column.children.forEach(c => {
                        c.leafIndex = leafIndex++;
                    });
                }
                else {
                    column.leafIndex = leafIndex++;
                }
                this.totalColumnsWidth += column.width || 0;
            }
            containerColumns.push(column);
            allColumns.push(column);
            this.totalLevels = column.level > this.totalLevels ? column.level : this.totalLevels;
        });
        this.hasGroupHeaderColumn = hasGroupHeaderColumn;
        this.hasGroupFooter = hasGroupFooter;
        this.hasFooter = hasFooter;
        this.leafColumnsToRender = leafColumnsToRender;
        this.lockedColumnsToRender = lockedColumnsToRender;
        this.nonLockedColumnsToRender = nonLockedColumnsToRender;
        this.unlockedWidth = unlockedWidth;
        const changes = reset([this.leafColumns, leafColumns], [this.lockedLeafColumns, lockedLeafColumns], [this.nonLockedLeafColumns, nonLockedLeafColumns], [this.lockedColumns, lockedColumns], [this.allColumns, allColumns], [this.nonLockedColumns, nonLockedColumns]) || currentLevels !== this.totalLevels;
        if (changes) {
            this.changes.emit();
        }
        return changes;
    }
}

const NO_STICKY = { left: '0px', right: '0px' };
/**
 * @hidden
 */
class ColumnInfoService {
    visibilityChange = new EventEmitter();
    lockedChange = new EventEmitter();
    stickyChange = new EventEmitter();
    columnRangeChange = new EventEmitter();
    columnsContainer = new ColumnsContainer(() => []);
    list;
    stickyColumns;
    get lockedLeafColumns() {
        return this.columnsContainer.lockedLeafColumns;
    }
    get nonLockedLeafColumns() {
        return this.columnsContainer.nonLockedLeafColumns;
    }
    get isLocked() {
        return this.lockedLeafColumns.length > 0 && !this.columnsContainer.isStacked;
    }
    get totalLevels() {
        return this.columnsContainer.totalLevels;
    }
    get hiddenColumns() {
        if (!this.list) {
            return [];
        }
        return this.list().filter(column => !column.isVisible);
    }
    get leafNamedColumns() {
        if (!this.list) {
            return [];
        }
        const columns = expandColumns(this.list().filterSort(column => !column.isColumnGroup))
            .filter(column => column.matchesMedia && column.displayTitle);
        return orderBy(columns, [{ field: 'locked', dir: 'desc' }]);
    }
    get unlockedRootCount() {
        return this.list().rootColumns().filter(column => !column.locked && column.isVisible).length;
    }
    stickyColumnsStyles(column) {
        this.stickyColumns = this.list().rootColumns().filter(column => column.sticky && !column.locked && column.isVisible);
        if (this.stickyColumns.length === 0) {
            return NO_STICKY;
        }
        const result = this.stickyColumns.reduce((acc, curr) => {
            if (curr.leafIndex < column.leafIndex) {
                acc.left += curr.width;
            }
            else if (curr.leafIndex > column.leafIndex) {
                acc.right += curr.width;
            }
            return acc;
        }, { left: 0, right: 0 });
        return {
            left: `${result.left}px`,
            right: `${result.right}px`
        };
    }
    init(columns, list) {
        this.columnsContainer = columns;
        this.list = list;
        this.stickyColumns = null;
    }
    changeVisibility(columns) {
        this.stickyColumns = null;
        this.visibilityChange.emit(columns);
    }
    changeLocked(columns) {
        this.stickyColumns = null;
        this.lockedChange.emit(columns);
    }
    changeStuck(columns) {
        this.stickyColumns = null;
        this.stickyChange.emit(columns);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnInfoService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnInfoService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnInfoService, decorators: [{
            type: Injectable
        }] });

let id$3 = 0;
function nextId$1() {
    return id$3++;
}
/**
 * @hidden
 */
class LogicalCellDirective {
    focusGroup;
    element;
    columnInfoService;
    idService;
    navigationService;
    renderer;
    zone;
    cellContext;
    logicalColIndex;
    logicalRowIndex;
    logicalSlaveCell = false;
    colIndex;
    colSpan = 1;
    rowSpan = 1;
    groupItem;
    dataRowIndex = -1;
    dataItem;
    detailExpandCell = false;
    headerLabelText;
    uid = nextId$1();
    get id() {
        if (!this.logicalSlaveCell && this.columnInfoService.isLocked) {
            return this.idService.cellId(this.logicalRowIndex, this.logicalColIndex);
        }
    }
    get cellRowspan() {
        return String(this.rowSpan);
    }
    get rowspanClass() {
        return this.dataRowIndex > -1 && this.rowSpan > 1;
    }
    get ariaColIndex() {
        if (this.logicalSlaveCell || this.logicalColIndex === -1) {
            return undefined;
        }
        return this.logicalColIndex + 1;
    }
    navigationChange;
    constructor(focusGroup, element, columnInfoService, idService, navigationService, renderer, zone, cellContext) {
        this.focusGroup = focusGroup;
        this.element = element;
        this.columnInfoService = columnInfoService;
        this.idService = idService;
        this.navigationService = navigationService;
        this.renderer = renderer;
        this.zone = zone;
        this.cellContext = cellContext;
    }
    ngOnInit() {
        if (!this.navigationService.tableEnabled) {
            return;
        }
        this.navigationChange = this.navigationService.changes.subscribe((e) => this.onNavigationChange(e));
    }
    ngDoCheck() {
        if (!this.navigationService.tableEnabled || this.logicalColIndex === -1) {
            return;
        }
        if (this.cellContext) {
            this.cellContext.focusGroup = this.focusGroup;
        }
        this.registerNoChanges();
    }
    ngOnChanges(changes) {
        if (!this.navigationService.tableEnabled) {
            return;
        }
        const keys = Object.keys(changes);
        if ((keys.length === 1 && keys[0] === 'groupItem') || this.logicalColIndex === -1) {
            // Ignore groupItem changes as the reference is not stable
            return;
        }
        const indexChange = changes['logicalColIndex'];
        const rowIndexChange = changes['logicalRowIndex'];
        const index = indexChange && !indexChange.isFirstChange() ? indexChange.previousValue : this.logicalColIndex;
        const rowIndex = rowIndexChange && !rowIndexChange.isFirstChange() ? rowIndexChange.previousValue : this.logicalRowIndex;
        this.navigationService.unregisterCell(index, rowIndex, this);
        this.registerChanges();
        this.updateElement();
    }
    ngOnDestroy() {
        if (this.navigationChange) {
            this.navigationChange.unsubscribe();
        }
        this.navigationService.unregisterCell(this.logicalColIndex, this.logicalRowIndex, this);
    }
    onNavigationChange(e) {
        const active = this.logicalColIndex === e.colIndex && this.logicalRowIndex === e.rowIndex;
        const wasActive = this.logicalColIndex === e.prevColIndex && this.logicalRowIndex === e.prevRowIndex;
        if (active || wasActive) {
            this.updateElement();
        }
    }
    updateElement() {
        const el = this.element.nativeElement;
        this.renderer.setAttribute(el, 'tabIndex', this.isFocusable() && !this.logicalSlaveCell ? '0' : '-1');
        if (this.isFocused()) {
            if (this.focusGroup.isNavigable()) {
                this.focusGroup.focus();
            }
            else {
                if (!this.logicalSlaveCell &&
                    this.navigationService.autoFocusCell(this.logicalColIndex, this.logicalColIndex + this.colSpan - 1)) {
                    this.microtask(() => {
                        if (this.isFocused()) {
                            el.focus({ preventScroll: this.navigationService.preventScroll });
                            this.navigationService.preventScroll = false;
                        }
                    });
                }
                this.renderer.addClass(el, 'k-focus');
            }
            if (this.headerLabelText) {
                el.removeAttribute('aria-label');
            }
        }
        else {
            this.renderer.removeClass(el, 'k-focus');
            if (this.headerLabelText) {
                el.setAttribute('aria-label', this.headerLabelText);
            }
        }
    }
    microtask(callback) {
        this.zone.runOutsideAngular(() => Promise.resolve(null).then(callback));
    }
    registerChanges() {
        if (!this.logicalSlaveCell) {
            this.navigationService.registerCell(this);
        }
    }
    registerNoChanges() {
        if (!this.logicalSlaveCell) {
            this.navigationService.registerCellOnCurrentRow(this);
        }
    }
    isFocusable() {
        return this.navigationService.isCellFocusable(this);
    }
    isFocused() {
        return this.navigationService.isCellFocused(this);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: LogicalCellDirective, deps: [{ token: FocusGroup }, { token: i0.ElementRef }, { token: ColumnInfoService }, { token: IdService }, { token: NavigationService }, { token: i0.Renderer2 }, { token: i0.NgZone }, { token: CELL_CONTEXT, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: LogicalCellDirective, isStandalone: true, selector: "[kendoGridLogicalCell]", inputs: { logicalColIndex: "logicalColIndex", logicalRowIndex: "logicalRowIndex", logicalSlaveCell: "logicalSlaveCell", colIndex: "colIndex", colSpan: "colSpan", rowSpan: "rowSpan", groupItem: "groupItem", dataRowIndex: "dataRowIndex", dataItem: "dataItem", detailExpandCell: "detailExpandCell", headerLabelText: "headerLabelText" }, host: { properties: { "attr.id": "this.id", "attr.rowspan": "this.cellRowspan", "class.k-table-td-row-span": "this.rowspanClass", "attr.aria-colindex": "this.ariaColIndex" } }, providers: [{
                provide: FocusGroup,
                deps: [FocusRoot],
                useClass: FocusGroup
            }], usesOnChanges: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: LogicalCellDirective, decorators: [{
            type: Directive,
            args: [{
                    providers: [{
                            provide: FocusGroup,
                            deps: [FocusRoot],
                            useClass: FocusGroup
                        }],
                    selector: '[kendoGridLogicalCell]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: FocusGroup }, { type: i0.ElementRef }, { type: ColumnInfoService }, { type: IdService }, { type: NavigationService }, { type: i0.Renderer2 }, { type: i0.NgZone }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [CELL_CONTEXT]
                }] }], propDecorators: { logicalColIndex: [{
                type: Input
            }], logicalRowIndex: [{
                type: Input
            }], logicalSlaveCell: [{
                type: Input
            }], colIndex: [{
                type: Input
            }], colSpan: [{
                type: Input
            }], rowSpan: [{
                type: Input
            }], groupItem: [{
                type: Input
            }], dataRowIndex: [{
                type: Input
            }], dataItem: [{
                type: Input
            }], detailExpandCell: [{
                type: Input
            }], headerLabelText: [{
                type: Input
            }], id: [{
                type: HostBinding,
                args: ['attr.id']
            }], cellRowspan: [{
                type: HostBinding,
                args: ['attr.rowspan']
            }], rowspanClass: [{
                type: HostBinding,
                args: ['class.k-table-td-row-span']
            }], ariaColIndex: [{
                type: HostBinding,
                args: ['attr.aria-colindex']
            }] } });

let id$2 = 0;
function nextId() {
    return id$2++;
}
/**
 * @hidden
 */
class LogicalRowDirective {
    idService;
    navigation;
    logicalRowIndex;
    logicalSlaveRow = false;
    logicalCellsCount;
    logicalSlaveCellsCount = 0;
    dataRowIndex = -1;
    dataItem;
    totalColumns;
    uid = nextId();
    get hostRole() {
        return this.logicalSlaveRow ? 'presentation' : 'row';
    }
    get ariaRowIndex() {
        return this.logicalSlaveRow ? null : this.logicalRowIndex + 1;
    }
    get rowIndex() {
        return this.logicalSlaveRow ? this.logicalRowIndex + 1 : null;
    }
    tableRowClass = true;
    get ariaOwns() {
        if (this.logicalSlaveRow || this.logicalSlaveCellsCount === 0) {
            return undefined;
        }
        const ids = [];
        if (this.dataRowIndex < 0) {
            let total = this.logicalCellsCount + this.logicalSlaveCellsCount;
            this.columnsArray.forEach(column => {
                if (column.isSpanColumn) {
                    total += column.colspan - 1;
                }
            });
            for (let cellIndex = this.logicalCellsCount; cellIndex < total; cellIndex++) {
                ids.push(this.idService.cellId(this.logicalRowIndex, cellIndex));
            }
        }
        else {
            let columnIndex = 0;
            this.columnsArray.forEach(column => {
                if (!column.isLocked) {
                    ids.push(this.idService.cellId(this.logicalRowIndex, columnIndex));
                }
                columnIndex += column.isSpanColumn ? column.colspan : 1;
            });
        }
        return ids.join(' ');
    }
    constructor(idService, navigation) {
        this.idService = idService;
        this.navigation = navigation;
    }
    ngOnChanges(changes) {
        if (!this.navigation.enabled || this.logicalSlaveRow) {
            return;
        }
        const indexChange = changes.logicalRowIndex;
        const logicalSlaveRowChange = changes.logicalSlaveRow;
        if (indexChange || logicalSlaveRowChange) {
            const index = indexChange && !indexChange.isFirstChange() ? indexChange.previousValue : this.logicalRowIndex;
            this.navigation.unregisterRow(index, this);
            this.navigation.registerRow(this);
        }
        else if (anyChanged(['dataRowIndex', 'dataItem'], changes)) {
            this.navigation.updateRow(this);
        }
    }
    ngOnDestroy() {
        this.navigation.unregisterRow(this.logicalRowIndex, this);
    }
    get columnsArray() {
        return this.totalColumns?.allColumns.toArray() || [];
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: LogicalRowDirective, deps: [{ token: IdService }, { token: NavigationService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: LogicalRowDirective, isStandalone: true, selector: "[kendoGridLogicalRow]", inputs: { logicalRowIndex: "logicalRowIndex", logicalSlaveRow: "logicalSlaveRow", logicalCellsCount: "logicalCellsCount", logicalSlaveCellsCount: "logicalSlaveCellsCount", dataRowIndex: "dataRowIndex", dataItem: "dataItem", totalColumns: "totalColumns" }, host: { properties: { "attr.role": "this.hostRole", "attr.aria-rowindex": "this.ariaRowIndex", "attr.data-kendo-grid-row-index": "this.rowIndex", "class.k-table-row": "this.tableRowClass", "attr.aria-owns": "this.ariaOwns" } }, usesOnChanges: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: LogicalRowDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridLogicalRow]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: IdService }, { type: NavigationService }], propDecorators: { logicalRowIndex: [{
                type: Input
            }], logicalSlaveRow: [{
                type: Input
            }], logicalCellsCount: [{
                type: Input
            }], logicalSlaveCellsCount: [{
                type: Input
            }], dataRowIndex: [{
                type: Input
            }], dataItem: [{
                type: Input
            }], totalColumns: [{
                type: Input
            }], hostRole: [{
                type: HostBinding,
                args: ['attr.role']
            }], ariaRowIndex: [{
                type: HostBinding,
                args: ['attr.aria-rowindex']
            }], rowIndex: [{
                type: HostBinding,
                args: ['attr.data-kendo-grid-row-index']
            }], tableRowClass: [{
                type: HostBinding,
                args: ['class.k-table-row']
            }], ariaOwns: [{
                type: HostBinding,
                args: ['attr.aria-owns']
            }] } });

const FORMAT_REGEX$1 = /\{\d+:?/;
/**
 * @hidden
 */
class FieldAccessorPipe {
    intlService;
    constructor(intlService) {
        this.intlService = intlService;
    }
    transform(dataItem, fieldName, format) {
        if (!isNullOrEmptyString(fieldName)) {
            const value = getter(fieldName)(dataItem);
            if (!isNullOrEmptyString(format)) {
                return this.formatValue(format, value);
            }
            return value;
        }
        return dataItem;
    }
    formatValue(format, value) {
        const intl = this.intlService;
        if (isString(format) && FORMAT_REGEX$1.exec(format)) {
            return intl.format(format, value);
        }
        return intl.toString(value, format);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FieldAccessorPipe, deps: [{ token: i1$4.IntlService }], target: i0.ɵɵFactoryTarget.Pipe });
    static ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "19.2.18", ngImport: i0, type: FieldAccessorPipe, isStandalone: true, name: "valueOf", pure: false });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FieldAccessorPipe, decorators: [{
            type: Pipe,
            args: [{
                    // eslint-disable-next-line @angular-eslint/pipe-prefix
                    name: 'valueOf',
                    pure: false,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1$4.IntlService }] });

/**
 * @hidden
 */
class GridTableDirective {
    wrapper;
    hostClass = true;
    get sizeSmallClass() {
        return this.size === 'small';
    }
    get sizeMediumClass() {
        return this.size === 'medium' || !this.size;
    }
    set size(size) {
        this._size = size;
        if (size === 'none') {
            this.wrapper.nativeElement.classList.remove('k-table-sm', 'k-table-md');
        }
    }
    get size() {
        return this._size;
    }
    _size = 'medium';
    constructor(wrapper) {
        this.wrapper = wrapper;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GridTableDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: GridTableDirective, isStandalone: true, selector: "[kendoGridTable]", inputs: { size: "size" }, host: { properties: { "class.k-table": "this.hostClass", "class.k-table-sm": "this.sizeSmallClass", "class.k-table-md": "this.sizeMediumClass" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GridTableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridTable]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { hostClass: [{
                type: HostBinding,
                args: ['class.k-table']
            }], sizeSmallClass: [{
                type: HostBinding,
                args: ['class.k-table-sm']
            }], sizeMediumClass: [{
                type: HostBinding,
                args: ['class.k-table-md']
            }], size: [{
                type: Input
            }] } });

const forEachColumn = (list, callback) => {
    list.forEach((column) => {
        callback(column);
        if (column.isColumnGroup && column.hasChildren) {
            forEachColumn(column.childrenArray, callback);
        }
    });
};
const forEachLevel = (list, callback) => {
    sortColumns(list)
        .forEach((column) => {
        callback(column);
        if (column.isColumnGroup && column.hasChildren) {
            forEachLevel(column.childrenArray, callback);
        }
    });
};
const filterHierarchy = (list, predicate) => {
    const result = [];
    sortColumns(list)
        .forEach((column) => {
        if (predicate(column)) {
            if (column.isColumnGroup) {
                const children = filterHierarchy(column.childrenArray, predicate);
                if (children.length) {
                    result.push(column, ...children);
                }
            }
            else if (!column.isSpanColumn || filterHierarchy(column.childrenArray, predicate).length) {
                result.push(column);
            }
        }
    });
    return result.sort((a, b) => Number(b.locked) - Number(a.locked));
};
/**
 * @hidden
 */
class ColumnList {
    columns;
    static empty() {
        return new ColumnList(new QueryList());
    }
    constructor(columns) {
        this.columns = columns;
    }
    forEach(callback) {
        forEachColumn(this.columns, callback);
    }
    filter(callback) {
        const result = [];
        forEachColumn(this.columns, (column) => {
            if (callback(column)) {
                result.push(column);
            }
        });
        return result;
    }
    filterHierarchy(predicate) {
        return filterHierarchy(this.columns.toArray(), predicate);
    }
    filterSort(callback) {
        const result = [];
        forEachLevel(this.columns.toArray(), (column) => {
            if (callback(column)) {
                result.push(column);
            }
        });
        return result;
    }
    toArray() {
        const result = [];
        forEachColumn(this.columns, (column) => {
            result.push(column);
        });
        return result;
    }
    rootColumns() {
        return this.columns.toArray();
    }
    totalColumnLevels() {
        let totalLevels = 0;
        this.forEach(column => {
            totalLevels = Math.max(column.level, totalLevels);
        });
        return totalLevels;
    }
}

/**
 * @hidden
 */
class GroupInfoService {
    _columnList = ColumnList.empty;
    get columns() {
        return expandColumns(this._columnList().toArray()).filter(isColumnComponent);
    }
    registerColumnsContainer(columns) {
        this._columnList = columns;
    }
    formatForGroup(item) {
        const column = this.columnForGroup(item);
        return column ? column.format : "";
    }
    isGroupable(groupField) {
        const [column] = this.columns.filter(x => x.field === groupField);
        return column ? column.groupable : true;
    }
    groupTitle(item) {
        const column = this.columnForGroup(item);
        return column ? (column.title || column.field) : this.groupField(item);
    }
    groupHeaderTemplate(item) {
        const column = this.columnForGroup(item);
        return column ? column.groupHeaderTemplateRef || column.groupHeaderColumnTemplateRef : undefined;
    }
    groupField(group) {
        return group.data ? group.data.field : group.field;
    }
    columnForGroup(group) {
        const field = this.groupField(group);
        const [column] = this.columns.filter(x => x.field === field);
        return column;
    }
}

/**
 * @hidden
 */
class GroupHeaderComponent {
    groupsService;
    groupInfoService;
    ctx;
    rowIndex;
    logicalRowIndex;
    item;
    skipGroupDecoration = false;
    hasDetails = false;
    totalColumnsCount = 0;
    hasGroupHeaderColumn;
    groupHeaderColumns;
    columns;
    groups = [];
    groupItemClass = true;
    tableGroupRowClass = true;
    isExpanded = false;
    caretAltDownIcon = caretAltDownIcon;
    caretAltRightIcon = caretAltRightIcon;
    caretAltLeftIcon = caretAltLeftIcon;
    constructor(groupsService, groupInfoService, ctx) {
        this.groupsService = groupsService;
        this.groupInfoService = groupInfoService;
        this.ctx = ctx;
    }
    ngDoCheck() {
        const groupArgs = {
            group: this.item.data,
            groupIndex: this.item.index,
            parentGroup: getGroupRowArgs(this.item.parentGroup)
        };
        this.isExpanded = this.groupsService.isExpanded(groupArgs);
    }
    prefixGroupCell(item) {
        return new Array(item.level);
    }
    toggleGroup(item, event) {
        this.groupsService.toggleRow(item);
        if (this.ctx.navigable) {
            this.ctx.grid.navigationService.focusCellByElement(event.target.closest('td'));
        }
        return false;
    }
    groupSpan(item) {
        const groupCount = (this.groups || []).length;
        const detailOffset = this.hasDetails ? 1 : 0;
        if (this.hasGroupHeaderColumn) {
            return groupCount + 1 + detailOffset - item.level;
        }
        const columnCount = columnsSpan(this.columns);
        if (this.skipGroupDecoration) {
            return columnCount;
        }
        return groupCount + columnCount + detailOffset - item.level;
    }
    logicalColSpan() {
        return this.skipGroupDecoration ? 1 : this.totalColumnsCount;
    }
    ariaRole() {
        if (this.skipGroupDecoration) {
            return 'presentation';
        }
        return 'gridcell';
    }
    formatForGroup(item) {
        return this.groupInfoService.formatForGroup(item);
    }
    groupTitle(item) {
        return this.groupInfoService.groupTitle(item);
    }
    groupHeaderTemplate(item) {
        return this.groupInfoService.groupHeaderTemplate(item);
    }
    get groupButtonTitle() {
        const messageKey = this.isExpanded ? 'groupCollapse' : 'groupExpand';
        return this.ctx.localization.get(messageKey);
    }
    get arrowIcon() {
        const icon = !this.isExpanded ?
            !this.ctx.localization.rtl ?
                'caret-alt-right' :
                'caret-alt-left' :
            'caret-alt-down';
        return icon;
    }
    get arrowSVGIcon() {
        const icon = !this.isExpanded ?
            !this.ctx.localization.rtl ?
                this.caretAltRightIcon :
                this.caretAltLeftIcon :
            this.caretAltDownIcon;
        return icon;
    }
    get isStacked() {
        return this.ctx.grid?.isStacked;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GroupHeaderComponent, deps: [{ token: GroupsService }, { token: GroupInfoService }, { token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: GroupHeaderComponent, isStandalone: true, selector: "[kendoGridGroupHeader]", inputs: { rowIndex: "rowIndex", logicalRowIndex: "logicalRowIndex", item: "item", skipGroupDecoration: "skipGroupDecoration", hasDetails: "hasDetails", totalColumnsCount: "totalColumnsCount", hasGroupHeaderColumn: "hasGroupHeaderColumn", groupHeaderColumns: "groupHeaderColumns", columns: "columns", groups: "groups" }, host: { properties: { "class.k-grouping-row": "this.groupItemClass", "class.k-table-group-row": "this.tableGroupRowClass" } }, ngImport: i0, template: `
        @if (!skipGroupDecoration) {
          @for (g of prefixGroupCell(item); track $index) {
            <td class="k-group-cell k-table-td k-table-group-td"
              role="presentation"
            ></td>
          }
        }
        @if (!(skipGroupDecoration && hasGroupHeaderColumn)) {
          <td [attr.colspan]="groupSpan(item)"
            [attr.role]="ariaRole()"
            aria-selected="false"
            class="k-table-td"
            [attr.aria-expanded]="isExpanded"
            kendoGridLogicalCell
            [logicalRowIndex]="logicalRowIndex"
            [logicalColIndex]="0"
            [logicalSlaveCell]="skipGroupDecoration"
            [groupItem]="item"
            [colSpan]="logicalColSpan()">
            <p class="k-reset">
              @if (!skipGroupDecoration) {
                <a href="#" tabindex="-1" (click)="toggleGroup(item, $event)"
                  role="presentation"
                  [attr.title]="groupButtonTitle"
                  [attr.aria-label]="groupButtonTitle">
                  <kendo-icon-wrapper
                    [name]="arrowIcon"
                  [svgIcon]="arrowSVGIcon"></kendo-icon-wrapper>
                </a>
                @if (!groupHeaderTemplate(item)) {
                  {{groupTitle(item)}}: {{item.data | valueOf:"value": formatForGroup(item)}}
                }
                <ng-template
                        [templateContext]="{
                            templateRef: groupHeaderTemplate(item),
                            group: item.data,
                            aggregates: item.data?.aggregates,
                            value: item.data?.value,
                            field: item.data?.field,
                            index: item.index,
                            expanded: isExpanded,
                            $implicit: item.data
                            }">
                </ng-template>
              }
            </p>
            @if (isStacked) {
              <div class="k-grid-column-template">
                @for (column of groupHeaderColumns; track column; let index = $index) {
                  @if (column.groupHeaderColumnTemplateRef) {
                    <div class="k-column-template-item">
                      <ng-template [ngTemplateOutlet]="column.groupHeaderColumnTemplateRef"
                            [ngTemplateOutletContext]="{
                                group: item.data,
                                aggregates: item.data?.aggregates,
                                value: item.data?.value,
                                field: item.data?.field,
                                index: item.index,
                                $implicit: item.data
                                }">
                      </ng-template>
                    </div>
                  }
                }
              </div>
            }
          </td>
        }
        @if (hasGroupHeaderColumn && !isStacked) {
          @for (column of groupHeaderColumns; track column; let index = $index) {
            <td
              role="gridcell"
              class="k-table-td"
              aria-selected="false"
              kendoGridLogicalCell
              [logicalRowIndex]="logicalRowIndex"
              [logicalColIndex]="index + 1"
              [logicalSlaveCell]="false"
              [groupItem]="item"
              [colSpan]="1"
              >
              @if (column.groupHeaderColumnTemplateRef) {
                <ng-template [ngTemplateOutlet]="column.groupHeaderColumnTemplateRef"
                    [ngTemplateOutletContext]="{
                        group: item.data,
                        aggregates: item.data?.aggregates,
                        value: item.data?.value,
                        field: item.data?.field,
                        index: item.index,
                        $implicit: item.data
                        }">
                </ng-template>
              }
            </td>
          }
        }
        `, isInline: true, dependencies: [{ kind: "directive", type: LogicalCellDirective, selector: "[kendoGridLogicalCell]", inputs: ["logicalColIndex", "logicalRowIndex", "logicalSlaveCell", "colIndex", "colSpan", "rowSpan", "groupItem", "dataRowIndex", "dataItem", "detailExpandCell", "headerLabelText"] }, { kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "directive", type: TemplateContextDirective, selector: "[templateContext]", inputs: ["templateContext"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "pipe", type: FieldAccessorPipe, name: "valueOf" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GroupHeaderComponent, decorators: [{
            type: Component,
            args: [{
                    selector: '[kendoGridGroupHeader]',
                    template: `
        @if (!skipGroupDecoration) {
          @for (g of prefixGroupCell(item); track $index) {
            <td class="k-group-cell k-table-td k-table-group-td"
              role="presentation"
            ></td>
          }
        }
        @if (!(skipGroupDecoration && hasGroupHeaderColumn)) {
          <td [attr.colspan]="groupSpan(item)"
            [attr.role]="ariaRole()"
            aria-selected="false"
            class="k-table-td"
            [attr.aria-expanded]="isExpanded"
            kendoGridLogicalCell
            [logicalRowIndex]="logicalRowIndex"
            [logicalColIndex]="0"
            [logicalSlaveCell]="skipGroupDecoration"
            [groupItem]="item"
            [colSpan]="logicalColSpan()">
            <p class="k-reset">
              @if (!skipGroupDecoration) {
                <a href="#" tabindex="-1" (click)="toggleGroup(item, $event)"
                  role="presentation"
                  [attr.title]="groupButtonTitle"
                  [attr.aria-label]="groupButtonTitle">
                  <kendo-icon-wrapper
                    [name]="arrowIcon"
                  [svgIcon]="arrowSVGIcon"></kendo-icon-wrapper>
                </a>
                @if (!groupHeaderTemplate(item)) {
                  {{groupTitle(item)}}: {{item.data | valueOf:"value": formatForGroup(item)}}
                }
                <ng-template
                        [templateContext]="{
                            templateRef: groupHeaderTemplate(item),
                            group: item.data,
                            aggregates: item.data?.aggregates,
                            value: item.data?.value,
                            field: item.data?.field,
                            index: item.index,
                            expanded: isExpanded,
                            $implicit: item.data
                            }">
                </ng-template>
              }
            </p>
            @if (isStacked) {
              <div class="k-grid-column-template">
                @for (column of groupHeaderColumns; track column; let index = $index) {
                  @if (column.groupHeaderColumnTemplateRef) {
                    <div class="k-column-template-item">
                      <ng-template [ngTemplateOutlet]="column.groupHeaderColumnTemplateRef"
                            [ngTemplateOutletContext]="{
                                group: item.data,
                                aggregates: item.data?.aggregates,
                                value: item.data?.value,
                                field: item.data?.field,
                                index: item.index,
                                $implicit: item.data
                                }">
                      </ng-template>
                    </div>
                  }
                }
              </div>
            }
          </td>
        }
        @if (hasGroupHeaderColumn && !isStacked) {
          @for (column of groupHeaderColumns; track column; let index = $index) {
            <td
              role="gridcell"
              class="k-table-td"
              aria-selected="false"
              kendoGridLogicalCell
              [logicalRowIndex]="logicalRowIndex"
              [logicalColIndex]="index + 1"
              [logicalSlaveCell]="false"
              [groupItem]="item"
              [colSpan]="1"
              >
              @if (column.groupHeaderColumnTemplateRef) {
                <ng-template [ngTemplateOutlet]="column.groupHeaderColumnTemplateRef"
                    [ngTemplateOutletContext]="{
                        group: item.data,
                        aggregates: item.data?.aggregates,
                        value: item.data?.value,
                        field: item.data?.field,
                        index: item.index,
                        $implicit: item.data
                        }">
                </ng-template>
              }
            </td>
          }
        }
        `,
                    standalone: true,
                    imports: [LogicalCellDirective, IconWrapperComponent, TemplateContextDirective, NgTemplateOutlet, FieldAccessorPipe]
                }]
        }], ctorParameters: () => [{ type: GroupsService }, { type: GroupInfoService }, { type: ContextService }], propDecorators: { rowIndex: [{
                type: Input
            }], logicalRowIndex: [{
                type: Input
            }], item: [{
                type: Input
            }], skipGroupDecoration: [{
                type: Input
            }], hasDetails: [{
                type: Input
            }], totalColumnsCount: [{
                type: Input
            }], hasGroupHeaderColumn: [{
                type: Input
            }], groupHeaderColumns: [{
                type: Input
            }], columns: [{
                type: Input
            }], groups: [{
                type: Input
            }], groupItemClass: [{
                type: HostBinding,
                args: ['class.k-grouping-row']
            }], tableGroupRowClass: [{
                type: HostBinding,
                args: ['class.k-table-group-row']
            }] } });

const withoutField = ({ field }) => isNullOrEmptyString(field);
const alreadyGrouped = ({ groups, field }) => groups.some(group => group.field === field);
const overSameTarget = ({ target, field }) => target.field === field;
const overLastTarget = ({ target }) => target.lastTarget;
const isLastGroup = ({ groups, field }) => groups.map(group => group.field).indexOf(field) === groups.length - 1;
const isNotGroupable = (groupsService) => ({ field }) => !groupsService.isGroupable(field);
const columnRules = (groupService) => or(withoutField, alreadyGrouped, isNotGroupable(groupService));
const indicatorRules = or(overSameTarget, and(overLastTarget, isLastGroup));
/**
 * @hidden
 */
class GroupPanelComponent {
    hint;
    cue;
    groupInfoService;
    ctx;
    cd;
    popupService;
    ngZone;
    renderer;
    change = new EventEmitter();
    get groupHeaderClass() {
        return true;
    }
    set text(value) {
        this.emptyText = value;
    }
    get text() {
        return this.emptyText ? this.emptyText : this.ctx.localization.get('groupPanelEmpty');
    }
    navigable;
    groups = [];
    dropTargets = new QueryList();
    defaultTemplate;
    groupTitles = [];
    isChipMenuOpen = false;
    get gridId() {
        return this.ctx.grid?.ariaRootId;
    }
    rtl = false;
    first;
    last;
    arrowLeftIcon = arrowLeftIcon;
    arrowRightIcon = arrowRightIcon;
    emptyText;
    subscription;
    targetSubscription;
    popupSubs;
    popupRef;
    activeItem;
    constructor(hint, cue, groupInfoService, ctx, cd, popupService, ngZone, renderer) {
        this.hint = hint;
        this.cue = cue;
        this.groupInfoService = groupInfoService;
        this.ctx = ctx;
        this.cd = cd;
        this.popupService = popupService;
        this.ngZone = ngZone;
        this.renderer = renderer;
    }
    ngAfterViewInit() {
        this.subscription = this.ctx.localization.changes.subscribe(({ rtl }) => {
            this.rtl = rtl;
            this.cd.markForCheck();
        });
        this.subscription.add(observe(this.dropTargets)
            .subscribe(this.attachTargets.bind(this)));
    }
    ngDoCheck() {
        const currentTitles = this.groups.map(group => this.groupInfoService.groupTitle(group));
        if (currentTitles.length !== this.groupTitles.length || currentTitles.some((current, idx) => current !== this.groupTitles[idx])) {
            this.groupTitles = currentTitles;
            this.cd.markForCheck();
        }
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        if (this.targetSubscription) {
            this.targetSubscription.unsubscribe();
        }
        this.destroyMenu();
    }
    messageFor(token) {
        return this.ctx.localization.get(token);
    }
    getTitle(group) {
        return this.messageFor(group.dir === 'desc' ? 'sortedDescending' : 'sortedAscending');
    }
    getDirectionIcon(group) {
        return group.dir === 'desc' ? 'sort-desc-sm' : 'sort-asc-sm';
    }
    getDirectionSvgIcon(group) {
        return group.dir === 'desc' ? sortDescSmallIcon : sortAscSmallIcon;
    }
    directionChange(group) {
        group.dir = group.dir ? group.dir : "asc";
        group.dir = group.dir === 'asc' ? 'desc' : 'asc';
        const index = this.groups.findIndex(x => x.field === group.field);
        const groups = [...this.groups.slice(0, index), group, ...this.groups.slice(index + 1)];
        this.change.emit(groups);
    }
    insert(field, index) {
        const groups = this.groups.filter(x => x.field !== field);
        if (groups.length || this.groups.length === 0) {
            this.change.emit([...groups.slice(0, index), { field: field }, ...groups.slice(index)]);
        }
    }
    remove(group) {
        this.destroyMenu();
        this.change.emit(this.groups.filter(x => x.field !== group.field));
    }
    toggleMenu(chip, first, last, field) {
        const anchor = chip.element.nativeElement.querySelector('.k-chip-action');
        if (this.popupRef) {
            const popupAnchor = this.popupRef.popup.instance.anchor;
            this.destroyMenu();
            if (anchor === popupAnchor) {
                return;
            }
        }
        this.first = first;
        this.last = last;
        const direction = this.ctx.localization.rtl ? 'right' : 'left';
        this.popupRef = this.popupService.open({
            anchor: anchor,
            content: this.defaultTemplate,
            anchorAlign: { vertical: 'bottom', horizontal: direction },
            popupAlign: { vertical: 'top', horizontal: direction },
            positionMode: 'absolute'
        });
        this.activeItem = this.dropTargets.find(dt => dt.context.field === field);
        this.renderer.setAttribute(this.popupRef.popupElement, 'dir', this.ctx.localization.rtl ? 'rtl' : 'ltr');
        const menuItems = Array.from(this.popupRef.popupElement.querySelectorAll('.k-menu-item'));
        this.activateMenuItem(menuItems[1], 'previous');
        this.popupSubs = this.popupRef.popupAnchorViewportLeave.subscribe(() => {
            this.destroyMenu(true);
        });
        if (isUniversal()) {
            return;
        }
        this.ngZone.runOutsideAngular(() => {
            this.popupSubs.add(fromEvent(document, 'click')
                .pipe(filter((event) => !closest(event.target, (node) => node === this.popupRef.popupElement || (node.matches && node.matches('.k-chip-action'))))).subscribe(() => {
                this.destroyMenu();
            }));
        });
    }
    handleKeyDown = (e) => {
        const code = normalizeKeys(e);
        if (code === Keys.ArrowDown || code === Keys.ArrowUp) {
            e.preventDefault();
            const relatedItemType = e.target.matches(':first-child') ? 'next' : 'previous';
            this.activateMenuItem(e.target, relatedItemType);
        }
        else if (code === Keys.Escape) {
            this.destroyMenu(true);
        }
        else if (code === Keys.Tab) {
            this.destroyMenu(true);
        }
        else if (code === Keys.Space || code === Keys.Enter) {
            this.handleMenuClick(e);
        }
    };
    handleClick = (e) => {
        e.preventDefault();
        const menuItemEl = e.target.closest('.k-menu-item');
        if (!menuItemEl.matches('[aria-disabled="true"]')) {
            this.handleMenuClick(e);
            return;
        }
        if (menuItemEl.getAttribute('tabindex') === '0') {
            return;
        }
        const activeMenuItem = menuItemEl.closest('.k-menu-group').querySelector('[tabindex="0"]');
        const relatedItemType = activeMenuItem.matches(':first-child') ? 'next' : 'previous';
        this.activateMenuItem(activeMenuItem, relatedItemType);
    };
    canDrop(draggable, target) {
        const isIndicator = draggable.type === 'groupIndicator';
        const rules = isIndicator
            ? indicatorRules
            : columnRules(this.groupInfoService);
        return !rules({
            field: draggable.field,
            groups: this.groups,
            target
        });
    }
    attachTargets() {
        if (this.targetSubscription) {
            this.targetSubscription.unsubscribe();
        }
        this.targetSubscription = new Subscription();
        const enterStream = this.dropTargets
            .reduce((acc, target) => merge(acc, target.enter), from([]));
        const leaveStream = this.dropTargets
            .reduce((acc, target) => merge(acc, target.leave), from([]));
        const dropStream = this.dropTargets
            .reduce((acc, target) => merge(acc, target.drop), from([]));
        this.targetSubscription.add(enterStream.pipe(tap(() => {
            this.hint.removeLock();
            this.destroyMenu();
        }), filter(({ draggable, target }) => this.canDrop(draggable.context, target.context)), tap(this.enter.bind(this)), switchMapTo(dropStream.pipe(takeUntil(leaveStream.pipe(tap(this.leave.bind(this))))))).subscribe(this.drop.bind(this)));
    }
    enter({ draggable, target }) {
        this.hint.enable();
        let before = target.context.lastTarget || isTargetBefore(draggable.element.nativeElement, target.element.nativeElement);
        if (this.ctx.localization.rtl) {
            before = !before;
        }
        this.cue.position(position(target.element.nativeElement, before));
    }
    leave() {
        this.hint.disable();
        this.cue.hide();
    }
    drop({ target, draggable }) {
        const field = draggable.context.field;
        const index = this.dropTargets.toArray().indexOf(target);
        this.insert(field, index);
    }
    destroyMenu(focusAnchor) {
        if (this.popupRef) {
            this.popupRef.close();
            this.popupRef = null;
            this.popupSubs && this.popupSubs.unsubscribe();
            focusAnchor && this.activeItem.context.target.focus();
        }
    }
    activateMenuItem(item, relatedItemType) {
        this.renderer.setAttribute(item, 'tabindex', '-1');
        this.renderer.removeClass(item, 'k-focus');
        const relatedItem = item[`${relatedItemType}ElementSibling`];
        this.renderer.setAttribute(relatedItem, 'tabindex', '0');
        this.renderer.addClass(relatedItem, 'k-focus');
        this.ngZone.runOutsideAngular(() => setTimeout(() => relatedItem.focus()));
    }
    handleMenuClick(e) {
        e.preventDefault();
        if (e.target.getAttribute('aria-disabled') !== 'true') {
            const chips = this.dropTargets.toArray().slice(0, this.dropTargets.length - 1);
            let groupChip, groupChipIndex;
            for (let i = 0; i < chips.length; i++) {
                if (chips[i].element.nativeElement === this.popupRef.popup.instance.anchor.closest('.k-chip')) {
                    groupChip = chips[i];
                    groupChipIndex = i;
                    break;
                }
            }
            const isPrev = e.target.closest('.k-menu-item').matches(':first-child');
            if (isPrev && groupChipIndex > 0) {
                this.insert(groupChip.context.field, groupChipIndex - 1);
            }
            else if (!isPrev && groupChipIndex < chips.length - 1) {
                this.insert(groupChip.context.field, groupChipIndex + 1);
            }
            this.destroyMenu(true);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GroupPanelComponent, deps: [{ token: DragHintService }, { token: DropCueService }, { token: GroupInfoService }, { token: ContextService }, { token: i0.ChangeDetectorRef }, { token: i2.PopupService }, { token: i0.NgZone }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: GroupPanelComponent, isStandalone: true, selector: "kendo-grid-group-panel", inputs: { text: "text", navigable: "navigable", groups: "groups" }, outputs: { change: "change" }, host: { properties: { "class.k-grouping-header": "this.groupHeaderClass" } }, viewQueries: [{ propertyName: "defaultTemplate", first: true, predicate: ["defaultTemplate"], descendants: true, read: TemplateRef, static: true }, { propertyName: "dropTargets", predicate: DropTargetDirective, descendants: true }], ngImport: i0, template: `
        @if (groups.length === 0) {
          <div
            class="k-grouping-drop-container"
            [context]="{
                lastTarget: true
            }"
            kendoDropTarget
            >
            {{ text }}
          </div>
        }
        
        @if (groups.length !== 0) {
          <kendo-chiplist
            [navigable]="navigable"
            role="none"
            [orientation]="null"
            >
            @for (group of groups; track group; let index = $index; let first = $first; let last = $last) {
              <kendo-chip
                #chip
                kendoDropTarget
                kendoDraggableColumn
                kendoDraggable
                [title]="getTitle(group)"
                [enableDrag]="true"
                [context]="{
                    field: group.field,
                    type: 'groupIndicator',
                    hint:  groupTitles[index],
                    target: chip
                }"
                [label]="groupTitles[index]"
                [removable]="true"
                [hasMenu]="true"
                [icon]="getDirectionIcon(group)"
                [svgIcon]="getDirectionSvgIcon(group)"
                [attr.aria-haspopup]="'menu'"
                [attr.aria-expanded]="isChipMenuOpen"
                [attr.aria-controls]="gridId"
                (contentClick)="directionChange(group)"
                (remove)="remove(group)"
                (menuToggle)="toggleMenu(chip, first, last, group.field)"
                (keydown.alt.arrowdown)="$event.preventDefault(); toggleMenu(chip, first, last, group.field)"
                >
              </kendo-chip>
            }
          </kendo-chiplist>
        }
        
        @if (groups.length !== 0) {
          <div
            class="k-grouping-drop-container"
            [context]="{
                lastTarget: true
            }"
            kendoDropTarget
          >&nbsp;</div>
        }
        
        <ng-template #defaultTemplate>
            <ul unselectable="on" role="menu" class="k-group k-menu-group k-reset k-menu-group-md" [kendoEventsOutsideAngular]="{
                keydown: handleKeyDown,
                click: handleClick
            }">
            <li role="menuitem" unselectable="on" class="k-item k-menu-item" [attr.aria-disabled]="first">
              <span class="k-link k-menu-link" [class.k-disabled]="first">
                <kendo-icon-wrapper
                  [name]="rtl ? 'arrow-right' : 'arrow-left'"
                [svgIcon]="rtl ? arrowRightIcon : arrowLeftIcon"></kendo-icon-wrapper>
                <span class="k-menu-link-text">{{messageFor('groupChipMenuPrevious')}}</span>
              </span>
            </li>
            <li role="menuitem" unselectable="on" class="k-item k-menu-item" [attr.aria-disabled]="last">
              <span class="k-link k-menu-link" [class.k-disabled]="last">
                <kendo-icon-wrapper
                  [name]="rtl ? 'arrow-left' : 'arrow-right'"
                [svgIcon]="rtl ? arrowLeftIcon : arrowRightIcon"></kendo-icon-wrapper>
                <span class="k-menu-link-text">{{messageFor('groupChipMenuNext')}}</span>
              </span>
            </li>
          </ul>
        </ng-template>
        `, isInline: true, dependencies: [{ kind: "directive", type: DropTargetDirective, selector: "[kendoDropTarget]", inputs: ["context"], outputs: ["enter", "leave", "drop"] }, { kind: "component", type: ChipListComponent, selector: "kendo-chiplist, kendo-chip-list", inputs: ["orientation", "selection", "size", "role", "navigable"], outputs: ["selectedChange", "remove"] }, { kind: "component", type: ChipComponent, selector: "kendo-chip", inputs: ["label", "icon", "svgIcon", "iconClass", "avatarSettings", "selected", "removable", "removeIcon", "removeSvgIcon", "hasMenu", "menuIcon", "menuSvgIcon", "disabled", "size", "rounded", "fillMode", "themeColor"], outputs: ["remove", "menuToggle", "contentClick"] }, { kind: "directive", type: DraggableColumnDirective, selector: "[kendoDraggableColumn]", inputs: ["context", "enableDrag"], outputs: ["drag"] }, { kind: "directive", type: DraggableDirective, selector: "[kendoDraggable]", inputs: ["enableDrag"], outputs: ["kendoPress", "kendoDrag", "kendoRelease"] }, { kind: "directive", type: EventsOutsideAngularDirective, selector: "[kendoEventsOutsideAngular]", inputs: ["kendoEventsOutsideAngular", "scope"] }, { kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GroupPanelComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-grid-group-panel',
                    template: `
        @if (groups.length === 0) {
          <div
            class="k-grouping-drop-container"
            [context]="{
                lastTarget: true
            }"
            kendoDropTarget
            >
            {{ text }}
          </div>
        }
        
        @if (groups.length !== 0) {
          <kendo-chiplist
            [navigable]="navigable"
            role="none"
            [orientation]="null"
            >
            @for (group of groups; track group; let index = $index; let first = $first; let last = $last) {
              <kendo-chip
                #chip
                kendoDropTarget
                kendoDraggableColumn
                kendoDraggable
                [title]="getTitle(group)"
                [enableDrag]="true"
                [context]="{
                    field: group.field,
                    type: 'groupIndicator',
                    hint:  groupTitles[index],
                    target: chip
                }"
                [label]="groupTitles[index]"
                [removable]="true"
                [hasMenu]="true"
                [icon]="getDirectionIcon(group)"
                [svgIcon]="getDirectionSvgIcon(group)"
                [attr.aria-haspopup]="'menu'"
                [attr.aria-expanded]="isChipMenuOpen"
                [attr.aria-controls]="gridId"
                (contentClick)="directionChange(group)"
                (remove)="remove(group)"
                (menuToggle)="toggleMenu(chip, first, last, group.field)"
                (keydown.alt.arrowdown)="$event.preventDefault(); toggleMenu(chip, first, last, group.field)"
                >
              </kendo-chip>
            }
          </kendo-chiplist>
        }
        
        @if (groups.length !== 0) {
          <div
            class="k-grouping-drop-container"
            [context]="{
                lastTarget: true
            }"
            kendoDropTarget
          >&nbsp;</div>
        }
        
        <ng-template #defaultTemplate>
            <ul unselectable="on" role="menu" class="k-group k-menu-group k-reset k-menu-group-md" [kendoEventsOutsideAngular]="{
                keydown: handleKeyDown,
                click: handleClick
            }">
            <li role="menuitem" unselectable="on" class="k-item k-menu-item" [attr.aria-disabled]="first">
              <span class="k-link k-menu-link" [class.k-disabled]="first">
                <kendo-icon-wrapper
                  [name]="rtl ? 'arrow-right' : 'arrow-left'"
                [svgIcon]="rtl ? arrowRightIcon : arrowLeftIcon"></kendo-icon-wrapper>
                <span class="k-menu-link-text">{{messageFor('groupChipMenuPrevious')}}</span>
              </span>
            </li>
            <li role="menuitem" unselectable="on" class="k-item k-menu-item" [attr.aria-disabled]="last">
              <span class="k-link k-menu-link" [class.k-disabled]="last">
                <kendo-icon-wrapper
                  [name]="rtl ? 'arrow-left' : 'arrow-right'"
                [svgIcon]="rtl ? arrowLeftIcon : arrowRightIcon"></kendo-icon-wrapper>
                <span class="k-menu-link-text">{{messageFor('groupChipMenuNext')}}</span>
              </span>
            </li>
          </ul>
        </ng-template>
        `,
                    standalone: true,
                    imports: [DropTargetDirective, ChipListComponent, ChipComponent, DraggableColumnDirective, DraggableDirective, EventsOutsideAngularDirective, IconWrapperComponent]
                }]
        }], ctorParameters: () => [{ type: DragHintService }, { type: DropCueService }, { type: GroupInfoService }, { type: ContextService }, { type: i0.ChangeDetectorRef }, { type: i2.PopupService }, { type: i0.NgZone }, { type: i0.Renderer2 }], propDecorators: { change: [{
                type: Output
            }], groupHeaderClass: [{
                type: HostBinding,
                args: ["class.k-grouping-header"]
            }], text: [{
                type: Input
            }], navigable: [{
                type: Input
            }], groups: [{
                type: Input
            }], dropTargets: [{
                type: ViewChildren,
                args: [DropTargetDirective]
            }], defaultTemplate: [{
                type: ViewChild,
                args: ['defaultTemplate', { static: true, read: TemplateRef }]
            }] } });

const localizeOperators$1 = operators => localization => Object.keys(operators).reduce((acc, key) => {
    acc[operators[key]] = localization.get(key);
    return acc;
}, {});
const operatorTexts = localizeOperators$1({
    'filterEqOperator': 'eq',
    'filterNotEqOperator': 'neq',
    'filterGteOperator': 'gte',
    'filterGtOperator': 'gt',
    'filterLteOperator': 'lte',
    'filterLtOperator': 'lt',
    'filterIsNullOperator': 'isnull',
    'filterIsNotNullOperator': 'isnotnull',
    'filterIsEmptyOperator': 'isempty',
    'filterIsNotEmptyOperator': 'isnotempty',
    'filterContainsOperator': 'contains',
    'filterNotContainsOperator': 'doesnotcontain',
    'filterStartsWithOperator': 'startswith',
    'filterEndsWithOperator': 'endswith',
    'filterAfterOrEqualOperator': 'after-eq',
    'filterAfterOperator': 'after',
    'filterBeforeOrEqualOperator': 'before-eq',
    'filterBeforeOperator': 'before'
});
/**
 * @hidden
 */
const toJSON = (xs) => xs.map(x => x.toJSON());
/**
 * @hidden
 */
class FilterOperatorBase {
    operator;
    ctx;
    /**
     * The text that will be displayed in the drop-down list.
     * @readonly
     * @type {string}
     * @memberOf FilterOperatorBase
     */
    get text() {
        return this._text;
    }
    set text(value) {
        this._text = isNullOrEmptyString(value) ? this.messages[this.operator] : value;
    }
    subscription;
    messages;
    _text;
    constructor(operator, ctx) {
        this.operator = operator;
        this.ctx = ctx;
        this.messages = operatorTexts(this.ctx.localization);
        this._text = this.messages[this.operator];
        this.subscription = this.ctx.localization.changes.subscribe(this.refreshText.bind(this));
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
    /**
     * @hidden
     */
    toJSON() {
        return {
            text: this.text,
            value: this.operator
        };
    }
    refreshText() {
        const update = this._text === this.messages[this.operator];
        this.messages = operatorTexts(this.ctx.localization);
        if (update) {
            this._text = this.messages[this.operator];
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FilterOperatorBase, deps: [{ token: 'filterOperator' }, { token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: FilterOperatorBase, isStandalone: true, selector: "kendo-grid-filter-operator-base", inputs: { text: "text" }, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FilterOperatorBase, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-filter-operator-base',
                    template: ``
                }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: ['filterOperator']
                }] }, { type: ContextService }], propDecorators: { text: [{
                type: Input
            }] } });

/**
 * Represents the `Contains` (**Contains**) filter operator. [See example](slug:filtering_grid#toc-using-the-built-in-directive).
 * Use this operator to filter values that contain the specified text.
 * For more information and examples, see the article on setting [default filter operators](slug:filter_row#toc-default-filter-operator).
 *
 * @example
 * ```html Filter Cell
 * <kendo-grid-column field="ProductName" title="Product Name">
 *   <ng-template kendoGridFilterCellTemplate let-filter let-column="column">
 *     <kendo-grid-string-filter-cell
 *       [column]="column"
 *       [filter]="filter">
 *       <kendo-filter-contains-operator></kendo-filter-contains-operator>
 *     </kendo-grid-string-filter-cell>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 * ```html Filter Menu
 * <kendo-grid-column field="ProductName" title="Product Name">
 *   <ng-template kendoGridFilterMenuTemplate let-filter let-column="column" let-filterService="filterService">
 *     <kendo-grid-string-filter-menu
 *       [column]="column"
 *       [filter]="filter"
 *       [filterService]="filterService">
 *       <kendo-filter-contains-operator></kendo-filter-contains-operator>
 *     </kendo-grid-string-filter-menu>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 */
class ContainsFilterOperatorComponent extends FilterOperatorBase {
    constructor(ctx) { super('contains', ctx); }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ContainsFilterOperatorComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: ContainsFilterOperatorComponent, isStandalone: true, selector: "kendo-filter-contains-operator", providers: [
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => ContainsFilterOperatorComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ContainsFilterOperatorComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: FilterOperatorBase,
                            useExisting: forwardRef(() => ContainsFilterOperatorComponent)
                        }
                    ],
                    selector: 'kendo-filter-contains-operator',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: ContextService }] });

/**
 * Represents the `DoesNotContain` (**Does not contain**) filter operator. [See example](slug:filtering_grid#toc-using-the-built-in-directive).
 * Use this operator to filter values that do not contain the specified text.
 * For more information and examples, see the article on setting [default filter operators](slug:filter_row#toc-default-filter-operator).
 *
 * @example
 * ```html Filter Cell
 * <kendo-grid-column field="ProductName" title="Product Name">
 *   <ng-template kendoGridFilterCellTemplate let-filter let-column="column">
 *     <kendo-grid-string-filter-cell
 *       [column]="column"
 *       [filter]="filter">
 *       <kendo-filter-not-contains-operator></kendo-filter-not-contains-operator>
 *     </kendo-grid-string-filter-cell>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 * ```html Filter Menu
 * <kendo-grid-column field="ProductName" title="Product Name">
 *   <ng-template kendoGridFilterMenuTemplate let-filter let-column="column" let-filterService="filterService">
 *     <kendo-grid-string-filter-menu
 *       [column]="column"
 *       [filter]="filter"
 *       [filterService]="filterService">
 *      <kendo-filter-not-contains-operator></kendo-filter-not-contains-operator>
 *    </kendo-grid-string-filter-menu>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 */
class DoesNotContainFilterOperatorComponent extends FilterOperatorBase {
    constructor(ctx) { super('doesnotcontain', ctx); }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DoesNotContainFilterOperatorComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: DoesNotContainFilterOperatorComponent, isStandalone: true, selector: "kendo-filter-not-contains-operator", providers: [
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => DoesNotContainFilterOperatorComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DoesNotContainFilterOperatorComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: FilterOperatorBase,
                            useExisting: forwardRef(() => DoesNotContainFilterOperatorComponent)
                        }
                    ],
                    selector: 'kendo-filter-not-contains-operator',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: ContextService }] });

/**
 * Represents the `EndsWith` (**Ends with**) string filter operator. [See example](slug:filtering_grid#toc-using-the-built-in-directive).
 * Use this operator to filter values that end with the specified text.
 * For more information and examples, see the article on setting [default filter operators](slug:filter_row#toc-default-filter-operator).
 *
 * @example
 * ```html Filter Cell
 * <kendo-grid-column field="ProductName" title="Product Name">
 *   <ng-template kendoGridFilterCellTemplate let-filter let-column="column">
 *     <kendo-grid-string-filter-cell
 *       [column]="column"
 *       [filter]="filter">
 *       <kendo-filter-endswith-operator></kendo-filter-endswith-operator>
 *     </kendo-grid-string-filter-cell>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 * ```html Filter Menu
 * <kendo-grid-column field="ProductName" title="Product Name">
 *   <ng-template kendoGridFilterMenuTemplate let-filter let-column="column" let-filterService="filterService">
 *     <kendo-grid-string-filter-menu
 *       [column]="column"
 *       [filter]="filter"
 *       [filterService]="filterService">
 *       <kendo-filter-endswith-operator></kendo-filter-endswith-operator>
 *     </kendo-grid-string-filter-menu>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 */
class EndsWithFilterOperatorComponent extends FilterOperatorBase {
    constructor(ctx) { super('endswith', ctx); }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: EndsWithFilterOperatorComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: EndsWithFilterOperatorComponent, isStandalone: true, selector: "kendo-filter-endswith-operator", providers: [
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => EndsWithFilterOperatorComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: EndsWithFilterOperatorComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: FilterOperatorBase,
                            useExisting: forwardRef(() => EndsWithFilterOperatorComponent)
                        }
                    ],
                    selector: 'kendo-filter-endswith-operator',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: ContextService }] });

/**
 * Represents the `Equal` (**Is equal to**) filter operator. [See example](slug:filtering_grid#toc-using-the-built-in-directive).
 * Use this operator to filter values that are equal to the specified value.
 * For more information and examples, see the article on setting [default filter operators](slug:filter_row#toc-default-filter-operator).
 *
 * @example
 * ```html String Filter Cell
 * <kendo-grid-column field="ProductName" title="Product Name">
 *   <ng-template kendoGridFilterCellTemplate let-filter let-column="column">
 *     <kendo-grid-string-filter-cell
 *       [column]="column"
 *       [filter]="filter">
 *       <kendo-filter-eq-operator></kendo-filter-eq-operator>
 *     </kendo-grid-string-filter-cell>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 * ```html Numeric Filter Cell
 * <kendo-grid-column field="UnitPrice" title="Price">
 *   <ng-template kendoGridFilterCellTemplate let-filter let-column="column">
 *     <kendo-grid-numeric-filter-cell
 *       [column]="column"
 *       [filter]="filter">
 *       <kendo-filter-eq-operator></kendo-filter-eq-operator>
 *     </kendo-grid-numeric-filter-cell>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 * ```html Date Filter Cell
 * <kendo-grid-column field="FirstOrderedOn">
 *   <ng-template kendoGridFilterCellTemplate let-filter let-column="column">
 *     <kendo-grid-date-filter-cell
 *       [column]="column"
 *       [filter]="filter">
 *       <kendo-filter-eq-operator></kendo-filter-eq-operator>
 *      </kendo-grid-date-filter-cell>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 *
 * @example
 * ```html String Filter Menu
 * <kendo-grid-column field="ProductName" title="Product Name">
 *   <ng-template kendoGridFilterMenuTemplate let-filter let-column="column" let-filterService="filterService">
 *     <kendo-grid-string-filter-menu
 *       [column]="column"
 *       [filter]="filter"
 *       [filterService]="filterService">
 *       <kendo-filter-eq-operator></kendo-filter-eq-operator>
 *     </kendo-grid-string-filter-menu>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 * ```html Numeric Filter Menu
 * <kendo-grid-column field="UnitPrice" title="Price">
 *   <ng-template kendoGridFilterMenuTemplate let-filter let-column="column" let-filterService="filterService">
 *     <kendo-grid-numeric-filter-menu
 *       [column]="column"
 *       [filter]="filter"
 *       [filterService]="filterService">
 *       <kendo-filter-eq-operator></kendo-filter-eq-operator>
 *     </kendo-grid-numeric-filter-menu>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 * ```html Date Filter Menu
 * <kendo-grid-column field="FirstOrderedOn">
 *   <ng-template kendoGridFilterMenuTemplate let-filter let-column="column" let-filterService="filterService">
 *     <kendo-grid-date-filter-menu
 *       [column]="column"
 *       [filter]="filter"
 *       [filterService]="filterService">
 *       <kendo-filter-eq-operator></kendo-filter-eq-operator>
 *      </kendo-grid-date-filter-menu>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 */
class EqualFilterOperatorComponent extends FilterOperatorBase {
    constructor(ctx) { super('eq', ctx); }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: EqualFilterOperatorComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: EqualFilterOperatorComponent, isStandalone: true, selector: "kendo-filter-eq-operator", providers: [
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => EqualFilterOperatorComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: EqualFilterOperatorComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: FilterOperatorBase,
                            useExisting: forwardRef(() => EqualFilterOperatorComponent)
                        }
                    ],
                    selector: 'kendo-filter-eq-operator',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: ContextService }] });

/**
 * Represents the `IsEmpty` (**Is empty**) filter operator. [See example](slug:filtering_grid#toc-using-the-built-in-directive).
 * Use this operator to filter out values that are empty strings.
 * For more information and examples, see the article on setting [default filter operators](slug:filter_row#toc-default-filter-operator).
 *
 * @example
 * ```html Filter Cell
 * <kendo-grid-column field="ProductName" title="Product Name">
 *   <ng-template kendoGridFilterCellTemplate let-filter let-column="column">
 *     <kendo-grid-string-filter-cell
 *       [column]="column"
 *       [filter]="filter">
 *       <kendo-filter-isempty-operator></kendo-filter-isempty-operator>
 *     </kendo-grid-string-filter-cell>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 * ```html Filter Menu
 * <kendo-grid-column field="ProductName" title="Product Name">
 *   <ng-template kendoGridFilterMenuTemplate let-filter let-column="column" let-filterService="filterService">
 *     <kendo-grid-string-filter-menu
 *       [column]="column"
 *       [filter]="filter"
 *       [filterService]="filterService">
 *       <kendo-filter-isempty-operator></kendo-filter-isempty-operator>
 *     </kendo-grid-string-filter-menu>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 */
class IsEmptyFilterOperatorComponent extends FilterOperatorBase {
    constructor(ctx) { super('isempty', ctx); }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: IsEmptyFilterOperatorComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: IsEmptyFilterOperatorComponent, isStandalone: true, selector: "kendo-filter-isempty-operator", providers: [
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => IsEmptyFilterOperatorComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: IsEmptyFilterOperatorComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: FilterOperatorBase,
                            useExisting: forwardRef(() => IsEmptyFilterOperatorComponent)
                        }
                    ],
                    selector: 'kendo-filter-isempty-operator',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: ContextService }] });

/**
 * Represents the `IsNotEmpty` (**Is not empty**) filter operator. [See example](slug:filtering_grid#toc-using-the-built-in-directive).
 * Use this operator to filter out values that are not empty strings.
 * For more information and examples, see the article on setting [default filter operators](slug:filter_row#toc-default-filter-operator).
 *
 * @example
 * ```html Filter Cell
 * <kendo-grid-column field="ProductName" title="Product Name">
 *   <ng-template kendoGridFilterCellTemplate let-filter let-column="column">
 *     <kendo-grid-string-filter-cell
 *       [column]="column"
 *       [filter]="filter">
 *       <kendo-filter-isnotempty-operator></kendo-filter-isnotempty-operator>
 *     </kendo-grid-string-filter-cell>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 * ```html Filter Menu
 * <kendo-grid-column field="ProductName" title="Product Name">
 *   <ng-template kendoGridFilterMenuTemplate let-filter let-column="column" let-filterService="filterService">
 *     <kendo-grid-string-filter-menu
 *       [column]="column"
 *       [filter]="filter"
 *       [filterService]="filterService">
 *       <kendo-filter-isnotempty-operator></kendo-filter-isnotempty-operator>
 *     </kendo-grid-string-filter-menu>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 */
class IsNotEmptyFilterOperatorComponent extends FilterOperatorBase {
    constructor(ctx) { super('isnotempty', ctx); }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: IsNotEmptyFilterOperatorComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: IsNotEmptyFilterOperatorComponent, isStandalone: true, selector: "kendo-filter-isnotempty-operator", providers: [
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => IsNotEmptyFilterOperatorComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: IsNotEmptyFilterOperatorComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: FilterOperatorBase,
                            useExisting: forwardRef(() => IsNotEmptyFilterOperatorComponent)
                        }
                    ],
                    selector: 'kendo-filter-isnotempty-operator',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: ContextService }] });

/**
 * Represents the `IsNotNull` (**Is not null**) filter operator. [See example](slug:filtering_grid#toc-using-the-built-in-directive).
 * Use this operator to filter out values that are not null.
 * For more information and examples, see the article on setting [default filter operators](slug:filter_row#toc-default-filter-operator).
 *
 * @example
 * ```html String Filter Cell
 * <kendo-grid-column field="ProductName" title="Product Name">
 *   <ng-template kendoGridFilterCellTemplate let-filter let-column="column">
 *     <kendo-grid-string-filter-cell
 *       [column]="column"
 *       [filter]="filter">
 *       <kendo-filter-isnotnull-operator></kendo-filter-isnotnull-operator>
 *     </kendo-grid-string-filter-cell>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 * ```html Numeric Filter Cell
 * <kendo-grid-column field="UnitPrice" title="Price">
 *   <ng-template kendoGridFilterCellTemplate let-filter let-column="column">
 *     <kendo-grid-numeric-filter-cell
 *       [column]="column"
 *       [filter]="filter">
 *       <kendo-filter-isnotnull-operator></kendo-filter-isnotnull-operator>
 *     </kendo-grid-numeric-filter-cell>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 * ```html Date Filter Cell
 * <kendo-grid-column field="FirstOrderedOn">
 *   <ng-template kendoGridFilterCellTemplate let-filter let-column="column">
 *     <kendo-grid-date-filter-cell
 *       [column]="column"
 *       [filter]="filter">
 *       <kendo-filter-isnotnull-operator></kendo-filter-isnotnull-operator>
 *      </kendo-grid-date-filter-cell>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 * @example
 * ```html String Filter Menu
 * <kendo-grid-column field="ProductName" title="Product Name">
 *   <ng-template kendoGridFilterMenuTemplate let-filter let-column="column" let-filterService="filterService">
 *     <kendo-grid-string-filter-menu
 *       [column]="column"
 *       [filter]="filter"
 *       [filterService]="filterService">
 *       <kendo-filter-isnotnull-operator></kendo-filter-isnotnull-operator>
 *     </kendo-grid-string-filter-menu>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 * ```html Numeric Filter Menu
 * <kendo-grid-column field="UnitPrice" title="Price">
 *   <ng-template kendoGridFilterMenuTemplate let-filter let-column="column" let-filterService="filterService">
 *     <kendo-grid-numeric-filter-menu
 *       [column]="column"
 *       [filter]="filter"
 *       [filterService]="filterService">
 *       <kendo-filter-isnotnull-operator></kendo-filter-isnotnull-operator>
 *     </kendo-grid-numeric-filter-menu>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 * ```html Date Filter Menu
 * <kendo-grid-column field="FirstOrderedOn">
 *  <ng-template kendoGridFilterMenuTemplate let-filter let-column="column" let-filterService="filterService">
 *    <kendo-grid-date-filter-menu
 *       [column]="column"
 *       [filter]="filter"
 *       [filterService]="filterService">
 *       <kendo-filter-isnotnull-operator></kendo-filter-isnotnull-operator>
 *     </kendo-grid-date-filter-menu>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 */
class IsNotNullFilterOperatorComponent extends FilterOperatorBase {
    constructor(ctx) { super('isnotnull', ctx); }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: IsNotNullFilterOperatorComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: IsNotNullFilterOperatorComponent, isStandalone: true, selector: "kendo-filter-isnotnull-operator", providers: [
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => IsNotNullFilterOperatorComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: IsNotNullFilterOperatorComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: FilterOperatorBase,
                            useExisting: forwardRef(() => IsNotNullFilterOperatorComponent)
                        }
                    ],
                    selector: 'kendo-filter-isnotnull-operator',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: ContextService }] });

/**
 * Represents the `IsNull` (**Is null**) filter operator. [See example](slug:filtering_grid#toc-using-the-built-in-directive).
 * Use this operator to filter out values that are null.
 * For more information and examples, see the article on setting [default filter operators](slug:filter_row#toc-default-filter-operator).
 *
 * @example
 * ```html String Filter Cell
 * <kendo-grid-column field="ProductName" title="Product Name">
 *   <ng-template kendoGridFilterCellTemplate let-filter let-column="column">
 *     <kendo-grid-string-filter-cell
 *       [column]="column"
 *       [filter]="filter">
 *       <kendo-filter-isnull-operator></kendo-filter-isnull-operator>
 *     </kendo-grid-string-filter-cell>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 * ```html Numeric Filter Cell
 * <kendo-grid-column field="UnitPrice" title="Price">
 *   <ng-template kendoGridFilterCellTemplate let-filter let-column="column">
 *     <kendo-grid-numeric-filter-cell
 *       [column]="column"
 *       [filter]="filter">
 *       <kendo-filter-isnull-operator></kendo-filter-isnull-operator>
 *     </kendo-grid-numeric-filter-cell>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 * ```html Date Filter Cell
 * <kendo-grid-column field="FirstOrderedOn">
 *   <ng-template kendoGridFilterCellTemplate let-filter let-column="column">
 *     <kendo-grid-date-filter-cell
 *       [column]="column"
 *       [filter]="filter">
 *       <kendo-filter-isnull-operator></kendo-filter-isnull-operator>
 *      </kendo-grid-date-filter-cell>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 * @example
 * ```html String Filter Menu
 * <kendo-grid-column field="ProductName" title="Product Name">
 *   <ng-template kendoGridFilterMenuTemplate let-filter let-column="column" let-filterService="filterService">
 *     <kendo-grid-string-filter-menu
 *       [column]="column"
 *       [filter]="filter"
 *       [filterService]="filterService">
 *       <kendo-filter-isnull-operator></kendo-filter-isnull-operator>
 *     </kendo-grid-string-filter-menu>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 * ```html Numeric Filter Menu
 * <kendo-grid-column field="UnitPrice" title="Price">
 *   <ng-template kendoGridFilterMenuTemplate let-filter let-column="column" let-filterService="filterService">
 *     <kendo-grid-numeric-filter-menu
 *       [column]="column"
 *       [filter]="filter"
 *       [filterService]="filterService">
 *       <kendo-filter-isnull-operator></kendo-filter-isnull-operator>
 *     </kendo-grid-numeric-filter-menu>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 * ```html Date Filter Menu
 * <kendo-grid-column field="FirstOrderedOn">
 *   <ng-template kendoGridFilterMenuTemplate let-filter let-column="column" let-filterService="filterService">
 *     <kendo-grid-date-filter-menu
 *       [column]="column"
 *       [filter]="filter"
 *       [filterService]="filterService">
 *       <kendo-filter-isnull-operator></kendo-filter-isnull-operator>
 *     </kendo-grid-date-filter-menu>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 */
class IsNullFilterOperatorComponent extends FilterOperatorBase {
    constructor(ctx) { super('isnull', ctx); }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: IsNullFilterOperatorComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: IsNullFilterOperatorComponent, isStandalone: true, selector: "kendo-filter-isnull-operator", providers: [
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => IsNullFilterOperatorComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: IsNullFilterOperatorComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: FilterOperatorBase,
                            useExisting: forwardRef(() => IsNullFilterOperatorComponent)
                        }
                    ],
                    selector: 'kendo-filter-isnull-operator',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: ContextService }] });

/**
 * Represents the `NotEqual` (**Is not equal to**) filter operator. [See example](slug:filtering_grid#toc-using-the-built-in-directive).
 * Use this operator to filter values that are not equal to the specified value.
 * For more information and examples, see the article on setting [default filter operators](slug:filter_row#toc-default-filter-operator).
 *
 * @example
 * ```html String Filter Cell
 * <kendo-grid-column field="ProductName" title="Product Name">
 *   <ng-template kendoGridFilterCellTemplate let-filter let-column="column">
 *     <kendo-grid-string-filter-cell
 *       [column]="column"
 *       [filter]="filter">
 *       <kendo-filter-neq-operator></kendo-filter-neq-operator>
 *     </kendo-grid-string-filter-cell>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 * ```html Numeric Filter Cell
 * <kendo-grid-column field="UnitPrice" title="Price">
 *   <ng-template kendoGridFilterCellTemplate let-filter let-column="column">
 *     <kendo-grid-numeric-filter-cell
 *       [column]="column"
 *       [filter]="filter">
 *       <kendo-filter-neq-operator></kendo-filter-neq-operator>
 *     </kendo-grid-numeric-filter-cell>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 * ```html Date Filter Cell
 * <kendo-grid-column field="FirstOrderedOn">
 *   <ng-template kendoGridFilterCellTemplate let-filter let-column="column">
 *     <kendo-grid-date-filter-cell
 *       [column]="column"
 *       [filter]="filter">
 *       <kendo-filter-neq-operator></kendo-filter-neq-operator>
 *      </kendo-grid-date-filter-cell>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 * @example
 * ```html String Filter Menu
 * <kendo-grid-column field="ProductName" title="Product Name">
 *   <ng-template kendoGridFilterMenuTemplate let-filter let-column="column" let-filterService="filterService">
 *     <kendo-grid-string-filter-menu
 *       [column]="column"
 *       [filter]="filter"
 *       [filterService]="filterService">
 *       <kendo-filter-neq-operator></kendo-filter-neq-operator>
 *     </kendo-grid-string-filter-menu>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 * ```html Numeric Filter Menu
 * <kendo-grid-column field="UnitPrice" title="Price">
 *   <ng-template kendoGridFilterMenuTemplate let-filter let-column="column" let-filterService="filterService">
 *     <kendo-grid-numeric-filter-menu
 *       [column]="column"
 *       [filter]="filter"
 *       [filterService]="filterService">
 *       <kendo-filter-neq-operator></kendo-filter-neq-operator>
 *     </kendo-grid-numeric-filter-menu>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 * ```html Date Filter Menu
 * <kendo-grid-column field="FirstOrderedOn">
 *  <ng-template kendoGridFilterMenuTemplate let-filter let-column="column" let-filterService="filterService">
 *     <kendo-grid-date-filter-menu
 *       [column]="column"
 *       [filter]="filter"
 *       [filterService]="filterService">
 *       <kendo-filter-neq-operator></kendo-filter-neq-operator>
 *     </kendo-grid-date-filter-menu>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 */
class NotEqualFilterOperatorComponent extends FilterOperatorBase {
    constructor(ctx) { super('neq', ctx); }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: NotEqualFilterOperatorComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: NotEqualFilterOperatorComponent, isStandalone: true, selector: "kendo-filter-neq-operator", providers: [
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => NotEqualFilterOperatorComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: NotEqualFilterOperatorComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: FilterOperatorBase,
                            useExisting: forwardRef(() => NotEqualFilterOperatorComponent)
                        }
                    ],
                    selector: 'kendo-filter-neq-operator',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: ContextService }] });

/**
 * Represents the `StartsWith` (**Starts with**) filter operator. [See example](slug:filtering_grid#toc-using-the-built-in-directive).
 * Use this operator to filter values that start with the specified text.
 * For more information and examples, see the article on setting [default filter operators](slug:filter_row#toc-default-filter-operator).
 *
 * @example
 * ```html Filter Cell
 * <kendo-grid-column field="ProductName" title="Product Name">
 *   <ng-template kendoGridFilterCellTemplate let-filter let-column="column">
 *     <kendo-grid-string-filter-cell
 *       [column]="column"
 *       [filter]="filter">
 *       <kendo-filter-startswith-operator></kendo-filter-startswith-operator>
 *     </kendo-grid-string-filter-cell>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 * ```html Filter Menu
 * <kendo-grid-column field="ProductName" title="Product Name">
 *   <ng-template kendoGridFilterMenuTemplate let-filter let-column="column" let-filterService="filterService">
 *     <kendo-grid-string-filter-menu
 *       [column]="column"
 *       [filter]="filter"
 *       [filterService]="filterService">
 *       <kendo-filter-startswith-operator></kendo-filter-startswith-operator>
 *     </kendo-grid-string-filter-menu>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 */
class StartsWithFilterOperatorComponent extends FilterOperatorBase {
    constructor(ctx) { super('startswith', ctx); }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: StartsWithFilterOperatorComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: StartsWithFilterOperatorComponent, isStandalone: true, selector: "kendo-filter-startswith-operator", providers: [
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => StartsWithFilterOperatorComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: StartsWithFilterOperatorComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: FilterOperatorBase,
                            useExisting: forwardRef(() => StartsWithFilterOperatorComponent)
                        }
                    ],
                    selector: 'kendo-filter-startswith-operator',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: ContextService }] });

/**
 * Represents the `Greater` (**Is greater than**) [numeric filter](slug:filtering_grid#toc-numeric-filter) operator.
 * Use this operator to filter values greater than the specified number.
 * [See example](slug:filter_row#toc-default-filter-operator).
 *
 * @example
 * ```html Filter Cell
 * <kendo-grid-column field="UnitPrice" title="Price">
 *   <ng-template kendoGridFilterCellTemplate let-filter let-column="column">
 *     <kendo-grid-numeric-filter-cell
 *       [column]="column"
 *       [filter]="filter">
 *       <kendo-filter-gt-operator></kendo-filter-gt-operator>
 *     </kendo-grid-numeric-filter-cell>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 * ```html Filter Menu
 * <kendo-grid-column field="UnitPrice" title="Price">
 *   <ng-template kendoGridFilterMenuTemplate let-filter let-column="column" let-filterService="filterService">
 *     <kendo-grid-numeric-filter-menu
 *       [column]="column"
 *       [filter]="filter"
 *       [filterService]="filterService">
 *       <kendo-filter-gt-operator></kendo-filter-gt-operator>
 *     </kendo-grid-numeric-filter-menu>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 */
class GreaterFilterOperatorComponent extends FilterOperatorBase {
    constructor(ctx) { super('gt', ctx); }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GreaterFilterOperatorComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: GreaterFilterOperatorComponent, isStandalone: true, selector: "kendo-filter-gt-operator", providers: [
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => GreaterFilterOperatorComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GreaterFilterOperatorComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: FilterOperatorBase,
                            useExisting: forwardRef(() => GreaterFilterOperatorComponent)
                        }
                    ],
                    selector: 'kendo-filter-gt-operator',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: ContextService }] });

/**
 * Represents the `GreaterOrEqualTo` (**Is greater than or equal to**) [numeric filter](slug:filtering_grid#toc-numeric-filter) operator.
 * Use this operator to filter values greater than or equal to the specified number.
 * [See example](slug:filter_row#toc-default-filter-operator).
 *
 * @example
 * ```html Filter Cell
 * <kendo-grid-column field="UnitPrice" title="Price">
 *   <ng-template kendoGridFilterCellTemplate let-filter let-column="column">
 *     <kendo-grid-numeric-filter-cell
 *       [column]="column"
 *       [filter]="filter">
 *       <kendo-filter-gte-operator></kendo-filter-gte-operator>
 *     </kendo-grid-numeric-filter-cell>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 * ```html Filter Menu
 * <kendo-grid-column field="UnitPrice" title="Price">
 *   <ng-template kendoGridFilterMenuTemplate let-filter let-column="column" let-filterService="filterService">
 *     <kendo-grid-numeric-filter-menu
 *       [column]="column"
 *       [filter]="filter"
 *       [filterService]="filterService">
 *       <kendo-filter-gte-operator></kendo-filter-gte-operator>
 *     </kendo-grid-numeric-filter-menu>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 */
class GreaterOrEqualToFilterOperatorComponent extends FilterOperatorBase {
    constructor(ctx) { super('gte', ctx); }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GreaterOrEqualToFilterOperatorComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: GreaterOrEqualToFilterOperatorComponent, isStandalone: true, selector: "kendo-filter-gte-operator", providers: [
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => GreaterOrEqualToFilterOperatorComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GreaterOrEqualToFilterOperatorComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: FilterOperatorBase,
                            useExisting: forwardRef(() => GreaterOrEqualToFilterOperatorComponent)
                        }
                    ],
                    selector: 'kendo-filter-gte-operator',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: ContextService }] });

/**
 * Represents the `Less` (**Is less than**) [numeric filter](slug:filtering_grid#toc-numeric-filter) operator.
 * Use this operator to filter values less than the specified number.
 * [See example](slug:filter_row#toc-default-filter-operator).
 *
 * @example
 * ```html Filter Cell
 * <kendo-grid-column field="UnitPrice" title="Price">
 *   <ng-template kendoGridFilterCellTemplate let-filter let-column="column">
 *     <kendo-grid-numeric-filter-cell
 *       [column]="column"
 *       [filter]="filter">
 *       <kendo-filter-lt-operator></kendo-filter-lt-operator>
 *     </kendo-grid-numeric-filter-cell>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 * ```html Filter Menu
 * <kendo-grid-column field="UnitPrice" title="Price">
 *   <ng-template kendoGridFilterMenuTemplate let-filter let-column="column" let-filterService="filterService">
 *     <kendo-grid-numeric-filter-menu
 *       [column]="column"
 *       [filter]="filter"
 *       [filterService]="filterService">
 *       <kendo-filter-lt-operator></kendo-filter-lt-operator>
 *     </kendo-grid-numeric-filter-menu>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 */
class LessFilterOperatorComponent extends FilterOperatorBase {
    constructor(ctx) { super('lt', ctx); }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: LessFilterOperatorComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: LessFilterOperatorComponent, isStandalone: true, selector: "kendo-filter-lt-operator", providers: [
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => LessFilterOperatorComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: LessFilterOperatorComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: FilterOperatorBase,
                            useExisting: forwardRef(() => LessFilterOperatorComponent)
                        }
                    ],
                    selector: 'kendo-filter-lt-operator',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: ContextService }] });

/**
 * Represents the `LessOrEqualTo` (**Is less than or equal to**) [numeric filter](slug:filtering_grid#toc-numeric-filter) operator.
 * Use this operator to filter values less than or equal to the specified number.
 * [See example](slug:filter_row#toc-default-filter-operator).
 *
 * @example
 * ```html Filter Cell
 * <kendo-grid-column field="UnitPrice" title="Price">
 *   <ng-template kendoGridFilterCellTemplate let-filter let-column="column">
 *     <kendo-grid-numeric-filter-cell
 *       [column]="column"
 *       [filter]="filter">
 *       <kendo-filter-lte-operator></kendo-filter-lte-operator>
 *     </kendo-grid-numeric-filter-cell>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 * ```html Filter Menu
 * <kendo-grid-column field="UnitPrice" title="Price">
 *   <ng-template kendoGridFilterMenuTemplate let-filter let-column="column" let-filterService="filterService">
 *     <kendo-grid-numeric-filter-menu
 *       [column]="column"
 *       [filter]="filter"
 *       [filterService]="filterService">
 *       <kendo-filter-lte-operator></kendo-filter-lte-operator>
 *     </kendo-grid-numeric-filter-menu>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 */
class LessOrEqualToFilterOperatorComponent extends FilterOperatorBase {
    constructor(ctx) { super('lte', ctx); }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: LessOrEqualToFilterOperatorComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: LessOrEqualToFilterOperatorComponent, isStandalone: true, selector: "kendo-filter-lte-operator", providers: [
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => LessOrEqualToFilterOperatorComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: LessOrEqualToFilterOperatorComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: FilterOperatorBase,
                            useExisting: forwardRef(() => LessOrEqualToFilterOperatorComponent)
                        }
                    ],
                    selector: 'kendo-filter-lte-operator',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: ContextService }] });

/**
 * Represents the `Greater` (**Is after**) [date filter](slug:filtering_grid#toc-date-filter) operator.
 * Use this operator to filter dates after the specified date.
 * [See example](slug:filter_row#toc-default-filter-operator).
 *
 * @example
 * ```html Filter Cell
 * <kendo-grid-column field="FirstOrderedOn">
 *   <ng-template kendoGridFilterCellTemplate let-filter let-column="column">
 *     <kendo-grid-date-filter-cell
 *       [column]="column"
 *       [filter]="filter">
 *       <kendo-filter-after-operator></kendo-filter-after-operator>
 *      </kendo-grid-date-filter-cell>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 * ```html Filter Menu
 * <kendo-grid-column field="FirstOrderedOn">
 *   <ng-template kendoGridFilterMenuTemplate let-filter let-column="column" let-filterService="filterService">
 *     <kendo-grid-date-filter-menu
 *       [column]="column"
 *       [filter]="filter"
 *       [filterService]="filterService">
 *       <kendo-filter-after-operator></kendo-filter-after-operator>
 *     </kendo-grid-date-filter-menu>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 */
class AfterFilterOperatorComponent extends FilterOperatorBase {
    constructor(ctx) { super('after', ctx); }
    /**
     * @hidden
     */
    toJSON() {
        return {
            text: this.text,
            value: 'gt'
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AfterFilterOperatorComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: AfterFilterOperatorComponent, isStandalone: true, selector: "kendo-filter-after-operator", providers: [
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => AfterFilterOperatorComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AfterFilterOperatorComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: FilterOperatorBase,
                            useExisting: forwardRef(() => AfterFilterOperatorComponent)
                        }
                    ],
                    selector: 'kendo-filter-after-operator',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: ContextService }] });

/**
 * Represents the `GreaterOrEqualTo` (**Is after or equal to**) [date filter](slug:filtering_grid#toc-date-filter) operator.
 * Use this operator to filter dates after or equal to the specified date.
 * [See example](slug:filter_row#toc-default-filter-operator).
 *
 * @example
 * ```html Filter Cell
 * <kendo-grid-column field="FirstOrderedOn">
 *   <ng-template kendoGridFilterCellTemplate let-filter let-column="column">
 *     <kendo-grid-date-filter-cell
 *       [column]="column"
 *       [filter]="filter">
 *       <kendo-filter-after-eq-operator></kendo-filter-after-eq-operator>
 *      </kendo-grid-date-filter-cell>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 * ```html Filter Menu
 * <kendo-grid-column field="FirstOrderedOn">
 *   <ng-template kendoGridFilterMenuTemplate let-filter let-column="column" let-filterService="filterService">
 *     <kendo-grid-date-filter-menu
 *       [column]="column"
 *       [filter]="filter"
 *       [filterService]="filterService">
 *       <kendo-filter-after-eq-operator></kendo-filter-after-eq-operator>
 *     </kendo-grid-date-filter-menu>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 */
class AfterEqFilterOperatorComponent extends FilterOperatorBase {
    constructor(ctx) { super('after-eq', ctx); }
    /**
     * @hidden
     */
    toJSON() {
        return {
            text: this.text,
            value: 'gte'
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AfterEqFilterOperatorComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: AfterEqFilterOperatorComponent, isStandalone: true, selector: "kendo-filter-after-eq-operator", providers: [
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => AfterEqFilterOperatorComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AfterEqFilterOperatorComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: FilterOperatorBase,
                            useExisting: forwardRef(() => AfterEqFilterOperatorComponent)
                        }
                    ],
                    selector: 'kendo-filter-after-eq-operator',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: ContextService }] });

/**
 * Represents the `LessOrEqualTo` (**Is before or equal to**) [date filter](slug:filtering_grid#toc-date-filter) operator.
 * Use this operator to filter dates before or equal to the specified date.
 * [See example](slug:filter_row#toc-default-filter-operator).
 *
 * @example
 * ```html Filter Cell
 * <kendo-grid-column field="FirstOrderedOn">
 *   <ng-template kendoGridFilterCellTemplate let-filter let-column="column">
 *     <kendo-grid-date-filter-cell
 *       [column]="column"
 *       [filter]="filter">
 *       <kendo-filter-before-eq-operator></kendo-filter-before-eq-operator>
 *      </kendo-grid-date-filter-cell>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 * ```html Filter Menu
 * <kendo-grid-column field="FirstOrderedOn">
 *   <ng-template kendoGridFilterMenuTemplate let-filter let-column="column" let-filterService="filterService">
 *     <kendo-grid-date-filter-menu
 *       [column]="column"
 *       [filter]="filter"
 *       [filterService]="filterService">
 *       <kendo-filter-before-eq-operator></kendo-filter-before-eq-operator>
 *     </kendo-grid-date-filter-menu>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 */
class BeforeEqFilterOperatorComponent extends FilterOperatorBase {
    constructor(ctx) { super('before-eq', ctx); }
    /**
     * @hidden
     */
    toJSON() {
        return {
            text: this.text,
            value: 'lte'
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: BeforeEqFilterOperatorComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: BeforeEqFilterOperatorComponent, isStandalone: true, selector: "kendo-filter-before-eq-operator", providers: [
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => BeforeEqFilterOperatorComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: BeforeEqFilterOperatorComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: FilterOperatorBase,
                            useExisting: forwardRef(() => BeforeEqFilterOperatorComponent)
                        }
                    ],
                    selector: 'kendo-filter-before-eq-operator',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: ContextService }] });

/**
 * Represents the `Less than` (**Is before**) [date filter](slug:filtering_grid#toc-date-filter) operator.
 * Use this operator to filter dates before the specified date.
 * [See example](slug:filter_row#toc-default-filter-operator).
 *
 * @example
 * ```html Filer Cell
 * <kendo-grid-column field="FirstOrderedOn">
 *   <ng-template kendoGridFilterCellTemplate let-filter let-column="column">
 *     <kendo-grid-date-filter-cell
 *       [column]="column"
 *       [filter]="filter">
 *       <kendo-filter-before-operator></kendo-filter-before-operator>
 *      </kendo-grid-date-filter-cell>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 * ```html Filter Menu
 * <kendo-grid-column field="FirstOrderedOn">
 *   <ng-template kendoGridFilterMenuTemplate let-filter let-column="column" let-filterService="filterService">
 *     <kendo-grid-date-filter-menu
 *       [column]="column"
 *       [filter]="filter"
 *       [filterService]="filterService">
 *       <kendo-filter-before-operator></kendo-filter-before-operator>
 *     </kendo-grid-date-filter-menu>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 */
class BeforeFilterOperatorComponent extends FilterOperatorBase {
    constructor(ctx) { super('before', ctx); }
    /**
     * @hidden
     */
    toJSON() {
        return {
            text: this.text,
            value: 'lt'
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: BeforeFilterOperatorComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: BeforeFilterOperatorComponent, isStandalone: true, selector: "kendo-filter-before-operator", providers: [
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => BeforeFilterOperatorComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: BeforeFilterOperatorComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: FilterOperatorBase,
                            useExisting: forwardRef(() => BeforeFilterOperatorComponent)
                        }
                    ],
                    selector: 'kendo-filter-before-operator',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: ContextService }] });

/**
 * @hidden
*/
class SizingOptionsService {
    changes = new Subject();
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SizingOptionsService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SizingOptionsService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SizingOptionsService, decorators: [{
            type: Injectable
        }] });

/**
 * Represents a component that displays filter operators.
 * Use this component to show a drop-down list of filter operators and a clear button.
 *
 * @example
 * ```html
 * <kendo-grid [data]="gridData">
 *   <kendo-grid-column field="ProductName">
 *     <ng-template kendoGridFilterCellTemplate let-filter let-column="column">
 *       <input />
 *       <kendo-grid-filter-cell-operators
 *         [operators]="[{text: 'Equals', value: 'eq'}]">
 *       </kendo-grid-filter-cell-operators>
 *     </ng-template>
 *   </kendo-grid-column>
 * <kendo-grid>
 * ```
 */
class FilterCellOperatorsComponent {
    ctx;
    sizing;
    clearText = 'Clear';
    filterClearIcon = filterClearIcon;
    /**
     * @hidden
     */
    filterSVGIcon = filterIcon;
    /**
     * @hidden
     */
    size = 'medium';
    /**
     * @hidden
     */
    get hostClasses() {
        return true;
    }
    /**
     * @hidden
     */
    dropdown;
    /**
     * Specifies the filter operators to display.
     * @type {Array<{ text: string, value: string }>}
     */
    operators = [];
    /**
     * Determines if the **Clear** button is displayed.
     * @type {boolean}
     */
    showButton;
    /**
     * Determines if the list of operators is displayed.
     * @type {boolean}
     * @default true
     */
    showOperators = true;
    /**
     * Represents the selected operator value.
     * @type {string}
     */
    value;
    /**
     * Sets the column instance for which the filter operators are displayed.
     * @type {ColumnComponent}
     */
    column;
    /**
     * Fires when the operator value changes.
     * @type {EventEmitter<string>}
     */
    valueChange = new EventEmitter();
    /**
     * Fires when the **Clear** button is clicked.
     * @type {EventEmitter<undefined>}
     */
    clear = new EventEmitter();
    subs;
    constructor(ctx, sizing) {
        this.ctx = ctx;
        this.sizing = sizing;
    }
    /**
     * @hidden
     */
    onChange(dataItem) {
        this.valueChange.emit(dataItem);
    }
    /**
     * @hidden
     */
    clearClick() {
        this.clear.emit();
        return false;
    }
    /**
     * @hidden
     */
    clearKeydown(args) {
        if (args.code === Keys.Enter || args.code === Keys.NumpadEnter || args.code === Keys.Space) {
            this.clear.emit();
        }
    }
    /**
     * @hidden
     */
    dropdownKeydown(args) {
        if (args.defaultPrevented) {
            return;
        }
        if ((args.code === Keys.Enter || args.code === Keys.NumpadEnter) && !this.dropdown.isOpen) {
            this.dropdown.toggle(true);
            args.preventDefault();
        }
    }
    ngOnInit() {
        this.subs = this.ctx.localization.changes.subscribe(() => this.clearText = this.ctx.localization.get('filterClearButton'));
        this.subs.add(this.sizing.changes.subscribe((size) => this.size = size));
    }
    ngOnDestroy() {
        if (this.subs) {
            this.subs.unsubscribe();
        }
    }
    /**
     * @hidden
     */
    get columnLabel() {
        const localizationMsg = this.ctx.localization.get('filterCellOperatorLabel') || '';
        const columnName = this.column.title || this.column.field;
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FilterCellOperatorsComponent, deps: [{ token: ContextService }, { token: SizingOptionsService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: FilterCellOperatorsComponent, isStandalone: true, selector: "kendo-grid-filter-cell-operators", inputs: { operators: "operators", showButton: "showButton", showOperators: "showOperators", value: "value", column: "column" }, outputs: { valueChange: "valueChange", clear: "clear" }, host: { properties: { "class.k-filtercell-operator": "this.hostClasses" } }, viewQueries: [{ propertyName: "dropdown", first: true, predicate: ["dropdown"], descendants: true }], ngImport: i0, template: `
        @if (showOperators) {
          <kendo-dropdownlist
            #dropdown
            kendoGridFocusable
            [attr.aria-label]="column && columnLabel"
            [data]="operators"
            class="k-dropdown-operator"
            (valueChange)="onChange($event)"
            [value]="value"
            icon="filter"
            [svgIcon]="filterSVGIcon"
            [valuePrimitive]="true"
            textField="text"
            [popupSettings]="{ width: 'auto' }"
            valueField="value"
            [size]="size"
            (keydown)="dropdownKeydown($event)">
          </kendo-dropdownlist>
        }
        @if (showButton) {
          <button type="button"
            kendoButton
            kendoGridFocusable
            icon="filter-clear"
            [svgIcon]="filterClearIcon"
            [title]="clearText"
            [size]="size"
            (click)="clearClick()"
          (keydown)="clearKeydown($event)"></button>
        }
        `, isInline: true, dependencies: [{ kind: "component", type: DropDownListComponent, selector: "kendo-dropdownlist", inputs: ["customIconClass", "showStickyHeader", "icon", "svgIcon", "loading", "data", "value", "textField", "valueField", "adaptiveMode", "adaptiveTitle", "adaptiveSubtitle", "popupSettings", "listHeight", "defaultItem", "disabled", "itemDisabled", "readonly", "filterable", "virtual", "ignoreCase", "delay", "valuePrimitive", "tabindex", "tabIndex", "size", "rounded", "fillMode", "leftRightArrowsNavigation", "id"], outputs: ["valueChange", "filterChange", "selectionChange", "open", "opened", "close", "closed", "focus", "blur"], exportAs: ["kendoDropDownList"] }, { kind: "directive", type: FocusableDirective, selector: "[kendoGridFocusable],\n        [kendoGridEditCommand],\n        [kendoGridRemoveCommand],\n        [kendoGridSaveCommand],\n        [kendoGridCancelCommand],\n        [kendoGridSelectionCheckbox]\n    ", inputs: ["kendoGridFocusable"] }, { kind: "component", type: ButtonComponent, selector: "button[kendoButton]", inputs: ["arrowIcon", "toggleable", "togglable", "selected", "tabIndex", "imageUrl", "iconClass", "icon", "disabled", "size", "rounded", "fillMode", "themeColor", "svgIcon", "primary", "look"], outputs: ["selectedChange", "click"], exportAs: ["kendoButton"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FilterCellOperatorsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-filter-cell-operators',
                    template: `
        @if (showOperators) {
          <kendo-dropdownlist
            #dropdown
            kendoGridFocusable
            [attr.aria-label]="column && columnLabel"
            [data]="operators"
            class="k-dropdown-operator"
            (valueChange)="onChange($event)"
            [value]="value"
            icon="filter"
            [svgIcon]="filterSVGIcon"
            [valuePrimitive]="true"
            textField="text"
            [popupSettings]="{ width: 'auto' }"
            valueField="value"
            [size]="size"
            (keydown)="dropdownKeydown($event)">
          </kendo-dropdownlist>
        }
        @if (showButton) {
          <button type="button"
            kendoButton
            kendoGridFocusable
            icon="filter-clear"
            [svgIcon]="filterClearIcon"
            [title]="clearText"
            [size]="size"
            (click)="clearClick()"
          (keydown)="clearKeydown($event)"></button>
        }
        `,
                    standalone: true,
                    imports: [DropDownListComponent, FocusableDirective, ButtonComponent]
                }]
        }], ctorParameters: () => [{ type: ContextService }, { type: SizingOptionsService }], propDecorators: { hostClasses: [{
                type: HostBinding,
                args: ['class.k-filtercell-operator']
            }], dropdown: [{
                type: ViewChild,
                args: ['dropdown', { static: false }]
            }], operators: [{
                type: Input
            }], showButton: [{
                type: Input
            }], showOperators: [{
                type: Input
            }], value: [{
                type: Input
            }], column: [{
                type: Input
            }], valueChange: [{
                type: Output
            }], clear: [{
                type: Output
            }] } });

/**
 * @hidden
 */
class FilterInputDirective {
    ngZone;
    element;
    renderer;
    change = new EventEmitter();
    composing = false;
    kendoInput;
    filterDelay = 500;
    columnLabel;
    set value(value) {
        this.accessor.writeValue(value);
    }
    set disabled(value) {
        this.accessor.setDisabledState(value);
    }
    accessor;
    changeRequests = new Subject();
    changeRequestsSubscription;
    unsubscribeEvents;
    constructor(valueAccessors, ngZone, element, renderer) {
        this.ngZone = ngZone;
        this.element = element;
        this.renderer = renderer;
        this.accessor = valueAccessors[0];
        ngZone.runOutsideAngular(() => {
            const unsubscribeStart = renderer.listen(element.nativeElement, 'compositionstart', () => this.composing = true);
            const unsubscribeEnd = renderer.listen(element.nativeElement, 'compositionend', (event) => {
                this.composing = false;
                const value = event.target?.value;
                this.filterDelay > 0 ?
                    this.changeRequests.next(value) :
                    this.change.emit(value);
            });
            this.unsubscribeEvents = () => {
                unsubscribeStart();
                unsubscribeEnd();
            };
        });
    }
    ngAfterViewInit() {
        this.addAriaAttributes();
        this.accessor.registerOnChange(x => this.filterDelay > 0 ?
            this.changeRequests.next(x) :
            this.change.emit(x));
        this.subscribeChanges();
    }
    ngOnChanges(changes) {
        if (isChanged$1('filterDelay', changes)) {
            this.unsubscribeChanges();
            this.subscribeChanges();
        }
    }
    ngOnDestroy() {
        this.unsubscribeChanges();
        this.unsubscribeEvents();
    }
    subscribeChanges() {
        this.changeRequestsSubscription = this.changeRequests
            .pipe(debounceTime(this.filterDelay), filter(() => !this.composing))
            .subscribe((x) => {
            this.ngZone.run(() => {
                this.change.emit(x);
            });
        });
    }
    unsubscribeChanges() {
        if (this.changeRequestsSubscription) {
            this.changeRequestsSubscription.unsubscribe();
        }
    }
    addAriaAttributes() {
        const ariaValue = this.columnLabel;
        if (this.kendoInput && this.kendoInput.focusableId && isDocumentAvailable()) {
            const focusableElement = this.element.nativeElement.querySelector(`#${this.kendoInput.focusableId}`) ||
                this.element.nativeElement;
            this.renderer.setAttribute(focusableElement, 'aria-label', ariaValue);
        }
        else {
            const inputElement = this.element.nativeElement.querySelector('.k-input-inner');
            const elementToSetLabel = inputElement ? inputElement : this.element.nativeElement;
            if (ariaValue) {
                this.renderer.setAttribute(elementToSetLabel, 'aria-label', ariaValue);
            }
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FilterInputDirective, deps: [{ token: NG_VALUE_ACCESSOR, self: true }, { token: i0.NgZone }, { token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: FilterInputDirective, isStandalone: true, selector: "[kendoFilterInput]", inputs: { filterDelay: "filterDelay", columnLabel: "columnLabel", value: "value" }, queries: [{ propertyName: "kendoInput", first: true, predicate: KendoInput, descendants: true, static: true }], usesOnChanges: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FilterInputDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoFilterInput]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Self
                }, {
                    type: Inject,
                    args: [NG_VALUE_ACCESSOR]
                }] }, { type: i0.NgZone }, { type: i0.ElementRef }, { type: i0.Renderer2 }], propDecorators: { kendoInput: [{
                type: ContentChild,
                args: [KendoInput, { static: true }]
            }], filterDelay: [{
                type: Input
            }], columnLabel: [{
                type: Input
            }], value: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class MenuTabbingService {
    firstFocusable;
    lastFocusable;
    isColumnMenu = false;
    isPopupOpen = false;
    lastMenuItem;
    isTabbedInterface = false;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: MenuTabbingService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: MenuTabbingService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: MenuTabbingService, decorators: [{
            type: Injectable
        }] });

/**
 * Provides a service to set the filter descriptor.
 * [See example]({% slug filter_row %}#toc-custom-filter-row-components).
 */
class FilterService {
    /**
     * @hidden
     */
    menuTabbingService;
    /**
     * Fires when the filter descriptor is set.
     */
    changes = new Subject();
    /**
     * Sets the filter descriptor.
     *
     * @param {CompositeFilterDescriptor} value - The filter descriptor to set.
     */
    filter(value) {
        this.changes.next(value);
    }
    /**
     * @hidden
     */
    constructor(menuTabbingService) {
        this.menuTabbingService = menuTabbingService;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FilterService, deps: [{ token: MenuTabbingService, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FilterService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FilterService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: MenuTabbingService, decorators: [{
                    type: Optional
                }] }] });

/**
 * @hidden
 */
class ScrollSyncService {
    ngZone;
    changes = new Subject();
    elements = [];
    source;
    subscriptions = new Subscription();
    headerSubscription = new Subscription();
    bodySubscription = new Subscription();
    constructor(ngZone) {
        this.ngZone = ngZone;
        this.subscriptions.add(this.changes.subscribe(args => this.scrollLeft(args)));
    }
    registerEmitter(el, sourceType) {
        this.unregister(sourceType);
        this.elements.push({ element: el, sourceType });
        if (sourceType === "body" || sourceType === "header") {
            this.ngZone.runOutsideAngular(() => {
                const obs = fromEvent(el, "scroll").pipe(map(({ target: { scrollLeft } }) => ({
                    scrollLeft,
                    sourceType
                })));
                const subscription = obs.pipe(distinctUntilChanged((x, y) => (x.scrollLeft === y.scrollLeft)), filter(x => !this.source || this.source === x.sourceType), tap(x => this.source = x.sourceType))
                    .subscribe((x) => this.changes.next(x));
                subscription.add(obs.pipe(filter(x => this.source && this.source !== x.sourceType))
                    .subscribe(() => this.source = undefined));
                if (sourceType === "body") {
                    this.bodySubscription.add(subscription);
                }
                else {
                    this.headerSubscription.add(subscription);
                }
            });
        }
    }
    /**
     * destroy
     */
    destroy() {
        this.subscriptions.unsubscribe();
        this.headerSubscription.unsubscribe();
        this.bodySubscription.unsubscribe();
    }
    scrollLeft({ scrollLeft, sourceType }) {
        this.ngZone.runOutsideAngular(() => {
            this.elements
                .filter(x => sourceType !== x.sourceType)
                .forEach(({ element }) => element.scrollLeft = scrollLeft);
        });
    }
    unregister(sourceType) {
        const index = this.elements.findIndex(x => x.sourceType === sourceType);
        if (index > -1) {
            if (sourceType === "header") {
                this.headerSubscription.unsubscribe();
                this.headerSubscription = new Subscription();
            }
            else if (sourceType === "body") {
                this.bodySubscription.unsubscribe();
                this.bodySubscription = new Subscription();
            }
            this.elements.splice(index, 1);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ScrollSyncService, deps: [{ token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ScrollSyncService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ScrollSyncService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: i0.NgZone }] });

/**
 * @hidden
 *
 * The AdaptiveGridService is used to provide common information for the ActionSheet used in adaptive mode.
 */
class AdaptiveGridService {
    ctx;
    adaptiveService;
    /**
     * Emits when the ActionSheet view animation ends.
     */
    get animationEnd() {
        return this.animationEndSubject.asObservable();
    }
    columnMenuService;
    columns = [];
    secondaryView;
    viewType;
    popupRef;
    column;
    filterMenuContainer;
    filterMenuContainerComponentRef;
    animationEndSubject = new Subject();
    constructor(ctx, adaptiveService) {
        this.ctx = ctx;
        this.adaptiveService = adaptiveService;
    }
    submitFilter() {
        this.filterMenuContainer.submit();
        this.ctx.grid.adaptiveRenderer.actionSheet.toggle(false);
        this.reset();
    }
    resetFilter() {
        this.filterMenuContainer.reset();
        this.ctx.grid.adaptiveRenderer.actionSheet.toggle(false);
        this.reset();
    }
    reset() {
        this.ctx.grid.adaptiveRenderer.actionSheet.currentView = 1;
        this.filterMenuContainerComponentRef?.destroy();
        this.column = null;
        this.popupRef = null;
        this.filterMenuContainer = null;
        this.viewType = null;
        this.secondaryView = null;
    }
    /**
     * Notifies that the ActionSheet animation has ended.
     */
    notifyAnimationEnd() {
        this.animationEndSubject.next();
    }
    get windowSize() {
        return this.adaptiveService.size;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AdaptiveGridService, deps: [{ token: ContextService }, { token: i2$1.AdaptiveService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AdaptiveGridService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AdaptiveGridService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: ContextService }, { type: i2$1.AdaptiveService }] });

const contains = (node, predicate) => {
    while (node) {
        if (predicate(node)) {
            return true;
        }
        node = node.parentNode;
    }
    return false;
};
/**
 * Arguments for the `close` event of the filter and column-menu popup.
 */
class PopupCloseEvent extends PreventableEvent {
    /**
     * The original DOM event that causes the popup to close.
     */
    originalEvent;
    /**
     * @hidden
     */
    constructor(e) {
        super();
        this.originalEvent = e;
    }
}
const DEFAULT_POPUP_CLASS = 'k-grid-filter-popup';
/**
 * Provides popup management for filter and column menus.
 * Use this service to open and close popups for the Grid filter and column menus ([see example]({% slug filter_menu %}#toc-filter-menu-with-popup)).
 */
class SinglePopupService {
    popupService;
    renderer;
    ngZone;
    ctx;
    adaptiveGridService;
    /**
     * Emits when the filter or column menu popup is about to close because the user clicked outside.
     * Use this event to prevent the popup from closing.
     */
    onClose = new Subject();
    removeClick;
    pointerEventsSub = new Subscription();
    popupRef;
    scrollSubscription;
    canClosePopup = true;
    /**
     * @hidden
     */
    constructor(popupService, renderer, ngZone, scrollSyncService, ctx, adaptiveGridService) {
        this.popupService = popupService;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.ctx = ctx;
        this.adaptiveGridService = adaptiveGridService;
        this.scrollSubscription = scrollSyncService.changes.pipe(skip(1)).subscribe(() => this.destroy());
    }
    /**
     * @hidden
     */
    open(anchor, template, popupRef, popupClass = DEFAULT_POPUP_CLASS) {
        const toggle = isPresent(popupRef) && this.popupRef === popupRef;
        this.destroy();
        if (!toggle) {
            const direction = this.ctx.localization.rtl ? 'right' : 'left';
            this.popupRef = this.popupService.open({
                anchorAlign: { vertical: 'bottom', horizontal: direction },
                popupAlign: { vertical: 'top', horizontal: direction },
                anchor: anchor,
                popupClass: popupClass,
                content: template,
                positionMode: "absolute"
            });
            this.adaptiveGridService.popupRef = this.popupRef;
            this.renderer.setAttribute(this.popupRef.popupElement, 'dir', this.ctx.localization.rtl ? 'rtl' : 'ltr');
            this.attachClose(anchor);
        }
        const popupEl = this.popupRef?.popupElement;
        if (popupEl) {
            this.attachMouseListeners(popupEl);
        }
        return this.popupRef;
    }
    /**
     * @hidden
     */
    destroy() {
        if (this.popupRef) {
            this.detachClose();
            this.pointerEventsSub.unsubscribe();
            this.pointerEventsSub = null;
            this.popupRef.close();
            this.popupRef = null;
            this.adaptiveGridService.popupRef = null;
        }
    }
    ngOnDestroy() {
        this.destroy();
        this.scrollSubscription.unsubscribe();
    }
    detachClose() {
        if (this.removeClick) {
            this.removeClick();
        }
    }
    attachClose(skipElement) {
        if (!isDocumentAvailable()) {
            return;
        }
        this.detachClose();
        this.ngZone.runOutsideAngular(() => this.removeClick = this.renderer.listen('document', 'click', (e) => {
            if (!contains(e.target, x => this.popupRef.popupElement === x || x === skipElement)) {
                const args = new PopupCloseEvent(e);
                this.onClose.next(args);
                if (!args.isDefaultPrevented() && this.canClosePopup) {
                    this.destroy();
                }
                this.canClosePopup = true;
            }
        }));
    }
    attachMouseListeners(el) {
        this.pointerEventsSub = new Subscription();
        this.ngZone.runOutsideAngular(() => {
            this.pointerEventsSub.add(this.renderer.listen(el, 'pointerdown', (e) => {
                e.stopImmediatePropagation();
                this.canClosePopup = false;
            }));
            this.pointerEventsSub.add(this.renderer.listen(el, 'pointerup', () => {
                this.canClosePopup = true;
            }));
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SinglePopupService, deps: [{ token: i2.PopupService }, { token: i0.Renderer2 }, { token: i0.NgZone }, { token: ScrollSyncService }, { token: ContextService }, { token: AdaptiveGridService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SinglePopupService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SinglePopupService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: i2.PopupService }, { type: i0.Renderer2 }, { type: i0.NgZone }, { type: ScrollSyncService }, { type: ContextService }, { type: AdaptiveGridService }] });

const insertDefaultFilter = (index, rootFilter, filter) => {
    rootFilter = (rootFilter || { filters: [], logic: "and" });
    rootFilter.filters[index] = filter;
    return filter;
};
/**
 * @hidden
 */
const setFilter = (index, filter, field, defaultOperator) => {
    if (isPresent(filter) && isPresent(filter.filters) && filter.filters.length > index) {
        return filter.filters[index];
    }
    else {
        return insertDefaultFilter(index, filter, {
            field,
            operator: defaultOperator
        });
    }
};
/**
 * @hidden
 */
const logicOperators = (localization) => [
    { text: localization.get("filterAndLogic"), value: "and" },
    { text: localization.get("filterOrLogic"), value: "or" }
];
/**
 * @hidden
 */
const flatten = (filter) => {
    if (isPresent(filter.filters)) {
        return filter.filters.reduce((acc, curr) => acc.concat(isCompositeFilterDescriptor(curr) ? flatten(curr) : [curr]), []);
    }
    return [];
};
const trimFilterByField = (filter, field) => {
    if (isPresent(filter) && isPresent(filter.filters)) {
        filter.filters = filter.filters.filter(x => {
            if (isCompositeFilterDescriptor(x)) {
                trimFilterByField(x, field);
                return x.filters.length;
            }
            else {
                return x.field !== field;
            }
        });
    }
};
/**
 * @hidden
 */
const filtersByField = (filter, field) => flatten(filter || {}).filter(x => x.field === field);
/**
 * @hidden
 */
const filterByField = (filter, field) => {
    const [currentFilter] = filtersByField(filter, field);
    return currentFilter;
};
/**
 * @hidden
 */
const removeFilter = (filter, field) => {
    trimFilterByField(filter, field);
    return filter;
};
/**
 * @hidden
 */
const localizeOperators = operators => localization => Object.keys(operators).map(key => ({
    text: localization.get(key),
    value: operators[key]
}));
/**
 * An abstract base class for the filter-cell component ([see example]({% slug filter_row %}#toc-custom-filter-row-components)).
 */
class BaseFilterCellComponent {
    filterService;
    get hostClasses() {
        return true;
    }
    operatorList = new QueryList();
    get operators() {
        return this._operators?.length ? this._operators : this.defaultOperators;
    }
    set operators(values) {
        this._operators = values;
    }
    /**
     * @hidden
     */
    size = 'medium';
    /**
     * The current root filter.
     * @type {CompositeFilterDescriptor}
     */
    filter;
    defaultOperators;
    _operators;
    operationListSubscription;
    constructor(filterService) {
        this.filterService = filterService;
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        this.operationListSubscription = observe(this.operatorList)
            .pipe(map(q => q.toArray()), map(toJSON))
            .subscribe(x => {
            this.operators = x;
        });
    }
    ngOnDestroy() {
        if (this.operationListSubscription) {
            this.operationListSubscription.unsubscribe();
        }
    }
    filterByField(field) {
        return filterByField(this.filter, field);
    }
    filtersByField(field) {
        return filtersByField(this.filter, field);
    }
    removeFilter(field) {
        return removeFilter(this.filter, field);
    }
    updateFilter(filter) {
        const root = this.filter || {
            filters: [],
            logic: "and"
        };
        const [currentFilter] = flatten(root).filter(x => x.field === filter.field);
        if (!isPresent(currentFilter)) {
            root.filters.push(filter);
        }
        else {
            Object.assign(currentFilter, filter);
        }
        return root;
    }
    applyFilter(filter) {
        this.filterService.filter(filter);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: BaseFilterCellComponent, deps: [{ token: FilterService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: BaseFilterCellComponent, isStandalone: true, inputs: { operators: "operators", filter: "filter" }, host: { properties: { "class.k-filtercell": "this.hostClasses" } }, queries: [{ propertyName: "operatorList", predicate: FilterOperatorBase }], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: BaseFilterCellComponent, decorators: [{
            type: Directive,
            args: [{}]
        }], ctorParameters: () => [{ type: FilterService }], propDecorators: { hostClasses: [{
                type: HostBinding,
                args: ['class.k-filtercell']
            }], operatorList: [{
                type: ContentChildren,
                args: [FilterOperatorBase]
            }], operators: [{
                type: Input
            }], filter: [{
                type: Input
            }] } });

const areDifferent = (a, b) => a.field !== b.field || a.operator !== b.operator || a.value !== b.value;
const isChanged = (a, b) => {
    if (a.length !== b.length) {
        return true;
    }
    for (let idx = 0, len = a.length; idx < len; idx++) {
        const prev = a[idx];
        const curr = b[idx];
        if (isCompositeFilterDescriptor(prev)) {
            if (diffFilters(prev, curr[idx])) {
                return true;
            }
        }
        else if (areDifferent(prev, curr)) {
            return true;
        }
    }
    return false;
};
const copyObject = (obj) => {
    const result = {};
    Object.assign(result, obj);
    if (obj.constructor !== Object) {
        const proto = obj.constructor.prototype;
        Object.getOwnPropertyNames(proto).forEach((property) => {
            if (property !== 'constructor' && property !== '__proto__' && property !== 'prototype' && proto.hasOwnProperty(property)) {
                result[property] = obj[property];
            }
        });
    }
    return result;
};
const cloneFilter = (filter) => copyObject(filter);
/**
 * @hidden
 */
const cloneFilters = (filter) => {
    if (!filter) {
        return;
    }
    if (isCompositeFilterDescriptor(filter)) {
        return {
            filters: cloneFilters(filter.filters),
            logic: filter.logic
        };
    }
    else if (Array.isArray(filter)) {
        return filter.map(cloneFilters);
    }
    return cloneFilter(filter);
};
/**
 * @hidden
 */
const diffFilters = (a, b) => {
    if (isPresent(a) && !isPresent(b)) {
        return true;
    }
    if (!isPresent(a) && isPresent(b)) {
        return true;
    }
    return isPresent(a) && isPresent(b) && isChanged(a.filters, b.filters);
};

/**
 * @hidden
 */
class FilterHostDirective {
    host;
    column;
    filter;
    component;
    constructor(host) {
        this.host = host;
    }
    ngOnInit() {
        this.component = this.host.createComponent(this.componentType());
        this.initComponent({
            column: this.column,
            filter: this.filter
        });
    }
    ngOnDestroy() {
        if (this.component) {
            this.component.destroy();
            this.component = null;
        }
    }
    ngOnChanges(changes) {
        if (anyChanged(["column", "filter"], changes)) {
            this.initComponent({
                column: this.column,
                filter: this.filter
            });
        }
    }
    initComponent({ column, filter }) {
        const instance = this.component.instance;
        instance.column = column;
        instance.filter = filter;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FilterHostDirective, deps: [{ token: i0.ViewContainerRef }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: FilterHostDirective, isStandalone: true, selector: "[kendoGridFilterHostBase]", inputs: { column: "column", filter: "filter" }, usesOnChanges: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FilterHostDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridFilterHostBase]'
                }]
        }], ctorParameters: () => [{ type: i0.ViewContainerRef }], propDecorators: { column: [{
                type: Input
            }], filter: [{
                type: Input
            }] } });

// eslint-disable no-access-missing-member
const stringOperators$1 = localizeOperators({
    "filterEqOperator": "eq",
    "filterNotEqOperator": "neq",
    "filterContainsOperator": "contains",
    "filterNotContainsOperator": "doesnotcontain",
    "filterStartsWithOperator": "startswith",
    "filterEndsWithOperator": "endswith",
    "filterIsNullOperator": "isnull",
    "filterIsNotNullOperator": "isnotnull",
    "filterIsEmptyOperator": "isempty",
    "filterIsNotEmptyOperator": "isnotempty"
});
/**
 * @hidden
 * Represents a base string filter component.
 */
class StringFilterComponent extends BaseFilterCellComponent {
    ctx;
    /**
     * Sets the column for this filter.
     * @type {ColumnComponent}
     */
    column;
    /**
     * Sets the default filter operator.
     * @type {string}
     * @default 'contains'
     */
    operator = "contains";
    /**
     * Gets the current filter for the column field.
     * @readonly
     * @type {FilterDescriptor}
     */
    get currentFilter() {
        return this.filterByField((this.column || {}).field);
    }
    /**
     * Gets the current filter operator for the column field.
     * @readonly
     * @type {string}
     */
    get currentOperator() {
        return this.currentFilter ? this.currentFilter.operator : this.operator;
    }
    subscription;
    constructor(filterService, ctx) {
        super(filterService);
        this.ctx = ctx;
    }
    ngOnInit() {
        this.subscription = this.ctx.localization.changes.subscribe(this.localizationChange.bind(this));
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        super.ngOnDestroy();
    }
    localizationChange() {
        this.defaultOperators = stringOperators$1(this.ctx.localization);
        if (this.operatorList.length) {
            this.operators = toJSON(this.operatorList.toArray());
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: StringFilterComponent, deps: [{ token: FilterService }, { token: ContextService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: StringFilterComponent, isStandalone: true, inputs: { column: "column", operator: "operator" }, usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: StringFilterComponent, decorators: [{
            type: Directive,
            args: [{}]
        }], ctorParameters: () => [{ type: FilterService }, { type: ContextService }], propDecorators: { column: [{
                type: Input
            }], operator: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class FilterMenuDropDownListDirective {
    host;
    filterMenuDropDownLabel;
    constructor(host) {
        this.host = host;
    }
    ngAfterViewInit() {
        const wrapperElement = this.host.wrapper.nativeElement;
        wrapperElement.setAttribute('aria-label', this.filterMenuDropDownLabel);
        wrapperElement.addEventListener('keydown', this.keydownHandler, true);
    }
    ngOnDestroy() {
        this.host.wrapper.nativeElement.removeEventListener('keydown', this.keydownHandler);
    }
    keydownHandler = (e) => {
        if (e.code === Keys.Escape && this.host.isOpen) {
            e.stopPropagation();
            this.host.toggle(false);
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FilterMenuDropDownListDirective, deps: [{ token: i1$5.DropDownListComponent }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: FilterMenuDropDownListDirective, isStandalone: true, selector: "[kendoFilterMenuDropDown]", inputs: { filterMenuDropDownLabel: "filterMenuDropDownLabel" }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FilterMenuDropDownListDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoFilterMenuDropDown]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1$5.DropDownListComponent }], propDecorators: { filterMenuDropDownLabel: [{
                type: Input
            }] } });

const EMPTY_VALUE_OPERATORS = new Set(['isnull', 'isnotnull', 'isempty', 'isnotempty']);
const isEmptyValueOperator = (operator) => EMPTY_VALUE_OPERATORS.has(operator);
/**
 * @hidden
 */
class FilterInputWrapperComponent extends BaseFilterCellComponent {
    column;
    input;
    get currentFilter() {
        return this.filterByField(this.column.field);
    }
    get currentOperator() {
        const filter = this.currentFilter;
        if (!this._operator) {
            this._operator = filter ? filter.operator : this.defaultOperator;
        }
        return this._operator;
    }
    set currentOperator(value) {
        this._operator = value;
        const emptyValueOperator = isEmptyValueOperator(value);
        this.filterInputDisabled = emptyValueOperator;
        if (emptyValueOperator) {
            this.applyNoValueFilter(value);
        }
        else if (!isBlank(value) && isPresent(this.currentFilter)) {
            this.onChange(this.currentFilter.value);
        }
    }
    get defaultOperator() {
        if (!isNullOrEmptyString(this._defaultOperator)) {
            return this._defaultOperator;
        }
        else if (this.operators && this.operators.length) {
            return this.operators[0].value;
        }
        return "eq";
    }
    set defaultOperator(value) {
        this._defaultOperator = value;
    }
    set filterInputDisabled(disabled) {
        if (!this.input) {
            return;
        }
        this.input.disabled = disabled;
    }
    _defaultOperator;
    _operator;
    changeSubscription;
    constructor(filterService) {
        super(filterService);
    }
    ngAfterContentInit() {
        if (isPresent(this.input)) {
            this.changeSubscription = this.input.change.subscribe(this.onChange.bind(this));
            this.filterInputDisabled = isEmptyValueOperator(this.currentOperator);
        }
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        if (this.changeSubscription) {
            this.changeSubscription.unsubscribe();
        }
    }
    onChange(value) {
        if (!isNullOrEmptyString(value) || this.filterByField(this.column.field)) {
            this.filterChange(isNullOrEmptyString(value) ?
                this.removeFilter(this.column.field) :
                this.updateFilter({
                    field: this.column.field,
                    operator: this.currentOperator,
                    value: value
                }));
        }
    }
    onClear() {
        this.onChange(null);
        this.filterInputDisabled = isEmptyValueOperator(this.defaultOperator);
    }
    applyNoValueFilter(operator) {
        this.filterChange(this.updateFilter({
            field: this.column.field,
            operator: operator,
            value: null
        }));
    }
    ngOnChanges(changes) {
        if (isChanged$1("filter", changes, false)) {
            this._operator = null;
            this.filterInputDisabled = isEmptyValueOperator(this.currentOperator);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FilterInputWrapperComponent, deps: [{ token: FilterService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: FilterInputWrapperComponent, isStandalone: true, inputs: { column: "column", defaultOperator: "defaultOperator" }, queries: [{ propertyName: "input", first: true, predicate: FilterInputDirective, descendants: true }], usesInheritance: true, usesOnChanges: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FilterInputWrapperComponent, decorators: [{
            type: Directive,
            args: [{}]
        }], ctorParameters: () => [{ type: FilterService }], propDecorators: { column: [{
                type: Input
            }], input: [{
                type: ContentChild,
                args: [FilterInputDirective, { static: false }]
            }], defaultOperator: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class FilterMenuInputWrapperComponent extends FilterInputWrapperComponent {
    ctx;
    adaptiveGridService;
    filterService;
    isFirstDropDown;
    menuTabbingService;
    firstOperatorDropDown;
    _currentFilter;
    subs = new Subscription();
    /**
     * @hidden
     */
    get hostClasses() {
        return false;
    }
    constructor(ctx, adaptiveGridService) {
        super(null);
        this.ctx = ctx;
        this.adaptiveGridService = adaptiveGridService;
    }
    ngAfterViewInit() {
        const shouldFocusFirstFocusable = this.isFirstDropDown && this.filterService?.menuTabbingService;
        const isTabbedInterface = this.menuTabbingService?.isTabbedInterface;
        if (shouldFocusFirstFocusable && !isTabbedInterface) {
            this.filterService.menuTabbingService.firstFocusable = this.firstOperatorDropDown;
            if (this.ctx.grid?.isActionSheetExpanded) {
                this.subs.add(this.adaptiveGridService.animationEnd.subscribe(() => {
                    this.firstOperatorDropDown.wrapper.nativeElement.focus({ preventScroll: true });
                }));
            }
            else {
                this.firstOperatorDropDown.wrapper.nativeElement.focus({ preventScroll: true });
            }
        }
    }
    ngOnDestroy() {
        this.subs?.unsubscribe();
    }
    operatorChange(dataItem) {
        this.currentOperator = dataItem;
    }
    filterChange(filter) {
        this.applyFilter(filter);
    }
    /**
     * The current filter for the associated column field.
     * @readonly
     * @type {FilterDescriptor}
     */
    get currentFilter() {
        return this._currentFilter;
    }
    /**
     * The current filter for the associated column field.
     * @readonly
     * @type {FilterDescriptor}
     */
    set currentFilter(value) {
        this._currentFilter = value;
    }
    updateFilter(filter) {
        Object.assign(this.currentFilter, filter);
        return this.filter;
    }
    onChange(value) {
        this.filterChange(this.updateFilter({
            field: this.column.field,
            operator: this.currentOperator,
            value: value
        }));
    }
    onShiftTab(e) {
        e.stopImmediatePropagation();
        if (!this.menuTabbingService?.isColumnMenu && this.isFirstDropDown && this.filterService.menuTabbingService.lastFocusable) {
            e.preventDefault();
            this.filterService.menuTabbingService.lastFocusable.focus();
        }
    }
    get filterMenuDropDownLabel() {
        const localizationMsg = this.ctx.localization.get('filterMenuOperatorsDropDownLabel') || '';
        const columnName = this.column ? this.column.title || this.column.field : '';
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FilterMenuInputWrapperComponent, deps: [{ token: ContextService }, { token: AdaptiveGridService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: FilterMenuInputWrapperComponent, isStandalone: true, selector: "kendo-grid-filter-menu-input-wrapper", inputs: { filterService: "filterService", isFirstDropDown: "isFirstDropDown", menuTabbingService: "menuTabbingService", currentFilter: "currentFilter" }, viewQueries: [{ propertyName: "firstOperatorDropDown", first: true, predicate: DropDownListComponent, descendants: true }], usesInheritance: true, ngImport: i0, template: `
        <kendo-dropdownlist
            kendoFilterMenuDropDown
            [adaptiveTitle]="ctx.localization.get('adaptiveFilterOperatorsTitle')"
            [adaptiveMode]="ctx.grid?.adaptiveMode"
            [size]="ctx.grid?.isActionSheetExpanded ? 'large' : null"
            [filterMenuDropDownLabel]="filterMenuDropDownLabel"
            [data]="operators"
            (valueChange)="operatorChange($event)"
            [value]="currentOperator"
            [valuePrimitive]="true"
            textField="text"
            valueField="value"
            (keydown.shift.tab)="onShiftTab($event)">
        </kendo-dropdownlist>
        <ng-content></ng-content>
    `, isInline: true, dependencies: [{ kind: "component", type: DropDownListComponent, selector: "kendo-dropdownlist", inputs: ["customIconClass", "showStickyHeader", "icon", "svgIcon", "loading", "data", "value", "textField", "valueField", "adaptiveMode", "adaptiveTitle", "adaptiveSubtitle", "popupSettings", "listHeight", "defaultItem", "disabled", "itemDisabled", "readonly", "filterable", "virtual", "ignoreCase", "delay", "valuePrimitive", "tabindex", "tabIndex", "size", "rounded", "fillMode", "leftRightArrowsNavigation", "id"], outputs: ["valueChange", "filterChange", "selectionChange", "open", "opened", "close", "closed", "focus", "blur"], exportAs: ["kendoDropDownList"] }, { kind: "directive", type: FilterMenuDropDownListDirective, selector: "[kendoFilterMenuDropDown]", inputs: ["filterMenuDropDownLabel"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FilterMenuInputWrapperComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-filter-menu-input-wrapper',
                    template: `
        <kendo-dropdownlist
            kendoFilterMenuDropDown
            [adaptiveTitle]="ctx.localization.get('adaptiveFilterOperatorsTitle')"
            [adaptiveMode]="ctx.grid?.adaptiveMode"
            [size]="ctx.grid?.isActionSheetExpanded ? 'large' : null"
            [filterMenuDropDownLabel]="filterMenuDropDownLabel"
            [data]="operators"
            (valueChange)="operatorChange($event)"
            [value]="currentOperator"
            [valuePrimitive]="true"
            textField="text"
            valueField="value"
            (keydown.shift.tab)="onShiftTab($event)">
        </kendo-dropdownlist>
        <ng-content></ng-content>
    `,
                    standalone: true,
                    imports: [DropDownListComponent, FilterMenuDropDownListDirective]
                }]
        }], ctorParameters: () => [{ type: ContextService }, { type: AdaptiveGridService }], propDecorators: { filterService: [{
                type: Input
            }], isFirstDropDown: [{
                type: Input
            }], menuTabbingService: [{
                type: Input
            }], firstOperatorDropDown: [{
                type: ViewChild,
                args: [DropDownListComponent, { static: false }]
            }], currentFilter: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class StringFilterMenuInputComponent {
    ctx;
    operators = [];
    column;
    filter;
    operator;
    currentFilter;
    filterService;
    isFirstDropDown;
    menuTabbingService;
    placeholder;
    constructor(ctx) {
        this.ctx = ctx;
    }
    get columnLabel() {
        const localizationMsg = this.ctx.localization.get('filterInputLabel') || '';
        const columnName = this.column ? this.column.title || this.column.field : '';
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: StringFilterMenuInputComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: StringFilterMenuInputComponent, isStandalone: true, selector: "kendo-grid-string-filter-menu-input", inputs: { operators: "operators", column: "column", filter: "filter", operator: "operator", currentFilter: "currentFilter", filterService: "filterService", isFirstDropDown: "isFirstDropDown", menuTabbingService: "menuTabbingService", placeholder: "placeholder" }, ngImport: i0, template: `
        <kendo-grid-filter-menu-input-wrapper
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [currentFilter]="currentFilter"
            [filterService]="filterService"
            [isFirstDropDown]="isFirstDropDown"
            [menuTabbingService]="menuTabbingService">
            <kendo-textbox
                kendoFilterInput
                [columnLabel]="columnLabel"
                [size]="ctx.grid?.isActionSheetExpanded ? 'large' : null"
                [filterDelay]="0"
                [placeholder]="placeholder"
                [ngModel]="currentFilter?.value ?? null">
            </kendo-textbox>
        </kendo-grid-filter-menu-input-wrapper>
    `, isInline: true, dependencies: [{ kind: "component", type: FilterMenuInputWrapperComponent, selector: "kendo-grid-filter-menu-input-wrapper", inputs: ["filterService", "isFirstDropDown", "menuTabbingService", "currentFilter"] }, { kind: "component", type: TextBoxComponent, selector: "kendo-textbox", inputs: ["focusableId", "title", "type", "disabled", "readonly", "tabindex", "value", "selectOnFocus", "showSuccessIcon", "showErrorIcon", "clearButton", "successIcon", "successSvgIcon", "errorIcon", "errorSvgIcon", "clearButtonIcon", "clearButtonSvgIcon", "size", "rounded", "fillMode", "tabIndex", "placeholder", "maxlength", "inputAttributes"], outputs: ["valueChange", "inputFocus", "inputBlur", "focus", "blur"], exportAs: ["kendoTextBox"] }, { kind: "directive", type: FilterInputDirective, selector: "[kendoFilterInput]", inputs: ["filterDelay", "columnLabel", "value"] }, { kind: "ngmodule", type: FormsModule }, { kind: "directive", type: i2$2.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$2.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: StringFilterMenuInputComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-string-filter-menu-input',
                    template: `
        <kendo-grid-filter-menu-input-wrapper
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [currentFilter]="currentFilter"
            [filterService]="filterService"
            [isFirstDropDown]="isFirstDropDown"
            [menuTabbingService]="menuTabbingService">
            <kendo-textbox
                kendoFilterInput
                [columnLabel]="columnLabel"
                [size]="ctx.grid?.isActionSheetExpanded ? 'large' : null"
                [filterDelay]="0"
                [placeholder]="placeholder"
                [ngModel]="currentFilter?.value ?? null">
            </kendo-textbox>
        </kendo-grid-filter-menu-input-wrapper>
    `,
                    standalone: true,
                    imports: [FilterMenuInputWrapperComponent, TextBoxComponent, FilterInputDirective, FormsModule]
                }]
        }], ctorParameters: () => [{ type: ContextService }], propDecorators: { operators: [{
                type: Input
            }], column: [{
                type: Input
            }], filter: [{
                type: Input
            }], operator: [{
                type: Input
            }], currentFilter: [{
                type: Input
            }], filterService: [{
                type: Input
            }], isFirstDropDown: [{
                type: Input
            }], menuTabbingService: [{
                type: Input
            }], placeholder: [{
                type: Input
            }] } });

/**
 * Represents a string-filter menu component.
 * Use this component to filter string values in the Grid.
 * [See example](slug:filter_menu#toc-built-in-filter-menu-components).
 *
 * @example
 * ```html
 * <kendo-grid-column field="ProductName">
 *   <ng-template kendoGridFilterMenuTemplate let-filter let-column="column" let-filterService="filterService">
 *     <kendo-grid-string-filter-menu
 *       [column]="column"
 *       [filter]="filter"
 *       [filterService]="filterService">
 *     </kendo-grid-string-filter-menu>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 * @remarks
 * Supported children components are: {@link EqualFilterOperatorComponent}, {@link NotEqualFilterOperatorComponent}, {@link ContainsFilterOperatorComponent}, {@link DoesNotContainFilterOperatorComponent}, {@link StartsWithFilterOperatorComponent}, {@link EndsWithFilterOperatorComponent}, {@link IsNullFilterOperatorComponent}, {@link IsNotNullFilterOperatorComponent}, {@link IsEmptyFilterOperatorComponent}, {@link IsNotEmptyFilterOperatorComponent}.
 */
class StringFilterMenuComponent extends StringFilterComponent {
    ctx;
    logicOperators = [];
    /**
     * @hidden
     */
    get hostClasses() {
        return false;
    }
    /**
     * The current menu filter.
     * @type {CompositeFilterDescriptor}
     */
    filter = { filters: [], logic: "and" };
    /**
     * Determines if the inputs for the second criteria are displayed.
     * @default true
     */
    extra = true;
    /**
     * Sets to `FilterService` instance that handles changes in the filter descriptor.
     */
    filterService;
    /**
     * The placeholder text for the filter input.
     * @type {string}
     */
    placeholder;
    /**
     * Sets the placeholder text for the second filter input.
     * Applies when `extra` is set to `true`.
     * @type {string}
     */
    extraPlaceholder;
    /**
     * @hidden
     */
    menuTabbingService;
    constructor(ctx) {
        super(null, ctx);
        this.ctx = ctx;
        this.logicOperators = logicOperators(this.ctx.localization);
    }
    get firstFilter() {
        return setFilter(0, this.filter, (this.column || {}).field, this.operator);
    }
    get secondFilter() {
        return setFilter(1, this.filter, (this.column || {}).field, this.operator);
    }
    logicChange(value) {
        this.filter.logic = value;
    }
    get filterMenuDropDownLabel() {
        const localizationMsg = this.ctx.localization.get('filterMenuLogicDropDownLabel') || '';
        const columnName = this.column ? this.column.title || this.column.field : '';
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
    localizationChange() {
        this.logicOperators = logicOperators(this.ctx.localization);
        super.localizationChange();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: StringFilterMenuComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: StringFilterMenuComponent, isStandalone: true, selector: "kendo-grid-string-filter-menu", inputs: { filter: "filter", extra: "extra", filterService: "filterService", placeholder: "placeholder", extraPlaceholder: "extraPlaceholder", menuTabbingService: "menuTabbingService" }, host: { properties: { "class.k-filtercell": "this.hostClasses" } }, usesInheritance: true, ngImport: i0, template: `
        <kendo-grid-string-filter-menu-input
          [currentFilter]="firstFilter"
          [operators]="operators"
          [filterService]="filterService"
          [column]="column"
          [filter]="filter"
          [isFirstDropDown]="true"
          [placeholder]="placeholder"
          [menuTabbingService]="menuTabbingService">
        </kendo-grid-string-filter-menu-input>
        @if (extra) {
          <kendo-dropdownlist
            kendoFilterMenuDropDown
            [adaptiveTitle]="ctx.localization.get('adaptiveFilterOperatorsTitle')"
            [adaptiveMode]="ctx.grid?.adaptiveMode"
            [size]="ctx.grid?.isActionSheetExpanded ? 'large' : null"
            [filterMenuDropDownLabel]="filterMenuDropDownLabel"
            class="k-filter-and"
            [data]="logicOperators"
            [valuePrimitive]="true" (valueChange)="logicChange($event)"
            [value]="filter?.logic"
            textField="text"
            valueField="value">
          </kendo-dropdownlist>
        }
        @if (extra) {
          <kendo-grid-string-filter-menu-input
            [operators]="operators"
            [currentFilter]="secondFilter"
            [filterService]="filterService"
            [column]="column"
            [filter]="filter"
            [placeholder]="extraPlaceholder"
            [menuTabbingService]="menuTabbingService">
          </kendo-grid-string-filter-menu-input>
        }
        `, isInline: true, dependencies: [{ kind: "component", type: StringFilterMenuInputComponent, selector: "kendo-grid-string-filter-menu-input", inputs: ["operators", "column", "filter", "operator", "currentFilter", "filterService", "isFirstDropDown", "menuTabbingService", "placeholder"] }, { kind: "component", type: DropDownListComponent, selector: "kendo-dropdownlist", inputs: ["customIconClass", "showStickyHeader", "icon", "svgIcon", "loading", "data", "value", "textField", "valueField", "adaptiveMode", "adaptiveTitle", "adaptiveSubtitle", "popupSettings", "listHeight", "defaultItem", "disabled", "itemDisabled", "readonly", "filterable", "virtual", "ignoreCase", "delay", "valuePrimitive", "tabindex", "tabIndex", "size", "rounded", "fillMode", "leftRightArrowsNavigation", "id"], outputs: ["valueChange", "filterChange", "selectionChange", "open", "opened", "close", "closed", "focus", "blur"], exportAs: ["kendoDropDownList"] }, { kind: "directive", type: FilterMenuDropDownListDirective, selector: "[kendoFilterMenuDropDown]", inputs: ["filterMenuDropDownLabel"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: StringFilterMenuComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-string-filter-menu',
                    template: `
        <kendo-grid-string-filter-menu-input
          [currentFilter]="firstFilter"
          [operators]="operators"
          [filterService]="filterService"
          [column]="column"
          [filter]="filter"
          [isFirstDropDown]="true"
          [placeholder]="placeholder"
          [menuTabbingService]="menuTabbingService">
        </kendo-grid-string-filter-menu-input>
        @if (extra) {
          <kendo-dropdownlist
            kendoFilterMenuDropDown
            [adaptiveTitle]="ctx.localization.get('adaptiveFilterOperatorsTitle')"
            [adaptiveMode]="ctx.grid?.adaptiveMode"
            [size]="ctx.grid?.isActionSheetExpanded ? 'large' : null"
            [filterMenuDropDownLabel]="filterMenuDropDownLabel"
            class="k-filter-and"
            [data]="logicOperators"
            [valuePrimitive]="true" (valueChange)="logicChange($event)"
            [value]="filter?.logic"
            textField="text"
            valueField="value">
          </kendo-dropdownlist>
        }
        @if (extra) {
          <kendo-grid-string-filter-menu-input
            [operators]="operators"
            [currentFilter]="secondFilter"
            [filterService]="filterService"
            [column]="column"
            [filter]="filter"
            [placeholder]="extraPlaceholder"
            [menuTabbingService]="menuTabbingService">
          </kendo-grid-string-filter-menu-input>
        }
        `,
                    standalone: true,
                    imports: [StringFilterMenuInputComponent, DropDownListComponent, FilterMenuDropDownListDirective]
                }]
        }], ctorParameters: () => [{ type: ContextService }], propDecorators: { hostClasses: [{
                type: HostBinding,
                args: ['class.k-filtercell']
            }], filter: [{
                type: Input
            }], extra: [{
                type: Input
            }], filterService: [{
                type: Input
            }], placeholder: [{
                type: Input
            }], extraPlaceholder: [{
                type: Input
            }], menuTabbingService: [{
                type: Input
            }] } });

// eslint-disable no-access-missing-member
const numericOperators = localizeOperators({
    "filterEqOperator": "eq",
    "filterNotEqOperator": "neq",
    "filterGteOperator": "gte",
    "filterGtOperator": "gt",
    "filterLteOperator": "lte",
    "filterLtOperator": "lt",
    "filterIsNullOperator": "isnull",
    "filterIsNotNullOperator": "isnotnull"
});
/**
 * @hidden
 * Represents a base numeric filter component.
 */
class NumericFilterComponent extends BaseFilterCellComponent {
    ctx;
    /**
     * Specifies the column for this filter.
     * @type {ColumnComponent}
     */
    column;
    /**
     * Sets the default filter operator.
     * @type {string}
     * @default 'eq'
     */
    operator = "eq";
    /**
     * Sets the value used to increment or decrement the component value.
     * @type {numeric}
     * @default 1
     */
    step = 1;
    /**
     * Sets the smallest valid value.
     * @type {number}
     */
    min;
    /**
     * Sets the greatest valid value.
     * @type {number}
     */
    max;
    /**
     * When `true`, shows the **Up** and **Down** spin buttons.
     * @type {boolean}
     * @default true
     */
    spinners = true;
    /**
     * Sets the number precision for the value when focused.
     * If the user enters a number with greater precision, the value is rounded.
     * @type {number}
     */
    decimals;
    /**
     * Gets the number format used when the component is not focused.
     * Uses `column.format` if set.
     */
    get format() {
        return !isNullOrEmptyString(this._format) ? this._format : this.columnFormat;
    }
    set format(value) {
        this._format = value;
    }
    /**
     * Gets the current filter for the column field.
     * @readonly
     * @type {FilterDescriptor}
     */
    get currentFilter() {
        return this.filterByField(this.column.field);
    }
    /**
     * Gets the current filter operator for the column field.
     * @readonly
     * @type {string}
     */
    get currentOperator() {
        return this.currentFilter ? this.currentFilter.operator : this.operator;
    }
    get columnFormat() {
        return this.column && !isNullOrEmptyString(this.column.format) ?
            extractFormat(this.column.format) : "n2";
    }
    _format;
    subscription;
    constructor(filterService, ctx) {
        super(filterService);
        this.ctx = ctx;
        this.defaultOperators = numericOperators(this.ctx.localization);
    }
    ngOnInit() {
        this.subscription = this.ctx.localization.changes.subscribe(this.localizationChange.bind(this));
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        super.ngOnDestroy();
    }
    localizationChange() {
        this.defaultOperators = numericOperators(this.ctx.localization);
        if (this.operatorList.length) {
            this.operators = toJSON(this.operatorList.toArray());
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: NumericFilterComponent, deps: [{ token: FilterService }, { token: ContextService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: NumericFilterComponent, isStandalone: true, inputs: { column: "column", operator: "operator", step: "step", min: "min", max: "max", spinners: "spinners", decimals: "decimals", format: "format" }, usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: NumericFilterComponent, decorators: [{
            type: Directive,
            args: [{}]
        }], ctorParameters: () => [{ type: FilterService }, { type: ContextService }], propDecorators: { column: [{
                type: Input
            }], operator: [{
                type: Input
            }], step: [{
                type: Input
            }], min: [{
                type: Input
            }], max: [{
                type: Input
            }], spinners: [{
                type: Input
            }], decimals: [{
                type: Input
            }], format: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class NumericFilterMenuInputComponent {
    ctx;
    operators = [];
    column;
    filter;
    operator;
    currentFilter;
    filterService;
    filterDelay;
    isFirstDropDown;
    menuTabbingService;
    /**
     * Specifies the value used to increment or decrement the component value.
     * @type {number}
     */
    step = 1;
    /**
     * Specifies the smallest value that is valid.
     * @type {number}
     */
    min;
    /**
     * Specifies the greatest value that is valid.
     * @type {number}
     */
    max;
    /**
     * Specifies whether the **Up** and **Down** spin buttons are rendered.
     * @type {boolean}
     */
    spinners = true;
    /**
     * Specifies the number precision applied to the component value when focused.
     * If the user enters a number with greater precision than configured, the component value is rounded.
     * @type {number}
     */
    decimals;
    /**
     * Specifies the number format used when the component is not focused.
     * By default, the `column.format` value is used if set.
     * @type {string}
     */
    format;
    /**
     * The placeholder text for the filter input.
     * @type {string}
     */
    placeholder;
    constructor(ctx) {
        this.ctx = ctx;
    }
    messageFor(key) {
        return this.ctx.localization.get(key);
    }
    /**
     * @hidden
     */
    get columnLabel() {
        const localizationMsg = this.ctx.localization.get('filterInputLabel') || '';
        const columnName = this.column ? this.column.title || this.column.field : '';
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: NumericFilterMenuInputComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: NumericFilterMenuInputComponent, isStandalone: true, selector: "kendo-grid-numeric-filter-menu-input", inputs: { operators: "operators", column: "column", filter: "filter", operator: "operator", currentFilter: "currentFilter", filterService: "filterService", filterDelay: "filterDelay", isFirstDropDown: "isFirstDropDown", menuTabbingService: "menuTabbingService", step: "step", min: "min", max: "max", spinners: "spinners", decimals: "decimals", format: "format", placeholder: "placeholder" }, ngImport: i0, template: `
        <kendo-grid-filter-menu-input-wrapper
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [currentFilter]="currentFilter"
            [filterService]="filterService"
            [isFirstDropDown]="isFirstDropDown"
            [menuTabbingService]="menuTabbingService">
            <kendo-numerictextbox
                kendoFilterInput
                [columnLabel]="columnLabel"
                [filterDelay]="filterDelay"
                [autoCorrect]="true"
                [size]="ctx.grid?.isActionSheetExpanded ? 'large' : null"
                [value]="currentFilter?.value"
                [format]="format"
                [decimals]="decimals"
                [spinners]="spinners"
                [min]="min"
                [max]="max"
                [step]="step"
                [placeholder]="placeholder">
                <kendo-numerictextbox-messages
                    [increment]="messageFor('filterNumericIncrement')"
                    [decrement]="messageFor('filterNumericDecrement')"
                ></kendo-numerictextbox-messages>
            </kendo-numerictextbox>
        </kendo-grid-filter-menu-input-wrapper>
    `, isInline: true, dependencies: [{ kind: "component", type: FilterMenuInputWrapperComponent, selector: "kendo-grid-filter-menu-input-wrapper", inputs: ["filterService", "isFirstDropDown", "menuTabbingService", "currentFilter"] }, { kind: "component", type: NumericTextBoxComponent, selector: "kendo-numerictextbox", inputs: ["focusableId", "disabled", "readonly", "title", "autoCorrect", "format", "max", "min", "decimals", "placeholder", "step", "spinners", "rangeValidation", "tabindex", "tabIndex", "changeValueOnScroll", "selectOnFocus", "value", "maxlength", "size", "rounded", "fillMode", "inputAttributes"], outputs: ["valueChange", "focus", "blur", "inputFocus", "inputBlur"], exportAs: ["kendoNumericTextBox"] }, { kind: "directive", type: FilterInputDirective, selector: "[kendoFilterInput]", inputs: ["filterDelay", "columnLabel", "value"] }, { kind: "component", type: NumericTextBoxCustomMessagesComponent, selector: "kendo-numerictextbox-messages" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: NumericFilterMenuInputComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-numeric-filter-menu-input',
                    template: `
        <kendo-grid-filter-menu-input-wrapper
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [currentFilter]="currentFilter"
            [filterService]="filterService"
            [isFirstDropDown]="isFirstDropDown"
            [menuTabbingService]="menuTabbingService">
            <kendo-numerictextbox
                kendoFilterInput
                [columnLabel]="columnLabel"
                [filterDelay]="filterDelay"
                [autoCorrect]="true"
                [size]="ctx.grid?.isActionSheetExpanded ? 'large' : null"
                [value]="currentFilter?.value"
                [format]="format"
                [decimals]="decimals"
                [spinners]="spinners"
                [min]="min"
                [max]="max"
                [step]="step"
                [placeholder]="placeholder">
                <kendo-numerictextbox-messages
                    [increment]="messageFor('filterNumericIncrement')"
                    [decrement]="messageFor('filterNumericDecrement')"
                ></kendo-numerictextbox-messages>
            </kendo-numerictextbox>
        </kendo-grid-filter-menu-input-wrapper>
    `,
                    standalone: true,
                    imports: [FilterMenuInputWrapperComponent, NumericTextBoxComponent, FilterInputDirective, NumericTextBoxCustomMessagesComponent]
                }]
        }], ctorParameters: () => [{ type: ContextService }], propDecorators: { operators: [{
                type: Input
            }], column: [{
                type: Input
            }], filter: [{
                type: Input
            }], operator: [{
                type: Input
            }], currentFilter: [{
                type: Input
            }], filterService: [{
                type: Input
            }], filterDelay: [{
                type: Input
            }], isFirstDropDown: [{
                type: Input
            }], menuTabbingService: [{
                type: Input
            }], step: [{
                type: Input
            }], min: [{
                type: Input
            }], max: [{
                type: Input
            }], spinners: [{
                type: Input
            }], decimals: [{
                type: Input
            }], format: [{
                type: Input
            }], placeholder: [{
                type: Input
            }] } });

/**
 * Represents a numeric filter-menu component.
 * Use this component to filter numeric values in the Grid.
 *
 * @example
 * ```html
 * <kendo-grid-column field="UnitPrice">
 *   <ng-template kendoGridFilterMenuTemplate let-filter let-column="column" let-filterService="filterService">
 *     <kendo-grid-numeric-filter-menu
 *       [column]="column"
 *       [filter]="filter"
 *       [filterService]="filterService">
 *     </kendo-grid-numeric-filter-menu>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 * @remarks
 * Supported children components are: {@link EqualFilterOperatorComponent}, {@link NotEqualFilterOperatorComponent}, {@link GreaterFilterOperatorComponent}, {@link GreaterOrEqualToFilterOperatorComponent}, {@link LessFilterOperatorComponent}, {@link LessOrEqualToFilterOperatorComponent}, {@link IsNullFilterOperatorComponent}, {@link IsNotNullFilterOperatorComponent}.
 */
class NumericFilterMenuComponent extends NumericFilterComponent {
    logicOperators = logicOperators(this.ctx.localization);
    /**
     * @hidden
     */
    get hostClasses() {
        return false;
    }
    /**
     * Represents the current filter descriptor for the menu.
     * @type {CompositeFilterDescriptor}
     */
    filter = { filters: [], logic: "and" };
    /**
     * Determines if the inputs for the second criteria are displayed.
     * @default true
     */
    extra = true;
    /**
     * Represents the `FilterService` instance that handles changes in the filter descriptor.
     */
    filterService;
    /**
     * Determines the delay in milliseconds before creating a filter descriptor based on the value.
     * A value of `0` means no delay.
     * @default 500
     */
    filterDelay = 500;
    /**
     * The placeholder text for the filter input.
     * @type {string}
     */
    placeholder = '';
    /**
     * Sets the placeholder text for the extra filter input.
     * Applies when `extra` is set to `true`.
     * @type {string}
     */
    extraPlaceholder = '';
    /**
     * @hidden
     */
    menuTabbingService;
    constructor(ctx) {
        super(null, ctx);
    }
    get firstFilter() {
        return setFilter(0, this.filter, (this.column || {}).field, this.operator);
    }
    get secondFilter() {
        return setFilter(1, this.filter, (this.column || {}).field, this.operator);
    }
    logicChange(value) {
        this.filter.logic = value;
    }
    get filterMenuDropDownLabel() {
        const localizationMsg = this.ctx.localization.get('filterMenuLogicDropDownLabel') || '';
        const columnName = this.column ? this.column.title || this.column.field : '';
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
    localizationChange() {
        this.logicOperators = logicOperators(this.ctx.localization);
        super.localizationChange();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: NumericFilterMenuComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: NumericFilterMenuComponent, isStandalone: true, selector: "kendo-grid-numeric-filter-menu", inputs: { filter: "filter", extra: "extra", filterService: "filterService", filterDelay: "filterDelay", placeholder: "placeholder", extraPlaceholder: "extraPlaceholder", menuTabbingService: "menuTabbingService" }, host: { properties: { "class.k-filtercell": "this.hostClasses" } }, usesInheritance: true, ngImport: i0, template: `
        <kendo-grid-numeric-filter-menu-input
          [currentFilter]="firstFilter"
          [operators]="operators"
          [filterService]="filterService"
          [column]="column"
          [filter]="filter"
          [filterDelay]="filterDelay"
          [format]="format"
          [decimals]="decimals"
          [spinners]="spinners"
          [min]="min"
          [max]="max"
          [step]="step"
          [menuTabbingService]="menuTabbingService"
          [isFirstDropDown]="true"
          [placeholder]="placeholder">
        </kendo-grid-numeric-filter-menu-input>
        @if (extra) {
          <kendo-dropdownlist
            kendoFilterMenuDropDown
            [adaptiveTitle]="ctx.localization.get('adaptiveFilterOperatorsTitle')"
            [adaptiveMode]="ctx.grid?.adaptiveMode"
            [size]="ctx.grid?.isActionSheetExpanded ? 'large' : null"
            [filterMenuDropDownLabel]="filterMenuDropDownLabel"
            class="k-filter-and"
            [data]="logicOperators"
            [valuePrimitive]="true"
            (valueChange)="logicChange($event)"
            [value]="filter?.logic"
            textField="text"
            valueField="value">
          </kendo-dropdownlist>
        }
        @if (extra) {
          <kendo-grid-numeric-filter-menu-input
            [operators]="operators"
            [currentFilter]="secondFilter"
            [filterService]="filterService"
            [column]="column"
            [filter]="filter"
            [format]="format"
            [decimals]="decimals"
            [spinners]="spinners"
            [min]="min"
            [max]="max"
            [step]="step"
            [menuTabbingService]="menuTabbingService"
            [placeholder]="extraPlaceholder">
          </kendo-grid-numeric-filter-menu-input>
        }
        `, isInline: true, dependencies: [{ kind: "component", type: NumericFilterMenuInputComponent, selector: "kendo-grid-numeric-filter-menu-input", inputs: ["operators", "column", "filter", "operator", "currentFilter", "filterService", "filterDelay", "isFirstDropDown", "menuTabbingService", "step", "min", "max", "spinners", "decimals", "format", "placeholder"] }, { kind: "component", type: DropDownListComponent, selector: "kendo-dropdownlist", inputs: ["customIconClass", "showStickyHeader", "icon", "svgIcon", "loading", "data", "value", "textField", "valueField", "adaptiveMode", "adaptiveTitle", "adaptiveSubtitle", "popupSettings", "listHeight", "defaultItem", "disabled", "itemDisabled", "readonly", "filterable", "virtual", "ignoreCase", "delay", "valuePrimitive", "tabindex", "tabIndex", "size", "rounded", "fillMode", "leftRightArrowsNavigation", "id"], outputs: ["valueChange", "filterChange", "selectionChange", "open", "opened", "close", "closed", "focus", "blur"], exportAs: ["kendoDropDownList"] }, { kind: "directive", type: FilterMenuDropDownListDirective, selector: "[kendoFilterMenuDropDown]", inputs: ["filterMenuDropDownLabel"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: NumericFilterMenuComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-numeric-filter-menu',
                    template: `
        <kendo-grid-numeric-filter-menu-input
          [currentFilter]="firstFilter"
          [operators]="operators"
          [filterService]="filterService"
          [column]="column"
          [filter]="filter"
          [filterDelay]="filterDelay"
          [format]="format"
          [decimals]="decimals"
          [spinners]="spinners"
          [min]="min"
          [max]="max"
          [step]="step"
          [menuTabbingService]="menuTabbingService"
          [isFirstDropDown]="true"
          [placeholder]="placeholder">
        </kendo-grid-numeric-filter-menu-input>
        @if (extra) {
          <kendo-dropdownlist
            kendoFilterMenuDropDown
            [adaptiveTitle]="ctx.localization.get('adaptiveFilterOperatorsTitle')"
            [adaptiveMode]="ctx.grid?.adaptiveMode"
            [size]="ctx.grid?.isActionSheetExpanded ? 'large' : null"
            [filterMenuDropDownLabel]="filterMenuDropDownLabel"
            class="k-filter-and"
            [data]="logicOperators"
            [valuePrimitive]="true"
            (valueChange)="logicChange($event)"
            [value]="filter?.logic"
            textField="text"
            valueField="value">
          </kendo-dropdownlist>
        }
        @if (extra) {
          <kendo-grid-numeric-filter-menu-input
            [operators]="operators"
            [currentFilter]="secondFilter"
            [filterService]="filterService"
            [column]="column"
            [filter]="filter"
            [format]="format"
            [decimals]="decimals"
            [spinners]="spinners"
            [min]="min"
            [max]="max"
            [step]="step"
            [menuTabbingService]="menuTabbingService"
            [placeholder]="extraPlaceholder">
          </kendo-grid-numeric-filter-menu-input>
        }
        `,
                    standalone: true,
                    imports: [NumericFilterMenuInputComponent, DropDownListComponent, FilterMenuDropDownListDirective]
                }]
        }], ctorParameters: () => [{ type: ContextService }], propDecorators: { hostClasses: [{
                type: HostBinding,
                args: ['class.k-filtercell']
            }], filter: [{
                type: Input
            }], extra: [{
                type: Input
            }], filterService: [{
                type: Input
            }], filterDelay: [{
                type: Input
            }], placeholder: [{
                type: Input
            }], extraPlaceholder: [{
                type: Input
            }], menuTabbingService: [{
                type: Input
            }] } });

// eslint-disable no-access-missing-member
const dateOperators = localizeOperators({
    "filterEqOperator": "eq",
    "filterNotEqOperator": "neq",
    "filterAfterOrEqualOperator": "gte",
    "filterAfterOperator": "gt",
    "filterBeforeOrEqualOperator": "lte",
    "filterBeforeOperator": "lt",
    "filterIsNullOperator": "isnull",
    "filterIsNotNullOperator": "isnotnull"
});
/**
 * @hidden
 */
class DateFilterComponent extends BaseFilterCellComponent {
    ctx;
    /**
     * Sets the column for this filter.
     * @type {ColumnComponent}
     */
    column;
    /**
     * Sets the default filter operator.
     * @type {string}
     * @default 'gte'
     */
    operator = "gte";
    /**
     * Gets the current filter for the column field.
     * @readonly
     * @type {FilterDescriptor}
     */
    get currentFilter() {
        return this.filterByField(this.column.field);
    }
    /**
     * Sets the date format used when the component is not focused.
     * Uses `column.format` if set.
     */
    set format(value) {
        this._format = value;
    }
    /**
     * Gets the date format used when the component is not focused.
     * Uses `column.format` if set.
     * @readonly
     * @type {string}
     */
    get format() {
        return !isNullOrEmptyString(this._format) ? this._format : this.columnFormat;
    }
    /**
     * Sets the smallest valid date value.
     * @type {Date}
     */
    min;
    /**
     * Sets the largest valid date value.
     * @type {Date}
     */
    max;
    /**
     * Sets the descriptions for the format sections in the input field.
     * [See example](slug:placeholders_datepicker#toc-format-sections-description).
     */
    formatPlaceholder;
    /**
     * Sets the hint shown when the value is `null`.
     * [See example](slug:placeholders_datepicker#toc-text-hints).
     */
    placeholder;
    /**
     * Sets the active calendar view when the calendar opens.
     * Set `activeView` within the `topView`-`bottomView` range.
     * @default 'month'
     */
    activeView = "month";
    /**
     * Defines the lowest calendar view level the user can navigate to.
     * @default 'month'
     */
    bottomView = "month";
    /**
     * Defines the highest calendar view level the user can navigate to.
     * @default 'century'
     */
    topView = "century";
    /**
     * When `true`, shows a week number column in the `month` view.
     * @default false
     */
    weekNumber = false;
    /**
     * Gets the current filter operator for the column field.
     * @readonly
     * @type {string}
     */
    get currentOperator() {
        return this.currentFilter ? this.currentFilter.operator : this.operator;
    }
    get columnFormat() {
        return this.column && !isNullOrEmptyString(this.column.format) ?
            extractFormat(this.column.format) : "d";
    }
    _format;
    subscription;
    constructor(filterService, ctx) {
        super(filterService);
        this.ctx = ctx;
        this.defaultOperators = dateOperators(this.ctx.localization);
    }
    ngOnInit() {
        this.subscription = this.ctx.localization.changes.subscribe(this.localizationChange.bind(this));
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        super.ngOnDestroy();
    }
    localizationChange() {
        this.defaultOperators = dateOperators(this.ctx.localization);
        if (this.operatorList.length) {
            this.operators = toJSON(this.operatorList.toArray());
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DateFilterComponent, deps: [{ token: FilterService }, { token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: DateFilterComponent, isStandalone: true, selector: "kendo-grid-date-filter-base", inputs: { column: "column", operator: "operator", format: "format", min: "min", max: "max", formatPlaceholder: "formatPlaceholder", placeholder: "placeholder", activeView: "activeView", bottomView: "bottomView", topView: "topView", weekNumber: "weekNumber" }, usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DateFilterComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-date-filter-base',
                    template: ``
                }]
        }], ctorParameters: () => [{ type: FilterService }, { type: ContextService }], propDecorators: { column: [{
                type: Input
            }], operator: [{
                type: Input
            }], format: [{
                type: Input
            }], min: [{
                type: Input
            }], max: [{
                type: Input
            }], formatPlaceholder: [{
                type: Input
            }], placeholder: [{
                type: Input
            }], activeView: [{
                type: Input
            }], bottomView: [{
                type: Input
            }], topView: [{
                type: Input
            }], weekNumber: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class DateFilterMenuInputComponent {
    popupService;
    ctx;
    operators = [];
    column;
    filter;
    operator;
    currentFilter;
    filterService;
    menuTabbingService;
    format;
    formatPlaceholder;
    placeholder;
    min;
    max;
    activeView;
    bottomView;
    topView;
    weekNumber;
    isFirstDropDown;
    subscription;
    constructor(popupService, ctx) {
        this.popupService = popupService;
        this.ctx = ctx;
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
    open(picker) {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        this.subscription = this.popupService.onClose
            .pipe(filter(() => picker.isActive))
            .subscribe(e => e.preventDefault());
    }
    messageFor(key) {
        return this.ctx.localization.get(key);
    }
    get columnLabel() {
        const localizationMsg = this.ctx.localization.get('filterInputLabel') || '';
        const columnName = this.column ? this.column.title || this.column.field : '';
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DateFilterMenuInputComponent, deps: [{ token: SinglePopupService }, { token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: DateFilterMenuInputComponent, isStandalone: true, selector: "kendo-grid-date-filter-menu-input", inputs: { operators: "operators", column: "column", filter: "filter", operator: "operator", currentFilter: "currentFilter", filterService: "filterService", menuTabbingService: "menuTabbingService", format: "format", formatPlaceholder: "formatPlaceholder", placeholder: "placeholder", min: "min", max: "max", activeView: "activeView", bottomView: "bottomView", topView: "topView", weekNumber: "weekNumber", isFirstDropDown: "isFirstDropDown" }, ngImport: i0, template: `
        <kendo-grid-filter-menu-input-wrapper
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [currentFilter]="currentFilter"
            [filterService]="filterService"
            [isFirstDropDown]="isFirstDropDown"
            [menuTabbingService]="menuTabbingService">
            <kendo-datepicker #picker
                kendoFilterInput
                [adaptiveMode]="ctx.grid?.adaptiveMode"
                [size]="ctx.grid?.isActionSheetExpanded ? 'large' : null"
                [columnLabel]="columnLabel"
                [filterDelay]="0"
                (open)="open(picker)"
                [value]="currentFilter?.value"
                [placeholder]="placeholder"
                [formatPlaceholder]="formatPlaceholder"
                [format]="format"
                [min]="min"
                [max]="max"
                [activeView]="activeView"
                [bottomView]="bottomView"
                [topView]="topView"
                [weekNumber]="weekNumber">
                <kendo-datepicker-messages
                    [toggle]="messageFor('filterDateToggle')"
                    [today]="messageFor('filterDateToday')"
                ></kendo-datepicker-messages>
            </kendo-datepicker>
        </kendo-grid-filter-menu-input-wrapper>
    `, isInline: true, dependencies: [{ kind: "component", type: FilterMenuInputWrapperComponent, selector: "kendo-grid-filter-menu-input-wrapper", inputs: ["filterService", "isFirstDropDown", "menuTabbingService", "currentFilter"] }, { kind: "component", type: DatePickerComponent, selector: "kendo-datepicker", inputs: ["focusableId", "cellTemplate", "clearButton", "inputAttributes", "monthCellTemplate", "yearCellTemplate", "decadeCellTemplate", "centuryCellTemplate", "weekNumberTemplate", "headerTitleTemplate", "headerTemplate", "footerTemplate", "footer", "navigationItemTemplate", "weekDaysFormat", "showOtherMonthDays", "activeView", "bottomView", "topView", "calendarType", "animateCalendarNavigation", "disabled", "readonly", "readOnlyInput", "popupSettings", "navigation", "min", "max", "incompleteDateValidation", "autoCorrectParts", "autoSwitchParts", "autoSwitchKeys", "enableMouseWheel", "allowCaretMode", "autoFill", "focusedDate", "value", "format", "twoDigitYearMax", "formatPlaceholder", "placeholder", "tabindex", "tabIndex", "disabledDates", "adaptiveTitle", "adaptiveSubtitle", "rangeValidation", "disabledDatesValidation", "weekNumber", "size", "rounded", "fillMode", "adaptiveMode"], outputs: ["valueChange", "focus", "blur", "open", "close", "escape"], exportAs: ["kendo-datepicker"] }, { kind: "directive", type: FilterInputDirective, selector: "[kendoFilterInput]", inputs: ["filterDelay", "columnLabel", "value"] }, { kind: "component", type: DatePickerCustomMessagesComponent, selector: "kendo-datepicker-messages" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DateFilterMenuInputComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-date-filter-menu-input',
                    template: `
        <kendo-grid-filter-menu-input-wrapper
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [currentFilter]="currentFilter"
            [filterService]="filterService"
            [isFirstDropDown]="isFirstDropDown"
            [menuTabbingService]="menuTabbingService">
            <kendo-datepicker #picker
                kendoFilterInput
                [adaptiveMode]="ctx.grid?.adaptiveMode"
                [size]="ctx.grid?.isActionSheetExpanded ? 'large' : null"
                [columnLabel]="columnLabel"
                [filterDelay]="0"
                (open)="open(picker)"
                [value]="currentFilter?.value"
                [placeholder]="placeholder"
                [formatPlaceholder]="formatPlaceholder"
                [format]="format"
                [min]="min"
                [max]="max"
                [activeView]="activeView"
                [bottomView]="bottomView"
                [topView]="topView"
                [weekNumber]="weekNumber">
                <kendo-datepicker-messages
                    [toggle]="messageFor('filterDateToggle')"
                    [today]="messageFor('filterDateToday')"
                ></kendo-datepicker-messages>
            </kendo-datepicker>
        </kendo-grid-filter-menu-input-wrapper>
    `,
                    standalone: true,
                    imports: [FilterMenuInputWrapperComponent, DatePickerComponent, FilterInputDirective, DatePickerCustomMessagesComponent]
                }]
        }], ctorParameters: () => [{ type: SinglePopupService }, { type: ContextService }], propDecorators: { operators: [{
                type: Input
            }], column: [{
                type: Input
            }], filter: [{
                type: Input
            }], operator: [{
                type: Input
            }], currentFilter: [{
                type: Input
            }], filterService: [{
                type: Input
            }], menuTabbingService: [{
                type: Input
            }], format: [{
                type: Input
            }], formatPlaceholder: [{
                type: Input
            }], placeholder: [{
                type: Input
            }], min: [{
                type: Input
            }], max: [{
                type: Input
            }], activeView: [{
                type: Input
            }], bottomView: [{
                type: Input
            }], topView: [{
                type: Input
            }], weekNumber: [{
                type: Input
            }], isFirstDropDown: [{
                type: Input
            }] } });

/**
 * Represents a filtering menu component for date columns.
 *
 * @example
 * ```html
 * <kendo-grid-column field="FirstOrderedOn">
 *   <ng-template kendoGridFilterMenuTemplate let-filter let-column="column" let-filterService="filterService">
 *     <kendo-grid-date-filter-menu
 *       [column]="column"
 *       [filter]="filter"
 *       [filterService]="filterService">
 *     </kendo-grid-date-filter-menu>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 * @remarks
 * Supported children components are: {@link EqualFilterOperatorComponent}, {@link NotEqualFilterOperatorComponent}, {@link AfterEqFilterOperatorComponent}, {@link AfterFilterOperatorComponent}, {@link BeforeEqFilterOperatorComponent}, {@link BeforeFilterOperatorComponent}, {@link IsNullFilterOperatorComponent}, {@link IsNotNullFilterOperatorComponent}.
 */
class DateFilterMenuComponent extends DateFilterComponent {
    logicOperators = logicOperators(this.ctx.localization);
    /**
     * @hidden
     */
    get hostClasses() {
        return false;
    }
    /**
     * The current menu filter.
     * @type {CompositeFilterDescriptor}
     */
    filter = { filters: [], logic: "and" };
    /**
     * Determines if the inputs for the second criteria are displayed.
     * @default true
     */
    extra = true;
    /**
     * Represents the `FilterService` instance that handles changes in the filter descriptor.
     */
    filterService;
    /**
     * @hidden
     */
    menuTabbingService;
    constructor(ctx) {
        super(null, ctx);
    }
    get firstFilter() {
        return setFilter(0, this.filter, (this.column || {}).field, this.operator);
    }
    get secondFilter() {
        return setFilter(1, this.filter, (this.column || {}).field, this.operator);
    }
    logicChange(value) {
        this.filter.logic = value;
    }
    get filterMenuDropDownLabel() {
        const localizationMsg = this.ctx.localization.get('filterMenuLogicDropDownLabel') || '';
        const columnName = this.column ? this.column.title || this.column.field : '';
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
    localizationChange() {
        this.logicOperators = logicOperators(this.ctx.localization);
        super.localizationChange();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DateFilterMenuComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: DateFilterMenuComponent, isStandalone: true, selector: "kendo-grid-date-filter-menu", inputs: { filter: "filter", extra: "extra", filterService: "filterService", menuTabbingService: "menuTabbingService" }, host: { properties: { "class.k-filtercell": "this.hostClasses" } }, usesInheritance: true, ngImport: i0, template: `
        <kendo-grid-date-filter-menu-input
          [currentFilter]="firstFilter"
          [operators]="operators"
          [filterService]="filterService"
          [column]="column"
          [filter]="filter"
          [activeView]="activeView"
          [bottomView]="bottomView"
          [topView]="topView"
          [format]="format"
          [formatPlaceholder]="formatPlaceholder"
          [placeholder]="placeholder"
          [min]="min"
          [max]="max"
          [weekNumber]="weekNumber"
          [isFirstDropDown]="true"
          [menuTabbingService]="menuTabbingService">
        </kendo-grid-date-filter-menu-input>
        @if (extra) {
          <kendo-dropdownlist
            kendoFilterMenuDropDown
            [adaptiveTitle]="ctx.localization.get('adaptiveFilterOperatorsTitle')"
            [adaptiveMode]="ctx.grid?.adaptiveMode"
            [size]="ctx.grid?.isActionSheetExpanded ? 'large' : null"
            [filterMenuDropDownLabel]="filterMenuDropDownLabel"
            class="k-filter-and"
            [data]="logicOperators"
            [valuePrimitive]="true"
            (valueChange)="logicChange($event)"
            [value]="filter?.logic"
            textField="text"
            valueField="value">
          </kendo-dropdownlist>
        }
        @if (extra) {
          <kendo-grid-date-filter-menu-input
            [operators]="operators"
            [currentFilter]="secondFilter"
            [filterService]="filterService"
            [column]="column"
            [filter]="filter"
            [activeView]="activeView"
            [bottomView]="bottomView"
            [topView]="topView"
            [format]="format"
            [formatPlaceholder]="formatPlaceholder"
            [placeholder]="placeholder"
            [min]="min"
            [max]="max"
            [weekNumber]="weekNumber"
            [menuTabbingService]="menuTabbingService">
          </kendo-grid-date-filter-menu-input>
        }
        `, isInline: true, dependencies: [{ kind: "component", type: DateFilterMenuInputComponent, selector: "kendo-grid-date-filter-menu-input", inputs: ["operators", "column", "filter", "operator", "currentFilter", "filterService", "menuTabbingService", "format", "formatPlaceholder", "placeholder", "min", "max", "activeView", "bottomView", "topView", "weekNumber", "isFirstDropDown"] }, { kind: "component", type: DropDownListComponent, selector: "kendo-dropdownlist", inputs: ["customIconClass", "showStickyHeader", "icon", "svgIcon", "loading", "data", "value", "textField", "valueField", "adaptiveMode", "adaptiveTitle", "adaptiveSubtitle", "popupSettings", "listHeight", "defaultItem", "disabled", "itemDisabled", "readonly", "filterable", "virtual", "ignoreCase", "delay", "valuePrimitive", "tabindex", "tabIndex", "size", "rounded", "fillMode", "leftRightArrowsNavigation", "id"], outputs: ["valueChange", "filterChange", "selectionChange", "open", "opened", "close", "closed", "focus", "blur"], exportAs: ["kendoDropDownList"] }, { kind: "directive", type: FilterMenuDropDownListDirective, selector: "[kendoFilterMenuDropDown]", inputs: ["filterMenuDropDownLabel"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DateFilterMenuComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-date-filter-menu',
                    template: `
        <kendo-grid-date-filter-menu-input
          [currentFilter]="firstFilter"
          [operators]="operators"
          [filterService]="filterService"
          [column]="column"
          [filter]="filter"
          [activeView]="activeView"
          [bottomView]="bottomView"
          [topView]="topView"
          [format]="format"
          [formatPlaceholder]="formatPlaceholder"
          [placeholder]="placeholder"
          [min]="min"
          [max]="max"
          [weekNumber]="weekNumber"
          [isFirstDropDown]="true"
          [menuTabbingService]="menuTabbingService">
        </kendo-grid-date-filter-menu-input>
        @if (extra) {
          <kendo-dropdownlist
            kendoFilterMenuDropDown
            [adaptiveTitle]="ctx.localization.get('adaptiveFilterOperatorsTitle')"
            [adaptiveMode]="ctx.grid?.adaptiveMode"
            [size]="ctx.grid?.isActionSheetExpanded ? 'large' : null"
            [filterMenuDropDownLabel]="filterMenuDropDownLabel"
            class="k-filter-and"
            [data]="logicOperators"
            [valuePrimitive]="true"
            (valueChange)="logicChange($event)"
            [value]="filter?.logic"
            textField="text"
            valueField="value">
          </kendo-dropdownlist>
        }
        @if (extra) {
          <kendo-grid-date-filter-menu-input
            [operators]="operators"
            [currentFilter]="secondFilter"
            [filterService]="filterService"
            [column]="column"
            [filter]="filter"
            [activeView]="activeView"
            [bottomView]="bottomView"
            [topView]="topView"
            [format]="format"
            [formatPlaceholder]="formatPlaceholder"
            [placeholder]="placeholder"
            [min]="min"
            [max]="max"
            [weekNumber]="weekNumber"
            [menuTabbingService]="menuTabbingService">
          </kendo-grid-date-filter-menu-input>
        }
        `,
                    standalone: true,
                    imports: [DateFilterMenuInputComponent, DropDownListComponent, FilterMenuDropDownListDirective]
                }]
        }], ctorParameters: () => [{ type: ContextService }], propDecorators: { hostClasses: [{
                type: HostBinding,
                args: ['class.k-filtercell']
            }], filter: [{
                type: Input
            }], extra: [{
                type: Input
            }], filterService: [{
                type: Input
            }], menuTabbingService: [{
                type: Input
            }] } });

// eslint-disable no-access-missing-member
/**
 * @hidden
 */
class BooleanFilterComponent extends BaseFilterCellComponent {
    ctx;
    /**
     * Sets the column for this filter.
     * @type {ColumnComponent}
     */
    column;
    /**
     * @hidden
     */
    operator = "eq";
    /**
     * Gets the current filter for the column field.
     * @readonly
     * @type {FilterDescriptor}
     */
    get currentFilter() {
        return this.filterByField(this.column.field);
    }
    /**
     * Gets the current filter operator for the column field.
     * @readonly
     * @type {string}
     */
    get currentOperator() {
        return this.currentFilter ? this.currentFilter.operator : this.operator;
    }
    items;
    defaultItem;
    subscription;
    constructor(filterService, ctx) {
        super(filterService);
        this.ctx = ctx;
        this.items = [
            { text: this.ctx.localization.get("filterIsTrue"), value: true },
            { text: this.ctx.localization.get("filterIsFalse"), value: false }
        ];
        this.defaultItem = { text: this.ctx.localization.get("filterBooleanAll"), value: null };
    }
    ngOnInit() {
        this.subscription = this.ctx.localization.changes.subscribe(this.localizationChange.bind(this));
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        super.ngOnDestroy();
    }
    localizationChange() {
        this.items = [
            { text: this.ctx.localization.get("filterIsTrue"), value: true },
            { text: this.ctx.localization.get("filterIsFalse"), value: false }
        ];
        this.defaultItem = { text: this.ctx.localization.get("filterBooleanAll"), value: null };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: BooleanFilterComponent, deps: [{ token: FilterService }, { token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: BooleanFilterComponent, isStandalone: true, selector: "kendo-grid-boolean-filter-base", inputs: { column: "column" }, usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: BooleanFilterComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-boolean-filter-base',
                    template: ``
                }]
        }], ctorParameters: () => [{ type: FilterService }, { type: ContextService }], propDecorators: { column: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class BooleanFilterRadioButtonDirective {
    hostElement;
    renderer;
    columnLabel;
    radioButtonEl;
    constructor(hostElement, renderer) {
        this.hostElement = hostElement;
        this.renderer = renderer;
    }
    ngAfterViewInit() {
        this.radioButtonEl = this.hostElement.nativeElement;
        this.renderer.setAttribute(this.hostElement.nativeElement, 'aria-label', this.columnLabel);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: BooleanFilterRadioButtonDirective, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: BooleanFilterRadioButtonDirective, isStandalone: true, selector: "[kendoFilterMenuRadioButton]", inputs: { columnLabel: "columnLabel" }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: BooleanFilterRadioButtonDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoFilterMenuRadioButton]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.Renderer2 }], propDecorators: { columnLabel: [{
                type: Input
            }] } });

/**
 * Represents a filtering menu component for boolean columns.
 * [See example](slug:filter_menu#toc-built-in-filter-menu-components).
 *
 * @example
 * ```html
 * <kendo-grid-column field="Discontinued" title="Discontinued">
 *   <ng-template kendoGridFilterMenuTemplate let-filter let-column="column" let-filterService="filterService">
 *     <kendo-grid-boolean-filter-menu
 *       [column]="column"
 *       [filter]="filter"
 *       [filterService]="filterService">
 *     </kendo-grid-boolean-filter-menu>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 */
class BooleanFilterMenuComponent extends BooleanFilterComponent {
    /**
     * @hidden
     */
    get hostClasses() {
        return false;
    }
    /**
     * The current menu filter.
     * @type {CompositeFilterDescriptor}
     */
    filter = { filters: [], logic: "and" };
    /**
     * Represents the `FilterService` instance that handles changes in the filter descriptor.
     */
    filterService;
    /**
     * @hidden
     */
    menuTabbingService;
    idPrefix = guid();
    /**
     * @hidden
     */
    radioButtons;
    constructor(ctx) {
        super(null, ctx);
    }
    ngAfterViewInit() {
        this.filterService.menuTabbingService.firstFocusable = this.radioButtons.first.radioButtonEl;
        if (!this.menuTabbingService?.isTabbedInterface) {
            this.radioButtons.first.radioButtonEl.focus();
        }
    }
    /**
     * @hidden
     */
    radioId(value) {
        return `${this.idPrefix}_${value}`;
    }
    /**
     * @hidden
     */
    onChange(value, input) {
        this.applyFilter(this.updateFilter({
            field: this.column.field,
            operator: "eq",
            value: value
        }));
        this.filterService.menuTabbingService.firstFocusable = input.hostElement.nativeElement;
    }
    /**
     * @hidden
     */
    isSelected(radioValue) {
        return this.filtersByField(this.column.field).some(({ value }) => value === radioValue);
    }
    /**
     * @hidden
     */
    onShiftTab(e) {
        if (!this.menuTabbingService?.isColumnMenu && this.filterService.menuTabbingService.lastFocusable) {
            e.preventDefault();
            this.filterService.menuTabbingService.lastFocusable.focus();
        }
    }
    /**
     * @hidden
     */
    get columnLabel() {
        const localizationMsg = this.ctx.localization.get('filterInputLabel') || '';
        const columnName = this.column.title || this.column.field;
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: BooleanFilterMenuComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: BooleanFilterMenuComponent, isStandalone: true, selector: "kendo-grid-boolean-filter-menu", inputs: { filter: "filter", filterService: "filterService", menuTabbingService: "menuTabbingService" }, host: { properties: { "class.k-filtercell": "this.hostClasses" } }, viewQueries: [{ propertyName: "radioButtons", predicate: BooleanFilterRadioButtonDirective, descendants: true }], usesInheritance: true, ngImport: i0, template: `
        <ul class="k-radio-list k-reset">
          @for (item of items; track item) {
            <li>
              <kendo-radiobutton
                kendoFilterMenuRadioButton
                [columnLabel]="columnLabel"
                #input
                [size]="ctx.grid?.isActionSheetExpanded ? 'large' : null"
                [name]="idPrefix"
                [checked]="isSelected(item.value)"
                [attr.id]="radioId(item.value)"
                (change)="onChange(item.value, input)"
                (keydown.shift.tab)="onShiftTab($event)"
              ></kendo-radiobutton>
              <label class="k-radio-label" [attr.for]="input.focusableId">{{item.text}}</label>
            </li>
          }
        </ul>
        `, isInline: true, dependencies: [{ kind: "component", type: RadioButtonComponent, selector: "kendo-radiobutton", inputs: ["checked"], outputs: ["checkedChange"], exportAs: ["kendoRadioButton"] }, { kind: "directive", type: BooleanFilterRadioButtonDirective, selector: "[kendoFilterMenuRadioButton]", inputs: ["columnLabel"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: BooleanFilterMenuComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-boolean-filter-menu',
                    template: `
        <ul class="k-radio-list k-reset">
          @for (item of items; track item) {
            <li>
              <kendo-radiobutton
                kendoFilterMenuRadioButton
                [columnLabel]="columnLabel"
                #input
                [size]="ctx.grid?.isActionSheetExpanded ? 'large' : null"
                [name]="idPrefix"
                [checked]="isSelected(item.value)"
                [attr.id]="radioId(item.value)"
                (change)="onChange(item.value, input)"
                (keydown.shift.tab)="onShiftTab($event)"
              ></kendo-radiobutton>
              <label class="k-radio-label" [attr.for]="input.focusableId">{{item.text}}</label>
            </li>
          }
        </ul>
        `,
                    standalone: true,
                    imports: [RadioButtonComponent, BooleanFilterRadioButtonDirective]
                }]
        }], ctorParameters: () => [{ type: ContextService }], propDecorators: { hostClasses: [{
                type: HostBinding,
                args: ['class.k-filtercell']
            }], filter: [{
                type: Input
            }], filterService: [{
                type: Input
            }], menuTabbingService: [{
                type: Input
            }], radioButtons: [{
                type: ViewChildren,
                args: [BooleanFilterRadioButtonDirective]
            }] } });

/**
 * @hidden
 *
 * > List the following components as `entryComponents` in the GridModule.
 */
const filterMenuComponentFactory = (type) => ({
    "boolean": BooleanFilterMenuComponent,
    "date": DateFilterMenuComponent,
    "numeric": NumericFilterMenuComponent,
    "text": StringFilterMenuComponent
}[type]);

/**
 * @hidden
 */
class FilterMenuHostDirective extends FilterHostDirective {
    filterService;
    menuTabbingService;
    constructor(host) {
        super(host);
    }
    componentType() {
        if (isPresent(this.column) && !isNullOrEmptyString(this.column.filter)) {
            return filterMenuComponentFactory(this.column.filter);
        }
        return StringFilterMenuComponent;
    }
    initComponent(ctx) {
        super.initComponent(ctx);
        this.component.instance.filterService = this.filterService;
        this.component.instance.menuTabbingService = this.menuTabbingService;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FilterMenuHostDirective, deps: [{ token: i0.ViewContainerRef }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: FilterMenuHostDirective, isStandalone: true, selector: "[kendoFilterMenuHost]", inputs: { filterService: "filterService", menuTabbingService: "menuTabbingService" }, usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FilterMenuHostDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoFilterMenuHost]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.ViewContainerRef }], propDecorators: { filterService: [{
                type: Input
            }], menuTabbingService: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class LocalDataChangesService {
    changes = new EventEmitter();
    data;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: LocalDataChangesService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: LocalDataChangesService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: LocalDataChangesService, decorators: [{
            type: Injectable
        }] });

const FORMAT_REGEX = /\{\d+:?/;
/**
 * @hidden
 */
class FormatPipe {
    intlService;
    constructor(intlService) {
        this.intlService = intlService;
    }
    transform(value, format) {
        const intl = this.intlService;
        if (isString(format) && FORMAT_REGEX.exec(format)) {
            return intl.format(format, value);
        }
        return intl.toString(value, format);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FormatPipe, deps: [{ token: i1$4.IntlService }], target: i0.ɵɵFactoryTarget.Pipe });
    static ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "19.2.18", ngImport: i0, type: FormatPipe, isStandalone: true, name: "format", pure: false });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FormatPipe, decorators: [{
            type: Pipe,
            args: [{
                    // eslint-disable-next-line @angular-eslint/pipe-prefix
                    name: 'format',
                    pure: false,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1$4.IntlService }] });

/**
 * @hidden
 */
class MultiCheckboxFilterComponent {
    ctx;
    dataChangesService;
    column;
    filterChange = new EventEmitter();
    filterInput;
    constructor(ctx, dataChangesService) {
        this.ctx = ctx;
        this.dataChangesService = dataChangesService;
    }
    listData = [];
    searchIcon = searchIcon;
    showSelectAll = true;
    currentlySelected = new Set();
    isSearched = false;
    currentFilter;
    filterChangeSub;
    baseListData = [];
    ngOnInit() {
        this.initializeData();
        this.currentFilter = this.ctx.grid?.filter ?? this.emptyFilter();
        this.updateSelectionFromFilter();
        if (this.currentFilter) {
            this.filterChange.emit(this.currentFilter);
        }
    }
    ngAfterViewInit() {
        if (this.filterInput) {
            this.filterChangeSub = this.filterInput.change.subscribe(this.onSearch.bind(this));
        }
    }
    ngOnDestroy() {
        if (this.filterChangeSub) {
            this.filterChangeSub.unsubscribe();
            this.filterChangeSub = null;
        }
    }
    isItemSelected(item) {
        return this.currentlySelected.has(item);
    }
    onSearch(value) {
        const searchValue = value;
        this.isSearched = searchValue.length > 0;
        this.showSelectAll = !this.isSearched;
        if (!searchValue) {
            this.listData = [...this.baseListData];
        }
        else {
            this.listData = filterBy(this.baseListData, { operator: 'contains', value: searchValue });
        }
    }
    handleCheckBoxChange(checkedState, value, selectAllChecked) {
        const field = this.column?.field;
        if (!field) {
            return;
        }
        if (!this.currentFilter) {
            this.currentFilter = this.emptyFilter();
        }
        const newFilter = this.currentFilter;
        const filters = [...newFilter.filters];
        const compositeIndex = this.getCompositeFilterIndex(newFilter);
        let fieldFilters = [];
        if (compositeIndex !== -1 && filters[compositeIndex].filters && !selectAllChecked) {
            fieldFilters = [...filters[compositeIndex].filters];
        }
        if (checkedState && selectAllChecked) {
            this.listData.forEach(item => {
                if (!fieldFilters.some(f => f.value === item)) {
                    fieldFilters.push({ field, operator: 'eq', value: item });
                }
            });
        }
        else if (!checkedState && selectAllChecked) {
            fieldFilters = [];
        }
        else if (checkedState) {
            if (!fieldFilters.some(f => f.value === value)) {
                fieldFilters.push({ field, operator: 'eq', value });
            }
        }
        else {
            const idx = fieldFilters.findIndex(f => f.value === value);
            if (idx > -1) {
                fieldFilters.splice(idx, 1);
            }
        }
        if (fieldFilters.length === 0) {
            if (compositeIndex !== -1) {
                filters.splice(compositeIndex, 1);
            }
        }
        else {
            const block = { logic: 'or', filters: fieldFilters };
            if (compositeIndex !== -1) {
                filters[compositeIndex] = block;
            }
            else {
                filters.push(block);
            }
        }
        newFilter.logic = 'and';
        newFilter.filters = filters;
        this.currentFilter = newFilter;
        this.updateSelectionFromFilter();
        this.filterChange.emit(this.currentFilter);
    }
    get filteredGridData() {
        return filterBy(this.gridData, this.ctx.grid?.filter);
    }
    get selectAllChecked() {
        if (!this.listData || this.listData.length === 0) {
            return false;
        }
        const total = this.listData.length;
        const selectedInView = this.listData.filter(i => this.currentlySelected.has(i)).length;
        if (selectedInView === 0) {
            return false;
        }
        if (selectedInView === total) {
            return true;
        }
        return 'indeterminate';
    }
    get gridData() {
        let data = [];
        const isLocalData = isPresent$1(this.ctx?.dataBindingDirective);
        if (isPresent$1(this.normalizedFilterVariant.data)) {
            data = this.normalizedFilterVariant.data;
        }
        else if (isLocalData) {
            data = this.dataChangesService.data;
        }
        else {
            data = this.ctx.grid?.flatData;
        }
        return data || [];
    }
    get normalizedFilterVariant() {
        const defaultMultiCheckboxSettings = { variant: 'multiCheckbox', search: true };
        if (typeof this.column?.filterVariant === 'string') {
            return {
                variant: this.column.filterVariant,
                search: true
            };
        }
        return Object.assign(defaultMultiCheckboxSettings, this.column?.filterVariant);
    }
    get selectedItemsMessage() {
        const localizationMsg = this.messageFor('multiCheckboxFilterSelectedItemsCount') || '';
        return replaceMessagePlaceholder(localizationMsg, 'selectedItemsCount', this.currentlySelected.size.toString());
    }
    messageFor(key) {
        return this.ctx.localization.get(key);
    }
    getUniqueDateValues(data) {
        return data.reduce((acc, current) => {
            const value = current[this.column.field];
            if (value instanceof Date && acc.findIndex(d => d.getTime() === value.getTime()) === -1) {
                acc.push(value);
            }
            return acc;
        }, []);
    }
    initializeData() {
        if (!this.column) {
            this.baseListData = [];
            return;
        }
        const isDate = this.column.filter === 'date';
        if (isDate) {
            const dates = this.getUniqueDateValues(this.gridData);
            const sortedDates = [...dates].sort((a, b) => a - b);
            this.baseListData = sortedDates;
        }
        else {
            const field = this.column.field;
            const mapped = this.gridData.map(item => item?.[field]);
            this.baseListData = [...new Set(mapped)].sort((a, b) => {
                if (a > b) {
                    return 1;
                }
                if (a < b) {
                    return -1;
                }
                return 0;
            });
        }
        this.listData = [...this.baseListData];
    }
    emptyFilter() { return { filters: [], logic: 'and' }; }
    getCompositeFilterIndex(filter) {
        const field = this.column?.field;
        return filter.filters.findIndex((f) => f.filters?.length && f.filters[0].field === field);
    }
    updateSelectionFromFilter() {
        this.currentlySelected.clear();
        if (!this.currentFilter || !this.column?.field) {
            return;
        }
        const idx = this.getCompositeFilterIndex(this.currentFilter);
        if (idx === -1) {
            return;
        }
        const block = this.currentFilter.filters[idx];
        if (block && Array.isArray(block.filters)) {
            block.filters.forEach((f) => {
                if (f.field === this.column.field && f.operator === 'eq') {
                    this.currentlySelected.add(f.value);
                }
            });
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: MultiCheckboxFilterComponent, deps: [{ token: ContextService }, { token: LocalDataChangesService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: MultiCheckboxFilterComponent, isStandalone: true, selector: "kendo-grid-multicheckbox-filter", inputs: { column: "column" }, outputs: { filterChange: "filterChange" }, viewQueries: [{ propertyName: "filterInput", first: true, predicate: FilterInputDirective, descendants: true }], ngImport: i0, template: `
        @if (normalizedFilterVariant.search) {
          <kendo-textbox
            kendoFilterInput
            class="k-searchbox"
            [placeholder]="messageFor('multiCheckboxFilterSearchPlaceholder')">
            <ng-template kendoTextBoxPrefixTemplate>
              <kendo-icon-wrapper innerCssClass="k-input-icon" name="search" [svgIcon]="searchIcon"></kendo-icon-wrapper>
            </ng-template>
          </kendo-textbox>
        }
        <ul class="k-reset k-multicheck-wrap">
          @if (showSelectAll) {
            <li class="k-item k-check-all-wrap">
              <label class="k-label k-checkbox-label" role="option">
                <kendo-checkbox
                  [checkedState]="selectAllChecked"
                  (checkedStateChange)="handleCheckBoxChange($event, null, true)">
                </kendo-checkbox>
                <span>{{ messageFor('multiCheckboxFilterSelectAllLabel') }}</span>
              </label>
            </li>
          }
          @for (item of listData; track item) {
            <li class="k-item">
              <label class="k-label k-checkbox-label" role="option">
                <kendo-checkbox
                  [checkedState]="isItemSelected(item)"
                  (checkedStateChange)="handleCheckBoxChange($event, item)">
                </kendo-checkbox>
                <span>{{ item | format: column.format }}</span>
              </label>
            </li>
          }
        </ul>
        <div class="k-filter-selected-items">{{selectedItemsMessage}}</div>
        `, isInline: true, dependencies: [{ kind: "component", type: CheckBoxComponent, selector: "kendo-checkbox", inputs: ["checkedState", "rounded"], outputs: ["checkedStateChange"], exportAs: ["kendoCheckBox"] }, { kind: "component", type: TextBoxComponent, selector: "kendo-textbox", inputs: ["focusableId", "title", "type", "disabled", "readonly", "tabindex", "value", "selectOnFocus", "showSuccessIcon", "showErrorIcon", "clearButton", "successIcon", "successSvgIcon", "errorIcon", "errorSvgIcon", "clearButtonIcon", "clearButtonSvgIcon", "size", "rounded", "fillMode", "tabIndex", "placeholder", "maxlength", "inputAttributes"], outputs: ["valueChange", "inputFocus", "inputBlur", "focus", "blur"], exportAs: ["kendoTextBox"] }, { kind: "directive", type: TextBoxPrefixTemplateDirective, selector: "[kendoTextBoxPrefixTemplate]", inputs: ["showSeparator"] }, { kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "pipe", type: FormatPipe, name: "format" }, { kind: "directive", type: FilterInputDirective, selector: "[kendoFilterInput]", inputs: ["filterDelay", "columnLabel", "value"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: MultiCheckboxFilterComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-multicheckbox-filter',
                    template: `
        @if (normalizedFilterVariant.search) {
          <kendo-textbox
            kendoFilterInput
            class="k-searchbox"
            [placeholder]="messageFor('multiCheckboxFilterSearchPlaceholder')">
            <ng-template kendoTextBoxPrefixTemplate>
              <kendo-icon-wrapper innerCssClass="k-input-icon" name="search" [svgIcon]="searchIcon"></kendo-icon-wrapper>
            </ng-template>
          </kendo-textbox>
        }
        <ul class="k-reset k-multicheck-wrap">
          @if (showSelectAll) {
            <li class="k-item k-check-all-wrap">
              <label class="k-label k-checkbox-label" role="option">
                <kendo-checkbox
                  [checkedState]="selectAllChecked"
                  (checkedStateChange)="handleCheckBoxChange($event, null, true)">
                </kendo-checkbox>
                <span>{{ messageFor('multiCheckboxFilterSelectAllLabel') }}</span>
              </label>
            </li>
          }
          @for (item of listData; track item) {
            <li class="k-item">
              <label class="k-label k-checkbox-label" role="option">
                <kendo-checkbox
                  [checkedState]="isItemSelected(item)"
                  (checkedStateChange)="handleCheckBoxChange($event, item)">
                </kendo-checkbox>
                <span>{{ item | format: column.format }}</span>
              </label>
            </li>
          }
        </ul>
        <div class="k-filter-selected-items">{{selectedItemsMessage}}</div>
        `,
                    standalone: true,
                    imports: [CheckBoxComponent, TextBoxComponent, TextBoxPrefixTemplateDirective, IconWrapperComponent, FormatPipe, FilterInputDirective]
                }]
        }], ctorParameters: () => [{ type: ContextService }, { type: LocalDataChangesService }], propDecorators: { column: [{
                type: Input
            }], filterChange: [{
                type: Output
            }], filterInput: [{
                type: ViewChild,
                args: [FilterInputDirective]
            }] } });

const isNoValueOperator = operator => (operator === "isnull"
    || operator === "isnotnull"
    || operator === "isempty"
    || operator === "isnotempty");
/**
 * @hidden
 */
const validFilters = ({ value, operator }) => !isNullOrEmptyString(value) || isNoValueOperator(operator);
const trimFilters = (filter) => {
    const trimComposite = (node) => {
        const trimmed = [];
        for (const f of node.filters || []) {
            if (isCompositeFilterDescriptor(f)) {
                const child = trimComposite(f);
                if (child.filters.length) {
                    trimmed.push(child);
                }
            }
            else if (validFilters(f)) {
                trimmed.push(f);
            }
        }
        return { logic: node.logic || 'and', filters: trimmed };
    };
    return trimComposite(filter);
};
const findParent = (filters, field, parent) => {
    return filters.reduce((acc, filter) => {
        if (acc) {
            return acc;
        }
        if (filter.filters) {
            return findParent(filter.filters, field, filter);
        }
        else if (filter.field === field) {
            return parent;
        }
        return acc;
    }, undefined);
};
/**
 * @hidden
 */
const parentLogicOfDefault = (filter, field, def = "and") => {
    const parent = findParent(((filter || {}).filters || []), field);
    return isPresent(parent) ? parent.logic : def;
};
/**
 * @hidden
 */
class FilterMenuContainerComponent {
    parentService;
    childService;
    ctx;
    cd;
    adaptiveGridService;
    close = new EventEmitter();
    /**
     * The column with which the filter is associated.
     * @type {ColumnComponent}
     */
    column;
    /**
     * @hidden
     */
    isLast;
    /**
     * @hidden
     */
    isExpanded;
    /**
     * @hidden
     */
    menuTabbingService;
    /**
     * The current root filter.
     * @type {CompositeFilterDescriptor}
     */
    set filter(value) {
        this._filter = cloneFilters(value);
    }
    get filter() {
        return this._filter;
    }
    /**
     * @hidden
     */
    actionsClass = 'k-actions k-actions-stretched k-actions-horizontal';
    get childFilter() {
        if (!isPresent(this._childFilter)) {
            this._childFilter = {
                filters: filtersByField(this.filter, (this.column || {}).field),
                logic: parentLogicOfDefault(this.filter, (this.column || {}).field)
            };
        }
        return this._childFilter;
    }
    resetButton;
    _childFilter;
    subscription;
    _templateContext = {};
    _filter;
    checkboxFilter;
    constructor(parentService, childService, ctx, cd, menuTabbingService, adaptiveGridService) {
        this.parentService = parentService;
        this.childService = childService;
        this.ctx = ctx;
        this.cd = cd;
        this.adaptiveGridService = adaptiveGridService;
        this.menuTabbingService = menuTabbingService;
        this.adaptiveGridService.filterMenuContainer = this;
    }
    ngOnInit() {
        this.subscription = this.childService.changes.subscribe(filter => this._childFilter = filter);
        this.subscription.add(this.ctx.localization.changes.subscribe(() => this.cd.markForCheck()));
    }
    ngAfterViewChecked() {
        if (!this.menuTabbingService.isColumnMenu || (this.isLast && this.isExpanded)) {
            this.menuTabbingService.lastFocusable = this.resetButton?.nativeElement;
        }
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        this.menuTabbingService.lastFocusable = undefined;
    }
    get disabled() {
        return this.isMultiFilter ? this.areFiltersEqual : !this.childFilter.filters.some(validFilters);
    }
    get templateContext() {
        this._templateContext.column = this.column;
        this._templateContext.filter = this.childFilter;
        this._templateContext.filterService = this.childService;
        this._templateContext["$implicit"] = this.childFilter;
        return this._templateContext;
    }
    get hasTemplate() {
        return isPresent(this.column) && isPresent(this.column.filterMenuTemplateRef);
    }
    submit() {
        if (this.isMultiFilter) {
            this.parentService.filter(this.checkboxFilter);
        }
        else {
            const filter = trimFilters(this.childFilter);
            if (filter.filters.length) {
                const root = this.filter || {
                    filters: [],
                    logic: "and"
                };
                removeFilter(root, this.column.field);
                root.filters.push(filter);
                this.parentService.filter(root);
            }
        }
        this.close.emit();
        return false;
    }
    reset() {
        const root = this.filter || {
            filters: [],
            logic: "and"
        };
        removeFilter(root, this.column.field);
        this.parentService.filter(root);
        this.close.emit();
    }
    resetChildFilters() {
        this._childFilter = null;
    }
    onTab(e, buttonType) {
        if (this.menuTabbingService.firstFocusable && (!this.menuTabbingService.isColumnMenu || this.isLast)) {
            e.preventDefault();
            if (buttonType === 'reset') {
                this.menuTabbingService.firstFocusable.focus();
            }
            else {
                this.disabled ? this.menuTabbingService.firstFocusable.focus() : this.resetButton.nativeElement.focus();
            }
        }
    }
    onCheckboxFilterChange(filter) {
        this.checkboxFilter = filter;
    }
    getButtonIcon(buttonType, iconType) {
        if (!this.isMultiFilter) {
            return;
        }
        const icons = {
            filter: {
                icon: 'filter',
                svgIcon: filterIcon
            },
            reset: {
                icon: 'filter-clear',
                svgIcon: filterClearIcon
            }
        };
        return icons[buttonType]?.[iconType];
    }
    get clearText() {
        return this.ctx.localization.get("filterClearButton");
    }
    get filterText() {
        return this.ctx.localization.get("filterFilterButton");
    }
    get isMultiFilter() {
        if (!isPresent(this.column?.filterVariant)) {
            return false;
        }
        const filterVariant = this.column?.filterVariant;
        return isPresent(filterVariant) && (filterVariant === 'multiCheckbox' || typeof filterVariant === 'object' && filterVariant.variant === 'multiCheckbox');
    }
    get areFiltersEqual() {
        const checkboxFilter = this.checkboxFilter;
        const gridFilter = this.filter;
        const isComposite = (f) => !!f && Array.isArray(f.filters);
        // Treat undefined and "empty (no inner filters)" as equivalent
        const isEmptyComposite = (f) => isComposite(f) && f.filters.length === 0;
        if (!checkboxFilter && !gridFilter) {
            return true;
        }
        if ((!checkboxFilter && isEmptyComposite(gridFilter)) || (!gridFilter && isEmptyComposite(checkboxFilter))) {
            return true;
        }
        if (!checkboxFilter || !gridFilter) {
            return false;
        }
        const eq = (x, y) => {
            const xIsComp = isComposite(x);
            const yIsComp = isComposite(y);
            if (xIsComp !== yIsComp) {
                return false;
            }
            if (xIsComp) {
                const xLogic = x.logic || 'and';
                const yLogic = y.logic || 'and';
                if (xLogic !== yLogic) {
                    return false;
                }
                if (x.filters.length !== y.filters.length) {
                    return false;
                }
                for (let i = 0; i < x.filters.length; i++) {
                    if (!eq(x.filters[i], y.filters[i])) {
                        return false;
                    }
                }
                return true;
            }
            return areObjectsEqual(x, y);
        };
        return eq(checkboxFilter, gridFilter);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FilterMenuContainerComponent, deps: [{ token: FilterService, skipSelf: true }, { token: FilterService }, { token: ContextService }, { token: i0.ChangeDetectorRef }, { token: MenuTabbingService }, { token: AdaptiveGridService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: FilterMenuContainerComponent, isStandalone: true, selector: "kendo-grid-filter-menu-container", inputs: { column: "column", isLast: "isLast", isExpanded: "isExpanded", menuTabbingService: "menuTabbingService", filter: "filter", actionsClass: "actionsClass" }, outputs: { close: "close" }, providers: [
            FilterService,
            MenuTabbingService
        ], viewQueries: [{ propertyName: "resetButton", first: true, predicate: ["resetButton"], descendants: true }], ngImport: i0, template: `
        <form (submit)="submit()" (reset)="reset()"
          class="k-filter-menu"
          [ngClass]="{'k-popup k-group k-reset': isMultiFilter && !ctx.grid?.isActionSheetExpanded}">
          <div class="k-filter-menu-container">
            @switch (hasTemplate) {
              @case (false) {
                @if (!isMultiFilter) {
                  <ng-container
                    kendoFilterMenuHost
                    [filterService]="childService"
                    [column]="column"
                    [filter]="childFilter"
                    [menuTabbingService]="menuTabbingService">
                  </ng-container>
                } @else {
                  <kendo-grid-multicheckbox-filter style="display: contents;" [column]="column" (filterChange)="onCheckboxFilterChange($event)"></kendo-grid-multicheckbox-filter>
                }
              }
              @case (true) {
                @if (column.filterMenuTemplateRef) {
                  <ng-template
                    [ngTemplateOutlet]="column.filterMenuTemplateRef"
                    [ngTemplateOutletContext]="templateContext"
                    >
                  </ng-template>
                }
              }
            }
            @if (!ctx.grid?.isActionSheetExpanded) {
              <div [ngClass]="actionsClass">
                <button #filterButton kendoButton
                  themeColor="primary"
                  type="submit"
                  [ngClass]="{'k-button-rectangle': !isMultiFilter}"
                  [disabled]="disabled"
                  [icon]="getButtonIcon('filter', 'icon')"
                  [svgIcon]="getButtonIcon('filter', 'svgIcon')"
                (keydown.tab)="onTab($event, 'filter')">{{filterText}}</button>
                <button #resetButton kendoButton
                  type="reset"
                  [ngClass]="{'k-button-rectangle': !isMultiFilter}"
                  [icon]="getButtonIcon('reset', 'icon')"
                  [svgIcon]="getButtonIcon('reset', 'svgIcon')"
                (keydown.tab)="onTab($event, 'reset')">{{clearText}}</button>
              </div>
            }
          </div>
        </form>
        `, isInline: true, dependencies: [{ kind: "ngmodule", type: FormsModule }, { kind: "directive", type: i2$2.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { kind: "directive", type: i2$2.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { kind: "directive", type: i2$2.NgForm, selector: "form:not([ngNoForm]):not([formGroup]),ng-form,[ngForm]", inputs: ["ngFormOptions"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { kind: "directive", type: FilterMenuHostDirective, selector: "[kendoFilterMenuHost]", inputs: ["filterService", "menuTabbingService"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "component", type: MultiCheckboxFilterComponent, selector: "kendo-grid-multicheckbox-filter", inputs: ["column"], outputs: ["filterChange"] }, { kind: "component", type: ButtonComponent, selector: "button[kendoButton]", inputs: ["arrowIcon", "toggleable", "togglable", "selected", "tabIndex", "imageUrl", "iconClass", "icon", "disabled", "size", "rounded", "fillMode", "themeColor", "svgIcon", "primary", "look"], outputs: ["selectedChange", "click"], exportAs: ["kendoButton"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FilterMenuContainerComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        FilterService,
                        MenuTabbingService
                    ],
                    selector: 'kendo-grid-filter-menu-container',
                    template: `
        <form (submit)="submit()" (reset)="reset()"
          class="k-filter-menu"
          [ngClass]="{'k-popup k-group k-reset': isMultiFilter && !ctx.grid?.isActionSheetExpanded}">
          <div class="k-filter-menu-container">
            @switch (hasTemplate) {
              @case (false) {
                @if (!isMultiFilter) {
                  <ng-container
                    kendoFilterMenuHost
                    [filterService]="childService"
                    [column]="column"
                    [filter]="childFilter"
                    [menuTabbingService]="menuTabbingService">
                  </ng-container>
                } @else {
                  <kendo-grid-multicheckbox-filter style="display: contents;" [column]="column" (filterChange)="onCheckboxFilterChange($event)"></kendo-grid-multicheckbox-filter>
                }
              }
              @case (true) {
                @if (column.filterMenuTemplateRef) {
                  <ng-template
                    [ngTemplateOutlet]="column.filterMenuTemplateRef"
                    [ngTemplateOutletContext]="templateContext"
                    >
                  </ng-template>
                }
              }
            }
            @if (!ctx.grid?.isActionSheetExpanded) {
              <div [ngClass]="actionsClass">
                <button #filterButton kendoButton
                  themeColor="primary"
                  type="submit"
                  [ngClass]="{'k-button-rectangle': !isMultiFilter}"
                  [disabled]="disabled"
                  [icon]="getButtonIcon('filter', 'icon')"
                  [svgIcon]="getButtonIcon('filter', 'svgIcon')"
                (keydown.tab)="onTab($event, 'filter')">{{filterText}}</button>
                <button #resetButton kendoButton
                  type="reset"
                  [ngClass]="{'k-button-rectangle': !isMultiFilter}"
                  [icon]="getButtonIcon('reset', 'icon')"
                  [svgIcon]="getButtonIcon('reset', 'svgIcon')"
                (keydown.tab)="onTab($event, 'reset')">{{clearText}}</button>
              </div>
            }
          </div>
        </form>
        `,
                    standalone: true,
                    imports: [FormsModule, FilterMenuHostDirective, NgTemplateOutlet, NgClass, MultiCheckboxFilterComponent, ButtonComponent]
                }]
        }], ctorParameters: () => [{ type: FilterService, decorators: [{
                    type: SkipSelf
                }] }, { type: FilterService }, { type: ContextService }, { type: i0.ChangeDetectorRef }, { type: MenuTabbingService }, { type: AdaptiveGridService }], propDecorators: { close: [{
                type: Output
            }], column: [{
                type: Input
            }], isLast: [{
                type: Input
            }], isExpanded: [{
                type: Input
            }], menuTabbingService: [{
                type: Input
            }], filter: [{
                type: Input
            }], actionsClass: [{
                type: Input
            }], resetButton: [{
                type: ViewChild,
                args: ['resetButton', { static: false }]
            }] } });

let id$1 = 0;
const getId$1 = (gridId) => `${gridId}-filter-menu-${id$1++}`;
/**
 * @hidden
 */
class FilterMenuComponent {
    filterService;
    popupService;
    ctx;
    navigationService;
    renderer;
    cdr;
    adaptiveGridService;
    idService;
    filterIcon = filterIcon;
    /**
     * The column with which the filter is associated.
     * @type {ColumnComponent}
     */
    column;
    /**
     * The current root filter.
     * @type {CompositeFilterDescriptor}
     */
    filter;
    anchor;
    template;
    tabIndex = '-1';
    popupRef;
    popupSubs;
    constructor(filterService, popupService, ctx, navigationService, renderer, cdr, adaptiveGridService, idService) {
        this.filterService = filterService;
        this.popupService = popupService;
        this.ctx = ctx;
        this.navigationService = navigationService;
        this.renderer = renderer;
        this.cdr = cdr;
        this.adaptiveGridService = adaptiveGridService;
        this.idService = idService;
    }
    ngOnDestroy() {
        this.cleanUp();
    }
    get hasFilters() {
        return filtersByField(this.filter, (this.column || {}).field).length > 0;
    }
    /**
     * @hidden
     */
    get filterLabel() {
        const localizationMsg = this.ctx.localization.get('filterMenuTitle') || '';
        const columnName = this.column.title || this.column.field;
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
    /**
     * @hidden
     */
    get isNavigable() {
        return this.navigationService.tableEnabled;
    }
    toggle(anchor, template) {
        if (this.ctx.grid?.adaptiveMode === 'auto' && this.adaptiveGridService.windowSize !== 'large') {
            if (!this.ctx.grid.isActionSheetExpanded) {
                this.adaptiveGridService.viewType = 'filterMenu';
                this.adaptiveGridService.column = this.column;
                this.ctx.grid.adaptiveRenderer.actionSheet.toggle(true);
            }
        }
        else {
            this.popupRef = this.popupService.open(anchor, template, this.popupRef);
            // Needed as changes to 'popupRef' are not reflected
            // automatically when the Popup is closed by clicking outside the anchor
            const ariaRoot = this.isNavigable ? anchor.closest('.k-table-th') : anchor;
            if (this.popupRef) {
                this.popupSubs?.unsubscribe();
                this.popupSubs = this.popupRef.popup.instance.anchorViewportLeave.subscribe(() => {
                    this.close();
                    this.updateAria(ariaRoot);
                });
                this.popupSubs.add(() => this.popupRef.popup.instance.close.subscribe(() => {
                    this.popupRef = null;
                    this.updateAria(ariaRoot);
                }));
                const popupAriaElement = this.popupRef.popupElement.querySelector('.k-grid-filter-popup');
                if (popupAriaElement) {
                    const popupId = getId$1(this.idService?.gridId());
                    this.renderer.setAttribute(popupAriaElement, 'id', popupId);
                    this.renderer.setAttribute(popupAriaElement, 'role', 'dialog');
                    this.renderer.setAttribute(popupAriaElement, 'aria-label', this.filterLabel);
                    ariaRoot && this.renderer.setAttribute(ariaRoot, 'aria-controls', popupId);
                    ariaRoot && this.renderer.setAttribute(ariaRoot, 'aria-expanded', 'true');
                }
            }
            else {
                this.focusRoot();
            }
        }
        return false;
    }
    close() {
        this.cleanUp();
        this.focusRoot();
    }
    updateAria(ariaRoot) {
        ariaRoot && this.renderer.removeAttribute(ariaRoot, 'aria-controls');
        ariaRoot && this.renderer.setAttribute(ariaRoot, 'aria-expanded', 'false');
    }
    cleanUp() {
        this.popupService.destroy();
        this.popupRef = null;
        this.popupSubs?.unsubscribe();
        this.popupSubs = null;
        this.cdr.markForCheck();
    }
    focusRoot() {
        if (this.isNavigable) {
            this.navigationService.preventScroll = true;
            this.navigationService.focusCell(0, this.column.leafIndex);
        }
        else {
            this.anchor.nativeElement.focus({ preventScroll: true });
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FilterMenuComponent, deps: [{ token: FilterService }, { token: SinglePopupService }, { token: ContextService }, { token: NavigationService }, { token: i0.Renderer2 }, { token: i0.ChangeDetectorRef }, { token: AdaptiveGridService }, { token: IdService, optional: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: FilterMenuComponent, isStandalone: true, selector: "kendo-grid-filter-menu", inputs: { column: "column", filter: "filter", tabIndex: "tabIndex" }, viewQueries: [{ propertyName: "anchor", first: true, predicate: ["anchor"], descendants: true, static: true }, { propertyName: "template", first: true, predicate: ["template"], descendants: true, read: TemplateRef, static: true }], ngImport: i0, template: `
        <a #anchor
            class="k-grid-filter-menu k-grid-header-menu"
            [class.k-active]="hasFilters"
            [tabindex]="tabIndex"
            (click)="toggle(anchor, template)"
            (keydown.enter)="$event.stopImmediatePropagation()"
            href="#"
            [attr.title]="filterLabel"
            [attr.aria-haspopup]="isNavigable ? undefined : 'dialog'"
            [attr.aria-expanded]="isNavigable ? undefined : false">
            <kendo-icon-wrapper
                name="filter"
                [svgIcon]="filterIcon"></kendo-icon-wrapper>
        </a>
        <ng-template #template>
            <kendo-grid-filter-menu-container
                [column]="column"
                [filter]="filter"
                (close)="close()"
                (keydown.escape)="close()"
                (keydown.enter)="$event.stopImmediatePropagation()">
            </kendo-grid-filter-menu-container>
        </ng-template>
    `, isInline: true, dependencies: [{ kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "component", type: FilterMenuContainerComponent, selector: "kendo-grid-filter-menu-container", inputs: ["column", "isLast", "isExpanded", "menuTabbingService", "filter", "actionsClass"], outputs: ["close"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FilterMenuComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-filter-menu',
                    template: `
        <a #anchor
            class="k-grid-filter-menu k-grid-header-menu"
            [class.k-active]="hasFilters"
            [tabindex]="tabIndex"
            (click)="toggle(anchor, template)"
            (keydown.enter)="$event.stopImmediatePropagation()"
            href="#"
            [attr.title]="filterLabel"
            [attr.aria-haspopup]="isNavigable ? undefined : 'dialog'"
            [attr.aria-expanded]="isNavigable ? undefined : false">
            <kendo-icon-wrapper
                name="filter"
                [svgIcon]="filterIcon"></kendo-icon-wrapper>
        </a>
        <ng-template #template>
            <kendo-grid-filter-menu-container
                [column]="column"
                [filter]="filter"
                (close)="close()"
                (keydown.escape)="close()"
                (keydown.enter)="$event.stopImmediatePropagation()">
            </kendo-grid-filter-menu-container>
        </ng-template>
    `,
                    standalone: true,
                    imports: [IconWrapperComponent, FilterMenuContainerComponent],
                }]
        }], ctorParameters: () => [{ type: FilterService }, { type: SinglePopupService }, { type: ContextService }, { type: NavigationService }, { type: i0.Renderer2 }, { type: i0.ChangeDetectorRef }, { type: AdaptiveGridService }, { type: IdService, decorators: [{
                    type: Optional
                }] }], propDecorators: { column: [{
                type: Input
            }], filter: [{
                type: Input
            }], anchor: [{
                type: ViewChild,
                args: ['anchor', { static: true }]
            }], template: [{
                type: ViewChild,
                args: ['template', { static: true, read: TemplateRef }]
            }], tabIndex: [{
                type: Input
            }] } });

const EMPTY_FILTER_OPERATORS = ['isnull', 'isnotnull', 'isempty', 'isnotempty'];
/**
 * @hidden
 */
class FilterCellWrapperComponent extends FilterInputWrapperComponent {
    get hostClasses() {
        return true;
    }
    get overrideBaseClasses() {
        return false;
    }
    showOperators = true;
    get showButton() {
        const filter = this.currentFilter;
        return isPresent(filter) && (!isNullOrEmptyString(filter.value) ||
            EMPTY_FILTER_OPERATORS.indexOf(String(filter.operator)) >= 0);
    }
    constructor(filterService) {
        super(filterService);
    }
    filterChange(filter) {
        this.applyFilter(filter);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FilterCellWrapperComponent, deps: [{ token: FilterService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: FilterCellWrapperComponent, isStandalone: true, selector: "kendo-grid-filter-wrapper-cell", inputs: { showOperators: "showOperators" }, host: { properties: { "class.k-filtercell-wrapper": "this.hostClasses", "class.k-filtercell": "this.overrideBaseClasses" } }, usesInheritance: true, ngImport: i0, template: `
        <ng-content></ng-content>
        <kendo-grid-filter-cell-operators
            [showOperators]="showOperators"
            [column]="column"
            [operators]="operators"
            (clear)="onClear()"
            [showButton]="showButton"
            [(value)]="currentOperator">
        </kendo-grid-filter-cell-operators>
    `, isInline: true, dependencies: [{ kind: "component", type: FilterCellOperatorsComponent, selector: "kendo-grid-filter-cell-operators", inputs: ["operators", "showButton", "showOperators", "value", "column"], outputs: ["valueChange", "clear"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FilterCellWrapperComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-filter-wrapper-cell',
                    template: `
        <ng-content></ng-content>
        <kendo-grid-filter-cell-operators
            [showOperators]="showOperators"
            [column]="column"
            [operators]="operators"
            (clear)="onClear()"
            [showButton]="showButton"
            [(value)]="currentOperator">
        </kendo-grid-filter-cell-operators>
    `,
                    standalone: true,
                    imports: [FilterCellOperatorsComponent]
                }]
        }], ctorParameters: () => [{ type: FilterService }], propDecorators: { hostClasses: [{
                type: HostBinding,
                args: ['class.k-filtercell-wrapper']
            }], overrideBaseClasses: [{
                type: HostBinding,
                args: ['class.k-filtercell']
            }], showOperators: [{
                type: Input
            }] } });

// eslint-disable no-access-missing-member
const stringOperators = localizeOperators({
    "filterContainsOperator": "contains",
    "filterNotContainsOperator": "doesnotcontain",
    "filterEqOperator": "eq",
    "filterNotEqOperator": "neq",
    "filterStartsWithOperator": "startswith",
    "filterEndsWithOperator": "endswith",
    "filterIsNullOperator": "isnull",
    "filterIsNotNullOperator": "isnotnull",
    "filterIsEmptyOperator": "isempty",
    "filterIsNotEmptyOperator": "isnotempty"
});
/**
 * @hidden
 */
class AutoCompleteFilterCellComponent extends BaseFilterCellComponent {
    ctx;
    showOperators = true;
    column;
    data;
    set valueField(value) {
        this._valueField = value;
    }
    get valueField() {
        return this._valueField ? this._valueField : this.column.field;
    }
    get currentFilter() {
        return this.filterByField(this.column.field);
    }
    get currentOperator() {
        return this.currentFilter ? this.currentFilter.operator : "contains";
    }
    size = 'medium';
    _valueField;
    subs;
    constructor(filterService, column, ctx, sizingOptionsService) {
        super(filterService);
        this.ctx = ctx;
        this.defaultOperators = stringOperators(this.ctx.localization);
        this.column = column;
        this.subs = sizingOptionsService.changes.subscribe(size => this.size = size);
    }
    ngOnDestroy() {
        if (this.subs) {
            this.subs.unsubscribe();
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AutoCompleteFilterCellComponent, deps: [{ token: FilterService }, { token: ColumnComponent }, { token: ContextService }, { token: SizingOptionsService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: AutoCompleteFilterCellComponent, isStandalone: true, selector: "kendo-grid-autocomplete-filter-cell", inputs: { showOperators: "showOperators", column: "column", data: "data", valueField: "valueField" }, usesInheritance: true, ngImport: i0, template: `
        <kendo-grid-filter-wrapper-cell
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [showOperators]="showOperators">
            <kendo-autocomplete
                kendoFilterInput
                [data]="data"
                [size]="size"
                [valueField]="valueField"
                [value]="currentFilter?.value">
            </kendo-autocomplete>
        </kendo-grid-filter-wrapper-cell>
    `, isInline: true, dependencies: [{ kind: "component", type: FilterCellWrapperComponent, selector: "kendo-grid-filter-wrapper-cell", inputs: ["showOperators"] }, { kind: "component", type: AutoCompleteComponent, selector: "kendo-autocomplete", inputs: ["highlightFirst", "showStickyHeader", "focusableId", "data", "value", "valueField", "placeholder", "adaptiveMode", "adaptiveTitle", "adaptiveSubtitle", "popupSettings", "listHeight", "loading", "clearButton", "suggest", "disabled", "itemDisabled", "readonly", "tabindex", "tabIndex", "filterable", "virtual", "size", "rounded", "fillMode", "inputAttributes"], outputs: ["valueChange", "filterChange", "open", "opened", "close", "closed", "focus", "blur", "inputFocus", "inputBlur"], exportAs: ["kendoAutoComplete"] }, { kind: "directive", type: FilterInputDirective, selector: "[kendoFilterInput]", inputs: ["filterDelay", "columnLabel", "value"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AutoCompleteFilterCellComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-autocomplete-filter-cell',
                    template: `
        <kendo-grid-filter-wrapper-cell
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [showOperators]="showOperators">
            <kendo-autocomplete
                kendoFilterInput
                [data]="data"
                [size]="size"
                [valueField]="valueField"
                [value]="currentFilter?.value">
            </kendo-autocomplete>
        </kendo-grid-filter-wrapper-cell>
    `,
                    standalone: true,
                    imports: [FilterCellWrapperComponent, AutoCompleteComponent, FilterInputDirective]
                }]
        }], ctorParameters: () => [{ type: FilterService }, { type: ColumnComponent }, { type: ContextService }, { type: SizingOptionsService }], propDecorators: { showOperators: [{
                type: Input
            }], column: [{
                type: Input
            }], data: [{
                type: Input
            }], valueField: [{
                type: Input
            }] } });

/**
 * Represents a filter-cell component for boolean columns.
 * See the article about the [built-in filter components](slug:filter_row#toc-built-in-filter-row-components).
 *
 * @example
 * ```html
 * <kendo-grid-column field="Discontinued">
 *   <ng-template kendoGridFilterCellTemplate let-filter let-column="column">
 *     <kendo-grid-boolean-filter-cell
 *       [column]="column"
 *       [filter]="filter">
 *     </kendo-grid-boolean-filter-cell>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 */
class BooleanFilterCellComponent extends BooleanFilterComponent {
    cd;
    /**
     * @hidden
     */
    size = 'medium';
    subs;
    constructor(filterService, ctx, cd, sizingService) {
        super(filterService, ctx);
        this.cd = cd;
        this.subs = sizingService.changes.subscribe((size) => this.size = size);
    }
    ngOnDestroy() {
        this.subs && this.subs.unsubscribe();
    }
    localizationChange() {
        super.localizationChange();
        this.cd.markForCheck();
    }
    /**
     * @hidden
     */
    get columnLabel() {
        const localizationMsg = this.ctx.localization.get('booleanFilterCellLabel') || '';
        const columnName = this.column.title || this.column.field;
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: BooleanFilterCellComponent, deps: [{ token: FilterService }, { token: ContextService }, { token: i0.ChangeDetectorRef }, { token: SizingOptionsService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: BooleanFilterCellComponent, isStandalone: true, selector: "kendo-grid-boolean-filter-cell", usesInheritance: true, ngImport: i0, template: `
        <kendo-grid-filter-wrapper-cell
            [column]="column"
            [filter]="filter"
            [showOperators]="false"
            [defaultOperator]="operator">
            <kendo-dropdownlist
                kendoFilterInput
                kendoGridFocusable
                [size]="size"
                [columnLabel]="columnLabel"
                [defaultItem]="defaultItem"
                [data]="items"
                textField="text"
                valueField="value"
                [popupSettings]="{ width: 'auto' }"
                [valuePrimitive]="true"
                [value]="currentFilter?.value">
            </kendo-dropdownlist>
        </kendo-grid-filter-wrapper-cell>
    `, isInline: true, dependencies: [{ kind: "component", type: FilterCellWrapperComponent, selector: "kendo-grid-filter-wrapper-cell", inputs: ["showOperators"] }, { kind: "component", type: DropDownListComponent, selector: "kendo-dropdownlist", inputs: ["customIconClass", "showStickyHeader", "icon", "svgIcon", "loading", "data", "value", "textField", "valueField", "adaptiveMode", "adaptiveTitle", "adaptiveSubtitle", "popupSettings", "listHeight", "defaultItem", "disabled", "itemDisabled", "readonly", "filterable", "virtual", "ignoreCase", "delay", "valuePrimitive", "tabindex", "tabIndex", "size", "rounded", "fillMode", "leftRightArrowsNavigation", "id"], outputs: ["valueChange", "filterChange", "selectionChange", "open", "opened", "close", "closed", "focus", "blur"], exportAs: ["kendoDropDownList"] }, { kind: "directive", type: FilterInputDirective, selector: "[kendoFilterInput]", inputs: ["filterDelay", "columnLabel", "value"] }, { kind: "directive", type: FocusableDirective, selector: "[kendoGridFocusable],\n        [kendoGridEditCommand],\n        [kendoGridRemoveCommand],\n        [kendoGridSaveCommand],\n        [kendoGridCancelCommand],\n        [kendoGridSelectionCheckbox]\n    ", inputs: ["kendoGridFocusable"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: BooleanFilterCellComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-boolean-filter-cell',
                    template: `
        <kendo-grid-filter-wrapper-cell
            [column]="column"
            [filter]="filter"
            [showOperators]="false"
            [defaultOperator]="operator">
            <kendo-dropdownlist
                kendoFilterInput
                kendoGridFocusable
                [size]="size"
                [columnLabel]="columnLabel"
                [defaultItem]="defaultItem"
                [data]="items"
                textField="text"
                valueField="value"
                [popupSettings]="{ width: 'auto' }"
                [valuePrimitive]="true"
                [value]="currentFilter?.value">
            </kendo-dropdownlist>
        </kendo-grid-filter-wrapper-cell>
    `,
                    standalone: true,
                    imports: [FilterCellWrapperComponent, DropDownListComponent, FilterInputDirective, FocusableDirective]
                }]
        }], ctorParameters: () => [{ type: FilterService }, { type: ContextService }, { type: i0.ChangeDetectorRef }, { type: SizingOptionsService }] });

/**
 * Represents a [DatePicker](slug:overview_datepicker) cell component for filtering of date columns.
 * See the article about the [built-in filter components](slug:filter_row#toc-built-in-filter-row-components).
 *
 * @example
 *
 * ```html
 * <kendo-grid-column field="FirstOrderedOn">
 *   <ng-template kendoGridFilterCellTemplate let-filter let-column="column">
 *     <kendo-grid-date-filter-cell
 *       [column]="column"
 *       [filter]="filter">
 *     </kendo-grid-date-filter-cell>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 *
 * @remarks
 * Supported children components are: {@link EqualFilterOperatorComponent}, {@link NotEqualFilterOperatorComponent}, {@link AfterEqFilterOperatorComponent}, {@link AfterFilterOperatorComponent}, {@link BeforeEqFilterOperatorComponent}, {@link BeforeFilterOperatorComponent}, {@link IsNullFilterOperatorComponent}, {@link IsNotNullFilterOperatorComponent}.
 */
class DateFilterCellComponent extends DateFilterComponent {
    ctx;
    /**
     * Determines if the drop-down filter operators are displayed.
     * @type {boolean}
     * @default true
     */
    showOperators = true;
    subs;
    constructor(filterService, ctx, sizingService) {
        super(filterService, ctx);
        this.ctx = ctx;
        this.subs = sizingService.changes.subscribe((size) => this.size = size);
    }
    ngOnDestroy() {
        this.subs && this.subs.unsubscribe();
    }
    /**
     * @hidden
     */
    messageFor(key) {
        return this.ctx.localization.get(key);
    }
    /**
     * @hidden
     */
    get columnLabel() {
        const localizationMsg = this.ctx.localization.get('filterInputLabel') || '';
        const columnName = this.column.title || this.column.field;
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DateFilterCellComponent, deps: [{ token: FilterService }, { token: ContextService }, { token: SizingOptionsService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: DateFilterCellComponent, isStandalone: true, selector: "kendo-grid-date-filter-cell", inputs: { showOperators: "showOperators" }, usesInheritance: true, ngImport: i0, template: `
        <kendo-grid-filter-wrapper-cell
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [showOperators]="showOperators"
        >
            <kendo-datepicker
                kendoFilterInput
                kendoGridFocusable
                [columnLabel]="columnLabel"
                [value]="currentFilter?.value"
                [format]="format"
                [size]="size"
                [formatPlaceholder]="formatPlaceholder"
                [placeholder]="placeholder"
                [activeView]="activeView"
                [bottomView]="bottomView"
                [topView]="topView"
                [min]="min"
                [max]="max"
                [weekNumber]="weekNumber">
                <kendo-datepicker-messages
                    [toggle]="messageFor('filterDateToggle')"
                    [today]="messageFor('filterDateToday')"
                ></kendo-datepicker-messages>
            </kendo-datepicker>
        </kendo-grid-filter-wrapper-cell>
    `, isInline: true, dependencies: [{ kind: "component", type: FilterCellWrapperComponent, selector: "kendo-grid-filter-wrapper-cell", inputs: ["showOperators"] }, { kind: "component", type: DatePickerComponent, selector: "kendo-datepicker", inputs: ["focusableId", "cellTemplate", "clearButton", "inputAttributes", "monthCellTemplate", "yearCellTemplate", "decadeCellTemplate", "centuryCellTemplate", "weekNumberTemplate", "headerTitleTemplate", "headerTemplate", "footerTemplate", "footer", "navigationItemTemplate", "weekDaysFormat", "showOtherMonthDays", "activeView", "bottomView", "topView", "calendarType", "animateCalendarNavigation", "disabled", "readonly", "readOnlyInput", "popupSettings", "navigation", "min", "max", "incompleteDateValidation", "autoCorrectParts", "autoSwitchParts", "autoSwitchKeys", "enableMouseWheel", "allowCaretMode", "autoFill", "focusedDate", "value", "format", "twoDigitYearMax", "formatPlaceholder", "placeholder", "tabindex", "tabIndex", "disabledDates", "adaptiveTitle", "adaptiveSubtitle", "rangeValidation", "disabledDatesValidation", "weekNumber", "size", "rounded", "fillMode", "adaptiveMode"], outputs: ["valueChange", "focus", "blur", "open", "close", "escape"], exportAs: ["kendo-datepicker"] }, { kind: "directive", type: FilterInputDirective, selector: "[kendoFilterInput]", inputs: ["filterDelay", "columnLabel", "value"] }, { kind: "directive", type: FocusableDirective, selector: "[kendoGridFocusable],\n        [kendoGridEditCommand],\n        [kendoGridRemoveCommand],\n        [kendoGridSaveCommand],\n        [kendoGridCancelCommand],\n        [kendoGridSelectionCheckbox]\n    ", inputs: ["kendoGridFocusable"] }, { kind: "component", type: DatePickerCustomMessagesComponent, selector: "kendo-datepicker-messages" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DateFilterCellComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-date-filter-cell',
                    template: `
        <kendo-grid-filter-wrapper-cell
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [showOperators]="showOperators"
        >
            <kendo-datepicker
                kendoFilterInput
                kendoGridFocusable
                [columnLabel]="columnLabel"
                [value]="currentFilter?.value"
                [format]="format"
                [size]="size"
                [formatPlaceholder]="formatPlaceholder"
                [placeholder]="placeholder"
                [activeView]="activeView"
                [bottomView]="bottomView"
                [topView]="topView"
                [min]="min"
                [max]="max"
                [weekNumber]="weekNumber">
                <kendo-datepicker-messages
                    [toggle]="messageFor('filterDateToggle')"
                    [today]="messageFor('filterDateToday')"
                ></kendo-datepicker-messages>
            </kendo-datepicker>
        </kendo-grid-filter-wrapper-cell>
    `,
                    standalone: true,
                    imports: [FilterCellWrapperComponent, DatePickerComponent, FilterInputDirective, FocusableDirective, DatePickerCustomMessagesComponent]
                }]
        }], ctorParameters: () => [{ type: FilterService }, { type: ContextService }, { type: SizingOptionsService }], propDecorators: { showOperators: [{
                type: Input
            }] } });

/**
 * Represents a filter cell component for filtering of string columns.
 * See the article about the [built-in filter components](slug:filter_row#toc-built-in-filter-row-components).
 *
 * @example
 * ```html
 * <kendo-grid-column field="ProductName" title="Product Name">
 *   <ng-template kendoGridFilterCellTemplate let-filter let-column="column">
 *     <kendo-grid-string-filter-cell
 *       [column]="column"
 *       [filter]="filter">
 *     </kendo-grid-string-filter-cell>
 *  </ng-template>
 * </kendo-grid-column>
 * ```
 * @remarks
 * Supported children components are: {@link EqualFilterOperatorComponent}, {@link NotEqualFilterOperatorComponent}, {@link ContainsFilterOperatorComponent}, {@link DoesNotContainFilterOperatorComponent}, {@link StartsWithFilterOperatorComponent}, {@link EndsWithFilterOperatorComponent}, {@link IsNullFilterOperatorComponent}, {@link IsNotNullFilterOperatorComponent}, {@link IsEmptyFilterOperatorComponent}, {@link IsNotEmptyFilterOperatorComponent}.
 */
class StringFilterCellComponent extends StringFilterComponent {
    /**
     * Sets the delay time in milliseconds before the filter value is submitted.
     * A value of `0` means no delay.
     * @type {number}
     * @default 500
     */
    filterDelay = 500;
    /**
     * Determines if the drop-down filter operators are displayed.
     * @type {boolean}
     * @default true
     */
    showOperators = true;
    /**
     * The placeholder text for the filter input.
     * @type {string}
     */
    placeholder;
    subs;
    constructor(filterService, ctx, sizingService) {
        super(filterService, ctx);
        this.subs = sizingService.changes.subscribe((size) => this.size = size);
    }
    ngOnDestroy() {
        if (this.subs) {
            this.subs.unsubscribe();
        }
    }
    /**
     * @hidden
     */
    get columnLabel() {
        const localizationMsg = this.ctx.localization.get('filterInputLabel') || '';
        const columnName = this.column.title || this.column.field;
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: StringFilterCellComponent, deps: [{ token: FilterService }, { token: ContextService }, { token: SizingOptionsService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: StringFilterCellComponent, isStandalone: true, selector: "kendo-grid-string-filter-cell", inputs: { filterDelay: "filterDelay", showOperators: "showOperators", placeholder: "placeholder" }, usesInheritance: true, ngImport: i0, template: `
        <kendo-grid-filter-wrapper-cell
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [showOperators]="showOperators">
            <kendo-textbox
                [size]="size"
                kendoGridFocusable
                kendoFilterInput
                [columnLabel]="columnLabel"
                [filterDelay]="filterDelay"
                [placeholder]="placeholder"
                [ngModel]="currentFilter?.value ?? null"
            ></kendo-textbox>
        </kendo-grid-filter-wrapper-cell>
    `, isInline: true, dependencies: [{ kind: "component", type: FilterCellWrapperComponent, selector: "kendo-grid-filter-wrapper-cell", inputs: ["showOperators"] }, { kind: "component", type: TextBoxComponent, selector: "kendo-textbox", inputs: ["focusableId", "title", "type", "disabled", "readonly", "tabindex", "value", "selectOnFocus", "showSuccessIcon", "showErrorIcon", "clearButton", "successIcon", "successSvgIcon", "errorIcon", "errorSvgIcon", "clearButtonIcon", "clearButtonSvgIcon", "size", "rounded", "fillMode", "tabIndex", "placeholder", "maxlength", "inputAttributes"], outputs: ["valueChange", "inputFocus", "inputBlur", "focus", "blur"], exportAs: ["kendoTextBox"] }, { kind: "directive", type: FocusableDirective, selector: "[kendoGridFocusable],\n        [kendoGridEditCommand],\n        [kendoGridRemoveCommand],\n        [kendoGridSaveCommand],\n        [kendoGridCancelCommand],\n        [kendoGridSelectionCheckbox]\n    ", inputs: ["kendoGridFocusable"] }, { kind: "directive", type: FilterInputDirective, selector: "[kendoFilterInput]", inputs: ["filterDelay", "columnLabel", "value"] }, { kind: "ngmodule", type: FormsModule }, { kind: "directive", type: i2$2.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$2.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: StringFilterCellComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-string-filter-cell',
                    template: `
        <kendo-grid-filter-wrapper-cell
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [showOperators]="showOperators">
            <kendo-textbox
                [size]="size"
                kendoGridFocusable
                kendoFilterInput
                [columnLabel]="columnLabel"
                [filterDelay]="filterDelay"
                [placeholder]="placeholder"
                [ngModel]="currentFilter?.value ?? null"
            ></kendo-textbox>
        </kendo-grid-filter-wrapper-cell>
    `,
                    standalone: true,
                    imports: [FilterCellWrapperComponent, TextBoxComponent, FocusableDirective, FilterInputDirective, FormsModule]
                }]
        }], ctorParameters: () => [{ type: FilterService }, { type: ContextService }, { type: SizingOptionsService }], propDecorators: { filterDelay: [{
                type: Input
            }], showOperators: [{
                type: Input
            }], placeholder: [{
                type: Input
            }] } });

/**
 * Represents a filter cell component for filtering of numeric columns.
 * See the article about the [built-in filter components](slug:filter_row#toc-built-in-filter-row-components).
 *
 * @example
 * ```html
 * <kendo-grid-column field="UnitPrice">
 *   <ng-template kendoGridFilterCellTemplate let-filter let-column="column">
 *     <kendo-grid-numeric-filter-cell
 *       [column]="column"
 *       [filter]="filter">
 *     </kendo-grid-numeric-filter-cell>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 * @remarks
 * Supported children components are: {@link EqualFilterOperatorComponent}, {@link NotEqualFilterOperatorComponent}, {@link GreaterFilterOperatorComponent}, {@link GreaterOrEqualToFilterOperatorComponent}, {@link LessFilterOperatorComponent}, {@link LessOrEqualToFilterOperatorComponent}, {@link IsNullFilterOperatorComponent}, {@link IsNotNullFilterOperatorComponent}.
 */
class NumericFilterCellComponent extends NumericFilterComponent {
    ctx;
    /**
     * Sets the delay time in milliseconds before the filter value is submitted.
     * A value of `0` means no delay.
     * @type {number}
     * @default 500
     */
    filterDelay = 500;
    /**
     * Determines if the drop-down filter operators are displayed.
     * @type {boolean}
     * @default true
     */
    showOperators = true;
    /**
     * The placeholder text for the filter input.
     * @type {string}
     */
    placeholder;
    subs;
    constructor(filterService, ctx, sizingService) {
        super(filterService, ctx);
        this.ctx = ctx;
        this.subs = sizingService.changes.subscribe((size) => this.size = size);
    }
    ngOnDestroy() {
        this.subs && this.subs.unsubscribe();
    }
    /**
     * @hidden
     */
    messageFor(key) {
        return this.ctx.localization.get(key);
    }
    /**
     * @hidden
     */
    get columnLabel() {
        const localizationMsg = this.ctx.localization.get('filterInputLabel') || '';
        const columnName = this.column.title || this.column.field;
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: NumericFilterCellComponent, deps: [{ token: FilterService }, { token: ContextService }, { token: SizingOptionsService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: NumericFilterCellComponent, isStandalone: true, selector: "kendo-grid-numeric-filter-cell", inputs: { filterDelay: "filterDelay", showOperators: "showOperators", placeholder: "placeholder" }, usesInheritance: true, ngImport: i0, template: `
        <kendo-grid-filter-wrapper-cell
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [showOperators]="showOperators"
        >
            <kendo-numerictextbox
                kendoGridFocusable
                kendoFilterInput
                [columnLabel]="columnLabel"
                [filterDelay]="filterDelay"
                [autoCorrect]="true"
                [value]="currentFilter?.value"
                [format]="format"
                [decimals]="decimals"
                [spinners]="spinners"
                [min]="min"
                [max]="max"
                [size]="size"
                [step]="step"
                [placeholder]="placeholder">
                <kendo-numerictextbox-messages
                    [increment]="messageFor('filterNumericIncrement')"
                    [decrement]="messageFor('filterNumericDecrement')"
                ></kendo-numerictextbox-messages>
            </kendo-numerictextbox>
        </kendo-grid-filter-wrapper-cell>
    `, isInline: true, dependencies: [{ kind: "component", type: FilterCellWrapperComponent, selector: "kendo-grid-filter-wrapper-cell", inputs: ["showOperators"] }, { kind: "component", type: NumericTextBoxComponent, selector: "kendo-numerictextbox", inputs: ["focusableId", "disabled", "readonly", "title", "autoCorrect", "format", "max", "min", "decimals", "placeholder", "step", "spinners", "rangeValidation", "tabindex", "tabIndex", "changeValueOnScroll", "selectOnFocus", "value", "maxlength", "size", "rounded", "fillMode", "inputAttributes"], outputs: ["valueChange", "focus", "blur", "inputFocus", "inputBlur"], exportAs: ["kendoNumericTextBox"] }, { kind: "directive", type: FocusableDirective, selector: "[kendoGridFocusable],\n        [kendoGridEditCommand],\n        [kendoGridRemoveCommand],\n        [kendoGridSaveCommand],\n        [kendoGridCancelCommand],\n        [kendoGridSelectionCheckbox]\n    ", inputs: ["kendoGridFocusable"] }, { kind: "directive", type: FilterInputDirective, selector: "[kendoFilterInput]", inputs: ["filterDelay", "columnLabel", "value"] }, { kind: "component", type: NumericTextBoxCustomMessagesComponent, selector: "kendo-numerictextbox-messages" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: NumericFilterCellComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-numeric-filter-cell',
                    template: `
        <kendo-grid-filter-wrapper-cell
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [showOperators]="showOperators"
        >
            <kendo-numerictextbox
                kendoGridFocusable
                kendoFilterInput
                [columnLabel]="columnLabel"
                [filterDelay]="filterDelay"
                [autoCorrect]="true"
                [value]="currentFilter?.value"
                [format]="format"
                [decimals]="decimals"
                [spinners]="spinners"
                [min]="min"
                [max]="max"
                [size]="size"
                [step]="step"
                [placeholder]="placeholder">
                <kendo-numerictextbox-messages
                    [increment]="messageFor('filterNumericIncrement')"
                    [decrement]="messageFor('filterNumericDecrement')"
                ></kendo-numerictextbox-messages>
            </kendo-numerictextbox>
        </kendo-grid-filter-wrapper-cell>
    `,
                    standalone: true,
                    imports: [FilterCellWrapperComponent, NumericTextBoxComponent, FocusableDirective, FilterInputDirective, NumericTextBoxCustomMessagesComponent]
                }]
        }], ctorParameters: () => [{ type: FilterService }, { type: ContextService }, { type: SizingOptionsService }], propDecorators: { filterDelay: [{
                type: Input
            }], showOperators: [{
                type: Input
            }], placeholder: [{
                type: Input
            }] } });

/**
 * @hidden
 *
 * > List the following components in the GridModule as `entryComponents`.
 */
const filterComponentFactory = (type) => ({
    "boolean": BooleanFilterCellComponent,
    "date": DateFilterCellComponent,
    "numeric": NumericFilterCellComponent,
    "text": StringFilterCellComponent
}[type]);

/**
 * @hidden
 */
class FilterCellHostDirective extends FilterHostDirective {
    constructor(host) {
        super(host);
    }
    componentType() {
        if (!isNullOrEmptyString(this.column.filter)) {
            return filterComponentFactory(this.column.filter);
        }
        return StringFilterCellComponent;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FilterCellHostDirective, deps: [{ token: i0.ViewContainerRef }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: FilterCellHostDirective, isStandalone: true, selector: "[kendoFilterCellHost]", usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FilterCellHostDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoFilterCellHost]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.ViewContainerRef }] });

/**
 * @hidden
 */
class FilterCellComponent {
    hostRole = 'gridcell';
    column;
    get filter() {
        return this._filter;
    }
    set filter(value) {
        this._filter = cloneFilters(value);
    }
    size = 'medium';
    _templateContext = {};
    _filter;
    get templateContext() {
        this._templateContext.column = this.column;
        this._templateContext.filter = this.filter;
        this._templateContext['$implicit'] = this.filter;
        return this._templateContext;
    }
    get hasTemplate() {
        return isPresent(this.column.filterCellTemplateRef);
    }
    get isFilterable() {
        return isPresent(this.column) && !isNullOrEmptyString(this.column.field) && this.column.filterable;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FilterCellComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: FilterCellComponent, isStandalone: true, selector: "[kendoGridFilterCell]", inputs: { column: "column", filter: "filter", size: "size" }, host: { properties: { "attr.role": "this.hostRole" } }, ngImport: i0, template: `
        @if (isFilterable) {
          @switch (hasTemplate) {
            @case (false) {
              <ng-container kendoFilterCellHost [column]="column" [filter]="filter"></ng-container>
            }
            @case (true) {
              @if (column.filterCellTemplateRef) {
                <ng-template
                  [ngTemplateOutlet]="column.filterCellTemplateRef"
                  [ngTemplateOutletContext]="templateContext">
                </ng-template>
              }
            }
          }
        }
        `, isInline: true, dependencies: [{ kind: "directive", type: FilterCellHostDirective, selector: "[kendoFilterCellHost]" }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FilterCellComponent, decorators: [{
            type: Component,
            args: [{
                    selector: '[kendoGridFilterCell]',
                    template: `
        @if (isFilterable) {
          @switch (hasTemplate) {
            @case (false) {
              <ng-container kendoFilterCellHost [column]="column" [filter]="filter"></ng-container>
            }
            @case (true) {
              @if (column.filterCellTemplateRef) {
                <ng-template
                  [ngTemplateOutlet]="column.filterCellTemplateRef"
                  [ngTemplateOutletContext]="templateContext">
                </ng-template>
              }
            }
          }
        }
        `,
                    standalone: true,
                    imports: [FilterCellHostDirective, NgTemplateOutlet]
                }]
        }], propDecorators: { hostRole: [{
                type: HostBinding,
                args: ['attr.role']
            }], column: [{
                type: Input
            }], filter: [{
                type: Input
            }], size: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class FilterRowComponent {
    ctx;
    columnInfoService;
    columns = [];
    filter;
    groups = [];
    detailTemplate;
    logicalRowIndex;
    lockedColumnsCount;
    filterRowClass = true;
    constructor(ctx, columnInfoService) {
        this.ctx = ctx;
        this.columnInfoService = columnInfoService;
    }
    addStickyStyles(column) {
        const sticky = column.sticky ? this.columnInfoService.stickyColumnsStyles(column) : null;
        return { ...sticky, ...column.filterStyle };
    }
    filterLabel(column) {
        const localizationMsg = this.ctx.localization.get('filterInputLabel') || '';
        const columnName = column.title || column.field;
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
    getLogicalColIndex(columnIndex) {
        const colIndex = this.lockedColumnsCount + columnIndex;
        return this.detailTemplate?.templateRef ? colIndex + 1 : colIndex;
    }
    get isStacked() {
        return this.ctx.grid?.isStacked;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FilterRowComponent, deps: [{ token: ContextService }, { token: ColumnInfoService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: FilterRowComponent, isStandalone: true, selector: "[kendoGridFilterRow]", inputs: { columns: "columns", filter: "filter", groups: "groups", detailTemplate: "detailTemplate", logicalRowIndex: "logicalRowIndex", lockedColumnsCount: "lockedColumnsCount" }, host: { properties: { "class.k-filter-row": "this.filterRowClass" } }, ngImport: i0, template: `
        @for (g of groups; track g) {
          <td
            class="k-table-td k-group-cell k-table-group-td"
            role="presentation">
          </td>
        }
        @if (detailTemplate?.templateRef && !isStacked) {
          <td
            class="k-table-td k-hierarchy-cell"
            role="presentation">
          </td>
        }
        @for (column of columns; track column; let columnIndex = $index) {
          <td
            class="k-table-td"
            [class.k-grid-header-sticky]="column.sticky"
            [ngStyle]="addStickyStyles(column)"
            [ngClass]="column.filterClass"
            [attr.aria-label]="filterLabel($any(column))"
            kendoGridFilterCell
            [column]="$any(column)"
            [filter]="filter"
            kendoGridLogicalCell
            [logicalRowIndex]="logicalRowIndex"
            [logicalColIndex]="getLogicalColIndex(columnIndex)"
          ></td>
        }
        `, isInline: true, dependencies: [{ kind: "component", type: FilterCellComponent, selector: "[kendoGridFilterCell]", inputs: ["column", "filter", "size"] }, { kind: "directive", type: LogicalCellDirective, selector: "[kendoGridLogicalCell]", inputs: ["logicalColIndex", "logicalRowIndex", "logicalSlaveCell", "colIndex", "colSpan", "rowSpan", "groupItem", "dataRowIndex", "dataItem", "detailExpandCell", "headerLabelText"] }, { kind: "directive", type: NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FilterRowComponent, decorators: [{
            type: Component,
            args: [{
                    selector: '[kendoGridFilterRow]',
                    template: `
        @for (g of groups; track g) {
          <td
            class="k-table-td k-group-cell k-table-group-td"
            role="presentation">
          </td>
        }
        @if (detailTemplate?.templateRef && !isStacked) {
          <td
            class="k-table-td k-hierarchy-cell"
            role="presentation">
          </td>
        }
        @for (column of columns; track column; let columnIndex = $index) {
          <td
            class="k-table-td"
            [class.k-grid-header-sticky]="column.sticky"
            [ngStyle]="addStickyStyles(column)"
            [ngClass]="column.filterClass"
            [attr.aria-label]="filterLabel($any(column))"
            kendoGridFilterCell
            [column]="$any(column)"
            [filter]="filter"
            kendoGridLogicalCell
            [logicalRowIndex]="logicalRowIndex"
            [logicalColIndex]="getLogicalColIndex(columnIndex)"
          ></td>
        }
        `,
                    standalone: true,
                    imports: [FilterCellComponent, LogicalCellDirective, NgStyle, NgClass]
                }]
        }], ctorParameters: () => [{ type: ContextService }, { type: ColumnInfoService }], propDecorators: { columns: [{
                type: Input
            }], filter: [{
                type: Input
            }], groups: [{
                type: Input
            }], detailTemplate: [{
                type: Input
            }], logicalRowIndex: [{
                type: Input
            }], lockedColumnsCount: [{
                type: Input
            }], filterRowClass: [{
                type: HostBinding,
                args: ['class.k-filter-row']
            }] } });

/**
 * Represents the service passed to the [`ColumnMenuTemplate`]({% slug api_grid_columnmenutemplatedirective %}) directive.
 *
 * Use this service to interact with the column menu from a custom template.
 *
 * @example
 * ```html
 * <kendo-grid [data]="data" [columnMenu]="true">
 *   <ng-template kendoGridColumnMenuTemplate let-service="service">
 *     <span class="k-icon k-font-icon k-i-x" (click)="service.close()"></span>
 *     <kendo-grid-columnmenu-sort [service]="service"></kendo-grid-columnmenu-sort>
 *   </ng-template>
 *   <kendo-grid-column field="Field1"></kendo-grid-column>
 * </kendo-grid>
 * ```
 */
class ColumnMenuService {
    /**
     * @hidden
     */
    menuTabbingService;
    /**
     * @hidden
     */
    closeMenu = new EventEmitter();
    /**
     * @hidden
     */
    column;
    /**
     * @hidden
     */
    sort;
    /**
     * @hidden
     */
    filter;
    /**
     * @hidden
     */
    sortable;
    /**
     * @hidden
     */
    columnMenuContainer;
    /**
     * @hidden
     */
    constructor(menuTabbingService) {
        this.menuTabbingService = menuTabbingService;
    }
    /**
     * Closes the column menu.
     */
    close() {
        this.closeMenu.emit();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnMenuService, deps: [{ token: MenuTabbingService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnMenuService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnMenuService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: MenuTabbingService }] });

/**
 * @hidden
 */
class ColumnListKeyboardNavigation {
    renderer;
    items;
    activeIndex = 0;
    constructor(renderer) {
        this.renderer = renderer;
    }
    next() {
        this.toggle(this.activeIndex, false);
        this.activeIndex = Math.min(this.activeIndex + 1, this.items.length - 1);
        this.toggle(this.activeIndex, true);
    }
    prev() {
        this.toggle(this.activeIndex, false);
        this.activeIndex = Math.max(this.activeIndex - 1, 0);
        this.toggle(this.activeIndex, true);
    }
    toggle(index, active) {
        const element = this.items[index]?.hostElement.nativeElement.closest('.k-column-list-item');
        element && this.renderer.setAttribute(element, 'tabindex', active ? '0' : '-1');
        active && element?.focus({ preventScroll: true });
    }
    toggleCheckedState() {
        this.items[this.activeIndex].hostElement.nativeElement.closest('.k-column-list-item').firstElementChild.click();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnListKeyboardNavigation, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnListKeyboardNavigation });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnListKeyboardNavigation, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: i0.Renderer2 }] });

/**
 * @hidden
 */
class ColumnListComponent {
    element;
    ngZone;
    renderer;
    listNavigationService;
    cdr;
    columnInfoService;
    adaptiveGridService;
    ctx;
    className = true;
    get listSizeMd() {
        return !(this.ctx?.grid?.isActionSheetExpanded);
    }
    get listSizeLg() {
        return this.ctx?.grid?.isActionSheetExpanded;
    }
    reset = new EventEmitter();
    apply = new EventEmitter();
    columnChange = new EventEmitter();
    set columns(value) {
        this.listNavigationService.items = this.checkboxes?.toArray();
        this._columns = value.filter(column => column.includeInChooser !== false);
    }
    get columns() {
        return this._columns;
    }
    get checkedCheckboxesLength() {
        return this.columns?.filter(column => column.currentlyChecked).length;
    }
    filteredColumns = [];
    autoSync = true;
    showSelectAll = false;
    isFiltered = false;
    ariaLabel;
    allowHideAll = false;
    applyText;
    resetText;
    selectAllText;
    isLast;
    isExpanded;
    service;
    filterable = false;
    checkboxes;
    get columnCheckboxes() {
        if (this.showSelectAll) {
            return this.checkboxes?.toArray().slice(1);
        }
        return this.checkboxes?.toArray();
    }
    get lockedColumnCheckboxes() {
        return this.columnCheckboxes?.filter((checkbox, index) => this.filteredColumns[index]?.locked);
    }
    get unlockedColumnCheckboxes() {
        return this.columnCheckboxes?.filter((checkbox, index) => !this.filteredColumns[index]?.locked);
    }
    get checkedCheckboxes() {
        if (this.showSelectAll && !this.isFiltered) {
            return this.checkboxes?.toArray().slice(1).filter(checkbox => checkbox.checkedState).length;
        }
        return this.checkboxes?.filter(checkbox => checkbox.checkedState).length;
    }
    resetButton;
    applyButton;
    filterInput;
    _columns;
    domSubscriptions = new Subscription();
    lastDisabledCheckbox;
    handledKeys = [Keys.ArrowDown, Keys.ArrowUp, Keys.Space];
    constructor(element, ngZone, renderer, listNavigationService, cdr, columnInfoService, adaptiveGridService, ctx) {
        this.element = element;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.listNavigationService = listNavigationService;
        this.cdr = cdr;
        this.columnInfoService = columnInfoService;
        this.adaptiveGridService = adaptiveGridService;
        this.ctx = ctx;
    }
    ngOnInit() {
        if (!this.element) {
            return;
        }
        this.ngZone.runOutsideAngular(() => {
            this.domSubscriptions.add(this.renderer.listen(this.element.nativeElement, 'click', (e) => {
                if (e.target.classList.contains('k-checkbox')) {
                    const label = e.target.closest('.k-column-list-item');
                    this.setTabindex(label);
                }
            }));
            this.domSubscriptions.add(this.renderer.listen(this.element.nativeElement, 'keydown', this.onKeydown));
        });
    }
    ngAfterViewInit() {
        this.ngZone.onStable.pipe(take(1)).subscribe(() => {
            this.listNavigationService.items = this.checkboxes.toArray();
            if (this.adaptiveGridService?.viewType !== 'columnMenu') {
                this.listNavigationService.toggle(0, true);
            }
            this.updateDisabled();
        });
        if (this.ctx?.grid?.isActionSheetExpanded) {
            this.domSubscriptions.add(this.adaptiveGridService.animationEnd.subscribe(() => {
                this.listNavigationService.toggle(0, true);
            }));
        }
    }
    ngOnChanges(changes) {
        if (!this.service) {
            return;
        }
        if (changes['isLast'] && this.isLast) {
            this.service.menuTabbingService.lastFocusable = this.applyButton?.nativeElement;
        }
        if (changes['isExpanded'] && this.isExpanded && this.isLast && this.applyButton) {
            this.service.menuTabbingService.lastFocusable = this.applyButton.nativeElement;
        }
    }
    onSelectAllCheckboxChange(checkedState) {
        if (!checkedState && !this.allowHideAll) {
            const columnsToKeep = [];
            if (!columnsToKeep.length) {
                const unlockedColumns = this.filteredColumns.filter(c => !c.locked);
                if (unlockedColumns.length > 0) {
                    columnsToKeep.push(unlockedColumns[0]);
                }
            }
            if (this.lockedColumnCheckboxes.length > 0) {
                const lockedColumns = this.filteredColumns.filter(c => c.locked);
                if (lockedColumns.length > 0) {
                    columnsToKeep.unshift(lockedColumns[0]);
                }
            }
            this.filteredColumns.forEach(column => {
                const isChecked = columnsToKeep.indexOf(column) >= 0;
                column.currentlyChecked = isChecked;
            });
        }
        else {
            this.filteredColumns.forEach(column => {
                column.currentlyChecked = checkedState;
            });
        }
        if (this.autoSync) {
            const changedColumns = this.filteredColumns.filter(column => column.initiallyChecked !== column.currentlyChecked);
            if (changedColumns.length > 0) {
                changedColumns.forEach(column => {
                    column.hidden = !column.currentlyChecked;
                    column.initiallyChecked = column.currentlyChecked;
                });
                this.ngZone.run(() => {
                    this.columnChange.emit(changedColumns);
                });
            }
        }
        this.filteredColumns = [...this.filteredColumns];
        this.updateDisabled();
    }
    ngOnDestroy() {
        this.domSubscriptions.unsubscribe();
    }
    cancelChanges() {
        this.columns.forEach((column) => {
            column.currentlyChecked = !column.hidden;
            column.initiallyChecked = !column.hidden;
        });
        this.filteredColumns.forEach((column) => {
            column.currentlyChecked = !column.hidden;
            column.initiallyChecked = !column.hidden;
        });
        this.updateDisabled();
        this.reset.emit();
    }
    applyChanges() {
        const changed = [];
        this.columns.forEach(column => {
            if (column.initiallyChecked !== column.currentlyChecked) {
                column.hidden = !column.currentlyChecked;
                changed.push(column);
            }
        });
        this.updateDisabled();
        this.apply.emit(changed);
        if (changed.length) {
            this.cdr.markForCheck();
            this.columnInfoService?.changeVisibility(changed);
        }
    }
    focusActiveColumn(e) {
        const keyboardEvent = e;
        if (keyboardEvent.shiftKey) {
            this.listNavigationService.toggle(this.listNavigationService.activeIndex, true);
            e.preventDefault();
        }
    }
    onTab(e) {
        if (this.isLast) {
            e.preventDefault();
            if (this.service) {
                this.service.menuTabbingService.firstFocusable.focus();
            }
            else if (this.filterable) {
                this.filterInput?.input.nativeElement.focus();
            }
            else {
                this.listNavigationService.toggle(this.listNavigationService.activeIndex, true);
            }
        }
    }
    onKeydown = (e) => {
        const code = normalizeKeys(e);
        if (this.handledKeys.includes(code)) {
            e.preventDefault();
        }
        if (code === 'Tab' && e.shiftKey) {
            this.resetButton?.nativeElement.focus();
            e.preventDefault();
        }
        if (code === 'Tab' && !e.shiftKey && this.autoSync) {
            if (this.filterable) {
                this.filterInput?.input.nativeElement.focus();
            }
            e.preventDefault();
        }
        if (code === 'Tab' && e.shiftKey && this.autoSync && this.filterable) {
            this.filterInput?.input.nativeElement.focus();
            e.preventDefault();
        }
        if (code === 'Tab' && !e.shiftKey && !this.autoSync) {
            this.applyButton?.nativeElement.focus();
            e.preventDefault();
        }
        if (code === 'Tab' && e.shiftKey) {
            if (!this.autoSync && this.filterable && e.target.matches('.k-column-list-item')) {
                this.filterInput?.input.nativeElement.focus();
                e.preventDefault();
                return;
            }
            this.ngZone.run(() => {
                if (e.target.matches('.k-column-list-item')) {
                    e.preventDefault();
                    this.resetButton?.nativeElement.focus();
                }
            });
        }
        if (code === Keys.ArrowDown) {
            this.listNavigationService.next();
        }
        else if (code === Keys.ArrowUp) {
            this.listNavigationService.prev();
        }
        else if (code === Keys.Space && e.target.classList.contains('k-column-list-item')) {
            this.listNavigationService.toggleCheckedState();
        }
    };
    updateDisabled() {
        const hasLockedColumns = this.columns.filter(c => c.locked).length > 0;
        if (this.allowHideAll && !hasLockedColumns) {
            return;
        }
        const currentlyCheckedUnlockedColumns = this.columns.filter(column => !column.locked && column.currentlyChecked).length;
        const shouldEnforceMinimumColumns = hasLockedColumns || !this.allowHideAll;
        if (shouldEnforceMinimumColumns && currentlyCheckedUnlockedColumns === 1) {
            this.disableFirstUnlockedCheckedCheckbox();
        }
        else {
            this.enableLastDisabledColumn();
        }
    }
    disableFirstUnlockedCheckedCheckbox() {
        const index = this.filteredColumns.filter(c => !c.locked).findIndex(column => column.currentlyChecked);
        const firstUnlockedCheckedCheckbox = this.unlockedColumnCheckboxes[index];
        this.setDisabledState(firstUnlockedCheckedCheckbox, true);
        this.lastDisabledCheckbox = firstUnlockedCheckedCheckbox;
    }
    enableLastDisabledColumn() {
        this.setDisabledState(this.lastDisabledCheckbox, false);
        this.lastDisabledCheckbox = null;
    }
    setDisabledState(checkbox, disabled) {
        if (!checkbox) {
            return;
        }
        if (checkbox.disabled !== disabled) {
            this.ngZone.runOutsideAngular(() => {
                checkbox.disabled = disabled;
                const checkboxElement = checkbox.hostElement.nativeElement;
                const parentElement = checkboxElement.parentElement;
                if (disabled) {
                    this.renderer.addClass(parentElement, 'k-disabled');
                    this.renderer.setAttribute(parentElement, 'aria-disabled', 'true');
                }
                else {
                    this.renderer.removeClass(parentElement, 'k-disabled');
                    this.renderer.removeAttribute(parentElement, 'aria-disabled');
                }
            });
        }
    }
    onCheckboxChange(checkedState, column, _index) {
        column.currentlyChecked = checkedState;
        if (this.autoSync) {
            column.hidden = !checkedState;
            column.initiallyChecked = checkedState;
            this.columnChange.emit([column]);
        }
        this.updateDisabled();
    }
    setTabindex(labelElement) {
        if (!labelElement) {
            return;
        }
        const allLabels = this.checkboxes.map(checkbox => checkbox.hostElement.nativeElement.parentElement);
        allLabels.forEach((label) => {
            const input = label.querySelector('input');
            input.classList.remove('k-focus');
            this.renderer.removeAttribute(label, 'tabindex');
        });
        this.renderer.setAttribute(labelElement, 'tabindex', '0');
        labelElement.focus();
        this.listNavigationService.activeIndex = allLabels.indexOf(labelElement);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnListComponent, deps: [{ token: i0.ElementRef }, { token: i0.NgZone }, { token: i0.Renderer2 }, { token: ColumnListKeyboardNavigation }, { token: i0.ChangeDetectorRef }, { token: ColumnInfoService, optional: true }, { token: AdaptiveGridService, optional: true }, { token: ContextService, optional: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: ColumnListComponent, isStandalone: true, selector: "kendo-grid-columnlist", inputs: { columns: "columns", filteredColumns: "filteredColumns", autoSync: "autoSync", showSelectAll: "showSelectAll", isFiltered: "isFiltered", ariaLabel: "ariaLabel", allowHideAll: "allowHideAll", applyText: "applyText", resetText: "resetText", selectAllText: "selectAllText", isLast: "isLast", isExpanded: "isExpanded", service: "service", filterable: "filterable" }, outputs: { reset: "reset", apply: "apply", columnChange: "columnChange" }, host: { properties: { "class.k-column-list-wrapper": "this.className", "class.k-column-list-md": "this.listSizeMd", "class.k-column-list-lg": "this.listSizeLg" } }, providers: [ColumnListKeyboardNavigation], viewQueries: [{ propertyName: "checkboxes", predicate: CheckBoxComponent, descendants: true }], usesOnChanges: true, ngImport: i0, template: `
        <div
          class="k-column-list"
          role="listbox"
          aria-multiselectable="true"
          [attr.aria-label]="ariaLabel">
          @if (showSelectAll) {
            <label
              class='k-column-list-item'
              role="option">
              <kendo-checkbox
                #checkbox
                [inputAttributes]="{'data-index': '0'}"
                [tabindex]="-1"
                [checkedState]="checkedCheckboxesLength === columns.length"
                (checkedStateChange)="onSelectAllCheckboxChange($event)"
              ></kendo-checkbox>
              <span class="k-checkbox-label">{{ selectAllText }}</span>
            </label>
          }
          @for (column of filteredColumns; track column; let index = $index) {
            <label
              class='k-column-list-item'
              role="option">
              <kendo-checkbox
                #checkbox
                [inputAttributes]="{'data-index': index.toString()}"
                [tabindex]="-1"
                [checkedState]="column.currentlyChecked"
                (checkedStateChange)="onCheckboxChange($event, column, index)"
              ></kendo-checkbox>
              <span class="k-checkbox-label">{{ column.displayTitle }}</span>
            </label>
          }
        </div>
        `, isInline: true, dependencies: [{ kind: "component", type: CheckBoxComponent, selector: "kendo-checkbox", inputs: ["checkedState", "rounded"], outputs: ["checkedStateChange"], exportAs: ["kendoCheckBox"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnListComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-columnlist',
                    providers: [ColumnListKeyboardNavigation],
                    template: `
        <div
          class="k-column-list"
          role="listbox"
          aria-multiselectable="true"
          [attr.aria-label]="ariaLabel">
          @if (showSelectAll) {
            <label
              class='k-column-list-item'
              role="option">
              <kendo-checkbox
                #checkbox
                [inputAttributes]="{'data-index': '0'}"
                [tabindex]="-1"
                [checkedState]="checkedCheckboxesLength === columns.length"
                (checkedStateChange)="onSelectAllCheckboxChange($event)"
              ></kendo-checkbox>
              <span class="k-checkbox-label">{{ selectAllText }}</span>
            </label>
          }
          @for (column of filteredColumns; track column; let index = $index) {
            <label
              class='k-column-list-item'
              role="option">
              <kendo-checkbox
                #checkbox
                [inputAttributes]="{'data-index': index.toString()}"
                [tabindex]="-1"
                [checkedState]="column.currentlyChecked"
                (checkedStateChange)="onCheckboxChange($event, column, index)"
              ></kendo-checkbox>
              <span class="k-checkbox-label">{{ column.displayTitle }}</span>
            </label>
          }
        </div>
        `,
                    standalone: true,
                    imports: [CheckBoxComponent]
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.NgZone }, { type: i0.Renderer2 }, { type: ColumnListKeyboardNavigation }, { type: i0.ChangeDetectorRef }, { type: ColumnInfoService, decorators: [{
                    type: Optional
                }] }, { type: AdaptiveGridService, decorators: [{
                    type: Optional
                }] }, { type: ContextService, decorators: [{
                    type: Optional
                }] }], propDecorators: { className: [{
                type: HostBinding,
                args: ["class.k-column-list-wrapper"]
            }], listSizeMd: [{
                type: HostBinding,
                args: ['class.k-column-list-md']
            }], listSizeLg: [{
                type: HostBinding,
                args: ['class.k-column-list-lg']
            }], reset: [{
                type: Output
            }], apply: [{
                type: Output
            }], columnChange: [{
                type: Output
            }], columns: [{
                type: Input
            }], filteredColumns: [{
                type: Input
            }], autoSync: [{
                type: Input
            }], showSelectAll: [{
                type: Input
            }], isFiltered: [{
                type: Input
            }], ariaLabel: [{
                type: Input
            }], allowHideAll: [{
                type: Input
            }], applyText: [{
                type: Input
            }], resetText: [{
                type: Input
            }], selectAllText: [{
                type: Input
            }], isLast: [{
                type: Input
            }], isExpanded: [{
                type: Input
            }], service: [{
                type: Input
            }], filterable: [{
                type: Input
            }], checkboxes: [{
                type: ViewChildren,
                args: [CheckBoxComponent]
            }] } });

/**
 * @hidden
 */
class ColumnChooserContentComponent {
    cdr;
    columnInfoService;
    ctx;
    resetButton;
    applyButton;
    columnList;
    filterInput;
    filterable = true;
    showSelectAll = true;
    showCheckedCount = true;
    allowHideAll = false;
    autoSync = false;
    actionsClass = 'k-actions k-actions-stretched k-actions-horizontal';
    closeOnReset = true;
    set columns(value) {
        this._columns = value;
    }
    get columns() {
        return this._columns;
    }
    isLast;
    isExpanded;
    service;
    close = new EventEmitter();
    get selectedItemsText() {
        const count = this.columnList?.checkedCheckboxesLength || 0;
        const localizedMessage = this.messageFor('columnChooserSelectedColumnsCount');
        return replaceMessagePlaceholder(localizedMessage, 'selectedColumnsCount', count.toString());
    }
    get actionSheetOpened() {
        return this.ctx?.grid?.isActionSheetExpanded;
    }
    searchIcon = searchIcon;
    checkIcon = checkIcon;
    arrowRotateCcwIcon = arrowRotateCcwIcon;
    applyText;
    resetText;
    filteredColumns = [];
    isFiltered = false;
    _columns = [];
    constructor(cdr, columnInfoService, ctx) {
        this.cdr = cdr;
        this.columnInfoService = columnInfoService;
        this.ctx = ctx;
    }
    ngOnInit() {
        this.applyText = this.ctx?.localization.get('columnsApply');
        this.resetText = this.ctx?.localization.get('columnsReset');
    }
    ngAfterViewInit() {
        this.filteredColumns = this.columnInfoService?.leafNamedColumns.filter(column => {
            if (column.includeInChooser !== false) {
                column.initiallyChecked = column.currentlyChecked = !column.hidden;
                return true;
            }
            return false;
        });
        this.cdr.detectChanges();
    }
    ngAfterViewChecked() {
        this.columnList.resetButton = this.resetButton;
        this.columnList.applyButton = this.applyButton;
        this.columnList.filterInput = this.filterInput;
    }
    onFilter(value) {
        this.isFiltered = value.length > 0;
        this.showSelectAll = !this.isFiltered;
        const filterDescriptor = {
            field: 'displayTitle',
            operator: 'contains',
            value: value
        };
        this.filteredColumns = filterBy(this.columnInfoService?.leafNamedColumns, filterDescriptor);
        this.cdr.detectChanges();
        this.columnList.listNavigationService.activeIndex = 0;
        this.columnList.listNavigationService.items = this.columnList.checkboxes?.toArray();
    }
    messageFor = token => this.ctx?.localization.get(token);
    onChange(changed) {
        this.cdr.markForCheck();
        this.columnInfoService?.changeVisibility(changed);
    }
    applyChanges() {
        this.columnList.applyChanges();
        this.close.emit();
    }
    cancelChanges() {
        this.columnList.cancelChanges();
        if (this.closeOnReset) {
            this.close.emit();
        }
    }
    onTab(e) {
        if (e.key === 'Tab' && !e.shiftKey) {
            this.columnList.listNavigationService.toggle(this.columnList.listNavigationService.activeIndex, true);
            e.preventDefault();
        }
        if (e.key === 'Tab' && e.shiftKey && !this.service) {
            this.columnList.resetButton?.nativeElement.focus();
            e.preventDefault();
        }
    }
    onApplyButtonKeydown(e) {
        if (e.key === 'Tab') {
            this.columnList.focusActiveColumn(e);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnChooserContentComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: ColumnInfoService, optional: true }, { token: ContextService, optional: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: ColumnChooserContentComponent, isStandalone: true, selector: "kendo-grid-column-chooser-content", inputs: { filterable: "filterable", showSelectAll: "showSelectAll", showCheckedCount: "showCheckedCount", allowHideAll: "allowHideAll", autoSync: "autoSync", actionsClass: "actionsClass", closeOnReset: "closeOnReset", columns: "columns", isLast: "isLast", isExpanded: "isExpanded", service: "service" }, outputs: { close: "close" }, viewQueries: [{ propertyName: "resetButton", first: true, predicate: ["resetButton"], descendants: true }, { propertyName: "applyButton", first: true, predicate: ["applyButton"], descendants: true }, { propertyName: "columnList", first: true, predicate: ["columnList"], descendants: true }, { propertyName: "filterInput", first: true, predicate: ["filterInput"], descendants: true }], ngImport: i0, template: `
            <form class="k-filter-menu">
              <div class="k-filter-menu-container">
                @if (filterable) {
                  <kendo-textbox
                    #filterInput
                    class="k-searchbox"
                    (valueChange)="onFilter($event)"
                    [kendoEventsOutsideAngular]="{'keydown': onTab}"
                    [scope]="this"
                    >
                    <ng-template kendoPrefixTemplate>
                      <kendo-icon-wrapper
                        [name]="'search'"
                        [svgIcon]="searchIcon">
                      </kendo-icon-wrapper>
                    </ng-template>
                  </kendo-textbox>
                }
                <kendo-grid-columnlist
                  #columnList
                  [columns]="columns"
                  [filteredColumns]="filteredColumns"
                  [ariaLabel]="messageFor('columns')"
                  [showSelectAll]="showSelectAll"
                  [isLast]="isLast"
                  [isFiltered]="isFiltered"
                  [filterable]="filterable"
                  [isExpanded]="isExpanded"
                  [service]="service"
                  [applyText]="messageFor('columnsApply')"
                  [resetText]="messageFor('columnsReset')"
                  [selectAllText]="messageFor('columnChooserSelectAll')"
                  [autoSync]="autoSync"
                  [allowHideAll]="allowHideAll"
                  (columnChange)="onChange($event)"
                  >
                </kendo-grid-columnlist>
                @if (showCheckedCount) {
                  <div class="k-filter-selected-items">
                    {{selectedItemsText}}
                  </div>
                }
                @if (!autoSync && !actionSheetOpened) {
                  <div [ngClass]="actionsClass">
                    <button
                      #applyButton
                      kendoButton
                      type="button"
                      icon="check"
                      [svgIcon]="checkIcon"
                      themeColor="primary"
                      (click)="applyChanges()"
                      (keydown)="onApplyButtonKeydown($event)"
                    >{{ applyText }}</button>
                    <button
                      #resetButton
                      kendoButton
                      type="button"
                      icon="reset"
                      (keydown.tab)="columnList.onTab($event)"
                      [svgIcon]="arrowRotateCcwIcon"
                      (click)="cancelChanges()"
                    >{{ resetText }}</button>
                  </div>
                }
              </div>
            </form>
            `, isInline: true, dependencies: [{ kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "component", type: ButtonComponent, selector: "button[kendoButton]", inputs: ["arrowIcon", "toggleable", "togglable", "selected", "tabIndex", "imageUrl", "iconClass", "icon", "disabled", "size", "rounded", "fillMode", "themeColor", "svgIcon", "primary", "look"], outputs: ["selectedChange", "click"], exportAs: ["kendoButton"] }, { kind: "component", type: ColumnListComponent, selector: "kendo-grid-columnlist", inputs: ["columns", "filteredColumns", "autoSync", "showSelectAll", "isFiltered", "ariaLabel", "allowHideAll", "applyText", "resetText", "selectAllText", "isLast", "isExpanded", "service", "filterable"], outputs: ["reset", "apply", "columnChange"] }, { kind: "component", type: TextBoxComponent, selector: "kendo-textbox", inputs: ["focusableId", "title", "type", "disabled", "readonly", "tabindex", "value", "selectOnFocus", "showSuccessIcon", "showErrorIcon", "clearButton", "successIcon", "successSvgIcon", "errorIcon", "errorSvgIcon", "clearButtonIcon", "clearButtonSvgIcon", "size", "rounded", "fillMode", "tabIndex", "placeholder", "maxlength", "inputAttributes"], outputs: ["valueChange", "inputFocus", "inputBlur", "focus", "blur"], exportAs: ["kendoTextBox"] }, { kind: "directive", type: PrefixTemplateDirective, selector: "[kendoPrefixTemplate]", inputs: ["showSeparator"] }, { kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "directive", type: EventsOutsideAngularDirective, selector: "[kendoEventsOutsideAngular]", inputs: ["kendoEventsOutsideAngular", "scope"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnChooserContentComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-column-chooser-content',
                    template: `
            <form class="k-filter-menu">
              <div class="k-filter-menu-container">
                @if (filterable) {
                  <kendo-textbox
                    #filterInput
                    class="k-searchbox"
                    (valueChange)="onFilter($event)"
                    [kendoEventsOutsideAngular]="{'keydown': onTab}"
                    [scope]="this"
                    >
                    <ng-template kendoPrefixTemplate>
                      <kendo-icon-wrapper
                        [name]="'search'"
                        [svgIcon]="searchIcon">
                      </kendo-icon-wrapper>
                    </ng-template>
                  </kendo-textbox>
                }
                <kendo-grid-columnlist
                  #columnList
                  [columns]="columns"
                  [filteredColumns]="filteredColumns"
                  [ariaLabel]="messageFor('columns')"
                  [showSelectAll]="showSelectAll"
                  [isLast]="isLast"
                  [isFiltered]="isFiltered"
                  [filterable]="filterable"
                  [isExpanded]="isExpanded"
                  [service]="service"
                  [applyText]="messageFor('columnsApply')"
                  [resetText]="messageFor('columnsReset')"
                  [selectAllText]="messageFor('columnChooserSelectAll')"
                  [autoSync]="autoSync"
                  [allowHideAll]="allowHideAll"
                  (columnChange)="onChange($event)"
                  >
                </kendo-grid-columnlist>
                @if (showCheckedCount) {
                  <div class="k-filter-selected-items">
                    {{selectedItemsText}}
                  </div>
                }
                @if (!autoSync && !actionSheetOpened) {
                  <div [ngClass]="actionsClass">
                    <button
                      #applyButton
                      kendoButton
                      type="button"
                      icon="check"
                      [svgIcon]="checkIcon"
                      themeColor="primary"
                      (click)="applyChanges()"
                      (keydown)="onApplyButtonKeydown($event)"
                    >{{ applyText }}</button>
                    <button
                      #resetButton
                      kendoButton
                      type="button"
                      icon="reset"
                      (keydown.tab)="columnList.onTab($event)"
                      [svgIcon]="arrowRotateCcwIcon"
                      (click)="cancelChanges()"
                    >{{ resetText }}</button>
                  </div>
                }
              </div>
            </form>
            `,
                    standalone: true,
                    imports: [NgClass, ButtonComponent, ColumnListComponent, TextBoxComponent, PrefixTemplateDirective, IconWrapperComponent, EventsOutsideAngularDirective]
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: ColumnInfoService, decorators: [{
                    type: Optional
                }] }, { type: ContextService, decorators: [{
                    type: Optional
                }] }], propDecorators: { resetButton: [{
                type: ViewChild,
                args: ['resetButton']
            }], applyButton: [{
                type: ViewChild,
                args: ['applyButton']
            }], columnList: [{
                type: ViewChild,
                args: ['columnList']
            }], filterInput: [{
                type: ViewChild,
                args: ['filterInput']
            }], filterable: [{
                type: Input
            }], showSelectAll: [{
                type: Input
            }], showCheckedCount: [{
                type: Input
            }], allowHideAll: [{
                type: Input
            }], autoSync: [{
                type: Input
            }], actionsClass: [{
                type: Input
            }], closeOnReset: [{
                type: Input
            }], columns: [{
                type: Input
            }], isLast: [{
                type: Input
            }], isExpanded: [{
                type: Input
            }], service: [{
                type: Input
            }], close: [{
                type: Output
            }] } });

/**
 * Represents the component for toggling visibility of the Grid columns visibility. [See example](slug:columnmenu_grid#toc-using-standalone-column-chooser).
 * To show and hide the columns without including the column chooser item in the [Column Menu](slug:columnmenu_grid),
 * add the component inside the [ToolbarTemplate](slug:toolbartemplate_grid) directive.
 *
 * @example
 * ```html
 * <kendo-grid [data]="data">
 *   <ng-template kendoGridToolbarTemplate>
 *     <kendo-grid-column-chooser></kendo-grid-column-chooser>
 *   </ng-template>
 *   <kendo-grid-column field="ProductID"></kendo-grid-column>
 * </kendo-grid>
 * ```
 */
class ColumnChooserComponent {
    ctx;
    columnInfoService;
    popupService;
    ngZone;
    renderer;
    changeDetector;
    /**
     * Specifies if the changes in the visibility of the column will be immediately applied.
     *
     * @default false
     */
    autoSync = false;
    /**
     * Specifies if the column chooser displays a search box.
     *
     * @default true
     */
    filterable = true;
    /**
     * Specifies if the column chooser displays a select all checkbox.
     *
     * @default true
     */
    showSelectAll = true;
    /**
     * Specifies if all columns can be hidden.
     *
     * @default true
     */
    allowHideAll = true;
    anchor;
    get columns() {
        return this.columnInfoService.leafNamedColumns;
    }
    columnsIcon = columnsIcon;
    popupRef;
    popupId;
    closeClick;
    escapeListener;
    constructor(ctx, columnInfoService, popupService, ngZone, renderer, changeDetector) {
        this.ctx = ctx;
        this.columnInfoService = columnInfoService;
        this.popupService = popupService;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.changeDetector = changeDetector;
    }
    ngOnDestroy() {
        this.close();
    }
    /**
     * @hidden
     */
    messageFor = token => this.ctx.localization.get(token);
    /**
     * @hidden
     */
    toggle(anchor, template) {
        if (!this.popupRef) {
            const direction = this.ctx.localization.rtl ? 'right' : 'left';
            this.popupRef = this.popupService.open({
                anchor: anchor.element,
                content: template,
                positionMode: 'absolute',
                anchorAlign: { vertical: 'bottom', horizontal: direction },
                popupAlign: { vertical: 'top', horizontal: direction }
            });
            const popupElement = this.popupRef?.popupElement;
            if (popupElement) {
                const popupId = `k-${guid()}`;
                const popupAriaElement = popupElement.querySelector('.k-popup');
                this.ngZone.runOutsideAngular(() => {
                    this.escapeListener = this.renderer.listen(popupAriaElement, 'keydown', (e) => {
                        if (e.code === Keys.Escape) {
                            this.close(true);
                        }
                    });
                });
                this.renderer.setAttribute(popupElement, 'dir', this.ctx.localization.rtl ? 'rtl' : 'ltr');
                this.renderer.setAttribute(popupAriaElement, 'id', popupId);
                this.renderer.setAttribute(popupAriaElement, 'role', 'dialog');
                this.popupId = popupId;
            }
            if (!isDocumentAvailable()) {
                return;
            }
            this.ngZone.runOutsideAngular(() => this.closeClick = this.renderer.listen('document', 'click', ({ target }) => {
                if (!closest(target, node => node === this.popupRef.popupElement || node === anchor.element)) {
                    this.ngZone.run(() => {
                        this.close();
                    });
                }
            }));
        }
        else {
            this.close();
        }
    }
    /**
     * @hidden
     */
    onChange(changed) {
        this.changeDetector.markForCheck();
        this.columnInfoService.changeVisibility(changed);
    }
    /**
     * @hidden
     */
    close(focusAnchor = false) {
        if (this.popupRef) {
            this.popupRef.close();
            this.popupRef = null;
            this.changeDetector.markForCheck();
            this.escapeListener?.();
        }
        this.detachClose();
        focusAnchor && this.anchor.element.focus();
    }
    detachClose() {
        if (this.closeClick) {
            this.closeClick();
            this.closeClick = null;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnChooserComponent, deps: [{ token: ContextService }, { token: ColumnInfoService }, { token: i2.PopupService }, { token: i0.NgZone }, { token: i0.Renderer2 }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: ColumnChooserComponent, isStandalone: true, selector: "kendo-grid-column-chooser", inputs: { autoSync: "autoSync", filterable: "filterable", showSelectAll: "showSelectAll", allowHideAll: "allowHideAll" }, viewQueries: [{ propertyName: "anchor", first: true, predicate: ["anchor"], descendants: true }], ngImport: i0, template: `
        <button #anchor
            kendoButton
            type="button"
            (click)="toggle(anchor, template)"
            fillMode="flat"
            [attr.title]="messageFor('columns')"
            icon="columns"
            [svgIcon]="columnsIcon"
            [attr.aria-haspopup]="'dialog'"
            [attr.aria-expanded]="!!(popupRef)"
            [attr.aria-controls]="!!(popupRef) ? popupId : undefined"></button>
        <ng-template #template>
            <kendo-grid-column-chooser-content
                [columns]="columns"
                [autoSync]="autoSync"
                [filterable]="filterable"
                [showSelectAll]="showSelectAll"
                [closeOnReset]="false"
                [isLast]="true"
                [allowHideAll]="allowHideAll"
                (close)="close(true)"
            >
            </kendo-grid-column-chooser-content>
        </ng-template>
    `, isInline: true, dependencies: [{ kind: "component", type: ButtonComponent, selector: "button[kendoButton]", inputs: ["arrowIcon", "toggleable", "togglable", "selected", "tabIndex", "imageUrl", "iconClass", "icon", "disabled", "size", "rounded", "fillMode", "themeColor", "svgIcon", "primary", "look"], outputs: ["selectedChange", "click"], exportAs: ["kendoButton"] }, { kind: "component", type: ColumnChooserContentComponent, selector: "kendo-grid-column-chooser-content", inputs: ["filterable", "showSelectAll", "showCheckedCount", "allowHideAll", "autoSync", "actionsClass", "closeOnReset", "columns", "isLast", "isExpanded", "service"], outputs: ["close"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnChooserComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-column-chooser',
                    template: `
        <button #anchor
            kendoButton
            type="button"
            (click)="toggle(anchor, template)"
            fillMode="flat"
            [attr.title]="messageFor('columns')"
            icon="columns"
            [svgIcon]="columnsIcon"
            [attr.aria-haspopup]="'dialog'"
            [attr.aria-expanded]="!!(popupRef)"
            [attr.aria-controls]="!!(popupRef) ? popupId : undefined"></button>
        <ng-template #template>
            <kendo-grid-column-chooser-content
                [columns]="columns"
                [autoSync]="autoSync"
                [filterable]="filterable"
                [showSelectAll]="showSelectAll"
                [closeOnReset]="false"
                [isLast]="true"
                [allowHideAll]="allowHideAll"
                (close)="close(true)"
            >
            </kendo-grid-column-chooser-content>
        </ng-template>
    `,
                    standalone: true,
                    imports: [ButtonComponent, ColumnChooserContentComponent]
                }]
        }], ctorParameters: () => [{ type: ContextService }, { type: ColumnInfoService }, { type: i2.PopupService }, { type: i0.NgZone }, { type: i0.Renderer2 }, { type: i0.ChangeDetectorRef }], propDecorators: { autoSync: [{
                type: Input
            }], filterable: [{
                type: Input
            }], showSelectAll: [{
                type: Input
            }], allowHideAll: [{
                type: Input
            }], anchor: [{
                type: ViewChild,
                args: ['anchor']
            }] } });

/**
 * @hidden
 */
const ToolbarToolName = {
    edit: 'edit',
    save: 'save',
    remove: 'remove',
    cancel: 'cancel',
    add: 'add',
    columns: 'columns',
    excelExport: 'excelExport',
    pdfExport: 'pdfExport',
    aiAssistant: 'aiAssistant'
};

const ICONS_MAP = {
    edit: { svgIcon: pencilIcon, icon: 'pencil' },
    save: { svgIcon: saveIcon, icon: 'save' },
    cancel: { svgIcon: cancelIcon, icon: 'cancel' },
    remove: { svgIcon: trashIcon, icon: 'trash' },
    add: { svgIcon: plusIcon, icon: 'plus' },
    excelExport: { svgIcon: fileExcelIcon, icon: 'file-excel' },
    pdfExport: { svgIcon: filePdfIcon, icon: 'file-pdf' },
    columns: { svgIcon: columnsIcon, icon: 'columns' },
    aiAssistant: { svgIcon: sparklesIcon, icon: 'sparkles' }
};
/**
 * @hidden
 */
class ToolbarToolBase {
    host;
    commandName;
    ctx;
    zone;
    cdr;
    clickSub = new Subscription();
    constructor(host, commandName, ctx, zone, cdr) {
        this.host = host;
        this.commandName = commandName;
        this.ctx = ctx;
        this.zone = zone;
        this.cdr = cdr;
    }
    ngOnInit() {
        this.clickSub = this.host.click.subscribe(e => this.onClick(e));
        const hasIcon = (isPresent$1(this.host.toolbarOptions.icon) && this.host.toolbarOptions.icon !== '') &&
            (isPresent$1(this.host.overflowOptions.icon) && this.host.overflowOptions.icon !== '');
        const hasSvgIcon = isPresent$1(this.host.toolbarOptions.svgIcon) && isPresent$1(this.host.overflowOptions.svgIcon);
        if (!hasIcon) {
            this.host.icon = ICONS_MAP[this.commandName].icon;
        }
        if (!hasSvgIcon) {
            this.host.svgIcon = ICONS_MAP[this.commandName].svgIcon;
        }
    }
    ngAfterViewInit() {
        const hasText = isPresent$1(this.host.text);
        if (!hasText) {
            this.zone.runOutsideAngular(() => {
                setTimeout(() => {
                    const messageKey = this.commandName === ToolbarToolName.columns ? 'columns' : `${this.commandName}ToolbarToolText`;
                    this.host.text = this.ctx.localization.get(messageKey);
                    this.zone.run(() => {
                        this.cdr.markForCheck();
                    });
                });
            });
        }
    }
    ngOnDestroy() {
        this.clickSub.unsubscribe();
    }
    onClick(_e) { }
    get buttonElement() {
        return this.host.getButton();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ToolbarToolBase, deps: [{ token: i54.ToolBarButtonComponent }, { token: 'command' }, { token: ContextService }, { token: i0.NgZone }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: ToolbarToolBase, isStandalone: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ToolbarToolBase, decorators: [{
            type: Directive,
            args: [{}]
        }], ctorParameters: () => [{ type: i54.ToolBarButtonComponent }, { type: undefined, decorators: [{
                    type: Inject,
                    args: ['command']
                }] }, { type: ContextService }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }] });

let incrementingId$3 = 0;
/**
 * Represents a column chooser toolbar tool of the Grid.
 * Use this directive on any `kendo-toolbar-button` inside a ToolbarComponent in the Grid.
 *
 * @example
 * ```html-no-run
 * <kendo-grid>
 *      <kendo-toolbar>
 *         <kendo-toolbar-button kendoGridColumnChooserTool></kendo-toolbar-button>
 *      </kendo-toolbar>
 * </kendo-grid>
 * ```
 * @remarks
 * Applied to: {@link ToolBarButtonComponent}.
 */
class ColumnChooserToolbarDirective extends ToolbarToolBase {
    renderer;
    popupSerivce;
    host;
    ctx;
    zone;
    refresh;
    adaptiveGridService;
    columnInfoService;
    /**
     * When `true`, changes to column visibility apply immediately.
     *
     * @default false
     */
    autoSync = false;
    /**
     * When `true`, enables the hiding of all columns.
     *
     * @default true
     */
    allowHideAll = true;
    /**
     * When `true`, enables the columns' filtering.
     *
     * @default true
     */
    filterable = true;
    /**
     * When `true`, displays a select all checkbox.
     *
     * @default true
     */
    showSelectAll = true;
    /**
     * @hidden
     */
    get columns() {
        return this.columnInfoService.leafNamedColumns;
    }
    popupRef;
    subs = new Subscription();
    actionSheetCloseSub;
    nextId = incrementingId$3++;
    constructor(renderer, popupSerivce, host, ctx, zone, refresh, adaptiveGridService, columnInfoService, cdr) {
        super(host, ToolbarToolName.columns, ctx, zone, cdr);
        this.renderer = renderer;
        this.popupSerivce = popupSerivce;
        this.host = host;
        this.ctx = ctx;
        this.zone = zone;
        this.refresh = refresh;
        this.adaptiveGridService = adaptiveGridService;
        this.columnInfoService = columnInfoService;
    }
    ngOnInit() {
        this.subs.add(this.host.click.subscribe(e => this.onClick(e)));
        const hasToolbarIcon = isPresent$1(this.host.toolbarOptions.icon) && this.host.toolbarOptions.icon !== '';
        const hasOverflowIcon = isPresent$1(this.host.overflowOptions.icon) && this.host.overflowOptions.icon !== '';
        const hasIcon = hasToolbarIcon && hasOverflowIcon;
        const hasSvgIcon = isPresent$1(this.host.toolbarOptions.svgIcon) && isPresent$1(this.host.overflowOptions.svgIcon);
        if (!hasIcon) {
            this.host.icon = 'columns';
        }
        if (!hasSvgIcon) {
            this.host.svgIcon = columnsIcon;
        }
    }
    ngAfterViewInit() {
        super.ngAfterViewInit();
        this.zone.onStable.pipe(take(1)).subscribe(() => {
            this.buttonElement?.setAttribute('aria-haspopup', 'dialog');
            this.buttonElement?.setAttribute('aria-expanded', 'false');
            this.buttonElement?.setAttribute('title', this.ctx.localization.get('columns'));
        });
        this.subs.add(this.refresh.onRefresh.pipe(filter((tool) => tool === this.host)).subscribe((tool) => {
            if (tool.overflows && this.popupRef) {
                this.popupRef.close();
            }
        }));
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        this.subs.unsubscribe();
        if (this.actionSheetCloseSub) {
            this.actionSheetCloseSub.unsubscribe();
            this.actionSheetCloseSub = null;
        }
    }
    /**
     * @hidden
     */
    onClick(e) {
        e.preventDefault();
        if (this.ctx.grid.adaptiveMode === 'auto' && this.adaptiveGridService.windowSize !== 'large') {
            if (!this.ctx.grid.isActionSheetExpanded) {
                this.adaptiveGridService.viewType = 'columnChooserToolbarTool';
                this.adaptiveGridService.columns = this.columns;
                this.ctx.grid.adaptiveRenderer.actionSheet.toggle(true);
                this.host.selected = true;
                this.actionSheetCloseSub = this.ctx.grid.adaptiveRenderer.actionSheet.collapse.subscribe(() => this.host.selected = false);
            }
        }
        else {
            this.togglePopup();
        }
    }
    togglePopup() {
        if (!this.popupRef) {
            const direction = this.ctx.localization.rtl ? 'right' : 'left';
            this.popupRef = this.popupSerivce.open({
                anchor: this.buttonElement,
                content: ColumnChooserContentComponent,
                positionMode: 'absolute',
                anchorAlign: { vertical: 'bottom', horizontal: direction },
                popupAlign: { vertical: 'top', horizontal: direction }
            });
            this.adaptiveGridService.popupRef = this.popupRef;
            const popupElement = this.popupRef.popupElement;
            const popupId = `k-column-chooser-tool-${this.nextId}-popup`;
            const popupAriaElement = popupElement.querySelector('.k-popup');
            this.zone.runOutsideAngular(() => {
                this.renderer.listen(popupAriaElement, 'keydown', (e) => {
                    if (e.key === 'Escape') {
                        this.closePopup(true);
                    }
                });
            });
            this.renderer.setAttribute(popupElement, 'dir', this.ctx.localization.rtl ? 'rtl' : 'ltr');
            this.renderer.setAttribute(popupAriaElement, 'id', popupId);
            this.renderer.setAttribute(popupAriaElement, 'role', 'dialog');
            this.buttonElement?.setAttribute('aria-expanded', 'true');
            this.buttonElement?.setAttribute('aria-controls', popupId);
            this.host.selected = true;
            const columnChooserContent = this.popupRef.content.instance;
            columnChooserContent.columnInfoService = this.columnInfoService;
            columnChooserContent.ctx = this.ctx;
            columnChooserContent.showSelectAll = this.showSelectAll;
            columnChooserContent.filterable = this.filterable;
            columnChooserContent.isLast = true;
            columnChooserContent.autoSync = this.autoSync;
            columnChooserContent.allowHideAll = this.allowHideAll;
            columnChooserContent.applyText = this.ctx.localization.get('columnsApply');
            columnChooserContent.resetText = this.ctx.localization.get('columnsReset');
            columnChooserContent.columns = this.columns;
            columnChooserContent.filteredColumns = this.columnInfoService?.leafNamedColumns.filter(column => {
                if (column.includeInChooser !== false) {
                    column.initiallyChecked = column.currentlyChecked = !column.hidden;
                    return true;
                }
                return false;
            });
            this.subs.add(this.popupRef.popup.instance.anchorViewportLeave.subscribe(() => {
                this.closePopup(true);
            }));
            this.subs.add(columnChooserContent.columnList.apply.subscribe((changed) => {
                if (changed.length) {
                    this.cdr.markForCheck();
                    this.columnInfoService.changeVisibility(changed);
                }
                this.closePopup();
            }));
            this.zone.runOutsideAngular(() => this.renderer.listen('document', 'click', ({ target }) => {
                if (this.popupRef && !closest$1(target, node => node === this.popupRef.popupElement || node === this.buttonElement)) {
                    this.zone.run(() => {
                        this.closePopup();
                    });
                }
            }));
        }
        else {
            this.closePopup();
        }
    }
    closePopup(focusAnchor = false) {
        this.popupRef.close();
        this.popupRef = null;
        this.buttonElement?.setAttribute('aria-expanded', 'false');
        this.buttonElement?.removeAttribute('aria-controls');
        this.host.selected = false;
        focusAnchor && this.buttonElement?.focus({ preventScroll: true });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnChooserToolbarDirective, deps: [{ token: i0.Renderer2 }, { token: i2.PopupService }, { token: i54.ToolBarButtonComponent }, { token: ContextService }, { token: i0.NgZone }, { token: i54.RefreshService }, { token: AdaptiveGridService }, { token: ColumnInfoService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: ColumnChooserToolbarDirective, isStandalone: true, selector: "[kendoGridColumnChooserTool]", inputs: { autoSync: "autoSync", allowHideAll: "allowHideAll", filterable: "filterable", showSelectAll: "showSelectAll" }, usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnChooserToolbarDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridColumnChooserTool]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.Renderer2 }, { type: i2.PopupService }, { type: i54.ToolBarButtonComponent }, { type: ContextService }, { type: i0.NgZone }, { type: i54.RefreshService }, { type: AdaptiveGridService }, { type: ColumnInfoService }, { type: i0.ChangeDetectorRef }], propDecorators: { autoSync: [{
                type: Input
            }], allowHideAll: [{
                type: Input
            }], filterable: [{
                type: Input
            }], showSelectAll: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class ColumnMenuItemBase {
    /**
     * Represents the [`ColumnMenuService`]({% slug api_grid_columnmenuservice %}) class.
     * This input is required.
     */
    service;
    hostClass = true;
    ngOnInit() {
        if (isDevMode() && !this.service) {
            throw new Error(ColumnMenuErrorMessages.serviceInput);
        }
    }
    /**
     * @hidden
     */
    close() {
        this.service.close();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnMenuItemBase, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: ColumnMenuItemBase, isStandalone: true, selector: "kendo-grid-column-menu-item-base", inputs: { service: "service" }, host: { properties: { "class.k-columnmenu-item-wrapper": "this.hostClass" } }, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnMenuItemBase, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-column-menu-item-base',
                    template: ``
                }]
        }], propDecorators: { service: [{
                type: Input
            }], hostClass: [{
                type: HostBinding,
                args: ['class.k-columnmenu-item-wrapper']
            }] } });

/**
 * @hidden
 */
const hasFilter = (settings, column) => settings.filter !== false && column.field && column.filterable;
/**
 * @hidden
 */
const hasSort = (settings, column) => settings.sort !== false && column.field && column.sortable;
/**
 * @hidden
 */
const hasLock = (settings, column) => settings.lock && column.lockable && !(column.parent && !column.parent.isSpanColumn);
/**
 * @hidden
 */
const hasStick = (settings, column) => settings.stick && column.stickable && !(column.parent && !column.parent.isSpanColumn);
/**
 * @hidden
 */
const hasPosition = (settings, column) => settings.setColumnPosition && (column.stickable || column.lockable) && !(column.parent && !column.parent.isSpanColumn);
/**
 * @hidden
 */
const hasColumnChooser = (settings) => settings.columnChooser !== false;
/**
 * @hidden
 */
const hasAutoSizeColumn = (settings) => settings.autoSizeColumn;
/**
 * @hidden
 */
const hasAutoSizeAllColumns = (settings) => settings.autoSizeAllColumns;
/**
 * @hidden
 */
const autoSizeColumn = (grid, service, column) => {
    column ? grid.autoFitColumn(column) : grid.autoFitColumns();
    service.close();
};
/**
 * @hidden
 */
const hasItems = (settings, column) => hasAutoSizeAllColumns(settings) ||
    hasColumnChooser(settings) ||
    hasFilter(settings, column) ||
    hasAutoSizeColumn(settings) ||
    hasLock(settings, column) ||
    hasSort(settings, column);

/**
 * Represents the content template of the
 * [`ColumnMenuItemComponent`]({% slug api_grid_columnmenuitemcomponent %}) component.
 * Use this directive to specify the content of a column menu item.
 * To define the content template, nest an `<ng-template>` tag with the
 * `kendoGridColumnMenuItemContentTemplate` directive inside a `<kendo-grid-columnmenu-item>`.
 *
 * @example
 * ```html
 * <kendo-grid [data]="data" [columnMenu]="true" ...>
 *   <ng-template kendoGridColumnMenuTemplate>
 *     <kendo-grid-columnmenu-item text="Text" [expanded]="true">
 *       <ng-template kendoGridColumnMenuItemContentTemplate>
 *         Content
 *       </ng-template>
 *     </kendo-grid-columnmenu-item>
 *   </ng-template>
 *   <kendo-grid-column field="ID"></kendo-grid-column>
 *   ...
 * </kendo-grid>
 * ```
 */
class ColumnMenuItemContentTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnMenuItemContentTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: ColumnMenuItemContentTemplateDirective, isStandalone: true, selector: "[kendoGridColumnMenuItemContentTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnMenuItemContentTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridColumnMenuItemContentTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }] });

/**
 * @hidden
 */
const DEFAULTS = {
    allowUnsort: true,
    mode: 'single',
    showIndexes: true,
    initialDirection: 'asc',
    multiSortKey: 'none'
};
/**
 * @hidden
 */
const normalize$1 = (...settings) => Object.assign({}, DEFAULTS, ...settings);

/**
 * Represents an item that you can place inside a
 * [`ColumnMenuTemplate`]({% slug api_grid_columnmenutemplatedirective %}) directive.
 *
 * @example
 * ```html
 * <kendo-grid [columnMenu]="true" ...>
 *   <ng-template kendoGridColumnMenuTemplate let-service="service" let-column="column">
 *     <kendo-grid-columnmenu-item text="Fit column"></kendo-grid-columnmenu-item>
 *   </ng-template>
 * </kendo-grid>
 * ```
 * @example
 * ```html
 * <kendo-grid-column field="ProductName">
 *   <ng-template kendoGridColumnMenuTemplate let-service="service">
 *     kendo-grid-columnmenu-item text="Fit column"></kendo-grid-columnmenu-item>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 */
class ColumnMenuItemComponent {
    ngZone;
    ctx;
    adaptiveGridService;
    element;
    /**
     * @hidden
     */
    sortAscSmallIcon = sortAscSmallIcon;
    /**
     * @hidden
     */
    sortDescSmallIcon = sortDescSmallIcon;
    /**
     * Fires when the item is clicked.
     */
    itemClick = new EventEmitter();
    /**
     * Fires when the content expands.
     */
    expand = new EventEmitter();
    /**
     * Fires when the content collapses.
     */
    collapse = new EventEmitter();
    /**
     * Specifies the name of the font icon to render within the item.
     */
    icon;
    /**
     * Specifies the SVG icon to render within the item.
     */
    svgIcon;
    /**
     * @hidden
     */
    indicatorIcon;
    /**
     * Specifies the item text.
     */
    text;
    /**
     * Specifies if the item is selected.
     */
    selected;
    /**
     * Specifies if the item is disabled.
     */
    disabled;
    /**
     * Specifies if the item is expanded.
     */
    expanded;
    /**
     * @hidden
     */
    focused;
    /**
     * Represents the [ColumnMenuService]({% slug api_grid_columnmenuservice %}) class.
     * Required to include the item in the column menu keyboard navigation sequence.
     */
    service;
    /**
     * @hidden
     */
    column;
    contentTemplate;
    contentState = 'collapsed';
    contentId;
    chevronUpIcon = chevronUpIcon;
    chevronDownIcon = chevronDownIcon;
    chevronRightIcon = chevronRightIcon;
    filterIcon = filterIcon;
    /**
     * @hidden
     */
    get hasFilters() {
        return filtersByField(this.ctx.grid.filter, this.column.field).length > 0;
    }
    get expandedIcon() {
        if (this.ctx.grid.isActionSheetExpanded) {
            return 'arrow-chevron-right';
        }
        return this.expanded ? 'arrow-chevron-up' : 'arrow-chevron-down';
    }
    get expandedSvgIcon() {
        if (this.ctx.grid.isActionSheetExpanded) {
            return this.chevronRightIcon;
        }
        return this.expanded ? this.chevronUpIcon : this.chevronDownIcon;
    }
    constructor(ngZone, ctx, adaptiveGridService, element) {
        this.ngZone = ngZone;
        this.ctx = ctx;
        this.adaptiveGridService = adaptiveGridService;
        this.element = element;
    }
    ngAfterViewInit() {
        this.ngZone.onStable.pipe(take(1)).subscribe(() => {
            this.contentTemplate && (this.contentId = `k-${guid()}`);
        });
    }
    ngOnChanges(changes) {
        if (changes.expanded) {
            this.updateContentState();
        }
    }
    /**
     * @hidden
     */
    sortDescriptor(field) {
        return this.ctx.grid.sort.find(item => item.field === field) || { field };
    }
    /**
     * @hidden
     */
    showSortNumbering(column) {
        const { showIndexes } = normalize$1(this.ctx.grid.sortable);
        return showIndexes
            && this.ctx.grid.sort
            && this.ctx.grid.sort.filter(({ dir }) => isPresent(dir)).length > 1
            && this.sortOrder(column.field) > 0;
    }
    /**
     * @hidden
     */
    sortOrder(field) {
        return this.ctx.grid.sort
            .filter(({ dir }) => isPresent(dir))
            .findIndex(x => x.field === field)
            + 1;
    }
    /**
     * @hidden
     */
    onClick(e) {
        this.itemClick.emit(e);
        if (this.contentTemplate) {
            if (!this.ctx.grid.isActionSheetExpanded) {
                this.expanded = !this.expanded;
                this.updateContentState();
            }
            if (this.expanded) {
                this.expand.emit();
            }
            else {
                this.collapse.emit();
            }
        }
    }
    updateContentState() {
        this.contentState = this.expanded ? 'expanded' : 'collapsed';
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnMenuItemComponent, deps: [{ token: i0.NgZone }, { token: ContextService }, { token: AdaptiveGridService }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: ColumnMenuItemComponent, isStandalone: true, selector: "kendo-grid-columnmenu-item", inputs: { icon: "icon", svgIcon: "svgIcon", indicatorIcon: "indicatorIcon", text: "text", selected: "selected", disabled: "disabled", expanded: "expanded", focused: "focused", service: "service", column: "column" }, outputs: { itemClick: "itemClick", expand: "expand", collapse: "collapse" }, queries: [{ propertyName: "contentTemplate", first: true, predicate: ColumnMenuItemContentTemplateDirective, descendants: true }], usesOnChanges: true, ngImport: i0, template: `
        @if (contentTemplate) {
          <div class="k-expander">
            <ng-container [ngTemplateOutlet]="content"></ng-container>
          </div>
        } @else {
          <div
            class="k-columnmenu-item"
            (click)="onClick($event)"
            (keydown.enter)="onClick($event)"
            [class.k-selected]="selected"
            [class.k-disabled]="disabled"
            [class.k-focus]="focused"
            role="button"
            [attr.aria-expanded]="expanded"
            [attr.aria-controls]="expanded ? contentId : undefined">
            @if (icon || svgIcon) {
              <kendo-icon-wrapper
                [name]="icon"
              [svgIcon]="svgIcon"></kendo-icon-wrapper>
            }
            {{ text }}
            @if ((ctx.grid.isActionSheetExpanded && adaptiveGridService.viewType === 'sortToolbarTool' && sortDescriptor(column.field).dir)) {
              <span
                class="k-columnmenu-indicators">
                <kendo-icon-wrapper
                  [name]="sortDescriptor(column.field).dir === 'asc' ? 'sort-asc-small' : 'sort-desc-small'"
                  [svgIcon]="sortDescriptor(column.field).dir === 'asc' ? sortAscSmallIcon : sortDescSmallIcon">
                </kendo-icon-wrapper>
                @if (showSortNumbering(column)) {
                  <span class="k-sort-index">{{sortOrder(column.field)}}</span>
                }
              </span>
            }
            @if ((ctx.grid.isActionSheetExpanded && adaptiveGridService.viewType === 'filterToolbarTool' && hasFilters) || indicatorIcon) {
              <kendo-icon-wrapper
                class="k-columnmenu-indicators"
                name="filter"
                [svgIcon]="filterIcon">
              </kendo-icon-wrapper>
            }
            @if (contentTemplate && adaptiveGridService.viewType !== 'sortToolbarTool') {
              <span class="k-spacer"></span>
            }
            @if (contentTemplate && adaptiveGridService.viewType !== 'sortToolbarTool') {
              <span class="k-expander-indicator">
                <kendo-icon-wrapper
                  [name]="expandedIcon"
                  [svgIcon]="expandedSvgIcon">
                </kendo-icon-wrapper>
              </span>
            }
          </div>
          @if (contentTemplate) {
            <div [attr.id]="contentId" [@state]="contentState" [style.overflow]="'hidden'" class="k-columnmenu-item-content">
              <ng-container [ngTemplateOutlet]="contentTemplate.templateRef">
              </ng-container>
            </div>
          }
        }
        
        <ng-template #content>
          <div
            class="k-columnmenu-item"
            (click)="onClick($event)"
            (keydown.enter)="onClick($event)"
            [class.k-selected]="selected"
            [class.k-disabled]="disabled"
            [class.k-focus]="focused"
            role="button"
            [attr.aria-expanded]="expanded"
            [attr.aria-controls]="expanded ? contentId : undefined">
            @if (icon || svgIcon) {
              <kendo-icon-wrapper
                [name]="icon"
              [svgIcon]="svgIcon"></kendo-icon-wrapper>
            }
            {{ text }}
            @if ((ctx.grid.isActionSheetExpanded && adaptiveGridService.viewType === 'sortToolbarTool' && sortDescriptor(column.field).dir)) {
              <span
                class="k-columnmenu-indicators">
                <kendo-icon-wrapper
                  [name]="sortDescriptor(column.field).dir === 'asc' ? 'sort-asc-small' : 'sort-desc-small'"
                  [svgIcon]="sortDescriptor(column.field).dir === 'asc' ? sortAscSmallIcon : sortDescSmallIcon">
                </kendo-icon-wrapper>
                @if (showSortNumbering(column)) {
                  <span class="k-sort-index">{{sortOrder(column.field)}}</span>
                }
              </span>
            }
            @if ((ctx.grid.isActionSheetExpanded && adaptiveGridService.viewType === 'filterToolbarTool' && hasFilters) || indicatorIcon) {
              <kendo-icon-wrapper
                class="k-columnmenu-indicators"
                name="filter"
                [svgIcon]="filterIcon">
              </kendo-icon-wrapper>
            }
            @if (contentTemplate && adaptiveGridService.viewType !== 'sortToolbarTool') {
              <span class="k-spacer"></span>
            }
            @if (contentTemplate && adaptiveGridService.viewType !== 'sortToolbarTool') {
              <span class="k-expander-indicator">
                <kendo-icon-wrapper
                  [name]="expandedIcon"
                  [svgIcon]="expandedSvgIcon">
                </kendo-icon-wrapper>
              </span>
            }
          </div>
          @if (contentTemplate) {
            <div [attr.id]="contentId" [@state]="contentState" [style.overflow]="'hidden'" class="k-columnmenu-item-content">
              <ng-container [ngTemplateOutlet]="contentTemplate.templateRef">
              </ng-container>
            </div>
          }
        </ng-template>
        `, isInline: true, dependencies: [{ kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }], animations: [
            trigger('state', [
                state('collapsed', style({ display: 'none' })),
                state('expanded', style({ display: 'block' })),
                transition('collapsed => expanded', [
                    style({
                        height: '0px',
                        display: 'block'
                    }),
                    animate('100ms ease-in', style({
                        height: '*'
                    }))
                ]),
                transition('expanded => collapsed', [
                    style({
                        height: '*'
                    }),
                    animate('100ms ease-in', style({
                        height: '0px'
                    }))
                ])
            ])
        ] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnMenuItemComponent, decorators: [{
            type: Component,
            args: [{
                    animations: [
                        trigger('state', [
                            state('collapsed', style({ display: 'none' })),
                            state('expanded', style({ display: 'block' })),
                            transition('collapsed => expanded', [
                                style({
                                    height: '0px',
                                    display: 'block'
                                }),
                                animate('100ms ease-in', style({
                                    height: '*'
                                }))
                            ]),
                            transition('expanded => collapsed', [
                                style({
                                    height: '*'
                                }),
                                animate('100ms ease-in', style({
                                    height: '0px'
                                }))
                            ])
                        ])
                    ],
                    selector: 'kendo-grid-columnmenu-item',
                    template: `
        @if (contentTemplate) {
          <div class="k-expander">
            <ng-container [ngTemplateOutlet]="content"></ng-container>
          </div>
        } @else {
          <div
            class="k-columnmenu-item"
            (click)="onClick($event)"
            (keydown.enter)="onClick($event)"
            [class.k-selected]="selected"
            [class.k-disabled]="disabled"
            [class.k-focus]="focused"
            role="button"
            [attr.aria-expanded]="expanded"
            [attr.aria-controls]="expanded ? contentId : undefined">
            @if (icon || svgIcon) {
              <kendo-icon-wrapper
                [name]="icon"
              [svgIcon]="svgIcon"></kendo-icon-wrapper>
            }
            {{ text }}
            @if ((ctx.grid.isActionSheetExpanded && adaptiveGridService.viewType === 'sortToolbarTool' && sortDescriptor(column.field).dir)) {
              <span
                class="k-columnmenu-indicators">
                <kendo-icon-wrapper
                  [name]="sortDescriptor(column.field).dir === 'asc' ? 'sort-asc-small' : 'sort-desc-small'"
                  [svgIcon]="sortDescriptor(column.field).dir === 'asc' ? sortAscSmallIcon : sortDescSmallIcon">
                </kendo-icon-wrapper>
                @if (showSortNumbering(column)) {
                  <span class="k-sort-index">{{sortOrder(column.field)}}</span>
                }
              </span>
            }
            @if ((ctx.grid.isActionSheetExpanded && adaptiveGridService.viewType === 'filterToolbarTool' && hasFilters) || indicatorIcon) {
              <kendo-icon-wrapper
                class="k-columnmenu-indicators"
                name="filter"
                [svgIcon]="filterIcon">
              </kendo-icon-wrapper>
            }
            @if (contentTemplate && adaptiveGridService.viewType !== 'sortToolbarTool') {
              <span class="k-spacer"></span>
            }
            @if (contentTemplate && adaptiveGridService.viewType !== 'sortToolbarTool') {
              <span class="k-expander-indicator">
                <kendo-icon-wrapper
                  [name]="expandedIcon"
                  [svgIcon]="expandedSvgIcon">
                </kendo-icon-wrapper>
              </span>
            }
          </div>
          @if (contentTemplate) {
            <div [attr.id]="contentId" [@state]="contentState" [style.overflow]="'hidden'" class="k-columnmenu-item-content">
              <ng-container [ngTemplateOutlet]="contentTemplate.templateRef">
              </ng-container>
            </div>
          }
        }
        
        <ng-template #content>
          <div
            class="k-columnmenu-item"
            (click)="onClick($event)"
            (keydown.enter)="onClick($event)"
            [class.k-selected]="selected"
            [class.k-disabled]="disabled"
            [class.k-focus]="focused"
            role="button"
            [attr.aria-expanded]="expanded"
            [attr.aria-controls]="expanded ? contentId : undefined">
            @if (icon || svgIcon) {
              <kendo-icon-wrapper
                [name]="icon"
              [svgIcon]="svgIcon"></kendo-icon-wrapper>
            }
            {{ text }}
            @if ((ctx.grid.isActionSheetExpanded && adaptiveGridService.viewType === 'sortToolbarTool' && sortDescriptor(column.field).dir)) {
              <span
                class="k-columnmenu-indicators">
                <kendo-icon-wrapper
                  [name]="sortDescriptor(column.field).dir === 'asc' ? 'sort-asc-small' : 'sort-desc-small'"
                  [svgIcon]="sortDescriptor(column.field).dir === 'asc' ? sortAscSmallIcon : sortDescSmallIcon">
                </kendo-icon-wrapper>
                @if (showSortNumbering(column)) {
                  <span class="k-sort-index">{{sortOrder(column.field)}}</span>
                }
              </span>
            }
            @if ((ctx.grid.isActionSheetExpanded && adaptiveGridService.viewType === 'filterToolbarTool' && hasFilters) || indicatorIcon) {
              <kendo-icon-wrapper
                class="k-columnmenu-indicators"
                name="filter"
                [svgIcon]="filterIcon">
              </kendo-icon-wrapper>
            }
            @if (contentTemplate && adaptiveGridService.viewType !== 'sortToolbarTool') {
              <span class="k-spacer"></span>
            }
            @if (contentTemplate && adaptiveGridService.viewType !== 'sortToolbarTool') {
              <span class="k-expander-indicator">
                <kendo-icon-wrapper
                  [name]="expandedIcon"
                  [svgIcon]="expandedSvgIcon">
                </kendo-icon-wrapper>
              </span>
            }
          </div>
          @if (contentTemplate) {
            <div [attr.id]="contentId" [@state]="contentState" [style.overflow]="'hidden'" class="k-columnmenu-item-content">
              <ng-container [ngTemplateOutlet]="contentTemplate.templateRef">
              </ng-container>
            </div>
          }
        </ng-template>
        `,
                    standalone: true,
                    imports: [IconWrapperComponent, NgTemplateOutlet]
                }]
        }], ctorParameters: () => [{ type: i0.NgZone }, { type: ContextService }, { type: AdaptiveGridService }, { type: i0.ElementRef }], propDecorators: { itemClick: [{
                type: Output
            }], expand: [{
                type: Output
            }], collapse: [{
                type: Output
            }], icon: [{
                type: Input
            }], svgIcon: [{
                type: Input
            }], indicatorIcon: [{
                type: Input
            }], text: [{
                type: Input
            }], selected: [{
                type: Input
            }], disabled: [{
                type: Input
            }], expanded: [{
                type: Input
            }], focused: [{
                type: Input
            }], service: [{
                type: Input
            }], column: [{
                type: Input
            }], contentTemplate: [{
                type: ContentChild,
                args: [ColumnMenuItemContentTemplateDirective]
            }] } });

/**
 * Represents the column-menu item for resizing all columns to the minimum possible width so that they fit the widest header or cell content without wrapping.
 * [See example](slug:columnmenu_grid#toc-autosize-all-columns-item).
 *
 * Place this component inside a [`ColumnMenuTemplate`]({% slug api_grid_columnmenutemplatedirective %}) directive.
 * To register it as a column menu item, set the [`ColumnMenuService`]({% slug api_grid_columnmenuservice %}) passed by
 * the template to the `service` input of the `kendo-grid-columnmenu-autosize-all-columns` component. [See example](slug:columnmenu_grid#toc-customizing-the-content).
 *
 * @example
 * ```html
 * <kendo-grid [columnMenu]="true" ...>
 *   <ng-template kendoGridColumnMenuTemplate let-service="service">
 *     <kendo-grid-columnmenu-autosize-all-columns [service]="service">
 *     </kendo-grid-columnmenu-autosize-all-columns>
 *   </ng-template>
 * </kendo-grid>
 * ```
 * @example
 * ```html
 * <kendo-grid-column field="ProductName">
 *   <ng-template kendoGridColumnMenuTemplate let-service="service">
 *     <kendo-grid-columnmenu-autosize-all-columns [service]="service">
 *     </kendo-grid-columnmenu-autosize-all-columns>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 */
class ColumnMenuAutoSizeAllColumnsComponent extends ColumnMenuItemBase {
    ctx;
    displayInlineFlexIcon = displayInlineFlexIcon;
    constructor(ctx) {
        super();
        this.ctx = ctx;
    }
    ngOnInit() {
        const isVirtualColumns = this.ctx.grid.columnMenuTemplate && this.ctx.grid.virtualColumns;
        if (isVirtualColumns && isDevMode()) {
            console.warn(ColumnMenuErrorMessages.autoSizeAllColumns);
        }
    }
    /**
     * Resizes all columns to the minimum possible width so that they fit the widest header or cell content without wrapping.
     */
    autoSizeAllColumns() {
        autoSizeColumn(this.ctx.grid, this.service);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnMenuAutoSizeAllColumnsComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: ColumnMenuAutoSizeAllColumnsComponent, isStandalone: true, selector: "kendo-grid-columnmenu-autosize-all-columns", usesInheritance: true, ngImport: i0, template: `
        @if (!this.ctx.grid.virtualColumns) {
          <kendo-grid-columnmenu-item
            [text]="ctx.localization.get('autosizeAllColumns')"
            icon="display-inline-flex"
            [svgIcon]="displayInlineFlexIcon"
            (itemClick)="autoSizeAllColumns()"
          ></kendo-grid-columnmenu-item>
        }
        `, isInline: true, dependencies: [{ kind: "component", type: ColumnMenuItemComponent, selector: "kendo-grid-columnmenu-item", inputs: ["icon", "svgIcon", "indicatorIcon", "text", "selected", "disabled", "expanded", "focused", "service", "column"], outputs: ["itemClick", "expand", "collapse"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnMenuAutoSizeAllColumnsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-columnmenu-autosize-all-columns',
                    template: `
        @if (!this.ctx.grid.virtualColumns) {
          <kendo-grid-columnmenu-item
            [text]="ctx.localization.get('autosizeAllColumns')"
            icon="display-inline-flex"
            [svgIcon]="displayInlineFlexIcon"
            (itemClick)="autoSizeAllColumns()"
          ></kendo-grid-columnmenu-item>
        }
        `,
                    standalone: true,
                    imports: [ColumnMenuItemComponent]
                }]
        }], ctorParameters: () => [{ type: ContextService }] });

/**
 * Represents the column-menu item for resizing the specified column to the minimum possible width so that it fits the header or cell content without wrapping.
 * [See example](slug:columnmenu_grid#toc-autosize-column-item).
 *
 * Place this component inside a [`ColumnMenuTemplate`]({% slug api_grid_columnmenutemplatedirective %}) directive.
 * Set the [`ColumnMenuService`]({% slug api_grid_columnmenuservice %}) and `column` passed by
 * the template to the `service` and `column` inputs of the `kendo-grid-columnmenu-autosize-column` component.
 *
 * @example
 * ```html
 * <kendo-grid [columnMenu]="true" ...>
 *   <ng-template kendoGridColumnMenuTemplate let-service="service" let-column="column">
 *     <kendo-grid-columnmenu-autosize-column [column]="column" [service]="service">
 *     </kendo-grid-columnmenu-autosize-column>
 *   </ng-template>
 * </kendo-grid>
 * ```
 * @example
 * ```html
 * <kendo-grid-column field="ProductName">
 *   <ng-template kendoGridColumnMenuTemplate let-service="service">
 *     <kendo-grid-columnmenu-autosize-column [column]="column" [service]="service">
 *     </kendo-grid-columnmenu-autosize-column>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 */
class ColumnMenuAutoSizeColumnComponent extends ColumnMenuItemBase {
    ctx;
    /**
     * Specifies the Grid column instance to resize with the auto size column option.
     */
    column;
    maxWidthIcon = maxWidthIcon;
    constructor(ctx) {
        super();
        this.ctx = ctx;
    }
    ngOnInit() {
        const isVirtualColumns = this.ctx.grid.columnMenuTemplate && this.ctx.grid.virtualColumns;
        if (isVirtualColumns && isDevMode()) {
            console.warn(ColumnMenuErrorMessages.autoSizeColumn);
        }
    }
    /**
     * Resizes the specified column to the minimum possible width so that it fits the widest header or cell content without wrapping.
     */
    autoSizeColumn() {
        autoSizeColumn(this.ctx.grid, this.service, this.column);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnMenuAutoSizeColumnComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: ColumnMenuAutoSizeColumnComponent, isStandalone: true, selector: "kendo-grid-columnmenu-autosize-column", inputs: { column: "column" }, usesInheritance: true, ngImport: i0, template: `
        @if (!this.ctx.grid.virtualColumns) {
          <kendo-grid-columnmenu-item
            class="k-grid-columnmenu-autosize-column"
            [text]="ctx.localization.get('autosizeThisColumn')"
            icon="max-width"
            [svgIcon]="maxWidthIcon"
            (itemClick)="autoSizeColumn()"
          ></kendo-grid-columnmenu-item>
        }
        `, isInline: true, dependencies: [{ kind: "component", type: ColumnMenuItemComponent, selector: "kendo-grid-columnmenu-item", inputs: ["icon", "svgIcon", "indicatorIcon", "text", "selected", "disabled", "expanded", "focused", "service", "column"], outputs: ["itemClick", "expand", "collapse"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnMenuAutoSizeColumnComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-columnmenu-autosize-column',
                    template: `
        @if (!this.ctx.grid.virtualColumns) {
          <kendo-grid-columnmenu-item
            class="k-grid-columnmenu-autosize-column"
            [text]="ctx.localization.get('autosizeThisColumn')"
            icon="max-width"
            [svgIcon]="maxWidthIcon"
            (itemClick)="autoSizeColumn()"
          ></kendo-grid-columnmenu-item>
        }
        `,
                    standalone: true,
                    imports: [ColumnMenuItemComponent]
                }]
        }], ctorParameters: () => [{ type: ContextService }], propDecorators: { column: [{
                type: Input
            }] } });

/**
 * Represents the column-menu item for selecting columns in the Grid. [See example](slug:columnmenu_grid#toc-column-chooser-item).
 *
 * Place this component inside a [`ColumnMenuTemplate`]({% slug api_grid_columnmenutemplatedirective %}) directive.
 * To register it as a column menu item, set the [`ColumnMenuService`]({% slug api_grid_columnmenuservice %}) passed by
 * the template to the `service` input of the `kendo-grid-columnmenu-chooser` component. [See example](slug:columnmenu_grid#toc-customizing-the-content).
 *
 * @example
 * ```html
 * <kendo-grid [columnMenu]="true" ...>
 *   <ng-template kendoGridColumnMenuTemplate let-service="service">
 *     <kendo-grid-columnmenu-chooser [service]="service"> </kendo-grid-columnmenu-chooser>
 *   </ng-template>
 * </kendo-grid>
 * ```
 * @example
 * ```html
 * <kendo-grid-column field="ProductName">
 *   <ng-template kendoGridColumnMenuTemplate let-service="service">
 *     <kendo-grid-columnmenu-chooser [service]="service"></kendo-grid-columnmenu-chooser>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 */
class ColumnMenuChooserComponent extends ColumnMenuItemBase {
    ctx;
    columnInfoService;
    hostElement;
    /**
     * Fires when the content expands.
     */
    expand = new EventEmitter();
    /**
     * Fires when the content collapses.
     */
    collapse = new EventEmitter();
    /**
     * Specifies if the content is expanded.
     * @default false
     */
    expanded = false;
    /**
     * @hidden
     */
    isLast = false;
    /**
     * @hidden
     */
    actionsClass = 'k-actions k-actions-stretched k-actions-horizontal';
    get columns() {
        return this.columnInfoService.leafNamedColumns;
    }
    columnsIcon = columnsIcon;
    constructor(ctx, columnInfoService, hostElement) {
        super();
        this.ctx = ctx;
        this.columnInfoService = columnInfoService;
        this.hostElement = hostElement;
    }
    /**
     * @hidden
     */
    onCollapse() {
        this.expanded = false;
        if (this.isLast) {
            this.service.menuTabbingService.lastFocusable = this.hostElement.nativeElement.querySelector('.k-columnmenu-item');
        }
        this.collapse.emit();
    }
    /**
     * @hidden
     */
    onExpand() {
        this.expanded = true;
        this.expand.emit();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnMenuChooserComponent, deps: [{ token: ContextService }, { token: ColumnInfoService }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: ColumnMenuChooserComponent, isStandalone: true, selector: "kendo-grid-columnmenu-chooser", inputs: { expanded: "expanded", isLast: "isLast" }, outputs: { expand: "expand", collapse: "collapse" }, usesInheritance: true, ngImport: i0, template: `
        <kendo-grid-columnmenu-item
            [text]="ctx.localization.get('columns')"
            icon="columns"
            [svgIcon]="columnsIcon"
            [expanded]="expanded"
            (collapse)="onCollapse()"
            (expand)="onExpand()">
            <ng-template kendoGridColumnMenuItemContentTemplate>
                <kendo-grid-column-chooser-content
                    [columns]="columns"
                    [isLast]="isLast"
                    [isExpanded]="expanded"
                    [closeOnReset]="false"
                    [service]="service"
                    (close)="close()"
                >
                </kendo-grid-column-chooser-content>
            </ng-template>
        </kendo-grid-columnmenu-item>
    `, isInline: true, dependencies: [{ kind: "component", type: ColumnMenuItemComponent, selector: "kendo-grid-columnmenu-item", inputs: ["icon", "svgIcon", "indicatorIcon", "text", "selected", "disabled", "expanded", "focused", "service", "column"], outputs: ["itemClick", "expand", "collapse"] }, { kind: "directive", type: ColumnMenuItemContentTemplateDirective, selector: "[kendoGridColumnMenuItemContentTemplate]" }, { kind: "component", type: ColumnChooserContentComponent, selector: "kendo-grid-column-chooser-content", inputs: ["filterable", "showSelectAll", "showCheckedCount", "allowHideAll", "autoSync", "actionsClass", "closeOnReset", "columns", "isLast", "isExpanded", "service"], outputs: ["close"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnMenuChooserComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-columnmenu-chooser',
                    template: `
        <kendo-grid-columnmenu-item
            [text]="ctx.localization.get('columns')"
            icon="columns"
            [svgIcon]="columnsIcon"
            [expanded]="expanded"
            (collapse)="onCollapse()"
            (expand)="onExpand()">
            <ng-template kendoGridColumnMenuItemContentTemplate>
                <kendo-grid-column-chooser-content
                    [columns]="columns"
                    [isLast]="isLast"
                    [isExpanded]="expanded"
                    [closeOnReset]="false"
                    [service]="service"
                    (close)="close()"
                >
                </kendo-grid-column-chooser-content>
            </ng-template>
        </kendo-grid-columnmenu-item>
    `,
                    standalone: true,
                    imports: [ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, ColumnChooserContentComponent]
                }]
        }], ctorParameters: () => [{ type: ContextService }, { type: ColumnInfoService }, { type: i0.ElementRef }], propDecorators: { expand: [{
                type: Output
            }], collapse: [{
                type: Output
            }], expanded: [{
                type: Input
            }], isLast: [{
                type: Input
            }] } });

/**
 * Represents a column-menu item for sticking or unsticking columns in the Grid.
 * [See example](slug:columnmenu_grid#toc-stick-and-unstick-items).
 *
 * Place this component inside a [`ColumnMenuTemplate`]({% slug api_grid_columnmenutemplatedirective %}) directive.
 * To register the component as a column menu item, set the [`ColumnMenuService`]({% slug api_grid_columnmenuservice %}) from the template to the `service` input of the `kendo-grid-columnmenu-stick` component.
 * [See example](slug:columnmenu_grid#toc-customizing-the-content).
 *
 * @example
 * ```html
 * <kendo-grid [data]="data" [columnMenu]="true">
 *   <ng-template kendoGridColumnMenuTemplate let-service="service">
 *      <kendo-grid-columnmenu-stick [service]="service">
 *      </kendo-grid-columnmenu-stick>
 *   </ng-template>
 * </kendo-grid>
 * ```
 * @example
 * ```html
 * <kendo-grid-column field="ProductName">
 *   <ng-template kendoGridColumnMenuTemplate let-service="service">
 *     <kendo-grid-columnmenu-stick [service]="service">
 *     </kendo-grid-columnmenu-stick>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 */
class ColumnMenuStickComponent extends ColumnMenuItemBase {
    ctx;
    columnInfoService;
    changeDetector;
    stickIcon = stickIcon;
    unstickIcon = unstickIcon;
    constructor(ctx, columnInfoService, changeDetector) {
        super();
        this.ctx = ctx;
        this.columnInfoService = columnInfoService;
        this.changeDetector = changeDetector;
    }
    get text() {
        return this.ctx.localization.get(this.sticky ? 'unstick' : 'stick');
    }
    get icon() {
        return this.sticky ? 'unstick' : 'stick';
    }
    get svgIcon() {
        return this.sticky ? this.unstickIcon : this.stickIcon;
    }
    get disabled() {
        return !this.sticky && this.columnInfoService.unlockedRootCount < 2;
    }
    /**
     * @hidden
     */
    toggleColumn() {
        this.toggleHierarchy(!this.sticky);
        this.close();
        this.changeDetector.markForCheck();
    }
    toggleHierarchy(sticky) {
        let root = this.service.column;
        while (root.parent) {
            root = root.parent;
        }
        const columns = [root];
        const allChanged = [];
        while (columns.length) {
            const column = columns.shift();
            column.sticky = sticky;
            allChanged.push(column);
            if (column.hasChildren) {
                columns.push(...column.childrenArray);
            }
        }
        this.columnInfoService.changeStuck(allChanged);
    }
    get sticky() {
        return this.service.column.sticky;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnMenuStickComponent, deps: [{ token: ContextService }, { token: ColumnInfoService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: ColumnMenuStickComponent, isStandalone: true, selector: "kendo-grid-columnmenu-stick", usesInheritance: true, ngImport: i0, template: `
        <kendo-grid-columnmenu-item
           [text]="text"
           [icon]="icon"
           [svgIcon]="svgIcon"
           (itemClick)="toggleColumn()"
           [disabled]="disabled">
        </kendo-grid-columnmenu-item>
    `, isInline: true, dependencies: [{ kind: "component", type: ColumnMenuItemComponent, selector: "kendo-grid-columnmenu-item", inputs: ["icon", "svgIcon", "indicatorIcon", "text", "selected", "disabled", "expanded", "focused", "service", "column"], outputs: ["itemClick", "expand", "collapse"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnMenuStickComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-columnmenu-stick',
                    template: `
        <kendo-grid-columnmenu-item
           [text]="text"
           [icon]="icon"
           [svgIcon]="svgIcon"
           (itemClick)="toggleColumn()"
           [disabled]="disabled">
        </kendo-grid-columnmenu-item>
    `,
                    standalone: true,
                    imports: [ColumnMenuItemComponent]
                }]
        }], ctorParameters: () => [{ type: ContextService }, { type: ColumnInfoService }, { type: i0.ChangeDetectorRef }] });

/**
 * Represents the column-menu item for locking and unlocking columns in the Grid. [See example](slug:columnmenu_grid#toc-lock-and-unlock-items).
 *
 * Place this component inside a [`ColumnMenuTemplate`]({% slug api_grid_columnmenutemplatedirective %}) directive.
 * To register the component as a known column menu item, set the [`ColumnMenuService`]({% slug api_grid_columnmenuservice %}) that the template passes to the `service` input of the `kendo-grid-columnmenu-lock` component. [See example](slug:columnmenu_grid#toc-customizing-the-content).
 *
 * @example
 * ```html
 * <kendo-grid [data]="data" [columnMenu]="true" ...>
 *   <ng-template kendoGridColumnMenuTemplate let-service="service">
 *     <kendo-grid-columnmenu-lock [service]="service">
 *     </kendo-grid-columnmenu-lock>
 *   </ng-template>
 * </kendo-grid>
 * ```
 * @example
 * ```html
 * <kendo-grid-column field="ProductName">
 *   <ng-template kendoGridColumnMenuTemplate let-service="service">
 *     <kendo-grid-columnmenu-lock [service]="service">
 *     </kendo-grid-columnmenu-lock>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 */
class ColumnMenuLockComponent extends ColumnMenuItemBase {
    ctx;
    columnInfoService;
    changeDetector;
    constructor(ctx, columnInfoService, changeDetector) {
        super();
        this.ctx = ctx;
        this.columnInfoService = columnInfoService;
        this.changeDetector = changeDetector;
    }
    get text() {
        return this.ctx.localization.get(this.locked ? 'unlock' : 'lock');
    }
    get icon() {
        return this.locked ? 'unlock' : 'lock';
    }
    unlockIcon = unlockIcon;
    lockIcon = lockIcon;
    get svgIcon() {
        return this.locked ? this.unlockIcon : this.lockIcon;
    }
    get disabled() {
        return !this.locked && this.columnInfoService.unlockedRootCount < 2;
    }
    /**
     * @hidden
     */
    toggleColumn() {
        this.toggleHierarchy(!this.locked);
        this.close();
        this.changeDetector.markForCheck();
    }
    toggleHierarchy(locked) {
        let root = this.service.column;
        while (root.parent) {
            root = root.parent;
        }
        const columns = [root];
        const allChanged = [];
        while (columns.length) {
            const column = columns.shift();
            column.locked = locked;
            allChanged.push(column);
            if (column.hasChildren) {
                columns.push(...column.childrenArray);
            }
        }
        this.columnInfoService.changeLocked(allChanged);
    }
    get locked() {
        return this.service.column.locked;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnMenuLockComponent, deps: [{ token: ContextService }, { token: ColumnInfoService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: ColumnMenuLockComponent, isStandalone: true, selector: "kendo-grid-columnmenu-lock", usesInheritance: true, ngImport: i0, template: `
       <kendo-grid-columnmenu-item
            [text]="text"
            [icon]="icon"
            [svgIcon]="svgIcon"
            (itemClick)="toggleColumn()"
            [disabled]="disabled">
       </kendo-grid-columnmenu-item>
    `, isInline: true, dependencies: [{ kind: "component", type: ColumnMenuItemComponent, selector: "kendo-grid-columnmenu-item", inputs: ["icon", "svgIcon", "indicatorIcon", "text", "selected", "disabled", "expanded", "focused", "service", "column"], outputs: ["itemClick", "expand", "collapse"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnMenuLockComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-columnmenu-lock',
                    template: `
       <kendo-grid-columnmenu-item
            [text]="text"
            [icon]="icon"
            [svgIcon]="svgIcon"
            (itemClick)="toggleColumn()"
            [disabled]="disabled">
       </kendo-grid-columnmenu-item>
    `,
                    standalone: true,
                    imports: [ColumnMenuItemComponent]
                }]
        }], ctorParameters: () => [{ type: ContextService }, { type: ColumnInfoService }, { type: i0.ChangeDetectorRef }] });

/**
 * Represents the column-menu item that combines lock and sticky column functionalities.
 *
 * Place this component inside a [`ColumnMenuTemplate`]({% slug api_grid_columnmenutemplatedirective %}) directive.
 * To register the component as a known column menu item, set the [`ColumnMenuService`]({% slug api_grid_columnmenuservice %}) that the template passes to the `service` input of the `kendo-grid-columnmenu-position` component. [See example](slug:columnmenu_grid#toc-set-column-position-item).
 *
 * @example
 * ```html
 * <kendo-grid [data]="data" [columnMenu]="true" ...>
 *   <ng-template kendoGridColumnMenuTemplate let-service="service" let-column="column">
 *     <kendo-grid-columnmenu-position [service]="service" [showLock]="true" [showStick]="true">
 *     </kendo-grid-columnmenu-position>
 *   </ng-template>
 * </kendo-grid>
 * ```
 * @example
 * ```html
 * <kendo-grid-column field="ProductName">
 *   <ng-template kendoGridColumnMenuTemplate let-service="service">
 *     <kendo-grid-columnmenu-position [service]="service" [showLock]="true" [showStick]="true">
 *     </kendo-grid-columnmenu-position>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 */
class ColumnMenuPositionComponent extends ColumnMenuItemBase {
    ctx;
    hostElement;
    /**
     * Emits when the content expands.
     */
    expand = new EventEmitter();
    /**
     * Emits when the content collapses.
     */
    collapse = new EventEmitter();
    /**
     * Specifies if the content is expanded.
     * @default false
     */
    expanded = false;
    /**
     * Specifies if the lock column item is shown.
     */
    showLock;
    /**
     * Specifies if the stick column item is shown.
     */
    showStick;
    /**
     * @hidden
     */
    actionsClass = 'k-actions';
    /**
     * @hidden
     */
    set isLast(value) {
        this.service.menuTabbingService.lastFocusable = this.getLastFocusableItem();
        this._isLast = value;
    }
    /**
     * @hidden
     */
    get isLast() {
        return this._isLast;
    }
    setColumnPositionIcon = setColumnPositionIcon;
    _isLast = false;
    constructor(ctx, hostElement) {
        super();
        this.ctx = ctx;
        this.hostElement = hostElement;
    }
    /**
     * @hidden
     */
    onTab(e, isLastItem) {
        if (this.isLast && isLastItem) {
            e.preventDefault();
            e.stopImmediatePropagation();
            if (this.service) {
                this.service.menuTabbingService.firstFocusable.focus();
            }
        }
    }
    /**
     * @hidden
     */
    onCollapse() {
        this.expanded = false;
        if (this.isLast) {
            this.service.menuTabbingService.lastFocusable = this.getLastFocusableItem();
        }
        this.collapse.emit();
    }
    /**
     * @hidden
     */
    onExpand() {
        this.expanded = true;
        if (this.isLast) {
            this.service.menuTabbingService.lastFocusable = this.getLastFocusableItem();
        }
        this.expand.emit();
    }
    getLastFocusableItem() {
        const menuItems = this.hostElement.nativeElement.querySelectorAll('.k-columnmenu-item');
        const lastFocusableIndex = this.expanded ? menuItems.length - 1 : 0;
        return menuItems[lastFocusableIndex];
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnMenuPositionComponent, deps: [{ token: ContextService }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: ColumnMenuPositionComponent, isStandalone: true, selector: "kendo-grid-columnmenu-position", inputs: { expanded: "expanded", showLock: "showLock", showStick: "showStick", isLast: "isLast" }, outputs: { expand: "expand", collapse: "collapse" }, usesInheritance: true, ngImport: i0, template: `
        <kendo-grid-columnmenu-item
          [text]="ctx.localization.get('setColumnPosition')"
          icon="set-column-position"
          [svgIcon]="setColumnPositionIcon"
          [expanded]="expanded"
          (keydown.tab)="onTab($event, !expanded)"
          (collapse)="onCollapse()"
          (expand)="onExpand()">
          <ng-template kendoGridColumnMenuItemContentTemplate>
            @if (showLock) {
              <kendo-grid-columnmenu-lock
                (keydown.tab)="onTab($event, !showStick)"
                [service]="service">
              </kendo-grid-columnmenu-lock>
            }
            @if (showStick) {
              <kendo-grid-columnmenu-stick
                (keydown.tab)="onTab($event, true)"
                [service]="service">
              </kendo-grid-columnmenu-stick>
            }
          </ng-template>
        </kendo-grid-columnmenu-item>
        `, isInline: true, dependencies: [{ kind: "component", type: ColumnMenuItemComponent, selector: "kendo-grid-columnmenu-item", inputs: ["icon", "svgIcon", "indicatorIcon", "text", "selected", "disabled", "expanded", "focused", "service", "column"], outputs: ["itemClick", "expand", "collapse"] }, { kind: "directive", type: ColumnMenuItemContentTemplateDirective, selector: "[kendoGridColumnMenuItemContentTemplate]" }, { kind: "component", type: ColumnMenuLockComponent, selector: "kendo-grid-columnmenu-lock" }, { kind: "component", type: ColumnMenuStickComponent, selector: "kendo-grid-columnmenu-stick" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnMenuPositionComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-columnmenu-position',
                    template: `
        <kendo-grid-columnmenu-item
          [text]="ctx.localization.get('setColumnPosition')"
          icon="set-column-position"
          [svgIcon]="setColumnPositionIcon"
          [expanded]="expanded"
          (keydown.tab)="onTab($event, !expanded)"
          (collapse)="onCollapse()"
          (expand)="onExpand()">
          <ng-template kendoGridColumnMenuItemContentTemplate>
            @if (showLock) {
              <kendo-grid-columnmenu-lock
                (keydown.tab)="onTab($event, !showStick)"
                [service]="service">
              </kendo-grid-columnmenu-lock>
            }
            @if (showStick) {
              <kendo-grid-columnmenu-stick
                (keydown.tab)="onTab($event, true)"
                [service]="service">
              </kendo-grid-columnmenu-stick>
            }
          </ng-template>
        </kendo-grid-columnmenu-item>
        `,
                    standalone: true,
                    imports: [ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, ColumnMenuLockComponent, ColumnMenuStickComponent]
                }]
        }], ctorParameters: () => [{ type: ContextService }, { type: i0.ElementRef }], propDecorators: { expand: [{
                type: Output
            }], collapse: [{
                type: Output
            }], expanded: [{
                type: Input
            }], showLock: [{
                type: Input
            }], showStick: [{
                type: Input
            }], isLast: [{
                type: Input
            }] } });

/**
 * Represents the column-menu item for editing column filters in the Grid. [See example](slug:columnmenu_grid#toc-filter-item).
 *
 * Place this component inside a [`ColumnMenuTemplate`]({% slug api_grid_columnmenutemplatedirective %}) directive.
 * To register the component as a known column menu item, set the [`ColumnMenuService`]({% slug api_grid_columnmenuservice %}) that the template passes to the `service` input of the `kendo-grid-columnmenu-filter` component. [See example](slug:columnmenu_grid#toc-customizing-the-content).
 *
 * @example
 * ```html
 * <kendo-grid [columnMenu]="true" ...>
 *   <ng-template kendoGridColumnMenuTemplate let-service="service">
 *     <kendo-grid-columnmenu-filter [service]="service">
 *     </kendo-grid-columnmenu-filter>
 *   </ng-template>
 * </kendo-grid>
 * ```
 * @example
 * ```html
 * <kendo-grid-column field="ProductName">
 *   <ng-template kendoGridColumnMenuTemplate let-service="service">
 *     <kendo-grid-columnmenu-filter [service]="service">
 *     </kendo-grid-columnmenu-filter>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 */
class ColumnMenuFilterComponent extends ColumnMenuItemBase {
    ctx;
    hostElement;
    /**
     * Emits when the content expands.
     */
    expand = new EventEmitter();
    /**
     * Emits when the content collapses.
     */
    collapse = new EventEmitter();
    /**
     * Specifies if the content is expanded.
     * @default false
     */
    expanded = false;
    /**
     * Specifies if this is the last item in the menu.
     * @hidden
     */
    isLast = false;
    /**
     * Sets the CSS class for the actions container.
     * @hidden
     */
    actionsClass = 'k-actions k-actions-stretched k-actions-horizontal';
    /**
     * Defines the SVG icon for the filter.
     */
    filterIcon = filterIcon;
    constructor(ctx, hostElement) {
        super();
        this.ctx = ctx;
        this.hostElement = hostElement;
    }
    /**
     * @hidden
     */
    onCollapse() {
        this.expanded = false;
        if (this.isLast) {
            this.service.menuTabbingService.lastFocusable = this.hostElement.nativeElement.querySelector('.k-columnmenu-item');
        }
        this.collapse.emit();
    }
    /**
     * @hidden
     */
    onExpand() {
        this.expanded = true;
        this.expand.emit();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnMenuFilterComponent, deps: [{ token: ContextService }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: ColumnMenuFilterComponent, isStandalone: true, selector: "kendo-grid-columnmenu-filter", inputs: { expanded: "expanded", isLast: "isLast" }, outputs: { expand: "expand", collapse: "collapse" }, usesInheritance: true, ngImport: i0, template: `
        <kendo-grid-columnmenu-item
            [text]="ctx.localization.get('filter')"
            icon="filter"
            [svgIcon]="filterIcon"
            [expanded]="expanded"
            (collapse)="onCollapse()"
            (expand)="onExpand()">
            <ng-template kendoGridColumnMenuItemContentTemplate>
                <kendo-grid-filter-menu-container
                    [column]="service.column"
                    [menuTabbingService]="service.menuTabbingService"
                    [filter]="service.filter"
                    [actionsClass]="actionsClass"
                    [isLast]="isLast"
                    [isExpanded]="expanded"
                    (keydown.shift.tab)="$event.stopImmediatePropagation()"
                    (close)="close()">
                </kendo-grid-filter-menu-container>
            </ng-template>
        </kendo-grid-columnmenu-item>
    `, isInline: true, dependencies: [{ kind: "component", type: ColumnMenuItemComponent, selector: "kendo-grid-columnmenu-item", inputs: ["icon", "svgIcon", "indicatorIcon", "text", "selected", "disabled", "expanded", "focused", "service", "column"], outputs: ["itemClick", "expand", "collapse"] }, { kind: "directive", type: ColumnMenuItemContentTemplateDirective, selector: "[kendoGridColumnMenuItemContentTemplate]" }, { kind: "component", type: FilterMenuContainerComponent, selector: "kendo-grid-filter-menu-container", inputs: ["column", "isLast", "isExpanded", "menuTabbingService", "filter", "actionsClass"], outputs: ["close"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnMenuFilterComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-columnmenu-filter',
                    template: `
        <kendo-grid-columnmenu-item
            [text]="ctx.localization.get('filter')"
            icon="filter"
            [svgIcon]="filterIcon"
            [expanded]="expanded"
            (collapse)="onCollapse()"
            (expand)="onExpand()">
            <ng-template kendoGridColumnMenuItemContentTemplate>
                <kendo-grid-filter-menu-container
                    [column]="service.column"
                    [menuTabbingService]="service.menuTabbingService"
                    [filter]="service.filter"
                    [actionsClass]="actionsClass"
                    [isLast]="isLast"
                    [isExpanded]="expanded"
                    (keydown.shift.tab)="$event.stopImmediatePropagation()"
                    (close)="close()">
                </kendo-grid-filter-menu-container>
            </ng-template>
        </kendo-grid-columnmenu-item>
    `,
                    standalone: true,
                    imports: [ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, FilterMenuContainerComponent]
                }]
        }], ctorParameters: () => [{ type: ContextService }, { type: i0.ElementRef }], propDecorators: { expand: [{
                type: Output
            }], collapse: [{
                type: Output
            }], expanded: [{
                type: Input
            }], isLast: [{
                type: Input
            }] } });

/**
 * Represents a directive that manages keyboard navigation for a column menu item ([see example](slug:columnmenu_grid#customizing-the-content)).
 *
 * @example
 * ```html
 * <ng-template kendoGridColumnMenuTemplate let-service="service" let-column="column">
 *   <kendo-grid-columnmenu-sort #sortItem [kendoGridColumnMenuItem]="sortItem" [service]="service"></kendo-grid-columnmenu-sort>
 * </ng-template>
 * ```
 * @remarks
 * Applied to:
 * {@link ColumnMenuChooserComponent},
 * {@link ColumnMenuFilterComponent},
 * {@link ColumnMenuSortComponent},
 * {@link ColumnMenuLockComponent},
 * {@link ColumnMenuStickyComponent},
 * {@link ColumnMenuComponent},
 * {@link ColumnMenuItemComponent},
 * {@link ColumnMenuPositionComponent},
 * {@link ColumnMenuAutoSizeAllColumnsComponent},
 * {@link ColumnMenuAutoSizeColumnComponent}.
 */
class ColumnMenuItemDirective {
    hostElement;
    renderer;
    ngZone;
    cdr;
    ctx;
    /**
     * Reference to the Grid column menu item. Required when you want to include the item in the built-in keyboard navigation.
     */
    menuItemComponent;
    /**
     * Holds the first focusable element.
     */
    firstFocusableElement;
    /**
     * Holds the last focusable element.
     */
    lastFocusableElement;
    /**
     * @hidden
     */
    set isFirst(value) {
        if (value) {
            const focusableElement = this.columnMenuItems[0];
            this.menuItemComponent.service.menuTabbingService.firstFocusable = focusableElement;
            this.ngZone.runOutsideAngular(() => {
                const firstItemKeydownSub = this.renderer.listen(focusableElement, 'keydown', this.onTab);
                this.subs.add(firstItemKeydownSub);
            });
        }
        this._isFirst = value;
    }
    /**
     * @hidden
     */
    get isFirst() {
        return this._isFirst;
    }
    /**
     * @hidden
     */
    set isLast(value) {
        if (!this.columnMenuItems) {
            return;
        }
        if (value) {
            const lastFocusableElement = this.getLastColumnMenuItem();
            this.menuItemComponent.service.menuTabbingService.lastFocusable = lastFocusableElement;
            this.ngZone.runOutsideAngular(() => {
                const lastItemKeydownSub = this.renderer.listen(lastFocusableElement, 'keydown', this.onTab);
                this.subs.add(lastItemKeydownSub);
            });
            if (this.isExpandableItem()) {
                this.menuItemComponent.isLast = true;
                if (this.ctx.grid.isActionSheetExpanded) {
                    this.cdr.detectChanges();
                }
            }
        }
        this._isLast = value;
    }
    /**
     * @hidden
     */
    get isLast() {
        return this._isLast;
    }
    _isFirst = false;
    _isLast = false;
    columnMenuItems;
    subs = new Subscription();
    constructor(hostElement, renderer, ngZone, cdr, ctx) {
        this.hostElement = hostElement;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.cdr = cdr;
        this.ctx = ctx;
    }
    ngAfterViewInit() {
        this.columnMenuItems = this.hostElement.nativeElement.querySelectorAll('.k-columnmenu-item');
        [].slice.apply(this.columnMenuItems).forEach(el => this.renderer.setAttribute(el, 'tabindex', '0'));
        if (this.menuItemComponent instanceof ColumnMenuFilterComponent) {
            this.menuItemComponent.service.menuTabbingService.isColumnMenu = true;
        }
        this.menuItemComponent.service?.columnMenuContainer?.templateMenuItems.push(this);
    }
    ngOnDestroy() {
        if (this.subs) {
            this.subs.unsubscribe();
        }
    }
    onTab = (e) => {
        if (e.code !== Keys.Tab) {
            return;
        }
        if (this.isFirst && e.shiftKey && e.target === this.columnMenuItems[0]) {
            e.preventDefault();
            this.menuItemComponent.service.menuTabbingService.lastFocusable.focus();
        }
        if (this.isLast && !e.shiftKey) {
            const lastColumnMenuItem = this.getLastColumnMenuItem();
            const isExpanded = this.menuItemComponent.expanded;
            if (lastColumnMenuItem === e.target && !isExpanded) {
                e.preventDefault();
                this.menuItemComponent.service.menuTabbingService.firstFocusable.focus();
            }
        }
    };
    getLastColumnMenuItem() {
        return (this.columnMenuItems.length === 1 ? this.columnMenuItems[0] : this.columnMenuItems[1]);
    }
    isExpandableItem() {
        return this.menuItemComponent instanceof ColumnMenuFilterComponent ||
            this.menuItemComponent instanceof ColumnMenuChooserComponent ||
            this.menuItemComponent instanceof ColumnMenuPositionComponent;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnMenuItemDirective, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }, { token: i0.NgZone }, { token: i0.ChangeDetectorRef }, { token: ContextService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: ColumnMenuItemDirective, isStandalone: true, selector: "[kendoGridColumnMenuItem]", inputs: { menuItemComponent: ["kendoGridColumnMenuItem", "menuItemComponent"] }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnMenuItemDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridColumnMenuItem]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }, { type: ContextService }], propDecorators: { menuItemComponent: [{
                type: Input,
                args: ['kendoGridColumnMenuItem']
            }] } });

/**
 * @hidden
 */
class ColumnMenuContainerComponent {
    service;
    ngZone;
    columnMenuItems;
    templateMenuItems = [];
    constructor(service, ngZone) {
        this.service = service;
        this.ngZone = ngZone;
        service.columnMenuContainer = this;
    }
    ngAfterViewInit() {
        if (this.columnMenuItems.length) {
            this.columnMenuItems.first.isFirst = true;
            this.columnMenuItems.last.isLast = true;
        }
        else if (this.templateMenuItems.length) {
            this.templateMenuItems[0].isFirst = true;
            this.templateMenuItems[this.templateMenuItems.length - 1].isLast = true;
        }
        else {
            return;
        }
        this.ngZone.onStable.pipe(take(1)).subscribe(() => {
            const firstFocusable = this.service.menuTabbingService.firstFocusable;
            if (firstFocusable instanceof DropDownListComponent) {
                firstFocusable.wrapper.nativeElement.focus({ preventScroll: true });
            }
            else {
                firstFocusable?.focus({ preventScroll: true });
            }
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnMenuContainerComponent, deps: [{ token: ColumnMenuService }, { token: NgZone }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: ColumnMenuContainerComponent, isStandalone: true, selector: "kendo-grid-columnmenu-container", queries: [{ propertyName: "columnMenuItems", predicate: ColumnMenuItemDirective, descendants: true }], ngImport: i0, template: `
        <ng-content></ng-content>
    `, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnMenuContainerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-columnmenu-container',
                    template: `
        <ng-content></ng-content>
    `,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: ColumnMenuService }, { type: i0.NgZone, decorators: [{
                    type: Inject,
                    args: [NgZone]
                }] }], propDecorators: { columnMenuItems: [{
                type: ContentChildren,
                args: [ColumnMenuItemDirective, { descendants: true }]
            }] } });

/**
 * @hidden
 */
class SortService {
    changes = new Subject();
    sort(value) {
        this.changes.next(value);
    }
}

/**
 * Represents the column-menu item for sorting Grid columns.
 *
 * Provides sorting options (ascending and descending) for a specific column in the Grid.
 * Place this component inside a [`ColumnMenuTemplate`]({% slug api_grid_columnmenutemplatedirective %}) directive and pass the [`ColumnMenuService`]({% slug api_grid_columnmenuservice %}) to the `service` input of the `kendo-grid-columnmenu-sort` component.
 *
 * @example
 * ```html
 * <kendo-grid [kendoGridBinding]="data" [sortable]="true" [columnMenu]="true">
 *   <ng-template kendoGridColumnMenuTemplate let-service="service">
 *     <kendo-grid-columnmenu-sort [service]="service"></kendo-grid-columnmenu-sort>
 *   </ng-template>
 * </kendo-grid>
 * ```
 * @example
 * ```html
 * <kendo-grid-column field="ProductName">
 *   <ng-template kendoGridColumnMenuTemplate let-service="service">
 *     <kendo-grid-columnmenu-sort [service]="service"></kendo-grid-columnmenu-sort>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 */
class ColumnMenuSortComponent extends ColumnMenuItemBase {
    ctx;
    sortService;
    renderer;
    sortAscSmallIcon = sortAscSmallIcon;
    sortDescSmallIcon = sortDescSmallIcon;
    constructor(ctx, sortService, renderer) {
        super();
        this.ctx = ctx;
        this.sortService = sortService;
        this.renderer = renderer;
    }
    get sortedAsc() {
        return this.descriptor?.dir === 'asc';
    }
    get sortedDesc() {
        return this.descriptor?.dir === 'desc';
    }
    /**
     * @hidden
     */
    toggleSort(dir) {
        const field = this.service.column.field;
        const { mode, allowUnsort } = normalize$1(this.service.sortable);
        const descriptor = this.descriptor;
        const sort = mode === 'multiple' ? this.service.sort.filter(s => s.field !== field) : [];
        if (descriptor && descriptor.dir === dir) {
            if (!allowUnsort) {
                return;
            }
        }
        else {
            sort.push({ field, dir });
        }
        this.sortService.sort(sort);
        this.close();
    }
    get descriptor() {
        return [].concat(this.service.sort || []).find(s => s.field === this.service.column.field);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnMenuSortComponent, deps: [{ token: ContextService }, { token: SortService }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: ColumnMenuSortComponent, isStandalone: true, selector: "kendo-grid-columnmenu-sort", usesInheritance: true, ngImport: i0, template: `
        <kendo-grid-columnmenu-item
            [text]="ctx.localization.get('sortAscending')"
            icon="sort-asc-small"
            [svgIcon]="sortAscSmallIcon"
            (itemClick)="toggleSort('asc')"
            [selected]="sortedAsc">
        </kendo-grid-columnmenu-item>
        <kendo-grid-columnmenu-item
            [text]="ctx.localization.get('sortDescending')"
            icon="sort-desc-small"
            [svgIcon]="sortDescSmallIcon"
            (itemClick)="toggleSort('desc')"
            [selected]="sortedDesc">
        </kendo-grid-columnmenu-item>
    `, isInline: true, dependencies: [{ kind: "component", type: ColumnMenuItemComponent, selector: "kendo-grid-columnmenu-item", inputs: ["icon", "svgIcon", "indicatorIcon", "text", "selected", "disabled", "expanded", "focused", "service", "column"], outputs: ["itemClick", "expand", "collapse"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnMenuSortComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-columnmenu-sort',
                    template: `
        <kendo-grid-columnmenu-item
            [text]="ctx.localization.get('sortAscending')"
            icon="sort-asc-small"
            [svgIcon]="sortAscSmallIcon"
            (itemClick)="toggleSort('asc')"
            [selected]="sortedAsc">
        </kendo-grid-columnmenu-item>
        <kendo-grid-columnmenu-item
            [text]="ctx.localization.get('sortDescending')"
            icon="sort-desc-small"
            [svgIcon]="sortDescSmallIcon"
            (itemClick)="toggleSort('desc')"
            [selected]="sortedDesc">
        </kendo-grid-columnmenu-item>
    `,
                    standalone: true,
                    imports: [ColumnMenuItemComponent]
                }]
        }], ctorParameters: () => [{ type: ContextService }, { type: SortService }, { type: i0.Renderer2 }] });

const POPUP_CLASSES = 'k-grid-columnmenu-popup k-column-menu';
let id = 0;
const getId = (gridId) => `${gridId}-column-menu-${id++}`;
/**
 * Represents the [column menu](slug:columnmenu_grid#toc-customizing-the-position) component.
 *
 * @example
 * ```html
 * <kendo-grid ...>
 *   <kendo-grid-column field="ProductName" [columnMenu]="false">
 *     <ng-template kendoGridHeaderTemplate let-column>
 *       <kendo-grid-column-menu [column]="column"></kendo-grid-column-menu>
 *     </ng-template>
 *   </kendo-grid-column>
 * </kendo-grid>
 * ```
 * @example
 * ```html
 * <kendo-grid-column field="ProductName">
 *   <ng-template kendoGridColumnMenuTemplate let-service="service">
 *     <kendo-grid-column-menu [column]="column"></kendo-grid-column-menu>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 */
class ColumnMenuComponent {
    navigationService;
    popupService;
    service;
    ctx;
    renderer;
    cdr;
    columnInfoService;
    idService;
    adaptiveGridService;
    /**
     * @hidden
     */
    standalone = true;
    /**
     * The Grid column instance controlled by the menu.
     */
    column;
    /**
     * The settings for the column menu.
     */
    settings = {};
    /**
     * The sort descriptors for the Grid data.
     * Typically bound to [`GridComponent.sort`]({% slug api_grid_gridcomponent %}#toc-sort).
     */
    sort;
    /**
     * The filter descriptor for the Grid data.
     * Typically bound to [`GridComponent.filter`]({% slug api_grid_gridcomponent %}#toc-filter).
     */
    filter;
    /**
     * @hidden
     */
    sortable = true;
    /**
     * @hidden
     */
    columnMenuTemplate;
    /**
     * @hidden
     */
    tabIndex = '-1';
    anchor;
    template;
    defaultTemplate;
    tabbedInterfaceTemplate;
    tabStrip;
    /**
     * @hidden
     */
    columnsIcon = columnsIcon;
    /**
     * @hidden
     */
    actionsClass = 'k-actions';
    /**
     * @hidden
     */
    slidersIcon = slidersIcon;
    /**
     * @hidden
     */
    filterIcon = filterIcon;
    /**
     * @hidden
     */
    expandedFilter = false;
    /**
     * @hidden
     */
    expandedColumns = false;
    /**
     * @hidden
     */
    expandedPosition = false;
    /**
     * @hidden
     */
    get showGeneralTab() {
        return this.hasSort
            || this.hasLock
            || this.hasStick
            || this.hasPosition
            || this.hasAutoSizeColumn
            || this.hasAutoSizeAllColumns;
    }
    moreVerticalIcon = moreVerticalIcon;
    popupRef;
    closeSubscription;
    popupSubs;
    constructor(navigationService, popupService, service, ctx, renderer, cdr, columnInfoService, idService, adaptiveGridService) {
        this.navigationService = navigationService;
        this.popupService = popupService;
        this.service = service;
        this.ctx = ctx;
        this.renderer = renderer;
        this.cdr = cdr;
        this.columnInfoService = columnInfoService;
        this.idService = idService;
        this.adaptiveGridService = adaptiveGridService;
        this.closeSubscription = service.closeMenu.subscribe(this.close.bind(this, true));
    }
    /**
     * @hidden
     */
    get isActive() {
        return (this.hasFilter && filtersByField(this.filter, this.column.field).length > 0) ||
            (!this.sortable && this.hasSort && this.sort.find(descriptor => descriptor.field === this.column.field));
    }
    /**
     * @hidden
     */
    get hasFilter() {
        return hasFilter(this.settings, this.column);
    }
    /**
     * @hidden
     */
    get isNavigable() {
        return this.navigationService.tableEnabled;
    }
    /**
     * @hidden
     */
    get hasSort() {
        return hasSort(this.settings, this.column);
    }
    /**
     * @hidden
     */
    get hasColumnChooser() {
        return hasColumnChooser(this.settings);
    }
    /**
     * @hidden
     */
    get hasAutoSizeColumn() {
        return hasAutoSizeColumn(this.settings);
    }
    /**
     * @hidden
     */
    get hasAutoSizeAllColumns() {
        return hasAutoSizeAllColumns(this.settings);
    }
    /**
     * @hidden
     */
    get hasLock() {
        return hasLock(this.settings, this.column);
    }
    /**
     * @hidden
     */
    get hasStick() {
        return hasStick(this.settings, this.column);
    }
    /**
     * @hidden
     */
    get hasPosition() {
        return hasPosition(this.settings, this.column);
    }
    /**
     * @hidden
     */
    get columns() {
        return this.columnInfoService.leafNamedColumns;
    }
    ngAfterViewInit() {
        if (this.ctx.grid.virtualColumns && isDevMode()) {
            if (this.settings.autoSizeAllColumns) {
                this.settings.autoSizeAllColumns = false;
                console.warn(ColumnMenuErrorMessages.autoSizeAllColumns);
            }
            if (this.settings.autoSizeColumn) {
                this.settings.autoSizeColumn = false;
                console.warn(ColumnMenuErrorMessages.autoSizeColumn);
            }
        }
        this.service.menuTabbingService.isTabbedInterface = this.settings.view === 'tabbed' ? true : false;
    }
    ngOnChanges() {
        this.service.column = this.column;
        this.service.sort = this.sort;
        this.service.filter = this.filter;
        this.service.sortable = this.sortable;
    }
    ngOnDestroy() {
        this.close();
        this.closeSubscription.unsubscribe();
        this.popupSubs?.unsubscribe();
        this.closeSubscription = this.popupSubs = null;
    }
    /**
     * @hidden
     */
    toggle(e, anchor, template) {
        if (e) {
            e.preventDefault();
            e instanceof KeyboardEvent && e.stopImmediatePropagation();
        }
        if (this.ctx.grid.adaptiveMode === 'auto' && this.adaptiveGridService.windowSize !== 'large') {
            if (!this.ctx.grid.isActionSheetExpanded) {
                this.adaptiveGridService.viewType = 'columnMenu';
                this.adaptiveGridService.columns = this.columns;
                this.adaptiveGridService.columnMenuService = this.service;
                this.adaptiveGridService.column = this.column;
                this.ctx.grid.adaptiveRenderer.actionSheet.toggle(true);
            }
        }
        else {
            this.expandedFilter = this.getExpandedState(this.settings.filter);
            this.expandedColumns = this.getExpandedState(this.settings.columnChooser);
            this.expandedPosition = this.getExpandedState(this.settings.setColumnPosition);
            this.popupRef = this.popupService.open(anchor, template, this.popupRef, POPUP_CLASSES);
            // Needed as changes to 'popupRef' and 'popupId' are not reflected
            // automatically when the Popup is closed by clicking outside the anchor
            const ariaRoot = this.isNavigable ? anchor.closest('.k-table-th') : anchor;
            if (this.popupRef) {
                this.popupSubs?.unsubscribe();
                this.popupSubs = this.popupRef.popup.instance.anchorViewportLeave.subscribe(() => {
                    this.popupSubs?.unsubscribe();
                    this.popupSubs = null;
                    this.close(true);
                    this.updateAria(ariaRoot);
                });
                this.popupSubs.add(() => this.popupRef.popup.instance.close.subscribe(() => {
                    this.popupSubs?.unsubscribe();
                    this.popupSubs = this.popupRef = null;
                    this.updateAria(ariaRoot);
                }));
                const popupAriaElement = this.popupRef.popupElement.querySelector('.k-grid-columnmenu-popup');
                if (popupAriaElement) {
                    const popupId = getId(this.idService?.gridId());
                    this.renderer.setAttribute(popupAriaElement, 'id', popupId);
                    this.renderer.setAttribute(popupAriaElement, 'role', 'dialog');
                    this.renderer.setAttribute(popupAriaElement, 'aria-label', this.columnMenuTitle);
                    ariaRoot && this.renderer.setAttribute(ariaRoot, 'aria-controls', popupId);
                    ariaRoot && this.renderer.setAttribute(ariaRoot, 'aria-expanded', 'true');
                }
                if (this.settings.view === 'tabbed') {
                    this.renderer.addClass(popupAriaElement, 'k-column-menu-tabbed');
                    this.renderer.addClass(popupAriaElement, 'k-column-menu');
                    this.cdr.detectChanges();
                    this.tabStrip?.selectTab(0);
                }
            }
            else {
                this.focusRoot();
            }
        }
    }
    /**
     * @hidden
     */
    close(triggerFocus = false) {
        if (this.ctx.grid.adaptiveMode === 'auto' && this.adaptiveGridService.windowSize !== 'large') {
            this.ctx.grid.adaptiveRenderer.actionSheet.toggle(false);
        }
        else {
            this.popupService.destroy();
            this.popupRef = null;
            this.cdr.markForCheck();
        }
        if (!triggerFocus) {
            return;
        }
        this.focusRoot();
    }
    /**
     * @hidden
     */
    get columnMenuTitle() {
        const localizationMsg = this.ctx.localization.get('columnMenu') || '';
        const columnName = this.column.title || this.column.field;
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
    getExpandedState(menuItemSettings) {
        return typeof (menuItemSettings) === 'object' ? menuItemSettings.expanded : false;
    }
    updateAria(ariaRoot) {
        ariaRoot && this.renderer.removeAttribute(ariaRoot, 'aria-controls');
        ariaRoot && this.renderer.setAttribute(ariaRoot, 'aria-expanded', 'false');
    }
    focusRoot() {
        if (this.isNavigable) {
            this.navigationService.preventScroll = true;
            this.navigationService.focusCell(0, this.column.leafIndex);
        }
        else {
            this.anchor.nativeElement.focus({ preventScroll: true });
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnMenuComponent, deps: [{ token: NavigationService }, { token: SinglePopupService }, { token: ColumnMenuService }, { token: ContextService }, { token: i0.Renderer2 }, { token: i0.ChangeDetectorRef }, { token: ColumnInfoService }, { token: IdService, optional: true }, { token: AdaptiveGridService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: ColumnMenuComponent, isStandalone: true, selector: "kendo-grid-column-menu", inputs: { standalone: "standalone", column: "column", settings: "settings", sort: "sort", filter: "filter", sortable: "sortable", columnMenuTemplate: "columnMenuTemplate", tabIndex: "tabIndex" }, host: { properties: { "class.k-grid-column-menu-standalone": "this.standalone" } }, providers: [
            ColumnMenuService,
            MenuTabbingService
        ], viewQueries: [{ propertyName: "anchor", first: true, predicate: ["anchor"], descendants: true, static: true }, { propertyName: "template", first: true, predicate: ["template"], descendants: true, read: TemplateRef, static: true }, { propertyName: "defaultTemplate", first: true, predicate: ["defaultTemplate"], descendants: true, read: TemplateRef, static: true }, { propertyName: "tabbedInterfaceTemplate", first: true, predicate: ["tabbedInterfaceTemplate"], descendants: true, read: TemplateRef, static: true }, { propertyName: "tabStrip", first: true, predicate: TabStripComponent, descendants: true }], usesOnChanges: true, ngImport: i0, template: `
        <a #anchor
          class="k-grid-header-menu k-grid-column-menu"
          [ngClass]="{ 'k-active': isActive }"
          (click)="toggle($event, anchor, template)"
          (keydown.enter)="$event.stopImmediatePropagation()"
          href="#"
          [tabindex]="tabIndex"
          [attr.title]="columnMenuTitle"
          [attr.aria-expanded]="isNavigable ? undefined : false"
          [attr.aria-haspopup]="isNavigable ? undefined : 'dialog'">
          <kendo-icon-wrapper
            name="more-vertical"
          [svgIcon]="moreVerticalIcon"></kendo-icon-wrapper>
        </a>
        <ng-template #template>
          <kendo-grid-columnmenu-container
            (keydown.escape)="close(true)"
            (keydown.enter)="$event.stopImmediatePropagation()">
            <ng-container
              [ngTemplateOutlet]="column.columnMenuTemplateRef || columnMenuTemplate || (settings.view === 'tabbed' ? tabbedInterfaceTemplate : defaultTemplate)"
              [ngTemplateOutletContext]="{ service: service, column: column }">
            </ng-container>
          </kendo-grid-columnmenu-container>
        </ng-template>
        <ng-template #defaultTemplate>
          <kendo-grid-columnmenu-container
            (keydown.escape)="close(true)"
            (keydown.enter)="$event.stopImmediatePropagation()">
            @if (hasSort) {
              <kendo-grid-columnmenu-sort #sortItem [kendoGridColumnMenuItem]="sortItem" [service]="service">
              </kendo-grid-columnmenu-sort>
            }
            @if (hasLock && !hasPosition) {
              <kendo-grid-columnmenu-lock #lockItem [kendoGridColumnMenuItem]="lockItem" [service]="service">
              </kendo-grid-columnmenu-lock>
            }
            @if (hasStick && !hasPosition) {
              <kendo-grid-columnmenu-stick #stickItem [kendoGridColumnMenuItem]="stickItem" [service]="service">
              </kendo-grid-columnmenu-stick>
            }
            @if (hasPosition) {
              <kendo-grid-columnmenu-position
                #positionItem
                [showLock]="hasLock"
                [showStick]="hasStick"
                [kendoGridColumnMenuItem]="positionItem"
                [service]="service"
                [expanded]="expandedPosition"
                >
              </kendo-grid-columnmenu-position>
            }
            @if (hasColumnChooser || hasAutoSizeColumn || hasAutoSizeAllColumns) {
              <span [style.borderColor]="'rgba(0, 0, 0, 0.08)'" class="k-separator"></span>
            }
            @if (hasColumnChooser) {
              <kendo-grid-columnmenu-chooser
                #chooserItem
                [kendoGridColumnMenuItem]="chooserItem"
                [service]="service"
                [expanded]="expandedColumns">
              </kendo-grid-columnmenu-chooser>
            }
            @if (hasAutoSizeColumn) {
              <kendo-grid-columnmenu-autosize-column
                #autoSizeColumnItem
                [service]="service"
                [kendoGridColumnMenuItem]="autoSizeColumnItem"
                [column]="column"
                >
              </kendo-grid-columnmenu-autosize-column>
            }

            @if (hasAutoSizeAllColumns) {
              <kendo-grid-columnmenu-autosize-all-columns
                #autoSizeAllColumnsItem
                [service]="service"
                [kendoGridColumnMenuItem]="autoSizeAllColumnsItem"
                >
              </kendo-grid-columnmenu-autosize-all-columns>
            }
            @if (hasColumnChooser || hasAutoSizeColumn || hasAutoSizeAllColumns) {
              <span [style.borderColor]="'rgba(0, 0, 0, 0.08)'" class="k-separator"></span>
            }
            @if (hasFilter) {
              <kendo-grid-columnmenu-filter
                #filterItem
                [kendoGridColumnMenuItem]="filterItem"
                [service]="service"
                [expanded]="expandedFilter">
              </kendo-grid-columnmenu-filter>
            }
          </kendo-grid-columnmenu-container>
        </ng-template>
        <ng-template #tabbedInterfaceTemplate>
          <kendo-tabstrip #tabstrip
            (keydown.escape)="close(true)">
            @if (hasFilter) {
              <kendo-tabstrip-tab>
                <ng-template kendoTabTitle>
                  <kendo-icon-wrapper
                    [attr.title]="ctx.localization.get('columnMenuFilterTabTitle')"
                    name="filter"
                    [svgIcon]="filterIcon">
                  </kendo-icon-wrapper>
                </ng-template>
                <ng-template kendoTabContent>
                  <kendo-grid-filter-menu-container
                    [column]="service.column"
                    [menuTabbingService]="service.menuTabbingService"
                    [filter]="service.filter"
                    [actionsClass]="actionsClass"
                    (keydown.shift.tab)="$event.stopImmediatePropagation()"
                    (close)="close()">
                  </kendo-grid-filter-menu-container>
                </ng-template>
              </kendo-tabstrip-tab>
            }
            @if (showGeneralTab) {
              <kendo-tabstrip-tab>
                <ng-template kendoTabTitle>
                  <kendo-icon-wrapper
                    [attr.title]="ctx.localization.get('columnMenuGeneralTabTitle')"
                    name="sliders"
                    [svgIcon]="slidersIcon">
                  </kendo-icon-wrapper>
                </ng-template>
                <ng-template kendoTabContent>
                  @if (hasSort) {
                    <kendo-grid-columnmenu-sort #sortItem [kendoGridColumnMenuItem]="sortItem" [service]="service">
                    </kendo-grid-columnmenu-sort>
                  }
                  @if (hasSort && (hasLock || hasStick || hasPosition || hasAutoSizeColumn || hasAutoSizeAllColumns)) {
                    <span [style.borderColor]="'rgba(0, 0, 0, 0.08)'" class="k-separator"></span>
                  }
                  @if (hasLock && !hasPosition) {
                    <kendo-grid-columnmenu-lock #lockItem [kendoGridColumnMenuItem]="lockItem" [service]="service">
                    </kendo-grid-columnmenu-lock>
                  }
                  @if (hasStick && !hasPosition) {
                    <kendo-grid-columnmenu-stick #stickItem [kendoGridColumnMenuItem]="stickItem" [service]="service">
                    </kendo-grid-columnmenu-stick>
                  }
                  @if ((hasLock || hasStick) && !hasPosition && (hasAutoSizeColumn || hasAutoSizeAllColumns)) {
                    <span [style.borderColor]="'rgba(0, 0, 0, 0.08)'" class="k-separator"></span>
                  }
                  @if (hasPosition) {
                    <kendo-grid-columnmenu-position
                      #positionItem
                      [showLock]="hasLock"
                      [showStick]="hasStick"
                      [kendoGridColumnMenuItem]="positionItem"
                      [service]="service"
                      [expanded]="expandedPosition">
                    </kendo-grid-columnmenu-position>
                  }
                  @if (hasPosition && (hasAutoSizeColumn || hasAutoSizeAllColumns)) {
                    <span [style.borderColor]="'rgba(0, 0, 0, 0.08)'" class="k-separator"></span>
                  }
                  @if (hasAutoSizeColumn) {
                    <kendo-grid-columnmenu-autosize-column
                      #autoSizeColumnItem
                      [service]="service"
                      [kendoGridColumnMenuItem]="autoSizeColumnItem"
                      [column]="column"
                      >
                    </kendo-grid-columnmenu-autosize-column>
                  }
                  @if (hasAutoSizeAllColumns) {
                    <kendo-grid-columnmenu-autosize-all-columns
                      #autoSizeAllColumnsItem
                      [service]="service"
                      [kendoGridColumnMenuItem]="autoSizeAllColumnsItem"
                      >
                    </kendo-grid-columnmenu-autosize-all-columns>
                  }
                </ng-template>
              </kendo-tabstrip-tab>
            }
            @if (hasColumnChooser) {
              <kendo-tabstrip-tab>
                <ng-template kendoTabTitle>
                  <kendo-icon-wrapper
                    [attr.title]="ctx.localization.get('columnMenuColumnsTabTitle')"
                    name="columns"
                    [svgIcon]="columnsIcon">
                  </kendo-icon-wrapper>
                </ng-template>
                <ng-template kendoTabContent>
                  <kendo-grid-column-chooser-content
                    [columns]="columns"
                    [service]="service"
                    (close)="close()"
                    >
                  </kendo-grid-column-chooser-content>
                </ng-template>
              </kendo-tabstrip-tab>
            }
          </kendo-tabstrip>
        </ng-template>

        `, isInline: true, dependencies: [{ kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "component", type: ColumnMenuContainerComponent, selector: "kendo-grid-columnmenu-container" }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: ColumnMenuSortComponent, selector: "kendo-grid-columnmenu-sort" }, { kind: "directive", type: ColumnMenuItemDirective, selector: "[kendoGridColumnMenuItem]", inputs: ["kendoGridColumnMenuItem"] }, { kind: "component", type: ColumnMenuLockComponent, selector: "kendo-grid-columnmenu-lock" }, { kind: "component", type: ColumnMenuStickComponent, selector: "kendo-grid-columnmenu-stick" }, { kind: "component", type: ColumnMenuPositionComponent, selector: "kendo-grid-columnmenu-position", inputs: ["expanded", "showLock", "showStick", "isLast"], outputs: ["expand", "collapse"] }, { kind: "component", type: ColumnMenuChooserComponent, selector: "kendo-grid-columnmenu-chooser", inputs: ["expanded", "isLast"], outputs: ["expand", "collapse"] }, { kind: "component", type: ColumnMenuAutoSizeColumnComponent, selector: "kendo-grid-columnmenu-autosize-column", inputs: ["column"] }, { kind: "component", type: ColumnMenuAutoSizeAllColumnsComponent, selector: "kendo-grid-columnmenu-autosize-all-columns" }, { kind: "component", type: ColumnMenuFilterComponent, selector: "kendo-grid-columnmenu-filter", inputs: ["expanded", "isLast"], outputs: ["expand", "collapse"] }, { kind: "component", type: TabStripComponent, selector: "kendo-tabstrip", inputs: ["height", "animate", "tabAlignment", "tabPosition", "keepTabContent", "closable", "scrollable", "size", "closeIcon", "closeIconClass", "closeSVGIcon", "showContentArea"], outputs: ["tabSelect", "tabClose", "tabScroll"], exportAs: ["kendoTabStrip"] }, { kind: "component", type: TabStripTabComponent, selector: "kendo-tabstrip-tab", inputs: ["title", "disabled", "cssClass", "cssStyle", "selected", "closable", "closeIcon", "closeIconClass", "closeSVGIcon"], exportAs: ["kendoTabStripTab"] }, { kind: "directive", type: TabTitleDirective, selector: "[kendoTabTitle]" }, { kind: "directive", type: TabContentDirective, selector: "[kendoTabContent]" }, { kind: "component", type: FilterMenuContainerComponent, selector: "kendo-grid-filter-menu-container", inputs: ["column", "isLast", "isExpanded", "menuTabbingService", "filter", "actionsClass"], outputs: ["close"] }, { kind: "component", type: ColumnChooserContentComponent, selector: "kendo-grid-column-chooser-content", inputs: ["filterable", "showSelectAll", "showCheckedCount", "allowHideAll", "autoSync", "actionsClass", "closeOnReset", "columns", "isLast", "isExpanded", "service"], outputs: ["close"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnMenuComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        ColumnMenuService,
                        MenuTabbingService
                    ],
                    selector: 'kendo-grid-column-menu',
                    template: `
        <a #anchor
          class="k-grid-header-menu k-grid-column-menu"
          [ngClass]="{ 'k-active': isActive }"
          (click)="toggle($event, anchor, template)"
          (keydown.enter)="$event.stopImmediatePropagation()"
          href="#"
          [tabindex]="tabIndex"
          [attr.title]="columnMenuTitle"
          [attr.aria-expanded]="isNavigable ? undefined : false"
          [attr.aria-haspopup]="isNavigable ? undefined : 'dialog'">
          <kendo-icon-wrapper
            name="more-vertical"
          [svgIcon]="moreVerticalIcon"></kendo-icon-wrapper>
        </a>
        <ng-template #template>
          <kendo-grid-columnmenu-container
            (keydown.escape)="close(true)"
            (keydown.enter)="$event.stopImmediatePropagation()">
            <ng-container
              [ngTemplateOutlet]="column.columnMenuTemplateRef || columnMenuTemplate || (settings.view === 'tabbed' ? tabbedInterfaceTemplate : defaultTemplate)"
              [ngTemplateOutletContext]="{ service: service, column: column }">
            </ng-container>
          </kendo-grid-columnmenu-container>
        </ng-template>
        <ng-template #defaultTemplate>
          <kendo-grid-columnmenu-container
            (keydown.escape)="close(true)"
            (keydown.enter)="$event.stopImmediatePropagation()">
            @if (hasSort) {
              <kendo-grid-columnmenu-sort #sortItem [kendoGridColumnMenuItem]="sortItem" [service]="service">
              </kendo-grid-columnmenu-sort>
            }
            @if (hasLock && !hasPosition) {
              <kendo-grid-columnmenu-lock #lockItem [kendoGridColumnMenuItem]="lockItem" [service]="service">
              </kendo-grid-columnmenu-lock>
            }
            @if (hasStick && !hasPosition) {
              <kendo-grid-columnmenu-stick #stickItem [kendoGridColumnMenuItem]="stickItem" [service]="service">
              </kendo-grid-columnmenu-stick>
            }
            @if (hasPosition) {
              <kendo-grid-columnmenu-position
                #positionItem
                [showLock]="hasLock"
                [showStick]="hasStick"
                [kendoGridColumnMenuItem]="positionItem"
                [service]="service"
                [expanded]="expandedPosition"
                >
              </kendo-grid-columnmenu-position>
            }
            @if (hasColumnChooser || hasAutoSizeColumn || hasAutoSizeAllColumns) {
              <span [style.borderColor]="'rgba(0, 0, 0, 0.08)'" class="k-separator"></span>
            }
            @if (hasColumnChooser) {
              <kendo-grid-columnmenu-chooser
                #chooserItem
                [kendoGridColumnMenuItem]="chooserItem"
                [service]="service"
                [expanded]="expandedColumns">
              </kendo-grid-columnmenu-chooser>
            }
            @if (hasAutoSizeColumn) {
              <kendo-grid-columnmenu-autosize-column
                #autoSizeColumnItem
                [service]="service"
                [kendoGridColumnMenuItem]="autoSizeColumnItem"
                [column]="column"
                >
              </kendo-grid-columnmenu-autosize-column>
            }

            @if (hasAutoSizeAllColumns) {
              <kendo-grid-columnmenu-autosize-all-columns
                #autoSizeAllColumnsItem
                [service]="service"
                [kendoGridColumnMenuItem]="autoSizeAllColumnsItem"
                >
              </kendo-grid-columnmenu-autosize-all-columns>
            }
            @if (hasColumnChooser || hasAutoSizeColumn || hasAutoSizeAllColumns) {
              <span [style.borderColor]="'rgba(0, 0, 0, 0.08)'" class="k-separator"></span>
            }
            @if (hasFilter) {
              <kendo-grid-columnmenu-filter
                #filterItem
                [kendoGridColumnMenuItem]="filterItem"
                [service]="service"
                [expanded]="expandedFilter">
              </kendo-grid-columnmenu-filter>
            }
          </kendo-grid-columnmenu-container>
        </ng-template>
        <ng-template #tabbedInterfaceTemplate>
          <kendo-tabstrip #tabstrip
            (keydown.escape)="close(true)">
            @if (hasFilter) {
              <kendo-tabstrip-tab>
                <ng-template kendoTabTitle>
                  <kendo-icon-wrapper
                    [attr.title]="ctx.localization.get('columnMenuFilterTabTitle')"
                    name="filter"
                    [svgIcon]="filterIcon">
                  </kendo-icon-wrapper>
                </ng-template>
                <ng-template kendoTabContent>
                  <kendo-grid-filter-menu-container
                    [column]="service.column"
                    [menuTabbingService]="service.menuTabbingService"
                    [filter]="service.filter"
                    [actionsClass]="actionsClass"
                    (keydown.shift.tab)="$event.stopImmediatePropagation()"
                    (close)="close()">
                  </kendo-grid-filter-menu-container>
                </ng-template>
              </kendo-tabstrip-tab>
            }
            @if (showGeneralTab) {
              <kendo-tabstrip-tab>
                <ng-template kendoTabTitle>
                  <kendo-icon-wrapper
                    [attr.title]="ctx.localization.get('columnMenuGeneralTabTitle')"
                    name="sliders"
                    [svgIcon]="slidersIcon">
                  </kendo-icon-wrapper>
                </ng-template>
                <ng-template kendoTabContent>
                  @if (hasSort) {
                    <kendo-grid-columnmenu-sort #sortItem [kendoGridColumnMenuItem]="sortItem" [service]="service">
                    </kendo-grid-columnmenu-sort>
                  }
                  @if (hasSort && (hasLock || hasStick || hasPosition || hasAutoSizeColumn || hasAutoSizeAllColumns)) {
                    <span [style.borderColor]="'rgba(0, 0, 0, 0.08)'" class="k-separator"></span>
                  }
                  @if (hasLock && !hasPosition) {
                    <kendo-grid-columnmenu-lock #lockItem [kendoGridColumnMenuItem]="lockItem" [service]="service">
                    </kendo-grid-columnmenu-lock>
                  }
                  @if (hasStick && !hasPosition) {
                    <kendo-grid-columnmenu-stick #stickItem [kendoGridColumnMenuItem]="stickItem" [service]="service">
                    </kendo-grid-columnmenu-stick>
                  }
                  @if ((hasLock || hasStick) && !hasPosition && (hasAutoSizeColumn || hasAutoSizeAllColumns)) {
                    <span [style.borderColor]="'rgba(0, 0, 0, 0.08)'" class="k-separator"></span>
                  }
                  @if (hasPosition) {
                    <kendo-grid-columnmenu-position
                      #positionItem
                      [showLock]="hasLock"
                      [showStick]="hasStick"
                      [kendoGridColumnMenuItem]="positionItem"
                      [service]="service"
                      [expanded]="expandedPosition">
                    </kendo-grid-columnmenu-position>
                  }
                  @if (hasPosition && (hasAutoSizeColumn || hasAutoSizeAllColumns)) {
                    <span [style.borderColor]="'rgba(0, 0, 0, 0.08)'" class="k-separator"></span>
                  }
                  @if (hasAutoSizeColumn) {
                    <kendo-grid-columnmenu-autosize-column
                      #autoSizeColumnItem
                      [service]="service"
                      [kendoGridColumnMenuItem]="autoSizeColumnItem"
                      [column]="column"
                      >
                    </kendo-grid-columnmenu-autosize-column>
                  }
                  @if (hasAutoSizeAllColumns) {
                    <kendo-grid-columnmenu-autosize-all-columns
                      #autoSizeAllColumnsItem
                      [service]="service"
                      [kendoGridColumnMenuItem]="autoSizeAllColumnsItem"
                      >
                    </kendo-grid-columnmenu-autosize-all-columns>
                  }
                </ng-template>
              </kendo-tabstrip-tab>
            }
            @if (hasColumnChooser) {
              <kendo-tabstrip-tab>
                <ng-template kendoTabTitle>
                  <kendo-icon-wrapper
                    [attr.title]="ctx.localization.get('columnMenuColumnsTabTitle')"
                    name="columns"
                    [svgIcon]="columnsIcon">
                  </kendo-icon-wrapper>
                </ng-template>
                <ng-template kendoTabContent>
                  <kendo-grid-column-chooser-content
                    [columns]="columns"
                    [service]="service"
                    (close)="close()"
                    >
                  </kendo-grid-column-chooser-content>
                </ng-template>
              </kendo-tabstrip-tab>
            }
          </kendo-tabstrip>
        </ng-template>

        `,
                    standalone: true,
                    imports: [
                        NgClass,
                        IconWrapperComponent,
                        ColumnMenuContainerComponent,
                        NgTemplateOutlet,
                        ColumnMenuSortComponent,
                        ColumnMenuItemDirective,
                        ColumnMenuLockComponent,
                        ColumnMenuStickComponent,
                        ColumnMenuPositionComponent,
                        ColumnMenuChooserComponent,
                        ColumnMenuAutoSizeColumnComponent,
                        ColumnMenuAutoSizeAllColumnsComponent,
                        ColumnMenuFilterComponent,
                        TabStripComponent,
                        TabStripTabComponent,
                        TabTitleDirective,
                        TabContentDirective,
                        FilterMenuContainerComponent,
                        ColumnChooserContentComponent
                    ]
                }]
        }], ctorParameters: () => [{ type: NavigationService }, { type: SinglePopupService }, { type: ColumnMenuService }, { type: ContextService }, { type: i0.Renderer2 }, { type: i0.ChangeDetectorRef }, { type: ColumnInfoService }, { type: IdService, decorators: [{
                    type: Optional
                }] }, { type: AdaptiveGridService }], propDecorators: { standalone: [{
                type: HostBinding,
                args: ['class.k-grid-column-menu-standalone']
            }, {
                type: Input
            }], column: [{
                type: Input
            }], settings: [{
                type: Input
            }], sort: [{
                type: Input
            }], filter: [{
                type: Input
            }], sortable: [{
                type: Input
            }], columnMenuTemplate: [{
                type: Input
            }], tabIndex: [{
                type: Input
            }], anchor: [{
                type: ViewChild,
                args: ['anchor', { static: true }]
            }], template: [{
                type: ViewChild,
                args: ['template', { static: true, read: TemplateRef }]
            }], defaultTemplate: [{
                type: ViewChild,
                args: ['defaultTemplate', { static: true, read: TemplateRef }]
            }], tabbedInterfaceTemplate: [{
                type: ViewChild,
                args: ['tabbedInterfaceTemplate', { static: true, read: TemplateRef }]
            }], tabStrip: [{
                type: ViewChild,
                args: [TabStripComponent]
            }] } });

/**
 * @hidden
 */
class ExcelService {
    saveToExcel = new EventEmitter();
    exportClick = new EventEmitter();
    save(component) {
        if (this.saveToExcel.observers.length === 0) {
            if (isDevMode()) {
                throw new Error(GridConfigurationErrorMessages.requiredModule('excel', 'ExcelModule', '<kendo-grid-excel>'));
            }
        }
        else {
            this.saveToExcel.emit(component);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ExcelService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ExcelService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ExcelService, decorators: [{
            type: Injectable
        }] });

/**
 * Provides arguments for the `excelExport` event.
 */
class ExcelExportEvent extends PreventableEvent {
    workbook;
    /**
     * @hidden
     */
    constructor(workbook) {
        super();
        this.workbook = workbook;
    }
}

const fetchComponentData = (component) => {
    return {
        data: component.view.map(item => item),
        group: component.group
    };
};
const toExcelColumn = (column) => {
    return {
        title: column.title,
        field: column.field,
        locked: Boolean(column.locked),
        width: column.width,
        level: column.level,
        hidden: !column.isVisible,
        groupHeaderTemplate: column.groupHeaderTemplate,
        groupHeaderColumnTemplate: column.groupHeaderColumnTemplate,
        groupFooterTemplate: column.groupFooterTemplate,
        footerTemplate: column.footerTemplate
    };
};
const toExcelColumns = (columns) => {
    const result = [];
    sortColumns(columns)
        .forEach((column) => {
        if (column.isSpanColumn) {
            result.push(...toExcelColumns(column.childrenArray));
        }
        else {
            const excelColumn = toExcelColumn(column);
            if (column.isColumnGroup) {
                excelColumn.children = [excelColumn].concat(toExcelColumns(column.childrenArray));
            }
            result.push(excelColumn);
        }
    });
    return result;
};
const componentColumns = (component) => {
    const columns = toExcelColumns(component.columns.toArray());
    return orderBy(columns, [{ field: 'locked', dir: 'desc' }]);
};
/**
 * The component is required when exporting the data to an Excel file. The componnet provides different options to further configure the Excel export settings of the Grid ([see example]({% slug excelexport_grid %})).
 *
 * @example
 * ```html
 * <kendo-grid>
 *   <kendo-grid-excel fileName="Export.xlsx"></kendo-grid-excel>
 * </kendo-grid>
 * ```
 */
class ExcelComponent {
    ctx;
    zone;
    /**
     * Sets the file name for the exported Excel file.
     * @default "Export.xlsx"
     */
    fileName = 'Export.xlsx';
    /**
     * Enables or disables column filtering in the Excel file. This option is different from the Grid's filtering feature.
     */
    filterable;
    /**
     * Sets the author of the workbook.
     */
    creator;
    /**
     * Sets the creation date of the workbook.
     */
    date;
    /**
     * Forwards the content to [`proxyURL`](#toc-proxyurl) even if the browser supports local file saving when set to `true`.
     */
    forceProxy;
    /**
     * Sets the URL of the server-side proxy that streams the file to the user. Use a proxy if the browser cannot save files locally.
     * You can also use a proxy to reduce memory usage by transmitting the file over the network.
     * Set [`forceProxy`](#toc-forceproxy) to `true` to skip client-side saving.
     * The proxy receives a POST request with specific parameters and returns the decoded file with the `"Content-Disposition"` header set to `attachment; filename="<fileName.xslx>"`.
     * For more details, see the [File Saver]({% slug overview_filesaver %}) documentation.
     */
    proxyURL;
    /**
     * Provides a function to get the exported data options. By default, uses the current Grid data and group.
     * Supply a custom function to export different data. Typically used to export all data, not just the current page [see example](slug:excelexport_grid#controlling-the-exported-data).
     */
    fetchData;
    /**
     * Sets options for cells inserted before the data, group, and footer cells to indicate the group hierarchy if the data is grouped.
     *
     */
    paddingCellOptions;
    /**
     * Sets the options for cells inserted before the header cells to align the headers and the column values when the data is grouped.
     */
    headerPaddingCellOptions;
    /**
     * Specifies if groups in the Excel file are collapsible.
     */
    collapsible;
    /**
     * @hidden
     */
    fileCreated = new EventEmitter();
    /**
     * @hidden
     */
    columns = new QueryList();
    saveSubscription;
    dataSubscription;
    constructor(excelService, ctx, zone) {
        this.ctx = ctx;
        this.zone = zone;
        this.saveSubscription = excelService.saveToExcel.subscribe(this.save.bind(this));
        this.ctx.excelComponent = this;
    }
    ngOnDestroy() {
        this.saveSubscription.unsubscribe();
        if (this.dataSubscription) {
            this.dataSubscription.unsubscribe();
        }
        if (this.ctx.excelComponent === this) {
            this.ctx.excelComponent = undefined;
        }
    }
    save(component) {
        const data = (this.fetchData || fetchComponentData)(component);
        const exportData = (result) => {
            delete this.dataSubscription;
            this.exportData(component, result);
        };
        if (data instanceof Promise) {
            data.then(exportData);
        }
        else if (data instanceof Observable) {
            this.dataSubscription = data.pipe(take(1)).subscribe(exportData);
        }
        else {
            exportData(data);
        }
    }
    exportData(component, result) {
        const options = workbookOptions({
            columns: this.columns.length ? this.columns : componentColumns(component),
            data: result.data,
            group: result.group,
            filterable: this.filterable,
            creator: this.creator,
            date: this.date,
            paddingCellOptions: this.paddingCellOptions,
            headerPaddingCellOptions: this.headerPaddingCellOptions,
            rtl: this.ctx.localization.rtl,
            collapsible: this.collapsible
        });
        const args = new ExcelExportEvent(options);
        component.excelExport.emit(args);
        if (!args.isDefaultPrevented()) {
            this.zone.runOutsideAngular(() => this.saveFile(options));
        }
    }
    saveFile(options) {
        toDataURL(options).then((dataURL) => {
            saveAs(dataURL, this.fileName, {
                forceProxy: this.forceProxy,
                proxyURL: this.proxyURL
            });
            this.fileCreated.emit();
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ExcelComponent, deps: [{ token: ExcelService }, { token: ContextService }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: ExcelComponent, isStandalone: true, selector: "kendo-grid-excel", inputs: { fileName: "fileName", filterable: "filterable", creator: "creator", date: "date", forceProxy: "forceProxy", proxyURL: "proxyURL", fetchData: "fetchData", paddingCellOptions: "paddingCellOptions", headerPaddingCellOptions: "headerPaddingCellOptions", collapsible: "collapsible" }, outputs: { fileCreated: "fileCreated" }, queries: [{ propertyName: "columns", predicate: ColumnBase$1, descendants: true }], ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ExcelComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-excel',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: ExcelService }, { type: ContextService }, { type: i0.NgZone }], propDecorators: { fileName: [{
                type: Input
            }], filterable: [{
                type: Input
            }], creator: [{
                type: Input
            }], date: [{
                type: Input
            }], forceProxy: [{
                type: Input
            }], proxyURL: [{
                type: Input
            }], fetchData: [{
                type: Input
            }], paddingCellOptions: [{
                type: Input
            }], headerPaddingCellOptions: [{
                type: Input
            }], collapsible: [{
                type: Input
            }], fileCreated: [{
                type: Output
            }], columns: [{
                type: ContentChildren,
                args: [ColumnBase$1, { descendants: true }]
            }] } });

/**
 * Represents the `excelExport` command of the Grid. Apply this
 * directive to any `button` element inside a [`ToolbarTemplate`]({% slug api_grid_toolbartemplatedirective %}).
 * When the user clicks the button, the [`excelExport`]({% slug api_grid_gridcomponent %}#toc-excelexport) event fires ([see example]({% slug excelexport_grid %})).
 *
 * @example
 * ```html
 * <kendo-grid>
 *   <ng-template kendoGridToolbarTemplate>
 *     <button kendoGridExcelCommand>Export to Excel</button>
 *   </ng-template>
 *   <kendo-grid-excel fileName="Grid.xlsx"></kendo-grid-excel>
 * </kendo-grid>
 * ```
 */
class ExcelCommandDirective extends Button {
    excelService;
    /**
     * @hidden
     */
    onClick(e) {
        e.preventDefault();
        this.excelService.exportClick.emit();
    }
    /**
     * @hidden
     */
    get excelClass() {
        return true;
    }
    constructor(excelService, element, renderer, ctx, ngZone) {
        super(element, renderer, null, ctx.localization, ngZone);
        this.excelService = excelService;
        this.ngZone = ngZone;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ExcelCommandDirective, deps: [{ token: ExcelService }, { token: i0.ElementRef }, { token: i0.Renderer2 }, { token: ContextService }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: ExcelCommandDirective, isStandalone: true, selector: "[kendoGridExcelCommand]", host: { listeners: { "click": "onClick($event)" }, properties: { "class.k-grid-excel": "this.excelClass" } }, usesInheritance: true, ngImport: i0, template: `
        @if (icon || svgIcon) {
          <kendo-icon-wrapper
            innerCssClass="k-button-icon"
            [name]="icon"
          [svgIcon]="svgIcon"></kendo-icon-wrapper>
        }
        @if (imageUrl) {
          <span class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
          </span>
        }
        @if (iconClass) {
          <span class="k-button-icon" [ngClass]="iconClass"></span>
        }
        <span class="k-button-text"><ng-content></ng-content></span>
        `, isInline: true, dependencies: [{ kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ExcelCommandDirective, decorators: [{
            type: Component,
            args: [{
                    selector: '[kendoGridExcelCommand]',
                    template: `
        @if (icon || svgIcon) {
          <kendo-icon-wrapper
            innerCssClass="k-button-icon"
            [name]="icon"
          [svgIcon]="svgIcon"></kendo-icon-wrapper>
        }
        @if (imageUrl) {
          <span class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
          </span>
        }
        @if (iconClass) {
          <span class="k-button-icon" [ngClass]="iconClass"></span>
        }
        <span class="k-button-text"><ng-content></ng-content></span>
        `,
                    standalone: true,
                    imports: [IconWrapperComponent, NgClass]
                }]
        }], ctorParameters: () => [{ type: ExcelService }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: ContextService }, { type: i0.NgZone }], propDecorators: { onClick: [{
                type: HostListener,
                args: ['click', ['$event']]
            }], excelClass: [{
                type: HostBinding,
                args: ['class.k-grid-excel']
            }] } });

/**
 * @hidden
 */
class SuspendService {
    scroll = false;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SuspendService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SuspendService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SuspendService, decorators: [{
            type: Injectable
        }] });

/**
 * @hidden
 */
class PDFService {
    savePDF = new EventEmitter();
    drawPDF = new EventEmitter();
    exportClick = new EventEmitter();
    dataChanged = new EventEmitter();
    exporting;
    restoreDOMVirtualization = new EventEmitter();
    save(component) {
        this.emitEvent(this.savePDF, component);
    }
    draw(component, promise) {
        this.emitEvent(this.drawPDF, { component, promise });
    }
    /**
     * @hidden
     */
    emitEvent(emitter, args) {
        if (emitter.observers.length === 0) {
            if (isDevMode()) {
                throw new Error(GridConfigurationErrorMessages.requiredModule('PDF', 'PDFModule', '<kendo-grid-pdf>'));
            }
        }
        else {
            emitter.emit(args);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PDFService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PDFService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PDFService, decorators: [{
            type: Injectable
        }] });

/**
 * Represents the Kendo UI PDFMargin component for Angular.
 * Use this component to set the PDF page margins.
 * Supported units are:
 * - `"mm"`
 * - `"cm"`
 * - `"in"`
 * - `"pt"` (default)
 * When you provide only a number, the units default to points (`pt`).
 *
 * @example
 * ```html
 * <kendo-grid>
 *   <kendo-grid-pdf [allPages]="true" [delay]="100">
 *     <kendo-grid-pdf-margin top="1cm" bottom="1cm" left="1cm" right="1cm"></kendo-grid-pdf-margin>
 *   </kendo-grid-pdf>
 * </kendo-grid>
 * ```
 */
class PDFMarginComponent extends PDFExportMarginComponent {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PDFMarginComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: PDFMarginComponent, isStandalone: true, selector: "kendo-grid-pdf-margin", usesInheritance: true, ngImport: i0, template: '', isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PDFMarginComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-pdf-margin',
                    template: '',
                    standalone: true
                }]
        }] });

/**
 * The directive allows customizing the PDF page template for the Grid.
 * Place an `<ng-template>` with the `kendoGridPDFTemplate` directive inside the `<kendo-grid-pdf>` tag.
 *
 * The template context provides:
 * - `pageNumber`&mdash;The current PDF page number.
 * - `totalPages`&mdash;The total number of PDF pages.
 *
 * @example
 * ```html
 * <kendo-grid [data]="gridData">
 *   ...
 *   <kendo-grid-pdf fileName="Products.pdf" paperSize="A4">
 *     <ng-template kendoGridPDFTemplate let-pageNumber="pageNumber" let-totalPages="totalPages">
 *         Page {{ pageNumber }} of {{ totalPages }}
 *     </ng-template>
 *   </kendo-grid-pdf>
 * </kendo-grid>
 * ```
 */
class PDFTemplateDirective extends PDFExportTemplateDirective {
    constructor(templateRef) {
        super(templateRef);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PDFTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: PDFTemplateDirective, isStandalone: true, selector: "[kendoGridPDFTemplate]", usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PDFTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridPDFTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }] });

/**
 * @hidden
 */
const HEADER_CLASS = 'k-grid-header';
/**
 * @hidden
 */
const FOOTER_CLASS = 'k-grid-footer';
const GRID_LIST = 'KENDO-GRID-LIST';
const TABLE = 'TABLE';
const matchesList = matchesNodeName(GRID_LIST);
const matchesTable = matchesNodeName(TABLE);
const suffix = (locked) => locked ? 'locked' : 'wrap';
/**
 * @hidden
 */
class GridQuery {
    element;
    headerWrap;
    list;
    footerWrap;
    constructor(element) {
        this.element = element;
        this.list = findElement(element, matchesList);
    }
    content(locked) {
        return findElement(this.list, matchesClasses(`k-grid-content${locked ? '-locked' : ''}`));
    }
    header(locked) {
        this.headerWrap = this.headerWrap || findElement(this.element, matchesClasses(HEADER_CLASS));
        return findElement(this.headerWrap, matchesClasses(`${HEADER_CLASS}-${suffix(locked)}`));
    }
    footer(locked) {
        this.footerWrap = this.footerWrap || findElement(this.element, matchesClasses(FOOTER_CLASS));
        return findElement(this.footerWrap, matchesClasses(`${FOOTER_CLASS}-${suffix(locked)}`));
    }
    table() {
        return findElement(this.element, matchesTable);
    }
}

const FIRST_CLASS = 'k-first';
const INPUTS = ['input', 'select', 'textarea', 'option'];
/** @hidden */
const cloneNode = (node) => {
    const clone = node.cloneNode(false);
    if (node._kendoExportVisual) {
        clone._kendoExportVisual = node._kendoExportVisual;
    }
    if (INPUTS.indexOf(String(node.nodeName).toLowerCase()) >= 0) {
        clone.removeAttribute("id");
        clone.removeAttribute("name");
        clone.value = node.value;
        clone.checked = node.checked;
        clone.selected = node.selected;
    }
    let child = node.firstChild;
    while (child) {
        clone.appendChild(cloneNode(child));
        child = child.nextSibling;
    }
    return clone;
};
const appendNodes = (element, nodes) => {
    const length = nodes.length;
    for (let idx = 0; idx < length; idx++) {
        element.appendChild(cloneNode(nodes[idx]));
    }
};
const wrapTable = (table, size) => {
    if (!isDocumentAvailable()) {
        return;
    }
    const wrapper = document.createElement('div');
    const classes = ['k-grid'];
    if (size && size !== 'none') {
        classes.push(`k-grid-${size === 'medium' ? 'md' : 'sm'}`);
    }
    wrapper.classList.add(...classes);
    wrapper.appendChild(table);
    return wrapper;
};
const createTableElement = (sources) => {
    const sourceCount = sources.length;
    const element = cloneNode(sources[0]);
    const rowsCount = element.rows.length;
    if (sourceCount > 1) {
        for (let rowIdx = 0; rowIdx < rowsCount; rowIdx++) {
            for (let sourceIdx = 1; sourceIdx < sourceCount; sourceIdx++) {
                appendNodes(element.rows[rowIdx], sources[sourceIdx].rows[rowIdx].cells);
            }
        }
    }
    return element;
};
const setFirstCellClass = (header, headers) => {
    if (headers.length > 1 && header.rows.length > 1) {
        for (let idx = 1; idx < header.rows.length; idx++) {
            const firstCellIndex = headers[0].rows[idx].cells.length;
            const cell = header.rows[idx].cells[firstCellIndex];
            if (String(cell.className).indexOf(FIRST_CLASS) === -1) {
                cell.className += ` ${FIRST_CLASS}`;
            }
        }
    }
};
const createTable = (colGroups, headers, bodies, footers, size) => {
    const table = document.createElement('table');
    const classes = ['k-table'];
    if (size && size !== 'none') {
        classes.push(`k-table-${size === 'medium' ? 'md' : 'sm'}`);
    }
    table.classList.add(...classes);
    const colGroup = colGroups[0].cloneNode(true);
    for (let idx = 1; idx < colGroups.length; idx++) {
        appendNodes(colGroup, colGroups[idx].querySelectorAll('col'));
    }
    const body = createTableElement(bodies);
    let header;
    if (headers.length > 0) {
        header = createTableElement(headers);
        setFirstCellClass(header, headers);
    }
    table.appendChild(colGroup);
    header && table.appendChild(header);
    table.appendChild(body);
    if (footers.length) {
        const footer = createTableElement(footers);
        table.appendChild(footer);
    }
    return wrapTable(table, size);
};
/**
 * @hidden
 */
const exportElement = (wrapper, size) => {
    const query = new GridQuery(wrapper);
    const content = query.content();
    let result;
    if (content) {
        const colGroups = [content.querySelector('colgroup')];
        const bodies = [content.querySelector('tbody')];
        const header = query.header();
        const footer = query.footer();
        const headers = [];
        const footers = [];
        if (header) {
            headers.push(header.querySelector('thead'));
        }
        if (footer) {
            footers.push(footer.querySelector('tfoot'));
        }
        const lockedContent = query.content(true);
        if (lockedContent) {
            if (headers.length > 0) {
                headers.unshift(query.header(true).querySelector('thead'));
            }
            colGroups.unshift(lockedContent.querySelector('colgroup'));
            bodies.unshift(lockedContent.querySelector('tbody'));
            if (footer) {
                footers.unshift(query.footer(true).querySelector('tfoot'));
            }
        }
        result = createTable(colGroups, headers, bodies, footers, size);
    }
    else {
        result = wrapTable(query.table().cloneNode(true), size);
    }
    return result;
};

const createElement$1 = (tagName, className) => {
    const element = document.createElement(tagName);
    if (className) {
        element.className = className;
    }
    return element;
};
const createDiv = (className) => {
    return createElement$1('div', className);
};
/**
 * Configures the settings for exporting the Grid to PDF. ([See example]({% slug pdfexport_grid %})).
 *
 * Use this component to customize PDF export options for the Grid.
 *
 * @example
 * ```html
 * <kendo-grid>
 *   <kendo-grid-pdf [allPages]="true" [delay]="100"></kendo-grid-pdf>
 * </kendo-grid>
 * ```
 * @remarks
 * Supported children components are: {@link PDFMarginComponent}.
 */
class PDFComponent extends PDFExportComponent {
    pdfService;
    suspendService;
    ngZone;
    ctx;
    /**
     * Exports all Grid pages, starting from the first page.
     */
    allPages;
    /**
     * Sets the delay in milliseconds before exporting the Grid content.
     * Use this property when exporting complex components in Grid templates, such as charts or data-bound components with asynchronous data retrieval. ([See example]({% slug pdfexport_grid %}#toc-exporting-all-pages)).
     *
     * @default 0
     */
    delay = 0;
    columns = new QueryList();
    /**
     * @hidden
     */
    marginComponent;
    /**
     * @hidden
     */
    pageTemplateDirective;
    progress;
    component;
    container;
    skip;
    pageSize;
    originalHeight;
    originalOverflow;
    saveSubscription;
    drawSubscription;
    renderAllPages;
    originalColumns;
    restoreDOMVirtualization;
    constructor(pdfService, suspendService, ngZone, element, ctx) {
        super(element);
        this.pdfService = pdfService;
        this.suspendService = suspendService;
        this.ngZone = ngZone;
        this.ctx = ctx;
        this.saveSubscription = pdfService.savePDF.subscribe(this.savePDF.bind(this));
        this.drawSubscription = pdfService.drawPDF.subscribe(this.drawPDF.bind(this));
        this.reset = this.reset.bind(this);
        this.draw = this.draw.bind(this);
        if (this.ctx) {
            this.ctx.pdfComponent = this;
        }
    }
    ngOnDestroy() {
        this.saveSubscription.unsubscribe();
        this.drawSubscription.unsubscribe();
        this.reset();
        if (this.ctx?.pdfComponent === this) {
            this.ctx.pdfComponent = undefined;
        }
    }
    /**
     * @hidden
     */
    saveAs() {
        throw new Error(GridConfigurationErrorMessages.unsupportedMethod('saveAs', 'GridComponent.saveAsPDF'));
    }
    /**
     * @hidden
     */
    export() {
        throw new Error(GridConfigurationErrorMessages.unsupportedMethod('export', 'GridComponent.drawPDF'));
    }
    savePDF(component) {
        this.createPDF(component, this.draw);
    }
    drawPDF({ component, promise }) {
        this.createPDF(component, () => {
            this.createExportGroup(promise);
        });
    }
    createPDF(component, callback) {
        const pageSize = component.pageSize;
        const total = component.view.total;
        const columns = this.columns.toArray();
        if (columns.length) {
            this.originalColumns = component.columns.toArray();
        }
        this.component = component;
        this.suspendService.scroll = true;
        this.pdfService.exporting = true;
        this.initProgress();
        this.renderAllPages = this.allPages && pageSize < total;
        if (component.isVirtual && component.pageable) {
            component.scrollable = 'scrollable';
            this.restoreDOMVirtualization = true;
            if (!this.renderAllPages) {
                this.changePage(component.skip, pageSize, callback, columns);
                if (!(columns.length || component.virtualColumns)) {
                    return;
                }
            }
        }
        if (this.renderAllPages) {
            this.skip = component.skip;
            this.pageSize = pageSize;
            this.changePage(0, total, callback, columns);
        }
        else if (columns.length || component.virtualColumns) {
            this.changeColumns(columns, callback);
        }
        else {
            callback();
        }
    }
    initProgress() {
        if (!isDocumentAvailable()) {
            return;
        }
        const wrapperElement = this.component.wrapper.nativeElement;
        const progress = this.progress = createDiv('k-loading-pdf-mask');
        const overlay = cloneNode(wrapperElement);
        progress.appendChild(overlay);
        progress.appendChild(createDiv('k-loading-color'));
        progress.appendChild(createElement$1('span', 'k-i-loading k-icon'));
        this.originalHeight = wrapperElement.style.height;
        this.originalOverflow = wrapperElement.style.overflow;
        wrapperElement.style.height = wrapperElement.offsetHeight + 'px';
        wrapperElement.style.overflow = 'hidden';
        wrapperElement.appendChild(progress);
        this.applyScroll(overlay);
    }
    applyScroll(overlay) {
        const query = new GridQuery(this.component.wrapper.nativeElement);
        const content = query.content();
        if (content) {
            const overlayQuery = new GridQuery(overlay);
            const overlayContent = overlayQuery.content();
            overlayContent.scrollTop = content.scrollTop;
            overlayContent.scrollLeft = content.scrollLeft;
            if (!this.ctx?.grid?.isStacked) {
                const header = query.header();
                const overlayHeader = overlayQuery.header();
                if (header && overlayHeader) {
                    overlayHeader.scrollLeft = header.scrollLeft;
                }
            }
            const footer = query.footer();
            const overlayFooter = overlayQuery.footer();
            if (footer && overlayFooter) {
                overlayFooter.scrollLeft = footer.scrollLeft;
            }
            const lockedContent = query.content(true);
            if (lockedContent) {
                const overlayLockedContent = overlayQuery.content(true);
                overlayLockedContent.scrollTop = lockedContent.scrollTop;
                overlayLockedContent.scrollLeft = lockedContent.scrollLeft;
            }
        }
    }
    draw() {
        this.createExportElement((element) => {
            this.save(element, this.fileName);
        });
    }
    createExportGroup(promise) {
        this.createExportElement((element) => {
            this.exportElement(element).then(group => promise.resolve(group));
        });
    }
    createExportElement(callback) {
        this.ngZone.runOutsideAngular(() => {
            const container = this.container = createDiv('k-grid-pdf-export-element');
            const element = exportElement(this.component.wrapper.nativeElement, this.ctx?.grid.size || 'medium');
            container.appendChild(element);
            document.body.appendChild(container);
            callback(element);
        });
    }
    drawOptions() {
        const options = super.drawOptions();
        options._destructive = true;
        return options;
    }
    cleanup() {
        super.cleanup();
        this.pdfService.exporting = false;
        if (this.component) {
            const originalColumns = this.originalColumns;
            delete this.originalColumns;
            if (this.restoreDOMVirtualization) {
                this.component.scrollable = 'virtual';
                this.pdfService.restoreDOMVirtualization.emit();
                this.restoreDOMVirtualization = false;
            }
            if (this.renderAllPages) {
                this.changePage(this.skip, this.pageSize, this.reset, originalColumns);
            }
            else if (originalColumns || this.component.virtualColumns) {
                this.changeColumns(originalColumns, this.reset);
            }
            else {
                this.reset();
            }
        }
        else {
            this.reset();
        }
        this.removeContainer();
    }
    removeContainer() {
        if (this.container) {
            document.body.removeChild(this.container);
            delete this.container;
        }
    }
    changePage(skip, _take, callback, columns) {
        this.ngZone.run(() => {
            this.pdfService.dataChanged.pipe(take(1)).subscribe(() => {
                if ((columns && columns.length) || this.component.virtualColumns) {
                    this.changeColumns(columns, callback);
                }
                else {
                    this.onStable(callback);
                }
            });
            this.component.notifyPageChange('pdf', { skip: skip, take: _take });
        });
    }
    changeColumns(columns, callback) {
        this.ngZone.run(() => {
            this.onStable(callback);
            if (columns && columns.length) {
                this.component.columns.reset(columns);
            }
        });
    }
    reset() {
        this.suspendService.scroll = false;
        this.renderAllPages = false;
        if (!this.component) {
            return;
        }
        const wrapperElement = this.component.wrapper.nativeElement;
        wrapperElement.removeChild(this.progress);
        wrapperElement.style.height = this.originalHeight;
        wrapperElement.style.overflow = this.originalOverflow;
        delete this.progress;
        delete this.component;
    }
    onStable(callback) {
        // not sure if it is an actual scenario. occurs in the tests.
        // onStable is triggered in the same pass without the change detection.
        // thus, the callback is called before the changes are applied without the timeout.
        setTimeout(() => {
            let onStable = this.ngZone.onStable.asObservable().pipe(take(1));
            if (this.delay > 0) {
                onStable = onStable.pipe(delay(this.delay));
            }
            onStable.subscribe(callback);
        }, 0);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PDFComponent, deps: [{ token: PDFService }, { token: SuspendService }, { token: i0.NgZone }, { token: i0.ElementRef }, { token: ContextService, optional: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: PDFComponent, isStandalone: true, selector: "kendo-grid-pdf", inputs: { allPages: "allPages", delay: "delay" }, queries: [{ propertyName: "marginComponent", first: true, predicate: PDFMarginComponent, descendants: true }, { propertyName: "pageTemplateDirective", first: true, predicate: PDFTemplateDirective, descendants: true }, { propertyName: "columns", predicate: ColumnBase }], usesInheritance: true, ngImport: i0, template: '', isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PDFComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-pdf',
                    template: '',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: PDFService }, { type: SuspendService }, { type: i0.NgZone }, { type: i0.ElementRef }, { type: ContextService, decorators: [{
                    type: Optional
                }] }], propDecorators: { allPages: [{
                type: Input
            }], delay: [{
                type: Input
            }], columns: [{
                type: ContentChildren,
                args: [ColumnBase]
            }], marginComponent: [{
                type: ContentChild,
                args: [PDFMarginComponent, { static: false }]
            }], pageTemplateDirective: [{
                type: ContentChild,
                args: [PDFTemplateDirective, { static: false }]
            }] } });

/**
 * Represents the PDF export command of the Grid.
 * Apply this directive to any `button` element inside a [ToolbarTemplate]({% slug api_grid_commandcolumncomponent %}).
 * When you click a button with this directive, the [`pdfExport`]({% slug api_grid_gridcomponent %}#toc-pdfexport) event fires. ([See example]({% slug pdfexport_grid %})).
 *
 * @example
 * ```html
 * <kendo-grid>
 *      <ng-template kendoGridToolbarTemplate>
 *          <button kendoGridPDFCommand>Export to PDF</button>
 *      </ng-template>
 *      <kendo-grid-pdf fileName="products.pdf"></kendo-grid-pdf>
 * </kendo-grid>
 * ```
 */
class PDFCommandDirective extends Button {
    pdfService;
    /**
     * @hidden
     */
    onClick(e) {
        e.preventDefault();
        this.pdfService.exportClick.emit();
    }
    /**
     * @hidden
     */
    get pdfClass() {
        return true;
    }
    constructor(pdfService, element, renderer, ctx, ngZone) {
        super(element, renderer, null, ctx.localization, ngZone);
        this.pdfService = pdfService;
        this.ngZone = ngZone;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PDFCommandDirective, deps: [{ token: PDFService }, { token: i0.ElementRef }, { token: i0.Renderer2 }, { token: ContextService }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: PDFCommandDirective, isStandalone: true, selector: "[kendoGridPDFCommand]", host: { listeners: { "click": "onClick($event)" }, properties: { "class.k-grid-pdf": "this.pdfClass" } }, usesInheritance: true, ngImport: i0, template: `
        @if (icon || svgIcon) {
          <kendo-icon-wrapper
            innerCssClass="k-button-icon"
            [name]="icon"
          [svgIcon]="svgIcon"></kendo-icon-wrapper>
        }
        @if (imageUrl) {
          <span class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
          </span>
        }
        @if (iconClass) {
          <span class="k-button-icon" [ngClass]="iconClass"></span>
        }
        <span class="k-button-text"><ng-content></ng-content></span>
        `, isInline: true, dependencies: [{ kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PDFCommandDirective, decorators: [{
            type: Component,
            args: [{
                    selector: '[kendoGridPDFCommand]',
                    template: `
        @if (icon || svgIcon) {
          <kendo-icon-wrapper
            innerCssClass="k-button-icon"
            [name]="icon"
          [svgIcon]="svgIcon"></kendo-icon-wrapper>
        }
        @if (imageUrl) {
          <span class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
          </span>
        }
        @if (iconClass) {
          <span class="k-button-icon" [ngClass]="iconClass"></span>
        }
        <span class="k-button-text"><ng-content></ng-content></span>
        `,
                    standalone: true,
                    imports: [IconWrapperComponent, NgClass]
                }]
        }], ctorParameters: () => [{ type: PDFService }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: ContextService }, { type: i0.NgZone }], propDecorators: { onClick: [{
                type: HostListener,
                args: ['click', ['$event']]
            }], pdfClass: [{
                type: HostBinding,
                args: ['class.k-grid-pdf']
            }] } });

/**
 * @hidden
 */
const isFilterable = (settings) => settings !== false;
/**
 * @hidden
 */
const hasFilterMenu = (settings) => typeof settings === 'string' && settings.indexOf('menu') > -1;
/**
 * @hidden
 */
const hasFilterRow = (settings) => settings === true || (typeof settings === 'string' && settings.indexOf('row') > -1);

/**
 * @hidden
 */
class ColumnReorderService {
    changes = new EventEmitter();
    reorder(e) {
        this.changes.emit(e);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnReorderService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnReorderService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnReorderService, decorators: [{
            type: Injectable
        }] });

/**
 * Provides the arguments for the `columnReorder` event.
 */
class ColumnReorderEvent extends PreventableEvent {
    /**
     * Represents the reordered column.
     */
    column;
    /**
     * Represents the new index of the column. This index is relative to the collection of columns.
     */
    newIndex;
    /**
     * Represents the original index of the column before reordering. This index is relative to the collection of columns.
     */
    oldIndex;
    /**
     * @hidden
     */
    constructor({ column, newIndex, oldIndex }) {
        super();
        this.column = column;
        this.newIndex = newIndex;
        this.oldIndex = oldIndex;
    }
}

/**
 * @hidden
 */
const fromPercentage = (value, percent) => {
    const sign = percent < 0 ? -1 : 1;
    return Math.ceil((Math.abs(percent) / 100) * value) * sign;
};
/**
 * @hidden
 */
const toPercentage = (value, whole) => (value / whole) * 100;
/**
 * @hidden
 */
const headerWidth = (handle) => handle.nativeElement.parentElement.getBoundingClientRect().width;
/**
 * @hidden
 */
const adjacentColumnWidth = (handle) => handle.nativeElement.parentElement.nextElementSibling?.getBoundingClientRect().width;
/**
 * @hidden
 */
const adjacentColumnInGroupWidth = (handle, rowIndex, colIndex) => {
    const tableElement = handle.nativeElement.closest('.k-grid-header-table');
    const selector = (rowAttribute) => `tr[${rowAttribute}="${rowIndex}"] th[aria-colindex="${colIndex}"]`;
    const thElement = tableElement.querySelector([selector('aria-rowindex'), selector('data-kendo-grid-row-index')]);
    return thElement.getBoundingClientRect().width;
};
/**
 * @hidden
 */
const allLeafColumns = columns => expandColumns(columns)
    .filter(c => !c.isColumnGroup);
/**
 * @hidden
 */
const createMoveStream = (service, draggable) => mouseDown => draggable.kendoDrag.pipe(takeUntil(draggable.kendoRelease.pipe(tap(() => service.end()))), map(({ pageX }) => ({
    originalX: mouseDown.pageX,
    pageX
})));
/**
 * @hidden
 */
const preventOnDblClick = release => mouseDown => of(mouseDown).pipe(delay(150), takeUntil(release));
/**
 * @hidden
 */
const isInSpanColumn = column => !!(column.parent && column.parent.isSpanColumn);
/**
 * @hidden
 *
 * Calculates the column index. If the column is stated in `SpanColumn`,
 * the index for all child columns equals the index of the first child.
 */
const indexOf = (target, list) => {
    let index = 0;
    let ignore = 0;
    let skip = 0;
    while (index < list.length) {
        const current = list[index];
        const isParentSpanColumn = isInSpanColumn(current);
        if (current === target) {
            break;
        }
        if ((ignore-- <= 0) && isParentSpanColumn) {
            ignore = current.parent.children.length - 1;
            skip += ignore;
        }
        index++;
    }
    return index - skip;
};
/**
 * @hidden
 */
class ColumnHandleDirective {
    draggable;
    element;
    service;
    zone;
    cdr;
    ctx;
    columnInfoService;
    isLast;
    columns = [];
    column;
    get visible() {
        if (this.isConstrainedMode && (this.isLast || this.isLastInGroup(this.column))) {
            return 'none';
        }
        return this.column.resizable ? 'block' : 'none';
    }
    get leftStyle() {
        return isTruthy(this.rtl) ? 0 : null;
    }
    get rightStyle() {
        return isTruthy(this.rtl) ? null : 0;
    }
    get isConstrainedMode() {
        const isConstrainedMode = this.ctx.grid?.resizable === 'constrained';
        const isUnconstrainedMode = this.ctx.grid?.resizable === true || this.ctx.grid?.resizable === 'unconstrained';
        const constrainedNoShift = isConstrainedMode && !this.service.isShiftPressed;
        const unconstrainedWithShift = isUnconstrainedMode && this.service.isShiftPressed;
        return constrainedNoShift || unconstrainedWithShift;
    }
    subscriptions = new Subscription();
    rtl = false;
    totalChildrenSum = 0;
    childrenColumns = [];
    minWidthTotal = 0;
    foundColumn;
    autoFit() {
        this.service.autoFitResize = true;
        const allLeafs = allLeafColumns(this.columns);
        const currentLeafs = leafColumns([this.column]).filter(column => isTruthy(column.resizable));
        const columnInfo = currentLeafs.map(column => {
            const isParentSpan = isInSpanColumn(column);
            const isLastInSpan = isParentSpan ? column.parent.children.last === column : false;
            const index = indexOf(column, allLeafs);
            return {
                column,
                headerIndex: this.columnsForLevel(column.level).indexOf(column),
                index,
                isLastInSpan,
                isParentSpan,
                level: column.level
            };
        });
        currentLeafs.forEach(column => column.width = 0);
        this.service.measureColumns(columnInfo);
    }
    constructor(draggable, element, service, zone, cdr, ctx, columnInfoService) {
        this.draggable = draggable;
        this.element = element;
        this.service = service;
        this.zone = zone;
        this.cdr = cdr;
        this.ctx = ctx;
        this.columnInfoService = columnInfoService;
    }
    ngOnInit() {
        if (isDocumentAvailable() && isBlank(this.column.width)) {
            this.column.implicitWidth = headerWidth(this.element);
        }
        const service = this.service.changes.pipe(filter(() => this.column.resizable), filter(e => isPresent(e.columns.find(column => column === this.column))));
        this.subscriptions.add(service.pipe(filter(e => e.type === 'start'))
            .subscribe(this.initState.bind(this)));
        this.subscriptions.add(service.pipe(filter(e => e.type === 'resizeColumn'))
            .subscribe(this.resize.bind(this)));
        this.subscriptions.add(this.service.changes.pipe(filter(e => e.type === 'start'), filter(this.shouldUpdate.bind(this)), take(1) //on first resize only
        ).subscribe(this.initColumnWidth.bind(this)));
        this.subscriptions.add(this.zone.runOutsideAngular(() => this.draggable.kendoPress.pipe(tap(this.stopPropagation), tap(() => this.service.start(this.column)), switchMap(preventOnDblClick(this.draggable.kendoRelease)), switchMap(createMoveStream(this.service, this.draggable)))
            .subscribe(({ pageX, originalX }) => {
            const delta = pageX - originalX;
            const percent = toPercentage(delta, this.column.resizeStartWidth || this.column.width);
            this.service.resizeColumns(percent);
        })));
        this.subscriptions.add(service.pipe(filter(e => e.type === 'autoFitComplete'))
            .subscribe(this.sizeToFit.bind(this)));
        this.subscriptions.add(service.pipe(filter(e => e.type === 'triggerAutoFit'))
            .subscribe(this.autoFit.bind(this)));
        this.subscriptions.add(this.ctx.localization.changes.subscribe(({ rtl }) => this.rtl = rtl));
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    }
    shouldUpdate() {
        return !allLeafColumns(this.columns)
            .map(column => column.width || (this.isConstrainedMode && !column.width && column.implicitWidth))
            .some(isBlank);
    }
    initColumnWidth() {
        if (!isDocumentAvailable()) {
            return;
        }
        this.column.width = headerWidth(this.element);
        if (this.isConstrainedMode) {
            this.column.resizeStartWidth = this.column.width;
        }
    }
    initState() {
        if (!isDocumentAvailable()) {
            return;
        }
        this.column.resizeStartWidth = headerWidth(this.element);
        if (this.isConstrainedMode && !this.service.adjacentColumn) {
            this.setAdjacentColumn();
        }
        this.service.resizedColumn({
            column: this.column,
            oldWidth: this.column.resizeStartWidth
        });
    }
    resize({ deltaPercent }) {
        let delta = fromPercentage(this.column.resizeStartWidth, deltaPercent);
        if (isTruthy(this.rtl)) {
            delta *= -1;
        }
        let newWidth = Math.max(this.column.resizeStartWidth + delta, this.column.minResizableWidth);
        if (isPresent(this.column.maxResizableWidth)) {
            newWidth = Math.min(newWidth, this.column.maxResizableWidth);
        }
        if (this.isConstrainedMode) {
            newWidth = this.calcNewColumnWidth(newWidth);
        }
        const tableDelta = this.getTableDelta(newWidth, delta);
        this.updateWidth(this.column, newWidth);
        this.service.resizeTable(this.column, tableDelta);
    }
    sizeToFit({ columns, widths }) {
        const index = columns.indexOf(this.column);
        const width = Math.max(...widths.map(w => w[index])) + 1; //add 1px for IE
        const tableDelta = width - this.column.resizeStartWidth;
        this.updateWidth(this.column, width);
        this.service.resizeTable(this.column, tableDelta);
    }
    updateWidth(column, width) {
        if (this.isConstrainedMode && this.service.adjacentColumn && !this.service.autoFitResize) {
            this.updateWidthsOfResizedColumns(column, width);
        }
        column.width = width;
        this.columnInfoService.hiddenColumns.forEach((col) => {
            if (isBlank(col.width) && isPresent(col.implicitWidth)) {
                // Resize hidden columns to their implicit width so they
                // can be displayed with the same width if made visible.
                col.width = col.implicitWidth;
            }
        });
        this.cdr.markForCheck(); //force CD cycle
    }
    updateWidthsOfResizedColumns(column, width) {
        let adjacentColumnNewWidth = column.resizeStartWidth + this.service.adjacentColumn.resizeStartWidth - width;
        if (this.service.draggedGroupColumn && column.parent) {
            this.updateWidthOfDraggedColumn(column, width);
            this.setGroupWidths(this.service.draggedGroupColumn);
        }
        else if (!this.service.draggedGroupColumn && !column.parent && this.service.adjacentColumn.parent) {
            this.service.adjacentColumn.parent.width = column.width + this.service.adjacentColumn.parent.width - width;
            this.service.adjacentColumn.width = adjacentColumnNewWidth;
        }
        else if (!this.service.draggedGroupColumn && column.parent && this.service.adjacentColumn.parent) {
            adjacentColumnNewWidth = column.width + this.service.adjacentColumn.width - width;
            this.service.adjacentColumn.width = adjacentColumnNewWidth;
            const filteredColumns = this.service.adjacentColumn.parent.children.filter(c => c !== this.service.adjacentColumn);
            const filteredColumnsWidth = filteredColumns.reduce((acc, c) => acc + c.width, 0);
            this.service.adjacentColumn.parent.width = adjacentColumnNewWidth + filteredColumnsWidth;
            this.setGroupWidths(this.service.adjacentColumn.parent);
        }
        else if (adjacentColumnNewWidth > this.service.adjacentColumn.minResizableWidth) {
            this.service.adjacentColumn.width = adjacentColumnNewWidth;
        }
    }
    calcNewColumnWidth(newWidth) {
        let maxAllowedResizableWidth;
        if (!this.service.adjacentColumn.parent) {
            maxAllowedResizableWidth = this.column.width + this.service.adjacentColumn.width - this.service.adjacentColumn.minResizableWidth;
            if (!this.column.parent) {
                maxAllowedResizableWidth = this.column.resizeStartWidth + this.service.adjacentColumn.resizeStartWidth - this.service.adjacentColumn.minResizableWidth;
                if (this.service.adjacentColumn.maxResizableWidth) {
                    const minResizableWidth = this.column.resizeStartWidth + this.service.adjacentColumn.resizeStartWidth - this.service.adjacentColumn.maxResizableWidth;
                    maxAllowedResizableWidth = this.column.resizeStartWidth + this.service.adjacentColumn.resizeStartWidth - this.service.adjacentColumn.minResizableWidth;
                    this.column.minResizableWidth = minResizableWidth;
                    this.column.maxResizableWidth = maxAllowedResizableWidth;
                }
            }
        }
        else {
            maxAllowedResizableWidth = this.column.width + this.service.adjacentColumn.width;
            newWidth = Math.min(newWidth, maxAllowedResizableWidth);
            this.minWidthTotal = 0;
            const minResizableWidth = this.minAdjacentColumnWidth(this.service.adjacentColumn);
            maxAllowedResizableWidth -= minResizableWidth;
        }
        return Math.min(newWidth, maxAllowedResizableWidth - 1);
    }
    setAdjacentColumn() {
        const columnsForLevel = this.columnsForLevel(this.column.level);
        if (this.column.parent) {
            if (this.column.isReordered) {
                this.service.adjacentColumn = columnsForLevel.find(c => c.orderIndex === this.column.orderIndex + 1);
                this.service.adjacentColumn.resizeStartWidth = this.service.adjacentColumn.width;
            }
            else {
                const columnIndex = columnsForLevel.indexOf(this.column);
                this.service.adjacentColumn = columnsForLevel[columnIndex + 1];
                this.service.adjacentColumn.resizeStartWidth = adjacentColumnWidth(this.element);
                const parentColumnChildren = Array.from(this.column.parent.children);
                const indexOfCurrentColumn = parentColumnChildren.indexOf(this.column);
                let adjacentColumn;
                if (indexOfCurrentColumn + 1 <= parentColumnChildren.length - 1) {
                    adjacentColumn = parentColumnChildren[indexOfCurrentColumn + 1];
                    if (adjacentColumn?.isColumnGroup) {
                        this.service.adjacentColumn = adjacentColumn;
                    }
                }
            }
            if (this.service.adjacentColumn.isColumnGroup) {
                this.foundColumn = null;
                this.service.adjacentColumn = this.firstGroupChild(this.service.adjacentColumn);
            }
            if (this.column.isColumnGroup) {
                this.service.draggedGroupColumn = this.column;
            }
        }
        else if (this.column.isColumnGroup) {
            if (this.column.isReordered) {
                this.service.adjacentColumn = columnsForLevel.find(c => c.orderIndex === this.column.orderIndex + 1);
            }
            else {
                this.service.adjacentColumn = columnsForLevel[columnsForLevel.indexOf(this.column) + 1];
            }
            this.service.adjacentColumn.resizeStartWidth = adjacentColumnWidth(this.element);
            if (this.service.adjacentColumn.isColumnGroup) {
                this.foundColumn = null;
                this.service.adjacentColumn = this.firstGroupChild(this.service.adjacentColumn);
            }
            this.service.adjacentColumn.resizeStartWidth = this.service.adjacentColumn.width;
            this.service.draggedGroupColumn = this.column;
        }
        else {
            if (this.column.isReordered) {
                this.service.adjacentColumn = columnsForLevel.find(col => col.orderIndex === this.column.orderIndex + 1);
            }
            else {
                let adjacentColumn = columnsForLevel.find(c => c.leafIndex === this.column.leafIndex + 1);
                if (!adjacentColumn) {
                    const indexOfCurrentColumn = columnsForLevel.indexOf(this.column);
                    adjacentColumn = columnsForLevel[indexOfCurrentColumn + 1];
                }
                this.service.adjacentColumn = adjacentColumn;
            }
            if (!this.service.adjacentColumn.parent) {
                this.service.adjacentColumn.resizeStartWidth = adjacentColumnWidth(this.element);
            }
            if (this.service.adjacentColumn.isColumnGroup) {
                this.foundColumn = null;
                this.service.adjacentColumn = this.firstGroupChild(this.service.adjacentColumn);
                const rowIndex = this.service.adjacentColumn.level + 1;
                const colIndex = this.service.adjacentColumn.leafIndex + 1;
                this.service.adjacentColumn.resizeStartWidth = adjacentColumnInGroupWidth(this.element, rowIndex, colIndex);
            }
        }
        this.service.resizedColumn({
            column: this.service.adjacentColumn,
            oldWidth: this.service.adjacentColumn.resizeStartWidth
        });
    }
    firstGroupChild(column) {
        Array.from(column.children).sort((a, b) => a.orderIndex - b.orderIndex).forEach((c, idx) => {
            if (idx === 0 && !c.isColumnGroup) {
                if (!this.foundColumn) {
                    this.foundColumn = c;
                }
            }
            else if (c.isColumnGroup) {
                this.firstGroupChild(c);
            }
        });
        return this.foundColumn;
    }
    setGroupWidths(column) {
        const childrenWidths = column.children.reduce((acc, c) => acc + c.width, 0);
        column.width = childrenWidths;
        column.children.forEach(c => {
            if (c.isColumnGroup) {
                this.setGroupWidths(c);
            }
        });
    }
    updateWidthOfDraggedColumn(column, width) {
        this.totalChildrenSum = 0;
        this.childrenColumns = [];
        this.calcChildrenWidth(this.service.draggedGroupColumn);
        const childrenWidthNotIncludingColumn = this.childrenColumns.reduce((acc, col) => {
            return col !== column ? acc + col.width : acc;
        }, 0);
        this.service.draggedGroupColumn.width = childrenWidthNotIncludingColumn + width;
        if (this.service.adjacentColumn.minResizableWidth <= this.totalChildrenSum + this.service.adjacentColumn.resizeStartWidth - width - childrenWidthNotIncludingColumn) {
            this.service.adjacentColumn.width = this.totalChildrenSum + this.service.adjacentColumn.resizeStartWidth - width - childrenWidthNotIncludingColumn;
        }
    }
    calcChildrenWidth(column) {
        const columnChildren = Array.from(column.children);
        const childrenNoGroups = columnChildren.filter(c => !c.isColumnGroup);
        const childrenGroups = columnChildren.filter(c => c.isColumnGroup);
        childrenNoGroups.forEach(col => {
            if (this.childrenColumns.indexOf(col) === -1) {
                this.childrenColumns.push(col);
            }
        });
        this.totalChildrenSum += childrenNoGroups.reduce((acc, col) => acc + col.resizeStartWidth, 0);
        childrenGroups.forEach((col) => {
            this.calcChildrenWidth(col);
        });
    }
    columnsForLevel(level) {
        return columnsToRender(this.columns ? this.columns.filter(column => column.level === level) : []);
    }
    minAdjacentColumnWidth(column) {
        if (column.isColumnGroup) {
            Array.from(column.children).forEach(c => {
                this.minAdjacentColumnWidth(c);
            });
        }
        else {
            this.minWidthTotal += column.minResizableWidth;
            if (column.width < column.minResizableWidth) {
                column.width = column.minResizableWidth;
            }
        }
        return this.minWidthTotal;
    }
    getTableDelta(newWidth, delta) {
        const minWidth = this.column.minResizableWidth;
        const maxWidth = this.column.maxResizableWidth;
        const startWidth = this.column.resizeStartWidth;
        const isAboveMin = newWidth > minWidth;
        const isBelowMax = newWidth < maxWidth;
        const isInBoundaries = isPresent(maxWidth) ?
            isAboveMin && isBelowMax :
            isAboveMin;
        if (isInBoundaries) {
            return delta;
        }
        else if (newWidth <= minWidth) {
            return minWidth - startWidth;
        }
        else {
            return startWidth - maxWidth;
        }
    }
    stopPropagation = ({ originalEvent: event }) => {
        this.service.isShiftPressed = event.shiftKey;
        event.stopPropagation();
        event.preventDefault();
    };
    isLastInGroup(column) {
        if (column.parent) {
            const groupChildren = Array.from(column.parent.children);
            const indexOfCurrentColumn = groupChildren.indexOf(column);
            if (column.isReordered || column.orderIndex > 0 || (column.isReordered && column.orderIndex === 0)) {
                return (column.orderIndex - groupChildren[0].orderIndex) === groupChildren.length - 1;
            }
            else {
                return indexOfCurrentColumn === groupChildren.length - 1;
            }
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnHandleDirective, deps: [{ token: i1$3.DraggableDirective, host: true }, { token: i0.ElementRef }, { token: ColumnResizingService }, { token: i0.NgZone }, { token: i0.ChangeDetectorRef }, { token: ContextService }, { token: ColumnInfoService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: ColumnHandleDirective, isStandalone: true, selector: "[kendoGridColumnHandle]", inputs: { isLast: "isLast", columns: "columns", column: "column" }, host: { listeners: { "dblclick": "autoFit()" }, properties: { "style.display": "this.visible", "style.left": "this.leftStyle", "style.right": "this.rightStyle" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ColumnHandleDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridColumnHandle]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1$3.DraggableDirective, decorators: [{
                    type: Host
                }] }, { type: i0.ElementRef }, { type: ColumnResizingService }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }, { type: ContextService }, { type: ColumnInfoService }], propDecorators: { isLast: [{
                type: Input
            }], columns: [{
                type: Input
            }], column: [{
                type: Input
            }], visible: [{
                type: HostBinding,
                args: ['style.display']
            }], leftStyle: [{
                type: HostBinding,
                args: ['style.left']
            }], rightStyle: [{
                type: HostBinding,
                args: ['style.right']
            }], autoFit: [{
                type: HostListener,
                args: ['dblclick']
            }] } });

/**
 * @hidden
 */
class CellSelectionAggregateService {
    ctx;
    columnInfoService;
    selectedItems = [];
    groupedAggregates = { dates: [], numbers: [], booleans: [] };
    aggregates = {
        sum: null,
        average: null,
        min: null,
        max: null,
        count: null,
        isTrue: null,
        isFalse: null,
        earliest: null,
        latest: null
    };
    sub = new Subscription();
    constructor(ctx, columnInfoService) {
        this.ctx = ctx;
        this.columnInfoService = columnInfoService;
    }
    ngOnDestroy() {
        this.sub.unsubscribe();
    }
    isAggregateIncluded(aggregate) {
        const { cellAggregates } = this.ctx.grid.selectable;
        if (typeof cellAggregates !== 'boolean') {
            return cellAggregates?.includes(aggregate);
        }
        return true;
    }
    init() {
        this.sub.add(this.ctx.grid.dataStateChange.subscribe(() => {
            // nullifies aggregates and sets default count to avoid mismatching state -
            // https://github.com/telerik/kendo-angular-private/issues/2964
            this.nullifyAggregates();
            if (this.isAggregateIncluded('count')) {
                this.aggregates['count'] = 0;
            }
        }));
        if (this.ctx.grid.selectable.cellAggregates) {
            if (this.isAggregateIncluded('count')) {
                this.aggregates['count'] = 0;
            }
            const selectionDirective = this.ctx.grid.selectionDirective;
            if (selectionDirective && !this.isRowSelection) {
                this.selectedItems = selectionDirective.selectedKeys;
            }
        }
    }
    onSelectionChange(selectionArgs) {
        this.handleSelectedItems(selectionArgs);
        this.nullifyAggregates();
        this.handleAggregateChanges();
        return this.aggregates;
    }
    get isRowSelection() {
        return typeof this.ctx.grid.selectable === 'boolean' || !this.ctx.grid.selectable.cell;
    }
    handleAggregateChanges() {
        const lockedColumns = this.columnInfoService.lockedLeafColumns.toArray();
        const nonLockedColumns = this.columnInfoService.nonLockedLeafColumns.toArray();
        const selectedItemsLength = this.selectedItems.length;
        const columns = [...lockedColumns, ...nonLockedColumns];
        const fields = columns.map(col => col.field);
        if (this.isAggregateIncluded('count')) {
            this.aggregates['count'] = this.isRowSelection ? (selectedItemsLength * columns.length) : selectedItemsLength;
        }
        this.selectedItems.forEach((item) => {
            if (this.isRowSelection) {
                fields.forEach((field) => {
                    const cellValue = item.dataItem;
                    if (cellValue && cellValue.hasOwnProperty(field)) {
                        const cellValue = item.dataItem[field];
                        this.groupAggregates(cellValue);
                    }
                });
            }
            else if (!this.isRowSelection) {
                // Enables working with the current Grid data regardless of its form (array, GridDataResult, GroupedResult).
                // Currently gets the item by index only - https://github.com/telerik/kendo-angular-private/issues/2964
                const selectedItem = this.ctx.grid.flatData.flatMap(recursiveFlatMap)[item.itemKey];
                const field = fields[item.columnKey];
                if (selectedItem && selectedItem.hasOwnProperty(field)) {
                    const cellValue = selectedItem[fields[item.columnKey]];
                    this.groupAggregates(cellValue);
                }
            }
        });
        this.calculateAggregates();
    }
    groupAggregates(aggregate) {
        if (typeof aggregate === 'number') {
            this.groupedAggregates.numbers.push(aggregate);
        }
        else if (typeof aggregate === 'boolean') {
            this.groupedAggregates.booleans.push(aggregate);
        }
        else if (aggregate instanceof Date) {
            this.groupedAggregates.dates.push(aggregate);
        }
    }
    calculateAggregates() {
        if (this.groupedAggregates.numbers.length > 0) {
            if (this.isAggregateIncluded('min')) {
                this.aggregates['min'] = Math.min(...this.groupedAggregates.numbers);
            }
            if (this.isAggregateIncluded('max')) {
                this.aggregates['max'] = Math.max(...this.groupedAggregates.numbers);
            }
            if (this.isAggregateIncluded('sum')) {
                this.aggregates['sum'] = this.groupedAggregates.numbers.reduce((acc, curr) => acc += curr, 0);
            }
            if (this.isAggregateIncluded('average')) {
                this.aggregates['average'] = this.aggregates['sum'] / this.groupedAggregates.numbers.length;
            }
        }
        if (this.groupedAggregates.booleans.length > 0) {
            if (this.isAggregateIncluded('isTrue')) {
                const isTrueCount = this.groupedAggregates.booleans.filter(bool => bool).length;
                this.aggregates['isTrue'] = isTrueCount > 0 ? isTrueCount : null;
            }
            if (this.isAggregateIncluded('isFalse')) {
                const isFalseCount = this.groupedAggregates.booleans.length - this.aggregates['isTrue'];
                this.aggregates['isFalse'] = isFalseCount > 0 ? isFalseCount : null;
            }
        }
        if (this.groupedAggregates.dates.length > 0) {
            if (this.isAggregateIncluded('earliest')) {
                this.aggregates['earliest'] = new Date(Math.min(...this.groupedAggregates.dates));
            }
            if (this.isAggregateIncluded('latest')) {
                this.aggregates['latest'] = new Date(Math.max(...this.groupedAggregates.dates));
            }
        }
    }
    handleSelectedItems(selectionArgs) {
        const rowOrCellSelect = `${this.isRowSelection ? 'selectedRows' : 'selectedCells'}`;
        const rowOrCellDeselect = `${this.isRowSelection ? 'deselectedRows' : 'deselectedCells'}`;
        const selectedItems = selectionArgs[rowOrCellSelect];
        const deselectedItems = selectionArgs[rowOrCellDeselect];
        if (!this.isRowSelection) {
            // Needed when we have column groups with cell selection, the deselected items are duplicated
            deselectedItems.forEach((item, index) => {
                if (index + 1 < deselectedItems.length) {
                    if (item.itemKey === deselectedItems[index + 1].itemKey
                        && item.columnKey === deselectedItems[index + 1].columnKey) {
                        deselectedItems.splice(index, 1);
                    }
                }
            });
        }
        if (selectedItems.length > 0) {
            selectedItems.forEach((item) => {
                this.selectedItems = [...this.selectedItems, item];
            });
        }
        if (deselectedItems.length > 0) {
            if (this.isRowSelection) {
                deselectedItems.forEach((row) => {
                    this.selectedItems = this.selectedItems.filter((elem) => elem.dataItem !== row.dataItem);
                });
            }
            else {
                deselectedItems.forEach((cell) => {
                    const index = this.selectedItems.findIndex((elem) => elem.itemKey === cell.itemKey && elem.columnKey === cell.columnKey);
                    this.selectedItems.splice(index, 1);
                });
            }
        }
    }
    nullifyAggregates() {
        this.groupedAggregates = { dates: [], numbers: [], booleans: [] };
        this.aggregates['count'] = null;
        this.aggregates['sum'] = this.aggregates['average'] = null;
        this.aggregates['max'] = this.aggregates['min'] = null;
        this.aggregates['isFalse'] = this.aggregates['isTrue'] = null;
        this.aggregates['earliest'] = this.aggregates['latest'] = null;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CellSelectionAggregateService, deps: [{ token: ContextService }, { token: ColumnInfoService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CellSelectionAggregateService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CellSelectionAggregateService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: ContextService }, { type: ColumnInfoService }] });

/**
 * @hidden
 */
class SelectionService {
    domEvents;
    aggregateService;
    localDataChangesService;
    navigationService;
    ctxService;
    changes = new EventEmitter();
    lastSelectionStartIndex;
    currentSelection = [];
    nonSelectableRows = new Map();
    selectAllChecked = false;
    settings;
    active = false;
    aggregates;
    get enableMarquee() {
        const checkboxOnly = this.settings && typeof this.settings === 'object' && this.settings.checkboxOnly;
        if (!this.settings || checkboxOnly) {
            return false;
        }
        const selectableSettings = this.settings.selectable;
        const dragAndMultiple = typeof (selectableSettings) === 'object' &&
            isPresent(selectableSettings) &&
            selectableSettings.mode === 'multiple' &&
            selectableSettings.enabled !== false &&
            !selectableSettings.checkboxOnly &&
            selectableSettings.drag;
        return this.active && dragAndMultiple;
    }
    mouseDownEventArgs;
    dragging = false;
    get hasNonSelectable() {
        return this.nonSelectableRows.size > 0;
    }
    cellClickSubscription;
    mousedownSubscription;
    dataChangedSubscription;
    lastSelectionData = {};
    _selectAllState;
    constructor(domEvents, aggregateService, localDataChangesService, navigationService, ctxService) {
        this.domEvents = domEvents;
        this.aggregateService = aggregateService;
        this.localDataChangesService = localDataChangesService;
        this.navigationService = navigationService;
        this.ctxService = ctxService;
        this.addSubscriptions();
    }
    init(settings) {
        this.settings = settings;
        if (!isPresent(this.lastSelectionStartIndex)) {
            this.lastSelectionStartIndex = this.ctxService?.grid.selectionDirective?.rangeSelectionStartRow?.index || 0;
            this.lastSelectionData = this.ctxService?.grid.selectionDirective?.rangeSelectionStartRow?.dataItem || {};
        }
        this.currentSelection = [];
        this.nonSelectableRows = new Map();
        if (settings.selectable && settings.selectable.enabled !== false) {
            const iterator = this.getIterator();
            this._selectAllState = true;
            let item = iterator.next();
            while (!item.done) {
                if (item.value && item.value.type === "data") {
                    const rowArgs = {
                        dataItem: item.value.data,
                        index: item.value.index
                    };
                    if (settings.rowSelected(rowArgs)) {
                        this.currentSelection[item.value.index] = rowArgs;
                    }
                    else {
                        this._selectAllState = undefined;
                    }
                    if (!settings.isRowSelectable(rowArgs)) {
                        this.nonSelectableRows.set(rowArgs.index, rowArgs.dataItem);
                        this._selectAllState = undefined;
                    }
                }
                item = iterator.next();
            }
            if (this.currentSelection.length === 0) {
                this._selectAllState = false;
            }
        }
    }
    isSelected(index) {
        if (this.settings && this.active) {
            return this.options.enabled && isPresent(this.currentSelection[index]) && !this.nonSelectableRows.has(index);
        }
    }
    handleClick(item, event) {
        if (this.dragging) {
            this.dragging = false;
            return;
        }
        let ev;
        const ctrlKey = event.ctrlKey || event.metaKey;
        if (this.options.mode === "single" && ctrlKey && this.isSelected(item.index)) {
            ev = this.toggle(item);
        }
        else if (this.options.mode === "multiple") {
            if ((ctrlKey || !this.options.metaKeyMultiSelect) && !event.shiftKey) {
                ev = this.toggle(item);
            }
            else if (event.shiftKey) {
                const preserveCurrentSelection = isMultipleRangesEnabled(this.settings);
                ev = this.addAllTo(item, ctrlKey, preserveCurrentSelection);
            }
        }
        if (!isPresent(ev)) {
            ev = this.select(item);
            this.currentSelection[item.index] = {
                dataItem: item.data,
                index: item.index
            };
        }
        if (!ev.selectedRows.length && !ev.deselectedRows.length) {
            return;
        }
        ev.ctrlKey = ctrlKey;
        ev.shiftKey = event.shiftKey;
        if (this.options.cellAggregates) {
            ev.cellAggregates = this.aggregateService.onSelectionChange(ev);
        }
        if (ev.shiftKey) {
            ev.rangeStartRow = { dataItem: this.lastSelectionData, index: this.lastSelectionStartIndex };
            ev.rangeEndRow = { dataItem: item.data, index: item.index };
            this.lastSelectionData = item.data;
            this.lastSelectionStartIndex = item.index;
        }
        this.syncCurrentSelection(ev);
        this.changes.emit(ev);
    }
    toggle(item) {
        const selectedRows = [];
        const deselectedRows = [];
        this.lastSelectionStartIndex = item.index;
        this.lastSelectionData = item.data;
        const rowArgs = { dataItem: item.data, index: item.index };
        if (this.isSelected(item.index)) {
            deselectedRows.push(rowArgs);
        }
        else if (!this.nonSelectableRows.has(item.index)) {
            selectedRows.push(rowArgs);
        }
        if (this.hasNonSelectable) {
            const nonSelectableRows = this.currentSelection.filter(i => this.nonSelectableRows.has(i.index));
            deselectedRows.push(...nonSelectableRows);
        }
        return {
            deselectedRows: deselectedRows,
            selectedRows: selectedRows
        };
    }
    toggleByIndex(index) {
        const iterator = this.getIterator();
        if (this.selectAllChecked && this.isSelected(index)) {
            this.selectAllChecked = false;
        }
        let item = iterator.next();
        while (!item.done) {
            if (item.value && item.value.type === "data" && item.value.index === index) {
                const itemToToggle = {
                    data: item.value.data,
                    index: item.value.index
                };
                if (this.isSelected(index) || this.options.mode === "multiple") {
                    return this.toggle(itemToToggle);
                }
                else {
                    return this.select(itemToToggle);
                }
            }
            item = iterator.next();
        }
    }
    select(item) {
        const deselectedRows = [];
        const selectedRows = [];
        this.lastSelectionStartIndex = item.index;
        this.lastSelectionData = item.data;
        if (!this.isSelected(item.index) && !this.nonSelectableRows.has(item.index)) {
            selectedRows.push({ dataItem: item.data, index: item.index });
        }
        this.currentSelection.forEach((row) => {
            if (row.index !== item.index) {
                deselectedRows.push(row);
            }
        });
        return {
            deselectedRows: deselectedRows,
            selectedRows: selectedRows
        };
    }
    //Used to manually deselect removed items
    deselect(removedItem) {
        const iterator = this.getIterator();
        let item = iterator.next();
        while (!item.done) {
            if (item.value && item.value.type === "data" && item.value.data === removedItem) {
                const rowArgs = {
                    dataItem: item.value.data,
                    index: item.value.index
                };
                if (this.isSelected(rowArgs.index) || this.nonSelectableRows.has(rowArgs.index)) {
                    const ev = {
                        ctrlKey: false,
                        deselectedRows: [rowArgs],
                        selectedRows: []
                    };
                    this.syncCurrentSelection(ev);
                    this.changes.emit(ev);
                }
            }
            item = iterator.next();
        }
    }
    addAllTo(item, ctrlKey, preserveSelection = false, shiftKey = false) {
        const selectedRows = [];
        const deselectedRows = [];
        const start = Math.min(this.lastSelectionStartIndex, item.index);
        const end = Math.max(this.lastSelectionStartIndex, item.index);
        const iterator = this.getIterator();
        let next = iterator.next();
        let selectedItem;
        while (!next.done) {
            if (next.value && next.value.type === "data") {
                const idx = next.value.index;
                const rowArgs = { dataItem: next.value.data, index: idx };
                if ((idx < start || idx > end) && this.isSelected(idx) && !ctrlKey && !preserveSelection) {
                    deselectedRows.push(rowArgs);
                }
                if ((idx >= start && idx <= end) && !this.isSelected(idx) && !this.nonSelectableRows.has(idx)) {
                    selectedRows.push(rowArgs);
                }
                if (idx === item.index && !this.nonSelectableRows.has(idx)) {
                    selectedItem = rowArgs;
                }
            }
            next = iterator.next();
        }
        if (this.hasNonSelectable) {
            const nonSelectableRows = this.currentSelection.filter(i => this.nonSelectableRows.has(i.index));
            deselectedRows.push(...nonSelectableRows);
        }
        const selectionEvent = {
            deselectedRows,
            selectedRows
        };
        if (shiftKey && selectedItem) {
            selectionEvent.rangeStartRow = {
                dataItem: this.lastSelectionData,
                index: this.lastSelectionStartIndex
            };
            selectionEvent.rangeEndRow = {
                dataItem: selectedItem.dataItem,
                index: selectedItem.index
            };
            this.lastSelectionData = selectedItem.dataItem;
            this.lastSelectionStartIndex = selectedItem.index;
        }
        return selectionEvent;
    }
    updateAll(selectAllChecked) {
        this.selectAllChecked = selectAllChecked;
        const selectedRows = [];
        const deselectedRows = [];
        const iterator = this.getIterator();
        let next = iterator.next();
        while (!next.done) {
            if (next.value && next.value.type === "data") {
                const idx = next.value.index;
                const rowArgs = { dataItem: next.value.data, index: idx };
                if (!this.nonSelectableRows.has(idx)) {
                    if (this.isSelected(idx) && !selectAllChecked) {
                        deselectedRows.push(rowArgs);
                    }
                    if (!this.isSelected(idx) && selectAllChecked) {
                        selectedRows.push(rowArgs);
                    }
                }
            }
            next = iterator.next();
        }
        if (!selectedRows.length && !deselectedRows.length) {
            return;
        }
        if (this.hasNonSelectable) {
            const nonSelectableRows = this.currentSelection.filter(i => this.nonSelectableRows.has(i.index));
            deselectedRows.push(...nonSelectableRows);
        }
        const ev = {
            ctrlKey: true,
            deselectedRows: deselectedRows,
            selectedRows: selectedRows,
            shiftKey: true
        };
        if (this.options.cellAggregates) {
            ev.cellAggregates = this.aggregateService.onSelectionChange(ev);
        }
        this.syncCurrentSelection(ev);
        this.changes.emit(ev);
    }
    selectRange(startIndex, endIndex, preserveSelection, existingSelections = []) {
        const selectedRows = [];
        const deselectedRows = [];
        const start = Math.min(startIndex, endIndex);
        const end = Math.max(startIndex, endIndex);
        const iterator = this.getIterator();
        let next = iterator.next();
        while (!next.done) {
            if (next.value && next.value.type === "data") {
                const idx = next.value.index;
                const rowArgs = { dataItem: next.value.data, index: idx };
                if ((idx < start || idx > end) && this.isSelected(idx)) {
                    const deselectRow = !(preserveSelection || existingSelections.find((value) => value && value.dataItem === rowArgs.dataItem && value.index === rowArgs.index));
                    if (deselectRow) {
                        deselectedRows.push(rowArgs);
                    }
                }
                if ((idx >= start && idx <= end) && !this.isSelected(idx) && !this.nonSelectableRows.has(idx)) {
                    selectedRows.push(rowArgs);
                }
            }
            next = iterator.next();
        }
        let cellAggregates;
        if (this.options.cellAggregates) {
            cellAggregates = this.aggregateService.onSelectionChange({ selectedRows, deselectedRows });
        }
        if (this.hasNonSelectable) {
            const nonSelectableRows = this.currentSelection.filter(i => this.nonSelectableRows.has(i.index));
            deselectedRows.push(...nonSelectableRows);
        }
        return {
            deselectedRows: deselectedRows,
            selectedRows: selectedRows,
            cellAggregates
        };
    }
    get selectAllState() {
        return this._selectAllState;
    }
    get selected() {
        return this.currentSelection.map((item) => {
            return item.index;
        }).filter((n) => typeof n === "number");
    }
    get options() {
        const defaultOptions = {
            cellAggregates: false,
            checkboxOnly: false,
            enabled: true,
            mode: "multiple",
            metaKeyMultiSelect: true
        };
        if (!isPresent(this.settings)) {
            return defaultOptions;
        }
        if (typeof this.settings.selectable === 'boolean') {
            return {
                cellAggregates: false,
                checkboxOnly: false,
                enabled: this.settings.selectable,
                mode: "multiple",
                metaKeyMultiSelect: true
            };
        }
        else {
            return Object.assign(defaultOptions, this.settings.selectable);
        }
    }
    ngOnDestroy() {
        this.removeSubscriptions();
    }
    targetArgs() {
        return {
            index: this.mouseDownEventArgs.rowIndex,
            dataItem: this.mouseDownEventArgs.dataItem
        };
    }
    addSubscriptions() {
        if (!this.cellClickSubscription) {
            this.cellClickSubscription = this.domEvents.cellClick.subscribe((args) => {
                if (this.options.enabled && !this.options.checkboxOnly && args.type !== 'contextmenu') {
                    if (this.active) {
                        this.handleClick({ index: args.rowIndex, data: args.dataItem }, args.originalEvent);
                    }
                }
            });
        }
        if (!this.mousedownSubscription) {
            this.mousedownSubscription = this.domEvents.cellMousedown.subscribe((args) => {
                this.mouseDownEventArgs = args;
                if ((this.options.enabled && (!this.options.mode || this.options.mode === "multiple") &&
                    !this.options.checkboxOnly && args.originalEvent.shiftKey)) {
                    if (this.active) {
                        args.originalEvent.preventDefault();
                        this.navigationService.focusCellByElement(args.originalEvent.target);
                    }
                }
            });
        }
        if (this.localDataChangesService && !this.dataChangedSubscription) {
            this.dataChangedSubscription = this.localDataChangesService.changes.subscribe((args) => {
                if (this.active) {
                    if (isPresent(args.action) && args.action === 'remove') {
                        this.deselect(args.item);
                    }
                }
            });
        }
    }
    getIterator() {
        const accessor = this.settings.view.accessor();
        if (!accessor) {
            return;
        }
        return accessor[iterator]();
    }
    removeSubscriptions() {
        if (this.cellClickSubscription) {
            this.cellClickSubscription.unsubscribe();
            this.cellClickSubscription = null;
        }
        if (this.mousedownSubscription) {
            this.mousedownSubscription.unsubscribe();
            this.mousedownSubscription = null;
        }
        if (this.dataChangedSubscription) {
            this.dataChangedSubscription.unsubscribe();
            this.dataChangedSubscription = null;
        }
    }
    syncCurrentSelection(ev) {
        for (const row of ev.deselectedRows) {
            this.currentSelection.splice(row.index, 1);
        }
        for (const row of ev.selectedRows) {
            this.currentSelection[row.index] = row;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SelectionService, deps: [{ token: DomEventsService }, { token: CellSelectionAggregateService }, { token: LocalDataChangesService }, { token: NavigationService }, { token: ContextService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SelectionService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SelectionService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: DomEventsService }, { type: CellSelectionAggregateService }, { type: LocalDataChangesService }, { type: NavigationService }, { type: ContextService }] });

/**
 * @hidden
 */
class CellSelectionService {
    domEvents;
    aggregateService;
    localDataChangesService;
    navigationService;
    changes = new EventEmitter();
    mouseUpEvent = new EventEmitter();
    currentSelection = [];
    settings;
    active = false;
    aggregates;
    nonSelectableRows = new Map();
    get enableMarquee() {
        const checkboxOnly = this.settings && typeof this.settings === 'object' && this.settings.checkboxOnly;
        if (!this.settings || checkboxOnly || this.settings.isStacked) {
            return false;
        }
        const selectableSettings = this.settings.selectable;
        const dragAndMultiple = typeof (selectableSettings) === 'object' &&
            isPresent(selectableSettings) &&
            selectableSettings.mode === 'multiple' &&
            selectableSettings.cell &&
            selectableSettings.enabled !== false &&
            selectableSettings.drag;
        return this.active && dragAndMultiple;
    }
    get hasNonSelectable() {
        return this.nonSelectableRows.size > 0;
    }
    mouseDownEventArgs;
    mouseUpEventArgs;
    dragging = false;
    dragSelectDeselect = false;
    lastSelectionItem = { itemKey: 0, columnKey: 0 };
    lastSelectionItemRowIndex = 0;
    lastSelectionItemColIndex = 0;
    cellClickSubscription;
    dataChangedSubscription;
    mousedownSubscription;
    constructor(domEvents, aggregateService, localDataChangesService, navigationService) {
        this.domEvents = domEvents;
        this.aggregateService = aggregateService;
        this.localDataChangesService = localDataChangesService;
        this.navigationService = navigationService;
        this.addSubscriptions();
    }
    init(settings) {
        this.settings = settings;
        this.currentSelection = [];
        this.nonSelectableRows = new Map();
        if (settings.selectable && settings.selectable.enabled !== false && !settings.isStacked) {
            const iterator = this.getIterator();
            let item = iterator.next();
            while (!item.done) {
                if (item.value && item.value.type === "data") {
                    const rowArgs = {
                        dataItem: item.value.data,
                        index: item.value.index
                    };
                    settings.columns.forEach(col => {
                        const selectedCellArgs = settings.cellSelected(rowArgs, col, col.leafIndex);
                        if (selectedCellArgs.selected) {
                            this.currentSelection.push(selectedCellArgs.item);
                        }
                        if (!settings.isRowSelectable(rowArgs)) {
                            this.nonSelectableRows.set(rowArgs.index, rowArgs.dataItem);
                        }
                    });
                }
                item = iterator.next();
            }
        }
    }
    isCellSelected(item, col) {
        if (this.settings && this.active && !this.settings.isStacked) {
            const selectedCellArgs = this.settings.cellSelected({ dataItem: item.data, index: item.index }, col, col.leafIndex);
            return this.options.enabled && selectedCellArgs.selected && !this.nonSelectableRows.has(item.index);
        }
        return false;
    }
    handleClick(item, event) {
        if (this.dragging) {
            this.dragging = false;
            return;
        }
        if (this.settings.isStacked) {
            return;
        }
        let ev;
        const ctrlKey = event.ctrlKey || event.metaKey;
        if (this.options.mode === "single" && ctrlKey && this.isCellSelected(item, item.column)) {
            ev = this.toggle(item);
        }
        else if (this.options.mode === "multiple") {
            if ((ctrlKey || !this.options.metaKeyMultiSelect) && !event.shiftKey) {
                ev = this.toggle(item);
            }
            else if (event.shiftKey) {
                const startRowIndex = Math.min(this.lastSelectionItemRowIndex, item.index);
                const startColIndex = Math.min(this.lastSelectionItemColIndex, item.column.leafIndex);
                const endRowIndex = Math.max(this.lastSelectionItemRowIndex, item.index);
                const endColIndex = Math.max(this.lastSelectionItemColIndex, item.column.leafIndex);
                const preserveCurrentSelection = isMultipleRangesEnabled(this.settings);
                ev = this.selectRange(startRowIndex, startColIndex, endRowIndex, endColIndex, preserveCurrentSelection);
                if (preserveCurrentSelection) {
                    this.lastSelectionItemRowIndex = item.index;
                    this.lastSelectionItemColIndex = item.column.leafIndex;
                }
            }
        }
        if (!isPresent(ev)) {
            ev = this.select(item);
            this.currentSelection = [this.lastSelectionItem];
        }
        if (!ev.selectedCells.length && !ev.deselectedCells.length) {
            return;
        }
        ev.ctrlKey = ctrlKey;
        ev.shiftKey = event.shiftKey;
        if (this.options.cellAggregates && !event.shiftKey) {
            ev.cellAggregates = this.aggregateService.onSelectionChange(ev);
        }
        if (ev.shiftKey) {
            ev.rangeStartCell = this.lastSelectionItem;
            ev.rangeEndCell = {
                ...this.settings.cellSelected({ dataItem: item.data, index: item.index }, item.column, item.column.leafIndex).item
            };
        }
        this.changes.emit(ev);
    }
    toggle(item) {
        const selectedCells = [];
        const deselectedCells = [];
        this.lastSelectionItem =
            this.settings.cellSelected({ dataItem: item.data, index: item.index }, item.column, item.column.leafIndex).item;
        this.lastSelectionItemRowIndex = item.index;
        this.lastSelectionItemColIndex = item.column.leafIndex;
        if (this.isCellSelected(item, item.column)) {
            deselectedCells.push(this.lastSelectionItem);
        }
        else if (!this.nonSelectableRows.has(item.index)) {
            selectedCells.push(this.lastSelectionItem);
        }
        return {
            deselectedCells,
            selectedCells
        };
    }
    select(item) {
        const selectedCells = [];
        const deselectedCells = [];
        this.lastSelectionItem =
            this.settings.cellSelected({ dataItem: item.data, index: item.index }, item.column, item.column.leafIndex).item;
        this.lastSelectionItemRowIndex = item.index;
        this.lastSelectionItemColIndex = item.column.leafIndex;
        if (!this.isCellSelected(item, item.column) && !this.nonSelectableRows.has(item.index)) {
            selectedCells.push(this.lastSelectionItem);
        }
        this.currentSelection.forEach((selectedItem) => {
            if (selectedItem.itemKey !== this.lastSelectionItem.itemKey || selectedItem.columnKey !== this.lastSelectionItem.columnKey) {
                deselectedCells.push(selectedItem);
            }
        });
        return {
            deselectedCells,
            selectedCells
        };
    }
    //Used to manually deselect removed items
    deselect(removedItem) {
        const iterator = this.getIterator();
        let item = iterator.next();
        let rowArgs;
        while (!item.done) {
            if (item.value && item.value.type === "data" && item.value.data === removedItem) {
                rowArgs = {
                    dataItem: item.value.data,
                    index: item.value.index
                };
                break;
            }
            item = iterator.next();
        }
        if (rowArgs) {
            const cellsToRemove = this.currentSelection.filter(selectedItem => {
                const contender = this.settings.cellSelected(rowArgs, null, null).item;
                return selectedItem.itemKey === contender.itemKey || this.nonSelectableRows.has(rowArgs.index);
            });
            if (cellsToRemove.length) {
                const ev = {
                    ctrlKey: false,
                    deselectedCells: cellsToRemove,
                    selectedCells: []
                };
                this.changes.emit(ev);
            }
        }
    }
    selectRange(startRowIndex, startColIndex, endRowIndex, endColIndex, preserveSelection = false, existingSelections = []) {
        const selectedCells = [];
        const deselectedCells = [];
        const selectionStartRow = Math.min(startRowIndex, endRowIndex);
        const selectionStartCol = Math.min(startColIndex, endColIndex);
        const selectionEndRow = Math.max(startRowIndex, endRowIndex);
        const selectionEndCol = Math.max(startColIndex, endColIndex);
        const iterator = this.getIterator();
        let next = iterator.next();
        while (!next.done) {
            if (next.value && next.value.type === "data") {
                const idx = next.value.index;
                const data = next.value.data;
                const rowArgs = {
                    dataItem: data,
                    index: idx
                };
                this.settings.columns.forEach(col => {
                    const { item } = this.settings.cellSelected(rowArgs, col, col.leafIndex);
                    const selected = this.isCellSelected(next.value, col);
                    const isInRowRange = selectionStartRow <= idx && idx <= selectionEndRow;
                    const isInColRange = selectionStartCol <= col.leafIndex && col.leafIndex <= selectionEndCol;
                    const isInSelectionRect = isInRowRange && isInColRange;
                    if (!isInSelectionRect && selected) {
                        const deselectCell = !(preserveSelection || existingSelections.find((value) => value && value.itemKey === item.itemKey && value.columnKey === item.columnKey));
                        if (deselectCell) {
                            deselectedCells.push(item);
                        }
                    }
                    if (isInSelectionRect && !selected && !this.nonSelectableRows.has(idx)) {
                        selectedCells.push(item);
                    }
                });
            }
            next = iterator.next();
        }
        let cellAggregates;
        if (this.options.cellAggregates) {
            cellAggregates = this.aggregateService.onSelectionChange({ selectedCells, deselectedCells });
        }
        return {
            deselectedCells,
            selectedCells,
            cellAggregates
        };
    }
    get options() {
        const defaultOptions = {
            cellAggregates: false,
            checkboxOnly: false,
            enabled: true,
            mode: "multiple",
            metaKeyMultiSelect: true
        };
        if (!isPresent(this.settings)) {
            return defaultOptions;
        }
        if (typeof this.settings.selectable === 'boolean') {
            return {
                cellAggregates: false,
                checkboxOnly: false,
                enabled: this.settings.selectable,
                mode: "multiple",
                metaKeyMultiSelect: true
            };
        }
        else {
            return Object.assign(defaultOptions, this.settings.selectable);
        }
    }
    ngOnDestroy() {
        this.removeSubscriptions();
    }
    addSubscriptions() {
        if (!this.cellClickSubscription) {
            this.cellClickSubscription = this.domEvents.cellClick.subscribe((args) => {
                if (this.options.enabled && !this.options.checkboxOnly && args.type !== 'contextmenu') {
                    if (this.active) {
                        this.handleClick({ index: args.rowIndex, data: args.dataItem, column: args.column }, args.originalEvent);
                    }
                }
            });
        }
        if (!this.mousedownSubscription) {
            this.mousedownSubscription = this.domEvents.cellMousedown.subscribe((args) => {
                this.mouseDownEventArgs = args;
                if (this.options.enabled && (!this.options.mode || this.options.mode === "multiple") &&
                    !this.options.checkboxOnly && args.originalEvent.shiftKey) {
                    if (this.active) {
                        args.originalEvent.preventDefault();
                        this.navigationService.focusCellByElement(args.originalEvent.target);
                    }
                }
            });
        }
        if (this.localDataChangesService && !this.dataChangedSubscription) {
            this.dataChangedSubscription = this.localDataChangesService.changes.subscribe((args) => {
                if (this.active) {
                    if (isPresent(args.action) && args.action === 'remove') {
                        this.deselect(args.item);
                    }
                }
            });
        }
    }
    getIterator() {
        const accessor = this.settings.view.accessor();
        if (!accessor) {
            return;
        }
        return accessor[iterator]();
    }
    removeSubscriptions() {
        if (this.cellClickSubscription) {
            this.cellClickSubscription.unsubscribe();
            this.cellClickSubscription = null;
        }
        if (this.mousedownSubscription) {
            this.mousedownSubscription.unsubscribe();
            this.mousedownSubscription = null;
        }
        if (this.dataChangedSubscription) {
            this.dataChangedSubscription.unsubscribe();
            this.dataChangedSubscription = null;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CellSelectionService, deps: [{ token: DomEventsService }, { token: CellSelectionAggregateService }, { token: LocalDataChangesService }, { token: NavigationService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CellSelectionService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CellSelectionService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: DomEventsService }, { type: CellSelectionAggregateService }, { type: LocalDataChangesService }, { type: NavigationService }] });

/**
 * Adds a select-all checkbox to the Grid. [See example](slug:grid_selection_persistence#selecting-all-rows).
 *
 * @example
 * ```html
 * <kendo-checkbox
 *     kendoGridSelectAllCheckbox
 *     [state]="selectAllState"
 *     (selectAllChange)="onSelectAllChange($event)"
 * ></kendo-checkbox>
 * ```
 */
class SelectAllCheckboxDirective {
    selectionService;
    cellSelectionService;
    ngZone;
    element;
    renderer;
    checkbox;
    /**
     * Explicitly overrides the state of the select-all checkbox.
     */
    state;
    /**
     * Emits when the user clicks the select-all checkbox.
     * ([see example](slug:grid_row_selection#toc-select-all-checkbox)).
     */
    selectAllChange = new EventEmitter();
    destroyClick;
    checkboxChange;
    stateSet = false;
    ngAfterContentChecked() {
        this.setState();
    }
    ngOnChanges() {
        this.stateSet = true;
    }
    constructor(selectionService, cellSelectionService, ngZone, element, renderer, checkbox) {
        this.selectionService = selectionService;
        this.cellSelectionService = cellSelectionService;
        this.ngZone = ngZone;
        this.element = element;
        this.renderer = renderer;
        this.checkbox = checkbox;
        this.ngZone.runOutsideAngular(() => {
            if (this.checkbox) {
                this.checkboxChange = this.checkbox.checkedStateChange.subscribe(this.onClick.bind(this));
            }
            else {
                this.destroyClick = this.renderer.listen(this.element.nativeElement, 'click', this.onClick.bind(this));
            }
        });
    }
    ngOnDestroy() {
        if (this.checkboxChange) {
            this.checkboxChange.unsubscribe();
        }
        if (this.destroyClick) {
            this.destroyClick();
        }
    }
    /**
     * @hidden
     */
    onClick() {
        const isIndeterminateState = this.checkbox?.checkedState === 'indeterminate' || this.element.nativeElement.indeterminate;
        const isCheckedState = this.checkbox?.checkedState === true || this.element.nativeElement.checked;
        const uncheckedState = isIndeterminateState ? 'indeterminate' : 'unchecked';
        const checkboxState = isCheckedState ? 'checked' : uncheckedState;
        const isChecked = this.selectionService.hasNonSelectable ? !this.selectionService.selectAllChecked : isCheckedState;
        const options = this.selectionService.options;
        const enabledAndMultiple = options.enabled && options.mode === 'multiple' && !this.cellSelectionService.active;
        const shouldEmitSelectAll = hasObservers(this.selectAllChange);
        if (enabledAndMultiple || shouldEmitSelectAll) {
            this.ngZone.run(() => {
                if (enabledAndMultiple) {
                    this.selectionService.updateAll(isChecked);
                }
                if (shouldEmitSelectAll) {
                    this.selectAllChange.emit(checkboxState);
                }
            });
        }
    }
    /**
     * @hidden
     */
    setState() {
        const state = this.stateSet ? this.stateToBool() : this.selectionService.selectAllState;
        if (this.checkbox) {
            this.checkbox.checkedState = isPresent(state) ? state : 'indeterminate';
        }
        else {
            const elem = this.element.nativeElement;
            this.renderer.setProperty(elem, 'indeterminate', !isPresent(state));
            this.renderer.setProperty(elem, 'checked', isPresent(state) ? state : false);
        }
    }
    /**
     * @hidden
     */
    stateToBool() {
        switch (this.state) {
            case 'checked':
                return true;
            case 'unchecked':
                return false;
            default:
                return undefined;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SelectAllCheckboxDirective, deps: [{ token: SelectionService }, { token: CellSelectionService }, { token: i0.NgZone }, { token: i0.ElementRef }, { token: i0.Renderer2 }, { token: i4.CheckBoxComponent, host: true, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: SelectAllCheckboxDirective, isStandalone: true, selector: "[kendoGridSelectAllCheckbox]", inputs: { state: "state" }, outputs: { selectAllChange: "selectAllChange" }, usesOnChanges: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SelectAllCheckboxDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridSelectAllCheckbox]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: SelectionService }, { type: CellSelectionService }, { type: i0.NgZone }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i4.CheckBoxComponent, decorators: [{
                    type: Host
                }, {
                    type: Optional
                }] }], propDecorators: { state: [{
                type: Input
            }], selectAllChange: [{
                type: Output
            }] } });

const mergeObjects = (...args) => Object.assign.apply(null, [{}].concat(args));
const directions$1 = initialDirection => initialDirection === "asc" ? ["asc", "desc"] : ["desc", "asc"];
/**
 * @hidden
 */
const isRootLevel = ({ parent }) => !isTruthy(parent);
const ofColumnType = ({ draggable }) => ['column', 'columnGroup']
    .indexOf(draggable.context.type) >= 0;
const notSameElement = ({ draggable, target }) => draggable.element.nativeElement !== target.element.nativeElement;
const inSameParent = (x, y) => x.parent === y.parent ||
    (isInSpanColumn$1(y) && inSameParent(x, y.parent));
const sameParent = ({ draggable, target }) => inSameParent(draggable.context.column, target.context.column);
const lastNonLocked = ({ draggable }) => !isTruthy(draggable.context.column.locked) &&
    isRootLevel(draggable.context.column) &&
    draggable.context.lastColumn;
const notInSpanColumn = ({ draggable }) => !isInSpanColumn$1(draggable.context.column);
const reorderable = ({ draggable }) => draggable.context.column.reorderable;
const lockable = ({ draggable, target }) => draggable.context.column.lockable !== false ||
    draggable.context.column.isLocked === target.context.column.isLocked;
const rules = and(ofColumnType, reorderable, notInSpanColumn, notSameElement, sameParent, not(lastNonLocked), lockable);
const modifierKeys = ['alt', 'ctrl', 'shift', 'meta'];
/**
 * @hidden
 */
class HeaderComponent {
    popupService;
    hint;
    cue;
    reorderService;
    idService;
    sortService;
    columnInfoService;
    cd;
    contextService;
    navigationService;
    zone;
    /**
     * @hidden
     */
    totalColumnLevels;
    columns = [];
    groups = [];
    detailTemplate;
    scrollable;
    filterable;
    sort = new Array();
    filter;
    sortable = false;
    groupable = false;
    lockedColumnsCount = 0;
    resizable = false;
    reorderable = false;
    columnMenu = false;
    columnMenuTemplate;
    totalColumnsCount = 0;
    totalColumns;
    tabIndex;
    size = 'medium';
    sortedFields = {};
    hostClass = true;
    get sortableLabel() {
        return this.contextService.localization.get('sortable');
    }
    get columnMenuSettings() {
        return this.columnMenu;
    }
    dropTargets = new QueryList();
    filterMenus;
    columnMenus;
    // Number of unlocked columns in the next table, if any
    get unlockedColumnsCount() {
        return this.totalColumnsCount - this.lockedColumnsCount - this.columns.length;
    }
    sortAscSmallIcon = sortAscSmallIcon;
    sortDescSmallIcon = sortDescSmallIcon;
    subscription = new Subscription();
    targetSubscription;
    stopSorting = false;
    _leafColumns;
    constructor(popupService, hint, cue, reorderService, idService, sortService, columnInfoService, cd, contextService, navigationService, zone) {
        this.popupService = popupService;
        this.hint = hint;
        this.cue = cue;
        this.reorderService = reorderService;
        this.idService = idService;
        this.sortService = sortService;
        this.columnInfoService = columnInfoService;
        this.cd = cd;
        this.contextService = contextService;
        this.navigationService = navigationService;
        this.zone = zone;
    }
    sortColumn(descriptor) {
        this.sortService.sort(descriptor);
    }
    getColumnComponent(column) {
        return column;
    }
    onSortClick(column, event, link) {
        if (this.stopSorting) {
            this.stopSorting = false;
            return;
        }
        const target = event.target;
        if (column.headerTemplateRef && target !== link) {
            const hasFocusableParent = Boolean(closestInScope(target, isFocusable, link));
            if (hasFocusableParent) {
                // Do not sort when clicking focusable template elements.
                return;
            }
        }
        const modifier = this.matchModifier(event);
        const toggledColumn = this.toggleSort(column, modifier);
        this.sortColumn(toggledColumn);
    }
    onHeaderKeydown(column, args) {
        const code = normalizeKeys(args);
        if (code === Keys.ArrowDown && args.altKey && this.showFilterMenu && this.isFilterable(column)) {
            args.preventDefault();
            args.stopImmediatePropagation();
            const filterMenu = this.filterMenus.find(fm => fm.column === column);
            filterMenu.toggle(filterMenu.anchor.nativeElement, filterMenu.template);
            return;
        }
        if (code === Keys.ArrowDown && args.altKey && this.showColumnMenu(column)) {
            args.preventDefault();
            args.stopImmediatePropagation();
            const columnMenu = this.columnMenus.find(cm => cm.column === column);
            columnMenu.toggle(null, columnMenu.anchor.nativeElement, columnMenu.template);
            return;
        }
        const isCtrlOrMeta = args.ctrlKey || args.metaKey;
        const isGroupingKeyShortcut = (code === Keys.Enter || code === Keys.Space) && isCtrlOrMeta;
        if (isGroupingKeyShortcut && this.isGroupable(column)) {
            args.preventDefault();
            args.stopImmediatePropagation();
            const isGroupedByField = this.groups.some(gr => gr.field === column.field);
            if (isGroupedByField) {
                this.groups = this.groups.filter(gr => gr.field !== column.field);
            }
            else {
                this.groups.push({
                    field: column.field
                });
            }
            this.contextService.grid.groupChange.emit(this.groups);
            return;
        }
        const isLeftOrRightArrow = code === Keys.ArrowLeft || code === Keys.ArrowRight;
        const isReorderingKeyShortcut = isLeftOrRightArrow && isCtrlOrMeta;
        if (isReorderingKeyShortcut && this.isReorderable(column)) {
            args.preventDefault();
            const columnsCount = this.columnInfoService.leafNamedColumns.length;
            const reorderDirection = code === Keys.ArrowLeft ? -1 : 1;
            const rtlMultiplier = this.contextService.localization.rtl ? -1 : 1;
            const reorderDirectionOffset = reorderDirection * rtlMultiplier;
            const newIndex = column.leafIndex + reorderDirectionOffset;
            const normalizedNewIndex = Math.min(Math.max(0, newIndex), columnsCount - 1);
            const gridInstance = this.contextService.grid;
            gridInstance.reorderColumn(column, normalizedNewIndex, { before: reorderDirectionOffset < 0 });
            gridInstance.columnReorder.emit(new ColumnReorderEvent({
                column,
                newIndex: normalizedNewIndex,
                oldIndex: column.leafIndex
            }));
            return;
        }
        if (!this.sortable || args.defaultPrevented || column.sortable === false) {
            return;
        }
        if (code === Keys.Enter && isPresent(column.field)) {
            const modifier = this.matchModifier(args);
            this.sortService.sort(this.toggleSort(column, modifier));
        }
    }
    showSortNumbering(column) {
        const { showIndexes } = normalize$1(this.sortable);
        return showIndexes
            && this.sort
            && this.sort.filter(({ dir }) => isPresent(dir)).length > 1
            && this.sortOrder(column.field) > 0;
    }
    sortOrder(field) {
        return this.sort
            .filter(({ dir }) => isPresent(dir))
            .findIndex(x => x.field === field)
            + 1;
    }
    sortState(column) {
        if (!this.isInteractive(column, 'sortable')) {
            return;
        }
        const state = this.sortDescriptor(column.field);
        if (state.dir === 'asc') {
            return 'ascending';
        }
        if (state.dir === 'desc') {
            return 'descending';
        }
    }
    get isNavigable() {
        return this.navigationService.tableEnabled;
    }
    /**
     *
     * @param column
     * @param modifier - Indicates whether the client-defined `multiSortKey` modifier is met. Defaults to `true`.
     * @returns - SortDescriptor[]
     */
    toggleSort(column, modifier = true) {
        const { allowUnsort, mode, initialDirection } = normalize$1(this.sortable, column.sortable);
        const descriptor = this.toggleDirection(column.field, allowUnsort, initialDirection);
        if (mode === 'single' || !modifier) {
            return [descriptor];
        }
        return [...this.sort.filter(desc => desc.field !== column.field), descriptor];
    }
    /**
     *
     * Determines whether the modifier key (if any) passed
     * with a click/keyboard event matches the user-defined multiSortKey.
     */
    matchModifier(event) {
        const { multiSortKey } = normalize$1(this.sortable);
        if (multiSortKey === 'none') {
            return modifierKeys.every(key => !event[`${key}Key`]);
        }
        return multiSortKey === 'ctrl'
            ? event.ctrlKey || event.metaKey
            : event[`${multiSortKey}Key`];
    }
    ngAfterViewInit() {
        this.subscription.add(observe(this.dropTargets)
            .subscribe(this.attachTargets.bind(this)));
    }
    ngDoCheck() {
        this._leafColumns = columnsToRender(this.columns || []).filter(x => !isColumnGroupComponent(x));
    }
    ngOnChanges(changes) {
        const sortChange = changes.sort;
        if (sortChange && !sortChange.isFirstChange()) {
            sortChange.currentValue.forEach(change => {
                this.sortedFields[change.field] = true;
            });
        }
    }
    ngOnInit() {
        this.subscription.add(this.contextService.localization.changes
            .subscribe(() => this.cd.markForCheck()));
    }
    ngOnDestroy() {
        if (this.targetSubscription) {
            this.targetSubscription.unsubscribe();
        }
        if (this.popupService) {
            this.popupService.destroy();
        }
        this.subscription.unsubscribe();
    }
    selectAllCheckboxId() {
        return this.idService.selectAllCheckboxId();
    }
    get selectAllCheckboxLabel() {
        return this.contextService.localization.get('selectAllCheckboxLabel');
    }
    isFirstOnRow(column, index) {
        const isTailing = (c) => c &&
            (this.columnsForLevel(c.level).indexOf(c) > 0 || isTailing(c.parent));
        return index === 0 && !this.groups.length && !this.detailTemplate && isTailing(column.parent);
    }
    logicalColumnIndex(column) {
        const index = column.leafIndex;
        if (isPresent(index)) {
            return index + (isPresent(this.detailTemplate) ? 1 : 0);
        }
        return -1;
    }
    get showFilterMenu() {
        return !this.columnMenu && hasFilterMenu(this.filterable);
    }
    get showFilterRow() {
        return hasFilterRow(this.filterable);
    }
    showColumnMenu(column) {
        return this.columnMenu && column.columnMenu &&
            (this.columnMenuTemplate || column.columnMenuTemplates.length || hasItems(this.columnMenu, column));
    }
    isFilterable(column) {
        return !isNullOrEmptyString(column.field) && column.filterable === true;
    }
    canDrop(draggable, target) {
        isDocumentAvailable() && this.zone.runOutsideAngular(() => {
            document.addEventListener('pointerup', () => {
                this.stopSorting = true;
                setTimeout(() => this.stopSorting = false);
            }, {
                once: true,
                capture: true
            });
        });
        return this.reorderable && rules({ draggable, target });
    }
    shouldActivate(column) {
        const canReorder = this.isReorderable(column);
        if (!canReorder && !isColumnComponent(column)) {
            return false;
        }
        const groupable = this.isGroupable(column);
        return groupable || canReorder;
    }
    isInteractive(column, prop) {
        return !isNullOrEmptyString(column.field)
            && isTruthy(this[prop]) && isTruthy(column[prop]);
    }
    isCheckboxColumn(column) {
        return isCheckboxColumn(column) && !column.templateRef;
    }
    addStickyStyles(column) {
        const stickyStyles = this.columnInfoService.stickyColumnsStyles(column);
        return { ...column.headerStyle, ...stickyStyles };
    }
    toggleDirection(field, allowUnsort, initialDirection) {
        const descriptor = this.sortDescriptor(field);
        const [first, second] = directions$1(initialDirection);
        let dir = first;
        if (descriptor.dir === first) {
            dir = second;
        }
        else if (descriptor.dir === second && allowUnsort) {
            dir = undefined;
        }
        return { dir, field };
    }
    columnsForLevel(level) {
        const columns = this.columns ? this.columns.filter(column => column.level === level) : [];
        return sortColumns(columnsToRender(columns));
    }
    isColumnGroupComponent(column) {
        return isColumnGroupComponent(column);
    }
    sortDescriptor(field) {
        return this.sort.find(item => item.field === field) || { field };
    }
    get columnLevels() {
        return new Array((this.totalColumnLevels || 0) + 1);
    }
    get leafColumns() {
        return this._leafColumns;
    }
    get isStacked() {
        return this.contextService.grid?.isStacked;
    }
    isReorderable(column) {
        return this.reorderable && column.reorderable;
    }
    isGroupable(column) {
        return this.groupable && isColumnComponent(column) && column.groupable !== false;
    }
    attachTargets() {
        if (this.targetSubscription) {
            this.targetSubscription.unsubscribe();
        }
        this.targetSubscription = new Subscription();
        const enterStream = merge(...this.dropTargets.map(target => target.enter));
        const leaveStream = merge(...this.dropTargets.map(target => target.leave));
        const dropStream = merge(...this.dropTargets.map(target => target.drop));
        this.targetSubscription.add(enterStream.pipe(tap(({ target, draggable }) => {
            if (draggable.context.type === 'groupIndicator') {
                return;
            }
            const targetLocked = isTruthy(target.context.column.isLocked);
            const draggableLocked = isTruthy(draggable.context.column.isLocked);
            if (this.lockedColumnsCount > 0 || targetLocked || draggableLocked) {
                this.hint.toggleLock(targetLocked);
            }
        }), filter(({ draggable, target }) => this.canDrop(draggable, target)), switchMap(this.trackMove.bind(this, leaveStream, dropStream)), map((e) => mergeObjects(e, { before: this.calculateBefore(e), changeContainer: e.changeContainer })), map(this.normalizeTarget.bind(this)), tap(this.enter.bind(this)), switchMap((args) => dropStream.pipe(map(() => args), takeUntil(leaveStream.pipe(tap(this.leave.bind(this)))))))
            .subscribe(this.drop.bind(this)));
    }
    normalizeTarget(e) {
        let target = e.target;
        const parent = target.context.column.parent;
        if (parent && parent.isSpanColumn) {
            const arr = this.dropTargets.toArray();
            const firstSpan = arr.find(t => t.context.column.parent === parent);
            const index = arr.indexOf(firstSpan);
            const adjust = e.before ? 0 : parent.children.length - 1;
            target = arr[index + adjust];
        }
        return mergeObjects(e, { target });
    }
    trackMove(leaveStream, dropStream, e) {
        const column = e.target.context.column;
        const levelColumns = this.columnsForLevel(column.level);
        const index = levelColumns.indexOf(column);
        const isFirst = (column.locked ? index === levelColumns.length - 1 : index === 0);
        const changed = e.draggable.context.column.isLocked !== column.isLocked;
        if (changed && isFirst) {
            return e.draggable.drag
                .pipe(takeUntil(leaveStream), takeUntil(dropStream), map(({ mouseEvent }) => mergeObjects({ changeContainer: true }, e, { mouseEvent })));
        }
        return of(mergeObjects({ changeContainer: changed }, e));
    }
    calculateBefore({ draggable, target, mouseEvent, changeContainer = false }) {
        const targetElement = target.element.nativeElement;
        let before = false;
        if (changeContainer) {
            const { left } = offset(targetElement);
            const halfWidth = targetElement.offsetWidth / 2;
            const middle = left + halfWidth;
            before = middle > mouseEvent.pageX;
            if (this.contextService.localization.rtl) {
                before = !before;
            }
        }
        else {
            before = isTargetBefore(draggable.element.nativeElement, targetElement);
        }
        return before;
    }
    enter({ target, before }) {
        this.hint.enable();
        if (this.contextService.localization.rtl) {
            before = !before;
        }
        this.cue.position(position(target.element.nativeElement, before));
    }
    leave() {
        this.hint.disable();
        this.cue.hide();
    }
    drop({ draggable, target, before, changeContainer }) {
        this.reorderService.reorder({
            before,
            changeContainer,
            source: draggable.context.column,
            target: target.context.column
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: HeaderComponent, deps: [{ token: SinglePopupService }, { token: DragHintService }, { token: DropCueService }, { token: ColumnReorderService }, { token: IdService }, { token: SortService }, { token: ColumnInfoService }, { token: i0.ChangeDetectorRef }, { token: ContextService }, { token: NavigationService }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: HeaderComponent, isStandalone: true, selector: "[kendoGridHeader]", inputs: { totalColumnLevels: "totalColumnLevels", columns: "columns", groups: "groups", detailTemplate: "detailTemplate", scrollable: "scrollable", filterable: "filterable", sort: "sort", filter: "filter", sortable: "sortable", groupable: "groupable", lockedColumnsCount: "lockedColumnsCount", resizable: "resizable", reorderable: "reorderable", columnMenu: "columnMenu", columnMenuTemplate: "columnMenuTemplate", totalColumnsCount: "totalColumnsCount", totalColumns: "totalColumns", tabIndex: "tabIndex", size: "size" }, host: { properties: { "class.k-table-thead": "this.hostClass" } }, viewQueries: [{ propertyName: "dropTargets", predicate: DropTargetDirective, descendants: true }, { propertyName: "filterMenus", predicate: FilterMenuComponent, descendants: true }, { propertyName: "columnMenus", predicate: ColumnMenuComponent, descendants: true }], usesOnChanges: true, ngImport: i0, template: `
        @for (i of columnLevels; track $index; let levelIndex = $index) {
          <tr
            kendoGridLogicalRow
            [logicalRowIndex]="levelIndex"
            [logicalSlaveRow]="lockedColumnsCount > 0"
            [logicalCellsCount]="columns.length"
            [logicalSlaveCellsCount]="unlockedColumnsCount"
            [totalColumns]="totalColumns">
            @for (g of groups; track g) {
              <th
                class="k-group-cell k-header k-table-th"
                role="presentation"
                >
              </th>
            }
            @if (detailTemplate?.templateRef && !isStacked) {
              <th class="k-hierarchy-cell k-header k-table-th"
                role="presentation"
                >
              </th>
            }
            @for (column of columnsForLevel(levelIndex); track column.id; let columnIndex = $index; let last = $last) {
              @if (!isColumnGroupComponent(column)) {
                <th
                  kendoGridLogicalCell
                  [logicalRowIndex]="levelIndex"
                  [logicalColIndex]="logicalColumnIndex(column)"
                  [headerLabelText]="column.title || getColumnComponent(column).field"
                  [colSpan]="column.colspan"
                  [rowSpan]="column.rowspan(totalColumnLevels)"
                  role="columnheader"
                  aria-selected="false"
                  [attr.aria-sort]="sortState(getColumnComponent(column))"
                  [class.k-sorted]="sortState(getColumnComponent(column))"
                  (keydown)="onHeaderKeydown(getColumnComponent(column), $event)"
                  kendoDropTarget
                  kendoDraggable
                  kendoDraggableColumn
                  [enableDrag]="shouldActivate(column)"
                    [context]="{
                        field: getColumnComponent(column).field,
                        type: 'column',
                        column: column,
                        hint: column.title || getColumnComponent(column).field,
                        lastColumn: last && columnIndex === 0
                    }"
                  class="k-header k-table-th"
                  [class.k-filterable]="(showFilterMenu && isFilterable(getColumnComponent(column))) || showColumnMenu(column)"
                  [class.k-first]="isFirstOnRow(getColumnComponent(column), columnIndex)"
                  [class.k-grid-header-sticky]="column.sticky"
                  [ngClass]="column.headerClass"
                  [ngStyle]="column.sticky ? addStickyStyles(column) : column.headerStyle"
                  [attr.rowspan]="column.rowspan(totalColumnLevels)"
                  [attr.colspan]="column.colspan"
                  [attr.aria-haspopup]="isNavigable && (showFilterMenu || showColumnMenu(column)) ? 'dialog' : undefined"
                  [attr.aria-expanded]="isNavigable && (showFilterMenu || showColumnMenu(column)) ? false : undefined"
                  [attr.aria-keyshortcuts]="isNavigable && (showFilterMenu || showColumnMenu(column)) ? 'Alt + ArrowDown' : undefined">
                  @if (!isInteractive(getColumnComponent(column), 'sortable')) {
                    <span class="k-cell-inner">
                      <span class="k-link" [class.!k-cursor-default]="!isInteractive(getColumnComponent(column), 'groupable') && !isInteractive(getColumnComponent(column), 'reorderable')">
                        <ng-template
                                    [templateContext]="{
                                        templateRef: column.headerTemplateRef,
                                        columnIndex: column.leafIndex,
                                        column: column,
                                        $implicit: column
                                    }">
                        </ng-template>
                        @if (!column.headerTemplateRef) {
                          <span class="k-column-title">{{column.displayTitle}}</span>
                        }
                      </span>
                      @if (showFilterMenu && isFilterable(getColumnComponent(column))) {
                        <kendo-grid-filter-menu
                          [column]="getColumnComponent(column)"
                          [filter]="filter"
                          [tabIndex]="tabIndex">
                        </kendo-grid-filter-menu>
                      }
                      @if (showColumnMenu(column)) {
                        <kendo-grid-column-menu
                          [standalone]="false"
                          [settings]="columnMenuSettings"
                          [column]="column"
                          [columnMenuTemplate]="columnMenuTemplate"
                          [sort]="sort"
                          [filter]="filter"
                          [sortable]="sortable"
                          [tabIndex]="tabIndex">
                        </kendo-grid-column-menu>
                      }
                    </span>
                  }
                  @if (isInteractive(getColumnComponent(column), 'sortable')) {
                    <span class="k-cell-inner">
                      <span #link class="k-link" (click)="onSortClick(getColumnComponent(column), $event, link)">
                        <ng-template
                                    [templateContext]="{
                                        templateRef: column.headerTemplateRef,
                                        columnIndex: column.leafIndex,
                                        column: column,
                                        $implicit: column
                                    }">
                        </ng-template>
                        @if (!column.headerTemplateRef) {
                          <span class="k-column-title">{{column.displayTitle}}</span>
                        }
                        <span [class.k-sort-icon]="sortDescriptor(getColumnComponent(column).field).dir">
                          @if (sortDescriptor(getColumnComponent(column).field).dir) {
                            <kendo-icon-wrapper
                              role="note" [attr.aria-label]="sortableLabel"
                              name="sort-{{sortDescriptor(getColumnComponent(column).field).dir}}-small"
                              [svgIcon]="sortDescriptor(getColumnComponent(column).field).dir === 'asc' ? sortAscSmallIcon : sortDescSmallIcon"
                            ></kendo-icon-wrapper>
                          }
                        </span>
                        @if (showSortNumbering(getColumnComponent(column))) {
                          <span class="k-sort-order">{{sortOrder(getColumnComponent(column).field)}}</span>
                        }
                      </span>
                      @if (showFilterMenu && isFilterable(getColumnComponent(column))) {
                        <kendo-grid-filter-menu
                          [column]="getColumnComponent(column)"
                          [filter]="filter"
                          [tabIndex]="tabIndex">
                        </kendo-grid-filter-menu>
                      }
                      @if (showColumnMenu(column)) {
                        <kendo-grid-column-menu
                          [standalone]="false"
                          [settings]="columnMenuSettings"
                          [column]="column"
                          [columnMenuTemplate]="columnMenuTemplate"
                          [sort]="sort"
                          [filter]="filter"
                          [sortable]="sortable"
                          [tabIndex]="tabIndex">
                        </kendo-grid-column-menu>
                      }
                    </span>
                  }
                  @if (isCheckboxColumn(column) && !column.headerTemplateRef && $any(column).showSelectAll) {
                    <kendo-checkbox
                      [attr.id]="selectAllCheckboxId()"
                      [inputAttributes]="{'aria-label': selectAllCheckboxLabel}"
                      kendoGridSelectAllCheckbox
                      kendoGridFocusable
                    ></kendo-checkbox>
                  }
                  @if (resizable) {
                    <span kendoGridColumnHandle
                      kendoDraggable
                      class="k-column-resizer"
                      [isLast]="last"
                      [column]="column"
                      [columns]="columns">
                    </span>
                  }
                </th>
              }
              @if (isColumnGroupComponent(column)) {
                <th
                  kendoGridLogicalCell
                  [logicalRowIndex]="levelIndex"
                  [logicalColIndex]="logicalColumnIndex(column)"
                  [rowSpan]="column.rowspan(totalColumnLevels)"
                  [colSpan]="column.colspan"
                  [headerLabelText]="column.title || getColumnComponent(column).field"
                  kendoDropTarget
                  kendoDraggable
                  kendoDraggableColumn
                  [enableDrag]="shouldActivate(column)"
                    [context]="{
                        type: 'columnGroup',
                        column: column,
                        hint: column.title,
                        lastColumn: last && columnIndex === 0
                    }"
                  class="k-header k-table-th"
                  [class.k-first]="isFirstOnRow(getColumnComponent(column), columnIndex)"
                  [class.k-filterable]="showColumnMenu(column)"
                  [class.k-grid-content-sticky]="column.sticky"
                  [ngClass]="column.headerClass"
                  [ngStyle]="column.headerStyle"
                  [attr.aria-haspopup]="(isNavigable && showColumnMenu(column)) ? 'dialog' : undefined"
                  [attr.aria-expanded]="(isNavigable && showColumnMenu(column)) ? false : undefined"
                  [attr.aria-keyshortcuts]="isNavigable && showColumnMenu(column) ? 'Alt + ArrowDown' : undefined"
                  [attr.rowspan]="column.rowspan(totalColumnLevels)"
                  [attr.colspan]="column.colspan">
                  <span class="k-cell-inner">
                    <span class="k-link" [class.!k-cursor-default]="!isInteractive(getColumnComponent(column), 'reorderable')">
                      <ng-template
                                [templateContext]="{
                                    templateRef: column.headerTemplateRef,
                                    columnIndex: lockedColumnsCount + columnIndex,
                                    column: column,
                                    $implicit: column
                                }">
                      </ng-template>
                      @if (!column.headerTemplateRef) {
                        <span class="k-column-title">{{column.displayTitle}}</span>
                      }
                    </span>
                    @if (showColumnMenu(column)) {
                      <kendo-grid-column-menu
                        [standalone]="false"
                        [settings]="columnMenuSettings"
                        [column]="column"
                        [columnMenuTemplate]="columnMenuTemplate">
                      </kendo-grid-column-menu>
                    }
                  </span>
                  @if (resizable) {
                    <span kendoGridColumnHandle
                      kendoDraggable
                      class="k-column-resizer"
                      [isLast]="last"
                      [column]="column"
                      [columns]="columns">
                    </span>
                  }
                </th>
              }
            }
          </tr>
        }
        @if (showFilterRow) {
          <tr
            kendoGridFilterRow
            [columns]="leafColumns"
            [filter]="filter"
            [groups]="groups"
            [detailTemplate]="detailTemplate"
            [lockedColumnsCount]="lockedColumnsCount"
            kendoGridLogicalRow
            [logicalRowIndex]="totalColumnLevels + 1"
            [logicalSlaveRow]="lockedColumnsCount > 0"
            [logicalCellsCount]="columns.length"
            [logicalSlaveCellsCount]="unlockedColumnsCount"
          [totalColumns]="totalColumns"></tr>
        }
        `, isInline: true, dependencies: [{ kind: "directive", type: LogicalRowDirective, selector: "[kendoGridLogicalRow]", inputs: ["logicalRowIndex", "logicalSlaveRow", "logicalCellsCount", "logicalSlaveCellsCount", "dataRowIndex", "dataItem", "totalColumns"] }, { kind: "directive", type: LogicalCellDirective, selector: "[kendoGridLogicalCell]", inputs: ["logicalColIndex", "logicalRowIndex", "logicalSlaveCell", "colIndex", "colSpan", "rowSpan", "groupItem", "dataRowIndex", "dataItem", "detailExpandCell", "headerLabelText"] }, { kind: "directive", type: DropTargetDirective, selector: "[kendoDropTarget]", inputs: ["context"], outputs: ["enter", "leave", "drop"] }, { kind: "directive", type: DraggableDirective, selector: "[kendoDraggable]", inputs: ["enableDrag"], outputs: ["kendoPress", "kendoDrag", "kendoRelease"] }, { kind: "directive", type: DraggableColumnDirective, selector: "[kendoDraggableColumn]", inputs: ["context", "enableDrag"], outputs: ["drag"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "directive", type: TemplateContextDirective, selector: "[templateContext]", inputs: ["templateContext"] }, { kind: "component", type: FilterMenuComponent, selector: "kendo-grid-filter-menu", inputs: ["column", "filter", "tabIndex"] }, { kind: "component", type: ColumnMenuComponent, selector: "kendo-grid-column-menu", inputs: ["standalone", "column", "settings", "sort", "filter", "sortable", "columnMenuTemplate", "tabIndex"] }, { kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "directive", type: SelectAllCheckboxDirective, selector: "[kendoGridSelectAllCheckbox]", inputs: ["state"], outputs: ["selectAllChange"] }, { kind: "directive", type: FocusableDirective, selector: "[kendoGridFocusable],\n        [kendoGridEditCommand],\n        [kendoGridRemoveCommand],\n        [kendoGridSaveCommand],\n        [kendoGridCancelCommand],\n        [kendoGridSelectionCheckbox]\n    ", inputs: ["kendoGridFocusable"] }, { kind: "directive", type: ColumnHandleDirective, selector: "[kendoGridColumnHandle]", inputs: ["isLast", "columns", "column"] }, { kind: "component", type: FilterRowComponent, selector: "[kendoGridFilterRow]", inputs: ["columns", "filter", "groups", "detailTemplate", "logicalRowIndex", "lockedColumnsCount"] }, { kind: "component", type: CheckBoxComponent, selector: "kendo-checkbox", inputs: ["checkedState", "rounded"], outputs: ["checkedStateChange"], exportAs: ["kendoCheckBox"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: HeaderComponent, decorators: [{
            type: Component,
            args: [{
                    selector: '[kendoGridHeader]',
                    template: `
        @for (i of columnLevels; track $index; let levelIndex = $index) {
          <tr
            kendoGridLogicalRow
            [logicalRowIndex]="levelIndex"
            [logicalSlaveRow]="lockedColumnsCount > 0"
            [logicalCellsCount]="columns.length"
            [logicalSlaveCellsCount]="unlockedColumnsCount"
            [totalColumns]="totalColumns">
            @for (g of groups; track g) {
              <th
                class="k-group-cell k-header k-table-th"
                role="presentation"
                >
              </th>
            }
            @if (detailTemplate?.templateRef && !isStacked) {
              <th class="k-hierarchy-cell k-header k-table-th"
                role="presentation"
                >
              </th>
            }
            @for (column of columnsForLevel(levelIndex); track column.id; let columnIndex = $index; let last = $last) {
              @if (!isColumnGroupComponent(column)) {
                <th
                  kendoGridLogicalCell
                  [logicalRowIndex]="levelIndex"
                  [logicalColIndex]="logicalColumnIndex(column)"
                  [headerLabelText]="column.title || getColumnComponent(column).field"
                  [colSpan]="column.colspan"
                  [rowSpan]="column.rowspan(totalColumnLevels)"
                  role="columnheader"
                  aria-selected="false"
                  [attr.aria-sort]="sortState(getColumnComponent(column))"
                  [class.k-sorted]="sortState(getColumnComponent(column))"
                  (keydown)="onHeaderKeydown(getColumnComponent(column), $event)"
                  kendoDropTarget
                  kendoDraggable
                  kendoDraggableColumn
                  [enableDrag]="shouldActivate(column)"
                    [context]="{
                        field: getColumnComponent(column).field,
                        type: 'column',
                        column: column,
                        hint: column.title || getColumnComponent(column).field,
                        lastColumn: last && columnIndex === 0
                    }"
                  class="k-header k-table-th"
                  [class.k-filterable]="(showFilterMenu && isFilterable(getColumnComponent(column))) || showColumnMenu(column)"
                  [class.k-first]="isFirstOnRow(getColumnComponent(column), columnIndex)"
                  [class.k-grid-header-sticky]="column.sticky"
                  [ngClass]="column.headerClass"
                  [ngStyle]="column.sticky ? addStickyStyles(column) : column.headerStyle"
                  [attr.rowspan]="column.rowspan(totalColumnLevels)"
                  [attr.colspan]="column.colspan"
                  [attr.aria-haspopup]="isNavigable && (showFilterMenu || showColumnMenu(column)) ? 'dialog' : undefined"
                  [attr.aria-expanded]="isNavigable && (showFilterMenu || showColumnMenu(column)) ? false : undefined"
                  [attr.aria-keyshortcuts]="isNavigable && (showFilterMenu || showColumnMenu(column)) ? 'Alt + ArrowDown' : undefined">
                  @if (!isInteractive(getColumnComponent(column), 'sortable')) {
                    <span class="k-cell-inner">
                      <span class="k-link" [class.!k-cursor-default]="!isInteractive(getColumnComponent(column), 'groupable') && !isInteractive(getColumnComponent(column), 'reorderable')">
                        <ng-template
                                    [templateContext]="{
                                        templateRef: column.headerTemplateRef,
                                        columnIndex: column.leafIndex,
                                        column: column,
                                        $implicit: column
                                    }">
                        </ng-template>
                        @if (!column.headerTemplateRef) {
                          <span class="k-column-title">{{column.displayTitle}}</span>
                        }
                      </span>
                      @if (showFilterMenu && isFilterable(getColumnComponent(column))) {
                        <kendo-grid-filter-menu
                          [column]="getColumnComponent(column)"
                          [filter]="filter"
                          [tabIndex]="tabIndex">
                        </kendo-grid-filter-menu>
                      }
                      @if (showColumnMenu(column)) {
                        <kendo-grid-column-menu
                          [standalone]="false"
                          [settings]="columnMenuSettings"
                          [column]="column"
                          [columnMenuTemplate]="columnMenuTemplate"
                          [sort]="sort"
                          [filter]="filter"
                          [sortable]="sortable"
                          [tabIndex]="tabIndex">
                        </kendo-grid-column-menu>
                      }
                    </span>
                  }
                  @if (isInteractive(getColumnComponent(column), 'sortable')) {
                    <span class="k-cell-inner">
                      <span #link class="k-link" (click)="onSortClick(getColumnComponent(column), $event, link)">
                        <ng-template
                                    [templateContext]="{
                                        templateRef: column.headerTemplateRef,
                                        columnIndex: column.leafIndex,
                                        column: column,
                                        $implicit: column
                                    }">
                        </ng-template>
                        @if (!column.headerTemplateRef) {
                          <span class="k-column-title">{{column.displayTitle}}</span>
                        }
                        <span [class.k-sort-icon]="sortDescriptor(getColumnComponent(column).field).dir">
                          @if (sortDescriptor(getColumnComponent(column).field).dir) {
                            <kendo-icon-wrapper
                              role="note" [attr.aria-label]="sortableLabel"
                              name="sort-{{sortDescriptor(getColumnComponent(column).field).dir}}-small"
                              [svgIcon]="sortDescriptor(getColumnComponent(column).field).dir === 'asc' ? sortAscSmallIcon : sortDescSmallIcon"
                            ></kendo-icon-wrapper>
                          }
                        </span>
                        @if (showSortNumbering(getColumnComponent(column))) {
                          <span class="k-sort-order">{{sortOrder(getColumnComponent(column).field)}}</span>
                        }
                      </span>
                      @if (showFilterMenu && isFilterable(getColumnComponent(column))) {
                        <kendo-grid-filter-menu
                          [column]="getColumnComponent(column)"
                          [filter]="filter"
                          [tabIndex]="tabIndex">
                        </kendo-grid-filter-menu>
                      }
                      @if (showColumnMenu(column)) {
                        <kendo-grid-column-menu
                          [standalone]="false"
                          [settings]="columnMenuSettings"
                          [column]="column"
                          [columnMenuTemplate]="columnMenuTemplate"
                          [sort]="sort"
                          [filter]="filter"
                          [sortable]="sortable"
                          [tabIndex]="tabIndex">
                        </kendo-grid-column-menu>
                      }
                    </span>
                  }
                  @if (isCheckboxColumn(column) && !column.headerTemplateRef && $any(column).showSelectAll) {
                    <kendo-checkbox
                      [attr.id]="selectAllCheckboxId()"
                      [inputAttributes]="{'aria-label': selectAllCheckboxLabel}"
                      kendoGridSelectAllCheckbox
                      kendoGridFocusable
                    ></kendo-checkbox>
                  }
                  @if (resizable) {
                    <span kendoGridColumnHandle
                      kendoDraggable
                      class="k-column-resizer"
                      [isLast]="last"
                      [column]="column"
                      [columns]="columns">
                    </span>
                  }
                </th>
              }
              @if (isColumnGroupComponent(column)) {
                <th
                  kendoGridLogicalCell
                  [logicalRowIndex]="levelIndex"
                  [logicalColIndex]="logicalColumnIndex(column)"
                  [rowSpan]="column.rowspan(totalColumnLevels)"
                  [colSpan]="column.colspan"
                  [headerLabelText]="column.title || getColumnComponent(column).field"
                  kendoDropTarget
                  kendoDraggable
                  kendoDraggableColumn
                  [enableDrag]="shouldActivate(column)"
                    [context]="{
                        type: 'columnGroup',
                        column: column,
                        hint: column.title,
                        lastColumn: last && columnIndex === 0
                    }"
                  class="k-header k-table-th"
                  [class.k-first]="isFirstOnRow(getColumnComponent(column), columnIndex)"
                  [class.k-filterable]="showColumnMenu(column)"
                  [class.k-grid-content-sticky]="column.sticky"
                  [ngClass]="column.headerClass"
                  [ngStyle]="column.headerStyle"
                  [attr.aria-haspopup]="(isNavigable && showColumnMenu(column)) ? 'dialog' : undefined"
                  [attr.aria-expanded]="(isNavigable && showColumnMenu(column)) ? false : undefined"
                  [attr.aria-keyshortcuts]="isNavigable && showColumnMenu(column) ? 'Alt + ArrowDown' : undefined"
                  [attr.rowspan]="column.rowspan(totalColumnLevels)"
                  [attr.colspan]="column.colspan">
                  <span class="k-cell-inner">
                    <span class="k-link" [class.!k-cursor-default]="!isInteractive(getColumnComponent(column), 'reorderable')">
                      <ng-template
                                [templateContext]="{
                                    templateRef: column.headerTemplateRef,
                                    columnIndex: lockedColumnsCount + columnIndex,
                                    column: column,
                                    $implicit: column
                                }">
                      </ng-template>
                      @if (!column.headerTemplateRef) {
                        <span class="k-column-title">{{column.displayTitle}}</span>
                      }
                    </span>
                    @if (showColumnMenu(column)) {
                      <kendo-grid-column-menu
                        [standalone]="false"
                        [settings]="columnMenuSettings"
                        [column]="column"
                        [columnMenuTemplate]="columnMenuTemplate">
                      </kendo-grid-column-menu>
                    }
                  </span>
                  @if (resizable) {
                    <span kendoGridColumnHandle
                      kendoDraggable
                      class="k-column-resizer"
                      [isLast]="last"
                      [column]="column"
                      [columns]="columns">
                    </span>
                  }
                </th>
              }
            }
          </tr>
        }
        @if (showFilterRow) {
          <tr
            kendoGridFilterRow
            [columns]="leafColumns"
            [filter]="filter"
            [groups]="groups"
            [detailTemplate]="detailTemplate"
            [lockedColumnsCount]="lockedColumnsCount"
            kendoGridLogicalRow
            [logicalRowIndex]="totalColumnLevels + 1"
            [logicalSlaveRow]="lockedColumnsCount > 0"
            [logicalCellsCount]="columns.length"
            [logicalSlaveCellsCount]="unlockedColumnsCount"
          [totalColumns]="totalColumns"></tr>
        }
        `,
                    standalone: true,
                    imports: [
                        LogicalRowDirective,
                        LogicalCellDirective,
                        DropTargetDirective,
                        DraggableDirective,
                        DraggableColumnDirective,
                        NgClass,
                        NgStyle,
                        TemplateContextDirective,
                        FilterMenuComponent,
                        ColumnMenuComponent,
                        IconWrapperComponent,
                        SelectAllCheckboxDirective,
                        FocusableDirective,
                        ColumnHandleDirective,
                        FilterRowComponent,
                        CheckBoxComponent
                    ]
                }]
        }], ctorParameters: () => [{ type: SinglePopupService }, { type: DragHintService }, { type: DropCueService }, { type: ColumnReorderService }, { type: IdService }, { type: SortService }, { type: ColumnInfoService }, { type: i0.ChangeDetectorRef }, { type: ContextService }, { type: NavigationService }, { type: i0.NgZone }], propDecorators: { totalColumnLevels: [{
                type: Input
            }], columns: [{
                type: Input
            }], groups: [{
                type: Input
            }], detailTemplate: [{
                type: Input
            }], scrollable: [{
                type: Input
            }], filterable: [{
                type: Input
            }], sort: [{
                type: Input
            }], filter: [{
                type: Input
            }], sortable: [{
                type: Input
            }], groupable: [{
                type: Input
            }], lockedColumnsCount: [{
                type: Input
            }], resizable: [{
                type: Input
            }], reorderable: [{
                type: Input
            }], columnMenu: [{
                type: Input
            }], columnMenuTemplate: [{
                type: Input
            }], totalColumnsCount: [{
                type: Input
            }], totalColumns: [{
                type: Input
            }], tabIndex: [{
                type: Input
            }], size: [{
                type: Input
            }], hostClass: [{
                type: HostBinding,
                args: ['class.k-table-thead']
            }], dropTargets: [{
                type: ViewChildren,
                args: [DropTargetDirective]
            }], filterMenus: [{
                type: ViewChildren,
                args: [FilterMenuComponent]
            }], columnMenus: [{
                type: ViewChildren,
                args: [ColumnMenuComponent]
            }] } });

/**
 * @hidden
 */
class FooterComponent {
    columnInfoService;
    ctx;
    columns = [];
    groups = [];
    detailTemplate;
    scrollable;
    lockedColumnsCount = 0;
    logicalRowIndex = 0;
    totalColumns;
    totalColumnsCount = 0;
    get footerClass() {
        return !this.scrollable;
    }
    hostClass = true;
    hostRole = 'rowgroup';
    constructor(columnInfoService, ctx) {
        this.columnInfoService = columnInfoService;
        this.ctx = ctx;
    }
    get columnsToRender() {
        return columnsToRender(this.columns || []);
    }
    // Number of unlocked columns in the next table, if any
    get unlockedColumnsCount() {
        return this.totalColumnsCount - (this.isStacked ? 0 : this.lockedColumnsCount) - this.columns.length;
    }
    trackByIndex(index) {
        return index;
    }
    logicalColumnIndex(column) {
        const index = column.leafIndex;
        if (isPresent(index)) {
            return index + (isPresent(this.detailTemplate) ? 1 : 0);
        }
        return -1;
    }
    addStickyStyles(column) {
        const stickyStyles = this.columnInfoService.stickyColumnsStyles(column);
        return { ...column.footerStyle, ...stickyStyles };
    }
    isColumnGroupComponent(column) {
        return isColumnGroupComponent(column);
    }
    get isStacked() {
        return this.ctx.grid?.isStacked;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FooterComponent, deps: [{ token: ColumnInfoService }, { token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: FooterComponent, isStandalone: true, selector: "[kendoGridFooter]", inputs: { columns: "columns", groups: "groups", detailTemplate: "detailTemplate", scrollable: "scrollable", lockedColumnsCount: "lockedColumnsCount", logicalRowIndex: "logicalRowIndex", totalColumns: "totalColumns", totalColumnsCount: "totalColumnsCount" }, host: { properties: { "class.k-grid-footer": "this.footerClass", "class.k-table-tfoot": "this.hostClass", "attr.role": "this.hostRole" } }, ngImport: i0, template: `
    <ng-container>
      <tr
        class="k-footer-template"
        kendoGridLogicalRow
        [logicalRowIndex]="logicalRowIndex"
        [logicalSlaveRow]="lockedColumnsCount > 0 && !isStacked"
        [logicalCellsCount]="columns.length"
        [logicalSlaveCellsCount]="unlockedColumnsCount"
        [totalColumns]="totalColumns"
        >
        @if (!isStacked) {
          @for (g of groups; track g) {
            <td
              class="k-table-td k-group-cell k-table-group-td"
              role="presentation"
              >
            </td>
          }
        }
        @if (detailTemplate?.templateRef && !isStacked) {
          <td
            role="presentation"
            class="k-table-td k-hierarchy-cell"
            >
          </td>
        }
        @if (!isStacked) {
          @for (column of columnsToRender; track $index; let columnIndex = $index) {
            @if (!isColumnGroupComponent(column)) {
              <td
                kendoGridLogicalCell
                class="k-table-td"
                [logicalRowIndex]="logicalRowIndex"
                [logicalColIndex]="logicalColumnIndex(column)"
                role="gridcell"
                aria-selected="false"
                [class.k-grid-footer-sticky]="column.sticky"
                [ngClass]="column.footerClass"
                [ngStyle]="column.sticky ? addStickyStyles(column) : column.footerStyle">
                <ng-template
                            [templateContext]="{
                                templateRef: column.footerTemplateRef,
                                columnIndex: column.leafIndex,
                                column: column,
                                $implicit: column
                            }">
                </ng-template>
              </td>
            }
          }
        }

        @if (isStacked) {
          <td kendoGridLogicalCell
            class="k-table-td"
            [logicalRowIndex]="logicalRowIndex"
            [logicalColIndex]="detailTemplate ? 1 : 0"
            role="gridcell"
            aria-selected="false">
            <div class="k-grid-column-template">
              @for (column of columnsToRender; track $index) {
                @if (column.footerTemplateRef) {
                  <div class="k-column-template-item">
                    <ng-template
                                    [templateContext]="{
                                        templateRef: column.footerTemplateRef,
                                        columnIndex: column.leafIndex,
                                        column: column,
                                        $implicit: column
                                    }">
                    </ng-template>
                  </div>
                }
              }
            </div>
          </td>
        }
      </tr>
    </ng-container>
    `, isInline: true, dependencies: [{ kind: "directive", type: LogicalRowDirective, selector: "[kendoGridLogicalRow]", inputs: ["logicalRowIndex", "logicalSlaveRow", "logicalCellsCount", "logicalSlaveCellsCount", "dataRowIndex", "dataItem", "totalColumns"] }, { kind: "directive", type: LogicalCellDirective, selector: "[kendoGridLogicalCell]", inputs: ["logicalColIndex", "logicalRowIndex", "logicalSlaveCell", "colIndex", "colSpan", "rowSpan", "groupItem", "dataRowIndex", "dataItem", "detailExpandCell", "headerLabelText"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "directive", type: TemplateContextDirective, selector: "[templateContext]", inputs: ["templateContext"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FooterComponent, decorators: [{
            type: Component,
            args: [{
                    selector: '[kendoGridFooter]',
                    template: `
    <ng-container>
      <tr
        class="k-footer-template"
        kendoGridLogicalRow
        [logicalRowIndex]="logicalRowIndex"
        [logicalSlaveRow]="lockedColumnsCount > 0 && !isStacked"
        [logicalCellsCount]="columns.length"
        [logicalSlaveCellsCount]="unlockedColumnsCount"
        [totalColumns]="totalColumns"
        >
        @if (!isStacked) {
          @for (g of groups; track g) {
            <td
              class="k-table-td k-group-cell k-table-group-td"
              role="presentation"
              >
            </td>
          }
        }
        @if (detailTemplate?.templateRef && !isStacked) {
          <td
            role="presentation"
            class="k-table-td k-hierarchy-cell"
            >
          </td>
        }
        @if (!isStacked) {
          @for (column of columnsToRender; track $index; let columnIndex = $index) {
            @if (!isColumnGroupComponent(column)) {
              <td
                kendoGridLogicalCell
                class="k-table-td"
                [logicalRowIndex]="logicalRowIndex"
                [logicalColIndex]="logicalColumnIndex(column)"
                role="gridcell"
                aria-selected="false"
                [class.k-grid-footer-sticky]="column.sticky"
                [ngClass]="column.footerClass"
                [ngStyle]="column.sticky ? addStickyStyles(column) : column.footerStyle">
                <ng-template
                            [templateContext]="{
                                templateRef: column.footerTemplateRef,
                                columnIndex: column.leafIndex,
                                column: column,
                                $implicit: column
                            }">
                </ng-template>
              </td>
            }
          }
        }

        @if (isStacked) {
          <td kendoGridLogicalCell
            class="k-table-td"
            [logicalRowIndex]="logicalRowIndex"
            [logicalColIndex]="detailTemplate ? 1 : 0"
            role="gridcell"
            aria-selected="false">
            <div class="k-grid-column-template">
              @for (column of columnsToRender; track $index) {
                @if (column.footerTemplateRef) {
                  <div class="k-column-template-item">
                    <ng-template
                                    [templateContext]="{
                                        templateRef: column.footerTemplateRef,
                                        columnIndex: column.leafIndex,
                                        column: column,
                                        $implicit: column
                                    }">
                    </ng-template>
                  </div>
                }
              }
            </div>
          </td>
        }
      </tr>
    </ng-container>
    `,
                    standalone: true,
                    imports: [LogicalRowDirective, LogicalCellDirective, NgClass, NgStyle, TemplateContextDirective]
                }]
        }], ctorParameters: () => [{ type: ColumnInfoService }, { type: ContextService }], propDecorators: { columns: [{
                type: Input
            }], groups: [{
                type: Input
            }], detailTemplate: [{
                type: Input
            }], scrollable: [{
                type: Input
            }], lockedColumnsCount: [{
                type: Input
            }], logicalRowIndex: [{
                type: Input
            }], totalColumns: [{
                type: Input
            }], totalColumnsCount: [{
                type: Input
            }], footerClass: [{
                type: HostBinding,
                args: ['class.k-grid-footer']
            }], hostClass: [{
                type: HostBinding,
                args: ['class.k-table-tfoot']
            }], hostRole: [{
                type: HostBinding,
                args: ['attr.role']
            }] } });

/**
 * Represents the command columns of the Grid. Define the content of the column inside an `<ng-template>` tag.
 * For more information and examples, see the [Editing Action Buttons](slug:basics_editing_grid#editing-action-buttons) article.
 *
 * @example
 * ```html
 * <kendo-grid [data]="data">
 *   <kendo-grid-column field="ID"></kendo-grid-column>
 *   <kendo-grid-command-column title="command" [width]="220">
 *      <ng-template kendoGridCellTemplate>
 *         <button kendoGridEditCommand>Edit</button>
 *         <button kendoGridRemoveCommand>Remove</button>
 *      </ng-template>
 *   </kendo-grid-command-column>
 * </kendo-grid>
 * ```
 */
class CommandColumnComponent extends ColumnBase {
    parent;
    template;
    constructor(parent, idService) {
        super(parent, idService);
        this.parent = parent;
    }
    get templateRef() {
        return this.template ? this.template.templateRef : undefined;
    }
    /**
     * Sets a function to determine the rowspan of each column cell.
     */
    set cellRowspan(cellRowspan) {
        super.cellRowspan = cellRowspan;
    }
    get cellRowspan() {
        return super.cellRowspan;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CommandColumnComponent, deps: [{ token: ColumnBase, host: true, optional: true, skipSelf: true }, { token: IdService, optional: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: CommandColumnComponent, isStandalone: true, selector: "kendo-grid-command-column", providers: [
            {
                provide: ColumnBase,
                useExisting: forwardRef(() => CommandColumnComponent)
            }
        ], queries: [{ propertyName: "template", first: true, predicate: CellTemplateDirective, descendants: true }], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CommandColumnComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: ColumnBase,
                            useExisting: forwardRef(() => CommandColumnComponent)
                        }
                    ],
                    selector: 'kendo-grid-command-column',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: ColumnBase, decorators: [{
                    type: SkipSelf
                }, {
                    type: Host
                }, {
                    type: Optional
                }] }, { type: IdService, decorators: [{
                    type: Optional
                }] }], propDecorators: { template: [{
                type: ContentChild,
                args: [CellTemplateDirective, { static: false }]
            }] } });

/**
 * Represents the checkbox column for selecting rows in the Grid. [See example](slug:grid_row_selection#toc-select-all-checkbox).
 *
 * Use this column to add checkboxes for row selection.
 *
 * @example
 * ```html
 * <kendo-grid [selectable]="{enabled: true, checkboxOnly: true}">
 *   <kendo-grid-checkbox-column title="Select"></kendo-grid-checkbox-column>
 *   <kendo-grid-column field="ID"></kendo-grid-column>
 * </kendo-grid>
 * ```
 */
class CheckboxColumnComponent extends ColumnBase {
    selectionService;
    cellSelectionService;
    parent;
    /**
     * Shows a select-all `kendoGridSelectAllCheckbox` checkbox in the header.
     */
    showSelectAll;
    /**
     * Shows checkboxes for rows marked as non-selectable. By default, these checkboxes are visible and disabled.
     */
    showDisabledCheckbox = true;
    /*
     * @hidden
     */
    isCheckboxColumn = true;
    template;
    constructor(selectionService, cellSelectionService, parent, idService) {
        super(parent, idService);
        this.selectionService = selectionService;
        this.cellSelectionService = cellSelectionService;
        this.parent = parent;
    }
    get templateRef() {
        return this.template ? this.template.templateRef : undefined;
    }
    /**
     * @hidden
     */
    rowSelectable(rowIdx) {
        return !this.selectionService.nonSelectableRows.has(rowIdx) && !this.cellSelectionService.nonSelectableRows.has(rowIdx);
    }
    /**
     * Defines a function to determine the rowspan of each column cell.
     */
    set cellRowspan(cellRowspan) {
        super.cellRowspan = cellRowspan;
    }
    get cellRowspan() {
        return super.cellRowspan;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CheckboxColumnComponent, deps: [{ token: SelectionService }, { token: CellSelectionService }, { token: ColumnBase, host: true, optional: true, skipSelf: true }, { token: IdService, optional: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: CheckboxColumnComponent, isStandalone: true, selector: "kendo-grid-checkbox-column", inputs: { showSelectAll: "showSelectAll", showDisabledCheckbox: "showDisabledCheckbox" }, providers: [
            {
                provide: ColumnBase,
                useExisting: forwardRef(() => CheckboxColumnComponent)
            }
        ], queries: [{ propertyName: "template", first: true, predicate: CellTemplateDirective, descendants: true }], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CheckboxColumnComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: ColumnBase,
                            useExisting: forwardRef(() => CheckboxColumnComponent)
                        }
                    ],
                    selector: 'kendo-grid-checkbox-column',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: SelectionService }, { type: CellSelectionService }, { type: ColumnBase, decorators: [{
                    type: SkipSelf
                }, {
                    type: Host
                }, {
                    type: Optional
                }] }, { type: IdService, decorators: [{
                    type: Optional
                }] }], propDecorators: { showSelectAll: [{
                type: Input
            }], showDisabledCheckbox: [{
                type: Input
            }], template: [{
                type: ContentChild,
                args: [CellTemplateDirective, { static: false }]
            }] } });

/**
 * Adds a row-selection checkbox to the Grid.
 * Use this directive on a `<kendo-checkbox>` component or `<input type="checkbox">` element inside a cell template.
 * When the user clicks the checkbox, the Grid triggers a [`selectionChange`](slug:api_grid_gridcomponent#toc-selectionChange) event.
 *
 * @example
 * ```html
 * <kendo-grid>
 *   <kendo-grid-column>
 *     <ng-template kendoGridCellTemplate let-rowIndex="rowIndex">
 *       <input [kendoGridSelectionCheckbox]="rowIndex"/>
 *       <kendo-checkbox [kendoGridSelectionCheckbox]="rowIndex"></kendo-checkbox>
 *     </ng-template>
 *   </kendo-grid-column>
 * </kendo-grid>
 * ```
 * @remarks
 * Applied to: {@link CheckBoxComponent}.
 */
class SelectionCheckboxDirective {
    selectionService;
    cellSelectionService;
    aggregateService;
    el;
    renderer;
    ngZone;
    checkbox;
    /**
     * Sets the index of the `dataItem` to select.
     */
    itemIndex;
    destroyClick;
    destroyKeyDown;
    ngAfterContentChecked() {
        this.setCheckedState();
    }
    constructor(selectionService, cellSelectionService, aggregateService, el, renderer, ngZone, checkbox) {
        this.selectionService = selectionService;
        this.cellSelectionService = cellSelectionService;
        this.aggregateService = aggregateService;
        this.el = el;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.checkbox = checkbox;
        this.ngZone.runOutsideAngular(() => {
            this.destroyClick = this.renderer.listen(this.el.nativeElement, 'click', this.onClick.bind(this));
            this.destroyKeyDown = this.renderer.listen(this.el.nativeElement, 'keydown', this.onKeyDown.bind(this));
        });
    }
    ngOnDestroy() {
        if (this.destroyClick) {
            this.destroyClick();
        }
        if (this.destroyKeyDown) {
            this.destroyKeyDown();
        }
    }
    onClick(event) {
        const nonSelectableRow = this.selectionService.nonSelectableRows.has(this.itemIndex) || this.cellSelectionService.nonSelectableRows.has(this.itemIndex);
        if (nonSelectableRow || this.cellSelectionService.active) {
            event.preventDefault();
            return;
        }
        if (this.selectionService.options.enabled) {
            this.ngZone.run(() => {
                let ev;
                const ctrlKey = event.ctrlKey || event.metaKey;
                if (event.shiftKey && this.selectionService.options.mode === 'multiple') {
                    const item = { index: this.itemIndex };
                    ev = this.selectionService.addAllTo(item, ctrlKey, false, event.shiftKey);
                }
                else {
                    ev = this.selectionService.toggleByIndex(this.itemIndex);
                }
                ev.ctrlKey = event.ctrlKey;
                ev.shiftKey = event.shiftKey;
                if (this.selectionService.options.cellAggregates) {
                    ev.cellAggregates = this.aggregateService.onSelectionChange(ev);
                }
                this.selectionService.changes.emit(ev);
            });
        }
    }
    onKeyDown(e) {
        if (e.code === Keys.Enter || e.code === Keys.NumpadEnter) {
            this.onClick(e);
        }
    }
    /*
     * @hidden
     */
    setCheckedState() {
        const isSelected = this.selectionService.nonSelectableRows.has(this.itemIndex) ? false : this.selectionService.isSelected(this.itemIndex);
        if (this.checkbox) {
            this.checkbox.checkedState = isSelected;
        }
        else {
            this.renderer.setProperty(this.el.nativeElement, 'checked', isSelected);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SelectionCheckboxDirective, deps: [{ token: SelectionService }, { token: CellSelectionService }, { token: CellSelectionAggregateService }, { token: i0.ElementRef }, { token: i0.Renderer2 }, { token: i0.NgZone }, { token: i4.CheckBoxComponent, host: true, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: SelectionCheckboxDirective, isStandalone: true, selector: "[kendoGridSelectionCheckbox]", inputs: { itemIndex: ["kendoGridSelectionCheckbox", "itemIndex"] }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SelectionCheckboxDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridSelectionCheckbox]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: SelectionService }, { type: CellSelectionService }, { type: CellSelectionAggregateService }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i0.NgZone }, { type: i4.CheckBoxComponent, decorators: [{
                    type: Host
                }, {
                    type: Optional
                }] }], propDecorators: { itemIndex: [{
                type: Input,
                args: ['kendoGridSelectionCheckbox']
            }] } });

/**
 * @hidden
 */
class ChangeNotificationService {
    ngZone;
    changes = new EventEmitter();
    subscription;
    constructor(ngZone) {
        this.ngZone = ngZone;
    }
    notify() {
        if (!this.subscription || this.subscription.closed) {
            this.subscription = this.ngZone.onStable
                .asObservable().pipe(take(1))
                .subscribe(() => this.changes.emit());
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ChangeNotificationService, deps: [{ token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ChangeNotificationService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ChangeNotificationService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: i0.NgZone }] });

/**
 * Lets you customize the item shown when the Grid has no data.
 * Place an `<ng-template>` tag with the `kendoGridNoRecordsTemplate` directive inside `<kendo-grid>` to define the no-records template. ([See example](slug:norecordtemplate_grid)).
 *
 * @example
 * ```html
 * <kendo-grid [data]="data">
 *   <ng-template kendoGridNoRecordsTemplate>
 *     There are no products. <a href="#" (click)="refresh()">Click here to refresh.</a>
 *   </ng-template>
 *   <kendo-grid-column field="ProductID"></kendo-grid-column>
 *   <kendo-grid-column field="ProductName"></kendo-grid-column>
 * </kendo-grid>
 * ```
 */
class NoRecordsTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: NoRecordsTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: NoRecordsTemplateDirective, isStandalone: true, selector: "[kendoGridNoRecordsTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: NoRecordsTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridNoRecordsTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }] });

/**
 * @hidden
 */
function defaultTrackBy(index, item) {
    if (item.type === 'data' && item.isEditing) {
        return item.data;
    }
    return index;
}

/**
 * @hidden
 */
const NON_DATA_CELL_CLASSES = 'k-hierarchy-cell k-detail-cell k-group-cell';
/**
 * @hidden
 */
const NON_DATA_ROW_CLASSES = 'k-grouping-row k-group-footer k-detail-row k-grid-norecords';
/**
 * @hidden
 */
const IGNORE_TARGET_CLASSSES = 'k-icon k-svg-icon';
/**
 * @hidden
 */
const IGNORE_CONTAINER_CLASSES = 'k-grid k-grid-ignore-click';

/**
 * @hidden
 */
class CellComponent {
    editService;
    idService;
    ctx;
    detailsService;
    localization;
    cellContext;
    get commandCellClass() {
        return this.isCommand(this.column);
    }
    get dragHandleCellClass() {
        return isRowReorderColumn(this.column);
    }
    get dragRowHandleLabel() {
        return isRowReorderColumn(this.column) ? this.ctx.localization.get('dragRowHandleLabel') : undefined;
    }
    column;
    columns;
    columnIndex;
    isNew = false;
    isLoading = false;
    isVirtual = false;
    loadingTemplate;
    detailTemplate;
    item;
    set rowIndex(index) {
        this._rowIndex = index;
        this.updateCellContext();
    }
    get rowIndex() {
        return this._rowIndex;
    }
    dataItem;
    reorderIcon = reorderIcon;
    minusIcon = minusIcon;
    plusIcon = plusIcon;
    detailButtonIconName(viewItem) {
        return viewItem.isExpanded ? 'minus' : 'plus';
    }
    detailButtonSvgIcon(viewItem) {
        return viewItem.isExpanded ? this.minusIcon : this.plusIcon;
    }
    detailButtonText(viewItem) {
        return viewItem.isExpanded ? this.localization.get('detailCollapse') : this.localization.get('detailExpand');
    }
    toggleRow(index, dataItem) {
        this.detailsService.toggleRow(index, dataItem);
        return false;
    }
    get stackedRowClass() {
        const columnsLength = this.ctx.grid.stackedColumns?.columns.length;
        if (this.ctx.grid.stackedColumns.areDefault && columnsLength > 1) {
            return `k-grid-cols-${columnsLength}`;
        }
    }
    get stackedRowStyle() {
        const columnsWidths = this.ctx.grid.stackedColumns.columns.map(c => c.width).join(' ');
        if (!this.ctx.grid.stackedColumns.areDefault && columnsWidths) {
            return {
                'grid-template-columns': `${columnsWidths}`
            };
        }
    }
    isEdited(column) {
        const currentColumn = column || this.column;
        if (!(this.editService.isEditing() || this.isNew) || !this.isColumnEditable(column)) {
            return false;
        }
        const editContext = this.editService.columnContext(this.rowIndex, currentColumn);
        return this.isFieldEditable(editContext, currentColumn);
    }
    get showLoading() {
        return this.isVirtual && this.isLoading;
    }
    get formGroup() {
        return this.editService.context(this.rowIndex).group;
    }
    getTemplateContext(column) {
        this._templateContext.isNew = this.isNew;
        this._templateContext.column = column || this.column;
        this._templateContext.dataItem = this.dataItem;
        this._templateContext.rowIndex = this.rowIndex;
        this._templateContext.columnIndex = this.columnIndex;
        this._templateContext.$implicit = this.dataItem;
        return this._templateContext;
    }
    get isStackedLayoutMode() {
        return this.ctx.grid?.isStacked;
    }
    getEditTemplateContext(column) {
        this._editTemplateContext.$implicit = this.formGroup;
        this._editTemplateContext.isNew = this.isNew;
        this._editTemplateContext.column = column || this.column;
        this._editTemplateContext.dataItem = this.dataItem;
        this._editTemplateContext.formGroup = this.formGroup;
        this._editTemplateContext.rowIndex = this.rowIndex;
        return this._editTemplateContext;
    }
    get rowReorderTemplateContext() {
        this._rowReorderTemplateContext.$implicit = this.dataItem;
        this._rowReorderTemplateContext.columnIndex = this.columnIndex;
        this._rowReorderTemplateContext.rowIndex = this.rowIndex;
        return this._rowReorderTemplateContext;
    }
    get format() {
        if (isColumnComponent(this.column) && !isNullOrEmptyString(this.column.format)) {
            return extractFormat(this.column.format);
        }
        return undefined;
    }
    isBoundColumn(column) {
        const currentColumn = column || this.column;
        return currentColumn.field && !currentColumn.templateRef;
    }
    isCheckboxColumn(column) {
        const currentColumn = column || this.column;
        return isCheckboxColumn(currentColumn) && !currentColumn.templateRef;
    }
    get selectionCheckboxId() {
        return this.idService.selectionCheckboxId(this.rowIndex);
    }
    get selectionCheckboxLabel() {
        return this.ctx.localization.get('selectionCheckboxLabel');
    }
    get isSpanColumn() {
        return isSpanColumn(this.column) && !this.column.templateRef;
    }
    get children() {
        return columnsToRender([this.column]);
    }
    isRowReorderColumn(column) {
        const currentColumn = column || this.column;
        return isRowReorderColumn(currentColumn) && !currentColumn.templateRef;
    }
    isRowSelectable(column) {
        const currentColumn = column || this.column;
        return currentColumn.rowSelectable(this._rowIndex);
    }
    _rowIndex;
    isColumnEditable(column) {
        const currentColumn = column || this.column;
        if (!currentColumn || this.isCommand(currentColumn)) {
            return false;
        }
        return currentColumn.editable !== false;
    }
    _templateContext = {};
    _editTemplateContext = {};
    _rowReorderTemplateContext = {};
    constructor(editService, idService, ctx, detailsService, localization, cellContext) {
        this.editService = editService;
        this.idService = idService;
        this.ctx = ctx;
        this.detailsService = detailsService;
        this.localization = localization;
        this.cellContext = cellContext;
    }
    ngDoCheck() {
        this.updateCellContext();
    }
    isCommand(column) {
        return column instanceof CommandColumnComponent;
    }
    isFieldEditable(editContext, column) {
        if (!isPresent(editContext)) {
            return false;
        }
        if (isPresent(column.editTemplate)) {
            return true;
        }
        return isPresent(editContext.group) && isPresent(editContext.group.get(column.field));
    }
    updateCellContext() {
        if (this.cellContext) {
            this.cellContext.rowIndex = this._rowIndex;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CellComponent, deps: [{ token: EditService }, { token: IdService }, { token: ContextService }, { token: DetailsService }, { token: i1$2.LocalizationService }, { token: CELL_CONTEXT, optional: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: CellComponent, isStandalone: true, selector: "[kendoGridCell]", inputs: { column: "column", columns: "columns", columnIndex: "columnIndex", isNew: "isNew", isLoading: "isLoading", isVirtual: "isVirtual", loadingTemplate: "loadingTemplate", detailTemplate: "detailTemplate", item: "item", rowIndex: "rowIndex", dataItem: "dataItem" }, host: { properties: { "class.k-command-cell": "this.commandCellClass", "class.k-drag-cell": "this.dragHandleCellClass", "class.k-touch-action-none": "this.dragHandleCellClass", "attr.aria-label": "this.dragRowHandleLabel" } }, ngImport: i0, template: `
        @if (isStackedLayoutMode) {
            <div class="k-grid-stack-row"
                [ngClass]="stackedRowClass"
                [ngStyle]="stackedRowStyle">
                @for (col of columns; track $index) {
                    <div class="k-grid-stack-cell"
                        [class.k-grid-stack-edit-cell]="isEdited(col)"
                        [class.k-drag-cell]="isRowReorderColumn(col) && !isNew"
                        [class.k-command-cell]="isCommand(col)"
                        [kendoGridFocusable]="!isCommand(col)">
                        <div class="k-grid-stack-header">
                            @if (!col.headerTemplateRef) {
                                {{col.displayTitle}}
                            } @else {
                                <ng-template #headerTemplate
                                    [templateContext]="{
                                        templateRef: col.headerTemplateRef,
                                        columnIndex: col.leafIndex,
                                        column: col,
                                        $implicit: col
                                    }">
                                </ng-template>
                            }
                        </div>
                        <div class="k-grid-stack-content">
                            @if (!isEdited(col)) {
                                @if (!col.templateRef) {
                                    @if (isBoundColumn(col)) {{{ dataItem | valueOf: col.field: col.format}}}
                                    @if (isCheckboxColumn(col) && !isNew) {
                                        @if (isRowSelectable(col)) {
                                            <kendo-checkbox
                                                [kendoGridSelectionCheckbox]="rowIndex"
                                                [attr.id]="selectionCheckboxId"
                                                [inputAttributes]="{'aria-label': selectionCheckboxLabel}"
                                                [title]="selectionCheckboxLabel">
                                            </kendo-checkbox>
                                        } @else {
                                            @if (col.showDisabledCheckbox) {
                                                <kendo-checkbox
                                                    [kendoGridSelectionCheckbox]="rowIndex"
                                                    [attr.id]="selectionCheckboxId"
                                                    [inputAttributes]="{'aria-label': selectionCheckboxLabel}"
                                                    [title]="selectionCheckboxLabel"
                                                    [disabled]="true"
                                                ></kendo-checkbox>
                                            }
                                        }
                                    }
                                    @if (isRowReorderColumn(col) && !isNew) {
                                        @if (!col.dragHandleTemplate?.first) {
                                            <kendo-icon-wrapper
                                                name="reorder"
                                                [svgIcon]="reorderIcon">
                                            </kendo-icon-wrapper>
                                        } @else {
                                            <ng-template
                                                [ngTemplateOutlet]="col.rowDragHandleTemplateRef"
                                                [ngTemplateOutletContext]="rowReorderTemplateContext">
                                            </ng-template>
                                        }
                                    }
                                } @else {
                                    <ng-template #template
                                        [ngTemplateOutlet]="col.templateRef"
                                        [ngTemplateOutletContext]="getTemplateContext(col)">
                                    </ng-template>
                                }
                            }
                            @if (isEdited(col)) {
                                @if (!col.editTemplateRef) {
                                    @switch (col.editor) {
                                        @case ('numeric') {
                                            <kendo-numerictextbox
                                                [format]="format"
                                                [formControl]="$any(formGroup.get(col.field))"
                                                kendoGridFocusable
                                            ></kendo-numerictextbox>
                                        }
                                        @case ('date') {
                                            <kendo-datepicker
                                                [format]="format"
                                                [formControl]="$any(formGroup.get(col.field))"
                                                kendoGridFocusable
                                            ></kendo-datepicker>
                                        }
                                        @case ('boolean') {
                                            <kendo-checkbox
                                                [formControl]="$any(formGroup.get(col.field))"
                                                kendoGridFocusable
                                            ></kendo-checkbox>
                                        }
                                        @default {
                                            <kendo-textbox
                                                [formControl]="$any(formGroup.get(col.field))"
                                                kendoGridFocusable
                                            ></kendo-textbox>
                                        }
                                    }
                                } @else {
                                    <ng-template
                                        [ngTemplateOutlet]="col.editTemplateRef"
                                        [ngTemplateOutletContext]="getEditTemplateContext(col)">
                                    </ng-template>
                                }
                            }
                        </div>
                    </div>
                }
                @if (detailTemplate?.showIf(item.data, $any(item).index)) {
                    <div class="k-grid-stack-cell" [attr.aria-expanded]="item.isExpanded">
                        <div class="k-grid-stack-content">
                            <button kendoButton
                                fillMode="flat"
                                themeColor="primary"
                                [icon]="detailButtonIconName(item)"
                                [svgIcon]="detailButtonSvgIcon(item)"
                                (click)="toggleRow($any(item).index, item.data)">
                                {{ detailButtonText(item) }}
                            </button>
                        </div>
                    </div>
                }
            </div>
        }

        @if (!isStackedLayoutMode) {
            @switch (isEdited()) {
                @case (false) {
                    @if (!showLoading) {
                        @if (column.templateRef) {
                            <ng-template
                                [ngTemplateOutlet]="column.templateRef"
                                [ngTemplateOutletContext]="getTemplateContext()">
                            </ng-template>
                        }
                        @if (isSpanColumn) {
                            @for (childColumn of children; track $index) {
                                {{ dataItem | valueOf: childColumn.field: childColumn.format}}
                            }
                        }
                        @if (isBoundColumn()) {{{ dataItem | valueOf: column.field: column.format}}}
                        @if (isCheckboxColumn() && !isNew) {
                            @if (isRowSelectable()) {
                                <kendo-checkbox
                                    [kendoGridSelectionCheckbox]="rowIndex"
                                    [attr.id]="selectionCheckboxId"
                                    [inputAttributes]="{'aria-label': selectionCheckboxLabel}"
                                    [title]="selectionCheckboxLabel">
                                </kendo-checkbox>
                            } @else {
                                @if (column.showDisabledCheckbox) {
                                    <kendo-checkbox
                                        [kendoGridSelectionCheckbox]="rowIndex"
                                        [attr.id]="selectionCheckboxId"
                                        [inputAttributes]="{'aria-label': selectionCheckboxLabel}"
                                        [title]="selectionCheckboxLabel"
                                        [disabled]="true"
                                    ></kendo-checkbox>
                                }
                            }
                        }
                        @if (isRowReorderColumn() && !isNew) {
                            @if (!column.dragHandleTemplate?.first) {
                                <kendo-icon-wrapper
                                    name="reorder"
                                    [svgIcon]="reorderIcon">
                                </kendo-icon-wrapper>
                            } @else {
                                <ng-template
                                    [ngTemplateOutlet]="column.rowDragHandleTemplateRef"
                                    [ngTemplateOutletContext]="rowReorderTemplateContext">
                                </ng-template>
                            }
                        }
                    } @else {
                        @if (loadingTemplate) {
                            <ng-template
                                [ngTemplateOutlet]="loadingTemplate"
                                [ngTemplateOutletContext]="{$implicit: column}">
                            </ng-template>
                        } @else {
                            <div class="k-skeleton-text k-skeleton"></div>
                        }
                    }
                }
                @case (true) {
                    @if (column.editTemplateRef) {
                        <ng-template
                            [ngTemplateOutlet]="column.editTemplateRef"
                            [ngTemplateOutletContext]="getEditTemplateContext()">
                        </ng-template>
                    } @else {
                        @switch (column.editor) {
                            @case ('numeric') {
                                <kendo-numerictextbox
                                    [format]="format"
                                    [formControl]="$any(formGroup.get(column.field))"
                                    kendoGridFocusable
                                ></kendo-numerictextbox>
                            }
                            @case ('date') {
                                <kendo-datepicker
                                    [format]="format"
                                    [formControl]="$any(formGroup.get(column.field))"
                                    kendoGridFocusable
                                ></kendo-datepicker>
                            }
                            @case ('boolean') {
                                <kendo-checkbox
                                    [formControl]="$any(formGroup.get(column.field))"
                                    kendoGridFocusable
                                ></kendo-checkbox>
                            }
                            @default {
                                <kendo-textbox
                                    [formControl]="$any(formGroup.get(column.field))"
                                    kendoGridFocusable
                                ></kendo-textbox>
                            }
                        }
                    }
                }
            }
        }
    `, isInline: true, dependencies: [{ kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: FocusableDirective, selector: "[kendoGridFocusable],\n        [kendoGridEditCommand],\n        [kendoGridRemoveCommand],\n        [kendoGridSaveCommand],\n        [kendoGridCancelCommand],\n        [kendoGridSelectionCheckbox]\n    ", inputs: ["kendoGridFocusable"] }, { kind: "directive", type: SelectionCheckboxDirective, selector: "[kendoGridSelectionCheckbox]", inputs: ["kendoGridSelectionCheckbox"] }, { kind: "directive", type: TemplateContextDirective, selector: "[templateContext]", inputs: ["templateContext"] }, { kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "component", type: NumericTextBoxComponent, selector: "kendo-numerictextbox", inputs: ["focusableId", "disabled", "readonly", "title", "autoCorrect", "format", "max", "min", "decimals", "placeholder", "step", "spinners", "rangeValidation", "tabindex", "tabIndex", "changeValueOnScroll", "selectOnFocus", "value", "maxlength", "size", "rounded", "fillMode", "inputAttributes"], outputs: ["valueChange", "focus", "blur", "inputFocus", "inputBlur"], exportAs: ["kendoNumericTextBox"] }, { kind: "component", type: DatePickerComponent, selector: "kendo-datepicker", inputs: ["focusableId", "cellTemplate", "clearButton", "inputAttributes", "monthCellTemplate", "yearCellTemplate", "decadeCellTemplate", "centuryCellTemplate", "weekNumberTemplate", "headerTitleTemplate", "headerTemplate", "footerTemplate", "footer", "navigationItemTemplate", "weekDaysFormat", "showOtherMonthDays", "activeView", "bottomView", "topView", "calendarType", "animateCalendarNavigation", "disabled", "readonly", "readOnlyInput", "popupSettings", "navigation", "min", "max", "incompleteDateValidation", "autoCorrectParts", "autoSwitchParts", "autoSwitchKeys", "enableMouseWheel", "allowCaretMode", "autoFill", "focusedDate", "value", "format", "twoDigitYearMax", "formatPlaceholder", "placeholder", "tabindex", "tabIndex", "disabledDates", "adaptiveTitle", "adaptiveSubtitle", "rangeValidation", "disabledDatesValidation", "weekNumber", "size", "rounded", "fillMode", "adaptiveMode"], outputs: ["valueChange", "focus", "blur", "open", "close", "escape"], exportAs: ["kendo-datepicker"] }, { kind: "pipe", type: FieldAccessorPipe, name: "valueOf" }, { kind: "ngmodule", type: ReactiveFormsModule }, { kind: "directive", type: i2$2.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$2.FormControlDirective, selector: "[formControl]", inputs: ["formControl", "disabled", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }, { kind: "component", type: CheckBoxComponent, selector: "kendo-checkbox", inputs: ["checkedState", "rounded"], outputs: ["checkedStateChange"], exportAs: ["kendoCheckBox"] }, { kind: "component", type: TextBoxComponent, selector: "kendo-textbox", inputs: ["focusableId", "title", "type", "disabled", "readonly", "tabindex", "value", "selectOnFocus", "showSuccessIcon", "showErrorIcon", "clearButton", "successIcon", "successSvgIcon", "errorIcon", "errorSvgIcon", "clearButtonIcon", "clearButtonSvgIcon", "size", "rounded", "fillMode", "tabIndex", "placeholder", "maxlength", "inputAttributes"], outputs: ["valueChange", "inputFocus", "inputBlur", "focus", "blur"], exportAs: ["kendoTextBox"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "component", type: ButtonComponent, selector: "button[kendoButton]", inputs: ["arrowIcon", "toggleable", "togglable", "selected", "tabIndex", "imageUrl", "iconClass", "icon", "disabled", "size", "rounded", "fillMode", "themeColor", "svgIcon", "primary", "look"], outputs: ["selectedChange", "click"], exportAs: ["kendoButton"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CellComponent, decorators: [{
            type: Component,
            args: [{
                    selector: '[kendoGridCell]',
                    template: `
        @if (isStackedLayoutMode) {
            <div class="k-grid-stack-row"
                [ngClass]="stackedRowClass"
                [ngStyle]="stackedRowStyle">
                @for (col of columns; track $index) {
                    <div class="k-grid-stack-cell"
                        [class.k-grid-stack-edit-cell]="isEdited(col)"
                        [class.k-drag-cell]="isRowReorderColumn(col) && !isNew"
                        [class.k-command-cell]="isCommand(col)"
                        [kendoGridFocusable]="!isCommand(col)">
                        <div class="k-grid-stack-header">
                            @if (!col.headerTemplateRef) {
                                {{col.displayTitle}}
                            } @else {
                                <ng-template #headerTemplate
                                    [templateContext]="{
                                        templateRef: col.headerTemplateRef,
                                        columnIndex: col.leafIndex,
                                        column: col,
                                        $implicit: col
                                    }">
                                </ng-template>
                            }
                        </div>
                        <div class="k-grid-stack-content">
                            @if (!isEdited(col)) {
                                @if (!col.templateRef) {
                                    @if (isBoundColumn(col)) {{{ dataItem | valueOf: col.field: col.format}}}
                                    @if (isCheckboxColumn(col) && !isNew) {
                                        @if (isRowSelectable(col)) {
                                            <kendo-checkbox
                                                [kendoGridSelectionCheckbox]="rowIndex"
                                                [attr.id]="selectionCheckboxId"
                                                [inputAttributes]="{'aria-label': selectionCheckboxLabel}"
                                                [title]="selectionCheckboxLabel">
                                            </kendo-checkbox>
                                        } @else {
                                            @if (col.showDisabledCheckbox) {
                                                <kendo-checkbox
                                                    [kendoGridSelectionCheckbox]="rowIndex"
                                                    [attr.id]="selectionCheckboxId"
                                                    [inputAttributes]="{'aria-label': selectionCheckboxLabel}"
                                                    [title]="selectionCheckboxLabel"
                                                    [disabled]="true"
                                                ></kendo-checkbox>
                                            }
                                        }
                                    }
                                    @if (isRowReorderColumn(col) && !isNew) {
                                        @if (!col.dragHandleTemplate?.first) {
                                            <kendo-icon-wrapper
                                                name="reorder"
                                                [svgIcon]="reorderIcon">
                                            </kendo-icon-wrapper>
                                        } @else {
                                            <ng-template
                                                [ngTemplateOutlet]="col.rowDragHandleTemplateRef"
                                                [ngTemplateOutletContext]="rowReorderTemplateContext">
                                            </ng-template>
                                        }
                                    }
                                } @else {
                                    <ng-template #template
                                        [ngTemplateOutlet]="col.templateRef"
                                        [ngTemplateOutletContext]="getTemplateContext(col)">
                                    </ng-template>
                                }
                            }
                            @if (isEdited(col)) {
                                @if (!col.editTemplateRef) {
                                    @switch (col.editor) {
                                        @case ('numeric') {
                                            <kendo-numerictextbox
                                                [format]="format"
                                                [formControl]="$any(formGroup.get(col.field))"
                                                kendoGridFocusable
                                            ></kendo-numerictextbox>
                                        }
                                        @case ('date') {
                                            <kendo-datepicker
                                                [format]="format"
                                                [formControl]="$any(formGroup.get(col.field))"
                                                kendoGridFocusable
                                            ></kendo-datepicker>
                                        }
                                        @case ('boolean') {
                                            <kendo-checkbox
                                                [formControl]="$any(formGroup.get(col.field))"
                                                kendoGridFocusable
                                            ></kendo-checkbox>
                                        }
                                        @default {
                                            <kendo-textbox
                                                [formControl]="$any(formGroup.get(col.field))"
                                                kendoGridFocusable
                                            ></kendo-textbox>
                                        }
                                    }
                                } @else {
                                    <ng-template
                                        [ngTemplateOutlet]="col.editTemplateRef"
                                        [ngTemplateOutletContext]="getEditTemplateContext(col)">
                                    </ng-template>
                                }
                            }
                        </div>
                    </div>
                }
                @if (detailTemplate?.showIf(item.data, $any(item).index)) {
                    <div class="k-grid-stack-cell" [attr.aria-expanded]="item.isExpanded">
                        <div class="k-grid-stack-content">
                            <button kendoButton
                                fillMode="flat"
                                themeColor="primary"
                                [icon]="detailButtonIconName(item)"
                                [svgIcon]="detailButtonSvgIcon(item)"
                                (click)="toggleRow($any(item).index, item.data)">
                                {{ detailButtonText(item) }}
                            </button>
                        </div>
                    </div>
                }
            </div>
        }

        @if (!isStackedLayoutMode) {
            @switch (isEdited()) {
                @case (false) {
                    @if (!showLoading) {
                        @if (column.templateRef) {
                            <ng-template
                                [ngTemplateOutlet]="column.templateRef"
                                [ngTemplateOutletContext]="getTemplateContext()">
                            </ng-template>
                        }
                        @if (isSpanColumn) {
                            @for (childColumn of children; track $index) {
                                {{ dataItem | valueOf: childColumn.field: childColumn.format}}
                            }
                        }
                        @if (isBoundColumn()) {{{ dataItem | valueOf: column.field: column.format}}}
                        @if (isCheckboxColumn() && !isNew) {
                            @if (isRowSelectable()) {
                                <kendo-checkbox
                                    [kendoGridSelectionCheckbox]="rowIndex"
                                    [attr.id]="selectionCheckboxId"
                                    [inputAttributes]="{'aria-label': selectionCheckboxLabel}"
                                    [title]="selectionCheckboxLabel">
                                </kendo-checkbox>
                            } @else {
                                @if (column.showDisabledCheckbox) {
                                    <kendo-checkbox
                                        [kendoGridSelectionCheckbox]="rowIndex"
                                        [attr.id]="selectionCheckboxId"
                                        [inputAttributes]="{'aria-label': selectionCheckboxLabel}"
                                        [title]="selectionCheckboxLabel"
                                        [disabled]="true"
                                    ></kendo-checkbox>
                                }
                            }
                        }
                        @if (isRowReorderColumn() && !isNew) {
                            @if (!column.dragHandleTemplate?.first) {
                                <kendo-icon-wrapper
                                    name="reorder"
                                    [svgIcon]="reorderIcon">
                                </kendo-icon-wrapper>
                            } @else {
                                <ng-template
                                    [ngTemplateOutlet]="column.rowDragHandleTemplateRef"
                                    [ngTemplateOutletContext]="rowReorderTemplateContext">
                                </ng-template>
                            }
                        }
                    } @else {
                        @if (loadingTemplate) {
                            <ng-template
                                [ngTemplateOutlet]="loadingTemplate"
                                [ngTemplateOutletContext]="{$implicit: column}">
                            </ng-template>
                        } @else {
                            <div class="k-skeleton-text k-skeleton"></div>
                        }
                    }
                }
                @case (true) {
                    @if (column.editTemplateRef) {
                        <ng-template
                            [ngTemplateOutlet]="column.editTemplateRef"
                            [ngTemplateOutletContext]="getEditTemplateContext()">
                        </ng-template>
                    } @else {
                        @switch (column.editor) {
                            @case ('numeric') {
                                <kendo-numerictextbox
                                    [format]="format"
                                    [formControl]="$any(formGroup.get(column.field))"
                                    kendoGridFocusable
                                ></kendo-numerictextbox>
                            }
                            @case ('date') {
                                <kendo-datepicker
                                    [format]="format"
                                    [formControl]="$any(formGroup.get(column.field))"
                                    kendoGridFocusable
                                ></kendo-datepicker>
                            }
                            @case ('boolean') {
                                <kendo-checkbox
                                    [formControl]="$any(formGroup.get(column.field))"
                                    kendoGridFocusable
                                ></kendo-checkbox>
                            }
                            @default {
                                <kendo-textbox
                                    [formControl]="$any(formGroup.get(column.field))"
                                    kendoGridFocusable
                                ></kendo-textbox>
                            }
                        }
                    }
                }
            }
        }
    `,
                    standalone: true,
                    imports: [NgTemplateOutlet, FocusableDirective, SelectionCheckboxDirective, TemplateContextDirective,
                        IconWrapperComponent, NumericTextBoxComponent, DatePickerComponent, FieldAccessorPipe, ReactiveFormsModule, CheckBoxComponent, TextBoxComponent, NgClass, NgStyle, ButtonComponent]
                }]
        }], ctorParameters: () => [{ type: EditService }, { type: IdService }, { type: ContextService }, { type: DetailsService }, { type: i1$2.LocalizationService }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [CELL_CONTEXT]
                }] }], propDecorators: { commandCellClass: [{
                type: HostBinding,
                args: ['class.k-command-cell']
            }], dragHandleCellClass: [{
                type: HostBinding,
                args: ['class.k-drag-cell']
            }, {
                type: HostBinding,
                args: ['class.k-touch-action-none']
            }], dragRowHandleLabel: [{
                type: HostBinding,
                args: ['attr.aria-label']
            }], column: [{
                type: Input
            }], columns: [{
                type: Input
            }], columnIndex: [{
                type: Input
            }], isNew: [{
                type: Input
            }], isLoading: [{
                type: Input
            }], isVirtual: [{
                type: Input
            }], loadingTemplate: [{
                type: Input
            }], detailTemplate: [{
                type: Input
            }], item: [{
                type: Input
            }], rowIndex: [{
                type: Input
            }], dataItem: [{
                type: Input
            }] } });

const columnCellIndex = (cell, cells, isStacked) => {
    let cellIndex = 0;
    for (let idx = 0; idx < cells.length; idx++) {
        const isChildCell = cell.parentNode === cells[idx];
        const isActualCell = cell === cells[idx];
        const matches = isActualCell || (isStacked && isChildCell);
        if (matches) {
            return cellIndex;
        }
        if (!hasClasses(cells[idx], 'k-hierarchy-cell k-group-cell')) {
            cellIndex++;
        }
    }
};
/**
 * @hidden
 */
class TableBodyComponent {
    detailsService;
    groupsService;
    changeNotification;
    editService;
    ctx;
    ngZone;
    renderer;
    element;
    domEvents;
    selectionService;
    cellSelectionService;
    columnInfoService;
    navigationService;
    columns = [];
    allColumns;
    groups = [];
    detailTemplate;
    noRecordsTemplate;
    rowsToRender;
    skip = 0;
    selectable;
    filterable;
    noRecordsText;
    isLocked = false;
    isLoading;
    isVirtual;
    cellLoadingTemplate;
    skipGroupDecoration = false;
    lockedColumnsCount = 0;
    totalColumnsCount = 0;
    virtualColumns;
    trackBy = defaultTrackBy;
    rowSticky;
    totalColumns;
    rowClass = () => null;
    rowHeight;
    detailRowHeight;
    hostClass = true;
    groupHeaderSlaveCellsCount;
    groupHeaderColumns;
    clickSubscription;
    touchSubscription;
    l10nSubscription;
    cellKeydownSubscription;
    clickTimeout;
    minusIcon = minusIcon;
    plusIcon = plusIcon;
    constructor(detailsService, groupsService, changeNotification, editService, ctx, ngZone, renderer, element, domEvents, selectionService, cellSelectionService, columnInfoService, navigationService) {
        this.detailsService = detailsService;
        this.groupsService = groupsService;
        this.changeNotification = changeNotification;
        this.editService = editService;
        this.ctx = ctx;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.element = element;
        this.domEvents = domEvents;
        this.selectionService = selectionService;
        this.cellSelectionService = cellSelectionService;
        this.columnInfoService = columnInfoService;
        this.navigationService = navigationService;
        this.noRecordsText = this.ctx.localization.get('noRecords');
        this.cellKeydownSubscription = this.navigationService.cellKeydown.subscribe((args) => this.cellKeydownHandler(args));
        this.trackByWrapper = this.trackByWrapper.bind(this);
        this.trackByColumns = this.trackByColumns.bind(this);
    }
    get newDataItem() {
        return this.editService.newDataItem;
    }
    // Number of unlocked columns in the next table, if any
    unlockedColumnsCount(item) {
        const allColumns = this.allColumns || this.columns;
        let allColumnsCount = allColumns.length;
        allColumns.forEach(column => {
            if (column.isSpanColumn) {
                allColumnsCount += column.colspan - 1;
            }
        });
        const contentColumnsCount = this.totalColumnsCount - (this.isStackedMode ? 0 : this.lockedColumnsCount) - allColumnsCount;
        const headerFooterColumnsCount = this.totalColumnsCount - (this.isStackedMode ? 0 : this.lockedColumnsCount) - allColumns.length;
        return item && item.type === 'data' ? contentColumnsCount : headerFooterColumnsCount;
    }
    isAriaSelected(item, column) {
        return this.cellSelectionService.isCellSelected(item, column) ||
            this.isRowSelected(item) ? 'true' : 'false';
    }
    toggleRow(index, dataItem) {
        this.detailsService.toggleRow(index, dataItem);
        return false;
    }
    detailButtonIconName(viewItem) {
        return viewItem.isExpanded ? 'minus' : 'plus';
    }
    detailButtonSvgIcon(viewItem) {
        return viewItem.isExpanded ? this.minusIcon : this.plusIcon;
    }
    detailButtonTitle(viewItem) {
        const messageKey = viewItem.isExpanded ? 'detailCollapse' : 'detailExpand';
        return this.ctx.localization.get(messageKey);
    }
    isOdd(item) {
        return item.index % 2 !== 0;
    }
    isSelectable(args) {
        const rowSelectable = this.isRowSelectable(args);
        const selectionEnabled = this.selectable && this.selectable.enabled !== false;
        return selectionEnabled && rowSelectable;
    }
    isRowSelected(item) {
        return this.selectionService.isSelected(item.index);
    }
    isRowSelectable(args) {
        return this.selectionService.settings?.isRowSelectable(args) || this.cellSelectionService.settings?.isRowSelectable(args);
    }
    trackByWrapper(index, item) {
        return this.trackBy(index, item);
    }
    trackByColumns(index, item) {
        return this.virtualColumns ? index : item;
    }
    ngDoCheck() {
        if (this.rowsToRender) {
            this.rowsToRender.forEach((item) => {
                if (item.type === 'data') {
                    item.isEditing = this.editService.hasEdited(item.index);
                }
            });
        }
        if (this.hasGroupHeaderColumn) {
            this.groupHeaderColumns = columnsToRender(this.skipGroupDecoration ? this.columns : this.columns.toArray().slice(1));
        }
        else {
            this.groupHeaderColumns = [];
        }
        if (this.isLocked) {
            this.groupHeaderSlaveCellsCount =
                this.hasGroupHeaderColumn ? this.columnsContainer.nonLockedColumnsToRender.length : 1;
        }
        else {
            this.groupHeaderSlaveCellsCount = 0;
        }
    }
    ngAfterViewChecked() {
        if (this.rowSticky) {
            this.applyStickyRowsStyling();
        }
    }
    ngOnChanges(changes) {
        if (isChanged$1('columns', changes, false)) {
            this.changeNotification.notify();
        }
    }
    logicalRowIndex(rowIndex) {
        const skip = this.skip + (this.ctx.scroller?.virtualSkip ?? 0);
        let pos = rowIndex + skip;
        if (this.hasDetailTemplate && !this.isStackedMode) {
            pos *= 2;
        }
        const absoluteRowIndex = this.isStackedMode ? pos : 1 + pos;
        const addRowOffset = this.editService.hasNewItem ? 1 : 0;
        const filterRowOffset = hasFilterRow(this.filterable) ? 1 : 0;
        const headerRowCount = this.columnInfoService.totalLevels + filterRowOffset + addRowOffset;
        return absoluteRowIndex + headerRowCount;
    }
    addRowLogicalIndex() {
        return this.columnInfoService.totalLevels + 1 +
            (hasFilterRow(this.filterable) ? 1 : 0);
    }
    logicalColIndex(column) {
        if (!isPresent(column.leafIndex)) {
            return -1;
        }
        return column.leafIndex + (this.hasDetailTemplate ? 1 : 0);
    }
    ngOnInit() {
        this.ngZone.runOutsideAngular(() => {
            const clickHandler = this.clickHandler.bind(this);
            const mousedownSubscription = this.renderer.listen(this.element.nativeElement, 'mousedown', clickHandler);
            const mouseupSubscription = this.renderer.listen(this.element.nativeElement, 'mouseup', clickHandler);
            const clickSubscription = this.renderer.listen(this.element.nativeElement, 'click', clickHandler);
            const contextmenuSubscription = this.renderer.listen(this.element.nativeElement, 'contextmenu', clickHandler);
            const touchstartSubscription = this.renderer.listen(this.element.nativeElement, 'touchstart', clickHandler);
            const touchendSubscription = this.renderer.listen(this.element.nativeElement, 'touchend', clickHandler);
            this.clickSubscription = () => {
                mousedownSubscription();
                mouseupSubscription();
                clickSubscription();
                contextmenuSubscription();
            };
            this.touchSubscription = () => {
                touchstartSubscription();
                touchendSubscription();
            };
        });
        let originalNoRecordText = this.ctx.localization.get('noRecords');
        this.l10nSubscription = this.ctx.localization.changes.subscribe(() => {
            if (this.noRecordsText === originalNoRecordText) {
                this.noRecordsText = this.ctx.localization.get('noRecords');
                originalNoRecordText = this.noRecordsText;
            }
        });
    }
    ngOnDestroy() {
        if (this.clickSubscription) {
            this.clickSubscription();
        }
        if (this.touchSubscription) {
            this.touchSubscription();
        }
        if (this.l10nSubscription) {
            this.l10nSubscription.unsubscribe();
        }
        this.cellKeydownSubscription.unsubscribe();
        clearTimeout(this.clickTimeout);
    }
    isEditingCell(index, column) {
        return this.editService.isEditing() && this.editService.isEditedColumn(index, column);
    }
    isEditingRow(index) {
        return this.editService.isEditing() && this.editService.hasEdited(index);
    }
    get isStackedMode() {
        return this.ctx.grid?.isStacked;
    }
    get hasGroupHeaderColumn() {
        return this.columnsContainer.hasGroupHeaderColumn;
    }
    get columnsContainer() {
        return this.columnInfoService.columnsContainer;
    }
    get columnsSpan() {
        return columnsSpan(this.columns);
    }
    get allColumnsSpan() {
        return columnsSpan(this.allColumns || this.columns);
    }
    get colSpan() {
        return this.columnsSpan + this.groups.length + (this.hasDetailTemplate ? 1 : 0);
    }
    get footerColumns() {
        const colsToRender = Array.from(this.columns).reduce((cols, col) => {
            const newCols = (col instanceof SpanColumnComponent) ? Array.from(col.children) : [col];
            return [...cols, ...newCols];
        }, []);
        return colsToRender;
    }
    addStickyColumnStyles(column) {
        const stickyStyles = this.columnInfoService.stickyColumnsStyles(column);
        return { ...column.style, ...stickyStyles };
    }
    resizeHandler() {
        this.applyStickyRowsStyling();
    }
    get hasDetailTemplate() {
        return isPresent(this.detailTemplate);
    }
    clickHandler(eventArg) {
        const element = this.element.nativeElement;
        const target = this.eventTarget(eventArg);
        const selectionEnabled = this.selectable && this.selectable.enabled !== false;
        if (eventArg.code === Keys.Space) {
            if (!selectionEnabled) {
                return;
            }
            const cellComparer = this.isStackedMode ? closest(target, (el) => hasClasses(el, 'k-grid-stack-cell')) || closest(target, matchesNodeName('td')) : closest(target, matchesNodeName('td'));
            const isCellFocused = cellComparer?.classList.contains('k-focus') || cellComparer === document.activeElement;
            const isShiftOrCtrlPressed = eventArg.shiftKey || eventArg.ctrlKey || eventArg.metaKey;
            if (isCellFocused && !isShiftOrCtrlPressed) {
                eventArg.preventDefault();
            }
        }
        let row, body, gridElement;
        const currentTarget = target;
        const gridTbody = closest(currentTarget, (el) => matchesNodeName('tbody')(el) && el === element);
        if (!gridTbody) {
            return;
        }
        let cell = closest(currentTarget, (el) => {
            if (!matchesNodeName('td')(el)) {
                return false;
            }
            const parentRow = el.parentElement;
            if (!parentRow || !matchesNodeName('tr')(parentRow)) {
                return false;
            }
            return parentRow.parentElement === element;
        });
        if (cell) {
            row = cell.parentElement;
            body = element;
            gridElement = null;
        }
        if (cell && !hasClasses(cell, NON_DATA_CELL_CLASSES) &&
            !hasClasses(row, NON_DATA_ROW_CLASSES) &&
            body === element && !gridElement) {
            const isCellTarget = hasClasses(currentTarget, 'k-grid-stack-cell');
            if (this.isStackedMode) {
                cell = closest(currentTarget, (el) => {
                    if (!closestInScope(target, matchesClasses('k-grid-stack-row'), cell)) {
                        return false;
                    }
                    const parentRow = isCellTarget ? currentTarget : el.parentElement;
                    return (parentRow && hasClasses(parentRow, 'k-grid-stack-cell'));
                });
                if (isCellTarget) {
                    cell = findElement(currentTarget, (el) => hasClasses(el, 'k-grid-stack-content'));
                }
                if (cell) {
                    row = cell.parentElement.parentElement;
                }
                else {
                    cell = closest(currentTarget, (el) => {
                        if (!matchesNodeName('td')(el)) {
                            return false;
                        }
                        const parentRow = el.parentElement;
                        if (!parentRow || !matchesNodeName('tr')(parentRow)) {
                            return false;
                        }
                        return parentRow.parentElement === element;
                    });
                    if (cell) {
                        row = cell.parentElement;
                        body = element;
                        gridElement = null;
                    }
                }
            }
            if (!cell) {
                return;
            }
            this.editService.preventCellClose();
            const focusable = (!isCellTarget && target !== cell) && isFocusableWithTabKey(target, false);
            const ignoreContainer = isCellTarget ? true : !closestInScope(target, matchesClasses(IGNORE_CONTAINER_CLASSES), cell);
            if (!focusable && !matchesNodeName('label')(target) && !hasClasses(target, IGNORE_TARGET_CLASSSES) && ignoreContainer) {
                const args = this.cellClickArgs(cell, row, eventArg);
                if (!args) {
                    return;
                }
                if (selectionEnabled && !this.isRowSelectable({ index: args.rowIndex, dataItem: args.dataItem })) {
                    return;
                }
                if (eventArg.type === 'mousedown' || eventArg.type === 'touchstart') {
                    this.domEvents.cellMousedown.emit(args);
                }
                else if (eventArg.type === 'mouseup' || eventArg.type === 'touchend') {
                    this.domEvents.cellMouseup.emit(args);
                }
                else {
                    if (args.isEditedColumn || !this.editService.closeCell(eventArg)) {
                        if (eventArg.type === 'click') {
                            this.clickTimeout = setTimeout(() => {
                                this.emitCellClick(args);
                            }, 0);
                        }
                        else {
                            this.emitCellClick(args);
                        }
                    }
                }
            }
        }
    }
    emitCellClick(args) {
        this.domEvents.cellClick.emit(Object.assign(args, {
            isEdited: args.isEditedRow || args.isEditedColumn
        }));
    }
    cellKeydownHandler(args) {
        if (args.code === Keys.Enter || args.code === Keys.NumpadEnter || args.code === Keys.Space || (this.navigationService.tableCellEntered && args.code === Keys.F2)) {
            this.clickHandler(args);
        }
    }
    cellClickArgs(cell, row, eventArg) {
        const cells = this.isStackedMode ? row.querySelectorAll('.k-grid-stack-cell') : row.cells;
        let index = columnCellIndex(cell, cells, this.isStackedMode);
        // In stacked mode, clicks on the outer cell should not trigger Grid's cellClick event
        let isOuterCellClicked = false;
        if (this.isStackedMode && !isPresent(index)) {
            const cells = row.cells;
            index = columnCellIndex(cell, cells, this.isStackedMode);
            isOuterCellClicked = true;
        }
        if (!isPresent(index)) {
            return;
        }
        const column = this.columns.toArray()[index];
        const columnIndex = (this.isStackedMode ? 0 : this.lockedColumnsCount) + index;
        let rowIndex = (this.isStackedMode && !isOuterCellClicked ? row.parentElement.parentElement : row).getAttribute('data-kendo-grid-item-index');
        rowIndex = rowIndex ? parseInt(rowIndex, 10) : -1;
        const dataItem = rowIndex === -1 ? this.editService.newDataItem : this.rowsToRender.find(item => +item.index === rowIndex && item.type === 'data')?.data;
        const isEditedColumn = this.editService.isEditedColumn(rowIndex, column);
        const isEditedRow = this.editService.isEdited(rowIndex);
        const type = eventArg.type === 'keydown' ? 'click' : eventArg.type;
        return {
            column: isOuterCellClicked ? null : column,
            columnIndex: columnIndex,
            dataItem: dataItem,
            isEditedColumn: isEditedColumn,
            isEditedRow: isEditedRow,
            originalEvent: eventArg,
            rowIndex: rowIndex,
            type: type
        };
    }
    eventTarget(args) {
        if (!isDocumentAvailable()) {
            return;
        }
        if (args.type === 'touchend') {
            const touch = args.changedTouches[0];
            return document.elementFromPoint(touch.clientX, touch.clientY);
        }
        return args.target;
    }
    applyStickyRowsStyling() {
        if (!isDocumentAvailable()) {
            return;
        }
        const stickyRows = nodesToArray(this.element.nativeElement.querySelectorAll('.k-grid-row-sticky'));
        const length = stickyRows.length;
        if (length) {
            let accumulatedHeight = 0;
            const stickyRowsOffsets = [];
            stickyRows.forEach(row => {
                const rowHeight = row.getBoundingClientRect().height;
                stickyRowsOffsets.push({ accumulatedHeight, rowHeight });
                accumulatedHeight += rowHeight;
            });
            stickyRows.forEach((row, index) => {
                this.renderer.setStyle(row, 'top', `${stickyRowsOffsets[index].accumulatedHeight}px`);
                this.renderer.setStyle(row, 'bottom', `${accumulatedHeight - stickyRowsOffsets[index].accumulatedHeight - stickyRowsOffsets[index].rowHeight}px`);
            });
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TableBodyComponent, deps: [{ token: DetailsService }, { token: GroupsService }, { token: ChangeNotificationService }, { token: EditService }, { token: ContextService }, { token: i0.NgZone }, { token: i0.Renderer2 }, { token: i0.ElementRef }, { token: DomEventsService }, { token: SelectionService }, { token: CellSelectionService }, { token: ColumnInfoService }, { token: NavigationService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: TableBodyComponent, isStandalone: true, selector: "[kendoGridTableBody]", inputs: { columns: "columns", allColumns: "allColumns", groups: "groups", detailTemplate: "detailTemplate", noRecordsTemplate: "noRecordsTemplate", rowsToRender: "rowsToRender", skip: "skip", selectable: "selectable", filterable: "filterable", noRecordsText: "noRecordsText", isLocked: "isLocked", isLoading: "isLoading", isVirtual: "isVirtual", cellLoadingTemplate: "cellLoadingTemplate", skipGroupDecoration: "skipGroupDecoration", lockedColumnsCount: "lockedColumnsCount", totalColumnsCount: "totalColumnsCount", virtualColumns: "virtualColumns", trackBy: "trackBy", rowSticky: "rowSticky", totalColumns: "totalColumns", rowClass: "rowClass", rowHeight: "rowHeight", detailRowHeight: "detailRowHeight" }, host: { properties: { "class.k-table-tbody": "this.hostClass" } }, usesOnChanges: true, ngImport: i0, template: `
    @if (editService.hasNewItem) {
        <tr class="k-grid-add-row k-grid-edit-row k-master-row"
            [style.height.px]="rowHeight"
            kendoGridLogicalRow
                [logicalRowIndex]="addRowLogicalIndex()"
                [logicalSlaveRow]="lockedColumnsCount > 0 && !isStackedMode"
                [logicalCellsCount]="columns.length"
                [logicalSlaveCellsCount]="unlockedColumnsCount()"
                [totalColumns]="totalColumns">
            @if (!skipGroupDecoration) {
                @for (g of groups; track $index) {
                    <td class="k-group-cell k-table-td k-table-group-td" role="presentation"></td>
                }
            }
            @if (detailTemplate?.templateRef && !isStackedMode) {
                <td class="k-hierarchy-cell k-table-td"
                    kendoGridLogicalCell
                        [logicalRowIndex]="addRowLogicalIndex()"
                        [logicalColIndex]="0"
                        aria-selected="false"
                    >
                </td>
            }
            @if (isStackedMode) {
                @for (item of rowsToRender; track trackByWrapper($index, item); let rowIndex = $index) {
                    <td
                        class="k-table-td"
                        kendoGridCell
                            [rowIndex]="-1"
                            [columnIndex]="0"
                            [isNew]="true"
                            [columns]="allColumns"
                            [dataItem]="newDataItem"
                        kendoGridLogicalCell
                            [logicalRowIndex]="addRowLogicalIndex()"
                            [logicalColIndex]="0">
                    </td>
                }
            } @else {
                @for (column of columns; track virtualColumns ? $index : column; let columnIndex = $index) {
                    <td
                        class="k-table-td"
                        kendoGridCell
                            [rowIndex]="-1"
                            [columnIndex]="lockedColumnsCount + columnIndex"
                            [isNew]="true"
                            [column]="column"
                            [dataItem]="newDataItem"
                        [class.k-grid-content-sticky]="column.sticky"
                        [ngClass]="column.cssClass"
                        [style.left]="column.sticky ? '0' : undefined"
                        [ngStyle]="column.sticky ? addStickyColumnStyles(column) : column.style"
                        [attr.colspan]="column.colspan"
                        [attr.role]="column.tableCellsRole"
                        kendoGridLogicalCell
                            [logicalRowIndex]="addRowLogicalIndex()"
                            [logicalColIndex]="logicalColIndex(column)"
                            [colSpan]="column.colspan">
                    </td>
                }
            }
        </tr>
    }
    @if (!rowsToRender?.length) {
        <tr class="k-grid-norecords" role="row">
            <td [attr.colspan]="colSpan" class="k-table-td">
                @if (noRecordsTemplate?.templateRef) {
                    <ng-template
                        [templateContext]="{
                            templateRef: noRecordsTemplate?.templateRef
                         }">
                    </ng-template>
                } @else {
                    {{noRecordsText}}
                }
            </td>
        </tr>
    }
    @for (item of rowsToRender; track trackByWrapper($index, item); let rowIndex = $index) {
        @if (item.type === 'group') {
            <tr
                [style.height.px]="rowHeight"
                kendoGridGroupHeader
                    [columns]="columns"
                    [groups]="groups"
                    [item]="$any(item)"
                    [hasDetails]="!!detailTemplate?.templateRef"
                    [skipGroupDecoration]="skipGroupDecoration"
                    [hasGroupHeaderColumn]="hasGroupHeaderColumn"
                    [groupHeaderColumns]="groupHeaderColumns"
                    [rowIndex]="rowIndex + 1"
                    [totalColumnsCount]="totalColumnsCount"
                kendoGridLogicalRow
                    [logicalRowIndex]="logicalRowIndex(rowIndex)"
                    [logicalSlaveRow]="lockedColumnsCount > 0 && !isStackedMode"
                    [totalColumns]="totalColumns"
                    [logicalCellsCount]="columns.length"
                    [logicalSlaveCellsCount]="groupHeaderSlaveCellsCount">
            </tr>
        }
        @if (item.showDataItem) {
            <tr
                [style.height.px]="rowHeight"
                kendoGridLogicalRow
                    [dataRowIndex]="$any(item).index"
                    [dataItem]="item.data"
                    [logicalRowIndex]="logicalRowIndex(rowIndex)"
                    [logicalSlaveRow]="lockedColumnsCount > 0 && !isStackedMode"
                    [totalColumns]="totalColumns"
                    [logicalCellsCount]="columns.length"
                    [logicalSlaveCellsCount]="unlockedColumnsCount(item)"
                class="{{ isOdd(item) ?  'k-table-alt-row' : ''}}"
                [class.k-grid-row-sticky]="rowSticky ? rowSticky({ dataItem: item.data, index: $any(item).index }) : false"
                [ngClass]="rowClass({ dataItem: item.data, index: $any(item).index })"
                [class.k-master-row]="true"
                [class.k-expanded]="item.isExpanded && !isStackedMode"
                [class.k-grid-edit-row]="isEditingRow($any(item).index)"
                [attr.aria-selected]="(lockedColumnsCount < 1 || isStackedMode) ? isSelectable({ dataItem: item.data, index: $any(item).index }) && isRowSelected(item) : undefined"
                [attr.data-kendo-grid-item-index]="$any(item).index"
                [class.k-selected]="isSelectable({ dataItem: item.data, index: $any(item).index }) && isRowSelected(item)"
                [class.k-highlighted]="item.isHighlighted">
                @if (!skipGroupDecoration) {
                    @for (g of groups; track $index) {
                        <td class="k-group-cell k-table-td k-table-group-td" role="presentation"></td>
                    }
                }
                @if (detailTemplate?.templateRef && !isStackedMode) {
                    <td class="k-hierarchy-cell k-table-td"
                        kendoGridLogicalCell
                            [logicalRowIndex]="logicalRowIndex(rowIndex)"
                            [logicalColIndex]="0"
                            [dataRowIndex]="$any(item).index"
                            [dataItem]="item.data"
                            [detailExpandCell]="true"
                            aria-selected="false"
                            role="gridcell"
                            [attr.aria-expanded]="item.isExpanded">
                        @if (detailTemplate.showIf(item.data, $any(item).index)) {
                            <a
                                [attr.title]="detailButtonTitle(item)"
                                [attr.aria-label]="detailButtonTitle(item)"
                                href="#" tabindex="-1" (click)="toggleRow($any(item).index, item.data)">
                                <kendo-icon-wrapper
                                    [name]="detailButtonIconName(item)"
                                    [svgIcon]="detailButtonSvgIcon(item)"></kendo-icon-wrapper>
                            </a>
                        }
                    </td>
                }
                @if (isStackedMode) {
                    <td kendoGridCell
                        [rowIndex]="$any(item).index"
                        [detailTemplate]="detailTemplate"
                        [item]="item"
                        [columnIndex]="0"
                        [attr.data-kendo-grid-column-index]="0"
                        [columns]="columns"
                        [dataItem]="item.data"
                        [isLoading]="isLoading"
                        [isVirtual]="isVirtual"
                        [loadingTemplate]="cellLoadingTemplate"
                        kendoGridLogicalCell
                        [logicalRowIndex]="logicalRowIndex(rowIndex)"
                        [logicalColIndex]="0"
                        [dataRowIndex]="$any(item).index"
                        [dataItem]="item.data"
                        [colIndex]="0"
                        class="k-table-td"
                        [class.k-touch-action-none]="isSelectable({ dataItem: item.data, index: $any(item).index }) && $any(selectable).drag">
                    </td>
                } @else {
                    @for (column of columns; track virtualColumns ? $index : column; let columnIndex = $index) {
                        @if (!item.cells?.[lockedColumnsCount + columnIndex]?.skip) {
                            <td
                                kendoGridCell
                                [rowIndex]="$any(item).index"
                                [columnIndex]="lockedColumnsCount + columnIndex"
                                [attr.data-kendo-grid-column-index]="lockedColumnsCount + columnIndex"
                                [column]="column"
                                [columns]="allColumns"
                                [dataItem]="item.data"
                                [isLoading]="isLoading"
                                [isVirtual]="isVirtual"
                                [loadingTemplate]="cellLoadingTemplate"
                                kendoGridLogicalCell
                                [logicalRowIndex]="logicalRowIndex(rowIndex)"
                                [logicalColIndex]="logicalColIndex(column)"
                                [dataRowIndex]="$any(item).index"
                                [dataItem]="item.data"
                                [colIndex]="columnIndex"
                                [colSpan]="column.colspan"
                                [rowSpan]="item.cells[lockedColumnsCount + columnIndex]?.rowspan"
                                [attr.role]="column.tableCellsRole"
                                class="k-table-td"
                                [attr.aria-selected]="lockedColumnsCount < 1 && isSelectable({ dataItem: item.data, index: $any(item).index }) ? isAriaSelected(item, column) : undefined"
                                [class.k-grid-content-sticky]="column.sticky"
                                [class.k-touch-action-none]="isSelectable({ dataItem: item.data, index: $any(item).index }) && $any(selectable).drag"
                                [ngClass]="column.cssClass"
                                [class.k-grid-edit-cell]="isEditingCell($any(item).index, column)"
                                [ngStyle]="column.sticky ? addStickyColumnStyles(column) : column.style"
                                [attr.colspan]="column.colspan"
                                [class.k-selected]="isSelectable && cellSelectionService.isCellSelected(item, column)"
                                [class.k-highlighted]="item.cells[lockedColumnsCount + columnIndex]?.isHighlighted">
                            </td>
                        }
                    }
                }
            </tr>
        }
        @if (item.showDetailRow) {
            <tr
                class="k-detail-row"
                [style.height.px]="detailRowHeight"
                kendoGridLogicalRow
                    [dataRowIndex]="$any(item).index"
                    [dataItem]="item.data"
                    [logicalRowIndex]="isStackedMode ? logicalRowIndex(rowIndex) : logicalRowIndex(rowIndex) + 1"
                    [logicalSlaveRow]="false"
                    [logicalCellsCount]="1">
                @if (!isStackedMode) {
                    @for (g of groups; track $index) {
                        <td class="k-group-cell k-table-td k-table-group-td"></td>
                    }
                    <td class="k-hierarchy-cell k-table-td"></td>
                    <td class="k-detail-cell k-table-td"
                        [attr.colspan]="columnsSpan"
                        kendoGridLogicalCell
                            [logicalRowIndex]="logicalRowIndex(rowIndex) + 1"
                            [logicalColIndex]="0"
                            [dataRowIndex]="$any(item).index"
                            [dataItem]="item.data"
                            [colIndex]="0"
                            [colSpan]="allColumnsSpan + 1"
                            role="gridcell" aria-selected="false">
                        <ng-template
                            [ngTemplateOutlet]="detailTemplate.templateRef"
                            [ngTemplateOutletContext]="{
                                dataItem: item.data,
                                rowIndex: $any(item).index,
                                $implicit: item.data
                            }">
                        </ng-template>
                    </td>
                } @else {
                    <td class="k-detail-cell k-table-td"
                        [attr.colspan]="columnsSpan"
                        kendoGridLogicalCell
                            [logicalRowIndex]="logicalRowIndex(rowIndex)"
                            [logicalColIndex]="0"
                            [dataRowIndex]="$any(item).index"
                            [dataItem]="item.data"
                            [colIndex]="0"
                            [colSpan]="allColumnsSpan + 1"
                            role="gridcell"
                            aria-selected="false">
                        <ng-template
                            [ngTemplateOutlet]="detailTemplate.templateRef"
                            [ngTemplateOutletContext]="{
                                dataItem: item.data,
                                rowIndex: $any(item).index,
                                $implicit: item.data
                            }">
                        </ng-template>
                    </td>
                }
            </tr>
        }
        @if (item.type === 'footer') {
            <tr
                class="k-group-footer"
                [style.height.px]="rowHeight"
                kendoGridLogicalRow
                    [logicalRowIndex]="logicalRowIndex(rowIndex)"
                    [logicalSlaveRow]="lockedColumnsCount > 0 && !isStackedMode"
                    [totalColumns]="totalColumns"
                    [logicalCellsCount]="columns.length"
                    [logicalSlaveCellsCount]="unlockedColumnsCount(item)">
                @if (!skipGroupDecoration) {
                    @for (g of groups; track $index) {
                        <td class="k-group-cell k-table-td k-table-group-td"></td>
                    }
                }
                @if (detailTemplate?.templateRef && !isStackedMode) {
                    <td class="k-hierarchy-cell k-table-td"
                        kendoGridLogicalCell
                            [logicalRowIndex]="logicalRowIndex(rowIndex)"
                            [logicalColIndex]="0"
                            aria-selected="false">
                    </td>
                }

                @if (!isStackedMode) {
                    @for (column of footerColumns; track virtualColumns ? $index : column; let columnIndex = $index) {
                        <td kendoGridLogicalCell
                                [logicalRowIndex]="logicalRowIndex(rowIndex)"
                                [logicalColIndex]="logicalColIndex(column)"
                            [attr.data-skip]="skipGroupDecoration"
                            class="k-table-td">
                            <ng-template
                                [templateContext]="{
                                    templateRef: $any(column).groupFooterTemplateRef,
                                    group: $any(item.data),
                                    field: $any(column).field,
                                    column: column,
                                    aggregates: $any(item.data)?.aggregates,
                                    $implicit: $any(item.data)?.aggregates
                                }">
                            </ng-template>
                       </td>
                    }
                } @else {
                    <td kendoGridLogicalCell
                        [logicalRowIndex]="logicalRowIndex(rowIndex)"
                        [logicalColIndex]="hasDetailTemplate ? 1 : 0"
                        [attr.data-skip]="skipGroupDecoration"
                        class="k-table-td">
                        <div class="k-grid-column-template">
                            @for (col of footerColumns; track $index) {
                                @if ($any(col).groupFooterTemplateRef) {
                                    <div class="k-column-template-item">
                                        <ng-template
                                            [templateContext]="{
                                                templateRef: $any(col).groupFooterTemplateRef,
                                                group: $any(item.data),
                                                field: $any(col).field,
                                                column: col,
                                                aggregates: $any(item.data)?.aggregates,
                                                $implicit: $any(item.data)?.aggregates
                                            }">
                                        </ng-template>
                                    </div>
                                }
                            }
                        </div>
                    </td>
                }
            </tr>
        }
    }
    @if (rowSticky) {
        <kendo-resize-sensor (resize)="resizeHandler()"></kendo-resize-sensor>
    }
    `, isInline: true, dependencies: [{ kind: "directive", type: LogicalRowDirective, selector: "[kendoGridLogicalRow]", inputs: ["logicalRowIndex", "logicalSlaveRow", "logicalCellsCount", "logicalSlaveCellsCount", "dataRowIndex", "dataItem", "totalColumns"] }, { kind: "directive", type: LogicalCellDirective, selector: "[kendoGridLogicalCell]", inputs: ["logicalColIndex", "logicalRowIndex", "logicalSlaveCell", "colIndex", "colSpan", "rowSpan", "groupItem", "dataRowIndex", "dataItem", "detailExpandCell", "headerLabelText"] }, { kind: "component", type: CellComponent, selector: "[kendoGridCell]", inputs: ["column", "columns", "columnIndex", "isNew", "isLoading", "isVirtual", "loadingTemplate", "detailTemplate", "item", "rowIndex", "dataItem"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "directive", type: TemplateContextDirective, selector: "[templateContext]", inputs: ["templateContext"] }, { kind: "component", type: GroupHeaderComponent, selector: "[kendoGridGroupHeader]", inputs: ["rowIndex", "logicalRowIndex", "item", "skipGroupDecoration", "hasDetails", "totalColumnsCount", "hasGroupHeaderColumn", "groupHeaderColumns", "columns", "groups"] }, { kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: ResizeSensorComponent, selector: "kendo-resize-sensor", inputs: ["rateLimit"], outputs: ["resize"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TableBodyComponent, decorators: [{
            type: Component,
            args: [{
                    selector: '[kendoGridTableBody]',
                    template: `
    @if (editService.hasNewItem) {
        <tr class="k-grid-add-row k-grid-edit-row k-master-row"
            [style.height.px]="rowHeight"
            kendoGridLogicalRow
                [logicalRowIndex]="addRowLogicalIndex()"
                [logicalSlaveRow]="lockedColumnsCount > 0 && !isStackedMode"
                [logicalCellsCount]="columns.length"
                [logicalSlaveCellsCount]="unlockedColumnsCount()"
                [totalColumns]="totalColumns">
            @if (!skipGroupDecoration) {
                @for (g of groups; track $index) {
                    <td class="k-group-cell k-table-td k-table-group-td" role="presentation"></td>
                }
            }
            @if (detailTemplate?.templateRef && !isStackedMode) {
                <td class="k-hierarchy-cell k-table-td"
                    kendoGridLogicalCell
                        [logicalRowIndex]="addRowLogicalIndex()"
                        [logicalColIndex]="0"
                        aria-selected="false"
                    >
                </td>
            }
            @if (isStackedMode) {
                @for (item of rowsToRender; track trackByWrapper($index, item); let rowIndex = $index) {
                    <td
                        class="k-table-td"
                        kendoGridCell
                            [rowIndex]="-1"
                            [columnIndex]="0"
                            [isNew]="true"
                            [columns]="allColumns"
                            [dataItem]="newDataItem"
                        kendoGridLogicalCell
                            [logicalRowIndex]="addRowLogicalIndex()"
                            [logicalColIndex]="0">
                    </td>
                }
            } @else {
                @for (column of columns; track virtualColumns ? $index : column; let columnIndex = $index) {
                    <td
                        class="k-table-td"
                        kendoGridCell
                            [rowIndex]="-1"
                            [columnIndex]="lockedColumnsCount + columnIndex"
                            [isNew]="true"
                            [column]="column"
                            [dataItem]="newDataItem"
                        [class.k-grid-content-sticky]="column.sticky"
                        [ngClass]="column.cssClass"
                        [style.left]="column.sticky ? '0' : undefined"
                        [ngStyle]="column.sticky ? addStickyColumnStyles(column) : column.style"
                        [attr.colspan]="column.colspan"
                        [attr.role]="column.tableCellsRole"
                        kendoGridLogicalCell
                            [logicalRowIndex]="addRowLogicalIndex()"
                            [logicalColIndex]="logicalColIndex(column)"
                            [colSpan]="column.colspan">
                    </td>
                }
            }
        </tr>
    }
    @if (!rowsToRender?.length) {
        <tr class="k-grid-norecords" role="row">
            <td [attr.colspan]="colSpan" class="k-table-td">
                @if (noRecordsTemplate?.templateRef) {
                    <ng-template
                        [templateContext]="{
                            templateRef: noRecordsTemplate?.templateRef
                         }">
                    </ng-template>
                } @else {
                    {{noRecordsText}}
                }
            </td>
        </tr>
    }
    @for (item of rowsToRender; track trackByWrapper($index, item); let rowIndex = $index) {
        @if (item.type === 'group') {
            <tr
                [style.height.px]="rowHeight"
                kendoGridGroupHeader
                    [columns]="columns"
                    [groups]="groups"
                    [item]="$any(item)"
                    [hasDetails]="!!detailTemplate?.templateRef"
                    [skipGroupDecoration]="skipGroupDecoration"
                    [hasGroupHeaderColumn]="hasGroupHeaderColumn"
                    [groupHeaderColumns]="groupHeaderColumns"
                    [rowIndex]="rowIndex + 1"
                    [totalColumnsCount]="totalColumnsCount"
                kendoGridLogicalRow
                    [logicalRowIndex]="logicalRowIndex(rowIndex)"
                    [logicalSlaveRow]="lockedColumnsCount > 0 && !isStackedMode"
                    [totalColumns]="totalColumns"
                    [logicalCellsCount]="columns.length"
                    [logicalSlaveCellsCount]="groupHeaderSlaveCellsCount">
            </tr>
        }
        @if (item.showDataItem) {
            <tr
                [style.height.px]="rowHeight"
                kendoGridLogicalRow
                    [dataRowIndex]="$any(item).index"
                    [dataItem]="item.data"
                    [logicalRowIndex]="logicalRowIndex(rowIndex)"
                    [logicalSlaveRow]="lockedColumnsCount > 0 && !isStackedMode"
                    [totalColumns]="totalColumns"
                    [logicalCellsCount]="columns.length"
                    [logicalSlaveCellsCount]="unlockedColumnsCount(item)"
                class="{{ isOdd(item) ?  'k-table-alt-row' : ''}}"
                [class.k-grid-row-sticky]="rowSticky ? rowSticky({ dataItem: item.data, index: $any(item).index }) : false"
                [ngClass]="rowClass({ dataItem: item.data, index: $any(item).index })"
                [class.k-master-row]="true"
                [class.k-expanded]="item.isExpanded && !isStackedMode"
                [class.k-grid-edit-row]="isEditingRow($any(item).index)"
                [attr.aria-selected]="(lockedColumnsCount < 1 || isStackedMode) ? isSelectable({ dataItem: item.data, index: $any(item).index }) && isRowSelected(item) : undefined"
                [attr.data-kendo-grid-item-index]="$any(item).index"
                [class.k-selected]="isSelectable({ dataItem: item.data, index: $any(item).index }) && isRowSelected(item)"
                [class.k-highlighted]="item.isHighlighted">
                @if (!skipGroupDecoration) {
                    @for (g of groups; track $index) {
                        <td class="k-group-cell k-table-td k-table-group-td" role="presentation"></td>
                    }
                }
                @if (detailTemplate?.templateRef && !isStackedMode) {
                    <td class="k-hierarchy-cell k-table-td"
                        kendoGridLogicalCell
                            [logicalRowIndex]="logicalRowIndex(rowIndex)"
                            [logicalColIndex]="0"
                            [dataRowIndex]="$any(item).index"
                            [dataItem]="item.data"
                            [detailExpandCell]="true"
                            aria-selected="false"
                            role="gridcell"
                            [attr.aria-expanded]="item.isExpanded">
                        @if (detailTemplate.showIf(item.data, $any(item).index)) {
                            <a
                                [attr.title]="detailButtonTitle(item)"
                                [attr.aria-label]="detailButtonTitle(item)"
                                href="#" tabindex="-1" (click)="toggleRow($any(item).index, item.data)">
                                <kendo-icon-wrapper
                                    [name]="detailButtonIconName(item)"
                                    [svgIcon]="detailButtonSvgIcon(item)"></kendo-icon-wrapper>
                            </a>
                        }
                    </td>
                }
                @if (isStackedMode) {
                    <td kendoGridCell
                        [rowIndex]="$any(item).index"
                        [detailTemplate]="detailTemplate"
                        [item]="item"
                        [columnIndex]="0"
                        [attr.data-kendo-grid-column-index]="0"
                        [columns]="columns"
                        [dataItem]="item.data"
                        [isLoading]="isLoading"
                        [isVirtual]="isVirtual"
                        [loadingTemplate]="cellLoadingTemplate"
                        kendoGridLogicalCell
                        [logicalRowIndex]="logicalRowIndex(rowIndex)"
                        [logicalColIndex]="0"
                        [dataRowIndex]="$any(item).index"
                        [dataItem]="item.data"
                        [colIndex]="0"
                        class="k-table-td"
                        [class.k-touch-action-none]="isSelectable({ dataItem: item.data, index: $any(item).index }) && $any(selectable).drag">
                    </td>
                } @else {
                    @for (column of columns; track virtualColumns ? $index : column; let columnIndex = $index) {
                        @if (!item.cells?.[lockedColumnsCount + columnIndex]?.skip) {
                            <td
                                kendoGridCell
                                [rowIndex]="$any(item).index"
                                [columnIndex]="lockedColumnsCount + columnIndex"
                                [attr.data-kendo-grid-column-index]="lockedColumnsCount + columnIndex"
                                [column]="column"
                                [columns]="allColumns"
                                [dataItem]="item.data"
                                [isLoading]="isLoading"
                                [isVirtual]="isVirtual"
                                [loadingTemplate]="cellLoadingTemplate"
                                kendoGridLogicalCell
                                [logicalRowIndex]="logicalRowIndex(rowIndex)"
                                [logicalColIndex]="logicalColIndex(column)"
                                [dataRowIndex]="$any(item).index"
                                [dataItem]="item.data"
                                [colIndex]="columnIndex"
                                [colSpan]="column.colspan"
                                [rowSpan]="item.cells[lockedColumnsCount + columnIndex]?.rowspan"
                                [attr.role]="column.tableCellsRole"
                                class="k-table-td"
                                [attr.aria-selected]="lockedColumnsCount < 1 && isSelectable({ dataItem: item.data, index: $any(item).index }) ? isAriaSelected(item, column) : undefined"
                                [class.k-grid-content-sticky]="column.sticky"
                                [class.k-touch-action-none]="isSelectable({ dataItem: item.data, index: $any(item).index }) && $any(selectable).drag"
                                [ngClass]="column.cssClass"
                                [class.k-grid-edit-cell]="isEditingCell($any(item).index, column)"
                                [ngStyle]="column.sticky ? addStickyColumnStyles(column) : column.style"
                                [attr.colspan]="column.colspan"
                                [class.k-selected]="isSelectable && cellSelectionService.isCellSelected(item, column)"
                                [class.k-highlighted]="item.cells[lockedColumnsCount + columnIndex]?.isHighlighted">
                            </td>
                        }
                    }
                }
            </tr>
        }
        @if (item.showDetailRow) {
            <tr
                class="k-detail-row"
                [style.height.px]="detailRowHeight"
                kendoGridLogicalRow
                    [dataRowIndex]="$any(item).index"
                    [dataItem]="item.data"
                    [logicalRowIndex]="isStackedMode ? logicalRowIndex(rowIndex) : logicalRowIndex(rowIndex) + 1"
                    [logicalSlaveRow]="false"
                    [logicalCellsCount]="1">
                @if (!isStackedMode) {
                    @for (g of groups; track $index) {
                        <td class="k-group-cell k-table-td k-table-group-td"></td>
                    }
                    <td class="k-hierarchy-cell k-table-td"></td>
                    <td class="k-detail-cell k-table-td"
                        [attr.colspan]="columnsSpan"
                        kendoGridLogicalCell
                            [logicalRowIndex]="logicalRowIndex(rowIndex) + 1"
                            [logicalColIndex]="0"
                            [dataRowIndex]="$any(item).index"
                            [dataItem]="item.data"
                            [colIndex]="0"
                            [colSpan]="allColumnsSpan + 1"
                            role="gridcell" aria-selected="false">
                        <ng-template
                            [ngTemplateOutlet]="detailTemplate.templateRef"
                            [ngTemplateOutletContext]="{
                                dataItem: item.data,
                                rowIndex: $any(item).index,
                                $implicit: item.data
                            }">
                        </ng-template>
                    </td>
                } @else {
                    <td class="k-detail-cell k-table-td"
                        [attr.colspan]="columnsSpan"
                        kendoGridLogicalCell
                            [logicalRowIndex]="logicalRowIndex(rowIndex)"
                            [logicalColIndex]="0"
                            [dataRowIndex]="$any(item).index"
                            [dataItem]="item.data"
                            [colIndex]="0"
                            [colSpan]="allColumnsSpan + 1"
                            role="gridcell"
                            aria-selected="false">
                        <ng-template
                            [ngTemplateOutlet]="detailTemplate.templateRef"
                            [ngTemplateOutletContext]="{
                                dataItem: item.data,
                                rowIndex: $any(item).index,
                                $implicit: item.data
                            }">
                        </ng-template>
                    </td>
                }
            </tr>
        }
        @if (item.type === 'footer') {
            <tr
                class="k-group-footer"
                [style.height.px]="rowHeight"
                kendoGridLogicalRow
                    [logicalRowIndex]="logicalRowIndex(rowIndex)"
                    [logicalSlaveRow]="lockedColumnsCount > 0 && !isStackedMode"
                    [totalColumns]="totalColumns"
                    [logicalCellsCount]="columns.length"
                    [logicalSlaveCellsCount]="unlockedColumnsCount(item)">
                @if (!skipGroupDecoration) {
                    @for (g of groups; track $index) {
                        <td class="k-group-cell k-table-td k-table-group-td"></td>
                    }
                }
                @if (detailTemplate?.templateRef && !isStackedMode) {
                    <td class="k-hierarchy-cell k-table-td"
                        kendoGridLogicalCell
                            [logicalRowIndex]="logicalRowIndex(rowIndex)"
                            [logicalColIndex]="0"
                            aria-selected="false">
                    </td>
                }

                @if (!isStackedMode) {
                    @for (column of footerColumns; track virtualColumns ? $index : column; let columnIndex = $index) {
                        <td kendoGridLogicalCell
                                [logicalRowIndex]="logicalRowIndex(rowIndex)"
                                [logicalColIndex]="logicalColIndex(column)"
                            [attr.data-skip]="skipGroupDecoration"
                            class="k-table-td">
                            <ng-template
                                [templateContext]="{
                                    templateRef: $any(column).groupFooterTemplateRef,
                                    group: $any(item.data),
                                    field: $any(column).field,
                                    column: column,
                                    aggregates: $any(item.data)?.aggregates,
                                    $implicit: $any(item.data)?.aggregates
                                }">
                            </ng-template>
                       </td>
                    }
                } @else {
                    <td kendoGridLogicalCell
                        [logicalRowIndex]="logicalRowIndex(rowIndex)"
                        [logicalColIndex]="hasDetailTemplate ? 1 : 0"
                        [attr.data-skip]="skipGroupDecoration"
                        class="k-table-td">
                        <div class="k-grid-column-template">
                            @for (col of footerColumns; track $index) {
                                @if ($any(col).groupFooterTemplateRef) {
                                    <div class="k-column-template-item">
                                        <ng-template
                                            [templateContext]="{
                                                templateRef: $any(col).groupFooterTemplateRef,
                                                group: $any(item.data),
                                                field: $any(col).field,
                                                column: col,
                                                aggregates: $any(item.data)?.aggregates,
                                                $implicit: $any(item.data)?.aggregates
                                            }">
                                        </ng-template>
                                    </div>
                                }
                            }
                        </div>
                    </td>
                }
            </tr>
        }
    }
    @if (rowSticky) {
        <kendo-resize-sensor (resize)="resizeHandler()"></kendo-resize-sensor>
    }
    `,
                    standalone: true,
                    imports: [
                        LogicalRowDirective, LogicalCellDirective, CellComponent, NgClass, NgStyle, TemplateContextDirective,
                        GroupHeaderComponent, IconWrapperComponent, NgTemplateOutlet, ResizeSensorComponent
                    ]
                }]
        }], ctorParameters: () => [{ type: DetailsService }, { type: GroupsService }, { type: ChangeNotificationService }, { type: EditService }, { type: ContextService }, { type: i0.NgZone }, { type: i0.Renderer2 }, { type: i0.ElementRef }, { type: DomEventsService }, { type: SelectionService }, { type: CellSelectionService }, { type: ColumnInfoService }, { type: NavigationService }], propDecorators: { columns: [{
                type: Input
            }], allColumns: [{
                type: Input
            }], groups: [{
                type: Input
            }], detailTemplate: [{
                type: Input
            }], noRecordsTemplate: [{
                type: Input
            }], rowsToRender: [{
                type: Input
            }], skip: [{
                type: Input
            }], selectable: [{
                type: Input
            }], filterable: [{
                type: Input
            }], noRecordsText: [{
                type: Input
            }], isLocked: [{
                type: Input
            }], isLoading: [{
                type: Input
            }], isVirtual: [{
                type: Input
            }], cellLoadingTemplate: [{
                type: Input
            }], skipGroupDecoration: [{
                type: Input
            }], lockedColumnsCount: [{
                type: Input
            }], totalColumnsCount: [{
                type: Input
            }], virtualColumns: [{
                type: Input
            }], trackBy: [{
                type: Input
            }], rowSticky: [{
                type: Input
            }], totalColumns: [{
                type: Input
            }], rowClass: [{
                type: Input
            }], rowHeight: [{
                type: Input
            }], detailRowHeight: [{
                type: Input
            }], hostClass: [{
                type: HostBinding,
                args: ['class.k-table-tbody']
            }] } });

/**
 * Represents the `edit` command of the Grid. You can apply this directive to any `button`
 * element inside a [CommandColumnComponent]({% slug api_grid_commandcolumncomponent %}).
 * When an associated button with the directive is clicked, the
 * [`edit`]({% slug api_grid_gridcomponent %}#toc-edit) event
 * is triggered ([see example]({% slug basics_editing_grid %})).
 *
 * When the row is in the `edit` mode, the button with `kendoGridEditCommand` is automatically hidden.
 *
 * @example
 * ```html
 * <kendo-grid>
 *   <kendo-grid-command-column title="command">
 *     <ng-template kendoGridCellTemplate>
 *       <button kendoGridEditCommand class="k-primary">Edit</button>
 *     </ng-template>
 *   </kendo-grid-command-column>
 * </kendo-grid>
 * ```
 *
 */
class EditCommandDirective extends Button {
    editService;
    cellContext;
    rowIndex;
    isEdited;
    /**
     * @hidden
     */
    get visible() {
        return this.isEdited ? 'none' : '';
    }
    /**
     * @hidden
     */
    commandClass = true;
    /**
     * @hidden
     */
    onClick(e) {
        e.preventDefault();
        this.editService.beginEdit(this.rowIndex);
    }
    constructor(editService, cellContext, element, renderer, ctx, ngZone) {
        super(element, renderer, null, ctx.localization, ngZone);
        this.editService = editService;
        this.cellContext = cellContext;
    }
    ngDoCheck() {
        if (this.cellContext) {
            this.rowIndex = this.cellContext.rowIndex;
            this.isEdited = this.editService.isEdited(this.rowIndex);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: EditCommandDirective, deps: [{ token: EditService }, { token: CELL_CONTEXT }, { token: i0.ElementRef }, { token: i0.Renderer2 }, { token: ContextService }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: EditCommandDirective, isStandalone: true, selector: "[kendoGridEditCommand]", host: { listeners: { "click": "onClick($event)" }, properties: { "style.display": "this.visible", "class.k-grid-edit-command": "this.commandClass" } }, usesInheritance: true, ngImport: i0, template: `
        @if (icon || svgIcon) {
          <kendo-icon-wrapper
            innerCssClass="k-button-icon"
            [name]="icon"
          [svgIcon]="svgIcon"></kendo-icon-wrapper>
        }
        @if (imageUrl) {
          <span class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
          </span>
        }
        @if (iconClass) {
          <span class="k-button-icon" [ngClass]="iconClass"></span>
        }
        <span class="k-button-text"><ng-content></ng-content></span>
        `, isInline: true, dependencies: [{ kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: EditCommandDirective, decorators: [{
            type: Component,
            args: [{
                    selector: '[kendoGridEditCommand]',
                    template: `
        @if (icon || svgIcon) {
          <kendo-icon-wrapper
            innerCssClass="k-button-icon"
            [name]="icon"
          [svgIcon]="svgIcon"></kendo-icon-wrapper>
        }
        @if (imageUrl) {
          <span class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
          </span>
        }
        @if (iconClass) {
          <span class="k-button-icon" [ngClass]="iconClass"></span>
        }
        <span class="k-button-text"><ng-content></ng-content></span>
        `,
                    standalone: true,
                    imports: [IconWrapperComponent, NgClass]
                }]
        }], ctorParameters: () => [{ type: EditService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [CELL_CONTEXT]
                }] }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: ContextService }, { type: i0.NgZone }], propDecorators: { visible: [{
                type: HostBinding,
                args: ['style.display']
            }], commandClass: [{
                type: HostBinding,
                args: ['class.k-grid-edit-command']
            }], onClick: [{
                type: HostListener,
                args: ['click', ['$event']]
            }] } });

/**
 * Represents the `cancel` command of the Grid. Apply this directive to any `button`
 * element inside a [CommandColumnComponent]({% slug api_grid_commandcolumncomponent %})
 * ([see example](slug:basics_editing_grid#editing-action-buttons)).
 *
 * When a button with this directive is clicked, the
 * [`cancel`]({% slug api_grid_gridcomponent %}#toc-cancel) event
 * is triggered. If the row is not in edit mode, the button is automatically hidden.
 *
 * You can customize the button content based on the row's state.
 *
 * @example
 * ```html
 * <kendo-grid>
 *   <kendo-grid-command-column title="command">
 *     <ng-template kendoGridCellTemplate let-isNew="isNew">
 *       <button kendoGridCancelCommand>{{isNew ? 'Discard' : 'Cancel changes'}}</button>
 *     </ng-template>
 *   </kendo-grid-command-column>
 * </kendo-grid>
 * ```
 */
class CancelCommandDirective extends Button {
    editService;
    cellContext;
    rowIndex;
    isEdited;
    /**
     * @hidden
     */
    get visible() {
        return !this.isEdited ? 'none' : '';
    }
    /**
     * @hidden
     */
    commandClass = true;
    /**
     * @hidden
     */
    onClick(e) {
        e.preventDefault();
        if (this.isEdited) {
            this.editService.endEdit(this.rowIndex);
        }
    }
    constructor(editService, cellContext, element, renderer, ctx, ngZone) {
        super(element, renderer, null, ctx.localization, ngZone);
        this.editService = editService;
        this.cellContext = cellContext;
    }
    ngDoCheck() {
        if (this.cellContext) {
            this.rowIndex = this.cellContext.rowIndex;
            this.isEdited = this.editService.isEdited(this.rowIndex);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CancelCommandDirective, deps: [{ token: EditService }, { token: CELL_CONTEXT }, { token: i0.ElementRef }, { token: i0.Renderer2 }, { token: ContextService }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: CancelCommandDirective, isStandalone: true, selector: "[kendoGridCancelCommand]", host: { listeners: { "click": "onClick($event)" }, properties: { "style.display": "this.visible", "class.k-grid-cancel-command": "this.commandClass" } }, usesInheritance: true, ngImport: i0, template: `
        @if (icon || svgIcon) {
          <kendo-icon-wrapper
            innerCssClass="k-button-icon"
            [name]="icon"
          [svgIcon]="svgIcon"></kendo-icon-wrapper>
        }
        @if (imageUrl) {
          <span class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
          </span>
        }
        @if (iconClass) {
          <span class="k-button-icon" [ngClass]="iconClass"></span>
        }
        <span class="k-button-text"><ng-content></ng-content></span>
        `, isInline: true, dependencies: [{ kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CancelCommandDirective, decorators: [{
            type: Component,
            args: [{
                    selector: '[kendoGridCancelCommand]',
                    template: `
        @if (icon || svgIcon) {
          <kendo-icon-wrapper
            innerCssClass="k-button-icon"
            [name]="icon"
          [svgIcon]="svgIcon"></kendo-icon-wrapper>
        }
        @if (imageUrl) {
          <span class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
          </span>
        }
        @if (iconClass) {
          <span class="k-button-icon" [ngClass]="iconClass"></span>
        }
        <span class="k-button-text"><ng-content></ng-content></span>
        `,
                    standalone: true,
                    imports: [IconWrapperComponent, NgClass]
                }]
        }], ctorParameters: () => [{ type: EditService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [CELL_CONTEXT]
                }] }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: ContextService }, { type: i0.NgZone }], propDecorators: { visible: [{
                type: HostBinding,
                args: ['style.display']
            }], commandClass: [{
                type: HostBinding,
                args: ['class.k-grid-cancel-command']
            }], onClick: [{
                type: HostListener,
                args: ['click', ['$event']]
            }] } });

/**
 * Represents the `save` command of the Grid. Apply this directive to any `button`
 * element inside a [CommandColumnComponent]({% slug api_grid_commandcolumncomponent %})
 * ([see example](slug:basics_editing_grid#editing-action-buttons)).
 * When you click the button with this directive, the
 * [`save`]({% slug api_grid_gridcomponent %}#toc-save) event fires.
 * The button with `kendoGridSaveCommand` is automatically hidden when the row is not in edit mode.
 *
 * You can change the button content based on the row state.
 *
 * @example
 * ```html
 * <kendo-grid>
 *   <kendo-grid-command-column title="command">
 *     <ng-template kendoGridCellTemplate let-isNew="isNew">
 *       <button kendoGridSaveCommand>{{isNew ? 'Add' : 'Update'}}</button>
 *     </ng-template>
 *   </kendo-grid-command-column>
 * </kendo-grid>
 * ```
 */
class SaveCommandDirective extends Button {
    editService;
    cellContext;
    rowIndex;
    isEdited;
    /**
     * @hidden
     */
    get visible() {
        return !this.isEdited ? 'none' : '';
    }
    /**
     * @hidden
     */
    commandClass = true;
    /**
     * @hidden
     */
    onClick(e) {
        e.preventDefault();
        if (this.isEdited) {
            this.editService.save(this.rowIndex);
        }
    }
    constructor(editService, cellContext, element, renderer, ctx, ngZone) {
        super(element, renderer, null, ctx.localization, ngZone);
        this.editService = editService;
        this.cellContext = cellContext;
    }
    ngDoCheck() {
        if (this.cellContext) {
            this.rowIndex = this.cellContext.rowIndex;
            this.isEdited = this.editService.isEdited(this.rowIndex);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SaveCommandDirective, deps: [{ token: EditService }, { token: CELL_CONTEXT }, { token: i0.ElementRef }, { token: i0.Renderer2 }, { token: ContextService }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: SaveCommandDirective, isStandalone: true, selector: "[kendoGridSaveCommand]", host: { listeners: { "click": "onClick($event)" }, properties: { "style.display": "this.visible", "class.k-grid-save-command": "this.commandClass" } }, usesInheritance: true, ngImport: i0, template: `
        @if (icon || svgIcon) {
          <kendo-icon-wrapper
            innerCssClass="k-button-icon"
            [name]="icon"
          [svgIcon]="svgIcon"></kendo-icon-wrapper>
        }
        @if (imageUrl) {
          <span class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
          </span>
        }
        @if (iconClass) {
          <span class="k-button-icon" [ngClass]="iconClass"></span>
        }
        <span class="k-button-text"><ng-content></ng-content></span>
        `, isInline: true, dependencies: [{ kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SaveCommandDirective, decorators: [{
            type: Component,
            args: [{
                    selector: '[kendoGridSaveCommand]',
                    template: `
        @if (icon || svgIcon) {
          <kendo-icon-wrapper
            innerCssClass="k-button-icon"
            [name]="icon"
          [svgIcon]="svgIcon"></kendo-icon-wrapper>
        }
        @if (imageUrl) {
          <span class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
          </span>
        }
        @if (iconClass) {
          <span class="k-button-icon" [ngClass]="iconClass"></span>
        }
        <span class="k-button-text"><ng-content></ng-content></span>
        `,
                    standalone: true,
                    imports: [IconWrapperComponent, NgClass]
                }]
        }], ctorParameters: () => [{ type: EditService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [CELL_CONTEXT]
                }] }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: ContextService }, { type: i0.NgZone }], propDecorators: { visible: [{
                type: HostBinding,
                args: ['style.display']
            }], commandClass: [{
                type: HostBinding,
                args: ['class.k-grid-save-command']
            }], onClick: [{
                type: HostListener,
                args: ['click', ['$event']]
            }] } });

/**
 * Represents the `remove` command of the Grid. Apply this directive to any `button` element
 * inside a [CommandColumnComponent]({% slug api_grid_commandcolumncomponent %})
 * ([see example](slug:basics_editing_grid#editing-action-buttons)).
 * When you click the button with this directive, the
 * [`remove`]({% slug api_grid_gridcomponent %}#toc-remove) event fires.
 * The button with `kendoGridRemoveCommand` is automatically hidden when the row is in edit mode.
 *
 * @example
 * ```html
 * <kendo-grid>
 *   <kendo-grid-command-column title="command">
 *     <ng-template kendoGridCellTemplate>
 *       <button kendoGridRemoveCommand>Remove row</button>
 *     </ng-template>
 *   </kendo-grid-command-column>
 * </kendo-grid>
 * ```
 */
class RemoveCommandDirective extends Button {
    editService;
    cellContext;
    rowIndex;
    isEdited;
    /**
     * @hidden
     */
    get visible() {
        return this.isEdited ? 'none' : '';
    }
    /**
     * @hidden
     */
    commandClass = true;
    /**
     * @hidden
     */
    onClick(e) {
        e.preventDefault();
        e.stopImmediatePropagation();
        this.editService.remove(this.rowIndex);
    }
    constructor(editService, cellContext, element, renderer, ctx, ngZone) {
        super(element, renderer, null, ctx.localization, ngZone);
        this.editService = editService;
        this.cellContext = cellContext;
    }
    ngDoCheck() {
        if (this.cellContext) {
            this.rowIndex = this.cellContext.rowIndex;
            this.isEdited = this.editService.isEdited(this.rowIndex);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: RemoveCommandDirective, deps: [{ token: EditService }, { token: CELL_CONTEXT }, { token: i0.ElementRef }, { token: i0.Renderer2 }, { token: ContextService }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: RemoveCommandDirective, isStandalone: true, selector: "[kendoGridRemoveCommand]", host: { listeners: { "click": "onClick($event)" }, properties: { "style.display": "this.visible", "class.k-grid-remove-command": "this.commandClass" } }, usesInheritance: true, ngImport: i0, template: `
        @if (icon || svgIcon) {
          <kendo-icon-wrapper
            innerCssClass="k-button-icon"
            [name]="icon"
          [svgIcon]="svgIcon"></kendo-icon-wrapper>
        }
        @if (imageUrl) {
          <span class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
          </span>
        }
        @if (iconClass) {
          <span class="k-button-icon" [ngClass]="iconClass"></span>
        }
        <span class="k-button-text"><ng-content></ng-content></span>
        `, isInline: true, dependencies: [{ kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: RemoveCommandDirective, decorators: [{
            type: Component,
            args: [{
                    selector: '[kendoGridRemoveCommand]',
                    template: `
        @if (icon || svgIcon) {
          <kendo-icon-wrapper
            innerCssClass="k-button-icon"
            [name]="icon"
          [svgIcon]="svgIcon"></kendo-icon-wrapper>
        }
        @if (imageUrl) {
          <span class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
          </span>
        }
        @if (iconClass) {
          <span class="k-button-icon" [ngClass]="iconClass"></span>
        }
        <span class="k-button-text"><ng-content></ng-content></span>
        `,
                    standalone: true,
                    imports: [IconWrapperComponent, NgClass]
                }]
        }], ctorParameters: () => [{ type: EditService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [CELL_CONTEXT]
                }] }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: ContextService }, { type: i0.NgZone }], propDecorators: { visible: [{
                type: HostBinding,
                args: ['style.display']
            }], commandClass: [{
                type: HostBinding,
                args: ['class.k-grid-remove-command']
            }], onClick: [{
                type: HostListener,
                args: ['click', ['$event']]
            }] } });

/**
 * Represents the command for adding a new item to the Grid. Apply this directive to any
 * `button` element inside a [ToolbarTemplate]({% slug api_grid_commandcolumncomponent %}).
 * When you click the button with this directive, the [`add`]({% slug api_grid_gridcomponent %}#toc-add) event is triggered
 * ([see example]({% slug basics_editing_grid %})).
 *
 * @example
 * ```html
 * <button kendoGridAddCommand>Add new item</button>
 * ```
 */
class AddCommandDirective extends Button {
    editService;
    /**
     * @hidden
     */
    onClick(e) {
        e.preventDefault();
        this.editService.beginAdd();
    }
    /**
     * @hidden
     */
    get commandClass() {
        return true;
    }
    constructor(editService, element, renderer, ctx, ngZone) {
        super(element, renderer, null, ctx.localization, ngZone);
        this.editService = editService;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AddCommandDirective, deps: [{ token: EditService }, { token: i0.ElementRef }, { token: i0.Renderer2 }, { token: ContextService }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: AddCommandDirective, isStandalone: true, selector: "[kendoGridAddCommand]", host: { listeners: { "click": "onClick($event)" }, properties: { "class.k-grid-add-command": "this.commandClass" } }, usesInheritance: true, ngImport: i0, template: `
        @if (icon || svgIcon) {
          <kendo-icon-wrapper
            innerCssClass="k-button-icon"
            [name]="icon"
          [svgIcon]="svgIcon"></kendo-icon-wrapper>
        }
        @if (imageUrl) {
          <span class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
          </span>
        }
        @if (iconClass) {
          <span class="k-button-icon" [ngClass]="iconClass"></span>
        }
        <span class="k-button-text"><ng-content></ng-content></span>
        `, isInline: true, dependencies: [{ kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AddCommandDirective, decorators: [{
            type: Component,
            args: [{
                    selector: '[kendoGridAddCommand]',
                    template: `
        @if (icon || svgIcon) {
          <kendo-icon-wrapper
            innerCssClass="k-button-icon"
            [name]="icon"
          [svgIcon]="svgIcon"></kendo-icon-wrapper>
        }
        @if (imageUrl) {
          <span class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
          </span>
        }
        @if (iconClass) {
          <span class="k-button-icon" [ngClass]="iconClass"></span>
        }
        <span class="k-button-text"><ng-content></ng-content></span>
        `,
                    standalone: true,
                    imports: [IconWrapperComponent, NgClass]
                }]
        }], ctorParameters: () => [{ type: EditService }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: ContextService }, { type: i0.NgZone }], propDecorators: { onClick: [{
                type: HostListener,
                args: ['click', ['$event']]
            }], commandClass: [{
                type: HostBinding,
                args: ['class.k-grid-add-command']
            }] } });

/**
 * The directive allows customizing the loading indicator for virtual scrolling cells in the Grid.
 * Place an `<ng-template>` tag with the `kendoGridCellLoadingTemplate` directive inside `<kendo-grid>` to define the loading cell template. ([See example]({% slug virtualscrolling_grid %}#toc-custom-loading-skeleton)).
 *
 * The template context is set to the current column. You can use the following field:
 * - `column`&mdash;The current column instance. This is the default context for any template variable that uses the `let-x` syntax (for example, `let-column`).
 *
 * @example
 * ```html
 * <kendo-grid ... scrollable="virtual" [rowHeight]="36" [height]="450">
 *   <ng-template kendoGridCellLoadingTemplate let-column>
 *    ...
 *   </ng-template>
 * </kendo-grid>
 * ```
 */
class CellLoadingTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CellLoadingTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: CellLoadingTemplateDirective, isStandalone: true, selector: "[kendoGridCellLoadingTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CellLoadingTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridCellLoadingTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }] });

/**
 * The directive allows customizing the drag handle cell in the Grid row reorder column.
 * Place an `<ng-template>` tag with the `kendoGridRowDragHandleTemplate` directive inside the `<kendo-grid-rowreorder-column>` tag to set the cell template.
 *
 * The template context is the current data item. You also get access to the following additional fields:
 * - `columnIndex`&mdash;The current column index. Use it as a template variable with `let-columnIndex="columnIndex"`.
 * - `rowIndex`&mdash;The data row index. Use it as a template variable with `let-rowIndex="rowIndex"`.
 *
 * @example
 * ```html
 * <kendo-grid [kendoGridBinding]="data" [rowReorderable]="true">
 *    <kendo-grid-rowreorder-column>
 *      <ng-template kendoGridRowDragHandleTemplate>
 *        <span>Drag here</span>
 *      </ng-template>
 *    </kendo-grid-rowreorder-column>
 *   <kendo-grid-column field="Field1"></kendo-grid-column>
 *   <kendo-grid-column field="Field2"></kendo-grid-column>
 * </kendo-grid>
 * ```
 */
class RowDragHandleTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: RowDragHandleTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: RowDragHandleTemplateDirective, isStandalone: true, selector: "[kendoGridRowDragHandleTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: RowDragHandleTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridRowDragHandleTemplate]',
                    standalone: true,
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }] });

/**
 * The directive allows customizing the drag hint in the Grid row reorder column.
 * Place an `<ng-template>` tag with the `kendoGridRowDragHintTemplate` directive inside the `<kendo-grid-rowreorder-column>` tag to set the hint template.
 *
 * The template context is the current data item. You also get the data row index as an extra field. Use it as a template variable with `let-rowIndex="rowIndex"`.
 *
 * @example
 * ```html
 * <kendo-grid [kendoGridBinding]="data" [rowReorderable]="true">
 *    <kendo-grid-rowreorder-column>
 *      <ng-template kendoGridRowDragHintTemplate>
 *        <span>Custom hint</span>
 *      </ng-template>
 *    </kendo-grid-rowreorder-column>
 *   <kendo-grid-column field="Field1"></kendo-grid-column>
 *   <kendo-grid-column field="Field2"></kendo-grid-column>
 * </kendo-grid>
 * ```
 */
class RowDragHintTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: RowDragHintTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: RowDragHintTemplateDirective, isStandalone: true, selector: "[kendoGridRowDragHintTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: RowDragHintTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridRowDragHintTemplate]',
                    standalone: true,
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }] });

/**
 * Represents the drag handle for reordering rows in the Grid. [See example](slug:reordering_rows_grid).
 *
 * @example
 * ```html
 * <kendo-grid>
 *   <kendo-grid-rowreorder-column></kendo-grid-rowreorder-column>
 *   <kendo-grid-column field="ProductID"></kendo-grid-column>
 * </kendo-grid>
 * ```
 */
class RowReorderColumnComponent extends ColumnBase {
    parent;
    /**
     * Defines the name for an existing font icon in the Kendo UI theme.
     * @hidden
     */
    dragHandleIcon;
    /**
     * Defines an SVGIcon to be rendered as a drag handle.
     * @hidden
     */
    dragHandleSVGIcon;
    /**
     * @hidden
     */
    dragHandleTemplate = new QueryList();
    /**
     * @hidden
     */
    dragHintTemplate = new QueryList();
    /**
     * @hidden
     */
    isRowReorderColumn = true;
    /**
     * @hidden
     */
    get rowDragHandleTemplateRef() {
        const rowTemplate = this.dragHandleTemplate.first;
        return rowTemplate ? rowTemplate.templateRef : undefined;
    }
    /**
     * @hidden
     */
    get rowDragHintTemplateRef() {
        const rowTemplate = this.dragHintTemplate.first;
        return rowTemplate ? rowTemplate.templateRef : undefined;
    }
    constructor(parent, idService) {
        super(parent, idService);
        this.parent = parent;
    }
    /**
     * Sets a function to determine the rowspan of each column cell.
     */
    set cellRowspan(cellRowspan) {
        super.cellRowspan = cellRowspan;
    }
    get cellRowspan() {
        return super.cellRowspan;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: RowReorderColumnComponent, deps: [{ token: ColumnBase, host: true, optional: true, skipSelf: true }, { token: IdService, optional: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: RowReorderColumnComponent, isStandalone: true, selector: "kendo-grid-rowreorder-column", inputs: { dragHandleIcon: "dragHandleIcon", dragHandleSVGIcon: "dragHandleSVGIcon" }, providers: [
            {
                provide: ColumnBase,
                useExisting: forwardRef(() => RowReorderColumnComponent)
            }
        ], queries: [{ propertyName: "dragHandleTemplate", predicate: RowDragHandleTemplateDirective }, { propertyName: "dragHintTemplate", predicate: RowDragHintTemplateDirective }], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: RowReorderColumnComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: ColumnBase,
                            useExisting: forwardRef(() => RowReorderColumnComponent)
                        }
                    ],
                    selector: 'kendo-grid-rowreorder-column',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: ColumnBase, decorators: [{
                    type: SkipSelf
                }, {
                    type: Host
                }, {
                    type: Optional
                }] }, { type: IdService, decorators: [{
                    type: Optional
                }] }], propDecorators: { dragHandleIcon: [{
                type: Input
            }], dragHandleSVGIcon: [{
                type: Input
            }], dragHandleTemplate: [{
                type: ContentChildren,
                args: [RowDragHandleTemplateDirective, { descendants: false }]
            }], dragHintTemplate: [{
                type: ContentChildren,
                args: [RowDragHintTemplateDirective, { descendants: false }]
            }] } });

/**
 * @hidden
 */
class ZoneAwareEventEmitter extends EventEmitter {
    ngZone;
    constructor(ngZone, isAsync = false) {
        super(isAsync);
        this.ngZone = ngZone;
    }
    subscribe(generatorOrNext, error, complete) {
        let schedulerFn;
        let errorFn = (_) => null;
        let completeFn = () => null;
        if (generatorOrNext && typeof generatorOrNext === 'object') {
            schedulerFn = (value) => { this.ngZone.run(() => generatorOrNext.next(value)); };
            if (generatorOrNext.error) {
                errorFn = (err) => { this.ngZone.run(() => generatorOrNext.error(err)); };
            }
            if (generatorOrNext.complete) {
                completeFn = () => { this.ngZone.run(() => generatorOrNext.complete()); };
            }
        }
        else {
            schedulerFn = (value) => { this.ngZone.run(() => generatorOrNext(value)); };
            if (error) {
                errorFn = (err) => { this.ngZone.run(() => error(err)); };
            }
            if (complete) {
                completeFn = () => { this.ngZone.run(() => complete()); };
            }
        }
        return super.subscribe(schedulerFn, errorFn, completeFn);
    }
}

/**
 * @hidden
 */
const packageMetadata = {
    name: '@progress/kendo-angular-grid',
    productName: 'Kendo UI for Angular',
    productCode: 'KENDOUIANGULAR',
    productCodes: ['KENDOUIANGULAR'],
    publishDate: 0,
    version: '22.0.1',
    licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/'
};

/**
 * @hidden
 * Converts date strings in a filter to Date objects.
 */
const convertDateStringsInFilter = (filter) => {
    if (!filter) {
        return filter;
    }
    if (filter.filters && Array.isArray(filter.filters)) {
        return {
            ...filter,
            filters: filter.filters.map(f => convertDateStringsInFilter(f))
        };
    }
    if (filter.field && filter.value !== undefined) {
        if (typeof filter.value === 'string' && isDateOperator(filter.operator)) {
            const date = parseDate(filter.value);
            return {
                ...filter,
                value: date || filter.value
            };
        }
    }
    return filter;
};
/**
 * @hidden
 */
const isDateOperator = (operator) => {
    const dateOperators = [
        'eq', 'neq', 'lt', 'lte', 'gt', 'gte'
    ];
    return dateOperators.includes(operator);
};
/**
 * @hidden
 * Processes cell highlights for a specific filter and item.
 */
const processCellHighlights = (filter, rowIndex, columns, highlightItems) => {
    Object.keys(filter.cells).forEach((columnField) => {
        const actualColumnIndex = Array.from(columns).findIndex((col) => col.field === columnField);
        if (actualColumnIndex !== -1) {
            highlightItems.push({
                itemKey: rowIndex,
                columnKey: actualColumnIndex,
            });
        }
    });
};
/**
 * @hidden
 * Processes filtered results and adds highlight items.
 */
const processFilteredResults = (filteredResults, data, filter, columns, highlightItems) => {
    filteredResults?.forEach((item) => {
        const rowIndex = data.findIndex((dataItem) => dataItem === item);
        if (filter.cells && Object.keys(filter.cells).length > 0) {
            processCellHighlights(filter, rowIndex, columns, highlightItems);
        }
        else {
            highlightItems.push({
                itemKey: rowIndex,
            });
        }
    });
};
/**
 * @hidden
 * Highlights items in a grid based on the provided filters and columns.
 * @param data - The data to be highlighted.
 * @param filters - The composite highlight descriptors containing the filters and logic.
 * @param columns - The columns of the grid.
 * @returns An array of HighlightItem objects representing the highlighted items.
 */
const highlightBy = (data, filters, columns) => {
    const highlightItems = [];
    filters.forEach((filter) => {
        const processedFilters = filter.filters.map((filter) => convertDateStringsInFilter(filter));
        const filteredResults = filterBy(data, {
            logic: filter.logic || "and",
            filters: processedFilters,
        });
        processFilteredResults(filteredResults, data, filter, columns, highlightItems);
    });
    return highlightItems;
};

/**
 * @hidden
 *
 * Service that builds AI requests and processes AI responses for the Grid.
 * Used internally by both the Grid component and the AI Assistant tool.
 */
class GridAIRequestResponseService {
    ctx;
    columnInfoService;
    zone;
    constructor(ctx, columnInfoService, zone) {
        this.ctx = ctx;
        this.columnInfoService = columnInfoService;
        this.zone = zone;
    }
    /**
     * Builds the request body for the AI service based on the Grid's column structure.
     * Returns a column descriptor tree that includes column metadata for the AI service.
     */
    buildRequestBody(promptMessage, role) {
        const columnsTree = this.buildColumnDescriptors();
        return {
            role: role || 'user',
            contents: [
                {
                    text: promptMessage
                }
            ],
            columns: columnsTree
        };
    }
    /**
     * Builds a nested column descriptor tree based on the Grid's column structure.
     * Includes root columns and their nested children (for ColumnGroup and SpanColumn).
     */
    buildColumnDescriptors() {
        const rootColumns = this.ctx?.grid?.columnList?.rootColumns() || [];
        const buildDescriptor = (col) => {
            const hasChildren = Boolean(col.hasChildren && col.childrenArray?.length);
            const descriptor = {
                id: col.id,
                field: col.field,
                header: col.title
            };
            if (hasChildren) {
                descriptor.columns = col.childrenArray.map((c) => buildDescriptor(c));
            }
            // For special columns that don't have a field, emit an optional type token
            // so the AI service knows how to treat them (checkbox/command/reorder)
            if (!col.field) {
                if (isCheckboxColumn(col)) {
                    descriptor.type = 'checkbox';
                }
                else if (col instanceof CommandColumnComponent) {
                    descriptor.type = 'command';
                }
            }
            return descriptor;
        };
        return rootColumns.map((col) => buildDescriptor(col));
    }
    /**
     * Processes AI response commands and applies them to the Grid.
     * Returns an array of display messages for each command.
     */
    processCommands(commands, columns, leafColumns) {
        const messages = [];
        this.executeCommands(commands || [], columns, leafColumns, messages);
        return messages;
    }
    executeCommands(commands, columns, leafColumns, messages) {
        if (!commands?.length) {
            return;
        }
        const grid = this.ctx.grid;
        const isFilterable = Boolean(grid.filterable);
        const isSortable = Boolean(grid.sortable);
        const isGroupable = Boolean(grid.groupable);
        const findColumnById = (id) => grid.columnList.toArray().find((c) => c.id === id);
        const updateColumnHierarchy = (column, updater) => {
            const changed = [];
            const queue = [column];
            while (queue.length) {
                const current = queue.shift();
                if (!current) {
                    continue;
                }
                const didChange = updater(current);
                if (didChange) {
                    changed.push(current);
                }
                if (current.hasChildren && current.childrenArray?.length) {
                    queue.push(...current.childrenArray);
                }
            }
            return changed;
        };
        commands.forEach((cmd) => {
            let displayMessage = cmd.message || '';
            if (this.isColumnCommand(cmd.type)) {
                if (cmd.id) {
                    const column = findColumnById(cmd.id);
                    const replacement = this.getColumnReplacement(column);
                    displayMessage = this.replaceQuotedColumnId(displayMessage, replacement);
                }
            }
            messages.push(displayMessage);
            switch (cmd.type) {
                case 'GridSort':
                    if (!isSortable) {
                        break;
                    }
                    this.processArrayResponse([cmd.sort], grid.currentState.sort || [], (item) => item.field, (mergedArray) => grid.sortChange.next(mergedArray));
                    break;
                case 'GridClearSort':
                    if (!isSortable) {
                        break;
                    }
                    grid.sortChange.next([]);
                    break;
                case 'GridFilter':
                    if (!isFilterable) {
                        break;
                    }
                    this.processFilterResponse(cmd.filter);
                    break;
                case 'GridClearFilter':
                    if (!isFilterable) {
                        break;
                    }
                    grid.filterChange.next(undefined);
                    break;
                case 'GridGroup':
                    if (!isGroupable) {
                        break;
                    }
                    this.processArrayResponse([cmd.group], grid.currentState.group || [], (item) => item.field, (mergedArray) => grid.groupChange.next(mergedArray));
                    break;
                case 'GridClearGroup':
                    if (!isGroupable) {
                        break;
                    }
                    grid.groupChange.next([]);
                    break;
                case 'GridHighlight':
                    if (!this.ctx.highlightDirective) {
                        break;
                    }
                    this.processHighlightResponse([cmd.highlight], columns);
                    break;
                case 'GridClearHighlight':
                    if (!this.ctx.highlightDirective) {
                        break;
                    }
                    this.ctx.highlightDirective['setState']([]);
                    break;
                case 'GridSelect': {
                    this.processSelectionResponse([cmd.select], columns, leafColumns, messages);
                    break;
                }
                case 'GridClearSelect': {
                    const selectionInstance = this.getSelectionInstance();
                    if (!selectionInstance) {
                        this.updateLastMessage(messages, this.ctx.localization?.get('aiAssistantSelectionNotEnabled'));
                        break;
                    }
                    this.applySelectionState(selectionInstance, []);
                    break;
                }
                case 'GridColumnResize': {
                    const col = findColumnById(cmd.id);
                    if (!col) {
                        break;
                    }
                    let newWidth;
                    if (typeof cmd.size === 'number') {
                        newWidth = cmd.size;
                    }
                    else if (typeof cmd.size === 'string') {
                        const numericPart = parseFloat(cmd.size);
                        if (!isNaN(numericPart)) {
                            newWidth = numericPart;
                        }
                    }
                    if (typeof newWidth === 'number') {
                        const oldWidth = col.width;
                        col.width = newWidth;
                        const args = [{ column: col, oldWidth: oldWidth, newWidth: newWidth }];
                        grid.columnResize.emit(args);
                    }
                    break;
                }
                case 'GridColumnReorder': {
                    const col = findColumnById(cmd.id);
                    if (!col) {
                        break;
                    }
                    const newPosition = Number(cmd.position);
                    if (!isNaN(newPosition) && newPosition >= 0) {
                        this.changeColumnPosition(col, newPosition);
                    }
                    break;
                }
                case 'GridColumnShow':
                case 'GridColumnHide': {
                    const col = findColumnById(cmd.id);
                    if (!col) {
                        break;
                    }
                    const targetHidden = cmd.type === 'GridColumnHide';
                    const changed = updateColumnHierarchy(col, (current) => {
                        if (current.hidden === targetHidden) {
                            return false;
                        }
                        current.hidden = targetHidden;
                        return true;
                    });
                    if (changed.length) {
                        this.columnInfoService.changeVisibility(changed);
                    }
                    break;
                }
                case 'GridColumnLock':
                case 'GridColumnUnlock': {
                    const col = findColumnById(cmd.id);
                    if (!col) {
                        break;
                    }
                    const targetLocked = cmd.type === 'GridColumnLock';
                    const changed = updateColumnHierarchy(col, (current) => {
                        if (current.locked === targetLocked) {
                            return false;
                        }
                        current.locked = targetLocked;
                        return true;
                    });
                    if (changed.length) {
                        this.columnInfoService.changeLocked(changed);
                    }
                    break;
                }
                case 'GridPage': {
                    this.processPageCommand(cmd);
                    break;
                }
                case 'GridPageSize': {
                    this.processPageSizeCommand(cmd);
                    break;
                }
                case 'GridExportExcel': {
                    this.runExportWithFileName(this.ctx.excelComponent, cmd.fileName, () => grid.saveAsExcel());
                    break;
                }
                case 'GridExportPDF': {
                    this.runExportWithFileName(this.ctx.pdfComponent, cmd.fileName, () => grid.emitPDFExportEvent());
                    break;
                }
                default:
                    break;
            }
        });
    }
    processArrayResponse(newItems, currentItems, getField, updateGrid) {
        if (newItems?.length === 0) {
            updateGrid([]);
        }
        else if (newItems?.length) {
            let mergedArray = [...newItems];
            const newFields = newItems.map(getField);
            const existingItemsToKeep = currentItems.filter(item => !newFields.includes(getField(item)));
            mergedArray = [...mergedArray, ...existingItemsToKeep];
            updateGrid(mergedArray);
        }
    }
    runExportWithFileName(component, fileName, action) {
        if (!component || !fileName) {
            action();
            return;
        }
        const previousFileName = component.fileName;
        component.fileName = fileName;
        action();
        const isExcel = component === this.ctx.excelComponent;
        if (isExcel) {
            this.zone.runOutsideAngular(() => {
                this.ctx.excelComponent.fileCreated.subscribe(() => {
                    component.fileName = previousFileName;
                });
            });
        }
        else {
            component.fileName = previousFileName;
        }
    }
    processPageCommand(command) {
        const pageSize = this.getCurrentPageSizeValue();
        if (!isPresent$1(pageSize) || pageSize <= 0) {
            return;
        }
        const total = this.getTotalItemsCount();
        const requestedPage = Number(command.page);
        let targetPage = Number.isFinite(requestedPage) ? Math.floor(requestedPage) : 1;
        if (targetPage < 1) {
            targetPage = 1;
        }
        if (isPresent$1(total) && pageSize > 0) {
            const maxPage = Math.max(1, Math.ceil(total / pageSize));
            targetPage = Math.min(targetPage, maxPage);
        }
        const skip = (targetPage - 1) * pageSize;
        this.emitGridPageChange(skip, pageSize);
    }
    processPageSizeCommand(command) {
        const rawPageSize = Number(command.pageSize);
        if (!Number.isFinite(rawPageSize)) {
            return;
        }
        const newPageSize = Math.max(1, Math.floor(rawPageSize));
        const skip = Math.max(0, this.ctx.grid?.skip ?? 0);
        this.ensurePageSizeOption(newPageSize);
        this.emitGridPageChange(skip, newPageSize);
    }
    emitGridPageChange(skip, take) {
        const grid = this.ctx.grid;
        const normalizedSkip = Math.max(0, Math.floor(skip));
        const normalizedTake = Math.max(1, Math.floor(take));
        grid.skip = normalizedSkip;
        grid.pageSize = normalizedTake;
        grid.pageChange.emit({ skip: normalizedSkip, take: normalizedTake });
    }
    ensurePageSizeOption(pageSize) {
        const grid = this.ctx.grid;
        if (!grid) {
            return;
        }
        const pageable = grid.pageable;
        if (!pageable || typeof pageable === 'boolean') {
            return;
        }
        const pageSizes = pageable.pageSizes;
        if (!Array.isArray(pageSizes) || pageSizes.length === 0) {
            return;
        }
        if (pageSizes.includes(pageSize)) {
            return;
        }
        const uniqueSizes = [pageSize, ...pageSizes.filter(size => size !== pageSize)];
        grid.pageable = {
            ...pageable,
            pageSizes: uniqueSizes
        };
        const changeDetector = grid?.changeDetectorRef;
        if (changeDetector && typeof changeDetector.markForCheck === 'function') {
            changeDetector.markForCheck();
        }
    }
    getCurrentPageSizeValue() {
        const grid = this.ctx.grid;
        if (!grid) {
            return null;
        }
        const candidates = [grid.pageSize, grid.currentState?.take, this.ctx.dataBindingDirective?.['state']?.take];
        for (const candidate of candidates) {
            if (typeof candidate === 'number' && candidate > 0) {
                return candidate;
            }
        }
        const pageable = grid.pageable;
        if (pageable && typeof pageable === 'object' && Array.isArray(pageable.pageSizes)) {
            const numericSize = pageable.pageSizes.find(size => typeof size === 'number' && size > 0);
            if (numericSize) {
                return numericSize;
            }
        }
        const originalData = this.ctx.dataBindingDirective?.['originalData'];
        if (Array.isArray(originalData) && originalData.length > 0) {
            return originalData.length;
        }
        return null;
    }
    getTotalItemsCount() {
        const grid = this.ctx.grid;
        if (!grid) {
            return null;
        }
        const gridData = grid.data;
        if (gridData && typeof gridData.total === 'number') {
            return gridData.total;
        }
        const view = grid.view;
        if (view && typeof view.total === 'number') {
            return view.total;
        }
        const originalData = this.ctx.dataBindingDirective?.['originalData'];
        if (Array.isArray(originalData)) {
            return originalData.length;
        }
        return null;
    }
    getSelectionInstance() {
        const selectionDirective = this.ctx.grid?.selectionDirective;
        if (selectionDirective && typeof selectionDirective === 'object') {
            return selectionDirective;
        }
        const defaultSelection = this.ctx.grid?.defaultSelection;
        if (defaultSelection && typeof defaultSelection === 'object') {
            return defaultSelection;
        }
        return null;
    }
    updateLastMessage(messages, newMessage) {
        if (!messages.length) {
            return;
        }
        messages[messages.length - 1] = newMessage;
    }
    isColumnCommand(type) {
        return type === 'GridColumnResize' ||
            type === 'GridColumnReorder' ||
            type === 'GridColumnShow' ||
            type === 'GridColumnHide' ||
            type === 'GridColumnLock' ||
            type === 'GridColumnUnlock';
    }
    getColumnReplacement(column) {
        if (!column) {
            return '';
        }
        if (column.title && String(column.title).trim()) {
            return String(column.title).trim();
        }
        if (column.field && String(column.field).trim()) {
            return String(column.field).trim();
        }
        return '';
    }
    replaceQuotedColumnId(message, replacement) {
        if (!replacement) {
            const columnIdPattern = /(?:&quot;|")(k-grid\d+-col\d+)(?:&quot;|")\s*/g;
            return message.replace(columnIdPattern, '').replace(/\s{2,}/g, ' ').trim();
        }
        const columnIdPattern = /(?:&quot;|")(k-grid\d+-col\d+)(?:&quot;|")/g;
        return message.replace(columnIdPattern, (match) => {
            const isEncoded = match.startsWith('&quot;');
            return isEncoded ? `&quot;${replacement}&quot;` : `"${replacement}"`;
        });
    }
    getHighlightItems(descriptors, columns) {
        if (!descriptors?.length) {
            return [];
        }
        const data = this.ctx.dataBindingDirective?.['originalData'] || [];
        return highlightBy(data, descriptors, columns);
    }
    processSelectionResponse(selection, columns, leafColumns, messages) {
        const selectionInstance = this.getSelectionInstance();
        if (!selectionInstance) {
            this.updateLastMessage(messages, this.ctx.localization?.get('aiAssistantSelectionNotEnabled'));
            return;
        }
        const descriptors = (selection || []).filter((descriptor) => Boolean(descriptor));
        if (descriptors.length === 0) {
            this.applySelectionState(selectionInstance, []);
            return;
        }
        const highlightItems = this.getHighlightItems(descriptors, columns);
        if (!highlightItems.length) {
            this.applySelectionState(selectionInstance, []);
            return;
        }
        const hasCellSelections = highlightItems.some(item => isPresent$1(item.columnKey));
        const hasRowSelections = highlightItems.some(item => !isPresent$1(item.columnKey));
        const isCellMode = selectionInstance.isCellSelectionMode;
        if ((!isCellMode && hasCellSelections) || (isCellMode && hasRowSelections)) {
            const key = isCellMode ? 'aiAssistantSelectionRowModeRequired' : 'aiAssistantSelectionCellModeRequired';
            this.updateLastMessage(messages, this.ctx.localization?.get(key));
            return;
        }
        const selectionState = this.mapHighlightItemsToSelection(selectionInstance, highlightItems, isCellMode, leafColumns);
        this.applySelectionState(selectionInstance, selectionState);
    }
    mapHighlightItemsToSelection(selectionInstance, highlightItems, isCellMode, leafColumns) {
        const data = this.ctx.dataBindingDirective?.['originalData'] || [];
        if (isCellMode) {
            const mapped = highlightItems
                .filter(item => isPresent$1(item.itemKey) && isPresent$1(item.columnKey))
                .map(item => {
                const rowIndex = item.itemKey;
                const columnIndex = item.columnKey;
                const dataItem = data[rowIndex];
                if (!isPresent$1(dataItem)) {
                    return null;
                }
                if (typeof selectionInstance['getSelectionItem'] === 'function') {
                    const columnComponent = leafColumns[columnIndex];
                    const selectionItem = selectionInstance['getSelectionItem']({ dataItem, index: rowIndex }, columnComponent, columnIndex);
                    if (selectionItem && isPresent$1(selectionItem.itemKey) && isPresent$1(selectionItem.columnKey)) {
                        return selectionItem;
                    }
                    return null;
                }
                const itemKey = typeof selectionInstance.getItemKey === 'function'
                    ? selectionInstance.getItemKey({ dataItem, index: rowIndex })
                    : rowIndex;
                return isPresent$1(itemKey) ? { itemKey, columnKey: columnIndex } : null;
            })
                .filter((item) => isPresent$1(item));
            return mapped.filter((item, index, self) => self.findIndex(other => other.itemKey === item.itemKey && other.columnKey === item.columnKey) === index);
        }
        const rowKeys = highlightItems
            .filter(item => isPresent$1(item.itemKey))
            .map(item => {
            const rowIndex = item.itemKey;
            const dataItem = data[rowIndex];
            if (!isPresent$1(dataItem)) {
                return null;
            }
            if (typeof selectionInstance.getItemKey === 'function') {
                return selectionInstance.getItemKey({ dataItem, index: rowIndex });
            }
            return rowIndex;
        })
            .filter(isPresent$1);
        return Array.from(new Set(rowKeys));
    }
    applySelectionState(selectionInstance, selectionState) {
        selectionInstance.selectedKeys = selectionState;
        if (typeof selectionInstance['setState'] === 'function') {
            selectionInstance['setState'](selectionState);
        }
        const changeDetector = selectionInstance['cd'];
        if (changeDetector && typeof changeDetector.markForCheck === 'function') {
            changeDetector.markForCheck();
        }
        if (typeof selectionInstance['notifyChange'] === 'function') {
            selectionInstance['notifyChange']();
        }
    }
    processHighlightResponse(highlight, columns) {
        const highlightedItems = this.getHighlightItems(highlight, columns);
        this.ctx.highlightDirective['setState'](highlightedItems);
    }
    processFilterResponse(filter) {
        const processedFilter = convertDateStringsInFilter(filter);
        const clearFilter = Object.keys(processedFilter).length === 0;
        if (clearFilter) {
            this.ctx.grid.filterChange.next(undefined);
        }
        else if (processedFilter?.filters.length) {
            const currentFilter = this.ctx.grid.currentState.filter;
            let mergedFilter = processedFilter;
            if (currentFilter && currentFilter.filters?.length > 0) {
                mergedFilter = {
                    logic: 'and',
                    filters: [
                        currentFilter,
                        processedFilter
                    ]
                };
            }
            this.ctx.grid.filterChange.next(mergedFilter);
        }
    }
    changeColumnPosition(column, newPosition) {
        const grid = this.ctx.grid;
        if (!grid?.columns) {
            return;
        }
        const currentColumns = grid.columns.toArray();
        const currentIndex = currentColumns.findIndex(col => col === column);
        if (currentIndex === -1) {
            return;
        }
        if (newPosition < 0 || newPosition >= currentColumns.length) {
            return;
        }
        const sortedColumns = currentColumns
            .map((col, idx) => ({ col, physicalIndex: idx, visualOrder: col.orderIndex ?? idx }))
            .sort((a, b) => a.visualOrder - b.visualOrder);
        const currentVisualPos = sortedColumns.findIndex(item => item.physicalIndex === currentIndex);
        if (currentVisualPos === newPosition) {
            return;
        }
        currentColumns.forEach((col, idx) => {
            const sortedIndex = sortedColumns.findIndex(item => item.physicalIndex === idx);
            if (idx === currentIndex) {
                col.orderIndex = newPosition;
            }
            else if (currentVisualPos < newPosition) {
                col.orderIndex = (sortedIndex > currentVisualPos && sortedIndex <= newPosition)
                    ? sortedIndex - 1 : sortedIndex;
            }
            else {
                col.orderIndex = (sortedIndex >= newPosition && sortedIndex < currentVisualPos)
                    ? sortedIndex + 1 : sortedIndex;
            }
            col.isReordered = true;
        });
        grid.columnReorder.emit({
            column: column,
            oldIndex: currentVisualPos,
            newIndex: newPosition
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GridAIRequestResponseService, deps: [{ token: ContextService }, { token: ColumnInfoService }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GridAIRequestResponseService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GridAIRequestResponseService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: ContextService }, { type: ColumnInfoService }, { type: i0.NgZone }] });

/**
 * @hidden
 */
const normalizeSettings = ({ buttonCount = 10, info = true, type = 'numeric', pageSizes = false, previousNext = true, responsive = true, position = 'bottom' }) => ({
    buttonCount,
    info,
    pageSizes,
    previousNext,
    type,
    responsive,
    position
});
/**
 * @hidden
 */
const normalize = (settings) => normalizeSettings(settings === true ? {} : settings);

const canCreateElement = () => isDocumentAvailable() && document.createElement;
let cachedScrollbarWidth = null;
let cachedPixelRatio;
let cachedRtlScrollLeft = null;
function scrollbarWidth() {
    if (cachedScrollbarWidth === null && canCreateElement()) {
        cachedPixelRatio = window.devicePixelRatio || 1;
        const div = document.createElement("div");
        div.style.cssText = "overflow:scroll;overflow-x:hidden;zoom:1;clear:both;display:block";
        div.innerHTML = "&nbsp;";
        document.body.appendChild(div);
        cachedScrollbarWidth = div.offsetWidth - div.scrollWidth;
        document.body.removeChild(div);
    }
    return cachedScrollbarWidth;
}
function rtlScrollLeft() {
    if (cachedRtlScrollLeft === null && canCreateElement()) {
        const outer = document.createElement('div');
        outer.style.direction = 'rtl';
        outer.style.display = 'block';
        outer.style.clear = 'both';
        outer.style.width = '100px';
        outer.style.visibility = 'hidden';
        outer.style.position = 'absolute';
        outer.style.left = '-10000px';
        outer.style.overflow = 'scroll';
        outer.style.zoom = '1';
        const inner = document.createElement('div');
        inner.style.width = '200px';
        inner.style.height = '1px';
        outer.append(inner);
        document.body.appendChild(outer);
        const initial = outer.scrollLeft;
        outer.scrollLeft = -1;
        cachedRtlScrollLeft = outer.scrollLeft < 0 ? outer.scrollLeft : initial;
        document.body.removeChild(outer);
    }
    return cachedRtlScrollLeft;
}
/**
 * @hidden
 * move to kendo-common
 */
class BrowserSupportService {
    zone;
    changeDetector;
    changes = new EventEmitter();
    subscriptions;
    constructor(zone, changeDetector) {
        this.zone = zone;
        this.changeDetector = changeDetector;
        if (typeof window === 'undefined') {
            return;
        }
        this.zone.runOutsideAngular(() => {
            this.subscriptions = fromEvent(window, 'resize').pipe(auditTime(100)).subscribe(() => {
                if (cachedPixelRatio !== window.devicePixelRatio) {
                    zone.run(() => {
                        cachedScrollbarWidth = null;
                        this.changes.emit();
                        this.changeDetector.markForCheck();
                    });
                }
            });
        });
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
            this.subscriptions = null;
        }
    }
    get scrollbarWidth() {
        return scrollbarWidth();
    }
    get rtlScrollLeft() {
        return rtlScrollLeft();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: BrowserSupportService, deps: [{ token: i0.NgZone }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: BrowserSupportService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: BrowserSupportService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: i0.NgZone }, { type: i0.ChangeDetectorRef }] });

const isGroupItem = (source) => {
    return source.items !== undefined &&
        source.field !== undefined;
};
const flattenGroups = (groups) => (groups.reduce((acc, curr) => {
    if (isGroupItem(curr)) {
        return acc.concat(flattenGroups(curr.items));
    }
    return acc.concat([curr]);
}, []));
/**
 * @hidden
 */
const itemAt = (data, index) => {
    const first = data[0];
    if (isPresent(first) && isGroupItem(first)) {
        return flattenGroups(data)[index];
    }
    return data[index];
};
/**
 * @hidden
 */
const getIterator = (data, { footers, level, dataIndex, parentGroupIndex, groupIndex, parentGroup }) => {
    const first = data[0];
    if (isPresent(first) && isGroupItem(first)) {
        return new GroupIterator(data, footers, level, dataIndex, parentGroupIndex, groupIndex, parentGroup);
    }
    return new ItemIterator(data, dataIndex, parentGroupIndex, parentGroup);
};
class ArrayIterator {
    arr;
    idx;
    constructor(arr, idx = 0) {
        this.arr = arr;
        this.idx = idx;
        this.arr = arr || [];
    }
    [iterator]() {
        return this;
    }
    next() {
        return this.idx < this.arr.length ? {
            done: false,
            value: this.arr[this.idx++]
        } : { done: true, value: undefined };
    }
}
/**
 * @hidden
 */
class Iterator {
    dataIndex;
    resultMap;
    _innerIterator;
    constructor(arr, dataIndex = 0, resultMap = (x) => x) {
        this.dataIndex = dataIndex;
        this.resultMap = resultMap;
        const iter = arr[iterator];
        this._innerIterator = iter ? arr[iterator]() : new ArrayIterator(arr);
    }
    [iterator]() {
        return this;
    }
    next() {
        return this.resultMap(this._innerIterator.next(), this.dataIndex++);
    }
}
/**
 * @hidden
 */
class ItemIterator extends Iterator {
    constructor(arr, dataIndex, groupIndex, group) {
        super(arr, dataIndex, (x, idx) => ({
            done: x.done,
            value: {
                data: x.value,
                groupIndex: groupIndex,
                index: idx,
                type: 'data',
                group
            }
        }));
    }
    /**
     * The index of the next record.
     * @readonly
     * @type {number}
     */
    get index() {
        return this.dataIndex;
    }
}
const prefix = (s, n) => {
    const p = s ? s + "_" : s;
    return `${p}${n}`;
};
/**
 * @hidden
 */
class GroupIterator {
    arr;
    outputFooters;
    level;
    dataIndex;
    parentIndex;
    groupIndex;
    parentGroup;
    current;
    _innerIterator;
    _iterator;
    currentGroupIndex = "";
    constructor(arr, outputFooters = false, level = 0, dataIndex = 0, parentIndex = '', groupIndex = 0, parentGroup = undefined) {
        this.arr = arr;
        this.outputFooters = outputFooters;
        this.level = level;
        this.dataIndex = dataIndex;
        this.parentIndex = parentIndex;
        this.groupIndex = groupIndex;
        this.parentGroup = parentGroup;
        this.arr = arr || [];
        this._iterator = new Iterator(this.arr, this.dataIndex);
    }
    [iterator]() {
        return this;
    }
    nextGroupItem() {
        this.current = this._iterator.next().value;
        this._innerIterator = null;
        if (this.current) {
            this.currentGroupIndex = prefix(this.parentIndex, this.groupIndex++);
            return {
                done: false,
                value: {
                    data: this.current,
                    index: this.currentGroupIndex,
                    level: this.level,
                    type: 'group',
                    parentGroup: this.parentGroup
                }
            };
        }
        else {
            this.current = null;
            return { done: true, value: undefined };
        }
    }
    footerItem() {
        if (this.current) {
            const group = this.current;
            this.current = null;
            return {
                done: false,
                value: {
                    data: group,
                    groupIndex: this.currentGroupIndex,
                    level: this.level,
                    type: 'footer',
                    group: {
                        data: group,
                        index: this.currentGroupIndex,
                        level: this.level,
                        type: 'group',
                        parentGroup: this.parentGroup
                    }
                }
            };
        }
        else {
            this.current = null;
            return { done: true, value: undefined };
        }
    }
    innerIterator(group) {
        if (!this._innerIterator) {
            this._innerIterator = getIterator(group.items, {
                dataIndex: this.dataIndex,
                footers: this.outputFooters,
                level: this.level + 1,
                parentGroupIndex: this.currentGroupIndex,
                parentGroup: {
                    data: this.current,
                    index: this.currentGroupIndex,
                    level: this.level,
                    type: 'group',
                    parentGroup: this.parentGroup
                }
            });
        }
        return this._innerIterator;
    }
    nextDataItem(group) {
        const iterator = this.innerIterator(group);
        const result = iterator.next();
        if (isPresent(result.value) && !result.done && result.value.type === "data") {
            this.dataIndex = result.value.index + 1;
        }
        return !result.done ? result : undefined;
    }
    next() {
        if (!isPresent(this.current)) {
            return this.nextGroupItem();
        }
        const item = this.nextDataItem(this.current);
        return item ? item : (this.outputFooters ? this.footerItem() : this.nextGroupItem());
    }
    /**
     * The index of the last iterated data record.
     * @readonly
     * @type {number}
     */
    get index() {
        return this.dataIndex + 1;
    }
}

/**
 * @hidden
 */
class DataResultIterator {
    source;
    skip;
    groupFooters;
    isObject;
    constructor(source, skip = 0, groupFooters = false) {
        this.source = source;
        this.skip = skip;
        this.groupFooters = groupFooters;
        this.source = this.source ? this.source : [];
        this.isObject = this.isGridDataResult(this.source);
    }
    isGridDataResult(source) {
        return source.total !== undefined && source.data !== undefined;
    }
    get total() {
        return this.isObject ? this.source.total : this.source.length;
    }
    get data() {
        return this.isObject ? this.source.data : this.source;
    }
    map(fn) {
        return this.data.map(fn);
    }
    filter(fn) {
        return this.data.filter(fn);
    }
    reduce(fn, init) {
        return this.data.reduce(fn, init);
    }
    forEach(fn) {
        this.data.forEach(fn);
    }
    some(fn) {
        return this.data.some(fn);
    }
    [iterator]() {
        return getIterator(this.data, {
            dataIndex: this.skip,
            footers: this.groupFooters,
            groupIndex: this.skip
        });
    }
    toString() { return this.data.toString(); }
}
/**
 * @hidden
 */
class DataCollection {
    accessor;
    constructor(accessor) {
        this.accessor = accessor;
    }
    get total() { return this.accessor().total; }
    get length() { return this.accessor().data.length; }
    get first() { return this.accessor().data[0]; }
    get last() { return this.accessor().data[this.length - 1]; }
    at(index) {
        return itemAt(this.accessor().data, index);
    }
    map(fn) { return this.accessor().map(fn); }
    filter(fn) {
        return this.accessor().filter(fn);
    }
    reduce(fn, init) {
        return this.accessor().reduce(fn, init);
    }
    forEach(fn) {
        this.accessor().forEach(fn);
    }
    some(fn) {
        return this.accessor().some(fn);
    }
    [iterator]() {
        return this.accessor()[iterator]();
    }
    toString() { return this.accessor().toString(); }
}

/**
 * @hidden
 *
 * Quick look-up structure for combinations of keys or single keys.
 * Similar to the native JS Set, however, working with single keys or a couple of keys.
 * Supports both primitive keys and object keys (compared by reference).
 */
class PairSet {
    /**
     * Symbol used internally to represent "no Y key" when storing single X keys.
     */
    static SINGLE_KEY_SYMBOL = Symbol('SINGLE_KEY');
    /**
     * Gets the total number of key entries (both single keys and key pairs).
     */
    get size() {
        return this.totalKeysCount;
    }
    /**
     * Holds a set of Y keys for each defined X key.
     * Each X key creates a map which holds a set of Y keys.
     * For single keys, the Y value is the SINGLE_KEY_SYMBOL.
     *
     * Map { 'foo' => Set { Symbol(SINGLE_KEY) } } // single key: {x: 'foo'}
     * Map { 'foo2' => Set { 'bar', 'baz' } } // pairs: {x: 'foo2', y: 'bar'}, {x: 'foo2', y: 'baz'}
     */
    keysX = new Map();
    /**
     * Count each added or deleted key manually to avoid iterating over all items when calling `this.size`.
     */
    totalKeysCount = 0;
    constructor(items, keyXField, keyYField) {
        if (items && keyXField) {
            items.forEach(item => {
                if (keyYField && item[keyYField] !== undefined) {
                    this.add(item[keyXField], item[keyYField]);
                }
                else {
                    this.addSingle(item[keyXField]);
                }
            });
        }
    }
    /**
     * Adds a single key entry.
     */
    addSingle(keyX) {
        if (!this.keysX.has(keyX)) {
            this.keysX.set(keyX, new Set());
        }
        if (!this.hasSingle(keyX)) {
            this.keysX.get(keyX).add(PairSet.SINGLE_KEY_SYMBOL);
            this.totalKeysCount += 1;
        }
    }
    /**
     * Adds a couple of items identified as a combination.
     */
    add(keyX, keyY) {
        if (!this.keysX.has(keyX)) {
            this.keysX.set(keyX, new Set());
        }
        if (!this.has(keyX, keyY)) {
            this.keysX.get(keyX).add(keyY);
            this.totalKeysCount += 1;
        }
    }
    /**
     * Deletes a single key entry.
     */
    deleteSingle(keyX) {
        if (this.hasSingle(keyX)) {
            this.keysX.get(keyX).delete(PairSet.SINGLE_KEY_SYMBOL);
            this.totalKeysCount -= 1;
            if (this.keysX.get(keyX).size === 0) {
                this.keysX.delete(keyX);
            }
        }
    }
    /**
     * Deletes a combination of a couple of items identified together.
     */
    delete(keyX, keyY) {
        if (this.has(keyX, keyY)) {
            this.keysX.get(keyX).delete(keyY);
            this.totalKeysCount -= 1;
            if (this.keysX.get(keyX).size === 0) {
                this.keysX.delete(keyX);
            }
        }
    }
    /**
     * Checks whether a single key is stored.
     */
    hasSingle(keyX) {
        return this.keysX.has(keyX) && this.keysX.get(keyX).has(PairSet.SINGLE_KEY_SYMBOL);
    }
    /**
     * Checks whether the defined combination is stored.
     */
    has(keyX, keyY) {
        return this.keysX.has(keyX) && this.keysX.get(keyX).has(keyY);
    }
    /**
     * Checks whether any entry exists for the given X key (single or paired).
     */
    hasX(keyX) {
        return this.keysX.has(keyX) && this.keysX.get(keyX).size > 0;
    }
    /**
     * Gets all Y keys for a given X key, excluding single key entries.
     */
    getYKeys(keyX) {
        if (!this.keysX.has(keyX)) {
            return [];
        }
        const yKeys = Array.from(this.keysX.get(keyX));
        return yKeys.filter(yKey => yKey !== PairSet.SINGLE_KEY_SYMBOL);
    }
    /**
     * Clears all key combinations and single keys.
     */
    clear() {
        this.keysX.clear();
        this.totalKeysCount = 0;
    }
    /**
     * Converts the persisted data structure to an array of objects,
     * using the provided field names for the object props.
     * Single keys will only have the keyXField property.
     * Pair keys will have both keyXField and keyYField properties.
     */
    toArray(keyXField, keyYField) {
        return Array.from(this.keysX).reduce((pairs, pair) => {
            // Array.from(mapInstance) returns an array of arrays [[itemKey1, columnKeysSet1], [itemKey2, columnKeysSet2]]
            const [keyX, keysY] = pair;
            Array.from(keysY).forEach(keyY => {
                if (keyY === PairSet.SINGLE_KEY_SYMBOL) {
                    // Single key entry
                    pairs.push({ [keyXField]: keyX });
                }
                else {
                    // Pair key entry
                    const entry = { [keyXField]: keyX };
                    if (keyYField) {
                        entry[keyYField] = keyY;
                    }
                    pairs.push(entry);
                }
            });
            return pairs;
        }, []);
    }
}

/**
 * @hidden
 */
class Selection {
    ctx;
    cd;
    /**
     * Stores the selected item keys.
     * @default []
     */
    selectedKeys = [];
    /**
     * Sets the starting row index for `Shift`+click range selection.
     *
     * @default 0
     */
    rangeSelectionStartRow;
    /**
     * Sets the starting column index for `Shift`+click range selection when cell selection is on.
     *
     * @default 0
     */
    rangeSelectionStartColumnIndex = 0;
    /**
     * Sets the item key to store in `selectedKeys`.
     * [See example](slug:grid_selection_persistence#using-data-item-field).
     */
    selectionKey;
    /**
     * Sets a function to get the column key for a data cell.
     *
     * The function must return a unique value for each column.
     * The Grid uses the column index as the default column key.
     */
    columnKey;
    /**
     * Emits when the `selectedKeys` collection changes.
     */
    selectedKeysChange = new EventEmitter();
    rowSelectionState = new Set();
    cellSelectionState = new PairSet();
    /**
     * @hidden
     */
    get isCellSelectionMode() {
        return isPresent(this.ctx.grid.selectable) && this.ctx.grid.selectable['cell'];
    }
    lastSelectionState;
    selectionChangeSubscription;
    constructor(ctx, cd) {
        this.ctx = ctx;
        this.cd = cd;
        this.init();
    }
    ngOnChanges(changes) {
        // skip reinitialization if the user data is the same as the last state change
        if (isPresent(changes['selectedKeys']) && this.lastSelectionState !== this.selectedKeys) {
            this.setState(this.selectedKeys);
        }
    }
    init() {
        if (!isPresent(this.ctx.grid.rowSelected)) {
            this.ctx.grid.rowSelected = (row) => this.rowSelectionState.has(this.getItemKey(row));
        }
        if (!isPresent(this.ctx.grid.isRowSelectable)) {
            this.ctx.grid.isRowSelectable = () => Boolean(this.ctx.grid.selectable);
        }
        if (!isPresent(this.ctx.grid.cellSelected)) {
            this.ctx.grid.cellSelected = (row, column, colIndex) => {
                const contender = this.getSelectionItem(row, column, colIndex);
                return {
                    selected: this.cellSelectionState.has(contender.itemKey, contender.columnKey),
                    item: contender
                };
            };
        }
        this.selectionChangeSubscription = this.ctx.grid
            .selectionChange
            .subscribe(this.onSelectionChange.bind(this));
    }
    /**
     * @hidden
     */
    destroy() {
        this.selectionChangeSubscription.unsubscribe();
    }
    /**
     * @hidden
     */
    reset() {
        this.rowSelectionState.clear();
        this.cellSelectionState.clear();
    }
    /**
     * @hidden
     */
    getItemKey(row) {
        if (this.selectionKey) {
            if (typeof this.selectionKey === "string") {
                return row.dataItem[this.selectionKey];
            }
            if (typeof this.selectionKey === "function") {
                return this.selectionKey(row);
            }
        }
        return row.index;
    }
    /**
     * @hidden
     */
    stateToArray() {
        return this.isCellSelectionMode ?
            this.cellSelectionState.toArray('itemKey', 'columnKey') :
            Array.from(this.rowSelectionState);
    }
    getSelectionItem(row, col, colIndex) {
        const itemIdentifiers = {};
        itemIdentifiers.itemKey = this.getItemKey(row);
        if (!isPresent(col) && !isPresent(colIndex)) {
            return itemIdentifiers;
        }
        if (this.columnKey) {
            if (typeof this.columnKey === "string") {
                itemIdentifiers.columnKey = row.dataItem[this.columnKey];
            }
            if (typeof this.columnKey === "function") {
                itemIdentifiers.columnKey = this.columnKey(col, colIndex);
            }
        }
        return {
            itemKey: itemIdentifiers.itemKey,
            columnKey: itemIdentifiers.columnKey ? itemIdentifiers.columnKey : colIndex
        };
    }
    onSelectionChange(selection) {
        if (selection.selectedRows) {
            selection.deselectedRows.forEach((item) => {
                const itemKey = this.getItemKey(item);
                this.rowSelectionState.delete(itemKey);
            });
            if (this.ctx.grid.selectableSettings.mode === "single" && this.rowSelectionState.size > 0) {
                this.reset();
            }
            selection.selectedRows.forEach((item) => {
                const itemKey = this.getItemKey(item);
                this.rowSelectionState.add(itemKey);
            });
        }
        else {
            selection.deselectedCells.forEach(({ itemKey, columnKey }) => {
                this.cellSelectionState.delete(itemKey, columnKey);
            });
            if (this.ctx.grid.selectableSettings.mode === "single" && this.cellSelectionState.size > 0) {
                this.reset();
            }
            selection.selectedCells.forEach(({ itemKey, columnKey }) => {
                this.cellSelectionState.add(itemKey, columnKey);
            });
        }
        this.cd.markForCheck();
        this.notifyChange();
    }
    notifyChange() {
        this.lastSelectionState = this.stateToArray();
        this.selectedKeysChange.emit(this.lastSelectionState);
    }
    setState(selectedKeys) {
        this.reset();
        if (this.isCellSelectionMode) {
            this.cellSelectionState = new PairSet(selectedKeys, 'itemKey', 'columnKey');
        }
        else {
            this.rowSelectionState = new Set(selectedKeys);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: Selection, deps: [{ token: ContextService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: Selection, isStandalone: true, selector: "kendo-grid-selection-base", inputs: { selectedKeys: "selectedKeys", rangeSelectionStartRow: "rangeSelectionStartRow", rangeSelectionStartColumnIndex: "rangeSelectionStartColumnIndex", selectionKey: ["kendoGridSelectBy", "selectionKey"], columnKey: "columnKey" }, outputs: { selectedKeysChange: "selectedKeysChange" }, usesOnChanges: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: Selection, decorators: [{
            type: Directive,
            args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: 'kendo-grid-selection-base'
                }]
        }], ctorParameters: () => [{ type: ContextService }, { type: i0.ChangeDetectorRef }], propDecorators: { selectedKeys: [{
                type: Input
            }], rangeSelectionStartRow: [{
                type: Input
            }], rangeSelectionStartColumnIndex: [{
                type: Input
            }], selectionKey: [{
                type: Input,
                args: ["kendoGridSelectBy"]
            }], columnKey: [{
                type: Input
            }], selectedKeysChange: [{
                type: Output
            }] } });

const set = value => pair => pair.forEach(x => x.style.height = value);
const clearHeight = pairs => pairs
    .filter(([left, right]) => left.style.height || right.style.height)
    .forEach(set(""));
const zip = (arr1, arr2) => {
    const result = [];
    for (let idx = 0, len = arr1.length; idx < len; idx++) {
        if (!arr2[idx]) {
            break;
        }
        result.push([arr1[idx], arr2[idx]]);
    }
    return result;
};
const setHeight$1 = heights => (row, idx) => set(`${heights[idx] + 1}px`)(row);
const getHeights = rows => rows.map(([left, right]) => {
    const height = left.offsetHeight;
    const offsetHeight2 = right.offsetHeight;
    if (height < offsetHeight2) {
        return offsetHeight2;
    }
    return height;
});
/**
 * @hidden
 */
const syncRowsHeight = (table1, table2) => {
    if (!isDocumentAvailable()) {
        return;
    }
    const activeElement = document.activeElement;
    const rows = zip(table1.rows, table2.rows);
    clearHeight(rows);
    const heights = getHeights(rows);
    [table1, table2].forEach(x => x.style.display = 'none');
    rows.forEach(setHeight$1(heights));
    [table1, table2].forEach(x => x.style.display = '');
    if (document.activeElement !== activeElement &&
        (table1.contains(activeElement) || table2.contains(activeElement))) {
        activeElement.focus();
    }
};

/**
 * Provides the arguments for the `pdfExport` event.
 */
class PDFExportEvent extends PreventableEvent {
    /**
     * @hidden
     */
    constructor() {
        super();
    }
}

const bootstrapToMedia = (media) => (({
    "xs": "(max-width: 576px)",
    "sm": "(min-width: 576px)",
    "md": "(min-width: 768px)",
    "lg": "(min-width: 992px)",
    "xl": "(min-width: 1200px)"
})[media] || media);
const browserMatchMedia = (media) => window.matchMedia(media).matches;
/**
 * @hidden
 */
class ResponsiveService {
    /**
     * @hidden
     */
    matchMedia = browserMatchMedia;
    /**
     * @hidden
     */
    matchesMedia(media) {
        return !media || this.matchMedia(bootstrapToMedia(media));
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ResponsiveService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ResponsiveService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ResponsiveService, decorators: [{
            type: Injectable
        }] });

/**
 * Represents the toolbar template of the Grid.
 *
 * The template context provides:
 * - `position`&mdash;The position where the toolbar template renders. Possible values: `top`, `bottom`, and `both`.
 *
 * @example
 * ```html
 * <kendo-grid [data]="gridData" style="height: 200px">
 *    <ng-template kendoGridToolbarTemplate [position]="position" let-position="position">
 *       <button (click)="onClick()">Custom action</button>
 *    </ng-template>
 *    <kendo-grid-column field="ProductName">
 *    </kendo-grid-column>
 * </kendo-grid>
 * ```
 */
class ToolbarTemplateDirective {
    templateRef;
    _position = 'top';
    /**
     * Sets the position of the toolbar. ([See example]({% slug toolbartemplate_grid %}#toc-setting-the-toolbar-position)).
     *
     * @default 'top'
     */
    set position(position) {
        this._position = position;
    }
    get position() {
        return this._position;
    }
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ToolbarTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: ToolbarTemplateDirective, isStandalone: true, selector: "[kendoGridToolbarTemplate]", inputs: { position: "position" }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ToolbarTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridToolbarTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }], propDecorators: { position: [{
                type: Input,
                args: ["position"]
            }] } });

/**
 * @hidden
 */
class NavigationMetadata {
    dataRows;
    headerRows;
    isVirtual;
    hasPager;
    hasDetailTemplate;
    gridElement;
    virtualColumns;
    columns;
    footerRow;
    isStacked;
    get maxLogicalRowIndex() {
        const dataRows = this.hasDetailTemplate ? this.dataRows * 2 : this.dataRows;
        return this.headerRows + dataRows + this.footerRow - 1;
    }
    constructor(dataRows, headerRows, isVirtual, hasPager, hasDetailTemplate, gridElement, virtualColumns, columns, footerRow, isStacked) {
        this.dataRows = dataRows;
        this.headerRows = headerRows;
        this.isVirtual = isVirtual;
        this.hasPager = hasPager;
        this.hasDetailTemplate = hasDetailTemplate;
        this.gridElement = gridElement;
        this.virtualColumns = virtualColumns;
        this.columns = columns;
        this.footerRow = footerRow;
        this.isStacked = isStacked;
    }
}

/**
 * Arguments for the `columnVisibilityChange` event.
 */
class ColumnVisibilityChangeEvent {
    /**
     * The columns whose visibility is changed.
     */
    columns;
    /**
     * @hidden
     */
    constructor(columns) {
        this.columns = columns;
    }
}

/**
 * Arguments for the `columnLockedChange` event.
 */
class ColumnLockedChangeEvent {
    /**
     * The columns whose locked state changes.
     */
    columns;
    /**
     * @hidden
     */
    constructor(columns) {
        this.columns = columns;
    }
}

/**
 * @hidden
 */
const GROUP_CELL_WIDTH = 32; // this should be the value of group-cell inside the theme!
/**
 * @hidden
 */
const RESPONSIVE_BREAKPOINT_MEDIUM = 600;
/**
 * @hidden
 */
const RESPONSIVE_BREAKPOINT_LARGE = 768;

/**
 * Arguments for the `columnStickyChange` event.
 */
class ColumnStickyChangeEvent {
    /**
     * The columns whose sticky state is changed.
     */
    columns;
    /**
     * @hidden
     */
    constructor(columns) {
        this.columns = columns;
    }
}

/**
 * @hidden
 */
const isNextSibling = (dropTarget, dragTarget) => dropTarget === dragTarget.nextElementSibling;
/**
 * @hidden
 */
const isPreviousSibling = (dropTarget, dragTarget) => dropTarget === dragTarget.previousElementSibling;
/**
 * @hidden
 */
const isDifferentParent = (dropTarget, dragTarget) => dropTarget?.parentElement !== dragTarget?.parentElement;
/**
 * @hidden
 */
function getOffset(element) {
    const { clientTop, clientLeft } = getDocument(element);
    const { pageYOffset, pageXOffset } = getWindow(element);
    const { top, left } = element.getBoundingClientRect();
    return {
        top: top + pageYOffset - clientTop,
        left: left + pageXOffset - clientLeft
    };
}
/**
 * @hidden
 */
const hintIcons = {
    forbidden: 'cancel',
    before: 'insert-middle',
    after: 'insert-middle'
};
/**
 * @hidden
 */
const hintSVGIcons = {
    forbidden: cancelIcon,
    before: insertMiddleIcon,
    after: insertMiddleIcon
};
/**
 * @hidden
 */
const dropPosition = {
    forbidden: 'forbidden',
    before: 'before',
    after: 'after'
};
/**
 * @hidden
 */
const hintStyles = {
    zIndex: '20000',
    display: 'flex',
    position: 'fixed'
};
/**
 * @hidden
 */
const hintClasses = ['k-drag-clue', 'k-reorder-clue'];
/**
 * @hidden
 */
const dropIndicatorStyles = {
    zIndex: '19000',
    position: 'absolute'
};
/**
 * @hidden
 */
const dropIndicatorClasses = ['k-drop-hint', 'k-drop-hint-h'];
/**
 * @hidden
 */
const getDefaultSelectors = (isStacked) => {
    return {
        handle: isStacked ? '.k-grid-stack-cell.k-drag-cell' : '.k-table-td.k-drag-cell',
        dragTarget: '.k-master-row',
        dropTarget: '.k-master-row'
    };
};
const getDocument = element => element?.ownerDocument.documentElement;
const getWindow = element => element?.ownerDocument.defaultView;

/**
 * @hidden
 */
class RowReorderService {
    renderer;
    hintElement = null;
    defaultSelectors = getDefaultSelectors;
    hintText = '';
    skip;
    dropIndicator;
    lastDropPosition = dropPosition.forbidden;
    dragTarget = null;
    dropTarget = null;
    offsetY;
    rowReorder = new EventEmitter();
    constructor(renderer) {
        this.renderer = renderer;
    }
    ngOnDestroy() {
        this.destroyDropIndicator();
        this.destroyHintElement();
    }
    press(ev) {
        this.dragTarget = ev.dragTarget;
        this.offsetY = ev.dragEvent.offsetY;
    }
    dragStart() {
        this.createDropIndicator();
    }
    drag(ev) {
        if (isPresent$1(ev.hintElement) && !isPresent$1(this.hintElement)) {
            this.hintElement = ev.hintElement;
            this.decorateHint();
        }
        const position = {
            x: ev.dragEvent.clientX,
            y: ev.dragEvent.clientY - this.offsetY
        };
        if (isPresent$1(this.hintElement)) {
            this.renderer.setStyle(this.hintElement, 'left', `${position.x}px`);
            this.renderer.setStyle(this.hintElement, 'top', `${position.y}px`);
        }
        this.positionDropIndicator(ev);
    }
    dragEnter(ev) {
        this.dropTarget = ev.dropTarget;
    }
    dragLeave() {
        this.dropTarget = null;
        this.hide();
    }
    dragEnd() {
        this.destroyDropIndicator();
        this.destroyHintElement();
        this.dragTarget = null;
        this.dropTarget = null;
        this.hintElement = null;
    }
    drop(ev) {
        this.destroyDropIndicator();
        this.destroyHintElement();
        const rowReorderArgs = this.rowReorderArgs(this.dragTarget, this.dropTarget, ev.dragData);
        this.rowReorder.emit(rowReorderArgs);
    }
    reorderRows(ev, collection) {
        if (this.lastDropPosition === dropPosition.forbidden) {
            return;
        }
        const { draggedRows, dropTargetRow } = ev;
        const draggedDataItem = draggedRows[0].dataItem;
        const dropTargetDataItem = dropTargetRow.dataItem;
        const draggedItemIndex = collection.indexOf(draggedDataItem);
        const dropTargetIndex = collection.indexOf(dropTargetDataItem);
        const idxToAdd = this.calculateIndexToAdd(draggedItemIndex, dropTargetIndex);
        collection.splice(draggedItemIndex, 1);
        collection.splice(idxToAdd, 0, draggedDataItem);
    }
    get hintIcon() {
        return hintIcons[this.lastDropPosition];
    }
    get hintSVGIcon() {
        return hintSVGIcons[this.lastDropPosition];
    }
    getDefaultHintText(columns, data) {
        let hintText = '';
        const columnFieldsArray = columns
            .toArray()
            .filter(column => !column.hidden && isPresent$1(column.field))
            .map(column => column.field);
        const draggedDragRow = this.getDragRowPerElement(this.dragTarget, data);
        const draggedDataItem = draggedDragRow?.dataItem;
        isPresent$1(draggedDataItem) && columnFieldsArray.forEach(column => {
            const columnValue = draggedDataItem[column];
            if (isPresent$1(columnValue)) {
                hintText += `${columnValue} `;
            }
        });
        return hintText.trim();
    }
    getDraggedRow(data) {
        return this.getDragRowPerElement(this.dragTarget, data);
    }
    /**
     * Triggers row reordering programmatically via keyboard shortcut.
     * @param dragRowIndex - The index of the row to move
     * @param dropRowIndex - The index of the target row
     * @param dropPosition - The position relative to the target row ('before' or 'after')
     * @param data - The data array
     */
    reorderViaKeyboard(dragRowIndex, dropRowIndex, dropPosition, data) {
        if (dropPosition === 'forbidden') {
            return;
        }
        const dragRow = this.createVirtualRowElement(dragRowIndex);
        const dropRow = this.createVirtualRowElement(dropRowIndex);
        this.lastDropPosition = dropPosition;
        const rowReorderArgs = this.rowReorderArgs(dragRow, dropRow, data);
        this.rowReorder.emit(rowReorderArgs);
    }
    createVirtualRowElement(rowIndex) {
        const virtualElement = {
            getAttribute: (attr) => {
                if (attr === 'data-kendo-grid-item-index') {
                    return String(rowIndex);
                }
                return null;
            }
        };
        return virtualElement;
    }
    rowReorderArgs(dragRow, dropRow, data) {
        const dragRowData = this.getDragRowPerElement(dragRow, data);
        const dropRowData = this.getDragRowPerElement(dropRow, data);
        return {
            draggedRows: [dragRowData],
            dropTargetRow: dropRowData,
            dropPosition: this.lastDropPosition
        };
    }
    getDragRowPerElement(row, data) {
        let rowIndex = row?.getAttribute('data-kendo-grid-item-index');
        rowIndex = rowIndex ? parseInt(rowIndex, 10) : -1;
        const skip = this.skip || 0;
        const dataItem = rowIndex === -1 ? null : data[rowIndex - skip];
        return {
            dataItem,
            rowIndex,
            element: row
        };
    }
    createDropIndicator() {
        if (!isDocumentAvailable()) {
            return;
        }
        this.dropIndicator = document.createElement('div');
        this.decorateDropIndicator();
        this.dropIndicator.innerHTML = `
            <div class="k-drop-hint-start"></div>
            <div class="k-drop-hint-line"></div>
        `;
        document.body.appendChild(this.dropIndicator);
        this.hide();
    }
    destroyDropIndicator() {
        if (!isDocumentAvailable()) {
            return;
        }
        if (this.dropIndicator && this.dropIndicator.parentElement) {
            document.body.removeChild(this.dropIndicator);
            this.dropIndicator = null;
        }
    }
    destroyHintElement() {
        if (!isDocumentAvailable()) {
            return;
        }
        if (this.hintElement?.parentElement) {
            this.hintElement.parentElement.removeChild(this.hintElement);
            this.hintElement = null;
        }
    }
    decorateHint() {
        hintClasses.forEach(className => this.renderer.addClass(this.hintElement, className));
        Object.keys(hintStyles)
            .forEach(style => this.renderer.setStyle(this.hintElement, style, hintStyles[style]));
    }
    positionDropIndicator(ev) {
        this.lastDropPosition = this.getDropPosition(ev.dragEvent);
        this.updateDropIndicatorPosition();
    }
    calculateIndexToAdd(dragIndex, dropIndex) {
        if (dragIndex > dropIndex && this.lastDropPosition === dropPosition.after) {
            return dropIndex + 1;
        }
        else if (dragIndex > dropIndex && this.lastDropPosition === dropPosition.before) {
            return dropIndex;
        }
        else if (dragIndex < dropIndex && this.lastDropPosition === dropPosition.after) {
            return dropIndex;
        }
        else if (dragIndex < dropIndex && this.lastDropPosition === dropPosition.before) {
            return dropIndex - 1;
        }
    }
    decorateDropIndicator() {
        dropIndicatorClasses.forEach(className => this.renderer.addClass(this.dropIndicator, className));
        Object.keys(dropIndicatorStyles)
            .forEach(style => this.renderer.setStyle(this.dropIndicator, style, dropIndicatorStyles[style]));
    }
    getDropPosition(e) {
        if (this.dropTarget === this.dragTarget || !isPresent$1(this.dropTarget)) {
            return dropPosition.forbidden;
        }
        if (isDifferentParent(this.dropTarget, this.dragTarget)) {
            return dropPosition.forbidden;
        }
        const itemViewPortCoords = this.dropTarget.getBoundingClientRect();
        const itemDivisionsCount = 2;
        const itemDivisionHeight = itemViewPortCoords.height / itemDivisionsCount;
        const pointerPosition = e.clientY;
        const itemTop = itemViewPortCoords.top;
        let currentDropPosition = null;
        if (pointerPosition < itemTop + itemDivisionHeight) {
            currentDropPosition = dropPosition.before;
        }
        else if (pointerPosition >= itemTop + itemViewPortCoords.height - itemDivisionHeight) {
            currentDropPosition = dropPosition.after;
        }
        if (currentDropPosition === dropPosition.before && isNextSibling(this.dropTarget, this.dragTarget)) {
            currentDropPosition = dropPosition.forbidden;
        }
        else if (currentDropPosition === dropPosition.after && isPreviousSibling(this.dropTarget, this.dragTarget)) {
            currentDropPosition = dropPosition.forbidden;
        }
        return currentDropPosition;
    }
    updateDropIndicatorPosition() {
        if (this.shouldHideDropIndicator() || !this.dropTarget) {
            this.hide();
            return;
        }
        this.show();
        const destinationItemOffset = getOffset(this.dropTarget);
        let indicatorOffsetTop = destinationItemOffset.top;
        const indicatorOffsetLeft = destinationItemOffset.left + this.dropIndicator.offsetWidth / 2;
        if (this.lastDropPosition === dropPosition.after) {
            indicatorOffsetTop += this.dropTarget.offsetHeight;
        }
        this.renderer.setStyle(this.dropIndicator, 'left', `${indicatorOffsetLeft}px`);
        this.renderer.setStyle(this.dropIndicator, 'top', `${indicatorOffsetTop}px`);
    }
    shouldHideDropIndicator() {
        return this.lastDropPosition === dropPosition.forbidden;
    }
    hide() {
        if (isPresent$1(this.dropIndicator)) {
            this.dropIndicator.style.display = 'none';
        }
    }
    show() {
        if (isPresent$1(this.dropIndicator)) {
            this.dropIndicator.style.display = '';
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: RowReorderService, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: RowReorderService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: RowReorderService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: i0.Renderer2 }], propDecorators: { rowReorder: [{
                type: Output
            }] } });

/**
 * Represents the status bar template of the Grid. Use this directive to customize how the Grid displays aggregates in the status bar.
 *
 * The template context provides:
 * - `aggregates`&mdash;The [`SelectionAggregates`]({% slug api_grid_selectionaggregates %}) object with all calculated aggregates.
 *
 * Use the Angular [`ngFor`](link:site.data.urls.angular['ngfor']) structural directive and the [`KeyValuePipe`](https://angular.io/api/common/KeyValuePipe)
 * to loop through the aggregates as key-value pairs.
 */
class StatusBarTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: StatusBarTemplateDirective, deps: [{ token: i0.TemplateRef }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: StatusBarTemplateDirective, isStandalone: true, selector: "[kendoGridStatusBarTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: StatusBarTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridStatusBarTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef }] });

/**
 * @hidden
 */
class ClipboardService {
    contextService;
    targetColField;
    targetRowIndex;
    constructor(contextService) {
        this.contextService = contextService;
    }
    createClipboardData(data, columns, options) {
        let result = {
            gridItems: [],
            dataString: ''
        };
        const fieldCols = columns.flatMap(c => c instanceof ColumnComponent && isPresent$1(c.field) ? [c] : []);
        const clipboardData = { items: [], dataStrings: [] };
        const colFields = fieldCols.map(c => c.field);
        if (options.wholeRow) {
            this.targetColField = fieldCols[0]?.field;
            this.targetRowIndex = data[0].dataRowIndex;
            data.forEach(item => {
                clipboardData.items.push({ dataItem: { ...item.dataItem }, fields: colFields });
                clipboardData.dataStrings.push(this.itemToString(item.dataItem, fieldCols));
            });
            result = {
                gridItems: options.operationType === 'cut' ? clipboardData.items.map(item => {
                    item.fields.forEach(field => item.dataItem[field] = null);
                    return item;
                }) : [...clipboardData.items],
                dataString: options.copyHeaders ? this.addHeaders(clipboardData.dataStrings.join(`\r\n`), fieldCols) : clipboardData.dataStrings.join(`\n`)
            };
        }
        else {
            if (options.target === 'selection') {
                const { tabular, groups } = this.groupSelection();
                const selectionDirective = this.contextService.grid.selectionDirective;
                const colIdentifier = selectionDirective.columnKey;
                if (tabular) {
                    const selectionKeys = groups[0].items.map(item => item.columnKey);
                    const selectedFieldCols = columns.flatMap((c, i) => (c instanceof ColumnComponent && c.field) && isPresent$1((selectionKeys.find(k => typeof colIdentifier === 'function' ? k === colIdentifier(c, i) : k === i))) ? [c] : []);
                    const selectedColFields = selectedFieldCols.map(c => c.field);
                    this.targetColField = selectedColFields[0];
                    result.dataString = data.flatMap(item => {
                        const itemString = this.itemToString(item.dataItem, selectedFieldCols);
                        const existingItem = isPresent$1(itemString);
                        if (!isPresent$1(this.targetRowIndex) && isPresent$1(itemString)) {
                            this.targetRowIndex = item.dataRowIndex;
                        }
                        if (options.operationType === 'cut') {
                            selectedColFields.forEach(f => item.dataItem[f] = null);
                        }
                        result.gridItems.push({
                            dataItem: item.dataItem,
                            fields: selectedColFields
                        });
                        return existingItem ? [itemString] : [];
                    }).join(`\r\n`);
                    if (options.copyHeaders) {
                        result.dataString = this.addHeaders(result.dataString, selectedFieldCols);
                    }
                }
                else { // split per row (uneven rows)
                    const rowIdentifier = selectionDirective.selectionKey;
                    result.dataString = data.flatMap(item => {
                        // determine cols per item
                        const key = rowIdentifier ?
                            typeof rowIdentifier === 'string' ? item.dataItem[rowIdentifier] : rowIdentifier({ index: item.dataRowIndex, dataItem: item.dataItem }) :
                            item.dataRowIndex;
                        const selectionKeys = groups.find(gr => gr.value === key).items.map(item => item.columnKey);
                        const selectedFieldCols = columns.flatMap((c, i) => (c instanceof ColumnComponent && c.field) && isPresent$1(selectionKeys.find(k => typeof colIdentifier === 'function' ? k === colIdentifier(c, i) : k === i)) ? [c] : []);
                        const selectedColFields = selectedFieldCols.map(c => c.field);
                        if (!this.targetColField) {
                            this.targetColField = selectedColFields[0];
                        }
                        const itemString = this.itemToString(item.dataItem, selectedFieldCols);
                        const existingItem = isPresent$1(itemString);
                        if (!isPresent$1(this.targetRowIndex) && existingItem) {
                            this.targetRowIndex = item.dataRowIndex;
                        }
                        if (existingItem) {
                            if (options.operationType === 'cut') {
                                selectedColFields.forEach(f => item.dataItem[f] = null);
                            }
                            result.gridItems.push({
                                dataItem: item.dataItem,
                                fields: selectedColFields
                            });
                        }
                        return existingItem ? options.copyHeaders ? [this.addHeaders(itemString, selectedFieldCols)] : [itemString] : [];
                    }).join(`\r\n`);
                }
            }
            else {
                const item = data[0];
                const col = columns[item.colIndex];
                const colField = col.field;
                const title = col.title;
                const copiedData = item.dataItem[colField];
                this.targetRowIndex = item.dataRowIndex;
                this.targetColField = colField;
                if (options.operationType === 'cut' && colField) {
                    item.dataItem[colField] = null;
                }
                result = {
                    gridItems: [{
                            dataItem: item.dataItem,
                            fields: colField ? [colField] : []
                        }],
                    dataString: options.copyHeaders ? [title || colField, copiedData].join(`\r\n`) : colField ? copiedData : ``
                };
            }
        }
        return result;
    }
    getGridData(data, columns, targetType, targetRowIndex, options) {
        const separator = data.includes(`\r\n`) ? `\r\n` : data.includes(`\n`) ? `\n` : null;
        const dataRows = separator ? data.split(separator).filter(rowData => rowData.length) : [data];
        this.targetRowIndex = targetRowIndex;
        if (targetType === 'activeCell') {
            if (options.wholeRow) {
                this.targetColField = columns.find(c => c instanceof ColumnComponent && c.field)?.field;
            }
            else {
                const activeCellIndex = this.contextService.grid.activeCell.colIndex;
                for (let i = 0; i < columns.length; i++) {
                    const col = columns[i];
                    if (col instanceof ColumnComponent && col.field && i >= activeCellIndex) {
                        this.targetColField = col.field;
                        break;
                    }
                }
            }
        }
        else {
            if (options.wholeRow || !options.isCellSelection) {
                this.targetColField = (columns.filter(c => c instanceof ColumnComponent && c.field))[0]['field'];
            }
            else {
                const { groups } = this.groupSelection();
                const selectionDirective = this.contextService.grid.selectionDirective;
                const colIdentifier = selectionDirective.columnKey;
                const visibleCols = columns.filter(c => c.isVisible);
                const selectionKeys = groups[0].items.map(item => item.columnKey);
                const selectedFieldCols = visibleCols.flatMap((c, i) => (c instanceof ColumnComponent && c.field) && isPresent$1(selectionKeys.find(k => typeof colIdentifier === 'function' ? k === colIdentifier(c, i) : k === i)) ? [c] : []);
                const selectedColFields = selectedFieldCols.map(c => c.field);
                this.targetColField = selectedColFields[0];
            }
        }
        const items = dataRows.map(rowString => {
            const cells = rowString.includes(`\t`) ? rowString.split(`\t`) : [rowString];
            const colFields = columns.flatMap(c => (c instanceof ColumnComponent) && c.field ? [c.field] : []);
            const targetColFieldIndex = colFields.indexOf(this.targetColField);
            const affectedFields = colFields.slice(targetColFieldIndex, targetColFieldIndex + cells.length);
            const item = {};
            colFields.slice(targetColFieldIndex, targetColFieldIndex + cells.length).forEach((colField, index) => item[colField] = cells[index]);
            return {
                dataItem: item,
                fields: affectedFields
            };
        });
        return items;
    }
    itemToString = (item, cols) => {
        if (!cols.length) {
            return null;
        }
        return cols.map(col => item[col.field]).join(`\t`);
    };
    groupSelection() {
        const selection = this.contextService.grid.selection;
        const groups = groupBy(selection, [{ field: 'itemKey' }])
            .map(gr => {
            gr.items.sort((a, b) => a.columnKey - b.columnKey);
            return gr;
        });
        for (let i = 1; i < groups.length; i++) {
            if (!this.areEqual(groups[i].items, groups[i - 1].items)) {
                return {
                    tabular: false,
                    groups
                };
            }
        }
        return {
            tabular: true,
            groups
        };
    }
    areEqual(arr1, arr2) {
        if (arr1.length !== arr2.length) {
            return false;
        }
        for (let i = 0; i < arr1.length; i++) {
            if (arr1[i].columnKey !== arr2[i].columnKey) {
                return false;
            }
        }
        return true;
    }
    addHeaders(initialData, cols) {
        const headersRowData = cols.map(c => c.title || c.field).join(`\t`);
        return `${headersRowData}\r\n${initialData}`;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ClipboardService, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ClipboardService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ClipboardService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: ContextService }] });

/**
 * @hidden
 */
class StatusBarComponent {
    aggregateService;
    hostClasses = true;
    get isStatusBarTemplate() {
        return this.statusBarTemplate ? '' : 'none';
    }
    hostAriaLive = 'polite';
    statusBarTemplate;
    constructor(aggregateService) {
        this.aggregateService = aggregateService;
    }
    ngOnInit() {
        this.aggregateService.init();
    }
    get aggregates() {
        return this.aggregateService.aggregates;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: StatusBarComponent, deps: [{ token: CellSelectionAggregateService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: StatusBarComponent, isStandalone: true, selector: "kendo-grid-status-bar", inputs: { statusBarTemplate: "statusBarTemplate" }, host: { properties: { "class.k-selection-aggregates": "this.hostClasses", "class.k-grid-selection-aggregates": "this.hostClasses", "style.display": "this.isStatusBarTemplate", "attr.aria-live": "this.hostAriaLive" } }, ngImport: i0, template: `
        @if (statusBarTemplate) {
          <ng-template
            [ngTemplateOutlet]="statusBarTemplate?.templateRef"
            [ngTemplateOutletContext]="{ aggregates: aggregates }">
          </ng-template>
        }
        `, isInline: true, dependencies: [{ kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: StatusBarComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-status-bar',
                    template: `
        @if (statusBarTemplate) {
          <ng-template
            [ngTemplateOutlet]="statusBarTemplate?.templateRef"
            [ngTemplateOutletContext]="{ aggregates: aggregates }">
          </ng-template>
        }
        `,
                    standalone: true,
                    imports: [NgTemplateOutlet]
                }]
        }], ctorParameters: () => [{ type: CellSelectionAggregateService }], propDecorators: { hostClasses: [{
                type: HostBinding,
                args: ['class.k-selection-aggregates']
            }, {
                type: HostBinding,
                args: ['class.k-grid-selection-aggregates']
            }], isStatusBarTemplate: [{
                type: HostBinding,
                args: ['style.display']
            }], hostAriaLive: [{
                type: HostBinding,
                args: ['attr.aria-live']
            }], statusBarTemplate: [{
                type: Input
            }] } });

const createElement = () => {
    if (!isDocumentAvailable()) {
        return;
    }
    const marquee = document.createElement("div");
    marquee.className = "k-marquee";
    const marqueeColor = document.createElement("div");
    marqueeColor.className = "k-marquee-color";
    marquee.appendChild(marqueeColor);
    return marquee;
};
const POINTER_OFFSET = 2;
const MINIMAL_DRAG_DISTANCE = 5;
const offsets = {
    topLeft: { x: POINTER_OFFSET, y: POINTER_OFFSET },
    topRight: { x: -POINTER_OFFSET, y: POINTER_OFFSET },
    bottomLeft: { x: POINTER_OFFSET, y: -POINTER_OFFSET },
    bottomRight: { x: -POINTER_OFFSET, y: -POINTER_OFFSET }
};
/**
 * @hidden
 */
class GridMarqueeDirective {
    draggable;
    selection;
    cellSelection;
    domEvents;
    host;
    renderer;
    // possibly add snap
    pressArgs;
    marqueeElement;
    pressTarget;
    subscriptions;
    selectionStarted = false;
    dragEndSubscription;
    constructor(draggable, selection, cellSelection, domEvents, host, renderer) {
        this.draggable = draggable;
        this.selection = selection;
        this.cellSelection = cellSelection;
        this.domEvents = domEvents;
        this.host = host;
        this.renderer = renderer;
    }
    ngOnInit() {
        this.subscriptions = (this.draggable.kendoPress.subscribe(this.start.bind(this)));
        this.subscriptions.add(this.draggable.kendoDrag.subscribe(this.moveMarquee.bind(this)));
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
        this.clean();
    }
    start(args) {
        const isInvalidTarget = args.originalEvent.target.matches('.k-grid-content, .k-grid-content-locked, .k-grid-aria-root, .k-checkbox');
        const isRowReorderColumn = isPresent$1(args.originalEvent.target.closest('.k-drag-cell'));
        if (isInvalidTarget || isRowReorderColumn) {
            this.pressArgs = null;
            return;
        }
        this.pressArgs = args;
        this.pressTarget = null;
    }
    moveMarquee(args) {
        if (!this.pressTarget) {
            this.pressTarget = this.cellSelection.active ? this.cellSelection.mouseDownEventArgs : this.selection.mouseDownEventArgs;
        }
        const press = this.pressArgs;
        if (!press) {
            return;
        }
        if (!this.selectionStarted) {
            const distance = Math.sqrt((args.pageX - press.pageX) ** 2 + (args.pageY - press.pageY) ** 2);
            if (distance > MINIMAL_DRAG_DISTANCE) {
                this.selectionStarted = true;
                this.renderer.addClass(this.host.nativeElement, 'user-select-none');
                this.renderer.setStyle(this.host.nativeElement, 'user-select', 'none');
                this.dragEndSubscription = merge(this.domEvents.cellMouseup.pipe(take(1)), this.draggable.kendoRelease.pipe(delay(1), take(1)))
                    .subscribe(this.endSelection.bind(this));
            }
            else {
                return;
            }
        }
        this.initMarquee();
        const element = this.marqueeElement;
        const marqueeQuadrant = this.getMarqueeQuadrant(args.pageX, args.pageY, press.pageX, press.pageY);
        let left = Math.min(args.pageX, press.pageX);
        let top = Math.min(args.pageY, press.pageY);
        const width = Math.abs(args.pageX - press.pageX);
        const height = Math.abs(args.pageY - press.pageY);
        if (marqueeQuadrant) {
            left += offsets[marqueeQuadrant].x;
            top += offsets[marqueeQuadrant].y;
        }
        element.style.left = `${left}px`;
        element.style.top = `${top}px`;
        element.style.width = `${width}px`;
        element.style.height = `${height}px`;
    }
    endSelection(args) {
        if (args.type === 'mouseup' || args.type === 'touchend') {
            const modifier = args.originalEvent.ctrlKey || args.originalEvent.metaKey;
            const preserveCurrentSelection = modifier &&
                (isMultipleRangesEnabled(this.selection.settings) ||
                    isMultipleRangesEnabled(this.cellSelection.settings));
            if (this.cellSelection.active) {
                this.cellSelection.dragging = true;
                this.cellSelection.changes.emit(this.cellSelection.selectRange(this.pressTarget.rowIndex, this.pressTarget.column.leafIndex, args.rowIndex, args.column.leafIndex, preserveCurrentSelection));
            }
            else if (this.selection.active) {
                this.selection.dragging = true;
                this.selection.changes.emit(this.selection.selectRange(this.pressTarget.rowIndex, args.rowIndex, preserveCurrentSelection));
            }
        }
        this.clean();
    }
    clean() {
        if (this.marqueeElement) {
            document.body.removeChild(this.marqueeElement);
            this.marqueeElement = null;
        }
        if (this.dragEndSubscription) {
            this.dragEndSubscription.unsubscribe();
        }
        this.renderer.removeClass(this.host.nativeElement, 'user-select-none');
        this.renderer.removeStyle(this.host.nativeElement, 'user-select');
        this.dragEndSubscription = null;
        this.pressTarget = null;
        this.pressArgs = null;
        this.selectionStarted = false;
        // eslint-disable-next-line no-unused-expressions
        this.cellSelection.active ? this.cellSelection.dragging = false : this.selection.dragging = false;
    }
    initMarquee() {
        if (!isDocumentAvailable()) {
            return;
        }
        if (!this.marqueeElement) {
            this.marqueeElement = createElement();
            document.body.appendChild(this.marqueeElement);
        }
    }
    getMarqueeQuadrant(pointerX, pointerY, startX, startY) {
        const leftHalf = pointerX < startX;
        const rightHalf = pointerX > startX;
        const topHalf = pointerY < startY;
        const bottomHalf = pointerY > startY;
        if (leftHalf && topHalf) {
            return 'topLeft';
        }
        if (leftHalf && bottomHalf) {
            return 'bottomLeft';
        }
        if (rightHalf && topHalf) {
            return 'topRight';
        }
        if (rightHalf && bottomHalf) {
            return 'bottomRight';
        }
        return null;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GridMarqueeDirective, deps: [{ token: i1$3.DraggableDirective }, { token: SelectionService }, { token: CellSelectionService }, { token: DomEventsService }, { token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: GridMarqueeDirective, isStandalone: true, selector: "[kendoGridSelectionMarquee]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GridMarqueeDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridSelectionMarquee]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1$3.DraggableDirective }, { type: SelectionService }, { type: CellSelectionService }, { type: DomEventsService }, { type: i0.ElementRef }, { type: i0.Renderer2 }] });

/**
 * @hidden
 */
class RowHeightService {
    total;
    offsets = [];
    heights = [];
    constructor(total = 0, rowHeight) {
        this.total = total;
        let agg = 0;
        for (let idx = 0; idx < total; idx++) {
            this.offsets.push(agg);
            agg += rowHeight;
            this.heights.push(rowHeight);
        }
    }
    height(rowIndex) {
        return this.heights[rowIndex];
    }
    index(position) {
        for (let i = 0; i < this.offsets.length; i++) {
            if (position === this.offsets[i]) {
                return i;
            }
            if (position < this.offsets[i]) {
                return i - 1;
            }
        }
        return this.total - 1;
    }
    offset(rowIndex) {
        return this.offsets[rowIndex];
    }
    totalHeight() {
        if (!this.offsets.length) {
            return 0;
        }
        const lastOffset = this.offsets[this.offsets.length - 1];
        const lastHeight = this.heights[this.heights.length - 1];
        return lastOffset + lastHeight;
    }
    update(startIndex, rowHeights) {
        let agg = this.offsets[startIndex];
        for (let i = startIndex; i < this.heights.length; i++) {
            this.offsets[i] = agg;
            const currHeight = rowHeights[i - startIndex] || this.heights[i];
            agg += currHeight;
            this.heights[i] = currHeight;
        }
    }
}

/**
 * @hidden
 */
class ScrollAction {
    offset;
    changeVirtualData;
    constructor(offset, changeVirtualData) {
        this.offset = offset;
        this.changeVirtualData = changeVirtualData;
    }
}
/**
 * @hidden
 */
class PageAction {
    skip;
    take;
    constructor(skip, take) {
        this.skip = skip;
        this.take = take;
    }
}
/**
 * @hidden
 */
class ScrollBottomAction {
}
const SCROLL_BOTTOM_THRESHOLD = 2;
/**
 * @hidden
 */
class ScrollerService {
    scrollObservable;
    ctx;
    total = 0;
    rowHeightService;
    table = null;
    lockedTable = null;
    tableBody = null;
    container = null;
    scrollHeightContainer = null;
    scrollableVirtual = false;
    tableTransformOffset = 0;
    virtualSkip = 0;
    virtualPageSize = 0;
    firstToLoad = 0;
    lastLoaded = 0;
    scrollSyncing = false;
    scrollSubscription;
    subscription;
    lastScrollTop = 0;
    firstLoaded = 0;
    expandedRows = {};
    take;
    constructor(scrollObservable, ctx) {
        this.scrollObservable = scrollObservable;
        this.ctx = ctx;
    }
    create(rowHeightService, skip, take, total) {
        this.rowHeightService = rowHeightService;
        this.firstLoaded = skip;
        this.lastLoaded = skip + take;
        this.take = take;
        this.total = total;
        this.lastScrollTop = 0;
        const offset = this.rowHeightService.offset(skip);
        const subject = new BehaviorSubject(new ScrollAction(offset, this.scrollableVirtual && (Boolean(this.ctx.grid?.pageable) || Boolean(this.ctx.grid?.group?.length))));
        this.subscription = Observable.create(observer => {
            this.unsubscribe();
            this.scrollSubscription = this.scrollObservable.subscribe(x => this.onScroll(x, observer));
        }).subscribe(x => subject.next(x));
        return subject;
    }
    reset(skipScroll = false) {
        if (!skipScroll) {
            this.firstToLoad = 0;
            this.firstLoaded = 0;
            this.lastLoaded = 0;
            this.virtualSkip = 0;
        }
        this.rowHeightService = undefined;
        if (skipScroll) {
            this.scrollSyncing = true;
        }
        if (!skipScroll && this.container && this.container.scrollTop !== 0) {
            this.scrollSyncing = true;
            this.container.scrollTop = 0;
            this.lastScrollTop = 0;
            this.translate(0, true);
            this.tableTransformOffset = 0;
        }
    }
    update(skipAdjust = false) {
        const itemHeights = this.getItemHeights();
        if (this.firstLoaded > this.firstToLoad) {
            // Scrolled up
            const count = Math.min(this.firstLoaded - this.firstToLoad, this.take);
            const newItemsHeight = this.getTotalHeight(count, itemHeights);
            const newItemsExpectedHeight = this.getExpectedTotalHeight(count);
            const diff = newItemsHeight - newItemsExpectedHeight;
            if (!skipAdjust && diff !== 0) {
                this.adjustScroll(diff);
            }
        }
        this.rowHeightService?.update(this.firstToLoad, itemHeights);
        this.scrollHeightContainer && this.setScrollHeightContainerHeight();
        this.firstLoaded = this.firstToLoad;
        this.lastLoaded = this.firstLoaded + itemHeights.length - 1;
    }
    destroy() {
        this.unsubscribe();
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
    onScroll({ scrollTop, offsetHeight, scrollHeight, clientHeight }, observer) {
        if (this.scrollSyncing) {
            this.scrollSyncing = false;
            return;
        }
        if (!isDocumentAvailable() || (this.lastScrollTop === scrollTop)) {
            return;
        }
        const up = this.lastScrollTop >= scrollTop;
        const down = !up;
        this.lastScrollTop = scrollTop;
        let firstItemIndex = this.rowHeightService.index(scrollTop);
        const lastItemIndex = this.rowHeightService.index(scrollTop + offsetHeight);
        const overflow = Math.max(firstItemIndex + (this.virtualPageSize || this.take) - this.total, 0);
        firstItemIndex = Math.max(firstItemIndex - overflow, 0);
        if (down) {
            const atBottom = scrollHeight - clientHeight - scrollTop < SCROLL_BOTTOM_THRESHOLD;
            if (atBottom) {
                observer.next(new ScrollBottomAction());
            }
        }
        if (!this.scrollableVirtual) {
            return;
        }
        if (down && lastItemIndex >= this.lastLoaded && this.lastLoaded < this.total - 1) {
            this.firstToLoad = firstItemIndex;
            this.loadPage(observer);
        }
        else if (up && firstItemIndex < this.firstLoaded) {
            const nonVisibleBuffer = Math.max(Math.floor((this.virtualPageSize || this.take) * 0.3) - overflow, 0);
            this.firstToLoad = Math.max(firstItemIndex - nonVisibleBuffer, 0);
            this.loadPage(observer);
        }
    }
    loadPage(observer) {
        if (!this.rowHeightService) {
            return;
        }
        this.translate(this.rowHeightService.offset(this.firstToLoad));
        observer.next(new ScrollAction(this.rowHeightService.offset(this.firstToLoad)));
        this.virtualPageChange(this.firstToLoad, observer);
    }
    unsubscribe() {
        if (this.scrollSubscription) {
            this.scrollSubscription.unsubscribe();
            this.scrollSubscription = undefined;
        }
    }
    translate(dY, forceSet) {
        if (this.scrollableVirtual && this.table) {
            if (forceSet) {
                this.table.style.transform = 'translateY(' + dY + 'px)';
                if (this.lockedTable) {
                    this.lockedTable.style.transform = 'translateY(' + dY + 'px)';
                }
            }
            else {
                this.tableTransformOffset = dY;
            }
        }
    }
    adjustScroll(scrollOffset, initialAdjust = false) {
        if (Number.isNaN(scrollOffset)) {
            return;
        }
        this.scrollSyncing = true;
        if (this.container) {
            if (initialAdjust) {
                this.container.scrollTop = scrollOffset;
                this.translate(scrollOffset, true);
                this.tableTransformOffset = scrollOffset;
                this.firstToLoad = this.rowHeightService.index(scrollOffset);
            }
            else {
                this.container.scrollTop += scrollOffset;
            }
        }
    }
    isExpanded(rowIndex) {
        return this.expandedRows[rowIndex] || false;
    }
    resetVirtualSkip = () => {
        if (this.scrollableVirtual && this.virtualSkip) {
            this.virtualSkip = 0;
        }
    };
    setScrollHeightContainerHeight() {
        if (this.scrollableVirtual) {
            let containerHeight = this.rowHeightService?.totalHeight() || 0;
            containerHeight = isFirefox ? Math.min(firefoxMaxHeight, containerHeight) : containerHeight;
            this.scrollHeightContainer.style.height = containerHeight + 'px';
        }
        else {
            this.scrollHeightContainer.style.height = '0';
        }
    }
    getItemHeights() {
        const result = [];
        if (this.tableBody) {
            Array.from(this.tableBody.children).forEach((item, index) => {
                const itemHeight = item.getBoundingClientRect().height;
                if (item.classList.contains('k-detail-row')) {
                    result[result.length - 1] += itemHeight;
                    this.expandedRows[index] = true;
                }
                else {
                    result.push(itemHeight);
                }
            });
        }
        return result;
    }
    getTotalHeight(count, itemHeights) {
        return itemHeights.slice(0, count).reduce((sum, current) => sum + current, 0);
    }
    getExpectedTotalHeight(count) {
        const service = this.rowHeightService;
        if (!service) {
            return 0;
        }
        const lastItemIndex = this.firstToLoad + (count - 1);
        return service.offset(lastItemIndex) + service.height(lastItemIndex) - service.offset(this.firstToLoad);
    }
    virtualPageChange = (skip, observer) => {
        if (this.ctx.grid.pageable || this.ctx.grid.group?.length) {
            this.virtualSkip = skip;
            observer.next(new ScrollAction(this.rowHeightService?.offset(skip) || 0, true));
        }
        else if (skip !== this.ctx.grid.skip) {
            observer.next(new PageAction(Math.max(0, skip), this.take));
        }
    };
}

/**
 * @hidden
 */
const columnsToResize = ({ columns }) => Math.max(1, resizableColumns(columns).filter(c => !c.isColumnGroup).length);
/**
 * @hidden
 */
const row = selector => element => element.querySelector(selector);
/**
 * @hidden
 */
const headerRow = index => element => element.querySelectorAll('thead>tr')[index];
/**
 * @hidden
 */
const cell = (index, selector = 'td') => element => element.querySelectorAll(`${selector}:not(.k-group-cell):not(.k-hierarchy-cell)`)[index];
/**
 * @hidden
 */
const offsetWidth = element => element.offsetWidth;
/**
 * @hidden
 */
const pipe = (...fns) => data => fns.reduce((state, fn) => state ? fn(state) : 0, data);
/**
 * @hidden
 */
class TableDirective {
    element;
    renderer;
    service;
    zone;
    cdr;
    ctx;
    locked = false;
    virtualColumns;
    get minWidth() {
        return this.firstResize ? 0 : null;
    }
    firstResize = false;
    subscription;
    autoFitSubscription;
    constructor(element, renderer, service, zone, cdr, ctx) {
        this.element = element;
        this.renderer = renderer;
        this.service = service;
        this.zone = zone;
        this.cdr = cdr;
        this.ctx = ctx;
    }
    ngOnInit() {
        const obs = this.service
            .changes.pipe(filter(e => this.locked === e.locked));
        this.subscription = obs.pipe(filter(e => e.type === 'start'), tap(this.initState.bind(this)), map(columnsToResize), switchMap((take) => obs.pipe(filter(e => e.type === 'resizeTable'), map(e => e.delta), bufferCount(take)))).subscribe(this.resize.bind(this));
        this.autoFitSubscription = this.service
            .registerTable({
            autoFit: this.autoFitObservable.bind(this),
            locked: this.locked
        });
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        if (this.autoFitSubscription) {
            this.autoFitSubscription();
            this.autoFitSubscription = null;
        }
    }
    initState() {
        this.firstResize = true;
        const constrainedWithVirtualColumns = this.ctx.grid?.resizable === 'constrained' && this.virtualColumns;
        if ((!this.virtualColumns || this.locked) || constrainedWithVirtualColumns) {
            this.service.originalWidth = offsetWidth(this.element.nativeElement);
        }
    }
    resize(deltas) {
        const constrainedModeNoShift = this.ctx.grid?.resizable === 'constrained' && !this.service.isShiftPressed;
        const unconstrainedModeShift = (this.ctx.grid?.resizable === true || this.ctx.grid?.resizable === 'unconstrained') && this.service.isShiftPressed;
        const isConstrainedMode = constrainedModeNoShift || unconstrainedModeShift;
        if (isConstrainedMode && !this.service.autoFitResize) {
            this.renderer.setStyle(this.element.nativeElement, 'width', this.service.originalWidth + 'px');
        }
        else if (!this.virtualColumns || this.locked) {
            const delta = deltas.reduce((sum, item) => sum + item, 0);
            const width = this.service.originalWidth + delta;
            this.renderer.setStyle(this.element.nativeElement, 'width', width + 'px');
        }
        this.cdr.detectChanges();
    }
    autoFitObservable(columnInfo) {
        return Observable.create(observer => {
            this.zone.runOutsideAngular(() => {
                this.renderer.addClass(this.element.nativeElement, 'k-autofitting');
                this.cdr.detectChanges();
                const widths = columnInfo.map(this.measureColumn.bind(this));
                this.renderer.removeClass(this.element.nativeElement, 'k-autofitting');
                observer.next(widths);
            });
        });
    }
    measureColumn(info) {
        const dom = this.element.nativeElement;
        const header = pipe(headerRow(info.level), cell(info.headerIndex, 'th'), offsetWidth)(dom);
        let data = 0;
        if (!info.isParentSpan || (info.isParentSpan && info.isLastInSpan)) {
            data = pipe(row('tbody>tr:not(.k-grouping-row):not(.k-grid-norecords)'), cell(info.index), offsetWidth)(dom);
        }
        const footer = pipe(row('tfoot>tr'), cell(info.index), offsetWidth)(dom);
        return Math.max(header, data, footer);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TableDirective, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }, { token: ColumnResizingService }, { token: i0.NgZone }, { token: i0.ChangeDetectorRef }, { token: ContextService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: TableDirective, isStandalone: true, selector: "[kendoGridResizableTable]", inputs: { locked: "locked", virtualColumns: "virtualColumns" }, host: { properties: { "style.min-width": "this.minWidth" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridResizableTable]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: ColumnResizingService }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }, { type: ContextService }], propDecorators: { locked: [{
                type: Input
            }], virtualColumns: [{
                type: Input
            }], minWidth: [{
                type: HostBinding,
                args: ['style.min-width']
            }] } });

/**
 * @hidden
 */
class RowspanService {
    skipCells = [];
    addCells(rowIndex, colIndex, rowspan) {
        for (let i = 1; i < rowspan; i++) {
            if (!this.skipCells.some(this.cellExists(rowIndex + i, colIndex))) {
                this.skipCells.push({ rowIndex: rowIndex + i, colIndex });
            }
        }
    }
    reset() {
        this.skipCells = [];
    }
    shouldSkip(rowIndex, colIndex) {
        return !!this.skipCells.find(this.cellExists(rowIndex, colIndex));
    }
    cellExists = (rowIndex, colIndex) => cell => cell.rowIndex === rowIndex && cell.colIndex === colIndex;
}

/**
 * @hidden
 */
class DataMappingService {
    rowspanService;
    groupsService;
    detailsService;
    ctx;
    recalculateRowspan = true;
    dataArray = null;
    constructor(rowspanService, groupsService, detailsService, ctx) {
        this.rowspanService = rowspanService;
        this.groupsService = groupsService;
        this.detailsService = detailsService;
        this.ctx = ctx;
    }
    isGroup(item) {
        return item.type === 'group';
    }
    /**
     * Maps the data to the Grid row items, applying rowspan and detail row logic.
     */
    dataMapper(data, nonLockedColumnsToRender, lockedLeafColumns, detailTemplate, showFooter) {
        const result = [];
        if (!data || !nonLockedColumnsToRender && !lockedLeafColumns) {
            return [];
        }
        let dataIndex = 0;
        for (const item of data) {
            if (this.shouldRenderItem(item, detailTemplate, showFooter)) {
                if (item.type === 'data') {
                    item.cells = [];
                    for (let i = 0; i < (lockedLeafColumns.length + nonLockedColumnsToRender.length); i++) {
                        const column = i < lockedLeafColumns.length ? lockedLeafColumns.get(i) : nonLockedColumnsToRender.get(i - lockedLeafColumns.length);
                        const cell = {};
                        if (column.cellRowspan && this.shouldSkipCell(dataIndex, i)) {
                            cell.skip = true;
                        }
                        else {
                            cell.rowspan = column.cellRowspan ? this.getRowspan({
                                index: dataIndex,
                                dataItem: item
                            }, column, i, data) : 1;
                        }
                        if (isPresent$1(this.ctx.highlightDirective)) {
                            cell.isHighlighted = this.ctx.highlightDirective.isCellHighlighted(item, column, i);
                        }
                        item.cells.push(cell);
                    }
                    if (isPresent$1(this.ctx.highlightDirective)) {
                        item.isHighlighted = this.ctx.highlightDirective.isRowHighlighted(item);
                    }
                }
                result.push(item);
            }
            dataIndex++;
        }
        this.recalculateRowspan = true;
        this.rowspanService.reset();
        return result;
    }
    isDataItem(item) {
        return !this.isGroup(item) && !this.isFooter(item);
    }
    isFooter(item) {
        return item.type === 'footer';
    }
    isFooterItemInExpandedGroup(item) {
        const footerItem = { data: item.data, index: item.groupIndex, parentGroup: item.group.parentGroup };
        return this.isInExpandedGroup(footerItem);
    }
    isDataItemInExpandedGroup(item) {
        const dataItem = { data: item.group.data, index: item.groupIndex, parentGroup: item.group.parentGroup };
        return this.isInExpandedGroup(dataItem);
    }
    isInExpandedGroup(item) {
        return this.groupsService.isInExpandedGroup(item);
    }
    isParentGroupExpanded(item) {
        return this.groupsService.isInExpandedGroup(item.parentGroup);
    }
    isExpanded(viewItem) {
        return this.detailsService.isExpanded(viewItem.index, viewItem.data);
    }
    shouldRenderItem(item, detailTemplate, showFooter) {
        const renderGroupHeader = this.isGroup(item) && this.isParentGroupExpanded(item);
        const renderDataItem = this.isDataItem(item) && (!item.group || this.isDataItemInExpandedGroup(item));
        const renderDetailTemplate = renderDataItem && detailTemplate?.templateRef && detailTemplate.showIf(item.data, item.index) && this.isExpanded(item);
        const isVisibleFooter = this.isFooter(item) && item.group && (this.isFooterItemInExpandedGroup(item) || (showFooter && this.isParentGroupExpanded(item.group)));
        const renderFooter = isVisibleFooter && !item.data.hideFooter;
        item.showDataItem = renderDataItem;
        item.showDetailRow = renderDataItem && renderDetailTemplate;
        item.isExpanded = this.isExpanded(item);
        return renderGroupHeader || renderDataItem || renderDetailTemplate || renderFooter;
    }
    shouldSkipCell(rowIndex, colIndex) {
        return this.rowspanService.shouldSkip(rowIndex, colIndex);
    }
    cachedDataArray(data) {
        if (!this.dataArray) {
            this.dataArray = data.map(item => item);
        }
        return this.dataArray;
    }
    getRowspan(row, column, colIndex, data) {
        if (this.recalculateRowspan) {
            this.dataArray = null;
            this.recalculateRowspan = false;
        }
        const rowspan = column.cellRowspan(row, column, this.cachedDataArray(data));
        if (rowspan > 1) {
            this.rowspanService.addCells(row.index, colIndex, rowspan);
        }
        return rowspan;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DataMappingService, deps: [{ token: RowspanService }, { token: GroupsService }, { token: DetailsService }, { token: ContextService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DataMappingService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DataMappingService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: RowspanService }, { type: GroupsService }, { type: DetailsService }, { type: ContextService }] });

const elementAt = (index, elements, elementOffset) => {
    for (let idx = 0, elementIdx = 0; idx < elements.length; idx++) {
        const offset = elementOffset(elements[idx]);
        if (elementIdx <= index && index <= elementIdx + offset - 1) {
            return elements[idx];
        }
        elementIdx += offset;
    }
};
const rowAt = (index, rows) => elementAt(index, rows, () => 1);
const cellAt = (index, cells) => elementAt(index, cells, cell => !hasClasses(cell, NON_DATA_CELL_CLASSES) ? parseInt(cell.getAttribute('colSpan'), 10) || 1 : 0);
const EMPTY_OBJECT = {};
/**
 * @hidden
 */
const SCROLLER_FACTORY_TOKEN = new InjectionToken('grid-scroll-service-factory');
/**
 * @hidden
 */
function DEFAULT_SCROLLER_FACTORY(observable, ctx) {
    return new ScrollerService(observable, ctx);
}
const wheelDeltaY = (e) => {
    const deltaY = e.wheelDeltaY;
    if (e.wheelDelta && (deltaY === undefined || deltaY)) {
        return e.wheelDelta;
    }
    else if (e.detail && e.axis === e.VERTICAL_AXIS) {
        return (-e.detail) * 10;
    }
    return 0;
};
const preventLockedScroll = (args, element) => {
    const delta = wheelDeltaY(args);
    const scrollTop = element.scrollTop;
    const allowScroll = (scrollTop === 0 && 0 < delta) || (element.scrollHeight <= element.offsetHeight + scrollTop && delta < 0);
    if (!allowScroll) {
        args.preventDefault();
    }
};
const translateY = (renderer, value) => el => renderer.setStyle(el, "transform", `translateY(${value}px)`);
const maybeNativeElement = el => el ? el.nativeElement : null;
const hasScrollbar = (el, parent) => el.nativeElement.offsetWidth > parent.nativeElement.clientWidth;
const setHeight = renderer => ({ el, height }) => renderer.setStyle(el, "height", `${height}px`);
const bufferSize = 1;
/**
 * @hidden
 */
class ListComponent {
    changeNotification;
    suspendService;
    groupsService;
    ngZone;
    renderer;
    scrollSyncService;
    resizeService;
    editService;
    supportService;
    navigationService;
    ctx;
    columnResizingService;
    changeDetector;
    pdfService;
    columnInfo;
    dataMappingService;
    hostClass = true;
    hostRole = 'presentation';
    data;
    groups = [];
    total;
    rowHeight;
    detailRowHeight;
    take;
    skip = 0;
    columns = new ColumnsContainer(() => []);
    detailTemplate;
    noRecordsTemplate;
    selectable = false;
    groupable = false;
    filterable;
    rowClass;
    rowSticky;
    loading;
    trackBy = defaultTrackBy;
    virtualColumns;
    isVirtual;
    cellLoadingTemplate;
    loadingTemplate;
    sort = new Array();
    size = 'medium';
    contentScroll = new EventEmitter();
    pageChange = new EventEmitter();
    scrollBottom = new EventEmitter();
    columnsStartIdx = 0;
    allItems = [];
    itemsToRender = [];
    get showFooter() {
        return this.groupable && this.groupable.showFooter;
    }
    get totalWidth() {
        if (this.virtualColumns && this.columns.unlockedWidth) {
            return this.columns.unlockedWidth;
        }
    }
    container;
    lockedContainer;
    lockedTable;
    table;
    resizeSensors = new QueryList();
    scroller;
    subscriptions;
    scrollerSubscription;
    dispatcher = new Subject();
    rowHeightService;
    skipScroll;
    rebind;
    containerScrollTop = 0;
    viewportColumns;
    columnsEndIdx;
    viewportColumnsWidth;
    scrollLeft = 0;
    virtualPageSize;
    observer;
    get lockedLeafColumns() {
        return this.columns.lockedLeafColumns;
    }
    get nonLockedLeafColumns() {
        return this.columns.nonLockedLeafColumns;
    }
    get nonLockedColumnsToRender() {
        if (this.virtualColumns && !this.pdfService.exporting && !this.isStacked) {
            return this.viewportColumns;
        }
        return this.nonLockedLeafColumns;
    }
    get leafColumns() {
        return this.columns.leafColumnsToRender;
    }
    get lockedWidth() {
        const groupCellsWidth = this.groups.length * GROUP_CELL_WIDTH;
        return expandColumns(this.lockedLeafColumns.toArray()).reduce((prev, curr) => prev + (curr.width || 0), groupCellsWidth);
    }
    get nonLockedWidth() {
        if (((!this.rtl && this.lockedLeafColumns.length) || this.virtualColumns) && !this.isStacked) {
            return sumColumnWidths(expandColumns(this.nonLockedColumnsToRender.toArray()));
        }
        return undefined;
    }
    get isLocked() {
        return this.lockedLeafColumns.length > 0 && !this.isStacked;
    }
    rtl = false;
    columnUpdateFrame;
    hasLockedContainer;
    minRowHeight;
    handleSkipOnData = false;
    scrollToIndex = null;
    constructor(scrollerFactory, detailsService, changeNotification, suspendService, groupsService, ngZone, renderer, scrollSyncService, resizeService, editService, supportService, navigationService, scrollRequestService, ctx, columnResizingService, changeDetector, pdfService, columnInfo, dataMappingService) {
        this.changeNotification = changeNotification;
        this.suspendService = suspendService;
        this.groupsService = groupsService;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.scrollSyncService = scrollSyncService;
        this.resizeService = resizeService;
        this.editService = editService;
        this.supportService = supportService;
        this.navigationService = navigationService;
        this.ctx = ctx;
        this.columnResizingService = columnResizingService;
        this.changeDetector = changeDetector;
        this.pdfService = pdfService;
        this.columnInfo = columnInfo;
        this.dataMappingService = dataMappingService;
        this.scroller = this.ctx.scroller = scrollerFactory(this.dispatcher, this.ctx);
        this.subscriptions = detailsService.changes.subscribe(() => this.detailExpand());
        this.subscriptions.add(scrollRequestService.requests.subscribe(req => isPresent(req.adjustIndex) ? this.scrollTo(req.request, req.adjustIndex) : this.scrollToItem(req.request)));
        this.subscriptions.add(this.pdfService.restoreDOMVirtualization.subscribe(() => {
            this.ngZone.onStable.pipe(take(1)).subscribe(() => {
                this.init();
                this.setScrollerOptions();
                this.scroller.update();
            });
        }));
    }
    ngOnInit() {
        this.minRowHeight = this.isVirtual ? this.rowHeight || calcRowHeight(this.table.nativeElement) : this.rowHeight;
        this.init();
        this.subscriptions.add(this.ngZone.runOutsideAngular(this.handleRowSync.bind(this)));
        this.subscriptions.add(this.groupsService.changes.subscribe(() => {
            this.skipScroll = this.isVirtual;
        }));
        this.subscriptions.add(this.ngZone.runOutsideAngular(this.handleRowNavigationLocked.bind(this)));
        this.subscriptions.add(merge(this.columns.changes, this.resizeService.changes).subscribe(() => {
            if (this.virtualColumns) {
                this.ngZone.run(() => {
                    this.updateViewportColumns();
                    this.changeDetector.markForCheck();
                });
            }
        }));
        this.subscriptions.add(this.ctx.localization.changes.subscribe(({ rtl }) => this.rtl = rtl));
    }
    ngOnChanges(changes) {
        if (!isDocumentAvailable()) {
            return;
        }
        const changesInSkip = changes['skip'];
        const hasInitialSkip = changesInSkip && changesInSkip.firstChange && changesInSkip.currentValue > 0;
        if (hasInitialSkip) {
            this.handleSkipOnData = true;
        }
        if (isChanged$1('isVirtual', changes)) {
            if (this.isVirtual && !(this.minRowHeight || this.rowHeight)) {
                this.minRowHeight = calcRowHeight(this.table.nativeElement);
            }
            this.ngZone.onStable.pipe(take(1)).subscribe(() => {
                this.scroller.reset();
                this.rowHeightService = this.scroller.rowHeightService = new RowHeightService(this.total, this.rowHeight || this.minRowHeight);
                this.setScrollerOptions();
                this.scroller.update();
            });
        }
        if (isChanged$1("skip", changes) && !this.rebind) {
            this.skipScroll = true;
            this.container.nativeElement.scrollTop = (this.isVirtual && this.ctx.grid?.pageable) ? 0 : this.rowHeightService.offset(this.skip);
        }
        if (anyChanged(['total', 'take'], changes)) {
            // For virtual scrolling without paging, preserve scroll position when only take/pageSize changes
            const isVirtualOnly = this.isVirtual && !this.ctx.grid?.pageable;
            const onlyTakeChanged = isChanged$1('take', changes) && !isChanged$1('total', changes);
            if (isVirtualOnly && onlyTakeChanged) {
                this.skipScroll = true;
            }
            this.init();
        }
        this.rebind = false;
    }
    zoneSub;
    get totalIsAllItems() {
        return this.isVirtual && (Boolean(this.ctx.grid?.pageable || this.ctx.grid?.group?.length));
    }
    rebindGroupedDataFlag = false;
    ngDoCheck() {
        if (this.virtualColumns && (!this.viewportColumns || this.viewportWidthChange())) {
            this.updateViewportColumns();
        }
        if (!isPresent(this.virtualPageSize) && !this.ctx.grid?.pageable && isPresent(this.ctx.grid?.pageSize)) {
            this.virtualPageSize = this.ctx.grid.pageSize;
        }
        const shouldCalculatePageSize = isDocumentAvailable() && this.isVirtual && !isPresent(this.virtualPageSize) && (!isPresent(this.ctx.grid?.pageSize) || this.ctx.grid?.pageable);
        const previousTotal = this.allItems.length;
        this.allItems = this.dataMappingService.dataMapper(this.data, this.nonLockedColumnsToRender, this.lockedLeafColumns, this.detailTemplate, this.showFooter);
        const totalChanged = previousTotal !== this.allItems.length;
        const totalIncreased = this.allItems.length > previousTotal;
        if (this.totalIsAllItems && totalChanged) {
            this.scroller.reset(this.skipScroll);
            this.scroller.total = this.allItems.length;
            this.itemsToRender = this.allItems.slice(this.scroller.virtualSkip, this.scroller.virtualSkip + this.virtualPageSize);
        }
        else if (totalChanged && !this.ctx.grid?.group?.length) {
            // Preserve scroll position for non-virtual endless scrolling (scrollBottom event)
            if (!this.isVirtual && totalIncreased) {
                this.scroller.total = this.total;
            }
            else {
                this.scroller.reset(this.skipScroll);
                this.scroller.total = this.total;
                // Clear flags to allow viewport update on next change detection (virtual scrolling fix)
                this.skipScroll = false;
                this.scroller.scrollSyncing = false;
            }
        }
        if (!this.isVirtual || (this.isVirtual && !this.ctx.grid?.pageable && !this.ctx.grid?.group?.length)) {
            this.itemsToRender = this.allItems;
        }
        const rebindGroupedData = this.isVirtual && !totalChanged && this.ctx.grid?.group?.length && !this.rebindGroupedDataFlag;
        if (rebindGroupedData) {
            this.rebindGroupedDataFlag = true;
        }
        if (shouldCalculatePageSize || !isPresent(this.scroller.rowHeightService)) {
            const calculatedPageSize = this.virtualPageSize ?? this.calcVirtualPageSize();
            if (calculatedPageSize > 0) {
                this.ngZone.onStable.pipe(take(1)).subscribe(() => {
                    if (!isPresent(this.ctx.grid?.pageSize)) {
                        this.ctx.grid.pageSize = calculatedPageSize;
                        this.ngZone.run(() => {
                            this.pageChange.emit({
                                skip: this.skip || 0,
                                take: calculatedPageSize
                            });
                        });
                    }
                    if (this.ctx.grid?.pageable || this.ctx.grid?.group?.length) {
                        this.virtualPageSize = this.scroller.virtualPageSize = calculatedPageSize;
                        this.ngZone.run(() => this.itemsToRender = this.allItems.slice(this.scroller.virtualSkip, this.scroller.virtualSkip + this.virtualPageSize));
                    }
                });
            }
        }
        else if (this.rebindGroupedDataFlag) {
            this.ngZone.run(() => this.itemsToRender = this.allItems.slice(this.scroller.virtualSkip, this.scroller.virtualSkip + this.virtualPageSize));
            this.rebindGroupedDataFlag = false;
        }
        if (!this.zoneSub) {
            this.zoneSub = this.ngZone.onStable.subscribe(() => {
                if (!this.scroller.rowHeightService) {
                    const total = this.isVirtual && (this.ctx.grid?.pageable || this.ctx.grid?.group?.length) ? this.allItems.length : this.total;
                    this.scroller.rowHeightService = this.rowHeightService = new RowHeightService(total, this.rowHeight || this.minRowHeight);
                }
                if (this.allItems.length && this.handleSkipOnData && this.isVirtual && this.skip > 0 && this.total > 0) {
                    this.ngZone.onStable.pipe(take(1)).subscribe(() => {
                        this.scroller.adjustScroll(this.scroller.rowHeightService.offset(this.skip), true);
                        this.handleSkipOnData = false;
                    });
                }
                if (this.isVirtual && this.ctx.grid?.group?.length && this.scroller.total !== this.allItems.length) {
                    this.scroller.total = this.allItems.length;
                    this.rowHeightService = this.scroller.rowHeightService = new RowHeightService(this.scroller.total, this.rowHeight || this.minRowHeight);
                }
                this.isVirtual && this.scroller.update();
                // Item outside of the viewport is scrolled to programmatically.
                // RowHeightService offset for given index still may not match the current scrollTop
                // depending on the varying row heights, so we need to adjust the scroll position.
                if (isPresent(this.scrollToIndex)) {
                    const offset = this.scroller.rowHeightService.offset(this.scrollToIndex);
                    if (offset > this.container.nativeElement.scrollTop) {
                        this.scroller.adjustScroll(offset - this.container.nativeElement.scrollTop);
                    }
                    this.scrollToIndex = null;
                }
                if (this.isVirtual) {
                    this.ctx.grid?.updateNavigationMetadata();
                    // when navigating down from the header to content, skip navigation to the content
                    // that would be triggered by the resetNavigationViewport method to ensure that the
                    // focus is correctly set on the first data row in the content area.
                    const shouldResetViewport = !this.navigationService.activeRow || this.navigationService.activeRow?.dataRowIndex > -1 || isPresent(this.navigationService.activeRow?.groupItem);
                    if (shouldResetViewport) {
                        this.resetNavigationViewport();
                    }
                }
                this.zoneSub.unsubscribe();
                this.zoneSub = null;
            });
        }
    }
    ngAfterViewInit() {
        if (!isDocumentAvailable()) {
            return;
        }
        this.attachContainerScroll();
        this.initResizeService();
        this.setScrollerOptions();
    }
    ngAfterViewChecked() {
        const isLocked = this.isLocked;
        if (isLocked && !this.hasLockedContainer) {
            this.syncRowsHeight();
        }
        this.hasLockedContainer = isLocked;
    }
    syncRowsHeight() {
        if (this.lockedContainer) {
            syncRowsHeight(this.lockedTable.nativeElement, this.table.nativeElement);
        }
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
        if (this.zoneSub) {
            this.zoneSub.unsubscribe();
            this.zoneSub = null;
        }
        if (this.resizeService) {
            this.resizeService.destroy();
        }
        this.observer?.disconnect();
        this.cleanupScroller();
    }
    init() {
        if (this.suspendService.scroll) {
            return;
        }
        const total = this.isVirtual && this.ctx.grid?.pageable ? this.ctx.grid.pageSize : this.total;
        this.rowHeightService = this.scroller.rowHeightService = new RowHeightService(total, this.rowHeight || this.minRowHeight);
        if (!isUniversal()) {
            if (this.skipScroll) {
                // Update scroller's take value when preserving scroll position
                this.scroller.take = this.take;
                this.scroller.total = this.total;
                this.setScrollerOptions();
                this.scroller.update();
            }
            else {
                this.ngZone.runOutsideAngular(this.createScroller.bind(this));
            }
        }
    }
    lockedScroll() {
        if (!this.suspendService.scroll) {
            const lockedScrollTop = this.lockedContainer.nativeElement.scrollTop;
            if (lockedScrollTop !== this.containerScrollTop) {
                this.container.nativeElement.scrollTop = this.containerScrollTop = lockedScrollTop;
            }
        }
    }
    lockedMousewheel(args) {
        if (!args.ctrlKey) {
            preventLockedScroll(args, this.container.nativeElement);
            const scrollDelta = wheelDeltaY(args);
            this.container.nativeElement.scrollTop -= scrollDelta;
        }
    }
    lockedKeydown(args) {
        // on some keyboards arrow keys, PageUp/Down, and Home/End are mapped to Numpad keys
        const code = normalizeKeys(args);
        if (code === Keys.PageDown || code === Keys.PageUp) {
            const dir = code === Keys.PageDown ? 1 : -1;
            const element = this.container.nativeElement;
            element.scrollTop += element.offsetHeight * dir * 0.8;
            args.preventDefault();
        }
    }
    updateViewportColumns(range) {
        const columns = this.columns.nonLockedLeafColumns.toArray();
        // eslint-disable-next-line prefer-const
        let { startIdx, endIdx, offset } = range || this.calculateViewportColumns();
        const start = Math.max(0, startIdx - bufferSize);
        const end = Math.min(endIdx + bufferSize, columns.length - 1);
        if (start < startIdx) {
            for (let idx = startIdx - 1; idx >= start; idx--) {
                offset -= columns[idx].width;
            }
        }
        let currentColumns = columns.slice(start, end + 1);
        this.viewportColumnsWidth = currentColumns.reduce((total, column) => total + column.width, 0);
        const stickyBeforeStart = columns.slice(0, start).filter(c => c.sticky && !currentColumns.some(col => col === c));
        const stickyAfterEnd = columns.slice(end, columns.length).filter(c => c.sticky && !currentColumns.some(col => col === c));
        currentColumns = [...stickyBeforeStart, ...currentColumns, ...stickyAfterEnd];
        if (start > 0) {
            const offsetColumn = new ColumnBase();
            offsetColumn.width = offset;
            currentColumns.unshift(offsetColumn);
        }
        this.viewportColumns = new QueryList();
        this.viewportColumns.reset(currentColumns);
        this.columnsStartIdx = start;
        this.columnsEndIdx = end;
        this.columnInfo.columnRangeChange.emit({ start, end, offset });
        if (!range) {
            this.updateColumnViewport(startIdx, endIdx);
        }
    }
    /**
     * @hidden
     */
    get isStacked() {
        return this.ctx.grid?.isStacked;
    }
    resetNavigationViewport() {
        if (!isDocumentAvailable()) {
            return;
        }
        if (this.skipScroll || this.scroller.scrollSyncing) {
            this.ngZone.runOutsideAngular(() => {
                setTimeout(() => {
                    this.skipScroll = this.scroller.scrollSyncing = false;
                });
            });
            return;
        }
        if (!this.container || !this.navigationService.tableEnabled ||
            !this.navigationService.needsViewport() || this.allItems.length === 0) {
            return;
        }
        const { scrollTop, offsetHeight } = this.container.nativeElement;
        const scrollBottom = scrollTop + offsetHeight;
        const firstItemIndex = this.rowHeightService.index(scrollTop);
        const lastItemIndex = this.rowHeightService.index(scrollBottom);
        const lastItemOffset = this.rowHeightService.offset(lastItemIndex);
        let viewportStart = firstItemIndex;
        let viewportEnd = lastItemIndex;
        if (isPresent(this.detailTemplate)) {
            viewportStart *= 2;
            viewportEnd *= 2;
            const firstItemHeight = this.rowHeightService.offset(firstItemIndex);
            if (firstItemHeight + this.rowHeight < scrollTop) {
                viewportStart++;
            }
            const lastItemHeight = this.rowHeightService.height(lastItemIndex);
            const lastItemExpanded = this.scroller.isExpanded(lastItemIndex);
            const lastItemDetailOverflows = lastItemOffset + lastItemHeight > scrollBottom;
            if (lastItemExpanded && !lastItemDetailOverflows) {
                viewportEnd++;
            }
        }
        const offset = this.isVirtual && this.ctx.grid?.pageable ? this.skip : 0;
        this.navigationService.setViewport(viewportStart + offset, viewportEnd + offset);
    }
    detailExpand() {
        this.resetNavigationViewport();
    }
    attachContainerScroll() {
        if (isUniversal()) {
            return;
        }
        this.ngZone.runOutsideAngular(() => {
            this.subscriptions.add(fromEvent(this.container.nativeElement, 'scroll').pipe(map((event) => event.target), filter(() => !this.suspendService.scroll), tap((target) => {
                this.onContainerScroll(target);
                this.resetNavigationViewport();
                if (this.virtualColumns || this.isVirtual) {
                    this.handleColumnScroll();
                }
                const rowViewport = this.navigationService.viewport || EMPTY_OBJECT;
                const columnViewport = this.navigationService.columnViewport || EMPTY_OBJECT;
                this.contentScroll.emit({
                    scrollLeft: target.scrollLeft,
                    scrollTop: target.scrollTop,
                    startRow: rowViewport.firstItemIndex,
                    endRow: rowViewport.lastItemIndex,
                    startColumn: columnViewport.firstItemIndex,
                    endColumn: columnViewport.lastItemIndex
                });
            })).subscribe(this.dispatcher));
        });
        this.scrollSyncService.registerEmitter(this.container.nativeElement, 'body');
    }
    createScroller() {
        this.cleanupScroller();
        const observable = this.scroller
            .create(this.rowHeightService, this.skip, this.take, this.total);
        this.skipScroll = false;
        this.scrollerSubscription = observable.pipe(filter((x) => x instanceof PageAction), filter((x) => {
            const temp = this.skipScroll;
            this.skipScroll = false;
            return !temp && x.skip !== this.skip;
        }), tap(() => this.rebind = true))
            .subscribe((x) => this.ngZone.run(() => this.pageChange.emit(x)));
        this.scrollerSubscription.add(observable.pipe(filter((x) => x instanceof ScrollAction))
            .subscribe(this.scroll.bind(this)));
        this.scrollerSubscription.add(observable.pipe(filter((x) => x instanceof ScrollBottomAction))
            .subscribe(() => this.scrollBottom.emit()));
    }
    scroll(scrollActionArgs) {
        this.skipScroll = false;
        if (this.isVirtual) {
            [
                maybeNativeElement(this.table),
                maybeNativeElement(this.lockedTable)
            ].filter(isPresent).forEach(translateY(this.renderer, scrollActionArgs.offset));
            if (this.virtualPageSize && scrollActionArgs.changeVirtualData && (this.ctx.grid.pageable || this.ctx.grid.group?.length)) {
                this.ngZone.run(() => this.itemsToRender = this.allItems.slice(this.scroller.virtualSkip, this.scroller.virtualSkip + this.virtualPageSize));
            }
        }
        this.resetNavigationViewport();
    }
    onContainerScroll({ scrollTop }) {
        this.containerScrollTop = scrollTop;
        if (this.lockedContainer) {
            this.lockedContainer.nativeElement.scrollTop = scrollTop;
        }
    }
    handleRowSync() {
        const isLocked = () => isPresent(this.lockedContainer);
        const onStable = () => this.ngZone.onStable.asObservable().pipe(take(1));
        return merge(this.changeNotification.changes, this.groupsService.changes
            .pipe(filter(isLocked), switchMapTo(onStable())), this.editService.changed, this.resizeService.changes, this.columnResizingService.changes
            .pipe(filter(change => change.type === 'end')), this.supportService.changes)
            .pipe(filter(isLocked))
            .subscribe(() => {
            const scrollTop = this.container.nativeElement.scrollTop;
            const scrollLeft = this.container.nativeElement.scrollLeft;
            this.syncRowsHeight();
            this.syncContainerHeight();
            this.lockedContainer.nativeElement.scrollTop = this.container.nativeElement.scrollTop = scrollTop;
            // fixes scroll left position in IE when editing
            this.container.nativeElement.scrollLeft = scrollLeft;
            this.resizeSensors.forEach(sensor => sensor.acceptSize());
        });
    }
    handleRowNavigationLocked() {
        return this.navigationService.changes.pipe(filter(() => isPresent(this.lockedContainer)), delay(10)).subscribe((args) => {
            if (this.lockedLeafColumns.length <= args.prevColIndex && args.colIndex < this.lockedLeafColumns.length) {
                const cell = this.navigationService.activeCell;
                if (cell && cell.colIndex + cell.colSpan < args.prevColIndex) {
                    this.container.nativeElement.scrollLeft = 0;
                }
            }
        });
    }
    scrollToVirtualRow(itemIndex, adjustIndexForDetailTemplate = true) {
        if (!isDocumentAvailable()) {
            return;
        }
        if (isPresent(this.detailTemplate) && adjustIndexForDetailTemplate) {
            itemIndex = Math.floor(itemIndex / 2);
        }
        const offset = this.rowHeightService.offset(itemIndex);
        this.container.nativeElement.scrollTop = offset;
        this.scrollToIndex = itemIndex;
    }
    scrollTo({ row, column }, adjustIndex = false) {
        if (isNumber(row)) {
            if (this.isVirtual) {
                this.scrollToVirtualRow(row, adjustIndex);
            }
            else {
                const element = rowAt(row, this.table.nativeElement.rows);
                if (element) {
                    this.container.nativeElement.scrollTop = element.offsetTop;
                }
            }
        }
        if (isNumber(column)) {
            column -= this.lockedLeafColumns.length;
            if (this.virtualColumns) {
                const columns = this.columns.leafColumnsToRender;
                let offset = 0;
                for (let idx = 0; idx < column; idx++) {
                    offset += columns[idx].width || 0;
                }
                const startOffset = this.lockedLeafColumns.length ? 0 : this.groups.length * GROUP_CELL_WIDTH + (this.detailTemplate && column > 0 ? GROUP_CELL_WIDTH : 0);
                this.container.nativeElement.scrollLeft = this.normalizeScrollLeft(offset + startOffset);
            }
            else if (column === 0 && this.detailTemplate) {
                this.container.nativeElement.scrollLeft = this.normalizeScrollLeft(0);
            }
            else {
                const firstRow = rowAt(0, this.table.nativeElement.rows);
                if (firstRow) {
                    const element = cellAt(column, firstRow.cells);
                    if (element) {
                        this.container.nativeElement.scrollLeft = this.elementScrollLeft(element);
                    }
                }
            }
        }
    }
    scrollToItem(item) {
        if (!isDocumentAvailable()) {
            return;
        }
        const data = this.ctx.grid.data;
        const gridData = Array.isArray(data) ? data : data.data;
        const gridDataItems = gridData.flatMap(recursiveFlatMap);
        const dataItemIndex = gridDataItems.findIndex(dataItem => dataItem[item.idField] === item.id);
        if (dataItemIndex !== -1) {
            const row = Array.from(this.table.nativeElement.rows).find((r) => {
                const dataAttribute = r.getAttribute('data-kendo-grid-item-index');
                return dataAttribute && +dataAttribute === this.ctx.grid.skip + dataItemIndex;
            });
            row && row.scrollIntoView();
            this.resetNavigationViewport();
        }
    }
    cleanupScroller() {
        if (this.scrollerSubscription) {
            this.scrollerSubscription.unsubscribe();
        }
        if (this.scroller) {
            this.scroller.destroy();
        }
    }
    initResizeService() {
        this.resizeService.connect(merge(...this.resizeSensors.map(sensor => sensor.resize)));
    }
    syncContainerHeight() {
        [maybeNativeElement(this.lockedContainer)]
            .filter(isPresent)
            .map(el => {
            el.style.height = '';
            let height = this.container.nativeElement.offsetHeight;
            if (hasScrollbar(this.table, this.container)) {
                height -= this.supportService.scrollbarWidth;
            }
            return { el, height };
        })
            .forEach(setHeight(this.renderer));
    }
    handleColumnScroll() {
        const container = this.container.nativeElement;
        const scrollLeft = container.scrollLeft;
        if (this.scrollLeft !== scrollLeft) {
            this.scrollLeft = scrollLeft;
            const range = this.calculateViewportColumns();
            this.updateColumnViewport(range.startIdx, range.endIdx);
            if (range.startIdx < this.columnsStartIdx || this.columnsEndIdx < range.endIdx) {
                cancelAnimationFrame(this.columnUpdateFrame);
                this.columnUpdateFrame = requestAnimationFrame(() => {
                    this.ngZone.run(() => {
                        this.updateViewportColumns(range);
                        this.changeDetector.markForCheck();
                    });
                });
            }
        }
    }
    updateColumnViewport(startIdx, endIdx) {
        const lockedCount = this.lockedLeafColumns.length;
        const leafColumns = this.nonLockedLeafColumns.toArray();
        const viewportStart = lockedCount + startIdx + (this.detailTemplate && startIdx > 0 ? 1 : 0);
        let viewportEnd = lockedCount + endIdx + (this.detailTemplate ? 1 : 0);
        for (let idx = 0; idx < leafColumns.length; idx++) {
            const column = leafColumns[idx];
            if (column.isSpanColumn) {
                viewportEnd += column.children.length;
            }
        }
        this.navigationService.setColumnViewport(viewportStart, viewportEnd);
    }
    calculateViewportColumns() {
        const { scrollLeft, clientWidth } = this.container.nativeElement;
        const columns = this.columns.nonLockedLeafColumns.toArray();
        const normalizedScrollLeft = this.normalizeScrollLeft(scrollLeft);
        const viewportEnd = normalizedScrollLeft + clientWidth;
        let startIdx;
        let endIdx = 0;
        let current = 0;
        let offset = 0;
        let idx;
        for (idx = 0; idx < columns.length; idx++) {
            const column = columns[idx];
            current += column.width || 0;
            if (startIdx === undefined && current > normalizedScrollLeft) {
                startIdx = idx;
                offset = current - (column.width || 0);
            }
            if (current >= viewportEnd) {
                endIdx = idx;
                break;
            }
        }
        if (!endIdx && idx > 0) {
            endIdx = columns.length - 1;
        }
        return { startIdx, endIdx, offset };
    }
    viewportWidthChange() {
        const currentWidth = this.viewportColumns.toArray().reduce((total, column) => total + column.width, 0);
        return currentWidth !== this.viewportColumnsWidth;
    }
    normalizeScrollLeft(position) {
        return this.rtl ? rtlScrollPosition(position, this.container.nativeElement, this.supportService.rtlScrollLeft) : position;
    }
    elementScrollLeft(element) {
        if (this.rtl) {
            return this.normalizeScrollLeft(this.container.nativeElement.scrollWidth - element.offsetLeft - element.offsetWidth);
        }
        return element.offsetLeft;
    }
    calcVirtualPageSize = () => {
        const containerHeight = this.container.nativeElement.offsetHeight;
        if (containerHeight && (this.rowHeight ?? this.minRowHeight)) {
            return Math.ceil((containerHeight / (this.rowHeight ?? this.minRowHeight)) * 1.5);
        }
        return 0;
    };
    setScrollerOptions() {
        this.scroller.scrollableVirtual = this.isVirtual;
        this.scroller.table = this.table.nativeElement;
        this.scroller.lockedTable = this.lockedTable?.nativeElement || null;
        this.scroller.tableBody = this.table.nativeElement.tBodies[0];
        this.scroller.container = this.container.nativeElement;
        this.scroller.scrollHeightContainer = this.container.nativeElement.querySelector('.k-height-container');
        this.scroller.total = this.isVirtual && !this.ctx.grid?.pageable ? this.total : this.allItems.length;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ListComponent, deps: [{ token: SCROLLER_FACTORY_TOKEN }, { token: DetailsService }, { token: ChangeNotificationService }, { token: SuspendService }, { token: GroupsService }, { token: i0.NgZone }, { token: i0.Renderer2 }, { token: ScrollSyncService }, { token: ResizeService }, { token: EditService }, { token: BrowserSupportService }, { token: NavigationService }, { token: ScrollRequestService }, { token: ContextService }, { token: ColumnResizingService }, { token: i0.ChangeDetectorRef }, { token: PDFService }, { token: ColumnInfoService }, { token: DataMappingService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: ListComponent, isStandalone: true, selector: "kendo-grid-list", inputs: { data: "data", groups: "groups", total: "total", rowHeight: "rowHeight", detailRowHeight: "detailRowHeight", take: "take", skip: "skip", columns: "columns", detailTemplate: "detailTemplate", noRecordsTemplate: "noRecordsTemplate", selectable: "selectable", groupable: "groupable", filterable: "filterable", rowClass: "rowClass", rowSticky: "rowSticky", loading: "loading", trackBy: "trackBy", virtualColumns: "virtualColumns", isVirtual: "isVirtual", cellLoadingTemplate: "cellLoadingTemplate", loadingTemplate: "loadingTemplate", sort: "sort", size: "size" }, outputs: { contentScroll: "contentScroll", pageChange: "pageChange", scrollBottom: "scrollBottom" }, host: { properties: { "class.k-grid-container": "this.hostClass", "attr.role": "this.hostRole" } }, providers: [
            {
                provide: SCROLLER_FACTORY_TOKEN,
                useValue: DEFAULT_SCROLLER_FACTORY
            }
        ], viewQueries: [{ propertyName: "container", first: true, predicate: ["container"], descendants: true, static: true }, { propertyName: "lockedContainer", first: true, predicate: ["lockedContainer"], descendants: true }, { propertyName: "lockedTable", first: true, predicate: ["lockedTable"], descendants: true }, { propertyName: "table", first: true, predicate: ["table"], descendants: true, static: true }, { propertyName: "resizeSensors", predicate: ResizeSensorComponent, descendants: true }], usesOnChanges: true, ngImport: i0, template: `
    @if (isLocked && !isStacked) {
      <div #lockedContainer class="k-grid-content-locked" role="presentation"
        [style.width.px]="lockedWidth" tabindex="-1"
        [kendoEventsOutsideAngular]="{
            keydown: lockedKeydown,
            scroll: lockedScroll,
            mousewheel: lockedMousewheel,
            DOMMouseScroll: lockedMousewheel
        }"
        [scope]="this"
        >
        <div role="presentation">
          <table
            kendoGridResizableTable
            [locked]="true"
            #lockedTable
            class="k-grid-table"
            role="presentation"
            kendoGridTable
            [size]="size"
            [style.width.px]="lockedWidth">
            <colgroup kendoGridColGroup
              [groups]="groups"
              [columns]="$any(lockedLeafColumns)"
              [detailTemplate]="detailTemplate"
              [sort]="sort">
          </colgroup>
          <tbody kendoGridTableBody
            role="presentation"
            [groups]="groups"
            [isLocked]="true"
            [rowsToRender]="itemsToRender"
            [rowHeight]="rowHeight"
            [detailRowHeight]="detailRowHeight"
            [noRecordsText]="''"
            [columns]="$any(lockedLeafColumns)"
            [totalColumnsCount]="leafColumns.length"
            [totalColumns]="columns"
            [detailTemplate]="detailTemplate"
            [skip]="skip"
            [selectable]="selectable"
            [trackBy]="trackBy"
            [filterable]="filterable"
            [rowClass]="rowClass"
            [isLoading]="loading"
            [isVirtual]="isVirtual"
            [cellLoadingTemplate]="cellLoadingTemplate">
          </tbody>
        </table>
        <kendo-resize-sensor></kendo-resize-sensor>
      </div>
      @if (isVirtual) {
        <div class="k-height-container" role="presentation">
          <div></div>
        </div>
      }
    </div>
    }
    <div
      #container
      class="k-grid-content k-virtual-content"
      [kendoGridResizableContainer]="lockedLeafColumns.length > 0"
      [lockedWidth]="lockedWidth + 1"
      tabindex="-1"
      >
      <div role="presentation">
        <table
          [style.width.px]="nonLockedWidth"
          #table
          kendoGridResizableTable
          [virtualColumns]="virtualColumns"
          class="k-grid-table"
          kendoGridTable
          [size]="size"
          role="presentation">
          <colgroup kendoGridColGroup
            [groups]="isLocked ? [] : groups"
            [columns]="$any(nonLockedColumnsToRender)"
            [detailTemplate]="detailTemplate"
            [sort]="sort">
        </colgroup>
        <tbody kendoGridTableBody
          role="rowgroup"
          [skipGroupDecoration]="isLocked"
          [rowsToRender]="itemsToRender"
          [groups]="groups"
          [columns]="$any(nonLockedColumnsToRender)"
          [allColumns]="$any(nonLockedLeafColumns)"
          [detailTemplate]="detailTemplate"
          [noRecordsTemplate]="noRecordsTemplate"
          [lockedColumnsCount]="lockedLeafColumns.length"
          [totalColumnsCount]="leafColumns.length"
          [totalColumns]="columns"
          [skip]="skip"
          [selectable]="selectable"
          [trackBy]="trackBy"
          [filterable]="filterable"
          [rowClass]="rowClass"
          [rowSticky]="rowSticky"
          [virtualColumns]="virtualColumns"
          [isLoading]="loading"
          [isVirtual]="isVirtual"
          [cellLoadingTemplate]="cellLoadingTemplate"
          [rowHeight]="rowHeight"
          [detailRowHeight]="detailRowHeight">
        </tbody>
      </table>
      @if (isLocked) {
        <kendo-resize-sensor></kendo-resize-sensor>
      }
    </div>
    @if (isLocked || virtualColumns) {
      <kendo-resize-sensor></kendo-resize-sensor>
    }
    @if (isVirtual) {
      <div class="k-height-container" role="presentation">
        <div></div>
      </div>
    }
    @if (virtualColumns && !isStacked) {
      <div class="k-width-container" role="presentation">
        <div [style.width.px]="totalWidth"></div>
      </div>
    }
    </div>
    `, isInline: true, dependencies: [{ kind: "directive", type: EventsOutsideAngularDirective, selector: "[kendoEventsOutsideAngular]", inputs: ["kendoEventsOutsideAngular", "scope"] }, { kind: "directive", type: TableDirective, selector: "[kendoGridResizableTable]", inputs: ["locked", "virtualColumns"] }, { kind: "directive", type: GridTableDirective, selector: "[kendoGridTable]", inputs: ["size"] }, { kind: "component", type: ColGroupComponent, selector: "[kendoGridColGroup]", inputs: ["columns", "groups", "detailTemplate", "sort"] }, { kind: "component", type: TableBodyComponent, selector: "[kendoGridTableBody]", inputs: ["columns", "allColumns", "groups", "detailTemplate", "noRecordsTemplate", "rowsToRender", "skip", "selectable", "filterable", "noRecordsText", "isLocked", "isLoading", "isVirtual", "cellLoadingTemplate", "skipGroupDecoration", "lockedColumnsCount", "totalColumnsCount", "virtualColumns", "trackBy", "rowSticky", "totalColumns", "rowClass", "rowHeight", "detailRowHeight"] }, { kind: "component", type: ResizeSensorComponent, selector: "kendo-resize-sensor", inputs: ["rateLimit"], outputs: ["resize"] }, { kind: "directive", type: ResizableContainerDirective, selector: "[kendoGridResizableContainer]", inputs: ["lockedWidth", "kendoGridResizableContainer"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ListComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: SCROLLER_FACTORY_TOKEN,
                            useValue: DEFAULT_SCROLLER_FACTORY
                        }
                    ],
                    selector: 'kendo-grid-list',
                    template: `
    @if (isLocked && !isStacked) {
      <div #lockedContainer class="k-grid-content-locked" role="presentation"
        [style.width.px]="lockedWidth" tabindex="-1"
        [kendoEventsOutsideAngular]="{
            keydown: lockedKeydown,
            scroll: lockedScroll,
            mousewheel: lockedMousewheel,
            DOMMouseScroll: lockedMousewheel
        }"
        [scope]="this"
        >
        <div role="presentation">
          <table
            kendoGridResizableTable
            [locked]="true"
            #lockedTable
            class="k-grid-table"
            role="presentation"
            kendoGridTable
            [size]="size"
            [style.width.px]="lockedWidth">
            <colgroup kendoGridColGroup
              [groups]="groups"
              [columns]="$any(lockedLeafColumns)"
              [detailTemplate]="detailTemplate"
              [sort]="sort">
          </colgroup>
          <tbody kendoGridTableBody
            role="presentation"
            [groups]="groups"
            [isLocked]="true"
            [rowsToRender]="itemsToRender"
            [rowHeight]="rowHeight"
            [detailRowHeight]="detailRowHeight"
            [noRecordsText]="''"
            [columns]="$any(lockedLeafColumns)"
            [totalColumnsCount]="leafColumns.length"
            [totalColumns]="columns"
            [detailTemplate]="detailTemplate"
            [skip]="skip"
            [selectable]="selectable"
            [trackBy]="trackBy"
            [filterable]="filterable"
            [rowClass]="rowClass"
            [isLoading]="loading"
            [isVirtual]="isVirtual"
            [cellLoadingTemplate]="cellLoadingTemplate">
          </tbody>
        </table>
        <kendo-resize-sensor></kendo-resize-sensor>
      </div>
      @if (isVirtual) {
        <div class="k-height-container" role="presentation">
          <div></div>
        </div>
      }
    </div>
    }
    <div
      #container
      class="k-grid-content k-virtual-content"
      [kendoGridResizableContainer]="lockedLeafColumns.length > 0"
      [lockedWidth]="lockedWidth + 1"
      tabindex="-1"
      >
      <div role="presentation">
        <table
          [style.width.px]="nonLockedWidth"
          #table
          kendoGridResizableTable
          [virtualColumns]="virtualColumns"
          class="k-grid-table"
          kendoGridTable
          [size]="size"
          role="presentation">
          <colgroup kendoGridColGroup
            [groups]="isLocked ? [] : groups"
            [columns]="$any(nonLockedColumnsToRender)"
            [detailTemplate]="detailTemplate"
            [sort]="sort">
        </colgroup>
        <tbody kendoGridTableBody
          role="rowgroup"
          [skipGroupDecoration]="isLocked"
          [rowsToRender]="itemsToRender"
          [groups]="groups"
          [columns]="$any(nonLockedColumnsToRender)"
          [allColumns]="$any(nonLockedLeafColumns)"
          [detailTemplate]="detailTemplate"
          [noRecordsTemplate]="noRecordsTemplate"
          [lockedColumnsCount]="lockedLeafColumns.length"
          [totalColumnsCount]="leafColumns.length"
          [totalColumns]="columns"
          [skip]="skip"
          [selectable]="selectable"
          [trackBy]="trackBy"
          [filterable]="filterable"
          [rowClass]="rowClass"
          [rowSticky]="rowSticky"
          [virtualColumns]="virtualColumns"
          [isLoading]="loading"
          [isVirtual]="isVirtual"
          [cellLoadingTemplate]="cellLoadingTemplate"
          [rowHeight]="rowHeight"
          [detailRowHeight]="detailRowHeight">
        </tbody>
      </table>
      @if (isLocked) {
        <kendo-resize-sensor></kendo-resize-sensor>
      }
    </div>
    @if (isLocked || virtualColumns) {
      <kendo-resize-sensor></kendo-resize-sensor>
    }
    @if (isVirtual) {
      <div class="k-height-container" role="presentation">
        <div></div>
      </div>
    }
    @if (virtualColumns && !isStacked) {
      <div class="k-width-container" role="presentation">
        <div [style.width.px]="totalWidth"></div>
      </div>
    }
    </div>
    `,
                    standalone: true,
                    imports: [EventsOutsideAngularDirective, TableDirective, GridTableDirective, ColGroupComponent, TableBodyComponent, ResizeSensorComponent, ResizableContainerDirective]
                }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [SCROLLER_FACTORY_TOKEN]
                }] }, { type: DetailsService }, { type: ChangeNotificationService }, { type: SuspendService }, { type: GroupsService }, { type: i0.NgZone }, { type: i0.Renderer2 }, { type: ScrollSyncService }, { type: ResizeService }, { type: EditService }, { type: BrowserSupportService }, { type: NavigationService }, { type: ScrollRequestService }, { type: ContextService }, { type: ColumnResizingService }, { type: i0.ChangeDetectorRef }, { type: PDFService }, { type: ColumnInfoService }, { type: DataMappingService }], propDecorators: { hostClass: [{
                type: HostBinding,
                args: ['class.k-grid-container']
            }], hostRole: [{
                type: HostBinding,
                args: ['attr.role']
            }], data: [{
                type: Input
            }], groups: [{
                type: Input
            }], total: [{
                type: Input
            }], rowHeight: [{
                type: Input
            }], detailRowHeight: [{
                type: Input
            }], take: [{
                type: Input
            }], skip: [{
                type: Input
            }], columns: [{
                type: Input
            }], detailTemplate: [{
                type: Input
            }], noRecordsTemplate: [{
                type: Input
            }], selectable: [{
                type: Input
            }], groupable: [{
                type: Input
            }], filterable: [{
                type: Input
            }], rowClass: [{
                type: Input
            }], rowSticky: [{
                type: Input
            }], loading: [{
                type: Input
            }], trackBy: [{
                type: Input
            }], virtualColumns: [{
                type: Input
            }], isVirtual: [{
                type: Input
            }], cellLoadingTemplate: [{
                type: Input
            }], loadingTemplate: [{
                type: Input
            }], sort: [{
                type: Input
            }], size: [{
                type: Input
            }], contentScroll: [{
                type: Output
            }], pageChange: [{
                type: Output
            }], scrollBottom: [{
                type: Output
            }], container: [{
                type: ViewChild,
                args: ['container', { static: true }]
            }], lockedContainer: [{
                type: ViewChild,
                args: ['lockedContainer']
            }], lockedTable: [{
                type: ViewChild,
                args: ['lockedTable']
            }], table: [{
                type: ViewChild,
                args: ['table', { static: true }]
            }], resizeSensors: [{
                type: ViewChildren,
                args: [ResizeSensorComponent]
            }] } });

/**
 * @hidden
 */
class ToolbarComponent {
    ctx;
    wrapper;
    context = {};
    role = 'toolbar';
    hostClasses = true;
    get sizeSmallClass() {
        return this.size === 'small';
    }
    get sizeMediumClass() {
        return this.size === 'medium' || !this.size;
    }
    set position(value) {
        this.context.position = value;
    }
    set size(size) {
        this._size = size;
        if (size === 'none') {
            this.wrapper.nativeElement.classList.remove('k-toolbar-sm', 'k-toolbar-md');
        }
    }
    get size() {
        return this._size;
    }
    clickHandler(ev) {
        if (this.navigable && isDocumentAvailable()) {
            const closestFocusableElement = closestInScope$1(ev.target, isFocusable$1, this.wrapper.nativeElement)?.closest('[kendoGridToolbarFocusable]');
            const targetIndex = this.navigationService.navigableElements.indexOf(closestFocusableElement);
            if (targetIndex > -1) {
                this.navigationService.currentActiveIndex = targetIndex;
            }
            this.navigationService.updateFocus();
            if (ev.target === this.wrapper.nativeElement) {
                this.navigationService.focus();
            }
        }
    }
    arrowLeftListener() {
        if (this.navigable && isDocumentAvailable() && this.navigationService.navigableElements.length) {
            this.navigationService.currentActiveIndex--;
            if (this.navigationService.currentActiveIndex < 0) {
                this.navigationService.currentActiveIndex = this.navigationService.navigableElements.length - 1;
            }
            this.navigationService.updateFocus();
        }
    }
    arrowRightListener() {
        if (this.navigable && isDocumentAvailable() && this.navigationService.navigableElements.length) {
            this.navigationService.currentActiveIndex++;
            if (this.navigationService.currentActiveIndex >= this.navigationService.navigableElements.length) {
                this.navigationService.currentActiveIndex = 0;
            }
            this.navigationService.updateFocus();
        }
    }
    homeKeyListener(e) {
        if (this.navigable && isDocumentAvailable() && this.navigationService.navigableElements.length) {
            e.preventDefault();
            this.navigationService.currentActiveIndex = 0;
            this.navigationService.updateFocus();
        }
    }
    endKeyListener(e) {
        if (this.navigable && isDocumentAvailable() && this.navigationService.navigableElements.length) {
            e.preventDefault();
            this.navigationService.currentActiveIndex = this.navigationService.navigableElements.length - 1;
            this.navigationService.updateFocus();
        }
    }
    navigable;
    get toolbarTemplateRef() {
        return this.ctx.grid.toolbarTemplate ? this.ctx.grid.toolbarTemplate.templateRef : undefined;
    }
    _size = 'medium';
    navigationService;
    constructor(ctx, wrapper) {
        this.ctx = ctx;
        this.wrapper = wrapper;
        this.navigationService = this.ctx[`${this.wrapper.nativeElement.getAttribute('position')}ToolbarNavigation`];
        if (this.navigationService) {
            this.navigationService.toolbarElement = this.wrapper.nativeElement;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ToolbarComponent, deps: [{ token: ContextService }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: ToolbarComponent, isStandalone: true, selector: "kendo-grid-toolbar", inputs: { position: "position", size: "size", navigable: "navigable" }, host: { listeners: { "click": "clickHandler($event)", "keydown.arrowleft": "arrowLeftListener($event)", "keydown.arrowright": "arrowRightListener($event)", "keydown.home": "homeKeyListener($event)", "keydown.end": "endKeyListener($event)" }, properties: { "attr.role": "this.role", "class.k-toolbar": "this.hostClasses", "class.k-grid-toolbar": "this.hostClasses", "class.k-toolbar-solid": "this.hostClasses", "class.k-toolbar-sm": "this.sizeSmallClass", "class.k-toolbar-md": "this.sizeMediumClass" } }, ngImport: i0, template: `
        @if (toolbarTemplateRef) {
          <ng-template
            [ngTemplateOutlet]="toolbarTemplateRef"
          [ngTemplateOutletContext]="context"></ng-template>
        }
        `, isInline: true, dependencies: [{ kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ToolbarComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-toolbar',
                    template: `
        @if (toolbarTemplateRef) {
          <ng-template
            [ngTemplateOutlet]="toolbarTemplateRef"
          [ngTemplateOutletContext]="context"></ng-template>
        }
        `,
                    standalone: true,
                    imports: [NgTemplateOutlet]
                }]
        }], ctorParameters: () => [{ type: ContextService }, { type: i0.ElementRef }], propDecorators: { role: [{
                type: HostBinding,
                args: ['attr.role']
            }], hostClasses: [{
                type: HostBinding,
                args: ['class.k-toolbar']
            }, {
                type: HostBinding,
                args: ['class.k-grid-toolbar']
            }, {
                type: HostBinding,
                args: ['class.k-toolbar-solid']
            }], sizeSmallClass: [{
                type: HostBinding,
                args: ['class.k-toolbar-sm']
            }], sizeMediumClass: [{
                type: HostBinding,
                args: ['class.k-toolbar-md']
            }], position: [{
                type: Input
            }], size: [{
                type: Input
            }], clickHandler: [{
                type: HostListener,
                args: ['click', ['$event']]
            }], arrowLeftListener: [{
                type: HostListener,
                args: ['keydown.arrowleft', ['$event']]
            }], arrowRightListener: [{
                type: HostListener,
                args: ['keydown.arrowright', ['$event']]
            }], homeKeyListener: [{
                type: HostListener,
                args: ['keydown.home', ['$event']]
            }], endKeyListener: [{
                type: HostListener,
                args: ['keydown.end', ['$event']]
            }], navigable: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class GridMessages extends ComponentMessages {
    /**
     * Sets the text for the empty group panel.
     */
    groupPanelEmpty;
    /**
     * Sets the text when there are no records.
     */
    noRecords;
    /**
     * Sets the label for the pager. By default, it follows the pattern **Page {currentPage} of {totalPages}**.
     * For example, when the current page is 1 and the total number of pages is 10, the label is
     * **Page navigation, page 1 of 10**.
     *
     * The message includes the current page number, total number of pages, and a localizable string.
     * You can reorder these parts by using placeholders in the `pagerLabel` input.
     * Use `{currentPage}` and `{totalPages}` to insert the actual values.
     * [See example](slug:globalization_grid#toc-custom-messages).
     */
    pagerLabel;
    /**
     * Sets the label for the **First page** button.
     */
    pagerFirstPage;
    /**
     * Sets the label for the **Last page** button.
     */
    pagerLastPage;
    /**
     * Sets the label for the **Previous page** button.
     */
    pagerPreviousPage;
    /**
     * Sets the label for the **Next page** button.
     */
    pagerNextPage;
    /**
     * Sets the text displayed before the pager input.
     */
    pagerPage;
    /**
     * Sets the text displayed after the page-size selector.
     */
    pagerItemsPerPage;
    /**
     * Sets the text displayed before the total-page number.
     */
    pagerOf;
    /**
     * Sets the text displayed after the total number of items.
     */
    pagerItems;
    /**
     * Sets the title attribute of the page number input element.
     */
    pagerPageNumberInputTitle;
    /**
     * Sets the text for the aria-label attribute on the page number input element.
     */
    pagerInputLabel;
    /**
     * Sets the text for the title and `aria-label` attributes on the page chooser in the Grid Pager.
     */
    pagerSelectPage;
    /**
     * Sets the label for the filter cell or icon.
     */
    filter;
    /**
     * Sets the label for the filter input.
     *
     * The filter input label includes the column name and a localizable string.
     * For example, for a column named **Product Name**, the default label is **Product Name Filter**.
     *
     * You can reorder the column name and the localizable part by using a placeholder in `filterInputLabel`.
     * Use `{columnName}` to insert the column name, for example, **filter for {columnName}**.
     * [See example](slug:globalization_grid#toc-custom-messages).
     */
    filterInputLabel;
    /**
     * Sets the title for the filter menu icon.
     *
     * The title includes the column name and a localizable string.
     * For example, for a column named **Product Name**, the default title is **Product Name Filter Menu**.
     *
     * You can reorder the column name and the localizable part by using a placeholder in `filterMenuTitle`.
     * Use `{columnName}` to insert the column name, for example, **filter for {columnName}**.
     * [See example](slug:globalization_grid#toc-custom-messages).
     */
    filterMenuTitle;
    /**
     * Sets the label for the filter menu operators DropDownList.
     *
     * The label includes the column name and a localizable string.
     * For example, for a column named **Product Name**, the default label is **Product Name Filter Menu Operators**.
     *
     * You can reorder the column name and the localizable part by using a placeholder in `filterMenuOperatorsDropDownLabel`.
     * Use `{columnName}` to insert the column name, for example, **filter operators for {columnName}**.
     * [See example](slug:globalization_grid#toc-custom-messages).
     */
    filterMenuOperatorsDropDownLabel;
    /**
     * Sets the label for the filter menu logic DropDownList.
     *
     * The label includes the column name and a localizable string.
     * For example, for a column named **Product Name**, the default label is **Product Name Filter Menu Logic**.
     *
     * You can reorder the column name and the localizable part by using a placeholder in `filterMenuLogicDropDownLabel`.
     * Use `{columnName}` to insert the column name, for example, **filter logic for {columnName}**.
     * [See example](slug:globalization_grid#toc-custom-messages).
     */
    filterMenuLogicDropDownLabel;
    /**
     * Sets the label for the filter cell operators DropDownList.
     *
     * The label includes the column name and a localizable string.
     * For example, for a column named **Product Name**, the default label is **Filter cell operators for Product Name**.
     *
     * You can reorder the column name and the localizable part by using a placeholder in `filterCellOperatorLabel`.
     * Use `{columnName}` to insert the column name, for example, **Filter operators for {columnName}**.
     * [See example](slug:globalization_grid#toc-custom-messages).
     */
    filterCellOperatorLabel;
    /**
     * Sets the label for the boolean filter cell DropDownList.
     *
     * The label includes the column name and a localizable string.
     * For example, for a column named **Product Name**, the default label is **Boolean filter cell for Product Name**.
     *
     * You can reorder the column name and the localizable part by using a placeholder in `booleanFilterCellLabel`.
     * Use `{columnName}` to insert the column name, for example, **Boolean Filter operator for {columnName}**.
     * [See example](slug:globalization_grid#toc-custom-messages).
     */
    booleanFilterCellLabel;
    /**
     * The text of the AI Assistant Apply button.
     */
    aiAssistantApplyButtonText;
    /**
     * The text of the AI Assistant toolbar tool.
     */
    aiAssistantToolbarToolText;
    /**
     * The text of the AI Assistant Window title.
     */
    aiAssistantWindowTitle;
    /**
     * The title of the AI Assistant Window close button.
     */
    aiAssistantWindowCloseTitle;
    /**
     * The title of the AI Assistant Prompt Output Card.
     */
    aiAssistantOutputCardTitle;
    /**
     * The success message dispayed in the AI Assistant Prompt Output Card's body.
     */
    aiAssistantOutputCardBodyContent;
    /**
     * The message shown when AI selection requires the Grid selectable option.
     */
    aiAssistantSelectionNotEnabled;
    /**
     * The message shown when AI selection requires row selection mode.
     */
    aiAssistantSelectionRowModeRequired;
    /**
     * The message shown when AI selection requires cell selection mode.
     */
    aiAssistantSelectionCellModeRequired;
    /**
     * The title of the AI Assistant Window maximize button.
     */
    aiAssistantWindowMaximizeTitle;
    /**
     * The title of the AI Assistant Window minimize button.
     */
    aiAssistantWindowMinimizeTitle;
    /**
     * The title of the AI Assistant Window restore button.
     */
    aiAssistantWindowRestoreTitle;
    /**
     * Sets the text for the `Equal` (**Is equal to**) filter operator.
     */
    filterEqOperator;
    /**
     * Sets the text for the `NotEqual` (**Is not equal to**) filter operator.
     */
    filterNotEqOperator;
    /**
     * Sets the text for the `IsNull` (**Is null**) filter operator.
     */
    filterIsNullOperator;
    /**
     * Sets the text for the `IsNotNull` (**Is not null**) filter operator.
     */
    filterIsNotNullOperator;
    /**
     * Sets the text for the `IsEmpty` (**Is empty**) filter operator.
     */
    filterIsEmptyOperator;
    /**
     * Sets the text for the `IsNotEmpty` (**Is not empty**) filter operator.
     */
    filterIsNotEmptyOperator;
    /**
     * Sets the text for the `StartsWith` (**Starts with**) filter operator.
     */
    filterStartsWithOperator;
    /**
     * Sets the text for the `Contains` (**Contains**) filter operator.
     */
    filterContainsOperator;
    /**
     * Sets the text for the `DoesNotContain` (**Does not contain**) filter operator.
     */
    filterNotContainsOperator;
    /**
     * Sets the text for the `EndsWith` (**Ends with**) string filter operator.
     */
    filterEndsWithOperator;
    /**
     * Sets the text for the `GreaterOrEqualTo` (**Is greater than or equal to**) numeric filter operator.
     */
    filterGteOperator;
    /**
     * Sets the text for the `Greater` (**Is greater than**) numeric filter operator.
     */
    filterGtOperator;
    /**
     * Sets the text for the `LessOrEqualTo` (**Is less than or equal to**) numeric filter operator.
     */
    filterLteOperator;
    /**
     * Sets the text for the `Less` (**Is less than**) numeric filter operator.
     */
    filterLtOperator;
    /**
     * Sets the text for the `IsTrue` Boolean filter option.
     */
    filterIsTrue;
    /**
     * Sets the text for the `IsFalse` Boolean filter option.
     */
    filterIsFalse;
    /**
     * Sets the text for the `(All)` option in the Boolean filter.
     */
    filterBooleanAll;
    /**
     * Sets the title for the Operators ActionSheet in adaptive mode.
     */
    adaptiveFilterOperatorsTitle;
    /**
     * Sets the text for the `AfterOrEqualTo` (**Is after or equal to**) date filter operator.
     */
    filterAfterOrEqualOperator;
    /**
     * Sets the text for the `After` (**Is after**) date filter operator.
     */
    filterAfterOperator;
    /**
     * Sets the text for the `Before` (**Is before**) date filter operator.
     */
    filterBeforeOperator;
    /**
     * Sets the text for the `BeforeOrEqualTo` (**Is before or equal to**) date filter operator.
     */
    filterBeforeOrEqualOperator;
    /**
     * Sets the text for the **Filter** button.
     */
    filterFilterButton;
    /**
     * Sets the text for the **Clear filter** button.
     */
    filterClearButton;
    /**
     * Sets the title for the **Close** button of the ActionSheet that appears instead of the Popup on small screens in adaptive mode.
     */
    adaptiveCloseButtonTitle;
    /**
     * Sets the title for the **Back** button of the ActionSheet that appears instead of the Popup on small screens in adaptive mode.
     */
    adaptiveBackButtonTitle;
    /**
     * Sets the text for the `And` filter logic.
     */
    filterAndLogic;
    /**
     * Sets the text for the `Or` filter logic.
     */
    filterOrLogic;
    /**
     * Sets the button text for the Filter toolbar tool.
     */
    filterToolbarToolText;
    /**
     * Sets the loading text. The `loading` property a Grid accessibility feature.
     * Screen readers can detect its value, but it is not visible otherwise.
     */
    loading;
    /**
     * Sets the text for the `aria-label` attribute on the Grid focusable element.
     */
    gridLabel;
    /**
     * Sets the title for the column menu icon.
     *
     * The title includes the column name and a localizable string.
     * For example, for a column named **Product Name**, the default title is **Product Name Column Menu**.
     *
     * You can reorder the column name and the localizable part by using a placeholder in `columnMenu`.
     * Use `{columnName}` to insert the column name, for example, **menu for {columnName}**.
     * [See example](slug:globalization_grid#toc-custom-messages).
     */
    columnMenu;
    /**
     * Sets the text in the column menu for the set column position item.
     */
    setColumnPosition;
    /**
     * Sets the text for the Grid Column Chooser and Column Chooser toolbar tool.
     */
    columns;
    /**
     * Sets the text for the **Select all** checkbox in the Column Chooser.
     */
    columnChooserSelectAll;
    /**
     * The message for the selected columns count in the Column Chooser.
     * Follows the pattern **{selectedColumnsCount} Selected items ** by default.
     *
     * The message consists of two parts - selected columns count and a localizable string.
     * To allow for reordering its parts, the `columnChooserSelectedColumnsCount` input accepts a string with a placeholder for the selected columns count.
     * The `{selectedColumnsCount}` placeholder will be replaced internally with the respective actual value.
     */
    columnChooserSelectedColumnsCount;
    /**
     * Sets the subtitle for the adaptive Grid Column Chooser and Column Chooser toolbar tool.
     */
    columnsSubtitle;
    /**
     * Sets the title for the adaptive Filter Toolbar Tool and Filter Menu.
     */
    adaptiveFilterTitle;
    /**
     * Sets the title for the adaptive Sort Toolbar Tool.
     */
    adaptiveSortTitle;
    /**
     * Sets the title for the adaptive Group Toolbar Tool.
     */
    adaptiveGroupTitle;
    /**
     * Sets the text for the **Clear all filters** button in the Filter Toolbar Tool and adaptive Filter Toolbar Tool.
     */
    filterClearAllButton;
    /**
     * Sets the text for the **Clear grouping** button in the Group Toolbar Tool and adaptive Group Toolbar Tool.
     */
    groupClearButton;
    /**
     * Sets the text for the clear sort button in the Sort Toolbar Tool and adaptive Sort Toolbar Tool.
     */
    sortClearButton;
    /**
     * Sets the text for the **Done** sort button.
     */
    sortDoneButton;
    /**
     * Sets the text for the **Done** group button in the adaptive Group Toolbar Tool.
     */
    groupDoneButton;
    /**
     * Sets the text in the column menu for the lock item.
     */
    lock;
    /**
     * Sets the text in the column menu for the unlock item.
     */
    unlock;
    /**
     * Sets the text in the column menu for the stick item.
     */
    stick;
    /**
     * Sets the text in the column menu for the unstick item.
     */
    unstick;
    /**
     * Sets the label for the sort icon.
     */
    sortable;
    /**
     * Sets the text in the column menu for the ascending sort item.
     */
    sortAscending;
    /**
     * Sets the text in the column menu for the descending sort item.
     */
    sortDescending;
    /**
     * Sets the text in the column menu for the autosize this column item.
     */
    autosizeThisColumn;
    /**
     * Sets the text in the column menu for the autosize all columns item.
     */
    autosizeAllColumns;
    /**
     * Sets the title of the Group Chip for ascending sorting order of groups.
     */
    sortedAscending;
    /**
     * Sets the title of the Group Chip for descending sorting order of groups.
     */
    sortedDescending;
    /**
     * Sets the status announcement when a column is no longer sorted.
     */
    sortedDefault;
    /**
     * Sets the button text for the Sort toolbar tool.
     */
    sortToolbarToolText;
    /**
     * Sets the text in the column menu or column chooser item for the **Apply** button.
     */
    columnsApply;
    /**
     * Sets the text in the column menu or column chooser item for the **Reset** button.
     */
    columnsReset;
    /**
     * Sets the title for the expand icon of detail rows. Applies also to the expand button text in stacked mode.
     */
    detailExpand;
    /**
     * Sets the title for the collapse icon of detail rows. Applies also to the collapse button text in stacked mode.
     */
    detailCollapse;
    /**
     * Sets the text for the **Today** button in the Date filter.
     */
    filterDateToday;
    /**
     * Sets the title for the **Toggle** button in the Date filter.
     */
    filterDateToggle;
    /**
     * Sets the title for the **Decrement** button in the Numeric filter.
     */
    filterNumericDecrement;
    /**
     * Sets the title for the **Increment** button in the Numeric filter.
     */
    filterNumericIncrement;
    /**
     * Sets the labels of the checkboxes in the checkbox column.
     */
    selectionCheckboxLabel;
    /**
     * Sets the label for the select all checkbox in the checkbox column.
     */
    selectAllCheckboxLabel;
    /**
     * Sets the text for the title and `aria-label` attributes on the collapse icon of group rows.
     */
    groupCollapse;
    /**
     * Sets the text for the title and `aria-label` attributes on the expand icon of group rows.
     */
    groupExpand;
    /**
     * Sets the label for the top toolbar.
     */
    topToolbarLabel;
    /**
     * Sets the label for the bottom toolbar.
     */
    bottomToolbarLabel;
    /**
     * Sets the text for the Grid Edit toolbar tool.
     */
    editToolbarToolText;
    /**
     * Sets the text for the Grid Save toolbar tool.
     */
    saveToolbarToolText;
    /**
     * Sets the text for the Grid Add toolbar tool.
     */
    addToolbarToolText;
    /**
     * Sets the text for the Grid Cancel toolbar tool.
     */
    cancelToolbarToolText;
    /**
     * Sets the text for the Grid Remove toolbar tool.
     */
    removeToolbarToolText;
    /**
     * Sets the text for the Grid Excel Export toolbar tool.
     */
    excelExportToolbarToolText;
    /**
     * Sets the text for the Grid PDF Export toolbar tool.
     */
    pdfExportToolbarToolText;
    /**
     * Sets the label for the group panel toolbar.
     */
    groupPanelLabel;
    /**
     * Sets the label for the Grid drag row handle.
     */
    dragRowHandleLabel;
    /**
     * Sets the title for the column menu **Filter** tab.
     */
    columnMenuFilterTabTitle;
    /**
     * Sets the title for the column menu **General** tab.
     */
    columnMenuGeneralTabTitle;
    /**
     * Sets the title for the column menu **Columns** tab.
     */
    columnMenuColumnsTabTitle;
    /**
     * Sets the text for the Group pane Chip Menu **Move as previous** item.
     */
    groupChipMenuPrevious;
    /**
     * Sets the text for the Group pane Chip Menu **Move as next** item.
     */
    groupChipMenuNext;
    /**
     * Sets the button text for the Group toolbar tool.
     */
    groupToolbarToolText;
    /**
     * Sets the default text for a form validation error when you use built-in external editing.
     * <br/><br/>
     * The text includes the data item property name, the error name from the `FormControl` object, and a localizable string.
     * <br/><br/>
     * For a field named `ProductName` and an error named `required`, the default error text is `ProductName has required validation error`.
     * <br/><br/>
     * To customize the error text, use the `{errorName}` and `{fieldName}` placeholders and a custom localizable string.
     * For example, `{errorName} detected for {fieldName} field`.
     * <br/><br/>
     * The `{errorName}` and `{fieldName}` placeholders are replaced with the field and error names for the invalid form control,
     * and the error message is rendered as `required error detected for ProductName field`.
     * [See example](slug:globalization_grid#toc-custom-messages).
     */
    formValidationErrorText;
    /**
     * Sets the title for the remove item confirmation Dialog.
     */
    removeConfirmationDialogTitle;
    /**
     * Sets the content for the remove item confirmation Dialog.
     */
    removeConfirmationDialogContent;
    /**
     * Sets the text for the confirm action button in the remove confirmation Dialog.
     */
    removeConfirmationDialogConfirmText;
    /**
     * Sets the text for the reject action button in the remove confirmation Dialog.
     */
    removeConfirmationDialogRejectText;
    /**
     * Sets the title for the external editing Dialog or ActionSheet when editing an item.
     */
    externalEditingTitle;
    /**
     * Sets the title for the external editing Dialog or ActionSheet when adding a new item.
     */
    externalEditingAddTitle;
    /**
     * Sets the text for the external editing Dialog <b>Save</b> button.
     */
    externalEditingSaveText;
    /**
     * Sets the text for the external editing Dialog <b>Cancel</b> button.
     */
    externalEditingCancelText;
    /**
     * The placeholder text for the multi-checkbox filter search input
     */
    multiCheckboxFilterSearchPlaceholder;
    /**
     * The label for the multi-checkbox filter select all option
     */
    multiCheckboxFilterSelectAllLabel;
    /**
     * The text for the multi-checkbox filter selected items count
     *
     * The text includes the selected items count and a localizable string.
     * For 3 selected items the default text is `3 selected items`.
     *
     * To customize the text, use the `{selectedItemsCount}` placeholder and a custom localizable string.
     * For example, `{selectedItemsCount} items are selected`.
     *
     * The `{selectedItemsCount}` placeholder is replaced with the count of selected items,
     * and the message is rendered as `3 items are selected`.
     */
    multiCheckboxFilterSelectedItemsCount;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GridMessages, deps: null, target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: GridMessages, isStandalone: true, selector: "kendo-grid-messages-base", inputs: { groupPanelEmpty: "groupPanelEmpty", noRecords: "noRecords", pagerLabel: "pagerLabel", pagerFirstPage: "pagerFirstPage", pagerLastPage: "pagerLastPage", pagerPreviousPage: "pagerPreviousPage", pagerNextPage: "pagerNextPage", pagerPage: "pagerPage", pagerItemsPerPage: "pagerItemsPerPage", pagerOf: "pagerOf", pagerItems: "pagerItems", pagerPageNumberInputTitle: "pagerPageNumberInputTitle", pagerInputLabel: "pagerInputLabel", pagerSelectPage: "pagerSelectPage", filter: "filter", filterInputLabel: "filterInputLabel", filterMenuTitle: "filterMenuTitle", filterMenuOperatorsDropDownLabel: "filterMenuOperatorsDropDownLabel", filterMenuLogicDropDownLabel: "filterMenuLogicDropDownLabel", filterCellOperatorLabel: "filterCellOperatorLabel", booleanFilterCellLabel: "booleanFilterCellLabel", aiAssistantApplyButtonText: "aiAssistantApplyButtonText", aiAssistantToolbarToolText: "aiAssistantToolbarToolText", aiAssistantWindowTitle: "aiAssistantWindowTitle", aiAssistantWindowCloseTitle: "aiAssistantWindowCloseTitle", aiAssistantOutputCardTitle: "aiAssistantOutputCardTitle", aiAssistantOutputCardBodyContent: "aiAssistantOutputCardBodyContent", aiAssistantSelectionNotEnabled: "aiAssistantSelectionNotEnabled", aiAssistantSelectionRowModeRequired: "aiAssistantSelectionRowModeRequired", aiAssistantSelectionCellModeRequired: "aiAssistantSelectionCellModeRequired", aiAssistantWindowMaximizeTitle: "aiAssistantWindowMaximizeTitle", aiAssistantWindowMinimizeTitle: "aiAssistantWindowMinimizeTitle", aiAssistantWindowRestoreTitle: "aiAssistantWindowRestoreTitle", filterEqOperator: "filterEqOperator", filterNotEqOperator: "filterNotEqOperator", filterIsNullOperator: "filterIsNullOperator", filterIsNotNullOperator: "filterIsNotNullOperator", filterIsEmptyOperator: "filterIsEmptyOperator", filterIsNotEmptyOperator: "filterIsNotEmptyOperator", filterStartsWithOperator: "filterStartsWithOperator", filterContainsOperator: "filterContainsOperator", filterNotContainsOperator: "filterNotContainsOperator", filterEndsWithOperator: "filterEndsWithOperator", filterGteOperator: "filterGteOperator", filterGtOperator: "filterGtOperator", filterLteOperator: "filterLteOperator", filterLtOperator: "filterLtOperator", filterIsTrue: "filterIsTrue", filterIsFalse: "filterIsFalse", filterBooleanAll: "filterBooleanAll", adaptiveFilterOperatorsTitle: "adaptiveFilterOperatorsTitle", filterAfterOrEqualOperator: "filterAfterOrEqualOperator", filterAfterOperator: "filterAfterOperator", filterBeforeOperator: "filterBeforeOperator", filterBeforeOrEqualOperator: "filterBeforeOrEqualOperator", filterFilterButton: "filterFilterButton", filterClearButton: "filterClearButton", adaptiveCloseButtonTitle: "adaptiveCloseButtonTitle", adaptiveBackButtonTitle: "adaptiveBackButtonTitle", filterAndLogic: "filterAndLogic", filterOrLogic: "filterOrLogic", filterToolbarToolText: "filterToolbarToolText", loading: "loading", gridLabel: "gridLabel", columnMenu: "columnMenu", setColumnPosition: "setColumnPosition", columns: "columns", columnChooserSelectAll: "columnChooserSelectAll", columnChooserSelectedColumnsCount: "columnChooserSelectedColumnsCount", columnsSubtitle: "columnsSubtitle", adaptiveFilterTitle: "adaptiveFilterTitle", adaptiveSortTitle: "adaptiveSortTitle", adaptiveGroupTitle: "adaptiveGroupTitle", filterClearAllButton: "filterClearAllButton", groupClearButton: "groupClearButton", sortClearButton: "sortClearButton", sortDoneButton: "sortDoneButton", groupDoneButton: "groupDoneButton", lock: "lock", unlock: "unlock", stick: "stick", unstick: "unstick", sortable: "sortable", sortAscending: "sortAscending", sortDescending: "sortDescending", autosizeThisColumn: "autosizeThisColumn", autosizeAllColumns: "autosizeAllColumns", sortedAscending: "sortedAscending", sortedDescending: "sortedDescending", sortedDefault: "sortedDefault", sortToolbarToolText: "sortToolbarToolText", columnsApply: "columnsApply", columnsReset: "columnsReset", detailExpand: "detailExpand", detailCollapse: "detailCollapse", filterDateToday: "filterDateToday", filterDateToggle: "filterDateToggle", filterNumericDecrement: "filterNumericDecrement", filterNumericIncrement: "filterNumericIncrement", selectionCheckboxLabel: "selectionCheckboxLabel", selectAllCheckboxLabel: "selectAllCheckboxLabel", groupCollapse: "groupCollapse", groupExpand: "groupExpand", topToolbarLabel: "topToolbarLabel", bottomToolbarLabel: "bottomToolbarLabel", editToolbarToolText: "editToolbarToolText", saveToolbarToolText: "saveToolbarToolText", addToolbarToolText: "addToolbarToolText", cancelToolbarToolText: "cancelToolbarToolText", removeToolbarToolText: "removeToolbarToolText", excelExportToolbarToolText: "excelExportToolbarToolText", pdfExportToolbarToolText: "pdfExportToolbarToolText", groupPanelLabel: "groupPanelLabel", dragRowHandleLabel: "dragRowHandleLabel", columnMenuFilterTabTitle: "columnMenuFilterTabTitle", columnMenuGeneralTabTitle: "columnMenuGeneralTabTitle", columnMenuColumnsTabTitle: "columnMenuColumnsTabTitle", groupChipMenuPrevious: "groupChipMenuPrevious", groupChipMenuNext: "groupChipMenuNext", groupToolbarToolText: "groupToolbarToolText", formValidationErrorText: "formValidationErrorText", removeConfirmationDialogTitle: "removeConfirmationDialogTitle", removeConfirmationDialogContent: "removeConfirmationDialogContent", removeConfirmationDialogConfirmText: "removeConfirmationDialogConfirmText", removeConfirmationDialogRejectText: "removeConfirmationDialogRejectText", externalEditingTitle: "externalEditingTitle", externalEditingAddTitle: "externalEditingAddTitle", externalEditingSaveText: "externalEditingSaveText", externalEditingCancelText: "externalEditingCancelText", multiCheckboxFilterSearchPlaceholder: "multiCheckboxFilterSearchPlaceholder", multiCheckboxFilterSelectAllLabel: "multiCheckboxFilterSelectAllLabel", multiCheckboxFilterSelectedItemsCount: "multiCheckboxFilterSelectedItemsCount" }, usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GridMessages, decorators: [{
            type: Directive,
            args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: 'kendo-grid-messages-base'
                }]
        }], propDecorators: { groupPanelEmpty: [{
                type: Input
            }], noRecords: [{
                type: Input
            }], pagerLabel: [{
                type: Input
            }], pagerFirstPage: [{
                type: Input
            }], pagerLastPage: [{
                type: Input
            }], pagerPreviousPage: [{
                type: Input
            }], pagerNextPage: [{
                type: Input
            }], pagerPage: [{
                type: Input
            }], pagerItemsPerPage: [{
                type: Input
            }], pagerOf: [{
                type: Input
            }], pagerItems: [{
                type: Input
            }], pagerPageNumberInputTitle: [{
                type: Input
            }], pagerInputLabel: [{
                type: Input
            }], pagerSelectPage: [{
                type: Input
            }], filter: [{
                type: Input
            }], filterInputLabel: [{
                type: Input
            }], filterMenuTitle: [{
                type: Input
            }], filterMenuOperatorsDropDownLabel: [{
                type: Input
            }], filterMenuLogicDropDownLabel: [{
                type: Input
            }], filterCellOperatorLabel: [{
                type: Input
            }], booleanFilterCellLabel: [{
                type: Input
            }], aiAssistantApplyButtonText: [{
                type: Input
            }], aiAssistantToolbarToolText: [{
                type: Input
            }], aiAssistantWindowTitle: [{
                type: Input
            }], aiAssistantWindowCloseTitle: [{
                type: Input
            }], aiAssistantOutputCardTitle: [{
                type: Input
            }], aiAssistantOutputCardBodyContent: [{
                type: Input
            }], aiAssistantSelectionNotEnabled: [{
                type: Input
            }], aiAssistantSelectionRowModeRequired: [{
                type: Input
            }], aiAssistantSelectionCellModeRequired: [{
                type: Input
            }], aiAssistantWindowMaximizeTitle: [{
                type: Input
            }], aiAssistantWindowMinimizeTitle: [{
                type: Input
            }], aiAssistantWindowRestoreTitle: [{
                type: Input
            }], filterEqOperator: [{
                type: Input
            }], filterNotEqOperator: [{
                type: Input
            }], filterIsNullOperator: [{
                type: Input
            }], filterIsNotNullOperator: [{
                type: Input
            }], filterIsEmptyOperator: [{
                type: Input
            }], filterIsNotEmptyOperator: [{
                type: Input
            }], filterStartsWithOperator: [{
                type: Input
            }], filterContainsOperator: [{
                type: Input
            }], filterNotContainsOperator: [{
                type: Input
            }], filterEndsWithOperator: [{
                type: Input
            }], filterGteOperator: [{
                type: Input
            }], filterGtOperator: [{
                type: Input
            }], filterLteOperator: [{
                type: Input
            }], filterLtOperator: [{
                type: Input
            }], filterIsTrue: [{
                type: Input
            }], filterIsFalse: [{
                type: Input
            }], filterBooleanAll: [{
                type: Input
            }], adaptiveFilterOperatorsTitle: [{
                type: Input
            }], filterAfterOrEqualOperator: [{
                type: Input
            }], filterAfterOperator: [{
                type: Input
            }], filterBeforeOperator: [{
                type: Input
            }], filterBeforeOrEqualOperator: [{
                type: Input
            }], filterFilterButton: [{
                type: Input
            }], filterClearButton: [{
                type: Input
            }], adaptiveCloseButtonTitle: [{
                type: Input
            }], adaptiveBackButtonTitle: [{
                type: Input
            }], filterAndLogic: [{
                type: Input
            }], filterOrLogic: [{
                type: Input
            }], filterToolbarToolText: [{
                type: Input
            }], loading: [{
                type: Input
            }], gridLabel: [{
                type: Input
            }], columnMenu: [{
                type: Input
            }], setColumnPosition: [{
                type: Input
            }], columns: [{
                type: Input
            }], columnChooserSelectAll: [{
                type: Input
            }], columnChooserSelectedColumnsCount: [{
                type: Input
            }], columnsSubtitle: [{
                type: Input
            }], adaptiveFilterTitle: [{
                type: Input
            }], adaptiveSortTitle: [{
                type: Input
            }], adaptiveGroupTitle: [{
                type: Input
            }], filterClearAllButton: [{
                type: Input
            }], groupClearButton: [{
                type: Input
            }], sortClearButton: [{
                type: Input
            }], sortDoneButton: [{
                type: Input
            }], groupDoneButton: [{
                type: Input
            }], lock: [{
                type: Input
            }], unlock: [{
                type: Input
            }], stick: [{
                type: Input
            }], unstick: [{
                type: Input
            }], sortable: [{
                type: Input
            }], sortAscending: [{
                type: Input
            }], sortDescending: [{
                type: Input
            }], autosizeThisColumn: [{
                type: Input
            }], autosizeAllColumns: [{
                type: Input
            }], sortedAscending: [{
                type: Input
            }], sortedDescending: [{
                type: Input
            }], sortedDefault: [{
                type: Input
            }], sortToolbarToolText: [{
                type: Input
            }], columnsApply: [{
                type: Input
            }], columnsReset: [{
                type: Input
            }], detailExpand: [{
                type: Input
            }], detailCollapse: [{
                type: Input
            }], filterDateToday: [{
                type: Input
            }], filterDateToggle: [{
                type: Input
            }], filterNumericDecrement: [{
                type: Input
            }], filterNumericIncrement: [{
                type: Input
            }], selectionCheckboxLabel: [{
                type: Input
            }], selectAllCheckboxLabel: [{
                type: Input
            }], groupCollapse: [{
                type: Input
            }], groupExpand: [{
                type: Input
            }], topToolbarLabel: [{
                type: Input
            }], bottomToolbarLabel: [{
                type: Input
            }], editToolbarToolText: [{
                type: Input
            }], saveToolbarToolText: [{
                type: Input
            }], addToolbarToolText: [{
                type: Input
            }], cancelToolbarToolText: [{
                type: Input
            }], removeToolbarToolText: [{
                type: Input
            }], excelExportToolbarToolText: [{
                type: Input
            }], pdfExportToolbarToolText: [{
                type: Input
            }], groupPanelLabel: [{
                type: Input
            }], dragRowHandleLabel: [{
                type: Input
            }], columnMenuFilterTabTitle: [{
                type: Input
            }], columnMenuGeneralTabTitle: [{
                type: Input
            }], columnMenuColumnsTabTitle: [{
                type: Input
            }], groupChipMenuPrevious: [{
                type: Input
            }], groupChipMenuNext: [{
                type: Input
            }], groupToolbarToolText: [{
                type: Input
            }], formValidationErrorText: [{
                type: Input
            }], removeConfirmationDialogTitle: [{
                type: Input
            }], removeConfirmationDialogContent: [{
                type: Input
            }], removeConfirmationDialogConfirmText: [{
                type: Input
            }], removeConfirmationDialogRejectText: [{
                type: Input
            }], externalEditingTitle: [{
                type: Input
            }], externalEditingAddTitle: [{
                type: Input
            }], externalEditingSaveText: [{
                type: Input
            }], externalEditingCancelText: [{
                type: Input
            }], multiCheckboxFilterSearchPlaceholder: [{
                type: Input
            }], multiCheckboxFilterSelectAllLabel: [{
                type: Input
            }], multiCheckboxFilterSelectedItemsCount: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class LocalizedMessagesDirective extends GridMessages {
    service;
    constructor(service) {
        super();
        this.service = service;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: LocalizedMessagesDirective, deps: [{ token: i1$2.LocalizationService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: LocalizedMessagesDirective, isStandalone: true, selector: "[kendoGridLocalizedMessages]", providers: [
            {
                provide: GridMessages,
                useExisting: forwardRef(() => LocalizedMessagesDirective)
            }
        ], usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: LocalizedMessagesDirective, decorators: [{
            type: Directive,
            args: [{
                    providers: [
                        {
                            provide: GridMessages,
                            useExisting: forwardRef(() => LocalizedMessagesDirective)
                        }
                    ],
                    selector: '[kendoGridLocalizedMessages]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1$2.LocalizationService }] });

/**
 * @hidden
 */
class FilterToolbarToolComponent {
    element;
    filterService;
    ctx;
    columnInfoService;
    ngZone;
    adaptiveGridService;
    filterItems;
    menuItems;
    filterContainers;
    close = new EventEmitter();
    get hostStyles() {
        return {
            'maxHeight': '400px',
            'overflowX': 'hidden',
            'overflowY': 'auto'
        };
    }
    columnMenuService;
    columns;
    filter;
    isFilterApplied(column) {
        if (!this.filter?.filters) {
            return false;
        }
        if (Array.isArray(this.filter.filters)) {
            for (const filterGroup of this.filter.filters) {
                if (filterGroup.filters && Array.isArray(filterGroup.filters)) {
                    for (const filter of filterGroup.filters) {
                        if (filter.field === column.field) {
                            return true;
                        }
                    }
                }
                else if (filterGroup.field === column.field) {
                    return true;
                }
            }
        }
        return false;
    }
    isItemFocused(filterItem) {
        return this.currentFocusedItem === filterItem;
    }
    onItemFocus(item) {
        this.currentFocusedItem = item;
    }
    onItemFocusOut() {
        this.currentFocusedItem = null;
    }
    currentFocusedItem = null;
    subscriptions;
    constructor(element, filterService, ctx, columnInfoService, ngZone, adaptiveGridService) {
        this.element = element;
        this.filterService = filterService;
        this.ctx = ctx;
        this.columnInfoService = columnInfoService;
        this.ngZone = ngZone;
        this.adaptiveGridService = adaptiveGridService;
    }
    ngOnInit() {
        this.columns = this.columnInfoService.leafNamedColumns.filter(column => column?.filterable);
        this.filter = this.ctx.grid.filter;
        this.subscriptions = this.filterService.changes.subscribe(filter => {
            this.filter = cloneFilters(filter);
        });
    }
    ngAfterViewInit() {
        this.ngZone.onStable.pipe(take(1)).subscribe(() => {
            this.filterItems?.get(0)?.nativeElement.focus({ preventScroll: true });
        });
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    }
    navigateView(column) {
        if (this.ctx.grid.isActionSheetExpanded && this.adaptiveGridService.viewType === 'filterToolbarTool') {
            const componentRef = this.ctx.grid.adaptiveRenderer.filterToolbarToolTemplate.createComponent(FilterMenuContainerComponent);
            componentRef.instance.column = this.getColumnComponent(column);
            componentRef.instance.filter = this.filter;
            this.subscriptions.add(componentRef.instance.close.subscribe(() => {
                this.adaptiveGridService.reset();
            }));
            this.adaptiveGridService.filterMenuContainerComponentRef = componentRef;
            this.adaptiveGridService.secondaryView = 'columnFilter';
            this.adaptiveGridService.column = this.getColumnComponent(column);
            this.ctx.grid.adaptiveRenderer.actionSheet.nextView();
        }
    }
    getColumnComponent(column) {
        return column;
    }
    handleClose(filterItem) {
        filterItem.expanded = false;
        filterItem.contentState = 'collapsed';
        const filterContainer = this.filterContainers.find(container => container.column === filterItem.column);
        if (filterContainer) {
            // reset the child filter to ensure it is reinitialized based on the global filter on the next open
            filterContainer.resetChildFilters();
        }
    }
    toggleItem(event, index) {
        const menuItem = this.menuItems.get(index);
        if (!menuItem || event.target.closest('.k-filter-menu-container')) {
            return;
        }
        if (menuItem.expanded) {
            this.filterContainers.get(index).isExpanded = false;
            menuItem.expanded = false;
            menuItem.contentState = 'collapsed';
        }
        else {
            this.filterContainers.get(index).isExpanded = true;
            menuItem.expanded = true;
            menuItem.contentState = 'expanded';
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FilterToolbarToolComponent, deps: [{ token: i0.ElementRef }, { token: FilterService }, { token: ContextService }, { token: ColumnInfoService }, { token: i0.NgZone }, { token: AdaptiveGridService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: FilterToolbarToolComponent, isStandalone: true, selector: "kendo-filter-toolbar-tool", outputs: { close: "close" }, viewQueries: [{ propertyName: "filterItems", predicate: ["filterItem"], descendants: true, read: ElementRef }, { propertyName: "menuItems", predicate: ["filterItem"], descendants: true }, { propertyName: "filterContainers", predicate: ["filterContainer"], descendants: true }], ngImport: i0, template: `
        <div [style]="hostStyles">
          @for (column of columns; track column; let i = $index) {
            <kendo-grid-columnmenu-item
              class="k-columnmenu-item-wrapper" #filterItem
              role="button"
              tabindex="0"
              [column]="getColumnComponent(column)"
              [text]="column.title || getColumnComponent(column).field"
              (focus)="onItemFocus(filterItem)"
              (focusout)="onItemFocusOut()"
              (keydown.enter)="toggleItem($event, i)"
              [indicatorIcon]="isFilterApplied(column)"
              (itemClick)="navigateView(getColumnComponent(column))"
              [expanded]="false"
              [focused]="isItemFocused(filterItem)">
              <ng-template kendoGridColumnMenuItemContentTemplate>
                <kendo-grid-filter-menu-container
                  #filterContainer
                  (keydown.shift.tab)="$event.stopImmediatePropagation()"
                  [column]="getColumnComponent(column)"
                  [filter]="filter"
                  [isExpanded]="false"
                  (close)="handleClose(filterItem)">
                </kendo-grid-filter-menu-container>
              </ng-template>
            </kendo-grid-columnmenu-item>
          }
        </div>
        `, isInline: true, dependencies: [{ kind: "component", type: FilterMenuContainerComponent, selector: "kendo-grid-filter-menu-container", inputs: ["column", "isLast", "isExpanded", "menuTabbingService", "filter", "actionsClass"], outputs: ["close"] }, { kind: "component", type: ColumnMenuItemComponent, selector: "kendo-grid-columnmenu-item", inputs: ["icon", "svgIcon", "indicatorIcon", "text", "selected", "disabled", "expanded", "focused", "service", "column"], outputs: ["itemClick", "expand", "collapse"] }, { kind: "directive", type: ColumnMenuItemContentTemplateDirective, selector: "[kendoGridColumnMenuItemContentTemplate]" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FilterToolbarToolComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-filter-toolbar-tool',
                    template: `
        <div [style]="hostStyles">
          @for (column of columns; track column; let i = $index) {
            <kendo-grid-columnmenu-item
              class="k-columnmenu-item-wrapper" #filterItem
              role="button"
              tabindex="0"
              [column]="getColumnComponent(column)"
              [text]="column.title || getColumnComponent(column).field"
              (focus)="onItemFocus(filterItem)"
              (focusout)="onItemFocusOut()"
              (keydown.enter)="toggleItem($event, i)"
              [indicatorIcon]="isFilterApplied(column)"
              (itemClick)="navigateView(getColumnComponent(column))"
              [expanded]="false"
              [focused]="isItemFocused(filterItem)">
              <ng-template kendoGridColumnMenuItemContentTemplate>
                <kendo-grid-filter-menu-container
                  #filterContainer
                  (keydown.shift.tab)="$event.stopImmediatePropagation()"
                  [column]="getColumnComponent(column)"
                  [filter]="filter"
                  [isExpanded]="false"
                  (close)="handleClose(filterItem)">
                </kendo-grid-filter-menu-container>
              </ng-template>
            </kendo-grid-columnmenu-item>
          }
        </div>
        `,
                    standalone: true,
                    imports: [KENDO_BUTTON, FilterMenuContainerComponent, ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective]
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: FilterService }, { type: ContextService }, { type: ColumnInfoService }, { type: i0.NgZone }, { type: AdaptiveGridService }], propDecorators: { filterItems: [{
                type: ViewChildren,
                args: ['filterItem', { read: ElementRef }]
            }], menuItems: [{
                type: ViewChildren,
                args: ['filterItem']
            }], filterContainers: [{
                type: ViewChildren,
                args: ['filterContainer']
            }], close: [{
                type: Output
            }] } });

/**
 * @hidden
 */
const directions = initialDirection => initialDirection === "asc" ? ["asc", "desc"] : ["desc", "asc"];
/**
 * @hidden
 */
class SortToolbarToolComponent {
    element;
    ngZone;
    sortItems;
    wrapperClasses = true;
    onEscKeyDown(event) {
        event.preventDefault();
        this.hostButton?.focus(event);
        this.close.emit();
    }
    close = new EventEmitter();
    sortClear = new EventEmitter();
    sort = new Array();
    columns = [];
    sortAscSmallIcon = sortAscSmallIcon;
    sortDescSmallIcon = sortDescSmallIcon;
    clearIcon = xIcon;
    _columnInfoService;
    set columnInfoService(columnInfoService) {
        this._columnInfoService = columnInfoService;
        this.columns = this.columnInfoService.leafNamedColumns.filter(column => column?.sortable);
    }
    get columnInfoService() {
        return this._columnInfoService;
    }
    _ctx;
    set ctx(ctx) {
        this._ctx = ctx;
        this.sort = ctx.grid.sort;
    }
    get ctx() {
        return this._ctx;
    }
    _sortService;
    set sortService(sortService) {
        this._sortService = sortService;
        this.subscription = this._sortService.changes.subscribe(sort => {
            this.sort = sort;
        });
    }
    get sortService() {
        return this._sortService;
    }
    subscription;
    hostButton;
    constructor(element, ngZone) {
        this.element = element;
        this.ngZone = ngZone;
    }
    ngAfterViewInit() {
        this.ngZone.onStable.pipe(take(1)).subscribe(() => {
            this.sortItems?.get(0)?.nativeElement.focus({ preventScroll: true });
        });
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
    toggleSort(column, ev) {
        if (this.hostButton.location !== 'toolbar') {
            ev.stopImmediatePropagation();
        }
        const field = column?.field;
        if (!field) {
            return;
        }
        const descriptor = this.getDescriptor(column);
        this.sort = descriptor;
        this.sortService.sort(descriptor);
    }
    getColumnComponent(column) {
        return column;
    }
    sortDescriptor(field) {
        return this.sort.find(item => item.field === field) || { field };
    }
    getDescriptor(column) {
        const { allowUnsort, mode, initialDirection } = normalize$1(this.ctx.grid.sortable, column.sortable);
        const field = column?.field;
        if (!field) {
            return;
        }
        const descriptorT = this.sort.find(item => item.field === field) || { field };
        const [first, second] = directions(initialDirection);
        let dir = first;
        if (descriptorT.dir === first) {
            dir = second;
        }
        else if (descriptorT.dir === second && allowUnsort) {
            dir = undefined;
        }
        const descriptor = { field, dir };
        if (mode === 'single') {
            return [descriptor];
        }
        return [...this.sort.filter(desc => desc.field !== field), descriptor];
    }
    showSortNumbering(column) {
        return this.sort
            && this.sort.filter(({ dir }) => isPresent$1(dir)).length > 1
            && this.sortOrder(column.field) > 0;
    }
    sortOrder(field) {
        return this.sort
            .filter(({ dir }) => isPresent$1(dir))
            .findIndex(x => x.field === field)
            + 1;
    }
    clearSorting() {
        if (!this.sort || this.sort.length === 0) {
            return;
        }
        this.sort = [];
        this.sortService.sort([]);
        this.sortClear.emit();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SortToolbarToolComponent, deps: [{ token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: SortToolbarToolComponent, isStandalone: true, selector: "kendo-sort-toolbar-tool", outputs: { close: "close", sortClear: "sortClear" }, host: { listeners: { "keydown.escape": "onEscKeyDown($event)" }, properties: { "class.k-column-menu": "this.wrapperClasses", "class.k-column-menu-md": "this.wrapperClasses" } }, viewQueries: [{ propertyName: "sortItems", predicate: ["sortItem"], descendants: true, read: ElementRef }], ngImport: i0, template: `
        <div
          class="k-column-menu-item-wrapper"
          [style.max-height.px]="200"
          [style.overflow-x]="'hidden'"
          [style.overflow-y]="'auto'"
          >
          @for (column of columns; track column) {
            <div
              #sortItem
              role="button"
              class="k-columnmenu-item"
              (click)="toggleSort(column, $event)"
              (keydown.enter)="toggleSort(column, $event)"
              [tabindex]="'0'"
              >
              {{column.title || getColumnComponent(column).field}}
              <span class="k-columnmenu-indicators">
                @if (sortDescriptor(getColumnComponent(column).field).dir) {
                  <kendo-icon-wrapper
                    name="sort-{{sortDescriptor(getColumnComponent(column).field).dir}}-small"
                    [svgIcon]="sortDescriptor(getColumnComponent(column).field).dir === 'asc' ? sortAscSmallIcon : sortDescSmallIcon"
                  ></kendo-icon-wrapper>
                }
                @if (showSortNumbering(getColumnComponent(column))) {
                  <span class="k-sort-index">{{sortOrder(getColumnComponent(column).field)}}</span>
                }
              </span>
            </div>
          }
        </div>
        
        <div class="k-actions k-actions-stretched k-actions-horizontal k-column-menu-footer">
          <button kendoButton
            [svgIcon]="clearIcon"
            icon="x"
            (click)="clearSorting()">
            {{ctx?.localization.get('sortClearButton')}}
          </button>
        </div>
        `, isInline: true, dependencies: [{ kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "component", type: i1$6.ButtonComponent, selector: "button[kendoButton]", inputs: ["arrowIcon", "toggleable", "togglable", "selected", "tabIndex", "imageUrl", "iconClass", "icon", "disabled", "size", "rounded", "fillMode", "themeColor", "svgIcon", "primary", "look"], outputs: ["selectedChange", "click"], exportAs: ["kendoButton"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SortToolbarToolComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-sort-toolbar-tool',
                    template: `
        <div
          class="k-column-menu-item-wrapper"
          [style.max-height.px]="200"
          [style.overflow-x]="'hidden'"
          [style.overflow-y]="'auto'"
          >
          @for (column of columns; track column) {
            <div
              #sortItem
              role="button"
              class="k-columnmenu-item"
              (click)="toggleSort(column, $event)"
              (keydown.enter)="toggleSort(column, $event)"
              [tabindex]="'0'"
              >
              {{column.title || getColumnComponent(column).field}}
              <span class="k-columnmenu-indicators">
                @if (sortDescriptor(getColumnComponent(column).field).dir) {
                  <kendo-icon-wrapper
                    name="sort-{{sortDescriptor(getColumnComponent(column).field).dir}}-small"
                    [svgIcon]="sortDescriptor(getColumnComponent(column).field).dir === 'asc' ? sortAscSmallIcon : sortDescSmallIcon"
                  ></kendo-icon-wrapper>
                }
                @if (showSortNumbering(getColumnComponent(column))) {
                  <span class="k-sort-index">{{sortOrder(getColumnComponent(column).field)}}</span>
                }
              </span>
            </div>
          }
        </div>
        
        <div class="k-actions k-actions-stretched k-actions-horizontal k-column-menu-footer">
          <button kendoButton
            [svgIcon]="clearIcon"
            icon="x"
            (click)="clearSorting()">
            {{ctx?.localization.get('sortClearButton')}}
          </button>
        </div>
        `,
                    standalone: true,
                    imports: [IconWrapperComponent, KENDO_BUTTON]
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { sortItems: [{
                type: ViewChildren,
                args: ['sortItem', { read: ElementRef }]
            }], wrapperClasses: [{
                type: HostBinding,
                args: ['class.k-column-menu']
            }, {
                type: HostBinding,
                args: ['class.k-column-menu-md']
            }], onEscKeyDown: [{
                type: HostListener,
                args: ['keydown.escape', ['$event']]
            }], close: [{
                type: Output
            }], sortClear: [{
                type: Output
            }] } });

/**
 * @hidden
 */
class FormFormFieldComponent {
    localization;
    cdr;
    control;
    floatingLabel;
    showError;
    input;
    constructor(localization, cdr) {
        this.localization = localization;
        this.cdr = cdr;
    }
    // required to avoid ExpressionChangedAfterItHasBeenCheckedError caused by
    // binding to the label's 'for' attribute dynamically
    ngAfterContentInit() {
        this.cdr.detectChanges();
    }
    messageFor(key, errorName, field) {
        return replaceMessagePlaceholder(replaceMessagePlaceholder(this.localization.get(key), 'fieldName', field), 'errorName', errorName);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FormFormFieldComponent, deps: [{ token: i1$2.LocalizationService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: FormFormFieldComponent, isStandalone: true, selector: "kendo-form-formfield", inputs: { control: "control", floatingLabel: "floatingLabel", showError: "showError" }, viewQueries: [{ propertyName: "input", first: true, predicate: ["input"], descendants: true }], ngImport: i0, template: `
        <kendo-formfield
          [orientation]="control.orientation">
          @if (control.label && floatingLabel && $any(control.dataType) !== 'boolean') {
            <kendo-floatinglabel
              labelCssClass="k-form-label"
              [text]="control.label">
              @if ($any(control.dataType) === 'text') {
                <kendo-textbox
                [formControl]="control.formControl"></kendo-textbox>
              }
              @if ($any(control.dataType) === 'numeric') {
                <kendo-numerictextbox
                [formControl]="control.formControl"></kendo-numerictextbox>
              }
              @if ($any(control.dataType) === 'date') {
                <kendo-datepicker
                [formControl]="control.formControl"></kendo-datepicker>
              }
            </kendo-floatinglabel>
          }
          @if (control.label && !floatingLabel && $any(control.dataType) !== 'boolean') {
            <kendo-label [style.align-items]="'start'"
              labelCssClass="k-form-label"
              [text]="control.label"
              [for]="input">
            </kendo-label>
          }
          @if (!floatingLabel && (control.dataType) === 'text') {
            <kendo-textbox #input
            [formControl]="control.formControl"></kendo-textbox>
          }
          @if (!floatingLabel && $any(control.dataType) === 'numeric') {
            <kendo-numerictextbox #input
            [formControl]="control.formControl"></kendo-numerictextbox>
          }
          @if (!floatingLabel && $any(control.dataType) === 'date') {
            <kendo-datepicker #input
            [formControl]="control.formControl"></kendo-datepicker>
          }
          @if (control.label && $any(control.dataType) === 'boolean') {
            <div
              class="k-form-field-checkbox-wrap">
              <kendo-checkbox #cb [formControl]="control.formControl"></kendo-checkbox>
              @if (control.label) {
                <kendo-label
                  class="k-checkbox-label"
                  [for]="cb"
                  [text]="control.label">
                </kendo-label>
              }
            </div>
          }
        
          @if (control?.hint) {
            <kendo-formhint>{{control.hint}}</kendo-formhint>
          }
          @if (showError && control.formControl?.invalid && control.formControl.touched) {
            @for (err of control?.formControl?.errors | keyvalue; track err) {
              <kendo-formerror>{{control.errors ? control.errors[err.key] : messageFor('formValidationError', err.key, control.name)}}</kendo-formerror>
            }
          }
        </kendo-formfield>
        `, isInline: true, dependencies: [{ kind: "pipe", type: KeyValuePipe, name: "keyvalue" }, { kind: "ngmodule", type: ReactiveFormsModule }, { kind: "directive", type: i2$2.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$2.FormControlDirective, selector: "[formControl]", inputs: ["formControl", "disabled", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }, { kind: "component", type: i3.LabelComponent, selector: "kendo-label", inputs: ["text", "for", "optional", "labelCssStyle", "labelCssClass"], exportAs: ["kendoLabel"] }, { kind: "component", type: i3.FloatingLabelComponent, selector: "kendo-floatinglabel", inputs: ["labelCssStyle", "labelCssClass", "id", "text", "optional"], outputs: ["positionChange"], exportAs: ["kendoFloatingLabel"] }, { kind: "component", type: i4.FormFieldComponent, selector: "kendo-formfield", inputs: ["showHints", "orientation", "showErrors", "colSpan"] }, { kind: "component", type: i4.HintComponent, selector: "kendo-formhint", inputs: ["align"] }, { kind: "component", type: i4.ErrorComponent, selector: "kendo-formerror", inputs: ["align"] }, { kind: "component", type: i4.TextBoxComponent, selector: "kendo-textbox", inputs: ["focusableId", "title", "type", "disabled", "readonly", "tabindex", "value", "selectOnFocus", "showSuccessIcon", "showErrorIcon", "clearButton", "successIcon", "successSvgIcon", "errorIcon", "errorSvgIcon", "clearButtonIcon", "clearButtonSvgIcon", "size", "rounded", "fillMode", "tabIndex", "placeholder", "maxlength", "inputAttributes"], outputs: ["valueChange", "inputFocus", "inputBlur", "focus", "blur"], exportAs: ["kendoTextBox"] }, { kind: "component", type: i4.NumericTextBoxComponent, selector: "kendo-numerictextbox", inputs: ["focusableId", "disabled", "readonly", "title", "autoCorrect", "format", "max", "min", "decimals", "placeholder", "step", "spinners", "rangeValidation", "tabindex", "tabIndex", "changeValueOnScroll", "selectOnFocus", "value", "maxlength", "size", "rounded", "fillMode", "inputAttributes"], outputs: ["valueChange", "focus", "blur", "inputFocus", "inputBlur"], exportAs: ["kendoNumericTextBox"] }, { kind: "component", type: i4.CheckBoxComponent, selector: "kendo-checkbox", inputs: ["checkedState", "rounded"], outputs: ["checkedStateChange"], exportAs: ["kendoCheckBox"] }, { kind: "component", type: i5.DatePickerComponent, selector: "kendo-datepicker", inputs: ["focusableId", "cellTemplate", "clearButton", "inputAttributes", "monthCellTemplate", "yearCellTemplate", "decadeCellTemplate", "centuryCellTemplate", "weekNumberTemplate", "headerTitleTemplate", "headerTemplate", "footerTemplate", "footer", "navigationItemTemplate", "weekDaysFormat", "showOtherMonthDays", "activeView", "bottomView", "topView", "calendarType", "animateCalendarNavigation", "disabled", "readonly", "readOnlyInput", "popupSettings", "navigation", "min", "max", "incompleteDateValidation", "autoCorrectParts", "autoSwitchParts", "autoSwitchKeys", "enableMouseWheel", "allowCaretMode", "autoFill", "focusedDate", "value", "format", "twoDigitYearMax", "formatPlaceholder", "placeholder", "tabindex", "tabIndex", "disabledDates", "adaptiveTitle", "adaptiveSubtitle", "rangeValidation", "disabledDatesValidation", "weekNumber", "size", "rounded", "fillMode", "adaptiveMode"], outputs: ["valueChange", "focus", "blur", "open", "close", "escape"], exportAs: ["kendo-datepicker"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FormFormFieldComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-form-formfield',
                    standalone: true,
                    imports: [KeyValuePipe, ReactiveFormsModule, KENDO_LABELS, KENDO_FORMFIELD, KENDO_TEXTBOX, KENDO_NUMERICTEXTBOX, KENDO_BUTTON, KENDO_CHECKBOX, KENDO_DATEPICKER],
                    template: `
        <kendo-formfield
          [orientation]="control.orientation">
          @if (control.label && floatingLabel && $any(control.dataType) !== 'boolean') {
            <kendo-floatinglabel
              labelCssClass="k-form-label"
              [text]="control.label">
              @if ($any(control.dataType) === 'text') {
                <kendo-textbox
                [formControl]="control.formControl"></kendo-textbox>
              }
              @if ($any(control.dataType) === 'numeric') {
                <kendo-numerictextbox
                [formControl]="control.formControl"></kendo-numerictextbox>
              }
              @if ($any(control.dataType) === 'date') {
                <kendo-datepicker
                [formControl]="control.formControl"></kendo-datepicker>
              }
            </kendo-floatinglabel>
          }
          @if (control.label && !floatingLabel && $any(control.dataType) !== 'boolean') {
            <kendo-label [style.align-items]="'start'"
              labelCssClass="k-form-label"
              [text]="control.label"
              [for]="input">
            </kendo-label>
          }
          @if (!floatingLabel && (control.dataType) === 'text') {
            <kendo-textbox #input
            [formControl]="control.formControl"></kendo-textbox>
          }
          @if (!floatingLabel && $any(control.dataType) === 'numeric') {
            <kendo-numerictextbox #input
            [formControl]="control.formControl"></kendo-numerictextbox>
          }
          @if (!floatingLabel && $any(control.dataType) === 'date') {
            <kendo-datepicker #input
            [formControl]="control.formControl"></kendo-datepicker>
          }
          @if (control.label && $any(control.dataType) === 'boolean') {
            <div
              class="k-form-field-checkbox-wrap">
              <kendo-checkbox #cb [formControl]="control.formControl"></kendo-checkbox>
              @if (control.label) {
                <kendo-label
                  class="k-checkbox-label"
                  [for]="cb"
                  [text]="control.label">
                </kendo-label>
              }
            </div>
          }
        
          @if (control?.hint) {
            <kendo-formhint>{{control.hint}}</kendo-formhint>
          }
          @if (showError && control.formControl?.invalid && control.formControl.touched) {
            @for (err of control?.formControl?.errors | keyvalue; track err) {
              <kendo-formerror>{{control.errors ? control.errors[err.key] : messageFor('formValidationError', err.key, control.name)}}</kendo-formerror>
            }
          }
        </kendo-formfield>
        `
                }]
        }], ctorParameters: () => [{ type: i1$2.LocalizationService }, { type: i0.ChangeDetectorRef }], propDecorators: { control: [{
                type: Input
            }], floatingLabel: [{
                type: Input
            }], showError: [{
                type: Input
            }], input: [{
                type: ViewChild,
                args: ['input']
            }] } });

let idx = 0;
/**
 * @hidden
 */
class FormComponent {
    controls = [];
    set formSettings(value) {
        this._formSettings = { ...this._formSettings, ...value };
    }
    get formSettings() {
        return this._formSettings;
    }
    formGroup;
    set actionButtons(value) {
        if (typeof value === 'boolean') {
            this.normalizeActionButtonSettings(value);
        }
        else {
            this._actionButtons = value;
        }
    }
    get actionButtons() {
        return this._actionButtons;
    }
    formSubmit = new EventEmitter();
    get componentIndex() {
        return idx++;
    }
    _formSettings = {
        orientation: 'vertical',
        showErrors: true,
        floatingLabels: false
    };
    defaultActionButtons = [{
            actionType: 'submit',
            text: 'Submit',
            svgIcon: saveIcon,
            icon: 'save',
            themeColor: 'primary'
        }, {
            actionType: 'reset',
            svgIcon: cancelIcon,
            text: 'Reset',
            icon: 'cancel'
        }];
    _actionButtons = this.defaultActionButtons;
    ngOnInit() {
        idx++;
    }
    normalizeActionButtonSettings(value) {
        this._actionButtons = value ? this.defaultActionButtons : [];
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FormComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: FormComponent, isStandalone: true, selector: "kendo-grid-external-form", inputs: { controls: "controls", formSettings: "formSettings", formGroup: "formGroup", actionButtons: "actionButtons" }, outputs: { formSubmit: "formSubmit" }, ngImport: i0, template: `
        <div role="form"
          class="k-form k-form-md"
          [class.k-form-horizontal]="formSettings.orientation === 'horizontal'"
          [formGroup]="formGroup"
          (ngSubmit)="formSubmit.next({originalEvent: $event, formGroup})"
          (reset)="$event.preventDefault()">
          @for (control of controls; track control; let idx = $index) {
            @if (!control.template) {
              <kendo-form-formfield
                [control]="control"
                [showError]="formSettings.showErrors"
              [floatingLabel]="formSettings.floatingLabels"></kendo-form-formfield>
            } @else {
              <ng-container
                [ngTemplateOutlet]="control.template"
              [ngTemplateOutletContext]="control.templateContext"></ng-container>
            }
            <ng-template #template>
              <ng-container
                [ngTemplateOutlet]="control.template"
              [ngTemplateOutletContext]="control.templateContext"></ng-container>
            </ng-template>
          }
          @if ($any(actionButtons).length) {
            <div class="k-form-buttons">
              @for (button of $any(actionButtons); track button) {
                <button kendoButton
                  [class.k-form-submit]="button.actionType === 'submit'"
                  [size]="button.size"
                  [themeColor]="button.themeColor || button.actionType === 'submit' ? 'primary' : undefined"
                  [rounded]="button.rounded"
                  [attr.type]="button.actionType"
                  [svgIcon]="button.svgIcon"
                  [icon]="button.icon">
                  {{button.text}}
                </button>
              }
            </div>
          }
        </div>
        `, isInline: true, dependencies: [{ kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "ngmodule", type: ReactiveFormsModule }, { kind: "directive", type: i2$2.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { kind: "directive", type: i2$2.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { kind: "component", type: FormFormFieldComponent, selector: "kendo-form-formfield", inputs: ["control", "floatingLabel", "showError"] }, { kind: "component", type: i1$6.ButtonComponent, selector: "button[kendoButton]", inputs: ["arrowIcon", "toggleable", "togglable", "selected", "tabIndex", "imageUrl", "iconClass", "icon", "disabled", "size", "rounded", "fillMode", "themeColor", "svgIcon", "primary", "look"], outputs: ["selectedChange", "click"], exportAs: ["kendoButton"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FormComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-external-form',
                    standalone: true,
                    template: `
        <div role="form"
          class="k-form k-form-md"
          [class.k-form-horizontal]="formSettings.orientation === 'horizontal'"
          [formGroup]="formGroup"
          (ngSubmit)="formSubmit.next({originalEvent: $event, formGroup})"
          (reset)="$event.preventDefault()">
          @for (control of controls; track control; let idx = $index) {
            @if (!control.template) {
              <kendo-form-formfield
                [control]="control"
                [showError]="formSettings.showErrors"
              [floatingLabel]="formSettings.floatingLabels"></kendo-form-formfield>
            } @else {
              <ng-container
                [ngTemplateOutlet]="control.template"
              [ngTemplateOutletContext]="control.templateContext"></ng-container>
            }
            <ng-template #template>
              <ng-container
                [ngTemplateOutlet]="control.template"
              [ngTemplateOutletContext]="control.templateContext"></ng-container>
            </ng-template>
          }
          @if ($any(actionButtons).length) {
            <div class="k-form-buttons">
              @for (button of $any(actionButtons); track button) {
                <button kendoButton
                  [class.k-form-submit]="button.actionType === 'submit'"
                  [size]="button.size"
                  [themeColor]="button.themeColor || button.actionType === 'submit' ? 'primary' : undefined"
                  [rounded]="button.rounded"
                  [attr.type]="button.actionType"
                  [svgIcon]="button.svgIcon"
                  [icon]="button.icon">
                  {{button.text}}
                </button>
              }
            </div>
          }
        </div>
        `,
                    imports: [NgTemplateOutlet, ReactiveFormsModule, FormFormFieldComponent, KENDO_BUTTON],
                }]
        }], propDecorators: { controls: [{
                type: Input
            }], formSettings: [{
                type: Input
            }], formGroup: [{
                type: Input
            }], actionButtons: [{
                type: Input
            }], formSubmit: [{
                type: Output
            }] } });

/**
 * @hidden
 */
class DialogFormComponent extends DialogContentBase {
    localization;
    controls;
    formGroup;
    formSettings;
    saveIcon = saveIcon;
    cancelIcon = cancelIcon;
    constructor(dialogRef, localization) {
        super(dialogRef);
        this.localization = localization;
    }
    save() {
        this.dialog.close({ text: this.localization.get('externalEditingSaveText') });
    }
    cancel() {
        this.dialog.close({ text: this.localization.get('externalEditingCancelText') });
    }
    messageFor(key) {
        return this.localization.get(key);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DialogFormComponent, deps: [{ token: i1$7.DialogRef }, { token: i1$2.LocalizationService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: DialogFormComponent, isStandalone: true, selector: "kendo-grid-dialog-form", inputs: { controls: "controls", formGroup: "formGroup", formSettings: "formSettings" }, usesInheritance: true, ngImport: i0, template: `
        <kendo-grid-external-form
            [controls]="controls"
            [formGroup]="formGroup"
            [formSettings]="formSettings"
            [actionButtons]="false"></kendo-grid-external-form>
        <kendo-dialog-actions [layout]="this.dialog?.dialog?.instance?.actionsLayout">
            <button
                kendoButton
                themeColor="primary"
                [svgIcon]="saveIcon"
                [disabled]="!formGroup.valid"
                (click)="save()"
            >
                {{messageFor('externalEditingSaveText')}}
            </button>
            <button
                kendoButton
                [svgIcon]="cancelIcon"
                (click)="cancel()">
                {{messageFor('externalEditingCancelText')}}
            </button>
        </kendo-dialog-actions>
    `, isInline: true, dependencies: [{ kind: "component", type: FormComponent, selector: "kendo-grid-external-form", inputs: ["controls", "formSettings", "formGroup", "actionButtons"], outputs: ["formSubmit"] }, { kind: "component", type: DialogActionsComponent, selector: "kendo-dialog-actions", inputs: ["actions", "layout"], outputs: ["action"] }, { kind: "component", type: i1$6.ButtonComponent, selector: "button[kendoButton]", inputs: ["arrowIcon", "toggleable", "togglable", "selected", "tabIndex", "imageUrl", "iconClass", "icon", "disabled", "size", "rounded", "fillMode", "themeColor", "svgIcon", "primary", "look"], outputs: ["selectedChange", "click"], exportAs: ["kendoButton"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DialogFormComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-dialog-form',
                    standalone: true,
                    imports: [FormComponent, DialogActionsComponent, KENDO_BUTTON],
                    template: `
        <kendo-grid-external-form
            [controls]="controls"
            [formGroup]="formGroup"
            [formSettings]="formSettings"
            [actionButtons]="false"></kendo-grid-external-form>
        <kendo-dialog-actions [layout]="this.dialog?.dialog?.instance?.actionsLayout">
            <button
                kendoButton
                themeColor="primary"
                [svgIcon]="saveIcon"
                [disabled]="!formGroup.valid"
                (click)="save()"
            >
                {{messageFor('externalEditingSaveText')}}
            </button>
            <button
                kendoButton
                [svgIcon]="cancelIcon"
                (click)="cancel()">
                {{messageFor('externalEditingCancelText')}}
            </button>
        </kendo-dialog-actions>
    `
                }]
        }], ctorParameters: () => [{ type: i1$7.DialogRef }, { type: i1$2.LocalizationService }], propDecorators: { controls: [{
                type: Input
            }], formGroup: [{
                type: Input
            }], formSettings: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class GroupToolbarToolComponent {
    element;
    ngZone;
    hostClass = true;
    get lgClass() {
        return this.adaptive;
    }
    get mdClass() {
        return !this.adaptive;
    }
    onEscKeyDown(event) {
        event.preventDefault();
        this.hostButton?.focus(event);
        this.close.emit();
    }
    set groupItems(items) {
        this._groupItems = items;
        if (items?.first && (!isPresent$1(this.currentFocusedItemIndex) || this.currentFocusedItemIndex >= items.length || this.currentFocusedItemIndex < 0)) {
            this.ngZone.onStable.pipe(take(1)).subscribe(() => {
                this.currentFocusedItemIndex = 0;
                this.groupItems.first.nativeElement.focus({ preventScroll: true });
            });
            return;
        }
        if (items?.first) {
            items.get(this.currentFocusedItemIndex).nativeElement.focus({ preventScroll: true });
        }
    }
    get groupItems() {
        return this._groupItems;
    }
    _groupItems;
    adaptive = false;
    close = new EventEmitter();
    groupClear = new EventEmitter();
    currentFocusedItemIndex;
    group = new Array();
    columns = [];
    iconSize = 'medium';
    upIcon = chevronUpIcon;
    downIcon = chevronDownIcon;
    removeIcon = xCircleIcon;
    addIcon = plusCircleIcon;
    clearIcon = xIcon;
    _ctx;
    set ctx(ctx) {
        if (!ctx || !ctx.grid) {
            return;
        }
        this._ctx = ctx;
        this.group = ctx.grid.group;
        this.subscription = ctx.grid.groupChange.subscribe((group) => {
            this.group = group;
            this.updateGroupedColumns();
        });
        this.ngZone.onStable.pipe(take(1)).subscribe(() => {
            this.updateGroupedColumns();
        });
    }
    get ctx() {
        return this._ctx;
    }
    groupedColumns = [];
    ungroupedColumns = [];
    subscription;
    hostButton;
    constructor(element, ngZone) {
        this.element = element;
        this.ngZone = ngZone;
    }
    ngOnInit() {
        this.iconSize = this.adaptive ? 'large' : 'medium';
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
    addGroup(column, ev) {
        ev.stopImmediatePropagation();
        const index = this.group.length;
        const groups = this.group.filter(x => x.field !== column?.field);
        if (groups.length || this.group.length === 0) {
            this.group = [...groups.slice(0, index), { field: column?.field }, ...groups.slice(index)];
            this.ctx.grid.groupChange.emit(this.group);
            this.updateGroupedColumns();
            this.ngZone.onStable.pipe(take(1)).subscribe(() => {
                const newIndex = this.groupedColumns.length - 1;
                const newItem = this.groupItems.get(newIndex);
                if (newItem) {
                    this.currentFocusedItemIndex = (this.groupedColumns?.length || 0) + newIndex;
                    newItem.nativeElement.focus();
                }
            });
        }
    }
    removeGroup(column, ev) {
        ev.stopImmediatePropagation();
        this.group = this.group.filter(x => x.field !== column?.field);
        this.ctx.grid.groupChange.emit(this.group);
        this.updateGroupedColumns();
        this.ngZone.onStable.pipe(take(1)).subscribe(() => {
            const newIndex = this.ungroupedColumns.findIndex(ungroupedColumn => ungroupedColumn?.field === column?.field);
            const newItem = this.groupItems.get(newIndex + this.groupedColumns.length);
            if (newItem) {
                newItem.nativeElement.focus();
            }
        });
    }
    moveGroupUp(column, ev) {
        ev.stopImmediatePropagation();
        const index = this.group.findIndex(x => x.field === column?.field);
        if (index > 0) {
            const groupToMove = this.group[index];
            this.group.splice(index, 1);
            this.group.splice(index - 1, 0, groupToMove);
            this.ctx.grid.groupChange.emit(this.group);
            this.updateGroupedColumns();
            this.ngZone.onStable.pipe(take(1)).subscribe(() => {
                const newItem = this.groupItems.get(index - 1);
                if (newItem) {
                    newItem.nativeElement.focus();
                    this.currentFocusedItemIndex = index - 1;
                }
            });
        }
    }
    moveGroupDown(column, ev) {
        ev.stopImmediatePropagation();
        const index = this.group.findIndex(x => x.field === column?.field);
        if (index < this.group.length - 1) {
            const groupToMove = this.group[index];
            this.group.splice(index, 1);
            this.group.splice(index + 1, 0, groupToMove);
            this.ctx.grid.groupChange.emit(this.group);
            this.updateGroupedColumns();
            this.ngZone.onStable.pipe(take(1)).subscribe(() => {
                const newItem = this.groupItems.get(index + 1);
                if (newItem) {
                    newItem.nativeElement.focus();
                    this.currentFocusedItemIndex = index + 1;
                }
            });
        }
    }
    clear() {
        this.group = [];
        this.ctx.grid.groupChange.emit(this.group);
        this.groupClear.emit(this.group);
    }
    getColumnComponent(column) {
        return column;
    }
    onItemFocus(groupIndex, index) {
        const currentIndex = (typeof groupIndex === 'number' ? groupIndex : this.groupedColumns?.length || 0) + index;
        this.currentFocusedItemIndex = currentIndex;
    }
    handleGroupedKeydown(column, index, ev) {
        const code = normalizeKeys(ev);
        if (code === Keys.Enter || code === Keys.Backspace || code === Keys.Delete) {
            this.removeGroup(column, ev);
        }
        else if (code === Keys.ArrowUp && ev.shiftKey) {
            this.moveGroupUp(column, ev);
        }
        else if (code === Keys.ArrowDown && ev.shiftKey) {
            this.moveGroupDown(column, ev);
        }
        else if (code === Keys.ArrowUp) {
            this.navigateToPreviousItem();
        }
        else if (code === Keys.ArrowDown) {
            this.navigateToNextItem();
        }
    }
    handleUngroupedKeydown(column, index, ev) {
        const code = normalizeKeys(ev);
        if (code === Keys.Enter) {
            this.addGroup(column, ev);
        }
        else if (code === Keys.ArrowUp) {
            this.navigateToPreviousItem();
        }
        else if (code === Keys.ArrowDown) {
            this.navigateToNextItem();
        }
    }
    updateGroupedColumns() {
        const columns = this.ctx.grid['columnInfoService'].leafNamedColumns;
        const groupableColumns = columns.filter(column => column?.groupable);
        this.groupedColumns = this.group
            .map(group => columns.find(column => column?.field === group.field))
            .filter(column => !!column);
        this.ungroupedColumns = groupableColumns.filter(column => !this.groupedColumns.some(gc => gc?.field === column?.field));
    }
    navigateToNextItem() {
        if (this.currentFocusedItemIndex < this.groupItems.length - 1) {
            this.currentFocusedItemIndex++;
            this.groupItems.get(this.currentFocusedItemIndex).nativeElement.focus();
        }
        else if (this.currentFocusedItemIndex === this.groupItems.length - 1) {
            this.currentFocusedItemIndex = 0;
            this.groupItems.get(this.currentFocusedItemIndex).nativeElement.focus();
        }
    }
    navigateToPreviousItem() {
        if (this.currentFocusedItemIndex > 0) {
            this.currentFocusedItemIndex--;
            this.groupItems.get(this.currentFocusedItemIndex).nativeElement.focus();
        }
        else if (this.currentFocusedItemIndex === 0) {
            this.currentFocusedItemIndex = this.groupItems.length - 1;
            this.groupItems.get(this.currentFocusedItemIndex).nativeElement.focus();
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GroupToolbarToolComponent, deps: [{ token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: GroupToolbarToolComponent, isStandalone: true, selector: "kendo-group-toolbar-tool", inputs: { adaptive: "adaptive" }, outputs: { close: "close", groupClear: "groupClear" }, host: { listeners: { "keydown.escape": "onEscKeyDown($event)" }, properties: { "class.k-group-menu": "this.hostClass", "class.k-group-menu-lg": "this.lgClass", "class.k-group-menu-md": "this.mdClass" } }, viewQueries: [{ propertyName: "groupItems", predicate: ["groupItem"], descendants: true, read: ElementRef }], ngImport: i0, template: `
        @if (groupedColumns.length) {
          <div class="k-group-menu-item-wrap">
            @for (column of groupedColumns; track column; let i = $index) {
              <div
                #groupItem
                role="button"
                class="k-group-menu-item"
                tabindex="0"
                (keydown)="handleGroupedKeydown(column, i, $event)"
                (focus)="onItemFocus(i, 0)"
                >
                @if (groupedColumns.length > 1) {
                  <span class="k-group-menu-item-actions">
                    <span
                      class="k-group-menu-item-action k-group-menu-item-up-action"
                      (click)="moveGroupUp(column, $event)"
                      [attr.aria-disabled]="i === 0"
                      [class.k-disabled]="i === 0"
                      >
                      <kendo-icon-wrapper
                        name="arrow-chevron-up"
                        [svgIcon]="upIcon"
                        [size]="iconSize"
                      ></kendo-icon-wrapper>
                    </span>
                    <span
                      class="k-group-menu-item-action k-group-menu-item-down-action"
                      (click)="moveGroupDown(column, $event)"
                      [attr.aria-disabled]="i === groupedColumns.length - 1"
                      [class.k-disabled]="i === groupedColumns.length - 1"
                      >
                      <kendo-icon-wrapper
                        name="arrow-chevron-down"
                        [svgIcon]="downIcon"
                        [size]="iconSize"
                      ></kendo-icon-wrapper>
                    </span>
                  </span>
                }
                <span class="k-group-item-text">{{column.title || getColumnComponent(column).field}}</span>
                <span class="k-spacer"></span>
                <span class="k-group-menu-item-actions">
                  <span class="k-group-menu-item-action k-group-menu-item-remove-action" (click)="removeGroup(column, $event)">
                    <kendo-icon-wrapper
                      name="x-circle"
                      [svgIcon]="removeIcon"
                      [size]="iconSize"
                    ></kendo-icon-wrapper>
                  </span>
                </span>
              </div>
            }
          </div>
        }
        
        @if (ungroupedColumns.length) {
          <div class="k-group-menu-item-wrap">
            @for (column of ungroupedColumns; track column; let i = $index) {
              <div
                #groupItem
                role="button"
                class="k-group-menu-item"
                tabindex="0"
                (keydown)="handleUngroupedKeydown(column, i, $event)"
                (focus)="onItemFocus(null, i)"
                >
                <span class="k-group-item-text">{{column.title || getColumnComponent(column).field}}</span>
                <span class="k-spacer"></span>
                <span class="k-group-menu-item-actions">
                  <span class="k-group-menu-item-action k-group-menu-item-add-action" (click)="addGroup(column, $event)">
                    <kendo-icon-wrapper
                      name="plus-circle"
                      [svgIcon]="addIcon"
                      [size]="iconSize"
                    ></kendo-icon-wrapper>
                  </span>
                </span>
              </div>
            }
          </div>
        }
        
        @if (!adaptive) {
          <div class="k-actions k-actions-stretched k-actions-horizontal k-column-menu-footer">
            <button kendoButton
              [svgIcon]="clearIcon"
              (click)="clear()"
              icon="x"
              >
              {{ctx?.localization.get('groupClearButton')}}
            </button>
          </div>
        }
        `, isInline: true, dependencies: [{ kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "component", type: i1$6.ButtonComponent, selector: "button[kendoButton]", inputs: ["arrowIcon", "toggleable", "togglable", "selected", "tabIndex", "imageUrl", "iconClass", "icon", "disabled", "size", "rounded", "fillMode", "themeColor", "svgIcon", "primary", "look"], outputs: ["selectedChange", "click"], exportAs: ["kendoButton"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GroupToolbarToolComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-group-toolbar-tool',
                    template: `
        @if (groupedColumns.length) {
          <div class="k-group-menu-item-wrap">
            @for (column of groupedColumns; track column; let i = $index) {
              <div
                #groupItem
                role="button"
                class="k-group-menu-item"
                tabindex="0"
                (keydown)="handleGroupedKeydown(column, i, $event)"
                (focus)="onItemFocus(i, 0)"
                >
                @if (groupedColumns.length > 1) {
                  <span class="k-group-menu-item-actions">
                    <span
                      class="k-group-menu-item-action k-group-menu-item-up-action"
                      (click)="moveGroupUp(column, $event)"
                      [attr.aria-disabled]="i === 0"
                      [class.k-disabled]="i === 0"
                      >
                      <kendo-icon-wrapper
                        name="arrow-chevron-up"
                        [svgIcon]="upIcon"
                        [size]="iconSize"
                      ></kendo-icon-wrapper>
                    </span>
                    <span
                      class="k-group-menu-item-action k-group-menu-item-down-action"
                      (click)="moveGroupDown(column, $event)"
                      [attr.aria-disabled]="i === groupedColumns.length - 1"
                      [class.k-disabled]="i === groupedColumns.length - 1"
                      >
                      <kendo-icon-wrapper
                        name="arrow-chevron-down"
                        [svgIcon]="downIcon"
                        [size]="iconSize"
                      ></kendo-icon-wrapper>
                    </span>
                  </span>
                }
                <span class="k-group-item-text">{{column.title || getColumnComponent(column).field}}</span>
                <span class="k-spacer"></span>
                <span class="k-group-menu-item-actions">
                  <span class="k-group-menu-item-action k-group-menu-item-remove-action" (click)="removeGroup(column, $event)">
                    <kendo-icon-wrapper
                      name="x-circle"
                      [svgIcon]="removeIcon"
                      [size]="iconSize"
                    ></kendo-icon-wrapper>
                  </span>
                </span>
              </div>
            }
          </div>
        }
        
        @if (ungroupedColumns.length) {
          <div class="k-group-menu-item-wrap">
            @for (column of ungroupedColumns; track column; let i = $index) {
              <div
                #groupItem
                role="button"
                class="k-group-menu-item"
                tabindex="0"
                (keydown)="handleUngroupedKeydown(column, i, $event)"
                (focus)="onItemFocus(null, i)"
                >
                <span class="k-group-item-text">{{column.title || getColumnComponent(column).field}}</span>
                <span class="k-spacer"></span>
                <span class="k-group-menu-item-actions">
                  <span class="k-group-menu-item-action k-group-menu-item-add-action" (click)="addGroup(column, $event)">
                    <kendo-icon-wrapper
                      name="plus-circle"
                      [svgIcon]="addIcon"
                      [size]="iconSize"
                    ></kendo-icon-wrapper>
                  </span>
                </span>
              </div>
            }
          </div>
        }
        
        @if (!adaptive) {
          <div class="k-actions k-actions-stretched k-actions-horizontal k-column-menu-footer">
            <button kendoButton
              [svgIcon]="clearIcon"
              (click)="clear()"
              icon="x"
              >
              {{ctx?.localization.get('groupClearButton')}}
            </button>
          </div>
        }
        `,
                    standalone: true,
                    imports: [IconWrapperComponent, KENDO_BUTTON]
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { hostClass: [{
                type: HostBinding,
                args: ['class.k-group-menu']
            }], lgClass: [{
                type: HostBinding,
                args: ['class.k-group-menu-lg']
            }], mdClass: [{
                type: HostBinding,
                args: ['class.k-group-menu-md']
            }], onEscKeyDown: [{
                type: HostListener,
                args: ['keydown.escape', ['$event']]
            }], groupItems: [{
                type: ViewChildren,
                args: ['groupItem', { read: ElementRef }]
            }], adaptive: [{
                type: Input
            }], close: [{
                type: Output
            }], groupClear: [{
                type: Output
            }] } });

/**
 * @hidden
 */
class AdaptiveRendererComponent {
    service;
    adaptiveGridService;
    filterService;
    ctx;
    adaptiveService;
    sortService;
    columnInfoService;
    xIcon = xIcon;
    checkIcon = checkIcon;
    filterIcon = filterIcon;
    arrowRotateCcwIcon = arrowRotateCcwIcon;
    chevronLeft = chevronLeftIcon;
    filterClearIcon = filterClearIcon;
    cancelIcon = cancelIcon;
    saveIcon = saveIcon;
    columns;
    externalEditingSettings;
    get hasSort() {
        return hasSort(this.ctx.grid.columnMenu, this.adaptiveGridService.column);
    }
    get hasColumnChooser() {
        return hasColumnChooser(this.ctx.grid.columnMenu);
    }
    get hasFilter() {
        return hasFilter(this.ctx.grid.columnMenu, this.adaptiveGridService.column);
    }
    get hasAutoSizeColumn() {
        return hasAutoSizeColumn(this.ctx.grid.columnMenu);
    }
    get hasAutoSizeAllColumns() {
        return hasAutoSizeAllColumns(this.ctx.grid.columnMenu);
    }
    get hasLock() {
        return hasLock(this.ctx.grid.columnMenu, this.adaptiveGridService.column);
    }
    get hasStick() {
        return hasStick(this.ctx.grid.columnMenu, this.adaptiveGridService.column);
    }
    get hasPosition() {
        return hasPosition(this.ctx.grid.columnMenu, this.adaptiveGridService.column);
    }
    getColumnComponent(column) {
        return column;
    }
    get hasTitle() {
        const hasTitle = this.adaptiveGridService.viewType === 'columnMenu' ||
            this.adaptiveGridService.viewType === 'filterToolbarTool' ||
            this.adaptiveGridService.viewType === 'columnChooserToolbarTool' ||
            this.adaptiveGridService.viewType === 'filterMenu' ||
            this.adaptiveGridService.viewType === 'sortToolbarTool' ||
            this.adaptiveGridService.viewType === 'groupToolbarTool' ||
            this.adaptiveGridService.viewType === 'externalEditing';
        return hasTitle;
    }
    get hasSubtitle() {
        const hasSubtitle = (this.adaptiveGridService.viewType === 'columnMenu' && this.adaptiveGridService.secondaryView === 'columnChooser') ||
            this.adaptiveGridService.viewType === 'columnChooserToolbarTool';
        return hasSubtitle;
    }
    get actionSheetTitle() {
        if (this.adaptiveGridService.viewType === 'columnMenu') {
            if (this.adaptiveGridService.secondaryView === 'columnChooser') {
                return this.messageFor('columns');
            }
            if (this.adaptiveGridService.secondaryView === 'columnPosition') {
                return this.messageFor('setColumnPosition');
            }
            if (this.adaptiveGridService.secondaryView === 'columnFilter') {
                return this.adaptiveGridService.column.title || this.adaptiveGridService.column.field;
            }
            return this.columnMenuTitle;
        }
        if (this.adaptiveGridService.viewType === 'filterToolbarTool') {
            if (this.adaptiveGridService.secondaryView === 'columnFilter') {
                return this.adaptiveGridService.column.title || this.adaptiveGridService.column.field;
            }
            return this.messageFor('adaptiveFilterTitle');
        }
        if (this.adaptiveGridService.viewType === 'filterMenu') {
            return this.adaptiveGridService.column.title || this.adaptiveGridService.column.field;
        }
        if (this.adaptiveGridService.viewType === 'columnChooserToolbarTool') {
            return this.messageFor('columns');
        }
        if (this.adaptiveGridService.viewType === 'sortToolbarTool') {
            return this.messageFor('adaptiveSortTitle');
        }
        if (this.adaptiveGridService.viewType === 'groupToolbarTool') {
            return this.messageFor('adaptiveGroupTitle');
        }
        if (this.adaptiveGridService.viewType === 'externalEditing') {
            return this.messageFor(this.externalEditingSettings.event.isNew ? 'externalEditingAddTitle' : 'externalEditingTitle');
        }
    }
    get adaptiveFilterTitle() {
        const columnTitle = this.adaptiveGridService.column.title || this.adaptiveGridService.column.field;
        return `${this.messageFor('adaptiveFilterTitle')} ${columnTitle}`;
    }
    get columnMenuTitle() {
        const columnName = this.adaptiveGridService.column.title || this.adaptiveGridService.column.field;
        return columnName;
    }
    get filterLabel() {
        const localizationMsg = this.messageFor('filterMenuTitle') || '';
        const columnName = this.adaptiveGridService.column.title || this.adaptiveGridService.column.field;
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
    get hasXCloseIcon() {
        return this.adaptiveGridService.viewType !== 'sortToolbarTool' && this.adaptiveGridService.viewType !== 'groupToolbarTool';
    }
    get hasCheckCloseIcon() {
        return this.adaptiveGridService.viewType === 'sortToolbarTool' || this.adaptiveGridService.viewType === 'groupToolbarTool';
    }
    columnChooserContent;
    filterToolbarToolTemplate;
    filterMenuContainer;
    actionSheet;
    set groupToolbarTool(value) {
        value && (value.ctx = this.ctx);
    }
    adaptiveSizeChangeSubscription;
    constructor(service, adaptiveGridService, filterService, ctx, adaptiveService, sortService, columnInfoService) {
        this.service = service;
        this.adaptiveGridService = adaptiveGridService;
        this.filterService = filterService;
        this.ctx = ctx;
        this.adaptiveService = adaptiveService;
        this.sortService = sortService;
        this.columnInfoService = columnInfoService;
        this.adaptiveSizeChangeSubscription = this.adaptiveService.sizeChanges.subscribe(() => {
            if (this.ctx.grid.isOpen) {
                if (this.actionSheet.expanded) {
                    this.actionSheet.toggle(false);
                }
                else {
                    this.adaptiveGridService.popupRef.close();
                    this.adaptiveGridService.popupRef = null;
                }
            }
        });
    }
    ngOnInit() {
        this.columns = this.columnInfoService.leafNamedColumns.filter(column => column?.sortable);
    }
    ngOnDestroy() {
        if (this.adaptiveSizeChangeSubscription) {
            this.adaptiveSizeChangeSubscription.unsubscribe();
        }
    }
    messageFor = token => this.ctx.localization.get(token);
    close() {
        this.actionSheet.toggle(false);
        this.adaptiveGridService.reset();
    }
    prevView() {
        this.adaptiveGridService.secondaryView = null;
        this.adaptiveGridService.filterMenuContainerComponentRef?.destroy();
        this.actionSheet.prevView();
    }
    clearFilters() {
        const emptyFilter = { logic: 'and', filters: [] };
        this.filterService.filter(emptyFilter);
        this.actionSheet.toggle(false);
    }
    navigateToColumnsView() {
        this.adaptiveGridService.secondaryView = 'columnChooser';
        this.actionSheet.nextView();
    }
    navigateToFilterView() {
        this.adaptiveGridService.secondaryView = 'columnFilter';
        this.actionSheet.nextView();
    }
    navigateToPositionView() {
        this.adaptiveGridService.secondaryView = 'columnPosition';
        this.actionSheet.nextView();
    }
    applyChanges() {
        this.columnChooserContent.applyChanges();
        this.actionSheet.toggle(false);
    }
    sortBy(column) {
        this.toggleSort(this.getColumnComponent(column));
    }
    toggleSort(column) {
        const field = column?.field;
        if (!field) {
            return;
        }
        const descriptor = this.getDescriptor(column);
        this.sortService.sort(descriptor);
    }
    getDescriptor(column) {
        const { allowUnsort, mode, initialDirection } = normalize$1(this.ctx.grid.sortable, column.sortable);
        const field = column?.field;
        if (!field) {
            return;
        }
        const descriptorT = this.ctx.grid.sort.find(item => item.field === field) || { field };
        const [first, second] = directions(initialDirection);
        let dir = first;
        if (descriptorT.dir === first) {
            dir = second;
        }
        else if (descriptorT.dir === second && allowUnsort) {
            dir = undefined;
        }
        const descriptor = { field, dir };
        if (mode === 'single') {
            return [descriptor];
        }
        return [...this.ctx.grid.sort.filter(desc => desc.field !== field), descriptor];
    }
    clearSorting() {
        if (this.ctx.grid.sort.length > 0) {
            this.sortService.sort([]);
        }
        this.actionSheet.toggle(false);
    }
    clearGrouping() {
        if (this.ctx.grid.group.length > 0) {
            this.ctx.grid.group = [];
            this.ctx.grid.groupChange.emit(this.ctx.grid.group);
        }
        this.actionSheet.toggle(false);
    }
    onAnimationEnd() {
        this.adaptiveGridService.notifyAnimationEnd();
    }
    cancelChanges() {
        this.columnChooserContent.cancelChanges();
        this.columnChooserContent.cdr.detectChanges();
    }
    onTab(event) {
        this.columnChooserContent.onTab(event);
    }
    saveEditing() {
        const { event, formGroup, externalEditingDirective } = this.externalEditingSettings;
        externalEditingDirective.saveHandler({ ...event, formGroup });
        this.actionSheet.toggle(false);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AdaptiveRendererComponent, deps: [{ token: ColumnMenuService }, { token: AdaptiveGridService }, { token: FilterService }, { token: ContextService }, { token: i2$1.AdaptiveService }, { token: SortService }, { token: ColumnInfoService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: AdaptiveRendererComponent, isStandalone: true, selector: "kendo-grid-adaptive-renderer", viewQueries: [{ propertyName: "columnChooserContent", first: true, predicate: ["columnChooserContent"], descendants: true }, { propertyName: "filterToolbarToolTemplate", first: true, predicate: ["filterToolbarToolTemplate"], descendants: true, read: ViewContainerRef }, { propertyName: "filterMenuContainer", first: true, predicate: ["filterMenuContainer"], descendants: true }, { propertyName: "actionSheet", first: true, predicate: ActionSheetComponent, descendants: true }, { propertyName: "groupToolbarTool", first: true, predicate: GroupToolbarToolComponent, descendants: true }], ngImport: i0, template: `
        <kendo-actionsheet
            [cssClass]="{
                'k-adaptive-actionsheet': true,
                'k-actionsheet-fullscreen': adaptiveService.size === 'small',
                'k-actionsheet-bottom': adaptiveService.size === 'medium'
            }"
            [cssStyle]="{
                height: adaptiveService.size === 'small' ? '100vh' : '60vh'
            }"
          [overlayClickClose]="true"
          (collapse)="adaptiveGridService.reset()">
        
          <!-- sortToolbarTool view -->
          @if (adaptiveGridService.viewType === 'sortToolbarTool') {
            <kendo-actionsheet-view>
              <ng-template kendoActionSheetHeaderTemplate>
                <ng-container [ngTemplateOutlet]="actionSheetHeaderTemplate">
                </ng-container>
              </ng-template>
              <ng-template kendoActionSheetContentTemplate>
                <div class="k-column-menu k-column-menu-lg">
                  <div class="k-columnmenu-item-wrapper">
                    @for (column of columns; track column) {
                      <kendo-grid-columnmenu-item
                        [column]="getColumnComponent(column)"
                        [text]="column.title || getColumnComponent(column).field"
                        (itemClick)="sortBy(column)">
                      </kendo-grid-columnmenu-item>
                    }
                  </div>
                </div>
              </ng-template>
              <ng-template kendoActionSheetFooterTemplate>
                <button
                  kendoButton
                  size="large"
                  fillMode="solid"
                  icon="x"
                  [svgIcon]="xIcon"
                  (click)="clearSorting()">
                  {{messageFor('sortClearButton')}}
                </button>
                <button
                  kendoButton
                  size="large"
                  fillMode="solid"
                  icon="check"
                  [svgIcon]="checkIcon"
                  themeColor="primary"
                  (click)="actionSheet.toggle(false)">
                  {{messageFor('sortDoneButton')}}
                </button>
              </ng-template>
            </kendo-actionsheet-view>
          }
        
          <!-- columnChooserToolbarTool view -->
          @if (adaptiveGridService.viewType === 'columnChooserToolbarTool') {
            <kendo-actionsheet-view>
              <ng-template kendoActionSheetHeaderTemplate>
                <ng-container [ngTemplateOutlet]="actionSheetHeaderTemplate">
                </ng-container>
              </ng-template>
              <ng-template kendoActionSheetContentTemplate>
                <kendo-grid-column-chooser-content
                  #columnChooserContent
                  [columns]="columns"
                  [isLast]="true"
                  [autoSync]="false"
                  [allowHideAll]="false"
                  >
                </kendo-grid-column-chooser-content>
              </ng-template>
              <ng-template kendoActionSheetFooterTemplate>
                <ng-container [ngTemplateOutlet]="actionSheetFooterTemplate">
                </ng-container>
              </ng-template>
            </kendo-actionsheet-view>
          }
        
          <!-- filterToolbarTool first view -->
          @if (adaptiveGridService.viewType === 'filterToolbarTool') {
            <kendo-actionsheet-view
              [kendoEventsOutsideAngular]="{transitionend: onAnimationEnd}"
              [scope]="this">
              <ng-template kendoActionSheetHeaderTemplate>
                <ng-container [ngTemplateOutlet]="actionSheetHeaderTemplate">
                </ng-container>
              </ng-template>
              <ng-template kendoActionSheetContentTemplate>
                <div class="k-column-menu k-column-menu-lg">
                  <kendo-filter-toolbar-tool></kendo-filter-toolbar-tool>
                </div>
              </ng-template>
              <ng-template kendoActionSheetFooterTemplate>
                <button kendoButton
                  icon="filter-clear"
                  [svgIcon]="filterClearIcon"
                  size="large"
                  (click)="clearFilters()">
                  {{messageFor('filterClearAllButton')}}
                </button>
              </ng-template>
            </kendo-actionsheet-view>
          }
        
          <!-- filterToolbarTool second view -->
          @if (adaptiveGridService.viewType === 'filterToolbarTool') {
            <kendo-actionsheet-view>
              <ng-template kendoActionSheetHeaderTemplate>
                <ng-container [ngTemplateOutlet]="actionSheetHeaderTemplate">
                </ng-container>
              </ng-template>
              <ng-template kendoActionSheetContentTemplate>
                <ng-container #filterToolbarToolTemplate></ng-container>
              </ng-template>
              <ng-template kendoActionSheetFooterTemplate>
                <ng-container [ngTemplateOutlet]="filterFooterButtons">
                </ng-container>
              </ng-template>
            </kendo-actionsheet-view>
          }
        
          <!-- filterMenu view -->
          @if (adaptiveGridService.viewType === 'filterMenu') {
            <kendo-actionsheet-view>
              <ng-template kendoActionSheetHeaderTemplate >
                <ng-container [ngTemplateOutlet]="actionSheetHeaderTemplate">
                </ng-container>
              </ng-template>
              <ng-template kendoActionSheetContentTemplate>
                <kendo-grid-filter-menu-container
                  #filterMenuContainer
                  [column]="adaptiveGridService.column"
                  [filter]="ctx.grid.filter"
                  (close)="close()"
                  (keydown.enter)="$event.stopImmediatePropagation()">
                </kendo-grid-filter-menu-container>
              </ng-template>
              <ng-template kendoActionSheetFooterTemplate>
                <ng-container [ngTemplateOutlet]="filterFooterButtons">
                </ng-container>
              </ng-template>
            </kendo-actionsheet-view>
          }
        
          <!-- columnMenu first view -->
          @if (adaptiveGridService.viewType === 'columnMenu') {
            <kendo-actionsheet-view
              [kendoEventsOutsideAngular]="{transitionend: onAnimationEnd}"
              [scope]="this">
              <ng-template kendoActionSheetHeaderTemplate>
                <ng-container [ngTemplateOutlet]="actionSheetHeaderTemplate">
                </ng-container>
              </ng-template>
              <ng-template kendoActionSheetContentTemplate>
                <div class="k-column-menu k-column-menu-lg">
                  <kendo-grid-columnmenu-container>
                    @if (hasSort) {
                      <kendo-grid-columnmenu-sort #sortItem [kendoGridColumnMenuItem]="sortItem" [service]="adaptiveGridService.columnMenuService">
                      </kendo-grid-columnmenu-sort>
                    }
                    @if (hasLock && !hasPosition) {
                      <kendo-grid-columnmenu-lock #lockItem [kendoGridColumnMenuItem]="lockItem" [service]="adaptiveGridService.columnMenuService">
                      </kendo-grid-columnmenu-lock>
                    }
                    @if (hasStick && !hasPosition) {
                      <kendo-grid-columnmenu-stick #stickItem [kendoGridColumnMenuItem]="stickItem" [service]="adaptiveGridService.columnMenuService">
                      </kendo-grid-columnmenu-stick>
                    }
                    @if (hasPosition) {
                      <kendo-grid-columnmenu-position
                        #positionItem
                        [showLock]="hasLock"
                        [showStick]="hasStick"
                        [kendoGridColumnMenuItem]="positionItem"
                        [service]="adaptiveGridService.columnMenuService"
                        [expanded]="false"
                        (collapse)="navigateToPositionView()">
                      </kendo-grid-columnmenu-position>
                    }
                    @if (hasLock || hasStick || adaptiveGridService.column.sortable) {
                      <span [style.borderColor]="'rgba(0, 0, 0, 0.08)'" class="k-separator"></span>
                    }
                    @if (hasColumnChooser) {
                      <kendo-grid-columnmenu-chooser
                        #chooserItem
                        [kendoGridColumnMenuItem]="chooserItem"
                        [service]="adaptiveGridService.columnMenuService"
                        [expanded]="false"
                        (collapse)="navigateToColumnsView()">
                      </kendo-grid-columnmenu-chooser>
                    }
                    @if (hasAutoSizeColumn) {
                      <kendo-grid-columnmenu-autosize-column
                        #autoSizeColumnItem
                        [service]="adaptiveGridService.columnMenuService"
                        [kendoGridColumnMenuItem]="autoSizeColumnItem"
                        [column]="adaptiveGridService.column"
                        >
                      </kendo-grid-columnmenu-autosize-column>
                    }
                    @if (hasAutoSizeAllColumns) {
                      <kendo-grid-columnmenu-autosize-all-columns
                        #autoSizeAllColumnsItem
                        [service]="adaptiveGridService.columnMenuService"
                        [kendoGridColumnMenuItem]="autoSizeAllColumnsItem"
                        >
                      </kendo-grid-columnmenu-autosize-all-columns>
                    }
                    @if (adaptiveGridService.column.filterable) {
                      <span [style.borderColor]="'rgba(0, 0, 0, 0.08)'" class="k-separator"></span>
                    }
                    @if (hasFilter) {
                      <kendo-grid-columnmenu-filter
                        #filterItem
                        [kendoGridColumnMenuItem]="filterItem"
                        [service]="adaptiveGridService.columnMenuService"
                        [expanded]="false"
                        (collapse)="navigateToFilterView()">
                      </kendo-grid-columnmenu-filter>
                    }
                  </kendo-grid-columnmenu-container>
                </div>
              </ng-template>
            </kendo-actionsheet-view>
          }
        
          <!-- columnMenu second view -->
          @if (adaptiveGridService.viewType === 'columnMenu') {
            <kendo-actionsheet-view>
              <ng-template kendoActionSheetHeaderTemplate>
                <ng-container [ngTemplateOutlet]="actionSheetHeaderTemplate">
                </ng-container>
              </ng-template>
              <ng-template kendoActionSheetContentTemplate>
                @if (adaptiveGridService.secondaryView === 'columnChooser') {
                  <kendo-grid-column-chooser-content
                    #columnChooserContent
                    [columns]="adaptiveGridService.columns"
                    [isLast]="true"
                    [autoSync]="false"
                    [allowHideAll]="false"
                    >
                  </kendo-grid-column-chooser-content>
                }
                @if (adaptiveGridService.secondaryView === 'columnFilter') {
                  <kendo-grid-filter-menu-container
                    [column]="adaptiveGridService.column"
                    [filter]="ctx.grid.filter"
                    (close)="close()"
                    [kendoEventsOutsideAngular]="{'keydown.escape': close}"
                    [scope]="this">
                  </kendo-grid-filter-menu-container>
                }
                @if (adaptiveGridService.secondaryView === 'columnPosition' && hasLock) {
                  <kendo-grid-columnmenu-lock
                    [service]="adaptiveGridService.columnMenuService">
                  </kendo-grid-columnmenu-lock>
                }
                @if (adaptiveGridService.secondaryView === 'columnPosition' && hasStick) {
                  <kendo-grid-columnmenu-stick
                    [service]="adaptiveGridService.columnMenuService">
                  </kendo-grid-columnmenu-stick>
                }
              </ng-template>
              @if (adaptiveGridService.secondaryView === 'columnChooser') {
                <ng-template kendoActionSheetFooterTemplate>
                  <ng-container [ngTemplateOutlet]="actionSheetFooterTemplate">
                  </ng-container>
                </ng-template>
              }
              @if (adaptiveGridService.secondaryView === 'columnFilter') {
                <ng-template kendoActionSheetFooterTemplate>
                  <ng-container [ngTemplateOutlet]="filterFooterButtons">
                  </ng-container>
                </ng-template>
              }
            </kendo-actionsheet-view>
          }
        
          <!-- external editing view -->
          @if (adaptiveGridService.viewType === 'externalEditing') {
            <kendo-actionsheet-view>
              <ng-template kendoActionSheetHeaderTemplate>
                <ng-container [ngTemplateOutlet]="actionSheetHeaderTemplate">
                </ng-container>
              </ng-template>
              <ng-template kendoActionSheetContentTemplate>
                <kendo-grid-external-form
                  [controls]="externalEditingSettings.formControls"
                  [formGroup]="externalEditingSettings.formGroup"
                  [formSettings]="externalEditingSettings.formSettings"
                  [actionButtons]="false">
                </kendo-grid-external-form>
              </ng-template>
              <ng-template kendoActionSheetFooterTemplate>
                <button kendoButton
                  size="large"
                  icon="cancel"
                  [svgIcon]="cancelIcon"
                  (click)="actionSheet.toggle(false)">
                  {{messageFor('externalEditingCancelText')}}
                </button>
                <button kendoButton
                  themeColor="primary"
                  size="large"
                  icon="save"
                  [svgIcon]="saveIcon"
                  (click)="saveEditing()"
                  [disabled]="!externalEditingSettings.formGroup.valid">
                  {{messageFor('externalEditingSaveText')}}
                </button>
              </ng-template>
            </kendo-actionsheet-view>
          }
        
          <!-- groupToolbarTool view -->
          @if (adaptiveGridService.viewType === 'groupToolbarTool') {
            <kendo-actionsheet-view>
              <ng-template kendoActionSheetHeaderTemplate>
                <ng-container [ngTemplateOutlet]="actionSheetHeaderTemplate">
                </ng-container>
              </ng-template>
              <ng-template kendoActionSheetContentTemplate>
                <kendo-group-toolbar-tool [adaptive]="true"></kendo-group-toolbar-tool>
              </ng-template>
              <ng-template kendoActionSheetFooterTemplate>
                <button
                  kendoButton
                  size="large"
                  fillMode="solid"
                  icon="x"
                  [svgIcon]="xIcon"
                  (click)="clearGrouping()">
                  {{messageFor('groupClearButton')}}
                </button>
                <button
                  kendoButton
                  size="large"
                  fillMode="solid"
                  icon="check"
                  [svgIcon]="checkIcon"
                  themeColor="primary"
                  (click)="actionSheet.toggle(false)">
                  {{messageFor('groupDoneButton')}}
                </button>
              </ng-template>
            </kendo-actionsheet-view>
          }
        </kendo-actionsheet>
        
        <ng-template #actionSheetHeaderTemplate>
          <div class="k-actionsheet-titlebar-group">
            @if (adaptiveGridService.secondaryView) {
              <div class="k-actionsheet-actions">
                <button
                  kendoButton
                  icon="chevron-left"
                  [svgIcon]="chevronLeft"
                  fillMode="flat"
                  size="large"
                  [title]="messageFor('adaptiveBackButtonTitle')"
                  (click)="prevView()">
                </button>
              </div>
            }
            <div class="k-actionsheet-title">
              @if (hasTitle) {
                <div class="k-text-center">
                  {{actionSheetTitle}}
                </div>
              }
              @if (hasSubtitle) {
                <div
                  class="k-actionsheet-subtitle k-text-center">
                  {{messageFor('columnsSubtitle')}}
                </div>
              }
            </div>
            @if (hasXCloseIcon) {
              <div class="k-actionsheet-actions">
                <button
                  kendoButton
                  icon="x"
                  [svgIcon]="xIcon"
                  fillMode="flat"
                  size="large"
                  [title]="messageFor('adaptiveCloseButtonTitle')"
                  (click)="close()">
                </button>
              </div>
            }
            @if (hasCheckCloseIcon) {
              <div class="k-actionsheet-actions">
                <button
                  kendoButton
                  icon="check"
                  [svgIcon]="checkIcon"
                  fillMode="flat"
                  size="large"
                  themeColor="primary"
                  [title]="messageFor('adaptiveCloseButtonTitle')"
                  (click)="actionSheet.toggle(false)">
                </button>
              </div>
            }
          </div>
        </ng-template>
        
        <ng-template #actionSheetFooterTemplate>
          <button
            #resetButton
            kendoButton
            size="large"
            fillMode="solid"
            [svgIcon]="arrowRotateCcwIcon"
            icon="arrow-rotate-ccw"
            type="button"
                [kendoEventsOutsideAngular]="{click: cancelChanges, 
                                            'keydown.enter': cancelChanges,
                                            'keydown.space': cancelChanges,
                                            'keydown.tab': onTab
                                            }"
            [scope]="this">
            {{ messageFor('columnsReset') }}
          </button>
          <button
            #applyButton
            kendoButton
            type="button"
            [svgIcon]="checkIcon"
            icon="check"
            size="large"
            fillMode="solid"
            themeColor="primary"
                [kendoEventsOutsideAngular]="{click: applyChanges,
                                            'keydown.enter': applyChanges,
                                            'keydown.space': applyChanges
                                            }"
            [scope]="this">
            {{ messageFor('columnsApply') }}
          </button>
        </ng-template>
        
        <ng-template #filterFooterButtons>
          <button
            kendoButton
            size="large"
            fillMode="solid"
            (click)="adaptiveGridService.resetFilter()">
            {{messageFor('filterClearButton')}}
          </button>
          <button
            kendoButton
            size="large"
            fillMode="solid"
            themeColor="primary"
            [disabled]="adaptiveGridService.filterMenuContainer.disabled"
            (click)="adaptiveGridService.submitFilter()">
            {{messageFor('filterFilterButton')}}
          </button>
        </ng-template>
        `, isInline: true, dependencies: [{ kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: ActionSheetComponent, selector: "kendo-actionsheet", inputs: ["actions", "actionsLayout", "overlayClickClose", "title", "subtitle", "items", "cssClass", "cssStyle", "animation", "expanded", "titleId", "initialFocus"], outputs: ["expandedChange", "action", "expand", "collapse", "itemClick", "overlayClick"], exportAs: ["kendoActionSheet"] }, { kind: "component", type: ActionSheetViewComponent, selector: "kendo-actionsheet-view", inputs: ["title", "subtitle", "titleId"] }, { kind: "component", type: FilterToolbarToolComponent, selector: "kendo-filter-toolbar-tool", outputs: ["close"] }, { kind: "component", type: GroupToolbarToolComponent, selector: "kendo-group-toolbar-tool", inputs: ["adaptive"], outputs: ["close", "groupClear"] }, { kind: "component", type: ButtonDirective, selector: "button[kendoButton]", inputs: ["arrowIcon", "toggleable", "togglable", "selected", "tabIndex", "imageUrl", "iconClass", "icon", "disabled", "size", "rounded", "fillMode", "themeColor", "svgIcon", "primary", "look"], outputs: ["selectedChange", "click"], exportAs: ["kendoButton"] }, { kind: "directive", type: ActionSheetHeaderTemplateDirective, selector: "[kendoActionSheetHeaderTemplate]" }, { kind: "directive", type: ActionSheetContentTemplateDirective, selector: "[kendoActionSheetContentTemplate]" }, { kind: "directive", type: ActionSheetFooterTemplateDirective, selector: "[kendoActionSheetFooterTemplate]" }, { kind: "component", type: ColumnMenuContainerComponent, selector: "kendo-grid-columnmenu-container" }, { kind: "component", type: ColumnMenuFilterComponent, selector: "kendo-grid-columnmenu-filter", inputs: ["expanded", "isLast"], outputs: ["expand", "collapse"] }, { kind: "component", type: ColumnMenuSortComponent, selector: "kendo-grid-columnmenu-sort" }, { kind: "component", type: ColumnMenuLockComponent, selector: "kendo-grid-columnmenu-lock" }, { kind: "component", type: ColumnMenuStickComponent, selector: "kendo-grid-columnmenu-stick" }, { kind: "component", type: ColumnMenuPositionComponent, selector: "kendo-grid-columnmenu-position", inputs: ["expanded", "showLock", "showStick", "isLast"], outputs: ["expand", "collapse"] }, { kind: "component", type: ColumnMenuChooserComponent, selector: "kendo-grid-columnmenu-chooser", inputs: ["expanded", "isLast"], outputs: ["expand", "collapse"] }, { kind: "component", type: ColumnMenuAutoSizeColumnComponent, selector: "kendo-grid-columnmenu-autosize-column", inputs: ["column"] }, { kind: "component", type: ColumnMenuAutoSizeAllColumnsComponent, selector: "kendo-grid-columnmenu-autosize-all-columns" }, { kind: "component", type: ColumnMenuItemComponent, selector: "kendo-grid-columnmenu-item", inputs: ["icon", "svgIcon", "indicatorIcon", "text", "selected", "disabled", "expanded", "focused", "service", "column"], outputs: ["itemClick", "expand", "collapse"] }, { kind: "directive", type: ColumnMenuItemDirective, selector: "[kendoGridColumnMenuItem]", inputs: ["kendoGridColumnMenuItem"] }, { kind: "component", type: FilterMenuContainerComponent, selector: "kendo-grid-filter-menu-container", inputs: ["column", "isLast", "isExpanded", "menuTabbingService", "filter", "actionsClass"], outputs: ["close"] }, { kind: "directive", type: EventsOutsideAngularDirective, selector: "[kendoEventsOutsideAngular]", inputs: ["kendoEventsOutsideAngular", "scope"] }, { kind: "component", type: FormComponent, selector: "kendo-grid-external-form", inputs: ["controls", "formSettings", "formGroup", "actionButtons"], outputs: ["formSubmit"] }, { kind: "component", type: ColumnChooserContentComponent, selector: "kendo-grid-column-chooser-content", inputs: ["filterable", "showSelectAll", "showCheckedCount", "allowHideAll", "autoSync", "actionsClass", "closeOnReset", "columns", "isLast", "isExpanded", "service"], outputs: ["close"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AdaptiveRendererComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-adaptive-renderer',
                    template: `
        <kendo-actionsheet
            [cssClass]="{
                'k-adaptive-actionsheet': true,
                'k-actionsheet-fullscreen': adaptiveService.size === 'small',
                'k-actionsheet-bottom': adaptiveService.size === 'medium'
            }"
            [cssStyle]="{
                height: adaptiveService.size === 'small' ? '100vh' : '60vh'
            }"
          [overlayClickClose]="true"
          (collapse)="adaptiveGridService.reset()">
        
          <!-- sortToolbarTool view -->
          @if (adaptiveGridService.viewType === 'sortToolbarTool') {
            <kendo-actionsheet-view>
              <ng-template kendoActionSheetHeaderTemplate>
                <ng-container [ngTemplateOutlet]="actionSheetHeaderTemplate">
                </ng-container>
              </ng-template>
              <ng-template kendoActionSheetContentTemplate>
                <div class="k-column-menu k-column-menu-lg">
                  <div class="k-columnmenu-item-wrapper">
                    @for (column of columns; track column) {
                      <kendo-grid-columnmenu-item
                        [column]="getColumnComponent(column)"
                        [text]="column.title || getColumnComponent(column).field"
                        (itemClick)="sortBy(column)">
                      </kendo-grid-columnmenu-item>
                    }
                  </div>
                </div>
              </ng-template>
              <ng-template kendoActionSheetFooterTemplate>
                <button
                  kendoButton
                  size="large"
                  fillMode="solid"
                  icon="x"
                  [svgIcon]="xIcon"
                  (click)="clearSorting()">
                  {{messageFor('sortClearButton')}}
                </button>
                <button
                  kendoButton
                  size="large"
                  fillMode="solid"
                  icon="check"
                  [svgIcon]="checkIcon"
                  themeColor="primary"
                  (click)="actionSheet.toggle(false)">
                  {{messageFor('sortDoneButton')}}
                </button>
              </ng-template>
            </kendo-actionsheet-view>
          }
        
          <!-- columnChooserToolbarTool view -->
          @if (adaptiveGridService.viewType === 'columnChooserToolbarTool') {
            <kendo-actionsheet-view>
              <ng-template kendoActionSheetHeaderTemplate>
                <ng-container [ngTemplateOutlet]="actionSheetHeaderTemplate">
                </ng-container>
              </ng-template>
              <ng-template kendoActionSheetContentTemplate>
                <kendo-grid-column-chooser-content
                  #columnChooserContent
                  [columns]="columns"
                  [isLast]="true"
                  [autoSync]="false"
                  [allowHideAll]="false"
                  >
                </kendo-grid-column-chooser-content>
              </ng-template>
              <ng-template kendoActionSheetFooterTemplate>
                <ng-container [ngTemplateOutlet]="actionSheetFooterTemplate">
                </ng-container>
              </ng-template>
            </kendo-actionsheet-view>
          }
        
          <!-- filterToolbarTool first view -->
          @if (adaptiveGridService.viewType === 'filterToolbarTool') {
            <kendo-actionsheet-view
              [kendoEventsOutsideAngular]="{transitionend: onAnimationEnd}"
              [scope]="this">
              <ng-template kendoActionSheetHeaderTemplate>
                <ng-container [ngTemplateOutlet]="actionSheetHeaderTemplate">
                </ng-container>
              </ng-template>
              <ng-template kendoActionSheetContentTemplate>
                <div class="k-column-menu k-column-menu-lg">
                  <kendo-filter-toolbar-tool></kendo-filter-toolbar-tool>
                </div>
              </ng-template>
              <ng-template kendoActionSheetFooterTemplate>
                <button kendoButton
                  icon="filter-clear"
                  [svgIcon]="filterClearIcon"
                  size="large"
                  (click)="clearFilters()">
                  {{messageFor('filterClearAllButton')}}
                </button>
              </ng-template>
            </kendo-actionsheet-view>
          }
        
          <!-- filterToolbarTool second view -->
          @if (adaptiveGridService.viewType === 'filterToolbarTool') {
            <kendo-actionsheet-view>
              <ng-template kendoActionSheetHeaderTemplate>
                <ng-container [ngTemplateOutlet]="actionSheetHeaderTemplate">
                </ng-container>
              </ng-template>
              <ng-template kendoActionSheetContentTemplate>
                <ng-container #filterToolbarToolTemplate></ng-container>
              </ng-template>
              <ng-template kendoActionSheetFooterTemplate>
                <ng-container [ngTemplateOutlet]="filterFooterButtons">
                </ng-container>
              </ng-template>
            </kendo-actionsheet-view>
          }
        
          <!-- filterMenu view -->
          @if (adaptiveGridService.viewType === 'filterMenu') {
            <kendo-actionsheet-view>
              <ng-template kendoActionSheetHeaderTemplate >
                <ng-container [ngTemplateOutlet]="actionSheetHeaderTemplate">
                </ng-container>
              </ng-template>
              <ng-template kendoActionSheetContentTemplate>
                <kendo-grid-filter-menu-container
                  #filterMenuContainer
                  [column]="adaptiveGridService.column"
                  [filter]="ctx.grid.filter"
                  (close)="close()"
                  (keydown.enter)="$event.stopImmediatePropagation()">
                </kendo-grid-filter-menu-container>
              </ng-template>
              <ng-template kendoActionSheetFooterTemplate>
                <ng-container [ngTemplateOutlet]="filterFooterButtons">
                </ng-container>
              </ng-template>
            </kendo-actionsheet-view>
          }
        
          <!-- columnMenu first view -->
          @if (adaptiveGridService.viewType === 'columnMenu') {
            <kendo-actionsheet-view
              [kendoEventsOutsideAngular]="{transitionend: onAnimationEnd}"
              [scope]="this">
              <ng-template kendoActionSheetHeaderTemplate>
                <ng-container [ngTemplateOutlet]="actionSheetHeaderTemplate">
                </ng-container>
              </ng-template>
              <ng-template kendoActionSheetContentTemplate>
                <div class="k-column-menu k-column-menu-lg">
                  <kendo-grid-columnmenu-container>
                    @if (hasSort) {
                      <kendo-grid-columnmenu-sort #sortItem [kendoGridColumnMenuItem]="sortItem" [service]="adaptiveGridService.columnMenuService">
                      </kendo-grid-columnmenu-sort>
                    }
                    @if (hasLock && !hasPosition) {
                      <kendo-grid-columnmenu-lock #lockItem [kendoGridColumnMenuItem]="lockItem" [service]="adaptiveGridService.columnMenuService">
                      </kendo-grid-columnmenu-lock>
                    }
                    @if (hasStick && !hasPosition) {
                      <kendo-grid-columnmenu-stick #stickItem [kendoGridColumnMenuItem]="stickItem" [service]="adaptiveGridService.columnMenuService">
                      </kendo-grid-columnmenu-stick>
                    }
                    @if (hasPosition) {
                      <kendo-grid-columnmenu-position
                        #positionItem
                        [showLock]="hasLock"
                        [showStick]="hasStick"
                        [kendoGridColumnMenuItem]="positionItem"
                        [service]="adaptiveGridService.columnMenuService"
                        [expanded]="false"
                        (collapse)="navigateToPositionView()">
                      </kendo-grid-columnmenu-position>
                    }
                    @if (hasLock || hasStick || adaptiveGridService.column.sortable) {
                      <span [style.borderColor]="'rgba(0, 0, 0, 0.08)'" class="k-separator"></span>
                    }
                    @if (hasColumnChooser) {
                      <kendo-grid-columnmenu-chooser
                        #chooserItem
                        [kendoGridColumnMenuItem]="chooserItem"
                        [service]="adaptiveGridService.columnMenuService"
                        [expanded]="false"
                        (collapse)="navigateToColumnsView()">
                      </kendo-grid-columnmenu-chooser>
                    }
                    @if (hasAutoSizeColumn) {
                      <kendo-grid-columnmenu-autosize-column
                        #autoSizeColumnItem
                        [service]="adaptiveGridService.columnMenuService"
                        [kendoGridColumnMenuItem]="autoSizeColumnItem"
                        [column]="adaptiveGridService.column"
                        >
                      </kendo-grid-columnmenu-autosize-column>
                    }
                    @if (hasAutoSizeAllColumns) {
                      <kendo-grid-columnmenu-autosize-all-columns
                        #autoSizeAllColumnsItem
                        [service]="adaptiveGridService.columnMenuService"
                        [kendoGridColumnMenuItem]="autoSizeAllColumnsItem"
                        >
                      </kendo-grid-columnmenu-autosize-all-columns>
                    }
                    @if (adaptiveGridService.column.filterable) {
                      <span [style.borderColor]="'rgba(0, 0, 0, 0.08)'" class="k-separator"></span>
                    }
                    @if (hasFilter) {
                      <kendo-grid-columnmenu-filter
                        #filterItem
                        [kendoGridColumnMenuItem]="filterItem"
                        [service]="adaptiveGridService.columnMenuService"
                        [expanded]="false"
                        (collapse)="navigateToFilterView()">
                      </kendo-grid-columnmenu-filter>
                    }
                  </kendo-grid-columnmenu-container>
                </div>
              </ng-template>
            </kendo-actionsheet-view>
          }
        
          <!-- columnMenu second view -->
          @if (adaptiveGridService.viewType === 'columnMenu') {
            <kendo-actionsheet-view>
              <ng-template kendoActionSheetHeaderTemplate>
                <ng-container [ngTemplateOutlet]="actionSheetHeaderTemplate">
                </ng-container>
              </ng-template>
              <ng-template kendoActionSheetContentTemplate>
                @if (adaptiveGridService.secondaryView === 'columnChooser') {
                  <kendo-grid-column-chooser-content
                    #columnChooserContent
                    [columns]="adaptiveGridService.columns"
                    [isLast]="true"
                    [autoSync]="false"
                    [allowHideAll]="false"
                    >
                  </kendo-grid-column-chooser-content>
                }
                @if (adaptiveGridService.secondaryView === 'columnFilter') {
                  <kendo-grid-filter-menu-container
                    [column]="adaptiveGridService.column"
                    [filter]="ctx.grid.filter"
                    (close)="close()"
                    [kendoEventsOutsideAngular]="{'keydown.escape': close}"
                    [scope]="this">
                  </kendo-grid-filter-menu-container>
                }
                @if (adaptiveGridService.secondaryView === 'columnPosition' && hasLock) {
                  <kendo-grid-columnmenu-lock
                    [service]="adaptiveGridService.columnMenuService">
                  </kendo-grid-columnmenu-lock>
                }
                @if (adaptiveGridService.secondaryView === 'columnPosition' && hasStick) {
                  <kendo-grid-columnmenu-stick
                    [service]="adaptiveGridService.columnMenuService">
                  </kendo-grid-columnmenu-stick>
                }
              </ng-template>
              @if (adaptiveGridService.secondaryView === 'columnChooser') {
                <ng-template kendoActionSheetFooterTemplate>
                  <ng-container [ngTemplateOutlet]="actionSheetFooterTemplate">
                  </ng-container>
                </ng-template>
              }
              @if (adaptiveGridService.secondaryView === 'columnFilter') {
                <ng-template kendoActionSheetFooterTemplate>
                  <ng-container [ngTemplateOutlet]="filterFooterButtons">
                  </ng-container>
                </ng-template>
              }
            </kendo-actionsheet-view>
          }
        
          <!-- external editing view -->
          @if (adaptiveGridService.viewType === 'externalEditing') {
            <kendo-actionsheet-view>
              <ng-template kendoActionSheetHeaderTemplate>
                <ng-container [ngTemplateOutlet]="actionSheetHeaderTemplate">
                </ng-container>
              </ng-template>
              <ng-template kendoActionSheetContentTemplate>
                <kendo-grid-external-form
                  [controls]="externalEditingSettings.formControls"
                  [formGroup]="externalEditingSettings.formGroup"
                  [formSettings]="externalEditingSettings.formSettings"
                  [actionButtons]="false">
                </kendo-grid-external-form>
              </ng-template>
              <ng-template kendoActionSheetFooterTemplate>
                <button kendoButton
                  size="large"
                  icon="cancel"
                  [svgIcon]="cancelIcon"
                  (click)="actionSheet.toggle(false)">
                  {{messageFor('externalEditingCancelText')}}
                </button>
                <button kendoButton
                  themeColor="primary"
                  size="large"
                  icon="save"
                  [svgIcon]="saveIcon"
                  (click)="saveEditing()"
                  [disabled]="!externalEditingSettings.formGroup.valid">
                  {{messageFor('externalEditingSaveText')}}
                </button>
              </ng-template>
            </kendo-actionsheet-view>
          }
        
          <!-- groupToolbarTool view -->
          @if (adaptiveGridService.viewType === 'groupToolbarTool') {
            <kendo-actionsheet-view>
              <ng-template kendoActionSheetHeaderTemplate>
                <ng-container [ngTemplateOutlet]="actionSheetHeaderTemplate">
                </ng-container>
              </ng-template>
              <ng-template kendoActionSheetContentTemplate>
                <kendo-group-toolbar-tool [adaptive]="true"></kendo-group-toolbar-tool>
              </ng-template>
              <ng-template kendoActionSheetFooterTemplate>
                <button
                  kendoButton
                  size="large"
                  fillMode="solid"
                  icon="x"
                  [svgIcon]="xIcon"
                  (click)="clearGrouping()">
                  {{messageFor('groupClearButton')}}
                </button>
                <button
                  kendoButton
                  size="large"
                  fillMode="solid"
                  icon="check"
                  [svgIcon]="checkIcon"
                  themeColor="primary"
                  (click)="actionSheet.toggle(false)">
                  {{messageFor('groupDoneButton')}}
                </button>
              </ng-template>
            </kendo-actionsheet-view>
          }
        </kendo-actionsheet>
        
        <ng-template #actionSheetHeaderTemplate>
          <div class="k-actionsheet-titlebar-group">
            @if (adaptiveGridService.secondaryView) {
              <div class="k-actionsheet-actions">
                <button
                  kendoButton
                  icon="chevron-left"
                  [svgIcon]="chevronLeft"
                  fillMode="flat"
                  size="large"
                  [title]="messageFor('adaptiveBackButtonTitle')"
                  (click)="prevView()">
                </button>
              </div>
            }
            <div class="k-actionsheet-title">
              @if (hasTitle) {
                <div class="k-text-center">
                  {{actionSheetTitle}}
                </div>
              }
              @if (hasSubtitle) {
                <div
                  class="k-actionsheet-subtitle k-text-center">
                  {{messageFor('columnsSubtitle')}}
                </div>
              }
            </div>
            @if (hasXCloseIcon) {
              <div class="k-actionsheet-actions">
                <button
                  kendoButton
                  icon="x"
                  [svgIcon]="xIcon"
                  fillMode="flat"
                  size="large"
                  [title]="messageFor('adaptiveCloseButtonTitle')"
                  (click)="close()">
                </button>
              </div>
            }
            @if (hasCheckCloseIcon) {
              <div class="k-actionsheet-actions">
                <button
                  kendoButton
                  icon="check"
                  [svgIcon]="checkIcon"
                  fillMode="flat"
                  size="large"
                  themeColor="primary"
                  [title]="messageFor('adaptiveCloseButtonTitle')"
                  (click)="actionSheet.toggle(false)">
                </button>
              </div>
            }
          </div>
        </ng-template>
        
        <ng-template #actionSheetFooterTemplate>
          <button
            #resetButton
            kendoButton
            size="large"
            fillMode="solid"
            [svgIcon]="arrowRotateCcwIcon"
            icon="arrow-rotate-ccw"
            type="button"
                [kendoEventsOutsideAngular]="{click: cancelChanges, 
                                            'keydown.enter': cancelChanges,
                                            'keydown.space': cancelChanges,
                                            'keydown.tab': onTab
                                            }"
            [scope]="this">
            {{ messageFor('columnsReset') }}
          </button>
          <button
            #applyButton
            kendoButton
            type="button"
            [svgIcon]="checkIcon"
            icon="check"
            size="large"
            fillMode="solid"
            themeColor="primary"
                [kendoEventsOutsideAngular]="{click: applyChanges,
                                            'keydown.enter': applyChanges,
                                            'keydown.space': applyChanges
                                            }"
            [scope]="this">
            {{ messageFor('columnsApply') }}
          </button>
        </ng-template>
        
        <ng-template #filterFooterButtons>
          <button
            kendoButton
            size="large"
            fillMode="solid"
            (click)="adaptiveGridService.resetFilter()">
            {{messageFor('filterClearButton')}}
          </button>
          <button
            kendoButton
            size="large"
            fillMode="solid"
            themeColor="primary"
            [disabled]="adaptiveGridService.filterMenuContainer.disabled"
            (click)="adaptiveGridService.submitFilter()">
            {{messageFor('filterFilterButton')}}
          </button>
        </ng-template>
        `,
                    standalone: true,
                    imports: [
                        NgTemplateOutlet,
                        ActionSheetComponent,
                        ActionSheetViewComponent,
                        FilterToolbarToolComponent,
                        GroupToolbarToolComponent,
                        ButtonDirective,
                        ActionSheetHeaderTemplateDirective,
                        ActionSheetContentTemplateDirective,
                        ActionSheetFooterTemplateDirective,
                        ButtonDirective,
                        ColumnMenuContainerComponent,
                        ColumnMenuFilterComponent,
                        ColumnMenuSortComponent,
                        ColumnMenuLockComponent,
                        ColumnMenuStickComponent,
                        ColumnMenuPositionComponent,
                        ColumnMenuChooserComponent,
                        ColumnMenuAutoSizeColumnComponent,
                        ColumnMenuAutoSizeAllColumnsComponent,
                        ColumnMenuItemComponent,
                        ColumnMenuItemDirective,
                        FilterMenuContainerComponent,
                        ColumnMenuLockComponent,
                        EventsOutsideAngularDirective,
                        FormComponent,
                        ColumnChooserContentComponent
                    ]
                }]
        }], ctorParameters: () => [{ type: ColumnMenuService }, { type: AdaptiveGridService }, { type: FilterService }, { type: ContextService }, { type: i2$1.AdaptiveService }, { type: SortService }, { type: ColumnInfoService }], propDecorators: { columnChooserContent: [{
                type: ViewChild,
                args: ['columnChooserContent', { static: false }]
            }], filterToolbarToolTemplate: [{
                type: ViewChild,
                args: ['filterToolbarToolTemplate', { read: ViewContainerRef, static: false }]
            }], filterMenuContainer: [{
                type: ViewChild,
                args: ['filterMenuContainer']
            }], actionSheet: [{
                type: ViewChild,
                args: [ActionSheetComponent]
            }], groupToolbarTool: [{
                type: ViewChild,
                args: [GroupToolbarToolComponent]
            }] } });

const createControl = (source) => (acc, key) => {
    acc[key] = new FormControl(source[key]);
    return acc;
};
const validateColumnsField = (columns) => expandColumns(columns.toArray())
    .filter(isColumnComponent)
    .filter(({ field }) => !isValidFieldName(field))
    .forEach(({ field }) => console.warn(ColumnConfigurationErrorMessages.fieldName(field)));
const handleExpandCollapseGroupsService = (service, expandEmitter, collapseEmitter, map) => (service.changes.pipe(filter(({ group, emit }) => emit && isPresent(group)))
    .subscribe((x) => x.expand ? expandEmitter.emit(map(x)) : collapseEmitter.emit(map(x))));
const handleExpandCollapseDetailsService = (service, expandEmitter, collapseEmitter, map) => (service.changes.pipe(filter(({ dataItem }) => isPresent(dataItem)))
    .subscribe((x) => x.expand ? expandEmitter.emit(map(x)) : collapseEmitter.emit(map(x))));
const isInEditedCell = (element, gridElement, isStacked = false) => (closest(element, matchesClasses('k-grid-edit-cell')) || (isStacked && closest(element, matchesClasses('k-grid-stack-edit-cell')))) &&
    closest(element, matchesNodeName('kendo-grid')) === gridElement;
const NOTIFY_DELAY = 500;
/**
 * Represents the Kendo UI for Angular Data Grid component.
 *
 * Use the `kendo-grid` component to display and manage tabular data.
 *
 * @example
 * ```html
 * <kendo-grid [data]="gridData"></kendo-grid>
 * ```
 *
 * @remarks
 * Supported children components are:
 * {@link CheckboxColumnComponent},
 * {@link ColumnChooserComponent},
 * {@link ColumnComponent},
 * {@link ColumnGroupComponent},
 * {@link ColumnMenuAutoSizeAllColumnsComponent},
 * {@link ColumnMenuAutoSizeColumnComponent},
 * {@link ColumnMenuChooserComponent},
 * {@link ColumnMenuComponent},
 * {@link ColumnMenuFilterComponent},
 * {@link ColumnMenuItemComponent},
 * {@link ColumnMenuLockComponent},
 * {@link ColumnMenuPositionComponent},
 * {@link ColumnMenuSortComponent},
 * {@link ColumnMenuStickComponent},
 * {@link CommandColumnComponent},
 * {@link CustomMessagesComponent},
 * {@link ExcelComponent},
 * {@link GridSpacerComponent},
 * {@link PDFComponent},
 * {@link RowReorderColumnComponent},
 * {@link SpanColumnComponent},
 * {@link ToolBarComponent}.
 */
class GridComponent {
    supportService;
    selectionService;
    cellSelectionService;
    wrapper;
    groupInfoService;
    groupsService;
    changeNotification;
    detailsService;
    editService;
    filterService;
    pdfService;
    responsiveService;
    renderer;
    excelService;
    ngZone;
    scrollSyncService;
    domEvents;
    columnResizingService;
    changeDetectorRef;
    columnReorderService;
    columnInfoService;
    navigationService;
    sortService;
    scrollRequestService;
    localization;
    ctx;
    sizingService;
    adaptiveGridService;
    rowReorderService;
    dataMappingService;
    aiRequestResponseService;
    idService;
    /**
     * Sets the data of the Grid. If you provide an array, the Grid gets the total count automatically.
     * ([more information and example]({% slug binding_grid %})).
     */
    set data(value) {
        this._data = value;
        if (this.selectable && this.selectableSettings?.enabled && this.isVirtual) {
            this.blockArrowSelection = false;
        }
        if (this.notifyTimeout) {
            clearTimeout(this.notifyTimeout);
            this.notifyTimeout = null;
        }
        if (this.rowReorderable) {
            this.ngZone.runOutsideAngular(() => {
                this.notifyTimeout = setTimeout(() => {
                    this.notifyReorderContainers();
                }, NOTIFY_DELAY);
            });
        }
    }
    get data() {
        return this._data;
    }
    get hintText() {
        return this.rowReorderService.getDefaultHintText(this.columnList, this.flatData);
    }
    /**
     * @hidden
     */
    get customHintTemplate() {
        if (this.rowReorderable) {
            const allColumns = this.columnList.toArray();
            const rowReorderColumn = allColumns.find(column => column.isRowReorderColumn);
            return rowReorderColumn.rowDragHintTemplateRef;
        }
    }
    /**
     * @hidden
     */
    get hintContext() {
        if (this.customHintTemplate) {
            const draggedRow = this.rowReorderService?.getDraggedRow(this.flatData);
            return {
                $implicit: draggedRow?.dataItem,
                rowIndex: draggedRow?.rowIndex
            };
        }
    }
    /**
     * Defines the page size used by the Grid pager.
     * Required for the [`paging`]({% slug paging_grid %}) feature.
     */
    pageSize;
    /**
     * Defines the height in pixels for the Grid when `scrollable` is set.
     * You can also set the height using `style.height` with units like `px`, `%`, `em`, or `rem`.
     */
    height;
    /**
     * Sets the `style.height` attribute of each Grid data or group header/footer row (`tr`) element in the DOM in pixels.
     * If some row cells have content that requires more space, the row automatically expands to fit the content.
     */
    rowHeight;
    /**
     * Enables or disables adaptive mode. Adaptive rendering is off by default.
     *
     * @default 'none'
     */
    adaptiveMode = 'none';
    /**
     * Sets the `style.height` attribute of each Grid detail row (`tr.k-detail-row`) element in the DOM in pixels.
     * If the detail row has content that requires more space, the row automatically expands to fit the content.
     */
    detailRowHeight;
    /**
     * Defines the number of records to skip in the pager.
     * Required for the [`paging`]({% slug paging_grid %}) feature.
     */
    get skip() {
        return this._skip;
    }
    set skip(value) {
        if (typeof value === 'number' && value >= 0) {
            this._skip = this.rowReorderService.skip = value;
        }
    }
    /**
     * Defines the scroll mode for the Grid.
     *
     * @default 'scrollable'
     */
    scrollable = 'scrollable';
    /**
     * Enables the selection feature of the Grid. The `selectable` property can be set to `true`, `false`, or an object with additional settings.
     * [See example](slug:grid_row_selection).
     *
     * @default false
     */
    selectable = false;
    /**
     * Sets the descriptors for sorting the data ([see example](slug:manual_sorting_grid)).
     */
    set sort(value) {
        if (isArray(value)) {
            this._sort = value;
        }
    }
    get sort() {
        return this._sort;
    }
    /**
     * Specifies the sizing for Grid elements like tables, buttons, and inputs.
     *
     * @default 'medium'
     */
    set size(size) {
        this._size = size;
        if (size === 'none') {
            this.wrapper.nativeElement.classList.remove('k-grid-sm', 'k-grid-md');
        }
        this.sizingService.changes.next(this.size);
    }
    get size() {
        return this._size;
    }
    /**
     * A function that defines how to track changes for the data rows.
     * By default, the Grid tracks changes by the index of the data item.
     * Edited rows are tracked by reference.
     * [See example](slug:track_changes_grid).
     */
    trackBy = defaultTrackBy;
    /**
     * Sets the filter descriptor for the data ([see examples](slug:manual_filtering_grid)).
     */
    filter;
    /**
     * Sets the descriptors for grouping the data ([see example](slug:manual_grouping_grid)).
     */
    set group(value) {
        if (isArray(value)) {
            this._group = value;
        }
    }
    get group() {
        return this._group;
    }
    /**
     * If `true`, renders only columns in the current viewport.
     *
     * @default false
     */
    virtualColumns = false;
    /**
     * @hidden
     */
    get showStatusBar() {
        return !!(this.selectable);
    }
    /**
     * @hidden
     */
    get showTopToolbar() {
        return this.toolbarTemplate && ['top', 'both'].indexOf(this.toolbarTemplate.position) > -1;
    }
    /**
     * @hidden
     */
    get showBottomToolbar() {
        return this.toolbarTemplate && ['bottom', 'both'].indexOf(this.toolbarTemplate.position) > -1;
    }
    /**
     * @hidden
     */
    get isLocked() {
        return (this.lockedLeafColumns.length > 0 && !this.isStacked);
    }
    /**
     * @hidden
     */
    get showTopPager() {
        const position = this.pageable.position;
        return this.pageable !== false && ['top', 'both'].indexOf(position) > -1;
    }
    /**
     * @hidden
     */
    get showBottomPager() {
        const position = this.pageable.position;
        return this.pageable !== false && position !== 'top';
    }
    /**
     * @hidden
     */
    get hasPager() {
        return this.showTopPager || this.showBottomPager;
    }
    /**
     * @hidden
     */
    get showGroupPanel() {
        const isGroupable = this.groupable && this.groupable.enabled !== false;
        const isGrouped = this.group?.length > 0;
        return this.isStacked ? isGroupable && isGrouped : isGroupable;
    }
    /**
     * @hidden
     */
    get groupableEmptyText() {
        return this.groupable.emptyText;
    }
    /**
     * @hidden
     */
    get marqueeSelection() {
        return this.selectionService.enableMarquee || this.cellSelectionService.enableMarquee;
    }
    /**
     * @hidden
     */
    get isAdaptiveModeEnabled() {
        return this.adaptiveMode === 'auto';
    }
    /**
     * @hidden
     *
     * The `isOpen` property is used to determine if a Grid Popup or ActionSheet is open.
     */
    get isOpen() {
        return isPresent(this.adaptiveGridService.popupRef) || this.isActionSheetExpanded;
    }
    /**
     * @hidden
     */
    get isActionSheetExpanded() {
        return Boolean(this.adaptiveRenderer?.actionSheet?.expanded);
    }
    /**
     * @hidden
     */
    gridData = () => { return this.flatData; };
    /**
     * Enables the [filtering](slug:filtering_grid) feature of the Grid for columns with a `field` option.
     *
     * @default false
     */
    filterable = false;
    /**
     * Enables [sorting]({% slug sorting_grid %}) feature of the Grid for columns with a `field` option.
     * @default false
     */
    sortable = false;
    /**
     * Configures the Grid pager ([see example](slug:paging_grid_settings)).
     * @default false
     */
    pageable = false;
    get normalizedPageableSettings() {
        return normalize(this.pageable);
    }
    /**
     * If `true`, allows grouping by dragging column headers ([see example]({% slug grouping_grid %})).
     *
     * @default false
     */
    groupable = false;
    /**
     * Determines if the Grid can be resized.
     *
     * @default false
     */
    gridResizable = false;
    /**
     * Enables row reordering feature of the Grid ([see example]({% slug reordering_rows_grid %})).
     *
     * @default false
     */
    set rowReorderable(value) {
        this._rowReorderable = value;
        if (value) {
            this.rowReorderSubscription = this.rowReorderService.rowReorder.subscribe(args => {
                this.ngZone.run(() => {
                    this.rowReorder.emit(args);
                });
            });
        }
        else {
            this.rowReorderSubscription?.unsubscribe();
        }
    }
    get rowReorderable() {
        return this._rowReorderable;
    }
    /**
     * By default, navigation is enabled. To disable, set to `false`.
     * To enable navigation for specific sections, provide a [`GridNavigableSection`](slug:api_grid_gridnavigablesection).
     */
    set navigable(value) {
        if (typeof value === 'boolean') {
            this._navigable = value ? ['table', 'pager', 'toolbar'] : [];
            this.ctx.navigable = value;
            return;
        }
        else {
            this.ctx.navigable = value.includes('table');
        }
        this._navigable = value;
    }
    get navigable() {
        return this._navigable;
    }
    /**
     * If `true`, resizes columns during initialization to fit headers and content.
     * Columns with `autoSize` set to `false` are excluded.
     * [See example](slug:resizing_columns_grid).
     *
     * @default false
     */
    autoSize = false;
    /**
     * Sets a function to apply custom CSS classes to each data row ([see example](slug:styling_grid_rows)).
     */
    set rowClass(fn) {
        if (isDevMode() && typeof fn !== 'function') {
            throw new Error(GridConfigurationErrorMessages.functionType('rowClass', fn));
        }
        this._rowClass = fn;
    }
    get rowClass() {
        return this._rowClass;
    }
    /**
     * Sets a function to determine if a data row is sticky (always visible after scrolling).
     */
    set rowSticky(fn) {
        if (isDevMode() && isPresent(fn) && typeof fn !== 'function') {
            throw new Error(GridConfigurationErrorMessages.functionType('rowSticky', fn));
        }
        if (isPresent(fn)) {
            this._rowSticky = fn;
        }
    }
    get rowSticky() {
        return this._rowSticky;
    }
    /**
     * Sets a function to determine if a data row is selected ([see example]({% slug grid_selection_custom %}#toc-setting-the-selected-rows)).
     */
    set rowSelected(fn) {
        if (isDevMode() && typeof fn !== 'function') {
            throw new Error(GridConfigurationErrorMessages.functionType('rowSelected', fn));
        }
        this._rowSelected = fn;
    }
    get rowSelected() {
        return this._rowSelected;
    }
    /**
     * Sets a function to determine if a data row is selectable.
     */
    set isRowSelectable(fn) {
        if (isDevMode() && typeof fn !== 'function') {
            throw new Error(GridConfigurationErrorMessages.functionType('isRowSelectable', fn));
        }
        this._isRowSelectable = fn;
    }
    get isRowSelectable() {
        return this._isRowSelectable;
    }
    /**
     * Sets a function to determine if a data cell is selected.
     * The function returns an object with `selected` and `item` properties ([see example]({% slug grid_selection_custom %}#toc-setting-the-selected-cells)).
     */
    set cellSelected(fn) {
        if (isDevMode() && typeof fn !== 'function') {
            throw new Error(GridConfigurationErrorMessages.functionType('cellSelected', fn));
        }
        this._cellSelected = fn;
    }
    get cellSelected() {
        return this._cellSelected;
    }
    /**
     * Returns the currently focused cell (if any).
     */
    get activeCell() {
        return this.navigationService.activeCell;
    }
    /**
     * Returns the currently focused row (if any).
     */
    get activeRow() {
        return this.navigationService.activeRow;
    }
    /**
     * Returns the current Grid selection.
     *
     * @hidden
     */
    get selection() {
        return (this.selectable || this.selectionDirective) ?
            this.defaultSelection ? this.defaultSelection.stateToArray() : this.selectionDirective.stateToArray() :
            [];
    }
    /**
     * Gets the current `GridState`, including data operations and column state.
     * Use this to store and restore the Grid state.
     */
    get currentState() {
        return {
            filter: this.filter,
            group: this.group,
            sort: this.sort,
            skip: this.skip,
            take: this.pageSize,
            columnsState: this.columns.toArray().flatMap(recursiveColumnsFlatMap),
            currentData: structuredClone(this.data)
        };
    }
    /**
     * If `true`, allows resizing columns by dragging header cell edges ([see example]({% slug resizing_columns_grid %})).
     *
     * @default false
     */
    resizable = false;
    /**
     * If `true`, allows reordering columns by dragging header cells ([see example]({% slug reordering_columns_grid %})).
     *
     * @default false
     */
    reorderable = false;
    /**
     * If `true`, displays the Grid loading indicator ([see example]({% slug binding_grid %})).
     *
     * @default false
     */
    set loading(value) {
        this._loading = value;
        this.rowReorderable && this.notifyReorderContainers();
    }
    get loading() {
        return this._loading;
    }
    /**
     * If `true`, displays the column menu for columns ([see example]({% slug columnmenu_grid %})).
     *
     * @default false
     */
    columnMenu = false;
    /**
     * If `true`, hides the Grid header. The header is visible by default.
     * The header includes column headers and the [filter row](slug:filter_row).
     *
     * @default false
     */
    hideHeader = false;
    /**
     * Specifies if the currently inactive toolbar tools will be visible. Applicable when the toolbar is configured using the `<kendo-toolbar>` component. By default, such tools are hidden.
     *
     * @default false
     */
    showInactiveTools = false;
    /**
     * Sets a function to determine if a specific row is expanded.
     */
    set isDetailExpanded(callback) {
        this.detailsService.userCallback = callback;
    }
    get isDetailExpanded() {
        return this.detailsService.userCallback;
    }
    /**
     * Sets a function to determine if a specific group row is expanded.
     */
    set isGroupExpanded(callback) {
        this.groupsService.userCallback = callback;
        this.groupable = isPresent(callback);
    }
    get isGroupExpanded() {
        return this.groupsService.userCallback;
    }
    /**
     * Sets the Grid data layout display mode.
     *
     * @default 'columns'
     */
    dataLayoutMode = 'columns';
    /**
     * Fires when the Grid data is filtered through the UI and the filter descriptor changes.
     */
    filterChange = new EventEmitter();
    /**
     * Fires when the page is changed through the UI ([see example]({% slug paging_grid %})).
     */
    pageChange = new EventEmitter();
    /**
     * Fires when the Grid data is grouped through the UI and the group descriptors change ([see example]({% slug grouping_grid %})).
     */
    groupChange;
    /**
     * Fires when the Grid data is sorted through the UI and the sort descriptors change ([see example]({% slug sorting_grid %})).
     */
    sortChange = new EventEmitter();
    /**
     * Fires when the Grid selection changes through the UI.
     */
    selectionChange = new EventEmitter();
    /**
     * Fires when a row is reordered through the UI.
     */
    rowReorder = new EventEmitter();
    /**
     * Fires when the data state of the Grid is changed.
     */
    dataStateChange = new EventEmitter();
    /**
     * Fires when the data or columns state of the Grid is changed.
     */
    gridStateChange = new EventEmitter();
    /**
     * Fires when a group is expanded through the UI.
     */
    groupExpand = new EventEmitter();
    /**
     * Fires when a group is collapsed through the UI.
     */
    groupCollapse = new EventEmitter();
    /**
     * Fires when a detail row is expanded through the UI.
     */
    detailExpand = new EventEmitter();
    /**
     * Fires when a detail row is collapsed through the UI.
     */
    detailCollapse = new EventEmitter();
    /**
     * Fires when a row enters edit mode ([see example](slug:inline_editing_grid#editing-records-1)).
     */
    edit = new EventEmitter();
    /**
     * Fires when editing is canceled by clicking the **Cancel** command button ([see example]({% slug inline_editing_grid %}#toc-canceling-editing-1)).
     */
    cancel = new EventEmitter();
    /**
     * Fires when a row is saved by clicking the **Save** command button ([see example]({% slug inline_editing_grid %}#toc-saving-records-1)).
     */
    save = new EventEmitter();
    /**
     * Fires when a row is removed by clicking the **Remove** command button ([see example]({% slug inline_editing_grid %}#toc-removing-records-1)).
     */
    remove = new EventEmitter();
    /**
     * Fires when a new row is added by clicking the **Add** command button ([see example]({% slug inline_editing_grid %}#toc-adding-records-1)).
     */
    add = new EventEmitter();
    /**
     * Fires when a cell edit is closed ([see example](slug:editing_incell_grid)).
     */
    cellClose = new EventEmitter();
    /**
     * Fires when a cell is clicked ([see example](slug:editing_incell_grid)).
     */
    cellClick;
    /**
     * Fires when the PDF export command is triggered.
     */
    pdfExport = new EventEmitter();
    /**
     * Fires when the Excel export command is triggered.
     */
    excelExport = new EventEmitter();
    /**
     * Fires when columns are resized.
     */
    columnResize;
    /**
     * Fires when columns are reordered.
     */
    columnReorder = new EventEmitter();
    /**
     * Fires when column visibility changes.
     */
    columnVisibilityChange = new EventEmitter();
    /**
     * Fires when columns are locked or unlocked.
     */
    columnLockedChange = new EventEmitter();
    /**
     * Fires when columns are made sticky or unsticky.
     */
    columnStickyChange = new EventEmitter();
    /**
     * Fires when the last record is scrolled into view ([see example]({% slug scrollmmodes_grid %}#toc-endless-scrolling)).
     */
    scrollBottom = new EventEmitter();
    /**
     * Fires when the grid content is scrolled.
     * The event is triggered outside the Angular zone for performance. Enter the Angular zone if you make changes that require change detection.
     */
    contentScroll = new EventEmitter();
    /**
     * A query list of all declared columns.
     */
    columns = new QueryList();
    get dir() {
        return this.direction;
    }
    hostClass = true;
    get sizeSmallClass() {
        return this.size === 'small';
    }
    get sizeMediumClass() {
        return this.size === 'medium' || !this.size;
    }
    get stackedClass() {
        return this.dataLayoutMode === 'stacked';
    }
    get lockedClasses() {
        return this.lockedLeafColumns.length > 0 && !this.isStacked;
    }
    get virtualClasses() {
        return this.isVirtual;
    }
    get noScrollbarClass() {
        return this.scrollbarWidth === 0;
    }
    get isResizable() {
        return Boolean(this.gridResizable);
    }
    get minWidth() {
        return this.gridResizable.minWidth;
    }
    get maxWidth() {
        return this.gridResizable.maxWidth;
    }
    get minHeight() {
        return this.gridResizable.minHeight;
    }
    get maxHeight() {
        return this.gridResizable.maxHeight;
    }
    detailTemplateChildren;
    get detailTemplate() {
        if (this._customDetailTemplate) {
            return this._customDetailTemplate;
        }
        return this.detailTemplateChildren ? this.detailTemplateChildren.first : undefined;
    }
    set detailTemplate(detailTemplate) {
        this._customDetailTemplate = detailTemplate;
    }
    cellLoadingTemplateChildren;
    get cellLoadingTemplate() {
        if (this._cellLoadingTemplate) {
            return this._cellLoadingTemplate;
        }
        return this.cellLoadingTemplateChildren ? this.cellLoadingTemplateChildren.first : undefined;
    }
    set cellLoadingTemplate(cellLoadingTemplate) {
        this._cellLoadingTemplate = cellLoadingTemplate;
    }
    loadingTemplateChildren;
    get loadingTemplate() {
        if (this._loadingTemplate) {
            return this._loadingTemplate;
        }
        return this.loadingTemplateChildren ? this.loadingTemplateChildren.first : undefined;
    }
    set loadingTemplate(loadingTemplate) {
        this._loadingTemplate = loadingTemplate;
    }
    statusBarTemplateChildren;
    get statusBarTemplate() {
        if (this._statusBarTemplate) {
            return this._statusBarTemplate;
        }
        return this.statusBarTemplateChildren ? this.statusBarTemplateChildren.first : undefined;
    }
    set statusBarTemplate(statusBarTemplate) {
        this._statusBarTemplate = statusBarTemplate;
    }
    noRecordsTemplateChildren;
    get noRecordsTemplate() {
        if (this._customNoRecordsTemplate) {
            return this._customNoRecordsTemplate;
        }
        return this.noRecordsTemplateChildren ? this.noRecordsTemplateChildren.first : undefined;
    }
    set noRecordsTemplate(customNoRecordsTemplate) {
        this._customNoRecordsTemplate = customNoRecordsTemplate;
    }
    pagerTemplateChildren;
    get pagerTemplate() {
        if (this._customPagerTemplate) {
            return this._customPagerTemplate;
        }
        return this.pagerTemplateChildren ? this.pagerTemplateChildren.first : undefined;
    }
    set pagerTemplate(customPagerTemplate) {
        this._customPagerTemplate = customPagerTemplate;
    }
    toolbarTemplateChildren;
    get toolbarTemplate() {
        if (this._customToolbarTemplate) {
            return this._customToolbarTemplate;
        }
        return this.toolbarTemplateChildren ? this.toolbarTemplateChildren.first : undefined;
    }
    set toolbarTemplate(customToolbarTemplate) {
        this._customToolbarTemplate = customToolbarTemplate;
    }
    columnMenuTemplates;
    lockedHeader;
    header;
    footer = new QueryList();
    ariaRoot;
    dragTargetContainer;
    dropTargetContainer;
    dialogContainer;
    windowContainer;
    adaptiveRenderer;
    listComponent;
    get scrollbarWidth() {
        return this.supportService.scrollbarWidth;
    }
    get showPagerInput() {
        return this._showPagerInput;
    }
    set showPagerInput(value) {
        if (this._showPagerInput === value) {
            return;
        }
        this._showPagerInput = value;
    }
    get showPagerPageText() {
        return this._showPagerPageText;
    }
    set showPagerPageText(value) {
        if (!this.normalizedPageableSettings?.responsive) {
            this._showPagerPageText = true;
        }
        if (this._showPagerPageText === value) {
            return;
        }
        this._showPagerPageText = value;
    }
    get showPagerItemsText() {
        return this._showPagerItemsText;
    }
    set showPagerItemsText(value) {
        if (!this.normalizedPageableSettings?.responsive) {
            this._showPagerItemsText = true;
        }
        if (this._showPagerItemsText === value) {
            return;
        }
        this._showPagerItemsText = value;
    }
    get headerPadding() {
        if (isUniversal()) {
            return '';
        }
        const padding = Math.max(0, this.scrollbarWidth) + 'px';
        const right = this.rtl ? 0 : padding;
        const left = this.rtl ? padding : 0;
        return `0 ${right} 0 ${left}`;
    }
    columnMenuOptions;
    columnList;
    selectionDirective = false;
    ariaRootId = `k-${guid()}`;
    showLicenseWatermark = false;
    /**
     * @hidden
     */
    licenseMessage;
    columnsContainer = new ColumnsContainer(() => this.columnList.filterHierarchy(column => {
        if (!isUniversal()) {
            column.matchesMedia = this.matchesMedia(column);
        }
        return column.isVisible;
    }));
    view = new DataCollection(() => new DataResultIterator(this.data, this.skip, this.hasGroupFooters));
    get hasGroupFooters() {
        return this.columnsContainer.hasGroupFooter;
    }
    get showFooter() {
        return this.columnsContainer.hasFooter;
    }
    get showGroupFooters() {
        return this.groupable && this.groupable.showFooter;
    }
    get ariaRowCount() {
        return this.totalColumnLevels + 1 + this.view.total + (hasFilterRow(this.filterable) ? 1 : 0);
    }
    get ariaColCount() {
        return this.columnsContainer.leafColumnsToRender.length;
    }
    get navigation() {
        return this.navigationService;
    }
    /**
     * @hidden
     */
    get flatData() {
        return isArray(this.data) ? this.data : this.data.data;
    }
    shouldGenerateColumns = true;
    direction;
    notifyTimeout = null;
    _sort = new Array();
    _group = new Array();
    _skip = 0;
    _data = [];
    cachedWindowWidth = 0;
    defaultSelection;
    _rowSelected = null;
    _isRowSelectable = null;
    _cellSelected = null;
    _customDetailTemplate;
    _cellLoadingTemplate;
    _loadingTemplate;
    _statusBarTemplate;
    _customNoRecordsTemplate;
    _customPagerTemplate;
    _customToolbarTemplate;
    _rowReorderable = false;
    leafViewportColumns;
    viewportColumns;
    _navigable = ['table', 'pager', 'toolbar'];
    _size = 'medium';
    _loading = false;
    _showPagerInput = true;
    _showPagerPageText = true;
    _showPagerItemsText = true;
    get isVirtual() {
        return this.scrollable === 'virtual';
    }
    get isScrollable() {
        return this.scrollable !== 'none';
    }
    /**
     * @hidden
     */
    get isStacked() {
        return typeof this.dataLayoutMode === 'string' ? this.dataLayoutMode !== 'columns' : this.dataLayoutMode.mode !== 'columns';
    }
    get visibleColumns() {
        return this.columnsContainer.allColumns;
    }
    get lockedColumns() {
        return this.columnsContainer.lockedColumns;
    }
    get nonLockedColumns() {
        return this.columnsContainer.nonLockedColumns;
    }
    get lockedLeafColumns() {
        return this.columnsContainer.lockedLeafColumns;
    }
    get stickyColumns() {
        return this.columns.filter(column => column.sticky);
    }
    get nonLockedLeafColumns() {
        return this.columnsContainer.nonLockedLeafColumns;
    }
    get leafColumns() {
        return this.columnsContainer.leafColumns;
    }
    get totalColumnLevels() {
        return this.columnsContainer.totalLevels;
    }
    get headerColumns() {
        if (this.virtualColumns && !this.pdfService.exporting) {
            return this.viewportColumns;
        }
        return this.nonLockedColumns;
    }
    get headerLeafColumns() {
        if (this.virtualColumns && !this.pdfService.exporting) {
            return this.leafViewportColumns;
        }
        return this.nonLockedLeafColumns;
    }
    get lockedWidth() {
        if (this.isStacked) {
            return 0;
        }
        const groupCellsWidth = this.group.length * GROUP_CELL_WIDTH;
        return expandColumns(this.lockedLeafColumns.toArray()).reduce((prev, curr) => prev + (curr.width || 0), groupCellsWidth);
    }
    get nonLockedWidth() {
        if (((!this.rtl && this.lockedLeafColumns.length) || this.virtualColumns) && !this.isStacked) {
            return !this.virtualColumns ? this.columnsContainer.unlockedWidth :
                this.leafViewportColumns.reduce((acc, column) => acc + (column.width || 0), 0);
        }
        return undefined;
    }
    get selectableSettings() {
        if (this.selectionService) {
            return this.selectionService.options;
        }
        return undefined;
    }
    get columnMenuTemplate() {
        const template = this.columnMenuTemplates.first;
        return template ? template.templateRef : null;
    }
    get totalCount() {
        if (this.isVirtual || !isPresent(this.pageSize)) {
            return this.view.total;
        }
        return this.pageSize;
    }
    /**
     * @hidden
     */
    getDefaultSelectors(type) {
        return this.rowReorderService.defaultSelectors(this.isStacked)[type];
    }
    /**
     * @hidden
     */
    getHintSettings(type) {
        return this.rowReorderService[type];
    }
    /**
     * @hidden
     */
    blockArrowSelection = false;
    undoRedoService;
    rowsToRender;
    selectionSubscription;
    stateChangeSubscription;
    groupExpandCollapseSubscription;
    editServiceSubscription;
    detailsServiceSubscription;
    filterSubscription;
    sortSubscription;
    columnsChangeSubscription;
    pdfSubscription;
    excelSubscription;
    columnsContainerChangeSubscription;
    cellClickSubscription;
    footerChangeSubscription;
    columnResizingSubscription;
    columnReorderSubscription;
    detachElementEventHandlers;
    localizationSubscription;
    columnVisibilityChangeSubscription;
    columnLockedChangeSubscription;
    columnStickyChangeSubscription;
    focusElementSubscription;
    columnRangeChangeSubscription;
    rowReorderSubscription;
    rtl = false;
    _rowSticky;
    constructor(supportService, selectionService, cellSelectionService, wrapper, groupInfoService, groupsService, changeNotification, detailsService, editService, filterService, pdfService, responsiveService, renderer, excelService, ngZone, scrollSyncService, domEvents, columnResizingService, changeDetectorRef, columnReorderService, columnInfoService, navigationService, sortService, scrollRequestService, localization, ctx, sizingService, adaptiveGridService, rowReorderService, dataMappingService, aiRequestResponseService, idService) {
        this.supportService = supportService;
        this.selectionService = selectionService;
        this.cellSelectionService = cellSelectionService;
        this.wrapper = wrapper;
        this.groupInfoService = groupInfoService;
        this.groupsService = groupsService;
        this.changeNotification = changeNotification;
        this.detailsService = detailsService;
        this.editService = editService;
        this.filterService = filterService;
        this.pdfService = pdfService;
        this.responsiveService = responsiveService;
        this.renderer = renderer;
        this.excelService = excelService;
        this.ngZone = ngZone;
        this.scrollSyncService = scrollSyncService;
        this.domEvents = domEvents;
        this.columnResizingService = columnResizingService;
        this.changeDetectorRef = changeDetectorRef;
        this.columnReorderService = columnReorderService;
        this.columnInfoService = columnInfoService;
        this.navigationService = navigationService;
        this.sortService = sortService;
        this.scrollRequestService = scrollRequestService;
        this.localization = localization;
        this.ctx = ctx;
        this.sizingService = sizingService;
        this.adaptiveGridService = adaptiveGridService;
        this.rowReorderService = rowReorderService;
        this.dataMappingService = dataMappingService;
        this.aiRequestResponseService = aiRequestResponseService;
        this.idService = idService;
        const isValid = validatePackage(packageMetadata);
        this.licenseMessage = getLicenseMessage(packageMetadata);
        this.showLicenseWatermark = shouldShowValidationUI(isValid);
        this.ctx.grid = this;
        this.ctx.navigable = typeof this.navigable === 'boolean' ? this.navigable : this.navigable.includes('table');
        this.groupChange = new ZoneAwareEventEmitter(this.ngZone);
        this.cellClick = new ZoneAwareEventEmitter(this.ngZone);
        this.columnResize = new ZoneAwareEventEmitter(this.ngZone);
        this.localizationSubscription = this.localization.changes.subscribe(({ rtl }) => {
            this.rtl = rtl;
            this.direction = this.rtl ? 'rtl' : 'ltr';
        });
        this.groupInfoService.registerColumnsContainer(() => this.columnList);
        this.columnInfoService.init(this.columnsContainer, () => this.columnList);
        this.columnVisibilityChangeSubscription = this.columnInfoService.visibilityChange.subscribe((changed) => {
            this.columnVisibilityChange.emit(new ColumnVisibilityChangeEvent(changed));
        });
        this.columnLockedChangeSubscription = this.columnInfoService.lockedChange.subscribe((changed) => {
            this.columnLockedChange.emit(new ColumnLockedChangeEvent(changed));
        });
        this.columnStickyChangeSubscription = this.columnInfoService.stickyChange.subscribe((changed) => {
            this.columnStickyChange.emit(new ColumnStickyChangeEvent(changed));
        });
        this.groupExpandCollapseSubscription = handleExpandCollapseGroupsService(groupsService, this.groupExpand, this.groupCollapse, ({ group, groupIndex, parentGroup }) => ({ group, groupIndex, parentGroup }));
        this.detailsServiceSubscription = handleExpandCollapseDetailsService(detailsService, this.detailExpand, this.detailCollapse, args => args);
        this.filterSubscription = this.filterService.changes.subscribe(x => {
            this.filterChange.emit(x);
        });
        this.sortSubscription = this.sortService.changes.subscribe(x => {
            this.sortChange.emit(x);
        });
        this.attachStateChangesEmitter();
        this.attachEditHandlers();
        this.attachDomEventHandlers();
        this.pdfSubscription = this.pdfService.exportClick.subscribe(this.emitPDFExportEvent.bind(this));
        this.excelSubscription = this.excelService.exportClick.subscribe(this.saveAsExcel.bind(this));
        this.columnsContainerChange();
        this.handleColumnResize();
        this.columnList = new ColumnList(this.columns);
        this.columnReorderSubscription = this.columnReorderService
            .changes.subscribe(this.reorder.bind(this));
        this.columnRangeChangeSubscription = this.columnInfoService.columnRangeChange.subscribe(this.onColumnRangeChange.bind(this));
        this.columnsContainer.isStacked = this.isStacked;
    }
    /**
     * Expands the master row at the specified data row index ([see example]({% slug hierarchy_grid %})).
     *
     * This method is for backwards compatibility with legacy versions that track expanded state by row index.
     * For new development, use the [`kendoGridDetailsExpandBy` directive]({% slug api_grid_expanddetailsdirective %})
     * or provide an `isDetailExpanded` callback. See [Controlling the Expanded State]({% slug master_detail_expanded_state_grid %}) for examples.
     *
     * @param index The data row index of the master row.
     */
    expandRow(index) {
        this.toggleDetailRowLegacy(index, true);
    }
    /**
     * Collapses the master row at the specified data row index ([see example]({% slug hierarchy_grid %})).
     *
     * This method is for backwards compatibility with legacy versions that track expanded state by row index.
     * For new development, use the [`kendoGridDetailsExpandBy` directive]({% slug api_grid_expanddetailsdirective %})
     * or provide an `isDetailExpanded` callback. See [Controlling the Expanded State]({% slug master_detail_expanded_state_grid %}) for examples.
     *
     * @param index The data row index of the master row.
     */
    collapseRow(index) {
        this.toggleDetailRowLegacy(index, false);
    }
    /**
     * Expands a group header at the given hierarchical index, such as `0_1` for the second inner group of the first master group.
     *
     * This method is for backwards compatibility with legacy versions that track expanded group state by hierarchical group index.
     * If the Grid is pageable, the group indexes are offset by the current Grid [skip]({% slug api_grid_gridcomponent %}#toc-skip).
     *
     * @param {string} index The underscore-separated hierarchical index of the group.
     */
    expandGroup(index) {
        this.toggleGroupRowLegacy(index, true);
    }
    /**
     * Collapses a group header at the given hierarchical index, such as `0_1` for the second inner group of the first master group.
     *
     * This method is for backwards compatibility with legacy versions that track expanded group state by hierarchical group index.
     * If the Grid is pageable, the group indexes are offset by the current Grid [skip]({% slug api_grid_gridcomponent %}#toc-skip).
     *
     * @param {string} index The underscore-separated hierarchical index of the group.
     */
    collapseGroup(index) {
        this.toggleGroupRowLegacy(index, false);
    }
    /**
     * @hidden
     */
    resetGroupsState() {
        this.groupsService.reset();
    }
    /**
     * Builds the request body for the AI service based on the provided prompt message.
     * Allows developers to construct their own AI service requests.
     *
     * @param promptMessage - The prompt message to send to the AI service.
     * @returns The request body object ready to be sent to the AI service.
     *
     * @example
     * ```ts
     * const requestBody = this.grid.getAIRequest('Sort by Product Name ascending');
     *
     * // Send to your AI service
     * this.http.post('https://your-ai-service.com/api', requestBody).subscribe(response => {
     *   this.grid.handleAIResponse(response);
     * });
     * ```
     */
    getAIRequest(promptMessage) {
        return this.aiRequestResponseService.buildRequestBody(promptMessage);
    }
    /**
     * Processes an AI service response and applies the commands to the Grid.
     * Allows developers to handle their own AI service responses manually.
     *
     * @param response - The AI service response containing optional message and commands array.
     *
     * @example
     * ```ts
     * const response = {
     *   message: 'Applying sorting',
     *   commands: [
     *     { type: 'GridSort', sort: { field: 'ProductName', dir: 'asc' }, message: 'Sorted by Product Name' }
     *   ]
     * };
     * this.grid.handleAIResponse(response);
     * ```
     */
    handleAIResponse(response) {
        const columns = this.columnInfoService.leafNamedColumns?.map((col) => ({ field: col.field })) || [];
        const leafColumns = this.columnInfoService.leafNamedColumns || [];
        this.aiRequestResponseService.processCommands(response.commands || [], columns, leafColumns);
    }
    /**
     * @hidden
     */
    onDataChange() {
        this.autoGenerateColumns();
        this.changeNotification.notify();
        this.pdfService.dataChanged.emit();
        if (isPresent(this.defaultSelection)) {
            this.defaultSelection.reset();
        }
        this.initSelectionService();
        this.updateNavigationMetadata();
    }
    ngDoCheck() {
        if (!this.isScrollable) {
            this.rowsToRender = this.dataMappingService.dataMapper(this.view, this.nonLockedLeafColumns, this.lockedLeafColumns, this.detailTemplate, this.showGroupFooters);
        }
    }
    ngOnChanges(changes) {
        if (isChanged$1("data", changes)) {
            this.onDataChange();
        }
        if (this.lockedLeafColumns.length && anyChanged(["pageSize", "skip", "sort", "group"], changes)) {
            this.changeNotification.notify();
        }
        if (anyChanged(["pageSize", "scrollable", 'virtualColumns'], changes)) {
            this.updateNavigationMetadata();
        }
        if (isChanged$1("virtualColumns", changes)) {
            this.viewportColumns = this.leafViewportColumns = null;
        }
        if (isChanged$1("height", changes, false)) {
            this.renderer.setStyle(this.wrapper.nativeElement, 'height', `${this.height}px`);
        }
        if (isChanged$1("filterable", changes) && this.lockedColumns.length) {
            this.syncHeaderHeight(this.ngZone.onStable.asObservable().pipe(take(1)));
        }
        if (anyChanged(["columnMenu", "sortable", "filterable"], changes, false)) {
            this.columnMenuOptions = this.columnMenu && Object.assign({
                filter: Boolean(this.filterable),
                sort: Boolean(this.sortable)
            }, this.columnMenu);
        }
        if (isChanged$1("scrollable", changes) && this.isScrollable) {
            this.ngZone.onStable.pipe(take(1)).subscribe(() => this.attachScrollSync());
        }
        if (isChanged$1("selectable", changes) && this.shouldResetSelection(changes['selectable'])) {
            if (this.defaultSelection) {
                this.defaultSelection.reset();
            }
            else if (this.selectionDirective) {
                this.selectionDirective.reset();
            }
        }
        if (isChanged$1('groupable', changes, true)) {
            this.groupable = changes['groupable'].currentValue;
        }
        if (isChanged$1('navigable', changes, true)) {
            if (this.navigationService.enabled) {
                this.navigationService.setActiveSections(this.navigable);
            }
            else {
                if (this.navigable.length) {
                    this.navigationService.init(this.navigationMetadata(), this.navigable);
                }
            }
        }
        if (isChanged$1('dataLayoutMode', changes)) {
            if (this.isStacked) {
                this.generateStackedColumns();
            }
            else {
                this.stackedColumns = { columns: [], areDefault: false };
            }
            this.columnsContainer.isStacked = this.isStacked;
        }
    }
    ngAfterContentInit() {
        this.shouldGenerateColumns = !this.columns.length;
        this.autoGenerateColumns();
        this.columnList = new ColumnList(this.columns);
        this.columnsChangeSubscription = this.columns.changes.subscribe(() => this.verifySettings());
    }
    ngAfterViewInit() {
        this.attachScrollSync();
        this.attachElementEventHandlers();
        this.updateNavigationMetadata();
        this.applyAutoSize();
        const toolbarComponentWrapper = this.wrapper?.nativeElement?.querySelector('kendo-toolbar');
        if (toolbarComponentWrapper) {
            this.renderer.addClass(toolbarComponentWrapper, 'k-grid-toolbar');
        }
    }
    ngAfterContentChecked() {
        this.columnsContainer.refresh();
        this.verifySettings();
        this.initSelectionService();
    }
    ngOnInit() {
        if (this.navigable.length) {
            this.navigationService.init(this.navigationMetadata(), this.navigable);
        }
        this.isStacked && this.generateStackedColumns();
    }
    ngOnDestroy() {
        if (this.selectionSubscription) {
            this.selectionSubscription.unsubscribe();
        }
        if (this.rowReorderSubscription) {
            this.rowReorderSubscription.unsubscribe();
        }
        if (this.columnReorderSubscription) {
            this.columnReorderSubscription.unsubscribe();
        }
        if (this.stateChangeSubscription) {
            this.stateChangeSubscription.unsubscribe();
        }
        if (this.groupExpandCollapseSubscription) {
            this.groupExpandCollapseSubscription.unsubscribe();
        }
        if (this.detailsServiceSubscription) {
            this.detailsServiceSubscription.unsubscribe();
        }
        if (this.editServiceSubscription) {
            this.editServiceSubscription.unsubscribe();
        }
        if (this.pdfSubscription) {
            this.pdfSubscription.unsubscribe();
        }
        if (this.filterSubscription) {
            this.filterSubscription.unsubscribe();
        }
        if (this.sortSubscription) {
            this.sortSubscription.unsubscribe();
        }
        if (this.columnsChangeSubscription) {
            this.columnsChangeSubscription.unsubscribe();
        }
        if (this.excelSubscription) {
            this.excelSubscription.unsubscribe();
        }
        if (this.columnsContainerChangeSubscription) {
            this.columnsContainerChangeSubscription.unsubscribe();
        }
        if (this.scrollSyncService) {
            this.scrollSyncService.destroy();
        }
        if (this.detachElementEventHandlers) {
            this.detachElementEventHandlers();
        }
        if (this.defaultSelection) {
            this.defaultSelection.destroy();
        }
        if (this.cellClickSubscription) {
            this.cellClickSubscription.unsubscribe();
        }
        if (this.footerChangeSubscription) {
            this.footerChangeSubscription.unsubscribe();
        }
        this.ngZone = null;
        if (this.columnResizingSubscription) {
            this.columnResizingSubscription.unsubscribe();
        }
        if (this.columnReorderSubscription) {
            this.columnReorderSubscription.unsubscribe();
        }
        if (this.localizationSubscription) {
            this.localizationSubscription.unsubscribe();
        }
        if (this.columnVisibilityChangeSubscription) {
            this.columnVisibilityChangeSubscription.unsubscribe();
        }
        if (this.columnLockedChangeSubscription) {
            this.columnLockedChangeSubscription.unsubscribe();
        }
        if (this.columnStickyChangeSubscription) {
            this.columnStickyChangeSubscription.unsubscribe();
        }
        if (this.focusElementSubscription) {
            this.focusElementSubscription.unsubscribe();
        }
        if (this.rowReorderSubscription) {
            this.rowReorderSubscription.unsubscribe();
        }
        this.columnRangeChangeSubscription.unsubscribe();
    }
    /**
     * @hidden
     */
    onResize() {
        if (this.isVirtual) {
            this.ctx.scroller.update();
            this.listComponent.resetNavigationViewport();
        }
    }
    /**
     * @hidden
     */
    attachScrollSync() {
        if (isUniversal()) {
            return;
        }
        if (this.header) {
            this.scrollSyncService.registerEmitter(this.header.nativeElement, "header");
        }
        if (this.footer) {
            this.footerChangeSubscription = observe(this.footer)
                .subscribe(footers => footers
                .map(footer => footer.nativeElement)
                .filter(isPresent)
                .forEach(element => {
                this.scrollSyncService.registerEmitter(element, "footer");
                // sync footers and content scroll positions when footer visibility is changed dynamically
                element.scrollLeft = this.wrapper.nativeElement.querySelector('.k-grid-content')?.scrollLeft;
            }));
        }
    }
    /**
     * @hidden
     */
    get ariaLabel() {
        return this.localization.get('gridLabel');
    }
    /**
     * @hidden
     */
    messageFor = token => this.localization.get(token);
    /**
     * Switches the specified table row to edit mode ([see example]({% slug inline_editing_grid %}#toc-editing-records-1)).
     *
     * @param rowIndex The data row index to switch to edit mode.
     * @param group The [`FormGroup`](link:site.data.urls.angular['formgroupapi']) that describes the edit form.
     * @param options Additional options to configure the focus target when the editor opens.
     */
    editRow(rowIndex, group, options) {
        this.editService.editRow(rowIndex, group);
        if (isPresent(options) && options.skipFocus) {
            return;
        }
        const row = `tr[data-kendo-grid-item-index="${rowIndex}"]`;
        const columnIndex = options && options.columnIndex;
        const target = isNaN(columnIndex) ? row : `${row} td[data-kendo-grid-column-index="${columnIndex}"]`;
        this.focusEditElement(target);
    }
    /**
     * @hidden
     */
    handleReorderEvents(ev, evType) {
        this.rowReorderService[evType](ev);
    }
    /**
     * Closes the editor for the specified row ([see example]({% slug inline_editing_grid %}#toc-canceling-editing-1)).
     *
     * @param {number} index The row index to switch out of edit mode. If you do not provide an index, the new item editor closes.
     */
    closeRow(index) {
        this.editService.close(index);
        this.isStacked && (this.navigationService.stackedCellEntered = false);
    }
    /**
     * Creates a new row editor ([see example]({% slug inline_editing_grid %}#toc-adding-records-1)).
     *
     * @param {FormGroup} group The [`FormGroup`](link:site.data.urls.angular['formgroupapi']) that describes the edit form. If you pass a data item, the method builds the `FormGroup` from the data item fields.
     */
    addRow(group) {
        const isFormGroup = group instanceof FormGroup;
        if (!isFormGroup) {
            const fields = Object.keys(group).reduce(createControl(group), {}); // FormBuilder?
            group = new FormGroup(fields);
        }
        this.editService.addRow(group);
        this.focusEditElement('.k-grid-add-row');
    }
    /**
     * Puts the specified cell in edit mode ([see example](slug:editing_incell_grid)).
     *
     * @param {number} rowIndex The data row index to switch to edit mode.
     * @param {number|string|any} column The leaf column index, field name, or column instance to edit.
     * @param {FormGroup} group The [`FormGroup`](link:site.data.urls.angular['formgroupapi']) that describes the edit form.
     */
    editCell(rowIndex, column, group) {
        const instance = this.columnInstance(column);
        this.editService.editCell(rowIndex, instance, group);
        this.focusEditElement(this.isStacked ? '.k-grid-stack-edit-cell' : '.k-grid-edit-cell');
    }
    /**
     * Closes the current cell in edit mode and fires the [`cellClose`]({% slug api_grid_gridcomponent %}#toc-cellclose) event.
     *
     * @returns {boolean} `true` if the cell closed. Returns `false` if the [`cellClose`]({% slug api_grid_gridcomponent %}#toc-cellclose) event was prevented.
     */
    closeCell() {
        return !this.editService.closeCell();
    }
    /**
     * Closes the current cell in edit mode.
     */
    cancelCell() {
        this.editService.cancelCell();
    }
    /**
     * Returns `true` if a row or cell is currently edited.
     *
     * @returns {boolean} `true` if a row or cell is currently edited.
     */
    isEditing() {
        return this.editService.isEditing();
    }
    /**
     * Returns `true` if a cell is currently edited.
     *
     * @returns {boolean} `true` if a cell is currently being edited.
     */
    isEditingCell() {
        return this.editService.isEditingCell();
    }
    /**
     * Initiates the PDF export ([see example]({% slug pdfexport_grid %})).
     */
    saveAsPDF() {
        this.pdfService.save(this);
    }
    /**
     * Exports the Grid element to a Drawing [Group]({% slug api_kendo-drawing_group %}) using the `kendo-grid-pdf` component options
     * ([see example]({% slug pdfexport_grid %}#toc-exporting-multiple-grids-to-the-same-pdf)).
     *
     * @returns {Promise} A promise that resolves with the Drawing `Group`.
     */
    drawPDF() {
        const promise = createPromise();
        this.pdfService.draw(this, promise);
        return promise;
    }
    /**
     * Initiates the Excel export ([see example]({% slug excelexport_grid %})).
     */
    saveAsExcel() {
        this.excelService.save(this);
    }
    /**
     * Applies the given `GridState` object to the Grid.
     */
    loadState(state) {
        if (state.columnsState) {
            this.traverseColumns(this.columns, (column) => {
                const columnState = state.columnsState.find((col) => col.id === column.id);
                if (columnState) {
                    column.width = columnState.width;
                    column.hidden = columnState.hidden;
                    column.locked = columnState.locked;
                    column.sticky = columnState.sticky;
                    column.orderIndex = columnState.orderIndex;
                }
            });
            this.columns.reset(this.columns.toArray());
            this.columnsContainer.refresh();
        }
        this.sort = state.sort;
        this.group = state.group;
        this.filter = state.filter;
        this.skip = state.skip;
        this.pageSize = state.take;
        if (state.currentData) {
            this.data = state.currentData;
        }
        this.changeDetectorRef.markForCheck();
    }
    traverseColumns(columns, callback) {
        columns.forEach((column) => {
            if (column.isColumnGroup || column.isSpanColumn) {
                this.traverseColumns(column.children, callback);
            }
            else {
                callback(column);
            }
        });
    }
    /**
     * Applies the minimum possible width for the specified column so the whole text fits without wrapping.
     * This method expects the Grid to be [`resizable`](slug:resizing_columns_grid). Run this method after the Grid is populated with data.
     * [See example](slug:resizing_columns_grid#toc-auto-fitting-the-content)
     */
    autoFitColumn(column) {
        this.columnResizingService.autoFit(column);
    }
    /**
     * Adjusts the width of the specified columns to fit the entire content, including headers, without wrapping.
     * If you do not specify columns, `autoFitColumns` applies to all columns. Run this method after the Grid is populated with data.
     * [See example](slug:resizing_columns_grid#toc-auto-fitting-the-content)
     */
    autoFitColumns(columns = this.columns) {
        let cols;
        if (columns instanceof QueryList) {
            cols = columns.toArray();
        }
        else {
            cols = columns;
        }
        this.columnResizingService.autoFit(...cols);
    }
    /**
     * Adjusts the width of the Grid columns to fit the entire Grid width.
     * - when the sum of all columns widths is less than the available Grid width&mdash;the available space is distributed evenly between all columns.
     * - when the sum of all columns widths is greater than the available Grid width&mdash;the columns are shrinked equally to fit the Grid width.
     *
     * Run this method after the Grid is populated with data.
     */
    autoFitColumnsToGrid() {
        const gridElement = this.wrapper.nativeElement;
        if (!gridElement) {
            return;
        }
        const leafColumns = this.columnsContainer.leafColumns.toArray();
        if (!leafColumns.length || leafColumns.length === 0) {
            return;
        }
        this.columnResizingService.autoFitToGrid(gridElement, this.scrollbarWidth, ...leafColumns);
    }
    /**
     * @hidden
     */
    notifyPageChange(source, event) {
        if (source === "list" && !this.isVirtual) {
            return;
        }
        this.pageChange.emit(event);
    }
    /**
     * @hidden
     */
    handlePagerVisibilityChange(prop, ev) {
        this[prop] = ev;
    }
    /**
     * @hidden
     */
    notifyScrollBottom() {
        if (this.scrollable === 'none') {
            return;
        }
        if (hasObservers(this.scrollBottom)) {
            this.ngZone.run(() => this.scrollBottom.emit({ sender: this }));
        }
    }
    /**
     * @hidden
     */
    focusEditElement(containerSelector) {
        if (this.focusElementSubscription) {
            this.focusElementSubscription.unsubscribe();
        }
        this.ngZone.runOutsideAngular(() => {
            this.focusElementSubscription = this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {
                const wrapper = this.wrapper.nativeElement;
                if (!this.setEditFocus(wrapper.querySelector(containerSelector)) && this.isLocked) {
                    this.setEditFocus(wrapper.querySelector(`.k-grid-content ${containerSelector}`));
                }
                this.focusElementSubscription = null;
            });
        });
    }
    /**
     * Focuses the last active or the first cell of the Grid.
     *
     * @returns {NavigationCell} The focused cell.
     */
    focus() {
        this.assertNavigable();
        return this.navigationService.focusCell();
    }
    /**
     * Focuses the cell with the specified row and column index.
     *
     * The row index is based on the logical structure of the Grid and does not correspond to the data item index.
     * Header rows are included, starting at index 0.
     * Group headers and footers are included.
     * The row indexing is absolute and does not change with paging.
     *
     * If the Grid is configured for scrolling, including virtual scrolling, the scroll position will be updated.
     * If the row is not present on the current page, the method will have no effect.
     *
     * @param rowIndex The logical row index to focus. The top header row has an index 0.
     * @param colIndex The column index to focus.
     * @returns {NavigationCell} The focused cell.
     *
     */
    focusCell(rowIndex, colIndex) {
        this.assertNavigable();
        return this.navigationService.focusCell(rowIndex, colIndex);
    }
    /**
     * Focuses the next cell, optionally wrapping to the next row.
     *
     * @param wrap A Boolean value which indicates if the focus will move to the next row. Defaults to `true`.
     * @returns {NavigationCell} The focused cell. If the focus is already on the last cell, returns `null`.
     */
    focusNextCell(wrap = true) {
        this.assertNavigable();
        return this.navigationService.focusNextCell(wrap);
    }
    /**
     * Focuses the previous cell. Optionally wraps to the previous row.
     *
     * @param wrap - A Boolean value which indicates if the focus will move to the next row. Defaults to `true`.
     * @returns {NavigationCell} The focused cell. If the focus is already on the first cell, returns `null`.
     */
    focusPrevCell(wrap = true) {
        this.assertNavigable();
        return this.navigationService.focusPrevCell(wrap);
    }
    /**
     * Scrolls to the specified row and column ([see example](slug:scrollmmodes_grid#toc-scrolling-to-a-specific-row-and-column)).
     */
    scrollTo(request) {
        this.scrollRequestService.scrollTo(request, false);
    }
    /**
     * Scrolls to the specified data item and column ([see example](slug:scrollmmodes_grid#toc-scrolling-to-a-specific-item)).
     */
    scrollToItem(request) {
        this.scrollRequestService.scrollToItem(request);
    }
    /**
     * Changes the position of the specified column.
     * The reordering of columns operates only on the level inferred by the source column.
     * For this method to work, the `source` column must be visible.
     *
     * @param {ColumnBase} source The column to move.
     * @param {number} destIndex The new position of the column.
     * @param {ColumnReorderConfig} options Additional options.
     */
    reorderColumn(source, destIndex, options = { before: false }) {
        const columnsForLevel = sortColumns(this.allColumnsForLevel(source.level));
        let target = columnsForLevel[destIndex];
        if (!target) {
            return;
        }
        const lastNonLocked = target.isLocked &&
            !source.isLocked &&
            this.columnsContainer.nonLockedColumns.length === 1;
        if (lastNonLocked) {
            return;
        }
        if (isSpanColumnComponent(target) && !options.before) {
            target = target.children.last;
        }
        this.reorder({
            before: options.before,
            source: source,
            target: target
        });
    }
    /**
     * @hidden
     */
    updateNavigationMetadata() {
        this.navigationService.metadata = this.navigationMetadata();
    }
    reorder({ target, source, before, changeContainer }) {
        this.ngZone.run(() => {
            const columnsForLevel = sortColumns(this.allColumnsForLevel(source.level));
            let newIndex = columnsForLevel.indexOf(target);
            if (target.parent && target.parent.isSpanColumn) {
                newIndex = columnsForLevel.indexOf(target.parent);
                if (before) {
                    target = target.parent;
                }
            }
            const oldIndex = columnsForLevel.indexOf(source);
            if (changeContainer) {
                if (before && 0 < newIndex && oldIndex < newIndex) { // dropped before the first not locked column
                    newIndex--;
                }
                else if (!before && oldIndex > newIndex) { // dropped after the last locked column
                    newIndex++;
                }
            }
            const args = new ColumnReorderEvent({
                column: source,
                oldIndex: oldIndex,
                newIndex: newIndex
            });
            this.columnReorder.emit(args);
            if (args.isDefaultPrevented()) {
                return;
            }
            if (changeContainer) {
                this.columnLockedChange.emit(new ColumnLockedChangeEvent([source]));
            }
            this.updateColumnIndices({ columnsForLevel, source, target, before });
            if (source.locked !== target.locked) {
                source.locked = target.locked;
            }
            this.columnsContainer.refresh();
            if (this.virtualColumns) {
                this.listComponent.updateViewportColumns();
            }
            this.changeDetectorRef.markForCheck();
        });
    }
    updateColumnIndices({ columnsForLevel, source, target, before }) {
        const expandedColumns = expandColumnsWithSpan(columnsForLevel);
        const sourceColumnIndex = expandedColumns.indexOf(source);
        let nextSourceIndex = 0;
        let nextIndex = 0;
        let toSkip = 1;
        // Possible only when called from the API.
        if (source.isSpanColumn) {
            toSkip += source.children.length;
        }
        let i = 0;
        while (i < expandedColumns.length) {
            const column = expandedColumns[i];
            if (column === target) {
                nextSourceIndex = before ? nextIndex : nextIndex + 1;
                nextIndex = before ? nextIndex + toSkip : nextIndex;
                column.orderIndex = nextIndex;
                if (nextSourceIndex === nextIndex + 1) {
                    nextIndex += toSkip;
                }
            }
            else if (column === source) {
                i += toSkip;
                column.isReordered = true;
                continue;
            }
            else {
                column.orderIndex = nextIndex;
            }
            column.isReordered = true;
            nextIndex++;
            i++;
        }
        for (i = sourceColumnIndex; i < sourceColumnIndex + toSkip; i++) {
            expandedColumns[i].orderIndex = nextSourceIndex++;
            expandedColumns[i].isReordered = true;
        }
        this.updateIndicesForLevel(source.level + 1);
        this.columnResizingService.areColumnsReordered = true;
    }
    updateIndicesForLevel(level) {
        const colsForParentLevel = this.allColumnsForLevel(level - 1);
        const colsForLevel = [];
        sortColumns(colsForParentLevel).forEach((c) => {
            if (c.isColumnGroup) {
                colsForLevel.push(...c.childrenArray.sort((a, b) => a.orderIndex - b.orderIndex));
            }
        });
        expandColumnsWithSpan(colsForLevel).forEach((c, i) => {
            c.orderIndex = i;
            c.isReordered = true;
        });
        if (level < this.columnList.totalColumnLevels()) {
            this.updateIndicesForLevel(level + 1);
        }
    }
    allColumnsForLevel(level) {
        return this.columnList.toArray().filter(column => column.level === level);
    }
    initSelectionService() {
        if (!this.selectable) {
            this.selectionService.ngOnDestroy();
            this.cellSelectionService.ngOnDestroy();
            return;
        }
        if (!this.selectionDirective && !isPresent(this.defaultSelection)) {
            this.defaultSelection = new Selection(this.ctx, this.changeDetectorRef);
        }
        const cellSelectionMode = this.selectable['cell'];
        const activeService = cellSelectionMode ? this.cellSelectionService : this.selectionService;
        const inactiveService = cellSelectionMode ? this.selectionService : this.cellSelectionService;
        if (inactiveService.active) {
            inactiveService.ngOnDestroy();
            activeService.addSubscriptions();
            inactiveService.active = false;
        }
        activeService.active = true;
        activeService.init({
            cellSelected: cellSelectionMode ? this.cellSelected : undefined,
            rowSelected: cellSelectionMode ? undefined : this.rowSelected,
            isRowSelectable: this.isRowSelectable,
            selectable: this.selectable,
            view: this.view,
            columns: cellSelectionMode ? this.columnList.toArray() : undefined,
            isStacked: this.isStacked
        });
        if (!this.selectionDirective && !this.selectableSettings.enabled) {
            this.defaultSelection.reset();
        }
        if (this.selectionSubscription) {
            this.selectionSubscription.unsubscribe();
        }
        if (cellSelectionMode) {
            this.selectionSubscription = this.cellSelectionService.changes.subscribe((event) => {
                this.ngZone.run(() => this.selectionChange.emit(event));
            });
        }
        else {
            this.selectionSubscription = this.selectionService.changes.subscribe((event) => {
                this.ngZone.run(() => this.selectionChange.emit(event));
            });
        }
    }
    setEditFocus(element) {
        if (element) {
            return this.navigationService.tryFocus(element);
        }
    }
    columnInstance(column) {
        let instance;
        if (typeof column === 'number') {
            instance = this.columnsContainer.lockedLeafColumns.toArray()
                .concat(this.columnsContainer.nonLockedLeafColumns.toArray())[column];
        }
        else if (typeof column === 'string') {
            instance = this.columnList.filter((item) => item.field === column)[0];
        }
        else {
            instance = column;
        }
        if (!instance && isDevMode()) {
            throw new Error(ColumnConfigurationErrorMessages.invalidColumn(column));
        }
        return instance;
    }
    verifySettings() {
        if (isDevMode()) {
            const locked = this.lockedLeafColumns.length || (this.columnMenu && this.columnMenu.lock);
            const stickyColumns = this.stickyColumns.length || (this.columnMenu && this.columnMenu.stick);
            if (locked && this.detailTemplate) {
                throw new Error(GridConfigurationErrorMessages.incompatibleFeatures('detail template', 'locked columns'));
            }
            if (stickyColumns && this.detailTemplate) {
                throw new Error(GridConfigurationErrorMessages.incompatibleFeatures('detail template', 'sticky columns'));
            }
            if (this.lockedLeafColumns.length && !this.nonLockedLeafColumns.length) {
                console.warn(GridConfigurationErrorMessages.nonLockedColumnPresent);
            }
            if (!this.isStacked && (locked || this.virtualColumns) && expandColumns(this.columnList.toArray()).filter(column => !column.width && !isColumnGroupComponent(column)).length) {
                console.warn(ColumnConfigurationErrorMessages.requiredWidth(locked ? 'Locked' : 'Virtual'));
            }
            if (locked && !this.isScrollable) {
                console.warn(ColumnConfigurationErrorMessages.requiredScroll('Locked'));
            }
            if (stickyColumns && !this.isScrollable) {
                console.warn(ColumnConfigurationErrorMessages.requiredScroll('Sticky'));
            }
            if (this.virtualColumns && !this.isScrollable) {
                console.warn(ColumnConfigurationErrorMessages.requiredScroll('Virtual'));
            }
            if (this.columnList.filter(isColumnGroupComponent).filter((x) => !x.hasChildren).length) {
                throw new Error(ColumnConfigurationErrorMessages.groupColumnContent);
            }
            if (this.columnList.filter(x => x.locked && x.parent && !x.parent.isLocked).length) {
                throw new Error(ColumnConfigurationErrorMessages.lockedParent);
            }
            if (!this.isStacked && stickyColumns && expandColumns(this.columnList.toArray()).filter(column => !column.width && !isColumnGroupComponent(column)).length) {
                console.warn(ColumnConfigurationErrorMessages.requiredWidth('Sticky'));
            }
            if (this.rowSticky && this.scrollable === 'virtual') {
                throw new Error(GridConfigurationErrorMessages.incompatibleFeatures('sticky rows', 'row virtualization (scrollable="virtual")'));
            }
            if (this.rowSticky && this.groupable) {
                throw new Error(GridConfigurationErrorMessages.incompatibleFeatures('sticky rows', 'grouping'));
            }
            if (this.wrapper?.nativeElement?.querySelector('kendo-toolbar') && this.toolbarTemplate) {
                console.warn(GridConfigurationErrorMessages.unsupportedToolbarConfig);
            }
            validateColumnsField(this.columnList);
        }
    }
    autoGenerateColumns() {
        if (this.shouldGenerateColumns && !this.columns.length && this.view.length) {
            this.columns.reset(Object.keys(this.view.at(0)).map(field => {
                const column = new ColumnComponent(undefined, this.idService);
                column.field = field;
                return column;
            }));
        }
    }
    /**
     * @hidden
     */
    stackedColumns = { columns: [], areDefault: false };
    generateStackedColumns() {
        if (!this.isStacked || !isPresent(this.dataLayoutMode)) {
            return;
        }
        this.stackedColumns.columns = [];
        if (typeof this.dataLayoutMode === 'object') {
            if (this.dataLayoutMode.mode === 'stacked' && this.dataLayoutMode.stackedCols) {
                const columns = this.dataLayoutMode.stackedCols;
                if (typeof columns === 'number') {
                    for (let i = 0; i < columns; i++) {
                        const currCol = { width: `${this.wrapper.nativeElement.clientWidth / columns}px` };
                        this.stackedColumns.columns.push(currCol);
                    }
                    this.stackedColumns.areDefault = true;
                }
                else if (Array.isArray(columns)) {
                    this.stackedColumns.columns = columns.map((colSize) => {
                        const stackedColumn = {};
                        if (typeof colSize === 'number') {
                            stackedColumn.width = `${colSize}px`;
                        }
                        else if (typeof colSize === 'object' && colSize?.width) {
                            stackedColumn.width = typeof colSize.width === 'number' ? `${colSize.width}px` : colSize.width;
                        }
                        else if (typeof colSize === 'string') {
                            stackedColumn.width = colSize;
                        }
                        return stackedColumn;
                    });
                    this.stackedColumns.areDefault = false;
                }
            }
        }
        else {
            this.stackedColumns = { columns: [{ width: this.wrapper.nativeElement.clientWidth }], areDefault: true };
        }
    }
    attachStateChangesEmitter() {
        this.stateChangeSubscription =
            merge(this.pageChange.pipe(tap(() => {
                if (this.pageable) {
                    this.ctx.scroller?.reset();
                }
            }), map(x => ({
                filter: this.filter, group: this.group, skip: x.skip, sort: this.sort, take: x.take
            }))), this.sortChange.pipe(tap(() => {
                this.ctx.scroller?.reset();
            }), map(sort => ({ filter: this.filter, group: this.group, skip: this.isVirtual && !this.pageable ? 0 : this.skip, sort: sort, take: this.pageSize }))), this.groupChange.pipe(tap(() => {
                this.ctx.scroller?.reset();
            }), map(group => ({
                filter: this.filter, group: group, skip: this.pageable ? this.skip : 0, sort: this.sort, take: (this.pageable || !group?.length) ? this.pageSize : undefined
            }))), this.filterChange.pipe(tap(() => {
                this.ctx.scroller?.reset();
            }), map(filter => ({
                filter: filter, group: this.group, skip: 0, sort: this.sort, take: this.pageSize
            }))))
                .subscribe(x => {
                this.closeCell();
                this.cancelCell();
                if (this.selectable && this.selectableSettings?.enabled && this.isVirtual) {
                    this.blockArrowSelection = true;
                }
                this.isVirtual && this.ctx.scroller?.resetVirtualSkip();
                this.dataStateChange.emit(x);
                hasObservers(this.gridStateChange) && this.gridStateChange.emit({ ...this.currentState, ...x });
            });
        this.stateChangeSubscription.add(merge(this.columnReorder, this.columnResize, this.columnVisibilityChange, this.columnLockedChange, this.columnStickyChange).pipe(flatMap(() => this.ngZone.onStable.pipe(take(1))))
            .subscribe(() => this.ngZone.run(() => {
            hasObservers(this.gridStateChange) && this.gridStateChange.emit(this.currentState);
            if (this.isVirtual) {
                this.ctx.scroller?.update();
                this.listComponent?.resetNavigationViewport();
            }
        })));
    }
    attachEditHandlers() {
        if (!this.editService) {
            return;
        }
        this.editServiceSubscription = this.editService
            .changes.subscribe(this.emitCRUDEvent.bind(this));
    }
    emitCRUDEvent(args) {
        const { action, rowIndex, formGroup } = args;
        let dataItem = this.view.at(rowIndex - this.skip);
        if (action !== 'add' && !dataItem) {
            dataItem = formGroup.value;
        }
        this.closeCell();
        Object.assign(args, {
            dataItem: dataItem,
            sender: this
        });
        switch (action) {
            case 'add':
                this.add.emit(args);
                break;
            case 'cancel':
                this.cancel.emit(args);
                break;
            case 'edit':
                this.edit.emit(args);
                break;
            case 'remove':
                this.remove.emit(args);
                break;
            case 'save':
                this.save.emit(args);
                break;
            case 'cellClose':
                this.cellClose.emit(args);
                break;
            default: break;
        }
    }
    attachDomEventHandlers() {
        this.cellClickSubscription = this.domEvents.cellClick.subscribe((args) => {
            if (this.isStacked && !isPresent(args.column)) {
                return;
            }
            this.cellClick.emit(Object.assign({ sender: this }, args));
        });
    }
    attachElementEventHandlers() {
        if (isUniversal()) {
            return;
        }
        const wrapper = this.wrapper.nativeElement;
        const ariaRoot = this.ariaRoot.nativeElement;
        this.ngZone.runOutsideAngular(() => {
            const resizeCheck = this.resizeCheck.bind(this);
            const resizeSubscription = this.renderer.listen('window', 'resize', resizeCheck);
            const orientationSubscription = this.renderer.listen('window', 'orientationchange', resizeCheck);
            const documentClickSubscription = this.renderer.listen('document', 'click', (args) => {
                const activeElement = document.activeElement;
                if (this.editService.shouldCloseCell() &&
                    !closest(args.target, matchesClasses('k-animation-container k-grid-ignore-click')) &&
                    !(activeElement &&
                        (closest(activeElement, matchesClasses('k-animation-container')) ||
                            isInEditedCell(activeElement, this.wrapper.nativeElement, this.isStacked)))) {
                    this.editService.closeCell(args);
                }
            });
            const windowBlurSubscription = this.renderer.listen('window', 'blur', (args) => {
                const activeElement = document.activeElement;
                if (activeElement && !(matchesNodeName('input')(activeElement) && activeElement.type === 'file' &&
                    isInEditedCell(activeElement, this.wrapper.nativeElement, this.isStacked))) {
                    this.editService.closeCell(args);
                }
                this.domEvents.windowBlur.emit(args);
            });
            const clickSubscription = this.renderer.listen(wrapper, 'click', (args) => {
                this.domEvents.click.emit(args);
            });
            const keydownSubscription = this.renderer.listen(wrapper, 'keydown', (args) => {
                this.domEvents.keydown.emit(args);
            });
            const shiftKeyupSubscription = this.renderer.listen(wrapper, 'keyup', (args) => {
                if (args.key === 'Shift') {
                    this.domEvents.shiftKeyup.emit(args);
                }
            });
            // focusIn and focusOut are relative to the element with ARIA role "grid"
            let focused = false;
            const focusInSubscription = this.renderer.listen(ariaRoot, 'focusin', (args) => {
                this.domEvents.focus.emit(args);
                if (!focused) {
                    this.domEvents.focusIn.emit(args);
                    focused = true;
                }
            });
            const focusOutSubscription = this.renderer.listen(ariaRoot, 'focusout', (args) => {
                const next = args.relatedTarget || document.activeElement;
                const outside = !closest(next, (node) => node === ariaRoot);
                if (outside) {
                    this.domEvents.focusOut.emit(args);
                    this.domEvents.shiftKeyup.emit(args);
                    focused = false;
                }
            });
            this.detachElementEventHandlers = () => {
                resizeSubscription();
                orientationSubscription();
                documentClickSubscription();
                windowBlurSubscription();
                clickSubscription();
                keydownSubscription();
                shiftKeyupSubscription();
                focusInSubscription();
                focusOutSubscription();
            };
        });
    }
    matchesMedia(c) {
        return this.responsiveService.matchesMedia(c.media);
    }
    resizeCheck() {
        if (window.innerWidth !== this.cachedWindowWidth) {
            this.cachedWindowWidth = window.innerWidth;
            let hasChanges = false;
            this.columnList.filterHierarchy(column => {
                const matchesMedia = this.matchesMedia(column);
                if (column.matchesMedia !== matchesMedia) {
                    hasChanges = true;
                    column.matchesMedia = matchesMedia;
                }
                return column.isVisible;
            });
            if (hasChanges) {
                this.ngZone.run(() => {
                    this.changeDetectorRef.markForCheck();
                });
            }
        }
    }
    emitPDFExportEvent() {
        const args = new PDFExportEvent();
        this.pdfExport.emit(args);
        if (!args.isDefaultPrevented()) {
            this.saveAsPDF();
        }
    }
    syncHeaderHeight(observable) {
        return observable
            .pipe(filter(() => isPresent(this.lockedHeader)))
            .subscribe(() => syncRowsHeight(this.lockedHeader.nativeElement.children[0], this.header.nativeElement.children[0]));
    }
    columnsContainerChange() {
        this.columnsContainerChangeSubscription =
            this.syncHeaderHeight(this.columnsContainer.changes.pipe(filter(() => this.lockedColumns.length > 0), switchMap(() => this.ngZone.onStable.asObservable().pipe(take(1)))));
    }
    handleColumnResize() {
        const resizes = this.columnResizingService.changes;
        this.columnResizingSubscription = resizes.pipe(tap(e => {
            if (e.type === 'start') {
                this.renderer.addClass(this.wrapper.nativeElement, 'k-grid-column-resizing');
            }
            else if (e.type === 'end') {
                this.renderer.removeClass(this.wrapper.nativeElement, 'k-grid-column-resizing');
            }
        }), filter(e => e.type === 'start'), switchMap(() => resizes.pipe(takeUntil(resizes.pipe(filter(e => e.type === 'triggerAutoFit'))), filter(e => e.type === 'end'))))
            .subscribe(this.notifyResize.bind(this));
    }
    notifyResize(e) {
        const args = e.resizedColumns
            .filter(item => isTruthy(item.column.resizable) && !item.column.isColumnGroup)
            .map(item => ({
            column: item.column,
            newWidth: roundDown(item.column.width),
            oldWidth: roundDown(item.oldWidth)
        }));
        this.columnResize.emit(args);
    }
    assertNavigable() {
        if (isDevMode() && !this.navigationService.enabled) {
            throw new Error(GridConfigurationErrorMessages.focusNavigable);
        }
    }
    _rowClass = () => null;
    navigationMetadata() {
        const isVirtual = this.isVirtual;
        const dataVirtualization = isVirtual && !this.pageable && !this.group?.length;
        const groupedVirtual = isVirtual && this.group?.length > 0;
        let dataRows;
        if (this.pageable) {
            dataRows = this.skip + Math.min(this.pageSize, this.view.length); // last page might have less rows than the rest
        }
        else {
            dataRows = this.view.total;
        }
        if (groupedVirtual) {
            dataRows = this.ctx.scroller?.total ?? 0;
            if (!dataVirtualization) {
                dataRows += this.skip;
            }
        }
        const addRowOffset = this.editService.hasNewItem ? 1 : 0;
        const filterRowOffset = hasFilterRow(this.filterable) ? 1 : 0;
        const headerRows = this.isStacked ? 0 : this.totalColumnLevels + 1 + filterRowOffset + addRowOffset;
        return new NavigationMetadata(dataRows, headerRows, isVirtual, this.hasPager, isPresent(this.detailTemplate), this.wrapper, this.virtualColumns, this.columnsContainer, this.showFooter ? 1 : 0, this.isStacked);
    }
    applyAutoSize() {
        const cols = this.columns.filter((c) => this.autoSize ? c.autoSize !== false : c.autoSize);
        if (cols.length > 0) {
            this.ngZone.onStable.pipe(take(1)).subscribe(() => this.autoFitColumns(cols));
        }
    }
    onColumnRangeChange(range) {
        const viewportColumns = this.viewportColumns = [];
        const columnsArray = this.columnsContainer.nonLockedLeafColumns.toArray();
        let leafViewportColumns = columnsArray.slice(range.start, range.end + 1);
        const stickyBeforeStart = columnsArray.slice(0, range.start).filter(c => c.sticky && !leafViewportColumns.some(col => col === c));
        const stickyAfterEnd = columnsArray.slice(range.end, columnsArray.length).filter(c => c.sticky && !leafViewportColumns.some(col => col === c));
        leafViewportColumns = [...stickyBeforeStart, ...leafViewportColumns, ...stickyAfterEnd];
        for (let idx = 0; idx < leafViewportColumns.length; idx++) {
            let column = leafViewportColumns[idx];
            while (column.parent) {
                column = column.parent;
            }
            const toAdd = [column];
            while (toAdd.length) {
                column = toAdd.shift();
                viewportColumns.push(column);
                if (column.isColumnGroup) {
                    const children = columnsArray.filter(c => c.parent && c.parent.id === column.id);
                    toAdd.unshift(...children);
                }
            }
            const lastFromGroup = viewportColumns[viewportColumns.length - 1];
            column = leafViewportColumns[idx];
            while (column !== lastFromGroup && idx < leafViewportColumns.length) {
                idx++;
                column = leafViewportColumns[idx];
            }
        }
        if (range.start > 0) {
            const first = leafViewportColumns[0];
            let offset = range.offset;
            let current = viewportColumns[0];
            let index = 0;
            while (current !== first) {
                offset -= current.isColumnGroup ? 0 : current.width;
                index++;
                current = viewportColumns[index];
            }
            if (offset > 0) {
                const totalLevels = this.columnsContainer.totalLevels;
                let previous;
                for (let idx = 0; idx <= totalLevels; idx++) {
                    const offsetColumn = idx < totalLevels ? new ColumnGroupComponent(previous) : new ColumnBase(previous);
                    previous = offsetColumn;
                    offsetColumn.title = "\u00A0";
                    offsetColumn.width = offset;
                    viewportColumns.unshift(offsetColumn);
                }
            }
        }
        this.leafViewportColumns = viewportColumns.filter(c => !c.isColumnGroup);
    }
    toggleDetailRowLegacy(index, expand) {
        const hasCallback = typeof this.isDetailExpanded === 'function';
        if (isDevMode() && hasCallback) {
            throw new Error(GridConfigurationErrorMessages.expandCollapseMethods('expandRow', 'collapseRow', 'kendoGridDetailsExpandBy', 'isDetailExpanded'));
        }
        if (!isDevMode() && hasCallback) {
            return;
        }
        if (this.detailsService.isExpanded(index, null) !== expand) {
            this.detailsService.toggleRow(index, null);
        }
    }
    toggleGroupRowLegacy(index, expand) {
        const hasCallback = typeof this.isGroupExpanded === 'function';
        if (isDevMode() && hasCallback) {
            throw new Error(GridConfigurationErrorMessages.expandCollapseMethods('expandGroup', 'collapseGroup', 'kendoGridExpandGroupBy', 'isGroupExpanded'));
        }
        if (!isDevMode() && hasCallback) {
            return;
        }
        if (this.groupsService.isExpanded({ groupIndex: index }) !== expand) {
            this.groupsService.toggleRow({ index }, false);
        }
        this.changeDetectorRef.markForCheck();
    }
    shouldResetSelection(selectableChanges) {
        const previousValue = selectableChanges.previousValue;
        if (!previousValue) {
            // Selection was disabled, no need to reset.
            return false;
        }
        const currentValue = selectableChanges.currentValue;
        if (!currentValue || currentValue.enabled === false) {
            // Selection disabled, reset.
            return true;
        }
        return previousValue.cell !== currentValue.cell;
    }
    notifyReorderContainers() {
        this.dragTargetContainer?.notify();
        this.dropTargetContainer?.notify();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GridComponent, deps: [{ token: BrowserSupportService }, { token: SelectionService }, { token: CellSelectionService }, { token: i0.ElementRef }, { token: GroupInfoService }, { token: GroupsService }, { token: ChangeNotificationService }, { token: DetailsService }, { token: EditService }, { token: FilterService }, { token: PDFService }, { token: ResponsiveService }, { token: i0.Renderer2 }, { token: ExcelService }, { token: i0.NgZone }, { token: ScrollSyncService }, { token: DomEventsService }, { token: ColumnResizingService }, { token: i0.ChangeDetectorRef }, { token: ColumnReorderService }, { token: ColumnInfoService }, { token: NavigationService }, { token: SortService }, { token: ScrollRequestService }, { token: i1$2.LocalizationService }, { token: ContextService }, { token: SizingOptionsService }, { token: AdaptiveGridService }, { token: RowReorderService }, { token: DataMappingService }, { token: GridAIRequestResponseService }, { token: IdService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: GridComponent, isStandalone: true, selector: "kendo-grid", inputs: { data: "data", pageSize: "pageSize", height: "height", rowHeight: "rowHeight", adaptiveMode: "adaptiveMode", detailRowHeight: "detailRowHeight", skip: "skip", scrollable: "scrollable", selectable: "selectable", sort: "sort", size: "size", trackBy: "trackBy", filter: "filter", group: "group", virtualColumns: "virtualColumns", filterable: "filterable", sortable: "sortable", pageable: "pageable", groupable: "groupable", gridResizable: "gridResizable", rowReorderable: "rowReorderable", navigable: "navigable", autoSize: "autoSize", rowClass: "rowClass", rowSticky: "rowSticky", rowSelected: "rowSelected", isRowSelectable: "isRowSelectable", cellSelected: "cellSelected", resizable: "resizable", reorderable: "reorderable", loading: "loading", columnMenu: "columnMenu", hideHeader: "hideHeader", showInactiveTools: "showInactiveTools", isDetailExpanded: "isDetailExpanded", isGroupExpanded: "isGroupExpanded", dataLayoutMode: "dataLayoutMode" }, outputs: { filterChange: "filterChange", pageChange: "pageChange", groupChange: "groupChange", sortChange: "sortChange", selectionChange: "selectionChange", rowReorder: "rowReorder", dataStateChange: "dataStateChange", gridStateChange: "gridStateChange", groupExpand: "groupExpand", groupCollapse: "groupCollapse", detailExpand: "detailExpand", detailCollapse: "detailCollapse", edit: "edit", cancel: "cancel", save: "save", remove: "remove", add: "add", cellClose: "cellClose", cellClick: "cellClick", pdfExport: "pdfExport", excelExport: "excelExport", columnResize: "columnResize", columnReorder: "columnReorder", columnVisibilityChange: "columnVisibilityChange", columnLockedChange: "columnLockedChange", columnStickyChange: "columnStickyChange", scrollBottom: "scrollBottom", contentScroll: "contentScroll" }, host: { properties: { "attr.dir": "this.dir", "class.k-grid": "this.hostClass", "class.k-grid-sm": "this.sizeSmallClass", "class.k-grid-md": "this.sizeMediumClass", "class.k-grid-stack": "this.stackedClass", "class.k-grid-lockedcolumns": "this.lockedClasses", "class.k-grid-virtual": "this.virtualClasses", "class.k-grid-no-scrollbar": "this.noScrollbarClass", "class.k-grid-resizable": "this.isResizable", "style.minWidth": "this.minWidth", "style.maxWidth": "this.maxWidth", "style.minHeight": "this.minHeight", "style.maxHeight": "this.maxHeight" } }, providers: [
            BrowserSupportService,
            LocalizationService,
            ColumnInfoService,
            SelectionService,
            CellSelectionService,
            DetailsService,
            GroupsService,
            GroupInfoService,
            ChangeNotificationService,
            EditService,
            PDFService,
            SuspendService,
            {
                provide: CELL_CONTEXT,
                useValue: EMPTY_CELL_CONTEXT
            },
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.grid'
            },
            FilterService,
            ResponsiveService,
            PagerContextService,
            PagerNavigationService,
            ExcelService,
            ScrollSyncService,
            ResizeService,
            LocalDataChangesService,
            DomEventsService,
            ColumnResizingService,
            SinglePopupService,
            DragAndDropService,
            DragHintService,
            DropCueService,
            ColumnReorderService,
            NavigationService,
            FocusRoot,
            IdService,
            CellSelectionAggregateService,
            ScrollRequestService,
            SortService,
            ContextService,
            SizingOptionsService,
            RowReorderService,
            ClipboardService,
            GridAIRequestResponseService,
            RowspanService,
            AdaptiveGridService,
            ColumnMenuService,
            MenuTabbingService,
            DataMappingService
        ], queries: [{ propertyName: "columns", predicate: ColumnBase }, { propertyName: "detailTemplateChildren", predicate: DetailTemplateDirective }, { propertyName: "cellLoadingTemplateChildren", predicate: CellLoadingTemplateDirective }, { propertyName: "loadingTemplateChildren", predicate: LoadingTemplateDirective }, { propertyName: "statusBarTemplateChildren", predicate: StatusBarTemplateDirective }, { propertyName: "noRecordsTemplateChildren", predicate: NoRecordsTemplateDirective }, { propertyName: "pagerTemplateChildren", predicate: PagerTemplateDirective }, { propertyName: "toolbarTemplateChildren", predicate: ToolbarTemplateDirective }, { propertyName: "columnMenuTemplates", predicate: ColumnMenuTemplateDirective }], viewQueries: [{ propertyName: "lockedHeader", first: true, predicate: ["lockedHeader"], descendants: true }, { propertyName: "header", first: true, predicate: ["header"], descendants: true }, { propertyName: "ariaRoot", first: true, predicate: ["ariaRoot"], descendants: true, static: true }, { propertyName: "dragTargetContainer", first: true, predicate: DragTargetContainerDirective, descendants: true }, { propertyName: "dropTargetContainer", first: true, predicate: DropTargetContainerDirective, descendants: true }, { propertyName: "dialogContainer", first: true, predicate: ["dialogContainer"], descendants: true, read: ViewContainerRef }, { propertyName: "windowContainer", first: true, predicate: ["windowContainer"], descendants: true, read: ViewContainerRef }, { propertyName: "adaptiveRenderer", first: true, predicate: AdaptiveRendererComponent, descendants: true }, { propertyName: "listComponent", first: true, predicate: ListComponent, descendants: true }, { propertyName: "footer", predicate: ["footer"], descendants: true }], exportAs: ["kendoGrid"], usesOnChanges: true, ngImport: i0, template: `
        <ng-container kendoGridLocalizedMessages
          i18n-groupPanelEmpty="kendo.grid.groupPanelEmpty|The label visible in the Grid group panel when it is empty"
          groupPanelEmpty="Drag a column header and drop it here to group by that column"

          i18n-noRecords="kendo.grid.noRecords|The label visible in the Grid when there are no records"
          noRecords="No records available."

          i18n-pagerLabel="kendo.grid.pagerLabel|The label for the Grid pager"
          pagerLabel="{{ 'Page navigation, page {currentPage} of {totalPages}' }}"

          i18n-pagerFirstPage="kendo.grid.pagerFirstPage|The label for the first page button in Grid pager"
          pagerFirstPage="Go to the first page"

          i18n-pagerPreviousPage="kendo.grid.pagerPreviousPage|The label for the previous page button in Grid pager"
          pagerPreviousPage="Go to the previous page"

          i18n-pagerNextPage="kendo.grid.pagerNextPage|The label for the next page button in Grid pager"
          pagerNextPage="Go to the next page"

          i18n-pagerLastPage="kendo.grid.pagerLastPage|The label for the last page button in Grid pager"
          pagerLastPage="Go to the last page"

          i18n-pagerPage="kendo.grid.pagerPage|The label before the current page number in the Grid pager"
          pagerPage="Page"

          i18n-pagerOf="kendo.grid.pagerOf|The label before the total pages number in the Grid pager"
          pagerOf="of"

          i18n-pagerItems="kendo.grid.pagerItems|The label after the total pages number in the Grid pager"
          pagerItems="items"

          i18n-pagerPageNumberInputTitle="kendo.grid.pagerPageNumberInputTitle|The label for the pager input in the Grid pager"
          pagerPageNumberInputTitle="Page Number"

          i18n-pagerItemsPerPage="kendo.grid.pagerItemsPerPage|The label for the page size chooser in the Grid pager"
          pagerItemsPerPage="items per page"

          i18n-pagerInputLabel="kendo.grid.pagerInputLabel|The text of the aria-label attribute applied to the input element for entering the page number"
          pagerInputLabel="Type a page number"

          i18n-filter="kendo.grid.filter|The label of the filter cell or icon"
          filter="Filter"

          i18n-filterInputLabel="kendo.grid.filterInputLabel|The label of the filter row and menu inputs"
          filterInputLabel="{{ '{columnName} Filter' }}"

          i18n-filterMenuTitle="kendo.grid.filterMenuTitle|The title of the filter menu icon"
          filterMenuTitle="{{ '{columnName} Filter Menu' }}"

          i18n-filterMenuOperatorsDropDownLabel="kendo.grid.filterMenuOperatorsDropDownLabel|The label of the filter menu operators dropdown"
          filterMenuOperatorsDropDownLabel="{{ '{columnName} Filter Operators' }}"

          i18n-filterCellOperatorLabel="kendo.grid.filterCellOperatorLabel|The label of the filter cell operators dropdown"
          filterCellOperatorLabel="{{ 'Filter cell operators for {columnName}' }}"

          i18n-booleanFilterCellLabel="kendo.grid.booleanFilterCellLabel|The label of the boolean filter cell dropdown"
          booleanFilterCellLabel="{{ 'Boolean filter cell for {columnName}' }}"

          i18n-filterMenuLogicDropDownLabel="kendo.grid.filterMenuLogicDropDownLabel|The label of the filter menu logic dropdown"
          filterMenuLogicDropDownLabel="{{ '{columnName} Filter Logic' }}"

          i18n-filterEqOperator="kendo.grid.filterEqOperator|The text of the equal filter operator"
          filterEqOperator="Is equal to"

          i18n-filterNotEqOperator="kendo.grid.filterNotEqOperator|The text of the not equal filter operator"
          filterNotEqOperator="Is not equal to"

          i18n-filterIsNullOperator="kendo.grid.filterIsNullOperator|The text of the is null filter operator"
          filterIsNullOperator="Is null"

          i18n-filterIsNotNullOperator="kendo.grid.filterIsNotNullOperator|The text of the is not null filter operator"
          filterIsNotNullOperator="Is not null"

          i18n-filterIsEmptyOperator="kendo.grid.filterIsEmptyOperator|The text of the is empty filter operator"
          filterIsEmptyOperator="Is empty"

          i18n-filterIsNotEmptyOperator="kendo.grid.filterIsNotEmptyOperator|The text of the is not empty filter operator"
          filterIsNotEmptyOperator="Is not empty"

          i18n-filterStartsWithOperator="kendo.grid.filterStartsWithOperator|The text of the starts with filter operator"
          filterStartsWithOperator="Starts with"

          i18n-filterContainsOperator="kendo.grid.filterContainsOperator|The text of the contains filter operator"
          filterContainsOperator="Contains"

          i18n-filterNotContainsOperator="kendo.grid.filterNotContainsOperator|The text of the does not contain filter operator"
          filterNotContainsOperator="Does not contain"

          i18n-filterEndsWithOperator="kendo.grid.filterEndsWithOperator|The text of the ends with filter operator"
          filterEndsWithOperator="Ends with"

          i18n-filterGteOperator="kendo.grid.filterGteOperator|The text of the greater than or equal filter operator"
          filterGteOperator="Is greater than or equal to"

          i18n-filterGtOperator="kendo.grid.filterGtOperator|The text of the greater than filter operator"
          filterGtOperator="Is greater than"

          i18n-filterLteOperator="kendo.grid.filterLteOperator|The text of the less than or equal filter operator"
          filterLteOperator="Is less than or equal to"

          i18n-filterLtOperator="kendo.grid.filterLtOperator|The text of the less than filter operator"
          filterLtOperator="Is less than"

          i18n-filterIsTrue="kendo.grid.filterIsTrue|The text of the IsTrue boolean filter option"
          filterIsTrue="Is True"

          i18n-filterIsFalse="kendo.grid.filterIsFalse|The text of the IsFalse boolean filter option"
          filterIsFalse="Is False"

          i18n-filterBooleanAll="kendo.grid.filterBooleanAll|The text of the (All) boolean filter option"
          filterBooleanAll="(All)"

          i18n-filterAfterOrEqualOperator="kendo.grid.filterAfterOrEqualOperator|The text of the after or equal date filter operator"
          filterAfterOrEqualOperator="Is after or equal to"

          i18n-filterAfterOperator="kendo.grid.filterAfterOperator|The text of the after date filter operator"
          filterAfterOperator="Is after"

          i18n-filterBeforeOperator="kendo.grid.filterBeforeOperator|The text of the before date filter operator"
          filterBeforeOperator="Is before"

          i18n-filterBeforeOrEqualOperator="kendo.grid.filterBeforeOrEqualOperator|The text of the before or equal date filter operator"
          filterBeforeOrEqualOperator="Is before or equal to"

          i18n-filterFilterButton="kendo.grid.filterFilterButton|The text of the filter button"
          filterFilterButton="Filter"

          i18n-filterClearButton="kendo.grid.filterClearButton|The text of the clear filter button"
          filterClearButton="Clear"

          i18n-sortClearButton="kendo.grid.sortClearButton|The text of the clear sort button located in the Sort Toolbar Tool and adaptive Sort Toolbar Tool"
          sortClearButton="Clear sorting"

          i18n-adaptiveCloseButtonTitle="kendo.grid.adaptiveCloseButtonTitle|The title of the Close button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode"
          adaptiveCloseButtonTitle="Close"

          i18n-adaptiveBackButtonTitle="kendo.grid.adaptiveBackButtonTitle|The title of the Back button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode"
          adaptiveBackButtonTitle="Back"

          i18n-filterClearAllButton="kendo.grid.filterClearAllButton|The text of the clear all filters button located in the Filter Toolbar Tool and adaptive Filter Toolbar Tool"
          filterClearAllButton="Clear all filters"

          i18n-groupClearButton="kendo.grid.groupClearButton|The text of the clear grouping button in the Group Toolbar Tool and adaptive Group Toolbar Tool"
          groupClearButton="Clear grouping"

          i18n-sortDoneButton="kendo.grid.sortDoneButton|The text of the done sort button"
          sortDoneButton="Done"

          i18n-groupDoneButton="kendo.grid.groupDoneButton|The text of the done group button in the adaptive Group Toolbar Tool"
          groupDoneButton="Done"

          i18n-filterAndLogic="kendo.grid.filterAndLogic|The text of the And filter logic"
          filterAndLogic="And"

          i18n-filterOrLogic="kendo.grid.filterOrLogic|The text of the Or filter logic"
          filterOrLogic="Or"

          i18n-filterToolbarToolText="kendo.grid.filterToolbarToolText|The button text of the Filter toolbar tool"
          filterToolbarToolText="Filter"

          i18n-loading="kendo.grid.loading|The loading text"
          loading="Loading"

          i18n-gridLabel="kendo.grid.gridLabel|The Grid aria-label"
          gridLabel="Data table"

          i18n-columnMenu="kendo.grid.columnMenu|The title of the column menu icon"
          columnMenu="{{ '{columnName} Column Menu' }}"

          i18n-columns="kendo.grid.columns|The text for the Grid Column Chooser and Column Chooser toolbar tool"
          columns="Columns"

          i18n-columnsSubtitle="kendo.grid.columnsSubtitle|The subtitle for the adaptive Grid Column Chooser and Column Chooser toolbar tool"
          columnsSubtitle="Selected fields are visible"

          i18n-adaptiveFilterTitle="kendo.grid.adaptiveFilterTitle|The title that is displayed in the adaptive Filter Toolbar Tool and Filter Menu"
          adaptiveFilterTitle="Filter by"

          i18n-adaptiveFilterOperatorsTitle="kendo.grid.adaptiveFilterOperatorsTitle|The title that is displayed in the Operators Action Sheet"
          adaptiveFilterOperatorsTitle="Operators"

          i18n-adaptiveSortTitle="kendo.grid.adaptiveSortTitle|The title that is displayed in the adaptive Sort Toolbar Tool"
          adaptiveSortTitle="Sort by"

          i18n-adaptiveGroupTitle="kendo.grid.adaptiveGroupTitle|The title that is displayed in the adaptive Group Toolbar Tool."
          adaptiveGroupTitle="Group by"

          i18n-lock="kendo.grid.lock|The text shown in the column menu for the lock item"
          lock="Lock"

          i18n-unlock="kendo.grid.unlock|The text shown in the column menu for the unlock item"
          unlock="Unlock"

          i18n-setColumnPosition="kendo.grid.setColumnPosition|The text shown in the column menu for the set column position item"
          setColumnPosition="Set Column Position"

          i18n-stick="kendo.grid.stick|The text shown in the column menu for the stick item"
          stick="Stick"

          i18n-unstick="kendo.grid.unstick|The text shown in the column menu for the unstick item"
          unstick="Unstick"

          i18n-sortable="kendo.grid.sortable|The label of the sort icon"
          sortable="Sortable"

          i18n-sortAscending="kendo.grid.sortAscending|The text shown in the column menu for the sort ascending item"
          sortAscending="Sort Ascending"

          i18n-sortDescending="kendo.grid.sortDescending|The text shown in the column menu for the sort descending item"
          sortDescending="Sort Descending"

          i18n-autosizeAllColumns="kendo.grid.autosizeAllColumns|The text shown in the column menu for the autosize all columns item"
          autosizeAllColumns="Autosize All Columns"

          i18n-autosizeThisColumn="kendo.grid.autosizeThisColumn|The text shown in the column menu for the autosize this column item"
          autosizeThisColumn="Autosize This Column"

          i18n-sortedDefault="kendo.grid.sortedDefault|The status announcement when a column is no longer sorted"
          sortedDefault="Not Sorted"

          i18n-sortedAscending="kendo.grid.sortedAscending|The title of the Group Chip indicating the ascending sorting order of the groups"
          sortedAscending="Sorted Ascending"

          i18n-sortedDescending="kendo.grid.sortedDescending|The title of the Group Chip indicating the descending sorting order of the groups"
          sortedDescending="Sorted Descending"

          i18n-columnsApply="kendo.grid.columnsApply|The text shown in the column menu or column chooser for the columns apply button"
          columnsApply="Apply"

          i18n-columnsReset="kendo.grid.columnsReset|The text shown in the column menu or column chooser for the columns reset button"
          columnsReset="Reset"

          i18n-detailExpand="kendo.grid.detailExpand|The title of the expand icon of detail rows. Applies also to the expand button text in stacked mode."
          detailExpand="Expand Details"

          i18n-detailCollapse="kendo.grid.detailCollapse|The title of the collapse icon of detail rows. Applies also to the collapse button text in stacked mode."
          detailCollapse="Collapse Details"

          i18n-filterDateToday="kendo.grid.filterDateToday|The text of the Today button of the Date filter."
          filterDateToday="TODAY"

          i18n-filterDateToggle="kendo.grid.filterDateToggle|The title of the Toggle button of the Date filter."
          filterDateToggle="Toggle Calendar"

          i18n-filterNumericDecrement="kendo.grid.filterNumericDecrement|The title of the Decrement button of the Numeric filter."
          filterNumericDecrement="Decrement"

          i18n-filterNumericIncrement="kendo.grid.filterNumericIncrement|The title of the Increment button of the Numeric filter."
          filterNumericIncrement="Increment"

          i18n-selectionCheckboxLabel="kendo.grid.selectionCheckboxLabel|The labels of the checkbox column checkboxes."
          selectionCheckboxLabel="Select Row"

          i18n-selectAllCheckboxLabel="kendo.grid.selectAllCheckboxLabel|The label of the checkbox column select all checkbox."
          selectAllCheckboxLabel="Select All Rows"

          i18n-sortToolbarToolText="kendo.grid.sortToolbarToolText|The button text of the Sort toolbar tool."
          sortToolbarToolText="Sort"

          i18n-groupCollapse="kendo.grid.groupCollapse|The text of the title and aria-label attributes applied to the collapse icon of group rows."
          groupCollapse="Collapse Group"

          i18n-groupExpand="kendo.grid.groupExpand|The text of the title and aria-label attributes applied to the expand icon of group rows."
          groupExpand="Expand Group"

          i18n-pagerSelectPage="kendo.grid.pagerSelectPage|The text of the title and aria-label attributes applied to the page chooser in the Grid Pager"
          pagerSelectPage="Select page"

          i18n-topToolbarLabel="kendo.grid.topToolbarLabel|The label for the Grid top toolbar"
          topToolbarLabel="Top toolbar"

          i18n-bottomToolbarLabel="kendo.grid.bottomToolbarLabel|The label for the Grid bottom toolbar"
          bottomToolbarLabel="Bottom toolbar"

          i18n-editToolbarToolText="kendo.grid.editToolbarToolText|The text for the Grid Edit toolbar tool"
          editToolbarToolText="Edit"

          i18n-saveToolbarToolText="kendo.grid.saveToolbarToolText|The text for the Grid Save toolbar tool"
          saveToolbarToolText="Save"

          i18n-addToolbarToolText="kendo.grid.addToolbarToolText|The text for the Grid Add toolbar tool"
          addToolbarToolText="Add"

          i18n-cancelToolbarToolText="kendo.grid.cancelToolbarToolText|The text for the Grid Cancel toolbar tool"
          cancelToolbarToolText="Cancel"

          i18n-removeToolbarToolText="kendo.grid.removeToolbarToolText|The text for the Grid Remove toolbar tool"
          removeToolbarToolText="Delete"

          i18n-excelExportToolbarToolText="kendo.grid.excelExportToolbarToolText|The text for the Grid Excel export toolbar tool"
          excelExportToolbarToolText="Excel Export"

          i18n-pdfExportToolbarToolText="kendo.grid.pdfExportToolbarToolText|The text for the Grid PDF export toolbar tool"
          pdfExportToolbarToolText="PDF Export"

          i18n-groupPanelLabel="kendo.grid.groupPanelLabel|The label for the Grid group panel toolbar"
          groupPanelLabel="Group panel"

          i18n-dragRowHandleLabel="kendo.grid.dragRowHandleLabel|The label for the Grid drag row handle"
          dragRowHandleLabel="Drag row"

          i18n-columnMenuFilterTabTitle="kendo.grid.columnMenuFilterTabTitle|The title for the column menu Filter tab"
          columnMenuFilterTabTitle="Filter"

          i18n-columnMenuGeneralTabTitle="kendo.grid.columnMenuGeneralTabTitle|The title for the column menu General tab"
          columnMenuGeneralTabTitle="General"

          i18n-columnMenuColumnsTabTitle="kendo.grid.columnMenuColumnsTabTitle|The title for the column menu Columns tab"
          columnMenuColumnsTabTitle="Columns"

          i18n-groupChipMenuPrevious="kendo.grid.groupChipMenuPrevious|The text for the Group pane Chip Menu Move as previous item"
          groupChipMenuPrevious="Move as previous"

          i18n-groupChipMenuNext="kendo.grid.groupChipMenuNext|The text for the Group pane Chip Menu Move as next item"
          groupChipMenuNext="Move as next"

          i18n-groupToolbarToolText="kendo.grid.groupToolbarToolText|The button text of the Group toolbar tool"
          groupToolbarToolText="Group"

          i18n-formValidationErrorText="kendo.grid.formValidationErrorText|The default text of a form validation error when using external editing."
          formValidationErrorText="{{ 'The {fieldName} field has {errorName} validation error' }}"

          i18n-removeConfirmationDialogTitle="kendo.grid.removeConfirmationDialogTitle|The title of the built-in remove item confirmation Dialog"
          removeConfirmationDialogTitle="Please confirm"

          i18n-removeConfirmationDialogContent="kendo.grid.removeConfirmationDialogContent|The content of the built-in remove item confirmation Dialog"
          removeConfirmationDialogContent="Are you sure you want to delete this item?"

          i18n-removeConfirmationDialogConfirmText="kendo.grid.removeConfirmationDialogConfirmText|The text of the built-in remove item confirmation Dialog confirm action button"
          removeConfirmationDialogConfirmText="Yes"

          i18n-removeConfirmationDialogRejectText="kendo.grid.removeConfirmationDialogRejectText|The text of the built-in remove item confirmation Dialog reject action button"
          removeConfirmationDialogRejectText="No"

          i18n-externalEditingTitle="kendo.grid.externalEditingTitle|The title of the built-in external editing form container when editing an item"
          externalEditingTitle="Edit"

          i18n-externalEditingAddTitle="kendo.grid.externalEditingAddTitle|The title of the built-in external editing form container when adding a new item"
          externalEditingAddTitle="Add"

          i18n-externalEditingSaveText="kendo.grid.externalEditingSaveText|The text of the external editing form Save button"
          externalEditingSaveText="Save"

          i18n-externalEditingCancelText="kendo.grid.externalEditingCancelText|The text of the external editing form Cancel button"
          externalEditingCancelText="Cancel"

          i18n-aiAssistantToolbarToolText="kendo.grid.aiAssistantToolbarToolText|The text of the AI Assistant toolbar tool"
          aiAssistantToolbarToolText="AI Assistant"

          i18n-aiAssistantWindowTitle="kendo.grid.aiAssistantWindowTitle|The text of the AI Assistant Window title"
          aiAssistantWindowTitle="AI Assistant"

          i18n-aiAssistantApplyButtonText="kendo.grid.aiAssistantApplyButtonText|The text of the AI Assistant Apply button"
          aiAssistantApplyButtonText="Apply"

          i18n-aiAssistantWindowCloseTitle="kendo.grid.aiAssistantWindowCloseTitle|The title of the AI Assistant Window close button"
          aiAssistantWindowCloseTitle="Close"

          i18n-aiAssistantWindowMaximizeTitle="kendo.grid.aiAssistantWindowMaximizeTitle|The title of the AI Assistant Window maximize button"
          aiAssistantWindowMaximizeTitle="Maximize"

          i18n-aiAssistantWindowMinimizeTitle="kendo.grid.aiAssistantWindowMinimizeTitle|The title of the AI Assistant Window minimize button"
          aiAssistantWindowMinimizeTitle="Minimize"

          i18n-aiAssistantWindowRestoreTitle="kendo.grid.aiAssistantWindowRestoreTitle|The title of the AI Assistant Window restore button"
          aiAssistantWindowRestoreTitle="Restore"

          i18n-aiAssistantOutputCardTitle="kendo.grid.aiAssistantOutputCardTitle|The title of the AI Assistant Prompt Output Card"
          aiAssistantOutputCardTitle="Generated with AI"

          i18n-aiAssistantOutputCardBodyContent="kendo.grid.aiAssistantOutputCardBodyContent|The success message dispayed in the AI Assistant Prompt Output Card's body"
          aiAssistantOutputCardBodyContent="Operation is successful. Data is:"

          i18n-aiAssistantSelectionNotEnabled="kendo.grid.aiAssistantSelectionNotEnabled|The message shown when AI selection requires the Grid selectable option"
          aiAssistantSelectionNotEnabled="Selection can be applied only when the Grid selectable option is enabled."

          i18n-aiAssistantSelectionRowModeRequired="kendo.grid.aiAssistantSelectionRowModeRequired|The message shown when AI selection requires row selection mode"
          aiAssistantSelectionRowModeRequired="Selection can be applied only when row selection mode is enabled."

          i18n-aiAssistantSelectionCellModeRequired="kendo.grid.aiAssistantSelectionCellModeRequired|The message shown when AI selection requires cell selection mode"
          aiAssistantSelectionCellModeRequired="Selection can be applied only when cell selection mode is enabled."

          i18n-columnChooserSelectAll="kendo.grid.columnChooserSelectAll|The text for the Select all checkbox in the Column Chooser"
          columnChooserSelectAll="Select all"

          i18n-columnChooserSelectedColumnsCount="kendo.grid.columnChooserSelectedColumnsCount|The text displayed in the Column Chooser for the number of selected columns"
          columnChooserSelectedColumnsCount="{{ '{selectedColumnsCount} Selected items' }}"

          i18n-multiCheckboxFilterSearchPlaceholder="kendo.grid.multiCheckboxFilterSearchPlaceholder|The placeholder text for the multi-checkbox filter search input"
          multiCheckboxFilterSearchPlaceholder="Search..."

          i18n-multiCheckboxFilterSelectAllLabel="kendo.grid.multiCheckboxFilterSelectAllLabel|The label for the multi-checkbox filter select all option"
          multiCheckboxFilterSelectAllLabel="Select all"

          i18n-multiCheckboxFilterSelectedItemsCount="kendo.grid.multiCheckboxFilterSelectedItemsCount|The text for the multi-checkbox filter selected items count"
          multiCheckboxFilterSelectedItemsCount="{{ '{selectedItemsCount} selected items' }}"
          >
        </ng-container>
        @if (showTopToolbar) {
          <kendo-grid-toolbar
            [size]="size"
            [attr.aria-label]="messageFor('topToolbarLabel')"
            [navigable]="navigation.toolbarEnabled"
            [attr.aria-controls]="ariaRootId"
          position="top"></kendo-grid-toolbar>
        }
        <ng-content select="kendo-toolbar"></ng-content>
        @if (showTopPager) {
          <kendo-pager
            #topPager
            [navigable]="navigation.pagerEnabled"
            class="k-grid-pager k-grid-pager-top"
            [pageSize]="pageSize"
            [total]="view.total"
            [skip]="skip"
            [size]="size"
            [responsive]="normalizedPageableSettings.responsive && !pagerTemplate"
            [buttonCount]="normalizedPageableSettings.buttonCount"
            [info]="normalizedPageableSettings.info"
            [pageSizeValues]="normalizedPageableSettings.pageSizes"
            [previousNext]="normalizedPageableSettings.previousNext"
            [type]="normalizedPageableSettings.type"
            (pageChange)="notifyPageChange('pager', $event)"
            (pagerInputVisibilityChange)="handlePagerVisibilityChange('showPagerInput', $event)"
            (pageTextVisibilityChange)="handlePagerVisibilityChange('showPagerPageText', $event)"
            (itemsTextVisibilityChange)="handlePagerVisibilityChange('showPagerItemsText', $event)">
            <ng-template kendoPagerTemplate>
              <ng-container
                [ngTemplateOutlet]="pagerTemplate ? pagerTemplate?.templateRef : defaultPager"
              [ngTemplateOutletContext]="topPager.templateContext"></ng-container>
            </ng-template>
            <kendo-pager-messages
              [ariaLabel]="messageFor('pagerLabel')"
              [firstPage]="messageFor('pagerFirstPage')"
              [inputLabel]="messageFor('pagerInputLabel')"
              [previousPage]="messageFor('pagerPreviousPage')"
              [nextPage]="messageFor('pagerNextPage')"
              [lastPage]="messageFor('pagerLastPage')"
              [selectPage]="messageFor('pagerSelectPage')"
              [page]="messageFor('pagerPage')"
              [itemsPerPage]="messageFor('pagerItemsPerPage')"
              [items]="messageFor('pagerItems')"
              [of]="messageFor('pagerOf')"
              [pageNumberInputTitle]="messageFor('pagerPageNumberInputTitle')">
            </kendo-pager-messages>
          </kendo-pager>
        }
        @if (showGroupPanel) {
          <kendo-grid-group-panel
            [navigable]="navigation.toolbarEnabled"
            [text]="groupableEmptyText"
            [groups]="group"
            role="toolbar"
            [attr.aria-label]="messageFor('groupPanelLabel')"
            [attr.aria-controls]="ariaRootId"
            (change)="groupChange.emit($event)">
          </kendo-grid-group-panel>
        }
        <div #ariaRoot
          class="k-grid-aria-root"
          role="grid"
          kendoDragTargetContainer
          kendoDropTargetContainer
          mode="manual"
          [dragDisabled]="!rowReorderable"
          [dropDisabled]="!rowReorderable"
          [dragTargetFilter]="getDefaultSelectors('dragTarget')"
          [dropTargetFilter]="getDefaultSelectors('dropTarget')"
          [dragHandle]="getDefaultSelectors('handle')"
          [hint]="{hintTemplate: customHintTemplate || defaultHint}"
          [hintContext]="hintContext"
          (onPress)="handleReorderEvents($event, 'press')"
          (onDragStart)="handleReorderEvents($event, 'dragStart')"
          (onDrag)="handleReorderEvents($event, 'drag')"
          (onDragEnter)="handleReorderEvents($event, 'dragEnter')"
          (onDragLeave)="handleReorderEvents($event, 'dragLeave')"
          (onDragEnd)="handleReorderEvents($event, 'dragEnd')"
          (onDrop)="handleReorderEvents($event, 'drop')"
          [dragData]="gridData"
          [id]="ariaRootId"
          [attr.aria-label]="ariaLabel"
          [attr.aria-rowcount]="ariaRowCount"
          [attr.aria-colcount]="ariaColCount">
          @if (isScrollable) {
            @if (!hideHeader && !isStacked) {
              <div
                class="k-grid-header"
                [class.k-grid-draggable-header]="groupable || reorderable"
                role="presentation"
                [style.padding]="headerPadding">
                @if (isLocked) {
                  <div
                    #lockedHeader
                    role="presentation"
                    class="k-grid-header-locked"
                    [style.width.px]="lockedWidth">
                    <table
                      kendoGridResizableTable
                      [locked]="true"
                      role="presentation"
                      class="k-grid-header-table"
                      [style.width.px]="lockedWidth"
                      kendoGridTable
                      [size]="size">
                      <colgroup kendoGridColGroup
                        [columns]="$any(lockedLeafColumns)"
                        [groups]="group"
                        [detailTemplate]="detailTemplate">
                    </colgroup>
                    <thead kendoGridHeader
                      role="rowgroup"
                      [resizable]="resizable"
                      [scrollable]="true"
                      [columns]="$any(lockedColumns)"
                      [totalColumnLevels]="totalColumnLevels"
                      [sort]="sort"
                      [groups]="group"
                      [filter]="filter"
                      [filterable]="filterable"
                      [groupable]="showGroupPanel"
                      [reorderable]="reorderable"
                      [sortable]="sortable"
                      [columnMenu]="columnMenuOptions"
                      [columnMenuTemplate]="columnMenuTemplate"
                      [totalColumnsCount]="leafColumns.length"
                      [totalColumns]="columnsContainer"
                      [detailTemplate]="detailTemplate"
                      [tabIndex]="navigation.tableEnabled ? '-1' : '0'">
                    </thead>
                  </table>
                </div>
              }
              <div #header class="k-grid-header-wrap" role="presentation" data-scrollable
                [kendoGridResizableContainer]="lockedLeafColumns.length > 0"
                [lockedWidth]="lockedWidth + scrollbarWidth + 2">
                <table
                  role="presentation"
                  class="k-grid-header-table"
                  [style.width.px]="nonLockedWidth"
                  kendoGridResizableTable
                  [virtualColumns]="virtualColumns"
                  kendoGridTable
                  [size]="size">
                  <colgroup kendoGridColGroup
                    [columns]="headerLeafColumns"
                    [groups]="isLocked ? [] : group"
                    [detailTemplate]="detailTemplate">
                </colgroup>
                <thead kendoGridHeader
                  [resizable]="resizable"
                  role="rowgroup"
                  [scrollable]="true"
                  [columns]="headerColumns"
                  [totalColumnLevels]="totalColumnLevels"
                  [sort]="sort"
                  [filter]="filter"
                  [filterable]="filterable"
                  [groupable]="showGroupPanel"
                  [reorderable]="reorderable"
                  [groups]="isLocked ? [] : group"
                  [sortable]="sortable"
                  [columnMenu]="columnMenuOptions"
                  [columnMenuTemplate]="columnMenuTemplate"
                  [lockedColumnsCount]="lockedLeafColumns.length"
                  [totalColumnsCount]="leafColumns.length"
                  [totalColumns]="columnsContainer"
                  [detailTemplate]="detailTemplate"
                  [tabIndex]="navigation.tableEnabled ? '-1' : '0'">
                </thead>
              </table>
              @if (virtualColumns) {
                <div class="k-width-container" role="presentation">
                  <div [style.width.px]="columnsContainer.unlockedWidth"></div>
                </div>
              }
            </div>
          </div>
        }
        <kendo-grid-list
          [data]="$any(view)"
          [rowHeight]="rowHeight"
          [detailRowHeight]="detailRowHeight"
          [total]="totalCount"
          [take]="pageSize"
          [groups]="group"
          [groupable]="groupable"
          [skip]="skip"
          [trackBy]="trackBy"
          [columns]="columnsContainer"
          [selectable]="selectable"
          [filterable]="filterable"
          [detailTemplate]="detailTemplate"
          [noRecordsTemplate]="noRecordsTemplate"
          [size]="size"
          (pageChange)="notifyPageChange('list', $event)"
          [rowClass]="rowClass"
          [rowSticky]="rowSticky"
          [loading]="loading"
          [isVirtual]="isVirtual"
          [cellLoadingTemplate]="cellLoadingTemplate?.templateRef"
          [loadingTemplate]="loadingTemplate?.templateRef"
          [virtualColumns]="virtualColumns"
          (scrollBottom)="notifyScrollBottom()"
          (contentScroll)="contentScroll.emit($event)"
          kendoDraggable
          kendoGridSelectionMarquee
          [enableDrag]="marqueeSelection"
          [sort]="sort">
        </kendo-grid-list>
        @if (showFooter) {
          <div
            class="k-grid-footer"
            [style.padding]="headerPadding">
            @if (lockedLeafColumns.length && !isStacked) {
              <div
                class="k-grid-footer-locked"
                [style.width.px]="lockedWidth">
                <table
                  role="presentation"
                  class="k-grid-footer-table"
                  kendoGridResizableTable
                  [locked]="true"
                  [style.width.px]="lockedWidth"
                  kendoGridTable
                  [size]="size">
                  @if (!isStacked) {
                    <colgroup kendoGridColGroup
                      [columns]="$any(lockedLeafColumns)"
                      [groups]="group"
                      [detailTemplate]="detailTemplate">
                  </colgroup>
                }
                <tfoot kendoGridFooter
                  [scrollable]="true"
                  [groups]="group"
                  [columns]="$any(lockedLeafColumns)"
                  [detailTemplate]="detailTemplate"
                  [logicalRowIndex]="ariaRowCount"
                  [totalColumns]="columnsContainer"
                  [totalColumnsCount]="leafColumns.length">
                </tfoot>
              </table>
            </div>
          }
          <div #footer
            class="k-grid-footer-wrap" data-scrollable
            [kendoGridResizableContainer]="lockedLeafColumns.length > 0 && !isStacked"
            [lockedWidth]="lockedWidth + scrollbarWidth + 3">
            <table
              role="presentation"
              class="k-grid-footer-table"
              [style.width.px]="nonLockedWidth"
              kendoGridTable
              kendoGridResizableTable
              [size]="size">
              @if (!isStacked) {
                <colgroup kendoGridColGroup
                  [columns]="$any(headerLeafColumns)"
                  [groups]="isLocked ? [] : group"
                  [detailTemplate]="detailTemplate">
              </colgroup>
            }
            <tfoot kendoGridFooter
              [logicalRowIndex]="ariaRowCount"
              [scrollable]="true"
              [groups]="isLocked ? [] : group"
              [columns]="$any(headerColumns)"
              [lockedColumnsCount]="isStacked ? 0 : lockedLeafColumns.length"
              [detailTemplate]="detailTemplate"
              [totalColumns]="columnsContainer"
              [totalColumnsCount]="leafColumns.length">
            </tfoot>
          </table>
        </div>
        </div>
        }
        }
        @if (!isScrollable) {
          <table
            [style.table-layout]="resizable ? 'fixed' : null"
            kendoGridTable
            kendoGridResizableTable
            class="k-grid-table"
            role="presentation"
            [size]="size">
            <colgroup kendoGridColGroup
              [columns]="$any(leafColumns)"
              [groups]="group"
              [sort]="sort"
              [detailTemplate]="detailTemplate">
          </colgroup>
          @if (!hideHeader && !isStacked) {
            <thead kendoGridHeader
              class="k-grid-header"
              [class.k-grid-draggable-header]="groupable || reorderable"
              role="rowgroup"
              [resizable]="resizable"
              [scrollable]="false"
              [columns]="$any(visibleColumns)"
              [totalColumnLevels]="totalColumnLevels"
              [totalColumns]="columnsContainer"
              [groups]="group"
              [groupable]="showGroupPanel"
              [reorderable]="reorderable"
              [sort]="sort"
              [sortable]="sortable"
              [filter]="filter"
              [filterable]="filterable"
              [columnMenu]="columnMenuOptions"
              [columnMenuTemplate]="columnMenuTemplate"
              [detailTemplate]="detailTemplate"
              [tabIndex]="navigation.tableEnabled ? '-1' : '0'">
            </thead>
          }
          <tbody kendoGridTableBody
            [isLoading]="loading"
            [rowHeight]="rowHeight"
            [detailRowHeight]="detailRowHeight"
            [groups]="group"
            [rowsToRender]="rowsToRender"
            [skip]="skip"
            [columns]="$any(leafColumns)"
            [totalColumnsCount]="leafColumns.length"
            [totalColumns]="columnsContainer"
            [selectable]="selectable"
            [filterable]="filterable"
            [noRecordsTemplate]="noRecordsTemplate"
            [detailTemplate]="detailTemplate"
            [trackBy]="trackBy"
            [rowClass]="rowClass"
            kendoDraggable
            kendoGridSelectionMarquee
            [enableDrag]="marqueeSelection">
          </tbody>
          @if (showFooter) {
            <tfoot kendoGridFooter
              [scrollable]="false"
              [logicalRowIndex]="ariaRowCount"
              [groups]="group"
              [columns]="$any(leafColumns)"
              [detailTemplate]="detailTemplate"
              [totalColumns]="columnsContainer"
              [totalColumnsCount]="leafColumns.length">
            </tfoot>
          }
        </table>
        }
        @if (loading) {
          <div [loadingTemplate]="loadingTemplate" kendoGridLoading></div>
        }
        </div>
        @if (showStatusBar) {
          <kendo-grid-status-bar
            [statusBarTemplate]="statusBarTemplate">
          </kendo-grid-status-bar>
        }
        @if (showBottomPager) {
          <kendo-pager
            #bottomPager
            class="k-grid-pager"
            [navigable]="navigation.pagerEnabled"
            [pageSize]="pageSize"
            [total]="view.total"
            [skip]="skip"
            [size]="size"
            [responsive]="normalizedPageableSettings.responsive && !pagerTemplate"
            [buttonCount]="normalizedPageableSettings.buttonCount"
            [info]="normalizedPageableSettings.info"
            [pageSizeValues]="normalizedPageableSettings.pageSizes"
            [previousNext]="normalizedPageableSettings.previousNext"
            [type]="normalizedPageableSettings.type"
            (pageChange)="notifyPageChange('pager', $event)"
            (pagerInputVisibilityChange)="handlePagerVisibilityChange('showPagerInput', $event)"
            (pageTextVisibilityChange)="handlePagerVisibilityChange('showPagerPageText', $event)"
            (itemsTextVisibilityChange)="handlePagerVisibilityChange('showPagerItemsText', $event)">
            <ng-template kendoPagerTemplate>
              <ng-container
                [ngTemplateOutlet]="pagerTemplate ? pagerTemplate?.templateRef : defaultPager"
              [ngTemplateOutletContext]="bottomPager.templateContext"></ng-container>
            </ng-template>
            <kendo-pager-messages
              [ariaLabel]="messageFor('pagerLabel')"
              [firstPage]="messageFor('pagerFirstPage')"
              [inputLabel]="messageFor('pagerInputLabel')"
              [previousPage]="messageFor('pagerPreviousPage')"
              [nextPage]="messageFor('pagerNextPage')"
              [lastPage]="messageFor('pagerLastPage')"
              [selectPage]="messageFor('pagerSelectPage')"
              [page]="messageFor('pagerPage')"
              [itemsPerPage]="messageFor('pagerItemsPerPage')"
              [items]="messageFor('pagerItems')"
              [of]="messageFor('pagerOf')"
              [pageNumberInputTitle]="messageFor('pagerPageNumberInputTitle')">
            </kendo-pager-messages>
          </kendo-pager>
        }
        @if (showBottomToolbar) {
          <kendo-grid-toolbar
            class="k-grid-toolbar-bottom"
            [size]="size"
            [navigable]="navigation.toolbarEnabled"
            [attr.aria-label]="messageFor('bottomToolbarLabel')"
            [attr.aria-controls]="ariaRootId"
            position="bottom">
          </kendo-grid-toolbar>
        }

        <ng-template #defaultHint>
          <kendo-icon-wrapper
            [name]="getHintSettings('hintIcon')"
            [svgIcon]="getHintSettings('hintSVGIcon')"
            innerCssClass="k-drag-status">
          </kendo-icon-wrapper>
          {{hintText}}
        </ng-template>

        <ng-template #defaultPager>
          <div class="k-pager-numbers-wrap">
            @if (normalizedPageableSettings.previousNext) {
              <kendo-pager-prev-buttons [size]="size"></kendo-pager-prev-buttons>
            }
            @if (normalizedPageableSettings.type === 'numeric' && normalizedPageableSettings.buttonCount > 0) {
              <kendo-pager-numeric-buttons
                [size]="size"
                [buttonCount]="normalizedPageableSettings.buttonCount">
              </kendo-pager-numeric-buttons>
            }
            @if (normalizedPageableSettings.type === 'input' || showPagerInput) {
              <kendo-pager-input [size]="size" [showPageText]="showPagerPageText"></kendo-pager-input>
            }
            @if (normalizedPageableSettings.previousNext) {
              <kendo-pager-next-buttons [size]="size"></kendo-pager-next-buttons>
            }
          </div>
          @if (normalizedPageableSettings.pageSizes) {
            <kendo-pager-page-sizes
              [size]="size"
              [pageSizes]="normalizedPageableSettings.pageSizes"
              [showItemsText]="showPagerItemsText">
            </kendo-pager-page-sizes>
          }
          @if (normalizedPageableSettings.info) {
            <kendo-pager-info>
            </kendo-pager-info>
          }
        </ng-template>
        <div #dialogContainer></div>
        <div #windowContainer></div>

        @if (isAdaptiveModeEnabled) {
          <kendo-grid-adaptive-renderer></kendo-grid-adaptive-renderer>
        }
        @if (isVirtual) {
          <kendo-resize-sensor (resize)="onResize()"></kendo-resize-sensor>
        }

        @if (showLicenseWatermark) {
          <div kendoWatermarkOverlay [licenseMessage]="licenseMessage"></div>
        }
        `, isInline: true, dependencies: [{ kind: "directive", type: LocalizedMessagesDirective, selector: "[kendoGridLocalizedMessages]" }, { kind: "component", type: ToolbarComponent, selector: "kendo-grid-toolbar", inputs: ["position", "size", "navigable"] }, { kind: "component", type: GroupPanelComponent, selector: "kendo-grid-group-panel", inputs: ["text", "navigable", "groups"], outputs: ["change"] }, { kind: "directive", type: TableDirective, selector: "[kendoGridResizableTable]", inputs: ["locked", "virtualColumns"] }, { kind: "directive", type: GridTableDirective, selector: "[kendoGridTable]", inputs: ["size"] }, { kind: "component", type: ColGroupComponent, selector: "[kendoGridColGroup]", inputs: ["columns", "groups", "detailTemplate", "sort"] }, { kind: "component", type: HeaderComponent, selector: "[kendoGridHeader]", inputs: ["totalColumnLevels", "columns", "groups", "detailTemplate", "scrollable", "filterable", "sort", "filter", "sortable", "groupable", "lockedColumnsCount", "resizable", "reorderable", "columnMenu", "columnMenuTemplate", "totalColumnsCount", "totalColumns", "tabIndex", "size"] }, { kind: "directive", type: ResizableContainerDirective, selector: "[kendoGridResizableContainer]", inputs: ["lockedWidth", "kendoGridResizableContainer"] }, { kind: "component", type: ListComponent, selector: "kendo-grid-list", inputs: ["data", "groups", "total", "rowHeight", "detailRowHeight", "take", "skip", "columns", "detailTemplate", "noRecordsTemplate", "selectable", "groupable", "filterable", "rowClass", "rowSticky", "loading", "trackBy", "virtualColumns", "isVirtual", "cellLoadingTemplate", "loadingTemplate", "sort", "size"], outputs: ["contentScroll", "pageChange", "scrollBottom"] }, { kind: "directive", type: DragTargetContainerDirective, selector: "[kendoDragTargetContainer]", inputs: ["hint", "dragTargetFilter", "dragHandle", "dragDelay", "threshold", "dragTargetId", "dragData", "dragDisabled", "mode", "cursorStyle", "hintContext"], outputs: ["onDragReady", "onPress", "onDragStart", "onDrag", "onRelease", "onDragEnd"], exportAs: ["kendoDragTargetContainer"] }, { kind: "directive", type: DropTargetContainerDirective, selector: "[kendoDropTargetContainer]", inputs: ["dropTargetFilter", "dropDisabled"], outputs: ["onDragEnter", "onDragOver", "onDragLeave", "onDrop"], exportAs: ["kendoDropTargetContainer"] }, { kind: "directive", type: DraggableDirective, selector: "[kendoDraggable]", inputs: ["enableDrag"], outputs: ["kendoPress", "kendoDrag", "kendoRelease"] }, { kind: "directive", type: GridMarqueeDirective, selector: "[kendoGridSelectionMarquee]" }, { kind: "component", type: FooterComponent, selector: "[kendoGridFooter]", inputs: ["columns", "groups", "detailTemplate", "scrollable", "lockedColumnsCount", "logicalRowIndex", "totalColumns", "totalColumnsCount"] }, { kind: "component", type: TableBodyComponent, selector: "[kendoGridTableBody]", inputs: ["columns", "allColumns", "groups", "detailTemplate", "noRecordsTemplate", "rowsToRender", "skip", "selectable", "filterable", "noRecordsText", "isLocked", "isLoading", "isVirtual", "cellLoadingTemplate", "skipGroupDecoration", "lockedColumnsCount", "totalColumnsCount", "virtualColumns", "trackBy", "rowSticky", "totalColumns", "rowClass", "rowHeight", "detailRowHeight"] }, { kind: "component", type: LoadingComponent, selector: "[kendoGridLoading]", inputs: ["loadingTemplate"] }, { kind: "component", type: StatusBarComponent, selector: "kendo-grid-status-bar", inputs: ["statusBarTemplate"] }, { kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "component", type: WatermarkOverlayComponent, selector: "div[kendoWatermarkOverlay]", inputs: ["licenseMessage"] }, { kind: "component", type: i53.CustomMessagesComponent, selector: "kendo-datapager-messages, kendo-pager-messages" }, { kind: "component", type: i53.PagerInfoComponent, selector: "kendo-datapager-info, kendo-pager-info" }, { kind: "component", type: i53.PagerInputComponent, selector: "kendo-datapager-input, kendo-pager-input", inputs: ["showPageText", "size"] }, { kind: "component", type: i53.PagerNextButtonsComponent, selector: "kendo-datapager-next-buttons, kendo-pager-next-buttons", inputs: ["size"] }, { kind: "component", type: i53.PagerNumericButtonsComponent, selector: "kendo-datapager-numeric-buttons, kendo-pager-numeric-buttons", inputs: ["buttonCount", "size"] }, { kind: "component", type: i53.PagerPageSizesComponent, selector: "kendo-datapager-page-sizes, kendo-pager-page-sizes", inputs: ["showItemsText", "pageSizes", "size", "adaptiveMode"] }, { kind: "component", type: i53.PagerPrevButtonsComponent, selector: "kendo-datapager-prev-buttons, kendo-pager-prev-buttons", inputs: ["size"] }, { kind: "directive", type: i53.PagerTemplateDirective, selector: "[kendoDataPagerTemplate], [kendoPagerTemplate]" }, { kind: "component", type: i53.PagerComponent, selector: "kendo-datapager, kendo-pager", inputs: ["externalTemplate", "total", "skip", "pageSize", "buttonCount", "info", "type", "pageSizeValues", "previousNext", "navigable", "size", "responsive", "adaptiveMode"], outputs: ["pageChange", "pageSizeChange", "pagerInputVisibilityChange", "pageTextVisibilityChange", "itemsTextVisibilityChange"], exportAs: ["kendoDataPager", "kendoPager"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: AdaptiveRendererComponent, selector: "kendo-grid-adaptive-renderer" }, { kind: "component", type: ResizeSensorComponent, selector: "kendo-resize-sensor", inputs: ["rateLimit"], outputs: ["resize"] }], encapsulation: i0.ViewEncapsulation.None });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GridComponent, decorators: [{
            type: Component,
            args: [{
                    encapsulation: ViewEncapsulation.None,
                    exportAs: 'kendoGrid',
                    providers: [
                        BrowserSupportService,
                        LocalizationService,
                        ColumnInfoService,
                        SelectionService,
                        CellSelectionService,
                        DetailsService,
                        GroupsService,
                        GroupInfoService,
                        ChangeNotificationService,
                        EditService,
                        PDFService,
                        SuspendService,
                        {
                            provide: CELL_CONTEXT,
                            useValue: EMPTY_CELL_CONTEXT
                        },
                        {
                            provide: L10N_PREFIX,
                            useValue: 'kendo.grid'
                        },
                        FilterService,
                        ResponsiveService,
                        PagerContextService,
                        PagerNavigationService,
                        ExcelService,
                        ScrollSyncService,
                        ResizeService,
                        LocalDataChangesService,
                        DomEventsService,
                        ColumnResizingService,
                        SinglePopupService,
                        DragAndDropService,
                        DragHintService,
                        DropCueService,
                        ColumnReorderService,
                        NavigationService,
                        FocusRoot,
                        IdService,
                        CellSelectionAggregateService,
                        ScrollRequestService,
                        SortService,
                        ContextService,
                        SizingOptionsService,
                        RowReorderService,
                        ClipboardService,
                        GridAIRequestResponseService,
                        RowspanService,
                        AdaptiveGridService,
                        ColumnMenuService,
                        MenuTabbingService,
                        DataMappingService
                    ],
                    selector: 'kendo-grid',
                    template: `
        <ng-container kendoGridLocalizedMessages
          i18n-groupPanelEmpty="kendo.grid.groupPanelEmpty|The label visible in the Grid group panel when it is empty"
          groupPanelEmpty="Drag a column header and drop it here to group by that column"

          i18n-noRecords="kendo.grid.noRecords|The label visible in the Grid when there are no records"
          noRecords="No records available."

          i18n-pagerLabel="kendo.grid.pagerLabel|The label for the Grid pager"
          pagerLabel="{{ 'Page navigation, page {currentPage} of {totalPages}' }}"

          i18n-pagerFirstPage="kendo.grid.pagerFirstPage|The label for the first page button in Grid pager"
          pagerFirstPage="Go to the first page"

          i18n-pagerPreviousPage="kendo.grid.pagerPreviousPage|The label for the previous page button in Grid pager"
          pagerPreviousPage="Go to the previous page"

          i18n-pagerNextPage="kendo.grid.pagerNextPage|The label for the next page button in Grid pager"
          pagerNextPage="Go to the next page"

          i18n-pagerLastPage="kendo.grid.pagerLastPage|The label for the last page button in Grid pager"
          pagerLastPage="Go to the last page"

          i18n-pagerPage="kendo.grid.pagerPage|The label before the current page number in the Grid pager"
          pagerPage="Page"

          i18n-pagerOf="kendo.grid.pagerOf|The label before the total pages number in the Grid pager"
          pagerOf="of"

          i18n-pagerItems="kendo.grid.pagerItems|The label after the total pages number in the Grid pager"
          pagerItems="items"

          i18n-pagerPageNumberInputTitle="kendo.grid.pagerPageNumberInputTitle|The label for the pager input in the Grid pager"
          pagerPageNumberInputTitle="Page Number"

          i18n-pagerItemsPerPage="kendo.grid.pagerItemsPerPage|The label for the page size chooser in the Grid pager"
          pagerItemsPerPage="items per page"

          i18n-pagerInputLabel="kendo.grid.pagerInputLabel|The text of the aria-label attribute applied to the input element for entering the page number"
          pagerInputLabel="Type a page number"

          i18n-filter="kendo.grid.filter|The label of the filter cell or icon"
          filter="Filter"

          i18n-filterInputLabel="kendo.grid.filterInputLabel|The label of the filter row and menu inputs"
          filterInputLabel="{{ '{columnName} Filter' }}"

          i18n-filterMenuTitle="kendo.grid.filterMenuTitle|The title of the filter menu icon"
          filterMenuTitle="{{ '{columnName} Filter Menu' }}"

          i18n-filterMenuOperatorsDropDownLabel="kendo.grid.filterMenuOperatorsDropDownLabel|The label of the filter menu operators dropdown"
          filterMenuOperatorsDropDownLabel="{{ '{columnName} Filter Operators' }}"

          i18n-filterCellOperatorLabel="kendo.grid.filterCellOperatorLabel|The label of the filter cell operators dropdown"
          filterCellOperatorLabel="{{ 'Filter cell operators for {columnName}' }}"

          i18n-booleanFilterCellLabel="kendo.grid.booleanFilterCellLabel|The label of the boolean filter cell dropdown"
          booleanFilterCellLabel="{{ 'Boolean filter cell for {columnName}' }}"

          i18n-filterMenuLogicDropDownLabel="kendo.grid.filterMenuLogicDropDownLabel|The label of the filter menu logic dropdown"
          filterMenuLogicDropDownLabel="{{ '{columnName} Filter Logic' }}"

          i18n-filterEqOperator="kendo.grid.filterEqOperator|The text of the equal filter operator"
          filterEqOperator="Is equal to"

          i18n-filterNotEqOperator="kendo.grid.filterNotEqOperator|The text of the not equal filter operator"
          filterNotEqOperator="Is not equal to"

          i18n-filterIsNullOperator="kendo.grid.filterIsNullOperator|The text of the is null filter operator"
          filterIsNullOperator="Is null"

          i18n-filterIsNotNullOperator="kendo.grid.filterIsNotNullOperator|The text of the is not null filter operator"
          filterIsNotNullOperator="Is not null"

          i18n-filterIsEmptyOperator="kendo.grid.filterIsEmptyOperator|The text of the is empty filter operator"
          filterIsEmptyOperator="Is empty"

          i18n-filterIsNotEmptyOperator="kendo.grid.filterIsNotEmptyOperator|The text of the is not empty filter operator"
          filterIsNotEmptyOperator="Is not empty"

          i18n-filterStartsWithOperator="kendo.grid.filterStartsWithOperator|The text of the starts with filter operator"
          filterStartsWithOperator="Starts with"

          i18n-filterContainsOperator="kendo.grid.filterContainsOperator|The text of the contains filter operator"
          filterContainsOperator="Contains"

          i18n-filterNotContainsOperator="kendo.grid.filterNotContainsOperator|The text of the does not contain filter operator"
          filterNotContainsOperator="Does not contain"

          i18n-filterEndsWithOperator="kendo.grid.filterEndsWithOperator|The text of the ends with filter operator"
          filterEndsWithOperator="Ends with"

          i18n-filterGteOperator="kendo.grid.filterGteOperator|The text of the greater than or equal filter operator"
          filterGteOperator="Is greater than or equal to"

          i18n-filterGtOperator="kendo.grid.filterGtOperator|The text of the greater than filter operator"
          filterGtOperator="Is greater than"

          i18n-filterLteOperator="kendo.grid.filterLteOperator|The text of the less than or equal filter operator"
          filterLteOperator="Is less than or equal to"

          i18n-filterLtOperator="kendo.grid.filterLtOperator|The text of the less than filter operator"
          filterLtOperator="Is less than"

          i18n-filterIsTrue="kendo.grid.filterIsTrue|The text of the IsTrue boolean filter option"
          filterIsTrue="Is True"

          i18n-filterIsFalse="kendo.grid.filterIsFalse|The text of the IsFalse boolean filter option"
          filterIsFalse="Is False"

          i18n-filterBooleanAll="kendo.grid.filterBooleanAll|The text of the (All) boolean filter option"
          filterBooleanAll="(All)"

          i18n-filterAfterOrEqualOperator="kendo.grid.filterAfterOrEqualOperator|The text of the after or equal date filter operator"
          filterAfterOrEqualOperator="Is after or equal to"

          i18n-filterAfterOperator="kendo.grid.filterAfterOperator|The text of the after date filter operator"
          filterAfterOperator="Is after"

          i18n-filterBeforeOperator="kendo.grid.filterBeforeOperator|The text of the before date filter operator"
          filterBeforeOperator="Is before"

          i18n-filterBeforeOrEqualOperator="kendo.grid.filterBeforeOrEqualOperator|The text of the before or equal date filter operator"
          filterBeforeOrEqualOperator="Is before or equal to"

          i18n-filterFilterButton="kendo.grid.filterFilterButton|The text of the filter button"
          filterFilterButton="Filter"

          i18n-filterClearButton="kendo.grid.filterClearButton|The text of the clear filter button"
          filterClearButton="Clear"

          i18n-sortClearButton="kendo.grid.sortClearButton|The text of the clear sort button located in the Sort Toolbar Tool and adaptive Sort Toolbar Tool"
          sortClearButton="Clear sorting"

          i18n-adaptiveCloseButtonTitle="kendo.grid.adaptiveCloseButtonTitle|The title of the Close button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode"
          adaptiveCloseButtonTitle="Close"

          i18n-adaptiveBackButtonTitle="kendo.grid.adaptiveBackButtonTitle|The title of the Back button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode"
          adaptiveBackButtonTitle="Back"

          i18n-filterClearAllButton="kendo.grid.filterClearAllButton|The text of the clear all filters button located in the Filter Toolbar Tool and adaptive Filter Toolbar Tool"
          filterClearAllButton="Clear all filters"

          i18n-groupClearButton="kendo.grid.groupClearButton|The text of the clear grouping button in the Group Toolbar Tool and adaptive Group Toolbar Tool"
          groupClearButton="Clear grouping"

          i18n-sortDoneButton="kendo.grid.sortDoneButton|The text of the done sort button"
          sortDoneButton="Done"

          i18n-groupDoneButton="kendo.grid.groupDoneButton|The text of the done group button in the adaptive Group Toolbar Tool"
          groupDoneButton="Done"

          i18n-filterAndLogic="kendo.grid.filterAndLogic|The text of the And filter logic"
          filterAndLogic="And"

          i18n-filterOrLogic="kendo.grid.filterOrLogic|The text of the Or filter logic"
          filterOrLogic="Or"

          i18n-filterToolbarToolText="kendo.grid.filterToolbarToolText|The button text of the Filter toolbar tool"
          filterToolbarToolText="Filter"

          i18n-loading="kendo.grid.loading|The loading text"
          loading="Loading"

          i18n-gridLabel="kendo.grid.gridLabel|The Grid aria-label"
          gridLabel="Data table"

          i18n-columnMenu="kendo.grid.columnMenu|The title of the column menu icon"
          columnMenu="{{ '{columnName} Column Menu' }}"

          i18n-columns="kendo.grid.columns|The text for the Grid Column Chooser and Column Chooser toolbar tool"
          columns="Columns"

          i18n-columnsSubtitle="kendo.grid.columnsSubtitle|The subtitle for the adaptive Grid Column Chooser and Column Chooser toolbar tool"
          columnsSubtitle="Selected fields are visible"

          i18n-adaptiveFilterTitle="kendo.grid.adaptiveFilterTitle|The title that is displayed in the adaptive Filter Toolbar Tool and Filter Menu"
          adaptiveFilterTitle="Filter by"

          i18n-adaptiveFilterOperatorsTitle="kendo.grid.adaptiveFilterOperatorsTitle|The title that is displayed in the Operators Action Sheet"
          adaptiveFilterOperatorsTitle="Operators"

          i18n-adaptiveSortTitle="kendo.grid.adaptiveSortTitle|The title that is displayed in the adaptive Sort Toolbar Tool"
          adaptiveSortTitle="Sort by"

          i18n-adaptiveGroupTitle="kendo.grid.adaptiveGroupTitle|The title that is displayed in the adaptive Group Toolbar Tool."
          adaptiveGroupTitle="Group by"

          i18n-lock="kendo.grid.lock|The text shown in the column menu for the lock item"
          lock="Lock"

          i18n-unlock="kendo.grid.unlock|The text shown in the column menu for the unlock item"
          unlock="Unlock"

          i18n-setColumnPosition="kendo.grid.setColumnPosition|The text shown in the column menu for the set column position item"
          setColumnPosition="Set Column Position"

          i18n-stick="kendo.grid.stick|The text shown in the column menu for the stick item"
          stick="Stick"

          i18n-unstick="kendo.grid.unstick|The text shown in the column menu for the unstick item"
          unstick="Unstick"

          i18n-sortable="kendo.grid.sortable|The label of the sort icon"
          sortable="Sortable"

          i18n-sortAscending="kendo.grid.sortAscending|The text shown in the column menu for the sort ascending item"
          sortAscending="Sort Ascending"

          i18n-sortDescending="kendo.grid.sortDescending|The text shown in the column menu for the sort descending item"
          sortDescending="Sort Descending"

          i18n-autosizeAllColumns="kendo.grid.autosizeAllColumns|The text shown in the column menu for the autosize all columns item"
          autosizeAllColumns="Autosize All Columns"

          i18n-autosizeThisColumn="kendo.grid.autosizeThisColumn|The text shown in the column menu for the autosize this column item"
          autosizeThisColumn="Autosize This Column"

          i18n-sortedDefault="kendo.grid.sortedDefault|The status announcement when a column is no longer sorted"
          sortedDefault="Not Sorted"

          i18n-sortedAscending="kendo.grid.sortedAscending|The title of the Group Chip indicating the ascending sorting order of the groups"
          sortedAscending="Sorted Ascending"

          i18n-sortedDescending="kendo.grid.sortedDescending|The title of the Group Chip indicating the descending sorting order of the groups"
          sortedDescending="Sorted Descending"

          i18n-columnsApply="kendo.grid.columnsApply|The text shown in the column menu or column chooser for the columns apply button"
          columnsApply="Apply"

          i18n-columnsReset="kendo.grid.columnsReset|The text shown in the column menu or column chooser for the columns reset button"
          columnsReset="Reset"

          i18n-detailExpand="kendo.grid.detailExpand|The title of the expand icon of detail rows. Applies also to the expand button text in stacked mode."
          detailExpand="Expand Details"

          i18n-detailCollapse="kendo.grid.detailCollapse|The title of the collapse icon of detail rows. Applies also to the collapse button text in stacked mode."
          detailCollapse="Collapse Details"

          i18n-filterDateToday="kendo.grid.filterDateToday|The text of the Today button of the Date filter."
          filterDateToday="TODAY"

          i18n-filterDateToggle="kendo.grid.filterDateToggle|The title of the Toggle button of the Date filter."
          filterDateToggle="Toggle Calendar"

          i18n-filterNumericDecrement="kendo.grid.filterNumericDecrement|The title of the Decrement button of the Numeric filter."
          filterNumericDecrement="Decrement"

          i18n-filterNumericIncrement="kendo.grid.filterNumericIncrement|The title of the Increment button of the Numeric filter."
          filterNumericIncrement="Increment"

          i18n-selectionCheckboxLabel="kendo.grid.selectionCheckboxLabel|The labels of the checkbox column checkboxes."
          selectionCheckboxLabel="Select Row"

          i18n-selectAllCheckboxLabel="kendo.grid.selectAllCheckboxLabel|The label of the checkbox column select all checkbox."
          selectAllCheckboxLabel="Select All Rows"

          i18n-sortToolbarToolText="kendo.grid.sortToolbarToolText|The button text of the Sort toolbar tool."
          sortToolbarToolText="Sort"

          i18n-groupCollapse="kendo.grid.groupCollapse|The text of the title and aria-label attributes applied to the collapse icon of group rows."
          groupCollapse="Collapse Group"

          i18n-groupExpand="kendo.grid.groupExpand|The text of the title and aria-label attributes applied to the expand icon of group rows."
          groupExpand="Expand Group"

          i18n-pagerSelectPage="kendo.grid.pagerSelectPage|The text of the title and aria-label attributes applied to the page chooser in the Grid Pager"
          pagerSelectPage="Select page"

          i18n-topToolbarLabel="kendo.grid.topToolbarLabel|The label for the Grid top toolbar"
          topToolbarLabel="Top toolbar"

          i18n-bottomToolbarLabel="kendo.grid.bottomToolbarLabel|The label for the Grid bottom toolbar"
          bottomToolbarLabel="Bottom toolbar"

          i18n-editToolbarToolText="kendo.grid.editToolbarToolText|The text for the Grid Edit toolbar tool"
          editToolbarToolText="Edit"

          i18n-saveToolbarToolText="kendo.grid.saveToolbarToolText|The text for the Grid Save toolbar tool"
          saveToolbarToolText="Save"

          i18n-addToolbarToolText="kendo.grid.addToolbarToolText|The text for the Grid Add toolbar tool"
          addToolbarToolText="Add"

          i18n-cancelToolbarToolText="kendo.grid.cancelToolbarToolText|The text for the Grid Cancel toolbar tool"
          cancelToolbarToolText="Cancel"

          i18n-removeToolbarToolText="kendo.grid.removeToolbarToolText|The text for the Grid Remove toolbar tool"
          removeToolbarToolText="Delete"

          i18n-excelExportToolbarToolText="kendo.grid.excelExportToolbarToolText|The text for the Grid Excel export toolbar tool"
          excelExportToolbarToolText="Excel Export"

          i18n-pdfExportToolbarToolText="kendo.grid.pdfExportToolbarToolText|The text for the Grid PDF export toolbar tool"
          pdfExportToolbarToolText="PDF Export"

          i18n-groupPanelLabel="kendo.grid.groupPanelLabel|The label for the Grid group panel toolbar"
          groupPanelLabel="Group panel"

          i18n-dragRowHandleLabel="kendo.grid.dragRowHandleLabel|The label for the Grid drag row handle"
          dragRowHandleLabel="Drag row"

          i18n-columnMenuFilterTabTitle="kendo.grid.columnMenuFilterTabTitle|The title for the column menu Filter tab"
          columnMenuFilterTabTitle="Filter"

          i18n-columnMenuGeneralTabTitle="kendo.grid.columnMenuGeneralTabTitle|The title for the column menu General tab"
          columnMenuGeneralTabTitle="General"

          i18n-columnMenuColumnsTabTitle="kendo.grid.columnMenuColumnsTabTitle|The title for the column menu Columns tab"
          columnMenuColumnsTabTitle="Columns"

          i18n-groupChipMenuPrevious="kendo.grid.groupChipMenuPrevious|The text for the Group pane Chip Menu Move as previous item"
          groupChipMenuPrevious="Move as previous"

          i18n-groupChipMenuNext="kendo.grid.groupChipMenuNext|The text for the Group pane Chip Menu Move as next item"
          groupChipMenuNext="Move as next"

          i18n-groupToolbarToolText="kendo.grid.groupToolbarToolText|The button text of the Group toolbar tool"
          groupToolbarToolText="Group"

          i18n-formValidationErrorText="kendo.grid.formValidationErrorText|The default text of a form validation error when using external editing."
          formValidationErrorText="{{ 'The {fieldName} field has {errorName} validation error' }}"

          i18n-removeConfirmationDialogTitle="kendo.grid.removeConfirmationDialogTitle|The title of the built-in remove item confirmation Dialog"
          removeConfirmationDialogTitle="Please confirm"

          i18n-removeConfirmationDialogContent="kendo.grid.removeConfirmationDialogContent|The content of the built-in remove item confirmation Dialog"
          removeConfirmationDialogContent="Are you sure you want to delete this item?"

          i18n-removeConfirmationDialogConfirmText="kendo.grid.removeConfirmationDialogConfirmText|The text of the built-in remove item confirmation Dialog confirm action button"
          removeConfirmationDialogConfirmText="Yes"

          i18n-removeConfirmationDialogRejectText="kendo.grid.removeConfirmationDialogRejectText|The text of the built-in remove item confirmation Dialog reject action button"
          removeConfirmationDialogRejectText="No"

          i18n-externalEditingTitle="kendo.grid.externalEditingTitle|The title of the built-in external editing form container when editing an item"
          externalEditingTitle="Edit"

          i18n-externalEditingAddTitle="kendo.grid.externalEditingAddTitle|The title of the built-in external editing form container when adding a new item"
          externalEditingAddTitle="Add"

          i18n-externalEditingSaveText="kendo.grid.externalEditingSaveText|The text of the external editing form Save button"
          externalEditingSaveText="Save"

          i18n-externalEditingCancelText="kendo.grid.externalEditingCancelText|The text of the external editing form Cancel button"
          externalEditingCancelText="Cancel"

          i18n-aiAssistantToolbarToolText="kendo.grid.aiAssistantToolbarToolText|The text of the AI Assistant toolbar tool"
          aiAssistantToolbarToolText="AI Assistant"

          i18n-aiAssistantWindowTitle="kendo.grid.aiAssistantWindowTitle|The text of the AI Assistant Window title"
          aiAssistantWindowTitle="AI Assistant"

          i18n-aiAssistantApplyButtonText="kendo.grid.aiAssistantApplyButtonText|The text of the AI Assistant Apply button"
          aiAssistantApplyButtonText="Apply"

          i18n-aiAssistantWindowCloseTitle="kendo.grid.aiAssistantWindowCloseTitle|The title of the AI Assistant Window close button"
          aiAssistantWindowCloseTitle="Close"

          i18n-aiAssistantWindowMaximizeTitle="kendo.grid.aiAssistantWindowMaximizeTitle|The title of the AI Assistant Window maximize button"
          aiAssistantWindowMaximizeTitle="Maximize"

          i18n-aiAssistantWindowMinimizeTitle="kendo.grid.aiAssistantWindowMinimizeTitle|The title of the AI Assistant Window minimize button"
          aiAssistantWindowMinimizeTitle="Minimize"

          i18n-aiAssistantWindowRestoreTitle="kendo.grid.aiAssistantWindowRestoreTitle|The title of the AI Assistant Window restore button"
          aiAssistantWindowRestoreTitle="Restore"

          i18n-aiAssistantOutputCardTitle="kendo.grid.aiAssistantOutputCardTitle|The title of the AI Assistant Prompt Output Card"
          aiAssistantOutputCardTitle="Generated with AI"

          i18n-aiAssistantOutputCardBodyContent="kendo.grid.aiAssistantOutputCardBodyContent|The success message dispayed in the AI Assistant Prompt Output Card's body"
          aiAssistantOutputCardBodyContent="Operation is successful. Data is:"

          i18n-aiAssistantSelectionNotEnabled="kendo.grid.aiAssistantSelectionNotEnabled|The message shown when AI selection requires the Grid selectable option"
          aiAssistantSelectionNotEnabled="Selection can be applied only when the Grid selectable option is enabled."

          i18n-aiAssistantSelectionRowModeRequired="kendo.grid.aiAssistantSelectionRowModeRequired|The message shown when AI selection requires row selection mode"
          aiAssistantSelectionRowModeRequired="Selection can be applied only when row selection mode is enabled."

          i18n-aiAssistantSelectionCellModeRequired="kendo.grid.aiAssistantSelectionCellModeRequired|The message shown when AI selection requires cell selection mode"
          aiAssistantSelectionCellModeRequired="Selection can be applied only when cell selection mode is enabled."

          i18n-columnChooserSelectAll="kendo.grid.columnChooserSelectAll|The text for the Select all checkbox in the Column Chooser"
          columnChooserSelectAll="Select all"

          i18n-columnChooserSelectedColumnsCount="kendo.grid.columnChooserSelectedColumnsCount|The text displayed in the Column Chooser for the number of selected columns"
          columnChooserSelectedColumnsCount="{{ '{selectedColumnsCount} Selected items' }}"

          i18n-multiCheckboxFilterSearchPlaceholder="kendo.grid.multiCheckboxFilterSearchPlaceholder|The placeholder text for the multi-checkbox filter search input"
          multiCheckboxFilterSearchPlaceholder="Search..."

          i18n-multiCheckboxFilterSelectAllLabel="kendo.grid.multiCheckboxFilterSelectAllLabel|The label for the multi-checkbox filter select all option"
          multiCheckboxFilterSelectAllLabel="Select all"

          i18n-multiCheckboxFilterSelectedItemsCount="kendo.grid.multiCheckboxFilterSelectedItemsCount|The text for the multi-checkbox filter selected items count"
          multiCheckboxFilterSelectedItemsCount="{{ '{selectedItemsCount} selected items' }}"
          >
        </ng-container>
        @if (showTopToolbar) {
          <kendo-grid-toolbar
            [size]="size"
            [attr.aria-label]="messageFor('topToolbarLabel')"
            [navigable]="navigation.toolbarEnabled"
            [attr.aria-controls]="ariaRootId"
          position="top"></kendo-grid-toolbar>
        }
        <ng-content select="kendo-toolbar"></ng-content>
        @if (showTopPager) {
          <kendo-pager
            #topPager
            [navigable]="navigation.pagerEnabled"
            class="k-grid-pager k-grid-pager-top"
            [pageSize]="pageSize"
            [total]="view.total"
            [skip]="skip"
            [size]="size"
            [responsive]="normalizedPageableSettings.responsive && !pagerTemplate"
            [buttonCount]="normalizedPageableSettings.buttonCount"
            [info]="normalizedPageableSettings.info"
            [pageSizeValues]="normalizedPageableSettings.pageSizes"
            [previousNext]="normalizedPageableSettings.previousNext"
            [type]="normalizedPageableSettings.type"
            (pageChange)="notifyPageChange('pager', $event)"
            (pagerInputVisibilityChange)="handlePagerVisibilityChange('showPagerInput', $event)"
            (pageTextVisibilityChange)="handlePagerVisibilityChange('showPagerPageText', $event)"
            (itemsTextVisibilityChange)="handlePagerVisibilityChange('showPagerItemsText', $event)">
            <ng-template kendoPagerTemplate>
              <ng-container
                [ngTemplateOutlet]="pagerTemplate ? pagerTemplate?.templateRef : defaultPager"
              [ngTemplateOutletContext]="topPager.templateContext"></ng-container>
            </ng-template>
            <kendo-pager-messages
              [ariaLabel]="messageFor('pagerLabel')"
              [firstPage]="messageFor('pagerFirstPage')"
              [inputLabel]="messageFor('pagerInputLabel')"
              [previousPage]="messageFor('pagerPreviousPage')"
              [nextPage]="messageFor('pagerNextPage')"
              [lastPage]="messageFor('pagerLastPage')"
              [selectPage]="messageFor('pagerSelectPage')"
              [page]="messageFor('pagerPage')"
              [itemsPerPage]="messageFor('pagerItemsPerPage')"
              [items]="messageFor('pagerItems')"
              [of]="messageFor('pagerOf')"
              [pageNumberInputTitle]="messageFor('pagerPageNumberInputTitle')">
            </kendo-pager-messages>
          </kendo-pager>
        }
        @if (showGroupPanel) {
          <kendo-grid-group-panel
            [navigable]="navigation.toolbarEnabled"
            [text]="groupableEmptyText"
            [groups]="group"
            role="toolbar"
            [attr.aria-label]="messageFor('groupPanelLabel')"
            [attr.aria-controls]="ariaRootId"
            (change)="groupChange.emit($event)">
          </kendo-grid-group-panel>
        }
        <div #ariaRoot
          class="k-grid-aria-root"
          role="grid"
          kendoDragTargetContainer
          kendoDropTargetContainer
          mode="manual"
          [dragDisabled]="!rowReorderable"
          [dropDisabled]="!rowReorderable"
          [dragTargetFilter]="getDefaultSelectors('dragTarget')"
          [dropTargetFilter]="getDefaultSelectors('dropTarget')"
          [dragHandle]="getDefaultSelectors('handle')"
          [hint]="{hintTemplate: customHintTemplate || defaultHint}"
          [hintContext]="hintContext"
          (onPress)="handleReorderEvents($event, 'press')"
          (onDragStart)="handleReorderEvents($event, 'dragStart')"
          (onDrag)="handleReorderEvents($event, 'drag')"
          (onDragEnter)="handleReorderEvents($event, 'dragEnter')"
          (onDragLeave)="handleReorderEvents($event, 'dragLeave')"
          (onDragEnd)="handleReorderEvents($event, 'dragEnd')"
          (onDrop)="handleReorderEvents($event, 'drop')"
          [dragData]="gridData"
          [id]="ariaRootId"
          [attr.aria-label]="ariaLabel"
          [attr.aria-rowcount]="ariaRowCount"
          [attr.aria-colcount]="ariaColCount">
          @if (isScrollable) {
            @if (!hideHeader && !isStacked) {
              <div
                class="k-grid-header"
                [class.k-grid-draggable-header]="groupable || reorderable"
                role="presentation"
                [style.padding]="headerPadding">
                @if (isLocked) {
                  <div
                    #lockedHeader
                    role="presentation"
                    class="k-grid-header-locked"
                    [style.width.px]="lockedWidth">
                    <table
                      kendoGridResizableTable
                      [locked]="true"
                      role="presentation"
                      class="k-grid-header-table"
                      [style.width.px]="lockedWidth"
                      kendoGridTable
                      [size]="size">
                      <colgroup kendoGridColGroup
                        [columns]="$any(lockedLeafColumns)"
                        [groups]="group"
                        [detailTemplate]="detailTemplate">
                    </colgroup>
                    <thead kendoGridHeader
                      role="rowgroup"
                      [resizable]="resizable"
                      [scrollable]="true"
                      [columns]="$any(lockedColumns)"
                      [totalColumnLevels]="totalColumnLevels"
                      [sort]="sort"
                      [groups]="group"
                      [filter]="filter"
                      [filterable]="filterable"
                      [groupable]="showGroupPanel"
                      [reorderable]="reorderable"
                      [sortable]="sortable"
                      [columnMenu]="columnMenuOptions"
                      [columnMenuTemplate]="columnMenuTemplate"
                      [totalColumnsCount]="leafColumns.length"
                      [totalColumns]="columnsContainer"
                      [detailTemplate]="detailTemplate"
                      [tabIndex]="navigation.tableEnabled ? '-1' : '0'">
                    </thead>
                  </table>
                </div>
              }
              <div #header class="k-grid-header-wrap" role="presentation" data-scrollable
                [kendoGridResizableContainer]="lockedLeafColumns.length > 0"
                [lockedWidth]="lockedWidth + scrollbarWidth + 2">
                <table
                  role="presentation"
                  class="k-grid-header-table"
                  [style.width.px]="nonLockedWidth"
                  kendoGridResizableTable
                  [virtualColumns]="virtualColumns"
                  kendoGridTable
                  [size]="size">
                  <colgroup kendoGridColGroup
                    [columns]="headerLeafColumns"
                    [groups]="isLocked ? [] : group"
                    [detailTemplate]="detailTemplate">
                </colgroup>
                <thead kendoGridHeader
                  [resizable]="resizable"
                  role="rowgroup"
                  [scrollable]="true"
                  [columns]="headerColumns"
                  [totalColumnLevels]="totalColumnLevels"
                  [sort]="sort"
                  [filter]="filter"
                  [filterable]="filterable"
                  [groupable]="showGroupPanel"
                  [reorderable]="reorderable"
                  [groups]="isLocked ? [] : group"
                  [sortable]="sortable"
                  [columnMenu]="columnMenuOptions"
                  [columnMenuTemplate]="columnMenuTemplate"
                  [lockedColumnsCount]="lockedLeafColumns.length"
                  [totalColumnsCount]="leafColumns.length"
                  [totalColumns]="columnsContainer"
                  [detailTemplate]="detailTemplate"
                  [tabIndex]="navigation.tableEnabled ? '-1' : '0'">
                </thead>
              </table>
              @if (virtualColumns) {
                <div class="k-width-container" role="presentation">
                  <div [style.width.px]="columnsContainer.unlockedWidth"></div>
                </div>
              }
            </div>
          </div>
        }
        <kendo-grid-list
          [data]="$any(view)"
          [rowHeight]="rowHeight"
          [detailRowHeight]="detailRowHeight"
          [total]="totalCount"
          [take]="pageSize"
          [groups]="group"
          [groupable]="groupable"
          [skip]="skip"
          [trackBy]="trackBy"
          [columns]="columnsContainer"
          [selectable]="selectable"
          [filterable]="filterable"
          [detailTemplate]="detailTemplate"
          [noRecordsTemplate]="noRecordsTemplate"
          [size]="size"
          (pageChange)="notifyPageChange('list', $event)"
          [rowClass]="rowClass"
          [rowSticky]="rowSticky"
          [loading]="loading"
          [isVirtual]="isVirtual"
          [cellLoadingTemplate]="cellLoadingTemplate?.templateRef"
          [loadingTemplate]="loadingTemplate?.templateRef"
          [virtualColumns]="virtualColumns"
          (scrollBottom)="notifyScrollBottom()"
          (contentScroll)="contentScroll.emit($event)"
          kendoDraggable
          kendoGridSelectionMarquee
          [enableDrag]="marqueeSelection"
          [sort]="sort">
        </kendo-grid-list>
        @if (showFooter) {
          <div
            class="k-grid-footer"
            [style.padding]="headerPadding">
            @if (lockedLeafColumns.length && !isStacked) {
              <div
                class="k-grid-footer-locked"
                [style.width.px]="lockedWidth">
                <table
                  role="presentation"
                  class="k-grid-footer-table"
                  kendoGridResizableTable
                  [locked]="true"
                  [style.width.px]="lockedWidth"
                  kendoGridTable
                  [size]="size">
                  @if (!isStacked) {
                    <colgroup kendoGridColGroup
                      [columns]="$any(lockedLeafColumns)"
                      [groups]="group"
                      [detailTemplate]="detailTemplate">
                  </colgroup>
                }
                <tfoot kendoGridFooter
                  [scrollable]="true"
                  [groups]="group"
                  [columns]="$any(lockedLeafColumns)"
                  [detailTemplate]="detailTemplate"
                  [logicalRowIndex]="ariaRowCount"
                  [totalColumns]="columnsContainer"
                  [totalColumnsCount]="leafColumns.length">
                </tfoot>
              </table>
            </div>
          }
          <div #footer
            class="k-grid-footer-wrap" data-scrollable
            [kendoGridResizableContainer]="lockedLeafColumns.length > 0 && !isStacked"
            [lockedWidth]="lockedWidth + scrollbarWidth + 3">
            <table
              role="presentation"
              class="k-grid-footer-table"
              [style.width.px]="nonLockedWidth"
              kendoGridTable
              kendoGridResizableTable
              [size]="size">
              @if (!isStacked) {
                <colgroup kendoGridColGroup
                  [columns]="$any(headerLeafColumns)"
                  [groups]="isLocked ? [] : group"
                  [detailTemplate]="detailTemplate">
              </colgroup>
            }
            <tfoot kendoGridFooter
              [logicalRowIndex]="ariaRowCount"
              [scrollable]="true"
              [groups]="isLocked ? [] : group"
              [columns]="$any(headerColumns)"
              [lockedColumnsCount]="isStacked ? 0 : lockedLeafColumns.length"
              [detailTemplate]="detailTemplate"
              [totalColumns]="columnsContainer"
              [totalColumnsCount]="leafColumns.length">
            </tfoot>
          </table>
        </div>
        </div>
        }
        }
        @if (!isScrollable) {
          <table
            [style.table-layout]="resizable ? 'fixed' : null"
            kendoGridTable
            kendoGridResizableTable
            class="k-grid-table"
            role="presentation"
            [size]="size">
            <colgroup kendoGridColGroup
              [columns]="$any(leafColumns)"
              [groups]="group"
              [sort]="sort"
              [detailTemplate]="detailTemplate">
          </colgroup>
          @if (!hideHeader && !isStacked) {
            <thead kendoGridHeader
              class="k-grid-header"
              [class.k-grid-draggable-header]="groupable || reorderable"
              role="rowgroup"
              [resizable]="resizable"
              [scrollable]="false"
              [columns]="$any(visibleColumns)"
              [totalColumnLevels]="totalColumnLevels"
              [totalColumns]="columnsContainer"
              [groups]="group"
              [groupable]="showGroupPanel"
              [reorderable]="reorderable"
              [sort]="sort"
              [sortable]="sortable"
              [filter]="filter"
              [filterable]="filterable"
              [columnMenu]="columnMenuOptions"
              [columnMenuTemplate]="columnMenuTemplate"
              [detailTemplate]="detailTemplate"
              [tabIndex]="navigation.tableEnabled ? '-1' : '0'">
            </thead>
          }
          <tbody kendoGridTableBody
            [isLoading]="loading"
            [rowHeight]="rowHeight"
            [detailRowHeight]="detailRowHeight"
            [groups]="group"
            [rowsToRender]="rowsToRender"
            [skip]="skip"
            [columns]="$any(leafColumns)"
            [totalColumnsCount]="leafColumns.length"
            [totalColumns]="columnsContainer"
            [selectable]="selectable"
            [filterable]="filterable"
            [noRecordsTemplate]="noRecordsTemplate"
            [detailTemplate]="detailTemplate"
            [trackBy]="trackBy"
            [rowClass]="rowClass"
            kendoDraggable
            kendoGridSelectionMarquee
            [enableDrag]="marqueeSelection">
          </tbody>
          @if (showFooter) {
            <tfoot kendoGridFooter
              [scrollable]="false"
              [logicalRowIndex]="ariaRowCount"
              [groups]="group"
              [columns]="$any(leafColumns)"
              [detailTemplate]="detailTemplate"
              [totalColumns]="columnsContainer"
              [totalColumnsCount]="leafColumns.length">
            </tfoot>
          }
        </table>
        }
        @if (loading) {
          <div [loadingTemplate]="loadingTemplate" kendoGridLoading></div>
        }
        </div>
        @if (showStatusBar) {
          <kendo-grid-status-bar
            [statusBarTemplate]="statusBarTemplate">
          </kendo-grid-status-bar>
        }
        @if (showBottomPager) {
          <kendo-pager
            #bottomPager
            class="k-grid-pager"
            [navigable]="navigation.pagerEnabled"
            [pageSize]="pageSize"
            [total]="view.total"
            [skip]="skip"
            [size]="size"
            [responsive]="normalizedPageableSettings.responsive && !pagerTemplate"
            [buttonCount]="normalizedPageableSettings.buttonCount"
            [info]="normalizedPageableSettings.info"
            [pageSizeValues]="normalizedPageableSettings.pageSizes"
            [previousNext]="normalizedPageableSettings.previousNext"
            [type]="normalizedPageableSettings.type"
            (pageChange)="notifyPageChange('pager', $event)"
            (pagerInputVisibilityChange)="handlePagerVisibilityChange('showPagerInput', $event)"
            (pageTextVisibilityChange)="handlePagerVisibilityChange('showPagerPageText', $event)"
            (itemsTextVisibilityChange)="handlePagerVisibilityChange('showPagerItemsText', $event)">
            <ng-template kendoPagerTemplate>
              <ng-container
                [ngTemplateOutlet]="pagerTemplate ? pagerTemplate?.templateRef : defaultPager"
              [ngTemplateOutletContext]="bottomPager.templateContext"></ng-container>
            </ng-template>
            <kendo-pager-messages
              [ariaLabel]="messageFor('pagerLabel')"
              [firstPage]="messageFor('pagerFirstPage')"
              [inputLabel]="messageFor('pagerInputLabel')"
              [previousPage]="messageFor('pagerPreviousPage')"
              [nextPage]="messageFor('pagerNextPage')"
              [lastPage]="messageFor('pagerLastPage')"
              [selectPage]="messageFor('pagerSelectPage')"
              [page]="messageFor('pagerPage')"
              [itemsPerPage]="messageFor('pagerItemsPerPage')"
              [items]="messageFor('pagerItems')"
              [of]="messageFor('pagerOf')"
              [pageNumberInputTitle]="messageFor('pagerPageNumberInputTitle')">
            </kendo-pager-messages>
          </kendo-pager>
        }
        @if (showBottomToolbar) {
          <kendo-grid-toolbar
            class="k-grid-toolbar-bottom"
            [size]="size"
            [navigable]="navigation.toolbarEnabled"
            [attr.aria-label]="messageFor('bottomToolbarLabel')"
            [attr.aria-controls]="ariaRootId"
            position="bottom">
          </kendo-grid-toolbar>
        }

        <ng-template #defaultHint>
          <kendo-icon-wrapper
            [name]="getHintSettings('hintIcon')"
            [svgIcon]="getHintSettings('hintSVGIcon')"
            innerCssClass="k-drag-status">
          </kendo-icon-wrapper>
          {{hintText}}
        </ng-template>

        <ng-template #defaultPager>
          <div class="k-pager-numbers-wrap">
            @if (normalizedPageableSettings.previousNext) {
              <kendo-pager-prev-buttons [size]="size"></kendo-pager-prev-buttons>
            }
            @if (normalizedPageableSettings.type === 'numeric' && normalizedPageableSettings.buttonCount > 0) {
              <kendo-pager-numeric-buttons
                [size]="size"
                [buttonCount]="normalizedPageableSettings.buttonCount">
              </kendo-pager-numeric-buttons>
            }
            @if (normalizedPageableSettings.type === 'input' || showPagerInput) {
              <kendo-pager-input [size]="size" [showPageText]="showPagerPageText"></kendo-pager-input>
            }
            @if (normalizedPageableSettings.previousNext) {
              <kendo-pager-next-buttons [size]="size"></kendo-pager-next-buttons>
            }
          </div>
          @if (normalizedPageableSettings.pageSizes) {
            <kendo-pager-page-sizes
              [size]="size"
              [pageSizes]="normalizedPageableSettings.pageSizes"
              [showItemsText]="showPagerItemsText">
            </kendo-pager-page-sizes>
          }
          @if (normalizedPageableSettings.info) {
            <kendo-pager-info>
            </kendo-pager-info>
          }
        </ng-template>
        <div #dialogContainer></div>
        <div #windowContainer></div>

        @if (isAdaptiveModeEnabled) {
          <kendo-grid-adaptive-renderer></kendo-grid-adaptive-renderer>
        }
        @if (isVirtual) {
          <kendo-resize-sensor (resize)="onResize()"></kendo-resize-sensor>
        }

        @if (showLicenseWatermark) {
          <div kendoWatermarkOverlay [licenseMessage]="licenseMessage"></div>
        }
        `,
                    standalone: true,
                    imports: [
                        LocalizedMessagesDirective,
                        ToolbarComponent,
                        GroupPanelComponent,
                        TableDirective,
                        GridTableDirective,
                        ColGroupComponent,
                        HeaderComponent,
                        ResizableContainerDirective,
                        ListComponent,
                        DragTargetContainerDirective,
                        DropTargetContainerDirective,
                        DraggableDirective,
                        GridMarqueeDirective,
                        FooterComponent,
                        TableBodyComponent,
                        LoadingComponent,
                        StatusBarComponent,
                        IconWrapperComponent,
                        WatermarkOverlayComponent,
                        ...KENDO_PAGER,
                        NgTemplateOutlet,
                        AdaptiveRendererComponent,
                        ResizeSensorComponent
                    ]
                }]
        }], ctorParameters: () => [{ type: BrowserSupportService }, { type: SelectionService }, { type: CellSelectionService }, { type: i0.ElementRef }, { type: GroupInfoService }, { type: GroupsService }, { type: ChangeNotificationService }, { type: DetailsService }, { type: EditService }, { type: FilterService }, { type: PDFService }, { type: ResponsiveService }, { type: i0.Renderer2 }, { type: ExcelService }, { type: i0.NgZone }, { type: ScrollSyncService }, { type: DomEventsService }, { type: ColumnResizingService }, { type: i0.ChangeDetectorRef }, { type: ColumnReorderService }, { type: ColumnInfoService }, { type: NavigationService }, { type: SortService }, { type: ScrollRequestService }, { type: i1$2.LocalizationService }, { type: ContextService }, { type: SizingOptionsService }, { type: AdaptiveGridService }, { type: RowReorderService }, { type: DataMappingService }, { type: GridAIRequestResponseService }, { type: IdService }], propDecorators: { data: [{
                type: Input
            }], pageSize: [{
                type: Input
            }], height: [{
                type: Input
            }], rowHeight: [{
                type: Input
            }], adaptiveMode: [{
                type: Input
            }], detailRowHeight: [{
                type: Input
            }], skip: [{
                type: Input
            }], scrollable: [{
                type: Input
            }], selectable: [{
                type: Input
            }], sort: [{
                type: Input
            }], size: [{
                type: Input
            }], trackBy: [{
                type: Input
            }], filter: [{
                type: Input
            }], group: [{
                type: Input
            }], virtualColumns: [{
                type: Input
            }], filterable: [{
                type: Input
            }], sortable: [{
                type: Input
            }], pageable: [{
                type: Input
            }], groupable: [{
                type: Input
            }], gridResizable: [{
                type: Input
            }], rowReorderable: [{
                type: Input
            }], navigable: [{
                type: Input
            }], autoSize: [{
                type: Input
            }], rowClass: [{
                type: Input
            }], rowSticky: [{
                type: Input
            }], rowSelected: [{
                type: Input
            }], isRowSelectable: [{
                type: Input
            }], cellSelected: [{
                type: Input
            }], resizable: [{
                type: Input
            }], reorderable: [{
                type: Input
            }], loading: [{
                type: Input
            }], columnMenu: [{
                type: Input
            }], hideHeader: [{
                type: Input
            }], showInactiveTools: [{
                type: Input
            }], isDetailExpanded: [{
                type: Input
            }], isGroupExpanded: [{
                type: Input
            }], dataLayoutMode: [{
                type: Input
            }], filterChange: [{
                type: Output
            }], pageChange: [{
                type: Output
            }], groupChange: [{
                type: Output
            }], sortChange: [{
                type: Output
            }], selectionChange: [{
                type: Output
            }], rowReorder: [{
                type: Output
            }], dataStateChange: [{
                type: Output
            }], gridStateChange: [{
                type: Output
            }], groupExpand: [{
                type: Output
            }], groupCollapse: [{
                type: Output
            }], detailExpand: [{
                type: Output
            }], detailCollapse: [{
                type: Output
            }], edit: [{
                type: Output
            }], cancel: [{
                type: Output
            }], save: [{
                type: Output
            }], remove: [{
                type: Output
            }], add: [{
                type: Output
            }], cellClose: [{
                type: Output
            }], cellClick: [{
                type: Output
            }], pdfExport: [{
                type: Output
            }], excelExport: [{
                type: Output
            }], columnResize: [{
                type: Output
            }], columnReorder: [{
                type: Output
            }], columnVisibilityChange: [{
                type: Output
            }], columnLockedChange: [{
                type: Output
            }], columnStickyChange: [{
                type: Output
            }], scrollBottom: [{
                type: Output
            }], contentScroll: [{
                type: Output
            }], columns: [{
                type: ContentChildren,
                args: [ColumnBase]
            }], dir: [{
                type: HostBinding,
                args: ['attr.dir']
            }], hostClass: [{
                type: HostBinding,
                args: ['class.k-grid']
            }], sizeSmallClass: [{
                type: HostBinding,
                args: ['class.k-grid-sm']
            }], sizeMediumClass: [{
                type: HostBinding,
                args: ['class.k-grid-md']
            }], stackedClass: [{
                type: HostBinding,
                args: ['class.k-grid-stack']
            }], lockedClasses: [{
                type: HostBinding,
                args: ['class.k-grid-lockedcolumns']
            }], virtualClasses: [{
                type: HostBinding,
                args: ['class.k-grid-virtual']
            }], noScrollbarClass: [{
                type: HostBinding,
                args: ['class.k-grid-no-scrollbar']
            }], isResizable: [{
                type: HostBinding,
                args: ['class.k-grid-resizable']
            }], minWidth: [{
                type: HostBinding,
                args: ['style.minWidth']
            }], maxWidth: [{
                type: HostBinding,
                args: ['style.maxWidth']
            }], minHeight: [{
                type: HostBinding,
                args: ['style.minHeight']
            }], maxHeight: [{
                type: HostBinding,
                args: ['style.maxHeight']
            }], detailTemplateChildren: [{
                type: ContentChildren,
                args: [DetailTemplateDirective]
            }], cellLoadingTemplateChildren: [{
                type: ContentChildren,
                args: [CellLoadingTemplateDirective]
            }], loadingTemplateChildren: [{
                type: ContentChildren,
                args: [LoadingTemplateDirective]
            }], statusBarTemplateChildren: [{
                type: ContentChildren,
                args: [StatusBarTemplateDirective]
            }], noRecordsTemplateChildren: [{
                type: ContentChildren,
                args: [NoRecordsTemplateDirective]
            }], pagerTemplateChildren: [{
                type: ContentChildren,
                args: [PagerTemplateDirective]
            }], toolbarTemplateChildren: [{
                type: ContentChildren,
                args: [ToolbarTemplateDirective]
            }], columnMenuTemplates: [{
                type: ContentChildren,
                args: [ColumnMenuTemplateDirective]
            }], lockedHeader: [{
                type: ViewChild,
                args: ['lockedHeader']
            }], header: [{
                type: ViewChild,
                args: ['header']
            }], footer: [{
                type: ViewChildren,
                args: ['footer']
            }], ariaRoot: [{
                type: ViewChild,
                args: ['ariaRoot', { static: true }]
            }], dragTargetContainer: [{
                type: ViewChild,
                args: [DragTargetContainerDirective]
            }], dropTargetContainer: [{
                type: ViewChild,
                args: [DropTargetContainerDirective]
            }], dialogContainer: [{
                type: ViewChild,
                args: ['dialogContainer', { read: ViewContainerRef }]
            }], windowContainer: [{
                type: ViewChild,
                args: ['windowContainer', { read: ViewContainerRef }]
            }], adaptiveRenderer: [{
                type: ViewChild,
                args: [AdaptiveRendererComponent]
            }], listComponent: [{
                type: ViewChild,
                args: [ListComponent]
            }] } });

/**
 * The component allows you to override the default component messages with custom ones.
 * ([See example](slug:globalization_grid#toc-custom-messages).)
 *
 * @example
 * ```html
 * <kendo-grid [data]="gridData">
 *   <kendo-grid-messages
 *     [noRecords]="'No data found.'"
 *     [pagerLabel]="'Page {currentPage} of {totalPages}'">
 *   </kendo-grid-messages>
 * </kendo-grid>
 * ```
 */
class CustomMessagesComponent extends GridMessages {
    service;
    constructor(service) {
        super();
        this.service = service;
    }
    get override() {
        return true;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CustomMessagesComponent, deps: [{ token: i1$2.LocalizationService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: CustomMessagesComponent, isStandalone: true, selector: "kendo-grid-messages", providers: [
            {
                provide: GridMessages,
                useExisting: forwardRef(() => CustomMessagesComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CustomMessagesComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: GridMessages,
                            useExisting: forwardRef(() => CustomMessagesComponent)
                        }
                    ],
                    selector: 'kendo-grid-messages',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1$2.LocalizationService }] });

/**
 * A directive that handles in-memory data operations like [paging]({% slug paging_grid %}),
 * [sorting]({% slug sorting_grid %}), and [grouping]({% slug grouping_grid %}).
 *
 * Use this directive with local data and enable the Grid data operations with minimal configuration.
 * ([More information and examples]({% slug local_data_grid %}#toc-automatic-data-processing)).
 *
 * @example
 * ```html
 * <kendo-grid [kendoGridBinding]="gridData"></kendo-grid>
 * ```
 * @remarks
 * Applied to: {@link GridComponent}.
 */
class DataBindingDirective {
    grid;
    changeDetector;
    localDataChangesService;
    rowReorderService;
    /**
     * Sets the number of records to skip in the Grid.
     *
     * @default 0
     */
    set skip(value) {
        if (!isPresent(value)) {
            value = 0;
        }
        this.grid.skip = this.state.skip = value;
        if (this.rowReorderService) {
            this.rowReorderService.skip = value;
        }
    }
    /**
     * Sets the sort descriptors for the Grid data.
     *
     */
    set sort(value) {
        this.grid.sort = this.state.sort = value;
    }
    /**
     * Sets the filter descriptor for the Grid data.
     *
     */
    set filter(value) {
        this.grid.filter = this.state.filter = value;
    }
    /**
     * Sets the page size for the Grid pager.
     *
     */
    set pageSize(value) {
        this.grid.pageSize = this.state.take = value;
    }
    /**
     * Sets the group descriptors for the Grid data.
     *
     */
    set group(value) {
        this.grid.group = this.state.group = value;
    }
    /**
     * Sets the data array for the Grid.
     *
     */
    set data(value) {
        this.originalData = value || [];
        if (this.localDataChangesService) {
            this.localDataChangesService.data = value;
        }
        this.dataChanged = true;
    }
    state = {
        skip: 0
    };
    originalData = [];
    dataChanged;
    stateChangeSubscription;
    dataChangedSubscription;
    rowReorderSubscription;
    constructor(grid, changeDetector, localDataChangesService, rowReorderService, ctx) {
        this.grid = grid;
        this.changeDetector = changeDetector;
        this.localDataChangesService = localDataChangesService;
        this.rowReorderService = rowReorderService;
        if (localDataChangesService) {
            this.dataChangedSubscription = this.localDataChangesService.changes.subscribe(this.rebind.bind(this));
        }
        ctx && (ctx.dataBindingDirective = this);
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this.applyState(this.state);
        this.stateChangeSubscription = this.grid
            .dataStateChange
            .subscribe(this.onStateChange.bind(this));
        if (this.rowReorderService) {
            this.rowReorderSubscription = this.grid
                .rowReorder
                .subscribe(this.onRowReorder.bind(this));
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        if (this.stateChangeSubscription) {
            this.stateChangeSubscription.unsubscribe();
        }
        if (this.dataChangedSubscription) {
            this.dataChangedSubscription.unsubscribe();
        }
        if (this.rowReorderSubscription) {
            this.rowReorderSubscription.unsubscribe();
        }
    }
    ngOnChanges(changes) {
        if (anyChanged(["pageSize", "skip", "sort", "group", "filter"], changes)) {
            this.rebind();
        }
    }
    ngDoCheck() {
        if (this.dataChanged) {
            this.updateGridData();
        }
    }
    /**
     * @hidden
     */
    onStateChange(state) {
        this.applyState(state);
        this.rebind();
    }
    /**
     * @hidden
     */
    onRowReorder(ev) {
        this.rowReorderService.reorderRows(ev, this.originalData);
        this.rebind();
    }
    /**
     * @hidden
     */
    rebind() {
        this.data = this.originalData;
        this.updateGridData();
        this.notifyDataChange();
    }
    /**
     * Notifies the Grid that its data has changed.
     */
    notifyDataChange() {
        this.grid.onDataChange();
        if (this.changeDetector) {
            this.changeDetector.markForCheck();
        }
    }
    process(state) {
        if (this.grid.isVirtual && ((!isPresent(state.take) || state.take === 0) && !state.group?.length)) {
            return {
                data: [],
                total: this.originalData?.length || 0
            };
        }
        return process(this.originalData, state);
    }
    applyState({ skip, take, sort, group, filter }) {
        this.skip = skip;
        this.pageSize = take;
        this.sort = sort;
        this.group = group;
        this.filter = filter;
    }
    updateGridData() {
        // Virtual scrolling without pagination:
        // - With groups: set take to undefined for DOM virtualization only (all data loaded)
        // - Without groups: ensure take is set for data virtualization (skip/take based loading)
        if (this.grid.isVirtual && !this.grid.pageable) {
            if (this.state.group?.length) {
                this.state.take = undefined;
            }
            else if (!isPresent(this.state.take) && isPresent(this.grid.pageSize)) {
                // Restore pageSize when ungrouping to enable data virtualization
                this.state.take = this.grid.pageSize;
            }
        }
        this.grid.data = this.process(this.state);
        this.grid.updateNavigationMetadata();
        this.grid.ngDoCheck();
        this.dataChanged = false;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DataBindingDirective, deps: [{ token: GridComponent }, { token: i0.ChangeDetectorRef }, { token: LocalDataChangesService }, { token: RowReorderService }, { token: ContextService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: DataBindingDirective, isStandalone: true, selector: "[kendoGridBinding]", inputs: { skip: "skip", sort: "sort", filter: "filter", pageSize: "pageSize", group: "group", data: ["kendoGridBinding", "data"] }, exportAs: ["kendoGridBinding"], usesOnChanges: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DataBindingDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridBinding]',
                    exportAs: 'kendoGridBinding',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: GridComponent }, { type: i0.ChangeDetectorRef }, { type: LocalDataChangesService }, { type: RowReorderService }, { type: ContextService }], propDecorators: { skip: [{
                type: Input
            }], sort: [{
                type: Input
            }], filter: [{
                type: Input
            }], pageSize: [{
                type: Input
            }], group: [{
                type: Input
            }], data: [{
                type: Input,
                args: ["kendoGridBinding"]
            }] } });

/**
 * Stores the row selection state of the Grid in memory
 * ([see example](slug:grid_selection_persistence)).
 *
 * @example
 * ```html
 * <kendo-grid kendoGridSelectBy="ProductID"></kendo-grid>
 *
 * <kendo-grid [kendoGridSelectBy]="myKey"></kendo-grid>
 * ```
 * @remarks
 * Applied to: {@link GridComponent}.
 */
class SelectionDirective extends Selection {
    ctx;
    constructor(ctx, cd) {
        super(ctx, cd);
        this.ctx = ctx;
    }
    /**
     * @hidden
     */
    ngOnInit() {
        if (this.ctx.grid.selectable === false) {
            this.ctx.grid.selectable = true;
        }
        this.ctx.grid.selectionDirective = this;
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        super.destroy();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SelectionDirective, deps: [{ token: ContextService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: SelectionDirective, isStandalone: true, selector: "[kendoGridSelectBy]", usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SelectionDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridSelectBy]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: ContextService }, { type: i0.ChangeDetectorRef }] });

/**
 * @hidden
 */
class LocalEditService {
    grid;
    localDataChangesService;
    constructor(grid, localDataChangesService) {
        this.grid = grid;
        this.localDataChangesService = localDataChangesService;
    }
    create(item) {
        if (this.hasLocalData && this.grid.skip) {
            this.localDataChangesService.data.splice(this.grid.skip, 0, item);
        }
        else {
            this.data.unshift(item);
        }
        this.dataChanged();
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    update(_item) {
        /* noop */
    }
    remove(item) {
        const data = this.data;
        for (let idx = 0; idx < data.length; idx++) {
            if (item === data[idx]) {
                data.splice(idx, 1);
                this.dataChanged({ action: 'remove', item: item });
                break;
            }
        }
    }
    assignValues(target, source) {
        Object.assign(target, source);
    }
    dataChanged(args = {}) {
        if (this.hasLocalData) {
            this.localDataChangesService.changes.emit(args);
        }
    }
    get hasLocalData() {
        return Array.isArray(this.localDataChangesService.data);
    }
    get data() {
        if (this.hasLocalData) {
            return this.localDataChangesService.data;
        }
        const data = this.grid.data;
        if (Array.isArray(data)) {
            return data;
        }
        if (isDevMode()) {
            throw new Error(GridConfigurationErrorMessages.requiredEditService);
        }
        return [];
    }
}

/**
 * @hidden
 */
class EditingDirectiveBase {
    grid;
    localDataChangesService;
    // Consider adding support for the dependency injection of the service to allow for specifying a generic service without code.
    // The Input should still be kept.
    /**
     * The edit service that will handle the operations.
     */
    set editService(value) {
        this.userEditService = value;
    }
    get editService() {
        return this.userEditService || this.defaultEditService;
    }
    removeConfirmationSubject = new Subject();
    dialogService;
    localization;
    defaultRemoveConfirmation = (_item) => {
        const dialog = this.dialogService.open({
            appendTo: this.grid.dialogContainer,
            title: this.localization.get('removeConfirmationDialogTitle'),
            content: this.localization.get('removeConfirmationDialogContent'),
            actions: [{
                    text: this.localization.get('removeConfirmationDialogConfirmText'),
                    themeColor: 'primary',
                    svgIcon: checkIcon,
                    icon: 'check'
                }, {
                    text: this.localization.get('removeConfirmationDialogRejectText'),
                    svgIcon: xIcon,
                    icon: 'x'
                }],
        });
        dialog.result.pipe(take(1)).subscribe((e) => this.removeConfirmationSubject.next(e.text === this.localization.get('removeConfirmationDialogConfirmText')));
        return this.removeConfirmationSubject;
    };
    /**
     * A function that is called to confirm if the `dataItem` will be removed.
     * By default, the Grid displays its built-in confirmation dialog. To use a custom dialog, provide a `RemoveConfirmationCallback` function.
     * To prevent showing a confirmation dialog, set the `removeConfirmation` property to `false`.
     *
     * @default true
     */
    removeConfirmation = true;
    subscriptions = new Subscription();
    defaultEditService;
    userEditService;
    navigationService;
    constructor(grid, localDataChangesService) {
        this.grid = grid;
        this.localDataChangesService = localDataChangesService;
        this.defaultEditService = this.createDefaultService();
        this.dialogService = inject(DialogService);
        this.localization = inject(LocalizationService);
        this.navigationService = inject(NavigationService);
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this.subscriptions.add(this.grid.add.subscribe(this.addHandler.bind(this)));
        this.subscriptions.add(this.grid.remove.subscribe(this.removeHandler.bind(this)));
        this.subscriptions.add(this.grid.cancel.subscribe(this.cancelHandler.bind(this)));
        this.subscriptions.add(this.grid.save.subscribe(this.saveHandler.bind(this)));
        this.subscriptions.add(this.grid.dataStateChange.subscribe(this.onStateChange.bind(this)));
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    createDefaultService() {
        return new LocalEditService(this.grid, this.localDataChangesService);
    }
    addHandler(_args) {
        this.grid.addRow(this.createModel({ isNew: true }));
    }
    saveHandler(args) {
        const item = this.saveModel(args);
        if (item) {
            if (args.isNew) {
                this.editService.create(item);
            }
            else {
                this.editService.update(item);
            }
        }
        this.grid.closeRow(args.rowIndex);
    }
    cancelHandler({ rowIndex }) {
        this.closeEditor(rowIndex);
    }
    removeHandler({ dataItem }) {
        const removeItem = (shouldRemove) => {
            if (shouldRemove) {
                this.editService.remove(dataItem);
            }
        };
        if (this.removeConfirmation) {
            const confirmationCallback = typeof this.removeConfirmation === 'boolean' ? this.defaultRemoveConfirmation : this.removeConfirmation;
            const result = confirmationCallback(dataItem);
            if (result instanceof Promise) {
                result.then((res) => {
                    removeItem(res);
                    this.returnFocusToGrid();
                });
            }
            else if (result instanceof Observable) {
                result.pipe(take(1)).subscribe((res) => {
                    removeItem(res);
                    this.returnFocusToGrid();
                });
            }
            else {
                removeItem(result);
                this.returnFocusToGrid();
            }
        }
        else {
            removeItem(true);
        }
    }
    onStateChange() {
        this.closeEditor();
    }
    closeEditor(rowIndex) {
        this.grid.closeRow(rowIndex);
    }
    returnFocusToGrid() {
        if (!this.navigationService.focusCell()) {
            this.navigationService.focusPrevCell() || this.navigationService.focusNextCell();
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: EditingDirectiveBase, deps: [{ token: GridComponent }, { token: LocalDataChangesService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: EditingDirectiveBase, isStandalone: true, selector: "[kendoGridEditingDirectiveBase]", inputs: { editService: "editService", removeConfirmation: "removeConfirmation" }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: EditingDirectiveBase, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridEditingDirectiveBase]'
                }]
        }], ctorParameters: () => [{ type: GridComponent }, { type: LocalDataChangesService }], propDecorators: { editService: [{
                type: Input
            }], removeConfirmation: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class LocalRowEditService extends LocalEditService {
    update() {
        this.dataChanged();
    }
}

/**
 * @hidden
 */
class RowEditingDirectiveBase extends EditingDirectiveBase {
    rowIndex;
    /**
     * @hidden
     */
    ngOnInit() {
        super.ngOnInit();
        this.subscriptions
            .add(this.grid.edit.subscribe(this.editHandler.bind(this)));
    }
    createDefaultService() {
        return new LocalRowEditService(this.grid, this.localDataChangesService);
    }
    addHandler() {
        this.closeEditor();
        super.addHandler();
    }
    editHandler(args) {
        this.closeEditor();
        this.rowIndex = args.rowIndex;
        this.grid.editRow(args.rowIndex, this.createModel(args));
    }
    saveHandler(args) {
        super.saveHandler(args);
        this.clean();
    }
    closeEditor(rowIndex = this.rowIndex) {
        super.closeEditor(rowIndex);
        this.clean();
    }
    clean() {
        delete this.rowIndex;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: RowEditingDirectiveBase, deps: null, target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: RowEditingDirectiveBase, isStandalone: true, selector: "[kendoGridRowEditingDirectiveBase]", usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: RowEditingDirectiveBase, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridRowEditingDirectiveBase]'
                }]
        }] });

/**
 * Represents the directive that manages editing operations in the Grid when using Template-Driven Angular Forms ([see example](slug:inline_editing_grid#using-template-driven-forms)).
 *
 * @example
 * ```html
 * <kendo-grid [data]="data" kendoGridTemplateEditing></kendo-grid>
 * ```
 * @remarks
 * Applied to: {@link GridComponent}.
 */
class TemplateEditingDirective extends RowEditingDirectiveBase {
    grid;
    localDataChangesService;
    /**
     * Specifies the function that creates the `dataItem` for new rows.
     */
    createNewItem;
    dataItem;
    originalValues;
    constructor(grid, localDataChangesService) {
        super(grid, localDataChangesService);
        this.grid = grid;
        this.localDataChangesService = localDataChangesService;
    }
    editHandler(args) {
        super.editHandler(args);
        this.dataItem = args.dataItem;
        this.originalValues = {};
        this.editService.assignValues(this.originalValues, this.dataItem);
    }
    closeEditor(rowIndex) {
        if (this.dataItem) {
            this.editService.assignValues(this.dataItem, this.originalValues);
        }
        super.closeEditor(rowIndex);
    }
    createModel(args) {
        if (args.isNew) {
            return this.createNewItem();
        }
    }
    saveModel(args) {
        return args.dataItem;
    }
    clean() {
        super.clean();
        delete this.dataItem;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TemplateEditingDirective, deps: [{ token: GridComponent }, { token: LocalDataChangesService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: TemplateEditingDirective, isStandalone: true, selector: "[kendoGridTemplateEditing]", inputs: { createNewItem: ["kendoGridTemplateEditing", "createNewItem"] }, usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TemplateEditingDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridTemplateEditing]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: GridComponent }, { type: LocalDataChangesService }], propDecorators: { createNewItem: [{
                type: Input,
                args: ['kendoGridTemplateEditing']
            }] } });

/**
 * @hidden
 */
const markAllAsTouched = (control) => {
    control.markAsTouched();
    if (control.hasOwnProperty('controls')) {
        const controls = control.controls;
        for (const inner in controls) {
            if (controls.hasOwnProperty(inner)) {
                markAllAsTouched(controls[inner]);
            }
        }
    }
};

/**
 * Represents the directive that manages editing operations in the Grid when using Reactive Forms ([see example](slug:inline_editing_grid#using-reactive-forms)).
 *
 * @example
 * ```html
 * <kendo-grid [data]="data" kendoGridReactiveEditing></kendo-grid>
 * ```
 * @remarks
 * Applied to: {@link GridComponent}.
 */
class ReactiveEditingDirective extends RowEditingDirectiveBase {
    grid;
    localDataChangesService;
    /**
     * Specifies the function that creates the `FormGroup` for the edited model.
     */
    createFormGroup;
    constructor(grid, localDataChangesService) {
        super(grid, localDataChangesService);
        this.grid = grid;
        this.localDataChangesService = localDataChangesService;
    }
    createModel(args) {
        return this.createFormGroup(args);
    }
    saveModel({ dataItem, formGroup, isNew }) {
        if (!formGroup.dirty && !isNew) {
            return;
        }
        if (formGroup.valid) {
            this.editService.assignValues(dataItem, formGroup.value);
            return dataItem;
        }
        markAllAsTouched(formGroup);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ReactiveEditingDirective, deps: [{ token: GridComponent }, { token: LocalDataChangesService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: ReactiveEditingDirective, isStandalone: true, selector: "[kendoGridReactiveEditing]", inputs: { createFormGroup: ["kendoGridReactiveEditing", "createFormGroup"] }, usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ReactiveEditingDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridReactiveEditing]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: GridComponent }, { type: LocalDataChangesService }], propDecorators: { createFormGroup: [{
                type: Input,
                args: ['kendoGridReactiveEditing']
            }] } });

/**
 * Represent the directive that manages in-cell editing operations in the Grid when using Reactive Forms ([see example](slug:editing_incell_grid#quick-setup)).
 *
 * @example
 * ```html
 * <kendo-grid [data]="data" kendoGridInCellEditing></kendo-grid>
 * ```
 * @remarks
 * Applied to: {@link GridComponent}.
 */
class InCellEditingDirective extends EditingDirectiveBase {
    grid;
    localDataChangesService;
    cdr;
    /**
     * Specifies the function that creates the `FormGroup` for the edited model.
     */
    createFormGroup;
    constructor(grid, localDataChangesService, cdr) {
        super(grid, localDataChangesService);
        this.grid = grid;
        this.localDataChangesService = localDataChangesService;
        this.cdr = cdr;
    }
    // Need mixin
    createModel(args) {
        return this.createFormGroup(args);
    }
    saveModel({ dataItem, formGroup, isNew }) {
        if (!formGroup.dirty && !isNew) {
            return;
        }
        if (formGroup.valid) {
            this.editService.assignValues(dataItem, formGroup.value);
            return dataItem;
        }
        markAllAsTouched(formGroup);
    }
    /**
     * @hidden
     */
    ngOnInit() {
        super.ngOnInit();
        this.subscriptions.add(this.grid.cellClick.subscribe(this.cellClickHandler.bind(this)));
        this.subscriptions.add(this.grid.cellClose.subscribe(this.cellCloseHandler.bind(this)));
    }
    removeHandler(args) {
        super.removeHandler(args);
        this.grid.cancelCell();
    }
    cellClickHandler(args) {
        if (!args.isEdited && args.type !== 'contextmenu') {
            const colIndex = this.grid.isStacked ? args.column.leafIndex : args.columnIndex;
            this.grid.editCell(args.rowIndex, colIndex, this.createFormGroup(args));
            this.cdr.markForCheck();
        }
    }
    cellCloseHandler(args) {
        const { formGroup, dataItem } = args;
        if (!formGroup.valid) {
            args.preventDefault();
        }
        else if (formGroup.dirty) {
            if (args.originalEvent && args.originalEvent.code === Keys.Escape) {
                return;
            }
            this.editService.assignValues(dataItem, formGroup.value);
            this.editService.update(dataItem);
        }
        this.cdr.markForCheck();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: InCellEditingDirective, deps: [{ token: GridComponent }, { token: LocalDataChangesService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: InCellEditingDirective, isStandalone: true, selector: "[kendoGridInCellEditing]", inputs: { createFormGroup: ["kendoGridInCellEditing", "createFormGroup"] }, usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: InCellEditingDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridInCellEditing]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: GridComponent }, { type: LocalDataChangesService }, { type: i0.ChangeDetectorRef }], propDecorators: { createFormGroup: [{
                type: Input,
                args: ['kendoGridInCellEditing']
            }] } });

/**
 * Represents the Kendo UI Grid external editing directive. The directive manages editing operations in the Grid when using the
 * External Form ([see example](slug:external_editing_grid#quick-setup)).
 *
 * @example
 * ```typescript
 * <kendo-grid [data]="data" kendoGridExternalEditing></kendo-grid>
 * ```
 * @remarks
 * Applied to: {@link GridComponent}.
 */
class ExternalEditingDirective extends EditingDirectiveBase {
    grid;
    localDataChangesService;
    adaptiveGridService;
    /**
     * Specifies the function that creates the `FormGroup` for the edited model.
     */
    createFormGroup;
    /**
     * Customizes form orientation, hints, labels, and error messages.
     */
    formSettings;
    /**
     * Customizes the Dialog that contains the edit form.
     */
    dialogSettings;
    constructor(grid, localDataChangesService, adaptiveGridService) {
        super(grid, localDataChangesService);
        this.grid = grid;
        this.localDataChangesService = localDataChangesService;
        this.adaptiveGridService = adaptiveGridService;
    }
    ngOnInit() {
        super.ngOnInit();
        this.subscriptions
            .add(this.grid.edit.subscribe(this.editHandler.bind(this)));
    }
    /**
     * @hidden
     * Opens a Dialog that contains the edit form.
     */
    openEditFormDialog(editEventArgs, formGroup, formSettings) {
        const formControls = this.normalizeFormSettings(formGroup, editEventArgs);
        if (this.grid.adaptiveMode === 'auto' && this.adaptiveGridService.windowSize !== 'large') {
            if (!this.grid.isActionSheetExpanded) {
                this.adaptiveGridService.viewType = 'externalEditing';
                this.grid.adaptiveRenderer.externalEditingSettings = { formControls, formGroup, formSettings, event: editEventArgs, externalEditingDirective: this };
                this.grid.adaptiveRenderer.actionSheet.toggle(true);
            }
        }
        else {
            const settings = { appendTo: this.grid.dialogContainer, content: DialogFormComponent, title: this.localization.get('externalEditingTitle'), ...this.dialogSettings };
            const dialog = this.dialogService.open(settings);
            this.adaptiveGridService.popupRef = dialog;
            dialog.content.setInput('controls', formControls);
            formSettings && dialog.content.setInput('formSettings', formSettings);
            dialog.content.setInput('formGroup', formGroup);
            dialog.result.subscribe((r) => {
                const resultType = r['text'];
                if (resultType === this.localization.get('externalEditingSaveText')) {
                    this.saveHandler({ ...editEventArgs, formGroup });
                }
                dialog.close();
            });
        }
    }
    createModel(args) {
        return this.createFormGroup(args);
    }
    editHandler(args) {
        const formGroup = this.createModel(args);
        this.openEditFormDialog(args, formGroup, this.formSettings);
    }
    saveModel({ dataItem, formGroup, isNew }) {
        if (!formGroup.dirty && !isNew) {
            return;
        }
        if (formGroup.valid) {
            const item = dataItem || [];
            this.editService.assignValues(item, formGroup.value);
            return item;
        }
        markAllAsTouched(formGroup);
    }
    addHandler(args) {
        const formGroup = this.createModel(args);
        this.openEditFormDialog(args, formGroup, this.formSettings);
    }
    normalizeFormSettings(args, editEventArgs) {
        const editableColumnFields = this.grid.columns.toArray().filter(c => c.field && c.editable && isPresent$1(args.get(c.field))).map(c => c.field);
        const settings = editableColumnFields.map(k => {
            const column = this.grid.columns.toArray().find(c => c.field === k);
            const title = column.title || k;
            const template = column.editTemplateRef;
            const templateContext = template ? {
                $implicit: args,
                isNew: editEventArgs.isNew,
                column,
                dataItem: editEventArgs.dataItem,
                formGroup: args,
                rowIndex: editEventArgs.rowIndex
            } : null;
            const customSettings = this.formSettings?.fields?.[k];
            return {
                name: k,
                label: customSettings?.label || title,
                hint: customSettings?.hint,
                errors: customSettings?.errors,
                formControl: args.get(k),
                dataType: column.editor,
                orientation: this.formSettings?.orientation || 'vertical',
                template: template,
                templateContext: templateContext
            };
        });
        return settings.filter(item => isPresent$1(item));
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ExternalEditingDirective, deps: [{ token: GridComponent }, { token: LocalDataChangesService }, { token: AdaptiveGridService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: ExternalEditingDirective, isStandalone: true, selector: "[kendoGridExternalEditing]", inputs: { createFormGroup: ["kendoGridExternalEditing", "createFormGroup"], formSettings: "formSettings", dialogSettings: "dialogSettings" }, usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ExternalEditingDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridExternalEditing]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: GridComponent }, { type: LocalDataChangesService }, { type: AdaptiveGridService }], propDecorators: { createFormGroup: [{
                type: Input,
                args: ['kendoGridExternalEditing']
            }], formSettings: [{
                type: Input
            }], dialogSettings: [{
                type: Input
            }] } });

/**
 * Controls the expanded state of master detail rows in the Grid.
 * Use this directive to manage which detail rows are expanded or collapsed.
 * ([see example](slug:master_detail_expanded_state_grid#toc-built-in-directive))
 *
 * @example
 * ```html
 * <kendo-grid
 *     [kendoGridExpandDetailsBy]="expandDetailsKey"
 *     [expandedDetailKeys]="expandedDetailKeys">
 * </kendo-grid>
 * ```
 * @remarks
 * Applied to: {@link GridComponent}.
 */
class ExpandDetailsDirective {
    grid;
    /**
     * Fires when the `expandedDetailKeys` collection changes.
     */
    expandedDetailKeysChange = new EventEmitter();
    /**
     * Sets the item key stored in the `expandedDetailKeys` collection.
     * Accepts a property name or a function that returns a unique key for each data item.
     * ([See example]({% slug master_detail_expanded_state_grid %}#toc-built-in-directive)).
     */
    get expandDetailsKey() {
        return this._expandBy;
    }
    set expandDetailsKey(key) {
        if (isString(key)) {
            this._expandBy = getter(key);
        }
        else {
            this._expandBy = key;
        }
    }
    /**
     * @hidden
     * A deprecated alias for setting the `expandDetailsKey` property.
     */
    get expandDetailBy() {
        return this.expandDetailsKey;
    }
    set expandDetailBy(key) {
        this.expandDetailsKey = key;
    }
    /**
     * Holds the collection of expanded detail row keys.
     * Set this property to control which detail rows are expanded.
     */
    expandedDetailKeys = [];
    /**
     * Specifies if detail rows are expanded by default.
     * When set to `true`, items in the `expandedDetailKeys` collection are collapsed, and all others are expanded.
     * @default false
     */
    initiallyExpanded = false;
    expandedState = new Set();
    lastExpandedState;
    _expandBy;
    subscriptions = new Subscription();
    constructor(grid) {
        this.grid = grid;
        this.grid.isDetailExpanded = this.isExpanded.bind(this);
        this.subscriptions.add(merge(this.grid.detailExpand.pipe(map(e => ({ expand: true, ...e }))), this.grid.detailCollapse.pipe(map(e => ({ expand: false, ...e })))).subscribe(this.toggleState.bind(this)));
    }
    ngOnChanges(changes) {
        // skip reinitialization if the user data is the same as the last state change
        if (isPresent(changes['expandedDetailKeys']) && this.lastExpandedState !== this.expandedDetailKeys) {
            this.expandedState = new Set(this.expandedDetailKeys);
        }
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    get keyGetter() {
        return this._expandBy || getter(undefined);
    }
    /**
     * @hidden
     */
    isExpanded(args) {
        const key = this.keyGetter(args.dataItem);
        const hasKey = this.expandedState.has(key);
        // when [initiallyExpanded]="true" a present key means the corresponding detail row is collapsed
        return this.initiallyExpanded ? !hasKey : hasKey;
    }
    toggleState(args) {
        const key = this.keyGetter(args.dataItem);
        if (Boolean(this.initiallyExpanded) !== args.expand) {
            this.expandedState.add(key);
        }
        else {
            this.expandedState.delete(key);
        }
        this.notifyChange();
    }
    notifyChange() {
        this.lastExpandedState = Array.from(this.expandedState);
        this.expandedDetailKeysChange.emit(this.lastExpandedState);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ExpandDetailsDirective, deps: [{ token: GridComponent }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: ExpandDetailsDirective, isStandalone: true, selector: "[kendoGridExpandDetailsBy]", inputs: { expandDetailsKey: ["kendoGridExpandDetailsBy", "expandDetailsKey"], expandDetailBy: "expandDetailBy", expandedDetailKeys: "expandedDetailKeys", initiallyExpanded: "initiallyExpanded" }, outputs: { expandedDetailKeysChange: "expandedDetailKeysChange" }, exportAs: ["kendoGridExpandDetailsBy"], usesOnChanges: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ExpandDetailsDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridExpandDetailsBy]',
                    exportAs: 'kendoGridExpandDetailsBy',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: GridComponent }], propDecorators: { expandedDetailKeysChange: [{
                type: Output
            }], expandDetailsKey: [{
                type: Input,
                args: ['kendoGridExpandDetailsBy']
            }], expandDetailBy: [{
                type: Input
            }], expandedDetailKeys: [{
                type: Input
            }], initiallyExpanded: [{
                type: Input
            }] } });

const mapParentGroup = (parentGroup) => {
    const parentGroupKeys = [];
    while (parentGroup) {
        parentGroupKeys.push({ field: parentGroup.group.field, value: parentGroup.group.value });
        parentGroup = parentGroup.parentGroup;
    }
    return parentGroupKeys;
};
const DEFAULT_KEY_GETTER = (groupRowArgs) => ({
    field: groupRowArgs.group.field,
    value: groupRowArgs.group.value,
    parentGroupKeys: mapParentGroup(groupRowArgs.parentGroup)
});
/**
 * Controls the expanded state of group rows in the Grid.
 * Use this directive to manage which group rows are expanded or collapsed
 * ([see example]({% slug groups_expanded_state_grid %}#toc-built-in-directive)).
 *
 * @example
 * ```typescript
 * <kendo-grid [kendoGridExpandGroupBy]="expandGroupBy" [expandedGroupKeys]="expandedGroupKeys"></kendo-grid>
 * ```
 * @remarks
 * Applied to: {@link GridComponent}.
 */
class ExpandGroupDirective {
    grid;
    /**
     * Fires when the `expandedGroupKeys` collection changes.
     */
    expandedGroupKeysChange = new EventEmitter();
    /**
     * Sets the item format stored in the `expandedGroupKeys` collection.
     * Accepts a property name or a function that returns a unique key for each group
     * ([see example]({% slug groups_expanded_state_grid %}#toc-custom-group-key-format)).
     */
    get expandGroupBy() {
        return this._expandGroupBy;
    }
    set expandGroupBy(key) {
        if (typeof key === 'function') {
            this._expandGroupBy = key;
        }
    }
    /**
     * Holds the collection of expanded group keys.
     * Set this property to control which group rows are expanded.
     */
    get expandedGroupKeys() {
        return this._expandedGroupKeys;
    }
    set expandedGroupKeys(expandedGroups) {
        this._expandedGroupKeys = (expandedGroups || []).slice();
    }
    /**
     * Specifies if group items are expanded by default.
     * @default false
     */
    groupsInitiallyExpanded = false;
    _expandGroupBy;
    _expandedGroupKeys;
    subscriptions = new Subscription();
    constructor(grid) {
        this.grid = grid;
        this.grid.isGroupExpanded = this.isExpanded.bind(this);
        this.subscriptions.add(merge(this.grid.groupExpand.pipe(map(e => ({ expand: true, ...e }))), this.grid.groupCollapse.pipe(map(e => ({ expand: false, ...e })))).subscribe(this.toggleState.bind(this)));
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    get keyGetter() {
        return this.expandGroupBy || DEFAULT_KEY_GETTER;
    }
    /**
     * @hidden
     */
    isExpanded(groupArgs) {
        const itemIndex = this.getItemIndex(groupArgs);
        return itemIndex > -1 ? !this.groupsInitiallyExpanded : this.groupsInitiallyExpanded;
    }
    getItemIndex(groupArgs) {
        if (this.expandGroupBy) {
            return this.expandedGroupKeys.indexOf(this.keyGetter(groupArgs));
        }
        return this.expandedGroupKeys.findIndex(item => {
            let index = 0;
            let parentGroup = groupArgs.parentGroup;
            while (isPresent(parentGroup)) {
                if (!isPresent(item.parentGroupKeys) || !isPresent(item.parentGroupKeys[index]) ||
                    parentGroup.group.value !== item.parentGroupKeys[index].value ||
                    parentGroup.group.field !== item.parentGroupKeys[index].field) {
                    return false;
                }
                parentGroup = parentGroup.parentGroup;
                index++;
            }
            return item.value === groupArgs.group.value && item.field === groupArgs.group.field;
        });
    }
    toggleState(groupArgs) {
        const key = this.keyGetter(groupArgs);
        if (Boolean(this.groupsInitiallyExpanded) !== groupArgs.expand) {
            this.expandedGroupKeys.push(key);
        }
        else {
            const index = this.expandedGroupKeys.findIndex(group => {
                if (this.expandGroupBy) {
                    return group === key;
                }
                else if (key.parentGroupKeys?.length === 0) {
                    return group.value === key.value;
                }
                return JSON.stringify(group) === JSON.stringify(key);
            });
            this.expandedGroupKeys.splice(index, 1);
        }
        this.expandedGroupKeysChange.emit(this.expandedGroupKeys.slice());
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ExpandGroupDirective, deps: [{ token: GridComponent }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: ExpandGroupDirective, isStandalone: true, selector: "[kendoGridExpandGroupBy]", inputs: { expandGroupBy: ["kendoGridExpandGroupBy", "expandGroupBy"], expandedGroupKeys: "expandedGroupKeys", groupsInitiallyExpanded: "groupsInitiallyExpanded" }, outputs: { expandedGroupKeysChange: "expandedGroupKeysChange" }, exportAs: ["kendoGridExpandGroupBy"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ExpandGroupDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridExpandGroupBy]',
                    exportAs: 'kendoGridExpandGroupBy',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: GridComponent }], propDecorators: { expandedGroupKeysChange: [{
                type: Output
            }], expandGroupBy: [{
                type: Input,
                args: ['kendoGridExpandGroupBy']
            }], expandedGroupKeys: [{
                type: Input
            }], groupsInitiallyExpanded: [{
                type: Input
            }] } });

/**
 * Represents the Kendo UI GridSpacer component for Angular.
 * Used to give additional white space between the Pager inner elements,
 * and provides a way for customizing the spacer width.
 * It can also be used in any flex container within the Grid
 * ([see example](slug:toolbartemplate_grid#toc-defining-the-spacing-between-toolbar-elements)).
 *
 * @example
 * ```html
 * <kendo-grid [data]="data">
 *   <ng-template kendoGridToolbarTemplate>
 *     <kendo-grid-spacer></kendo-grid-spacer>
 *       <button type="button" kendoGridExcelCommand [svgIcon]="fileExcelIcon"> Export to Excel </button>
 *     <kendo-grid-spacer></kendo-grid-spacer>
 *   </ng-template>
 *   <kendo-grid-column field="ProductName" title="Product Name"></kendo-grid-column>
 * </kendo-grid>
 * ```
 */
class GridSpacerComponent {
    hostClass = true;
    get sizedClass() {
        return isPresent(this.width);
    }
    get flexBasisStyle() {
        return this.width;
    }
    /**
     * Specifies the width of the GridSpacer.
     * Accepts string values for the [CSS `flex-basis`](https://developer.mozilla.org/en-US/docs/Web/CSS/flex-basis) property.
     * If not set, the GridSpacer takes all available space.
     */
    width;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GridSpacerComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: GridSpacerComponent, isStandalone: true, selector: "kendo-grid-spacer", inputs: { width: "width" }, host: { properties: { "class.k-spacer": "this.hostClass", "class.k-spacer-sized": "this.sizedClass", "style.flexBasis": "this.flexBasisStyle" } }, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GridSpacerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-spacer',
                    template: ``,
                    standalone: true
                }]
        }], propDecorators: { hostClass: [{
                type: HostBinding,
                args: ['class.k-spacer']
            }], sizedClass: [{
                type: HostBinding,
                args: ['class.k-spacer-sized']
            }], flexBasisStyle: [{
                type: HostBinding,
                args: ['style.flexBasis']
            }], width: [{
                type: Input
            }] } });

/**
 * Adds keyboard navigation support to toolbar elements in the Grid.
 *
 * Apply this directive to toolbar elements that should be focusable and navigable with the keyboard.
 *
 * @example
 * ```html
 * <kendo-toolbar>
 *   <button kendoGridToolbarFocusable>Button</button>
 * </kendo-toolbar>
 * ```
 */
class GridToolbarFocusableDirective {
    host;
    ctx;
    /**
     * @hidden
     */
    get element() {
        return this.host.nativeElement;
    }
    /**
     * @hidden
     */
    get toolbarPosition() {
        return isDocumentAvailable() && this.host.nativeElement.closest('.k-toolbar')?.getAttribute('position');
    }
    constructor(host, ctx) {
        this.host = host;
        this.ctx = ctx;
    }
    ngAfterViewInit() {
        if (!isDocumentAvailable() || !this.toolbarPosition || !this.isToolbarNavigable) {
            return;
        }
        this.ctx[`${this.toolbarPosition}ToolbarNavigation`]?.navigableElements.push(this.element);
        this.ctx[`${this.toolbarPosition}ToolbarNavigation`]?.notify();
    }
    ngOnDestroy() {
        if (!isDocumentAvailable() || !this.toolbarPosition) {
            return;
        }
        const elements = this.ctx[`${this.toolbarPosition}ToolbarNavigation`].navigableElements;
        this.ctx[`${this.toolbarPosition}ToolbarNavigation`].navigableElements = elements.filter(el => el !== this.element);
        this.ctx[`${this.toolbarPosition}ToolbarNavigation`].notify();
    }
    get isToolbarNavigable() {
        if (typeof this.ctx.grid.navigable === 'boolean') {
            return this.ctx.grid.navigable;
        }
        if (Array.isArray(this.ctx.grid.navigable)) {
            return this.ctx.grid.navigable.includes('toolbar');
        }
        return false;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GridToolbarFocusableDirective, deps: [{ token: i0.ElementRef }, { token: ContextService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: GridToolbarFocusableDirective, isStandalone: true, selector: "\n        [kendoGridToolbarFocusable],\n        [kendoGridAddCommand],\n        [kendoGridCancelCommand],\n        [kendoGridEditCommand],\n        [kendoGridRemoveCommand],\n        [kendoGridSaveCommand],\n        [kendoGridExcelCommand],\n        [kendoGridPDFCommand]\n    ", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GridToolbarFocusableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: `
        [kendoGridToolbarFocusable],
        [kendoGridAddCommand],
        [kendoGridCancelCommand],
        [kendoGridEditCommand],
        [kendoGridRemoveCommand],
        [kendoGridSaveCommand],
        [kendoGridExcelCommand],
        [kendoGridPDFCommand]
    `,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: ContextService }] });

/**
 * Enables built-in clipboard support for the Grid. Allows copy, cut, and paste interactions.
 *
 * @example
 * ```html
 * <kendo-grid kendoGridClipboard></kendo-grid>
 * ```
 * @remarks
 * Applied to: {@link GridComponent}.
 */
class GridClipboardDirective {
    host;
    clipboardService;
    renderer;
    zone;
    /**
     * Sets the clipboard operation target. Possible values are `'activeCell'` and `'selection'`.([See example]({% slug clipboard_grid %}#toc-clipboard-target))
     *
     * @default 'selection'
     */
    set clipboardTarget(value) {
        if (isDevMode()) {
            this.zone.onStable.pipe(take(1)).subscribe(() => {
                if (value === 'activeCell' && !(this.host.navigable.length)) {
                    console.warn(ClipboardErrorMessages.clipboardTarget.activeCellNavigable);
                }
                else if (value === 'selection' && !(this.host.selectable || this.host.selectionDirective)) {
                    console.warn(ClipboardErrorMessages.selectionSelectable);
                }
            });
        }
        this._target = value;
    }
    get clipboardTarget() {
        return this._target;
    }
    /**
     * Configures the clipboard directive settings.
     *
     * @default { wholeRow: false, copyHeaders: false, copy: true, cut: true, paste: true }
     */
    set clipboardSettings(value) {
        this._clipboardSettings = Object.assign({}, this._clipboardSettings, value);
    }
    get clipboardSettings() {
        return this._clipboardSettings;
    }
    /**
     * Fires when a clipboard action (`cut`, `copy`, or `paste`) occurs in the Grid.
     */
    clipboard = new EventEmitter();
    _target = 'selection';
    _clipboardSettings = {
        wholeRow: false,
        copyHeaders: false,
        copy: true,
        cut: true,
        paste: true
    };
    subs = new Subscription();
    constructor(host, clipboardService, renderer, zone) {
        this.host = host;
        this.clipboardService = clipboardService;
        this.renderer = renderer;
        this.zone = zone;
    }
    ngAfterViewInit() {
        if (!isDocumentAvailable()) {
            return;
        }
        if (this.clipboardTarget === 'selection' && !(this.host.selectable || this.host.selectionDirective)) {
            console.warn(ClipboardErrorMessages.selectionSelectable);
        }
        // needed due to the following issue in Chrome
        // https://bugs.chromium.org/p/chromium/issues/detail?id=1156117&q=focus%20programmatically%20paste&can=2
        this.zone.runOutsideAngular(() => {
            this.subs.add(this.renderer.listen(document, 'copy', (args) => this.onClipboard('copy', args)));
            this.subs.add(this.renderer.listen(document, 'cut', (args) => this.onClipboard('cut', args)));
            this.subs.add(this.renderer.listen(document, 'paste', (args) => this.onClipboard('paste', args)));
        });
    }
    ngOnDestroy() {
        this.subs.unsubscribe();
    }
    onClipboard = (operationType, args) => {
        if (!this.clipboardSettings[operationType] || !this.inGrid(args)) {
            return;
        }
        const gridData = Array.isArray(this.host.data) ? this.host.data : this.host.data.data;
        const gridDataItems = gridData.flatMap(recursiveFlatMap);
        const selection = this.host.selection;
        const selectionDirective = this.host.selectionDirective;
        const targetType = this.clipboardTarget;
        const isCellSelection = (this.host.selectable?.cell || selectionDirective.isCellSelectionMode);
        let clipboardData = [];
        switch (targetType) {
            case 'activeCell':
                {
                    const targetCell = { ...this.host.activeCell };
                    clipboardData = targetCell && [{ dataItem: targetCell.dataItem, dataRowIndex: targetCell.dataRowIndex, colIndex: targetCell.colIndex }];
                }
                break;
            case 'selection':
                {
                    const identifier = selectionDirective.selectionKey;
                    clipboardData = gridDataItems.flatMap((item, index) => {
                        if (identifier) {
                            const key = typeof identifier === 'string' ? item[identifier] : identifier({ index: index + this.host.skip, dataItem: item });
                            return isCellSelection ?
                                selection.some(s => s.itemKey === key) ? [{ dataItem: item, dataRowIndex: index + this.host.skip }] : [] :
                                selection.indexOf(key) > -1 ? [{ dataItem: item, dataRowIndex: index + this.host.skip }] : [];
                        }
                        return isCellSelection ?
                            selection.some(s => s.itemKey === index + this.host.skip) ? [{ dataItem: item, dataRowIndex: index + this.host.skip }] : [] :
                            selection.indexOf(index + this.host.skip) > -1 ? [{ dataItem: item, dataRowIndex: index + this.host.skip }] : [];
                    });
                }
                break;
        }
        const isPaste = operationType === 'paste';
        const pastedData = args.clipboardData.getData('text');
        const visibleCols = this.host.columns.toArray().filter(c => c.isVisible);
        if (visibleCols.some(c => c.orderIndex > 0)) { // columns have been reordered
            visibleCols.sort((a, b) => a.orderIndex - b.orderIndex);
        }
        const data = isPaste ?
            {
                dataString: pastedData,
                gridItems: this.clipboardService.getGridData(pastedData, visibleCols, this.clipboardTarget, clipboardData[0]?.dataRowIndex, {
                    wholeRow: this.clipboardSettings.wholeRow,
                    isCellSelection
                })
            } :
            this.clipboardService.createClipboardData(clipboardData || [], visibleCols, {
                wholeRow: this.clipboardSettings.wholeRow || (this.clipboardTarget === 'selection' && !isCellSelection),
                target: this.clipboardTarget,
                copyHeaders: this.clipboardSettings.copyHeaders,
                operationType
            });
        !isPaste && navigator.clipboard.writeText(data.dataString);
        if (hasObservers(this.clipboard)) {
            this.zone.run(() => {
                this.clipboard.emit({
                    type: operationType,
                    originalEvent: args,
                    clipboardData: data.dataString,
                    gridData: data.gridItems,
                    target: {
                        dataRowIndex: this.clipboardService.targetRowIndex,
                        colField: this.clipboardService.targetColField,
                        dataItem: clipboardData.find(item => item.dataRowIndex === this.clipboardService.targetRowIndex)?.dataItem
                    }
                });
            });
        }
        this.clipboardService.targetColField = this.clipboardService.targetRowIndex = null;
    };
    inGrid = (args) => {
        const target = document.activeElement.matches('.k-table-td') ? document.activeElement : args.target;
        const inContentArea = closest(target, node => node.parentElement?.classList.contains('k-grid-container'));
        const inHost = contains$1(this.host.wrapper.nativeElement, target);
        return target && inHost && inContentArea;
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GridClipboardDirective, deps: [{ token: GridComponent }, { token: ClipboardService }, { token: i0.Renderer2 }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: GridClipboardDirective, isStandalone: true, selector: "[kendoGridClipboard]", inputs: { clipboardTarget: "clipboardTarget", clipboardSettings: "clipboardSettings" }, outputs: { clipboard: "clipboard" }, providers: [ClipboardService], exportAs: ["kendoGridClipboard"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GridClipboardDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridClipboard]',
                    exportAs: 'kendoGridClipboard',
                    providers: [ClipboardService],
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: GridComponent }, { type: ClipboardService }, { type: i0.Renderer2 }, { type: i0.NgZone }], propDecorators: { clipboardTarget: [{
                type: Input
            }], clipboardSettings: [{
                type: Input
            }], clipboard: [{
                type: Output
            }] } });

/**
 * Represents the PDF export toolbar tool of the Grid.
 * Apply this directive to any `kendo-toolbar-button` element inside a ToolbarComponent in the Grid.
 * When you click the toolbar button with this directive, the [`pdfExport`]({% slug api_grid_gridcomponent %}#toc-pdfexport) event fires. ([See example]({% slug pdfexport_grid %})).
 *
 * @example
 * ```html
 * <kendo-grid>
 *      <kendo-toolbar>
 *         <kendo-toolbar-button text="Export to PDF" kendoGridPDFTool></kendo-toolbar-button>
 *      </kendo-toolbar>
 *      <kendo-grid-pdf fileName="products.pdf"></kendo-grid-pdf>
 * </kendo-grid>
 * ```
 * @remarks
 * Applied to: {@link ToolBarButtonComponent}.
 */
class PDFCommandToolbarDirective extends ToolbarToolBase {
    pdfService;
    host;
    constructor(pdfService, host, ctx, zone, cdr) {
        super(host, ToolbarToolName.pdfExport, ctx, zone, cdr);
        this.pdfService = pdfService;
        this.host = host;
    }
    ngOnInit() {
        super.ngOnInit();
        this.host.className = 'k-grid-pdf';
    }
    /**
     * @hidden
     */
    onClick(e) {
        e.preventDefault();
        this.pdfService.exportClick.emit();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PDFCommandToolbarDirective, deps: [{ token: PDFService }, { token: i54.ToolBarButtonComponent }, { token: ContextService }, { token: i0.NgZone }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: PDFCommandToolbarDirective, isStandalone: true, selector: "[kendoGridPDFTool]", usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PDFCommandToolbarDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridPDFTool]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: PDFService }, { type: i54.ToolBarButtonComponent }, { type: ContextService }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }] });

/**
 * Represents the **Export to Excel** toolbar tool of the Grid.
 * Apply this directive to any `kendo-toolbar-button` element inside a ToolbarComponent used in the Grid.
 * When the user clicks the button, the [`excelExport`]({% slug api_grid_gridcomponent %}#toc-excelexport) event fires ([see example]({% slug excelexport_grid %})).
 *
 * @example
 * ```html
 * <kendo-grid>
 *   <kendo-toolbar>
 *     <kendo-toolbar-button text="Excel Export" kendoGridExcelTool></kendo-toolbar-button>
 *   </kendo-toolbar>
 *   <kendo-grid-excel fileName="Grid.xlsx"></kendo-grid-excel>
 * </kendo-grid>
 * ```
 * @remarks
 * Applied to: {@link ToolBarButtonComponent}.
 */
class ExcelCommandToolbarDirective extends ToolbarToolBase {
    excelService;
    constructor(excelService, host, ctx, zone, cdr) {
        super(host, ToolbarToolName.excelExport, ctx, zone, cdr);
        this.excelService = excelService;
    }
    ngOnInit() {
        super.ngOnInit();
        this.host.className = 'k-grid-excel';
    }
    /**
     * @hidden
     */
    onClick(e) {
        e.preventDefault();
        this.excelService.exportClick.emit();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ExcelCommandToolbarDirective, deps: [{ token: ExcelService }, { token: i54.ToolBarButtonComponent }, { token: ContextService }, { token: i0.NgZone }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: ExcelCommandToolbarDirective, isStandalone: true, selector: "[kendoGridExcelTool]", usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ExcelCommandToolbarDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridExcelTool]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: ExcelService }, { type: i54.ToolBarButtonComponent }, { type: ContextService }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }] });

/**
 * @hidden
 */
class ToolbarEditingToolBase extends ToolbarToolBase {
    host;
    commandName;
    ctx;
    editService;
    selection;
    isEdited = false;
    lastToolState = null;
    constructor(host, commandName, ctx, zone, cdr, editService, selection) {
        super(host, commandName, ctx, zone, cdr);
        this.host = host;
        this.commandName = commandName;
        this.ctx = ctx;
        this.editService = editService;
        this.selection = selection;
    }
    ngAfterViewInit() {
        super.ngAfterViewInit();
        const commandText = this.ctx.localization.get(`${this.commandName}ToolbarToolText`);
        this.buttonElement?.setAttribute('title', commandText);
    }
    ngDoCheck() {
        if (!isPresent$1(this.editService)) {
            return;
        }
        this.isEdited = this.editService.isEditing();
        const isAddNewItem = this.editService.hasNewItem;
        let isToolInactive = false;
        let formGroup;
        const selectionPresent = isPresent$1(this.lastSelectionIndex);
        if (this.isEdited || isAddNewItem) {
            formGroup = isAddNewItem ? this.editService.context()?.group : this.editService.editedIndices[0].group;
        }
        switch (this.commandName) {
            case ToolbarToolName.edit:
                isToolInactive = this.isEdited || !selectionPresent;
                break;
            case ToolbarToolName.save:
                isToolInactive = !(this.isEdited || isAddNewItem) || !formGroup?.valid;
                break;
            case ToolbarToolName.remove:
                isToolInactive = this.isEdited || !selectionPresent;
                break;
            case ToolbarToolName.cancel:
                isToolInactive = !(this.isEdited || isAddNewItem);
                break;
        }
        if (this.lastToolState !== isToolInactive) {
            this.lastToolState = isToolInactive;
            if (this.ctx.grid.showInactiveTools) {
                this.host.disabled = isToolInactive;
            }
            else if (this.host.isHidden !== isToolInactive) {
                this.host.isHidden = isToolInactive;
                const toolbar = this.host.host;
                toolbar.refreshService.refresh(this.host);
                this.zone.onStable.pipe(take(1)).subscribe(() => {
                    toolbar.onResize();
                });
            }
        }
    }
    get lastSelectionIndex() {
        return this.selection?.selected[this.selection?.selected.length - 1];
    }
    get isSelectionPresent() {
        return isPresent$1(this.lastSelectionIndex) && this.lastSelectionIndex > -1;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ToolbarEditingToolBase, deps: [{ token: i54.ToolBarButtonComponent }, { token: 'command' }, { token: ContextService }, { token: i0.NgZone }, { token: i0.ChangeDetectorRef }, { token: EditService }, { token: SelectionService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: ToolbarEditingToolBase, isStandalone: true, usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ToolbarEditingToolBase, decorators: [{
            type: Directive,
            args: [{}]
        }], ctorParameters: () => [{ type: i54.ToolBarButtonComponent }, { type: undefined, decorators: [{
                    type: Inject,
                    args: ['command']
                }] }, { type: ContextService }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }, { type: EditService }, { type: SelectionService }] });

/**
 * Represents the command for adding a new item to the Grid.
 * You can apply this directive to any `kendo-toolbar-button` element inside a ToolbarComponent used in the Grid.
 * When you click the toolbar button associated with the directive, the [`add`]({% slug api_grid_gridcomponent %}#toc-add) event triggers ([see example]({% slug basics_editing_grid %})).
 *
 * @example
 * ```html
 * <kendo-grid>
 *      <kendo-toolbar>
 *         <kendo-toolbar-button text="Add new" kendoGridAddTool></kendo-toolbar-button>
 *      </kendo-toolbar>
 * </kendo-grid>
 * ```
 * @remarks
 * Applied to: {@link ToolBarButtonComponent}.
 */
class AddCommandToolbarDirective extends ToolbarEditingToolBase {
    editService;
    host;
    constructor(editService, host, ctx, zone, cdr) {
        super(host, ToolbarToolName.add, ctx, zone, cdr, editService);
        this.editService = editService;
        this.host = host;
    }
    ngOnInit() {
        super.ngOnInit();
        this.host.className = 'k-grid-add-command';
    }
    /**
     * @hidden
     */
    onClick(e) {
        e.preventDefault();
        this.editService.beginAdd();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AddCommandToolbarDirective, deps: [{ token: EditService }, { token: i54.ToolBarButtonComponent }, { token: ContextService }, { token: i0.NgZone }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: AddCommandToolbarDirective, isStandalone: true, selector: "[kendoGridAddTool]", usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AddCommandToolbarDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridAddTool]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: EditService }, { type: i54.ToolBarButtonComponent }, { type: ContextService }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }] });

/**
 * @hidden
 * A linked-list based implementation of an undo-redo stack.
 * Maintains a chain of states that can be navigated forward and backward.
 */
class UndoRedoStack {
    maxSize;
    /** The current active node in the undo-redo history */
    currentNode = null;
    /** The root node of the stack (first state) */
    rootNode = null;
    /** Track the size of the stack */
    _size = 0;
    /**
     * Creates a new UndoRedoStack.
     * @param maxSize Optional maximum number of states to maintain (unlimited if not provided)
     */
    constructor(maxSize = -1) {
        this.maxSize = maxSize;
    }
    /**
     * Gets the current number of states in the stack
     */
    get size() {
        return this._size;
    }
    /**
     * Gets the current active state
     */
    get current() {
        return this.currentNode ? this.currentNode.state : null;
    }
    /**
     * Checks if undo is available (if there's a previous state)
     */
    get canUndo() {
        return isPresent$1(this.currentNode?.previous);
    }
    /**
     * Checks if redo is available (if there's a next state)
     */
    get canRedo() {
        return isPresent$1(this.currentNode?.next);
    }
    /**
     * Adds a new state to the undo-redo stack
     * @param state The state to add
     * @param id Optional identifier for the state
     * @returns The newly created node
     */
    add(state, id) {
        const newNode = {
            state,
            previous: this.currentNode,
            next: null,
            id
        };
        // If we have a current node, update its next reference
        if (this.currentNode) {
            // If we're adding after a node that already had a "next",
            // we need to discard that branch of history
            if (this.currentNode.next) {
                this.truncateForward(this.currentNode);
            }
            this.currentNode.next = newNode;
        }
        else {
            // This is the first node
            this.rootNode = newNode;
        }
        this.currentNode = newNode;
        this._size++;
        // If we've exceeded the max size, remove oldest nodes
        this.enforceMaxSize();
        return newNode;
    }
    /**
     * Finds a node by its identifier
     * @param id The identifier to search for
     * @returns The found node or null if not found
     */
    find(id) {
        if (!this.rootNode) {
            return null;
        }
        let node = this.rootNode;
        while (node) {
            if (node.id === id) {
                return node;
            }
            node = node.next;
        }
        return null;
    }
    /**
     * Removes a node by its identifier
     * @param id The identifier of the node to remove
     * @returns True if the node was found and removed, false otherwise
     */
    remove(id) {
        const nodeToRemove = this.find(id);
        if (!nodeToRemove) {
            return false;
        }
        // Handle removal of current node
        if (nodeToRemove === this.currentNode) {
            this.currentNode = nodeToRemove.previous || nodeToRemove.next;
        }
        // Connect previous and next nodes
        if (nodeToRemove.previous) {
            nodeToRemove.previous.next = nodeToRemove.next;
        }
        else {
            // Removing the root node
            this.rootNode = nodeToRemove.next;
        }
        if (nodeToRemove.next) {
            nodeToRemove.next.previous = nodeToRemove.previous;
        }
        // Clean up references to help garbage collection
        nodeToRemove.previous = null;
        nodeToRemove.next = null;
        this._size--;
        return true;
    }
    /**
     * Performs an undo operation, moving to the previous state
     * @returns The previous state or null if can't undo
     */
    undo() {
        if (!this.canUndo) {
            return null;
        }
        this.currentNode = this.currentNode.previous;
        return this.currentNode.state;
    }
    peekNext() {
        return this.currentNode.next?.state || null;
    }
    peekPrev() {
        return this.currentNode.previous?.state || null;
    }
    /**
     * Performs a redo operation, moving to the next state
     * @returns The next state or null if can't redo
     */
    redo() {
        if (!this.canRedo) {
            return null;
        }
        this.currentNode = this.currentNode.next;
        return this.currentNode.state;
    }
    /**
     * Clears all history
     */
    clear() {
        this.currentNode = null;
        this.rootNode = null;
        this._size = 0;
    }
    /**
     * Removes all states after the specified node
     * @param node The node to truncate from
     * @returns The number of nodes removed
     */
    truncateForward(node) {
        if (!node.next) {
            return 0;
        }
        let removedCount = 0;
        let currentNext = node.next;
        while (currentNext) {
            const temp = currentNext.next;
            // Clean up references for garbage collection
            currentNext.previous = null;
            currentNext.next = null;
            currentNext = temp;
            removedCount++;
        }
        // Update the node's next pointer
        node.next = null;
        this._size -= removedCount;
        return removedCount;
    }
    /**
     * Ensures the stack doesn't exceed the maximum size by removing oldest nodes
     */
    enforceMaxSize() {
        if (this.maxSize <= 0 || this._size <= this.maxSize) {
            return;
        }
        let nodesToRemove = this._size - this.maxSize;
        let currentNode = this.rootNode;
        // Find the new root node
        while (nodesToRemove > 0 && currentNode) {
            currentNode = currentNode.next;
            nodesToRemove--;
        }
        if (currentNode) {
            // Disconnect from previous history
            currentNode.previous = null;
            // Update root node
            this.rootNode = currentNode;
            // Update size
            this._size = this.maxSize;
        }
    }
    /**
     * Gets all states in the stack as an array (from oldest to newest)
     */
    toArray() {
        const result = [];
        let node = this.rootNode;
        while (node) {
            result.push(node.state);
            node = node.next;
        }
        return result;
    }
    /**
     * Gets the history nodes as an array (useful for debugging)
     */
    getNodes() {
        const result = [];
        let node = this.rootNode;
        while (node) {
            result.push(node);
            node = node.next;
        }
        return result;
    }
}

/**
 * Provides arguments for the `undo` and `redo` events.
 */
class UndoRedoEvent extends PreventableEvent$1 {
    /**
     * The event data for the action that changed the state.
     */
    originalEvent;
    /**
     * The Grid state and rendered data at the time of the action.
     */
    gridState;
    /**
     * @hidden
     */
    constructor({ originalEvent, gridState }) {
        super();
        this.originalEvent = originalEvent;
        this.gridState = gridState;
    }
}

/**
 * @hidden
 */
class UndoRedoService {
    originalEvent;
    onUndo = new Subject();
    onRedo = new Subject();
    stackEndReached = new Subject();
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: UndoRedoService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: UndoRedoService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: UndoRedoService, decorators: [{
            type: Injectable
        }] });

/**
 * Represents the directive that manages undo-redo operations in the Grid.
 * Use this directive to enable undo and redo functionality for user actions in the Grid.
 *
 * @example
 * ```html
 * <kendo-grid [data]="data" kendoGridUndoRedo></kendo-grid>
 * ```
 * @remarks
 * Applied to: {@link GridComponent}.
 */
class UndoRedoDirective {
    host;
    editService;
    undoRedoService;
    changeNotification;
    ctx;
    localDataChangesService;
    /**
     * Sets the maximum number of actions to keep in the undo-redo stack.
     * @default 10
     */
    maxStoredStates = 10;
    /**
     * Defines the property name of the data item unique key that will be used to identify the items when performing undo-redo actions.
     */
    itemIdKey;
    /**
     * Fires when you perform the undo action. Provides the Grid state to apply.
     */
    onUndo = new EventEmitter();
    /**
     * Fires when you perform the redo action. Provides the Grid state to apply.
     */
    onRedo = new EventEmitter();
    /**
     * Returns all undo-redo actions currently in the stack.
     */
    get undoRedoItems() {
        return this.stack.toArray();
    }
    stack;
    subs = new Subscription();
    addToState = true;
    constructor(host, editService, undoRedoService, changeNotification, ctx, localDataChangesService) {
        this.host = host;
        this.editService = editService;
        this.undoRedoService = undoRedoService;
        this.changeNotification = changeNotification;
        this.ctx = ctx;
        this.localDataChangesService = localDataChangesService;
        this.host.undoRedoService = this.undoRedoService;
    }
    ngOnInit() {
        this.stack = new UndoRedoStack(this.maxStoredStates);
        this.subs = this.host.gridStateChange.subscribe((state) => {
            if (this.addToState) {
                this.stack.add({
                    originalEvent: {
                        skip: state.skip,
                        take: state.take,
                        sort: state.sort,
                        filter: state.filter,
                        group: state.group
                    },
                    gridState: state
                });
            }
            let stackEndPointReached;
            if (this.stack.canUndo) {
                stackEndPointReached = this.stack.canRedo ? false : 'end';
            }
            else {
                stackEndPointReached = 'start';
            }
            this.undoRedoService.stackEndReached.next(stackEndPointReached);
        });
        this.subs.add(this.editService.changes
            .pipe(filter((event) => event.action === 'save' || event.action === 'remove'))
            .subscribe(event => {
            this.stack.add({
                originalEvent: { ...event, dataItem: structuredClone(event.dataItem) },
                gridState: this.host.currentState
            });
            this.addToState = false;
            this.host.gridStateChange.emit(this.stack.current.gridState);
            this.addToState = true;
            this.updateUndoRedoDisabled();
        }));
        this.subs.add(this.changeNotification.changes.subscribe(() => {
            if (!this.ctx.dataBindingDirective) {
                this.stack.current.gridState = this.host.currentState;
            }
        }));
        ['Undo', 'Redo'].forEach((action) => {
            this.subs.add(this.undoRedoService[`on${action}`].subscribe(() => {
                if (!this.stack[`can${action}`]) {
                    return;
                }
                let eventData;
                if (action === 'Undo') {
                    const isSaveOrRemove = this.stack.current.originalEvent.action === 'save' || this.stack.current.originalEvent.action === 'remove';
                    eventData = isSaveOrRemove ? this.stack.current : this.stack.peekPrev();
                }
                else {
                    eventData = this.stack.peekNext();
                }
                const event = new UndoRedoEvent(eventData);
                if (hasObservers(this[`on${action}`])) {
                    this[`on${action}`].emit(event);
                    if (event.isDefaultPrevented()) {
                        return;
                    }
                }
                this.stack[`${action.toLowerCase()}`]();
                this.updateUndoRedoDisabled();
                const originalAction = event.originalEvent.action;
                const isLocalData = isPresent$1(this.ctx?.dataBindingDirective);
                if (!isLocalData) {
                    return;
                }
                const isSaveOrRemove = originalAction === 'save' || originalAction === 'remove';
                if (isSaveOrRemove) {
                    if (originalAction === 'save') {
                        const stateItem = this.getGridDataItems(this.stack.current.gridState.currentData).find(item => item[this.itemIdKey] === event.originalEvent.dataItem[this.itemIdKey]);
                        this.localDataChangesService?.data.splice(event.originalEvent.rowIndex, 1, stateItem);
                    }
                    else if (action === 'Undo') {
                        this.localDataChangesService?.data.splice(event.originalEvent.rowIndex, 0, event.originalEvent.dataItem);
                    }
                    else {
                        this.localDataChangesService?.data.splice(event.originalEvent.rowIndex, 1);
                    }
                    this.localDataChangesService?.changes.emit();
                }
                else {
                    this.host.loadState({ ...this.stack.current.gridState, currentData: null });
                    if (this.isDataStateChangeEvent(event.originalEvent)) {
                        const { skip, take, sort, filter, group } = event.gridState;
                        this.host.dataStateChange.emit({ skip, take, sort, filter, group });
                    }
                }
            }));
        });
    }
    ngAfterViewInit() {
        this.stack.add({
            originalEvent: {
                skip: this.host.skip,
                take: this.host.pageSize,
                sort: this.host.sort,
                filter: this.host.filter,
                group: this.host.group
            }, gridState: this.host.currentState
        });
    }
    ngOnDestroy() {
        this.stack.clear();
        this.stack = null;
        this.subs.unsubscribe();
    }
    /**
     * Re-applies the last action that you reverted with the `undo` method.
     */
    redo() {
        if (this.stack.canRedo) {
            this.stack.redo();
            this.host.loadState(this.stack.current.gridState);
            if (!this.stack.canRedo) {
                this.undoRedoService.stackEndReached.next('end');
            }
        }
    }
    /**
     * Reverts the last user action that you performed.
     */
    undo() {
        if (this.stack.canUndo) {
            this.stack.undo();
            this.host.loadState(this.stack.current.gridState);
            if (!this.stack.canUndo) {
                this.undoRedoService.stackEndReached.next('start');
            }
        }
    }
    updateUndoRedoDisabled() {
        if (!this.stack.canRedo) {
            this.undoRedoService.stackEndReached.next('end');
            return;
        }
        if (!this.stack.canUndo) {
            this.undoRedoService.stackEndReached.next('start');
            return;
        }
        this.undoRedoService.stackEndReached.next(false);
    }
    getGridDataItems(data) {
        return Array.isArray(data) ? data.flatMap(recursiveFlatMap) :
            data.data.flatMap(recursiveFlatMap);
    }
    isDataStateChangeEvent(event) {
        return event && ['skip', 'take', 'sort', 'filter', 'group'].some(prop => prop in event);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: UndoRedoDirective, deps: [{ token: GridComponent }, { token: EditService }, { token: UndoRedoService }, { token: ChangeNotificationService }, { token: ContextService }, { token: LocalDataChangesService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: UndoRedoDirective, isStandalone: true, selector: "[kendoGridUndoRedo]", inputs: { maxStoredStates: "maxStoredStates", itemIdKey: "itemIdKey" }, outputs: { onUndo: "undo", onRedo: "redo" }, providers: [UndoRedoService], exportAs: ["kendoGridUndoRedo"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: UndoRedoDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridUndoRedo]',
                    standalone: true,
                    exportAs: 'kendoGridUndoRedo',
                    providers: [UndoRedoService]
                }]
        }], ctorParameters: () => [{ type: GridComponent }, { type: EditService }, { type: UndoRedoService }, { type: ChangeNotificationService }, { type: ContextService }, { type: LocalDataChangesService }], propDecorators: { maxStoredStates: [{
                type: Input
            }], itemIdKey: [{
                type: Input
            }], onUndo: [{
                type: Output,
                args: ['undo']
            }], onRedo: [{
                type: Output,
                args: ['redo']
            }] } });

/**
 * Represents the command that triggers the undo action in the Grid.
 * Apply this directive to any `kendo-toolbar-button` inside a ToolbarComponent in the Grid.
 *
 * When users click the toolbar button with this directive, the
 * [`undo`]({% slug api_grid_undoredodirective %}#toc-undo) event is triggered.
 *
 * @example
 * ```html
 * <kendo-grid>
 *      <kendo-toolbar>
 *         <kendo-toolbar-button kendoGridUndoTool></kendo-toolbar-button>
 *      </kendo-toolbar>
 * </kendo-grid>
 * ```
 */
class UndoCommandToolbarDirective {
    undoRedoService;
    host;
    subs = new Subscription();
    /**
     * @hidden
     */
    constructor(undoRedoService, host) {
        this.undoRedoService = undoRedoService;
        this.host = host;
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this.subs = this.host.click.subscribe((e) => this.onClick(e));
        this.host.className = 'k-grid-undo-command';
        this.host.svgIcon = undoIcon;
        this.host.icon = 'undo';
        this.host.text = 'Undo';
        this.host.disabled = true;
        this.subs.add(this.undoRedoService.stackEndReached.subscribe((stackEnd) => (this.host.disabled = stackEnd === 'start')));
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.subs.unsubscribe();
    }
    /**
     * @hidden
     */
    onClick(e) {
        e.preventDefault();
        this.undoRedoService.onUndo.next(undefined);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: UndoCommandToolbarDirective, deps: [{ token: UndoRedoService }, { token: i54.ToolBarButtonComponent }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: UndoCommandToolbarDirective, isStandalone: true, selector: "[kendoGridUndoTool]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: UndoCommandToolbarDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridUndoTool]',
                    standalone: true,
                }]
        }], ctorParameters: () => [{ type: UndoRedoService }, { type: i54.ToolBarButtonComponent }] });

/**
 * Represents the command that triggers the redo action in the Grid.
 * Apply this directive to any `kendo-toolbar-button` inside a ToolbarComponent in the Grid.
 *
 * When users click the toolbar button with this directive, the
 * [`redo`]({% slug api_grid_undoredodirective %}#toc-redo) event is triggered.
 *
 * @example
 * ```html
 * <kendo-grid>
 *      <kendo-toolbar>
 *         <kendo-toolbar-button kendoGridRedoTool></kendo-toolbar-button>
 *      </kendo-toolbar>
 * </kendo-grid>
 * ```
 */
class RedoCommandToolbarDirective {
    undoRedoService;
    host;
    subs = new Subscription();
    /**
     * @hidden
     */
    constructor(undoRedoService, host) {
        this.undoRedoService = undoRedoService;
        this.host = host;
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this.subs = this.host.click.subscribe((e) => this.onClick(e));
        this.host.className = 'k-grid-redo-command';
        this.host.svgIcon = redoIcon;
        this.host.icon = 'redo';
        this.host.text = 'Redo';
        this.host.disabled = true;
        this.subs.add(this.undoRedoService.stackEndReached.subscribe((stackEnd) => (this.host.disabled = stackEnd === 'end')));
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.subs.unsubscribe();
    }
    /**
     * @hidden
     */
    onClick(e) {
        e.preventDefault();
        this.undoRedoService.onRedo.next(undefined);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: RedoCommandToolbarDirective, deps: [{ token: UndoRedoService }, { token: i54.ToolBarButtonComponent }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: RedoCommandToolbarDirective, isStandalone: true, selector: "[kendoGridRedoTool]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: RedoCommandToolbarDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridRedoTool]',
                    standalone: true,
                }]
        }], ctorParameters: () => [{ type: UndoRedoService }, { type: i54.ToolBarButtonComponent }] });

let incrementingId$2 = 0;
/**
 * Represents the toolbar tool for sorting columns of the Grid.
 * Use this directive on any `kendo-toolbar-button` inside a ToolbarComponent in the Grid.
 *
 * When you click the toolbar button with this directive, the `sort` event is triggered.
 *
 * @example
 * ```html-no-run
 * <kendo-grid>
 *      <kendo-toolbar>
 *         <kendo-toolbar-button text="Sort" kendoGridSortTool></kendo-toolbar-button>
 *      </kendo-toolbar>
 * </kendo-grid>
 * ```
 * @remarks
 * Applied to: {@link ToolBarButtonComponent}.
 */
class SortCommandToolbarDirective {
    host;
    popupService;
    ctx;
    sortService;
    columnInfoService;
    ngZone;
    renderer;
    adaptiveGridService;
    popupRef;
    nextId = incrementingId$2++;
    toolSubs = new Subscription();
    popupSubs;
    actionSheetCloseSub;
    removeClickListener;
    /**
     * @hidden
     */
    isSortingApplied(sort) {
        return isPresent$1(sort) && sort.length > 0 && sort.filter(item => item.dir !== undefined).length > 0;
    }
    constructor(host, popupService, ctx, sortService, columnInfoService, ngZone, renderer, adaptiveGridService) {
        this.host = host;
        this.popupService = popupService;
        this.ctx = ctx;
        this.sortService = sortService;
        this.columnInfoService = columnInfoService;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.adaptiveGridService = adaptiveGridService;
    }
    ngOnInit() {
        this.toolSubs = this.host.click.subscribe(e => this.onClick(e));
        this.toolSubs.add(this.sortService.changes.subscribe(sort => {
            this.host.showBadge = this.isSortingApplied(sort);
        }));
        this.host.hasBadgeContainer = true;
        this.host.showBadge = this.isSortingApplied(this.ctx.grid.sort);
        const hasToolbarIcon = isPresent$1(this.host.toolbarOptions.icon) && this.host.toolbarOptions.icon !== '';
        const hasOverflowIcon = isPresent$1(this.host.overflowOptions.icon) && this.host.overflowOptions.icon !== '';
        const hasIcon = hasToolbarIcon && hasOverflowIcon;
        const hasSvgIcon = isPresent$1(this.host.toolbarOptions.svgIcon) && isPresent$1(this.host.overflowOptions.svgIcon);
        if (!hasIcon) {
            this.host.icon = 'arrows-swap';
        }
        if (!hasSvgIcon) {
            this.host.svgIcon = arrowsSwapIcon;
        }
    }
    ngAfterViewInit() {
        if (!isPresent$1(this.host.text)) {
            this.ngZone.onStable.pipe(take(1)).subscribe(() => {
                this.host.text = this.ctx.localization.get(`sortToolbarToolText`);
            });
        }
        this.buttonElement?.setAttribute('aria-haspopup', 'dialog');
        this.buttonElement?.setAttribute('aria-expanded', 'false');
        this.buttonElement?.setAttribute('title', this.ctx.localization.get('sortToolbarToolText'));
    }
    ngOnDestroy() {
        if (this.toolSubs) {
            this.toolSubs.unsubscribe();
        }
        if (this.popupSubs) {
            this.popupSubs.unsubscribe();
        }
        if (this.popupRef) {
            this.popupRef.close();
            this.popupRef = null;
        }
        if (this.actionSheetCloseSub) {
            this.actionSheetCloseSub.unsubscribe();
            this.actionSheetCloseSub = null;
        }
        if (this.removeClickListener) {
            this.removeClickListener();
            this.removeClickListener = null;
        }
    }
    onClick(e) {
        e.preventDefault();
        if (this.ctx.grid.adaptiveMode === 'auto' && this.adaptiveGridService.windowSize !== 'large') {
            if (!this.ctx.grid.isActionSheetExpanded) {
                this.adaptiveGridService.viewType = 'sortToolbarTool';
                this.ctx.grid.adaptiveRenderer.actionSheet.toggle(true);
                this.host.selected = true;
                this.actionSheetCloseSub = this.ctx.grid.adaptiveRenderer.actionSheet.collapse.subscribe(() => this.host.selected = false);
            }
        }
        else {
            if (this.popupRef) {
                this.closePopup();
                return;
            }
            this.openPopup();
        }
    }
    openPopup() {
        const direction = this.ctx.localization.rtl ? 'right' : 'left';
        this.popupRef = this.popupService.open({
            anchor: this.buttonElement,
            content: SortToolbarToolComponent,
            popupClass: 'k-grid-columnmenu-popup',
            positionMode: 'absolute',
            anchorAlign: { vertical: 'bottom', horizontal: direction },
            popupAlign: { vertical: 'top', horizontal: direction }
        });
        this.adaptiveGridService.popupRef = this.popupRef;
        this.setPopupAttributes();
        this.host.selected = true;
        this.ngZone.runOutsideAngular(() => {
            if (!isDocumentAvailable()) {
                return;
            }
            this.removeClickListener = this.renderer.listen('document', 'click', (e) => {
                if (this.popupRef && !closest$1(e.target, node => node === this.popupRef.popupElement || node === this.buttonElement)) {
                    this.ngZone.run(() => {
                        this.closePopup();
                    });
                }
            });
        });
        this.popupSubs = this.popupRef.popup.instance.anchorViewportLeave.subscribe(() => {
            this.popupSubs?.unsubscribe();
            this.popupSubs = null;
            this.closePopup();
        });
        this.initPopupProperties();
    }
    setPopupAttributes() {
        const popupElement = this.popupRef.popupElement;
        const popupId = `k-sort-tool-${this.nextId}-popup`;
        const popupAriaElement = popupElement.querySelector('.k-popup');
        this.renderer.setAttribute(popupElement, 'dir', this.ctx.localization.rtl ? 'rtl' : 'ltr');
        this.renderer.setAttribute(popupAriaElement, 'id', popupId);
        this.renderer.setAttribute(popupAriaElement, 'role', 'dialog');
        this.buttonElement?.setAttribute('aria-expanded', 'true');
        this.buttonElement?.setAttribute('aria-controls', popupId);
    }
    initPopupProperties() {
        this.popupRef.content.instance.columnInfoService = this.columnInfoService;
        this.popupRef.content.instance.ctx = this.ctx;
        this.popupRef.content.instance.sortService = this.sortService;
        this.popupRef.content.instance.hostButton = this.host;
        this.popupSubs.add(this.popupRef.content.instance.sortClear.subscribe(() => {
            this.closePopup();
        }));
        this.popupSubs.add(this.popupRef.content.instance.close.subscribe(() => {
            this.closePopup();
        }));
    }
    closePopup() {
        this.buttonElement?.setAttribute('aria-expanded', 'false');
        this.buttonElement?.removeAttribute('aria-controls');
        this.host.selected = false;
        if (this.popupRef) {
            this.popupRef.close();
            this.popupRef = null;
        }
        if (this.popupSubs) {
            this.popupSubs.unsubscribe();
            this.popupSubs = null;
        }
        if (this.removeClickListener) {
            this.removeClickListener();
            this.removeClickListener = null;
        }
    }
    get buttonElement() {
        return this.host.getButton();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SortCommandToolbarDirective, deps: [{ token: i54.ToolBarButtonComponent }, { token: i2.PopupService }, { token: ContextService }, { token: SortService }, { token: ColumnInfoService }, { token: i0.NgZone }, { token: i0.Renderer2 }, { token: AdaptiveGridService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: SortCommandToolbarDirective, isStandalone: true, selector: "[kendoGridSortTool]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SortCommandToolbarDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridSortTool]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i54.ToolBarButtonComponent }, { type: i2.PopupService }, { type: ContextService }, { type: SortService }, { type: ColumnInfoService }, { type: i0.NgZone }, { type: i0.Renderer2 }, { type: AdaptiveGridService }] });

/**
 * @hidden
 */
class FilterToolWrapperComponent {
    injector;
    container;
    wrapperClasses = true;
    onEscKeyDown(event) {
        event.preventDefault();
        this.close.emit();
        this.hostButton?.focus(event);
    }
    onClick(event) {
        if (this.hostButton.location !== 'toolbar') {
            event.stopImmediatePropagation();
        }
    }
    close = new EventEmitter();
    hostButton;
    clearIcon = filterClearIcon;
    columnInfoService;
    set ctx(ctx) {
        this._ctx = ctx;
        this.filter = ctx.grid.filter;
        this.createPopup();
    }
    get ctx() {
        return this._ctx;
    }
    set filterService(filterService) {
        this._filterService = filterService;
        this.subscriptions = this._filterService.changes.subscribe(filter => {
            this.filter = filter;
        });
        this.createPopup();
    }
    get filterService() {
        return this._filterService;
    }
    columnMenuService;
    popupRef;
    filter;
    subscriptions;
    _ctx;
    _filterService;
    constructor(injector) {
        this.injector = injector;
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
        if (this.popupRef) {
            this.popupRef.destroy();
            this.popupRef = null;
        }
    }
    clear() {
        if (!this.filter || this.filter.filters?.length === 0) {
            return;
        }
        this.filter = { logic: 'and', filters: [] };
        this.popupRef.instance.filter = cloneFilters(this.filter);
        this.filterService.filter(this.filter);
        this.close.emit();
    }
    createPopup() {
        if (this._ctx && this._filterService && this.container && !this.popupRef) {
            const customInjector = Injector.create({
                providers: [
                    { provide: FilterService, useValue: this._filterService },
                    { provide: ContextService, useValue: this._ctx },
                    { provide: ColumnInfoService, useValue: this.columnInfoService },
                    AdaptiveGridService,
                    SinglePopupService,
                    ScrollSyncService
                ],
                parent: this.injector
            });
            this.popupRef = this.container.createComponent(FilterToolbarToolComponent, {
                injector: customInjector
            });
            this.subscriptions.add(this.popupRef.instance.close.subscribe(() => this.close.emit()));
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FilterToolWrapperComponent, deps: [{ token: i0.Injector }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: FilterToolWrapperComponent, isStandalone: true, selector: "kendo-filter-tool-wrapper", outputs: { close: "close" }, host: { listeners: { "keydown.escape": "onEscKeyDown($event)", "click": "onClick($event)" }, properties: { "class.k-column-menu": "this.wrapperClasses", "class.k-column-menu-md": "this.wrapperClasses" } }, viewQueries: [{ propertyName: "container", first: true, predicate: ["container"], descendants: true, read: ViewContainerRef, static: true }], ngImport: i0, template: `
        <ng-container #container></ng-container>
        <div class="k-actions k-actions-stretched k-actions-horizontal k-column-menu-footer">
            <button kendoButton
                    [svgIcon]="clearIcon"
                    icon="filter-clear"
                    (click)="clear()">
                    {{ctx?.localization.get('filterClearAllButton')}}
            </button>
        </div>
    `, isInline: true, dependencies: [{ kind: "component", type: i1$6.ButtonComponent, selector: "button[kendoButton]", inputs: ["arrowIcon", "toggleable", "togglable", "selected", "tabIndex", "imageUrl", "iconClass", "icon", "disabled", "size", "rounded", "fillMode", "themeColor", "svgIcon", "primary", "look"], outputs: ["selectedChange", "click"], exportAs: ["kendoButton"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FilterToolWrapperComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-filter-tool-wrapper',
                    template: `
        <ng-container #container></ng-container>
        <div class="k-actions k-actions-stretched k-actions-horizontal k-column-menu-footer">
            <button kendoButton
                    [svgIcon]="clearIcon"
                    icon="filter-clear"
                    (click)="clear()">
                    {{ctx?.localization.get('filterClearAllButton')}}
            </button>
        </div>
    `,
                    standalone: true,
                    imports: [KENDO_BUTTON]
                }]
        }], ctorParameters: () => [{ type: i0.Injector }], propDecorators: { container: [{
                type: ViewChild,
                args: ['container', { read: ViewContainerRef, static: true }]
            }], wrapperClasses: [{
                type: HostBinding,
                args: ['class.k-column-menu']
            }, {
                type: HostBinding,
                args: ['class.k-column-menu-md']
            }], onEscKeyDown: [{
                type: HostListener,
                args: ['keydown.escape', ['$event']]
            }], onClick: [{
                type: HostListener,
                args: ['click', ['$event']]
            }], close: [{
                type: Output
            }] } });

let incrementingId$1 = 0;
/**
 * Represents the toolbar tool for filtering columns of the Grid.
 * Use this directive on any `kendo-toolbar-button` inside a ToolbarComponent in the Grid.
 *
 * When you click the toolbar button with this directive, the `filter` event is triggered.
 *
 * @example
 * ```html
 * <kendo-grid>
 *      <kendo-toolbar>
 *         <kendo-toolbar-button text="Filter" kendoGridFilterTool></kendo-toolbar-button>
 *      </kendo-toolbar>
 * </kendo-grid>
 * ```
 * @remarks
 * Applied to: {@link ToolBarButtonComponent}.
 */
class FilterCommandToolbarDirective {
    host;
    popupService;
    ctx;
    filterService;
    columnInfoService;
    ngZone;
    renderer;
    adaptiveGridService;
    popupRef;
    nextId = incrementingId$1++;
    toolSubs = new Subscription();
    popupSubs;
    actionSheetCloseSub;
    removeClickListener;
    /**
     * @hidden
     */
    isFilterApplied(filter) {
        return isPresent$1(filter) && filter.filters?.length > 0;
    }
    constructor(host, popupService, ctx, filterService, columnInfoService, ngZone, renderer, adaptiveGridService) {
        this.host = host;
        this.popupService = popupService;
        this.ctx = ctx;
        this.filterService = filterService;
        this.columnInfoService = columnInfoService;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.adaptiveGridService = adaptiveGridService;
    }
    ngOnInit() {
        this.toolSubs = this.host.click.subscribe(e => this.onClick(e));
        this.toolSubs.add(this.filterService.changes.subscribe(filter => {
            this.host.showBadge = this.isFilterApplied(filter);
        }));
        this.host.hasBadgeContainer = true;
        this.host.showBadge = this.isFilterApplied(this.ctx.grid.filter);
        const hasToolbarIcon = isPresent$1(this.host.toolbarOptions.icon) && this.host.toolbarOptions.icon !== '';
        const hasOverflowIcon = isPresent$1(this.host.overflowOptions.icon) && this.host.overflowOptions.icon !== '';
        const hasIcon = hasToolbarIcon && hasOverflowIcon;
        const hasSvgIcon = isPresent$1(this.host.toolbarOptions.svgIcon) && isPresent$1(this.host.overflowOptions.svgIcon);
        if (!hasIcon) {
            this.host.icon = 'filter';
        }
        if (!hasSvgIcon) {
            this.host.svgIcon = filterIcon;
        }
    }
    ngAfterViewInit() {
        if (!isPresent$1(this.host.text)) {
            this.ngZone.onStable.pipe(take(1)).subscribe(() => {
                this.host.text = this.ctx.localization.get(`filterToolbarToolText`);
            });
        }
        this.buttonElement?.setAttribute('aria-haspopup', 'dialog');
        this.buttonElement?.setAttribute('aria-expanded', 'false');
        this.buttonElement?.setAttribute('title', this.ctx.localization.get('filterToolbarToolText'));
    }
    ngOnDestroy() {
        if (this.toolSubs) {
            this.toolSubs.unsubscribe();
        }
        if (this.popupSubs) {
            this.popupSubs.unsubscribe();
        }
        if (this.popupRef) {
            this.popupRef.close();
            this.popupRef = null;
        }
        if (this.actionSheetCloseSub) {
            this.actionSheetCloseSub.unsubscribe();
            this.actionSheetCloseSub = null;
        }
        if (this.removeClickListener) {
            this.removeClickListener();
            this.removeClickListener = null;
        }
    }
    onClick(e) {
        e.preventDefault();
        if (this.popupRef) {
            this.closePopup();
            return;
        }
        this.openPopup();
    }
    openPopup() {
        const direction = this.ctx.localization.rtl ? 'right' : 'left';
        if (this.ctx.grid.adaptiveMode === 'auto' && this.adaptiveGridService.windowSize !== 'large') {
            if (!this.ctx.grid.isActionSheetExpanded) {
                this.adaptiveGridService.viewType = 'filterToolbarTool';
                this.ctx.grid.adaptiveRenderer.actionSheet.toggle(true);
                this.host.selected = true;
                this.actionSheetCloseSub = this.ctx.grid.adaptiveRenderer.actionSheet.collapse.subscribe(() => this.host.selected = false);
            }
        }
        else {
            this.popupRef = this.popupService.open({
                anchor: this.buttonElement,
                content: FilterToolWrapperComponent,
                popupClass: 'k-grid-columnmenu-popup',
                positionMode: 'absolute',
                anchorAlign: { vertical: 'bottom', horizontal: direction },
                popupAlign: { vertical: 'top', horizontal: direction }
            });
            this.adaptiveGridService.popupRef = this.popupRef;
            this.setPopupAttributes();
            this.host.selected = true;
            this.ngZone.runOutsideAngular(() => {
                if (!isDocumentAvailable()) {
                    return;
                }
                this.removeClickListener = this.renderer.listen('document', 'click', (e) => {
                    if (this.popupRef && !closest$1(e.target, node => node === this.popupRef.popupElement || node === this.buttonElement)) {
                        this.ngZone.run(() => {
                            this.closePopup();
                        });
                    }
                });
            });
            this.popupSubs = this.popupRef.popup.instance.anchorViewportLeave.subscribe(() => {
                this.popupSubs?.unsubscribe();
                this.popupSubs = null;
                this.closePopup();
            });
            this.initPopupProperties();
        }
    }
    setPopupAttributes() {
        const popupElement = this.popupRef.popupElement;
        const popupId = `k-filter-tool-${this.nextId}-popup`;
        const popupAriaElement = popupElement.querySelector('.k-popup');
        this.renderer.setAttribute(popupElement, 'dir', this.ctx.localization.rtl ? 'rtl' : 'ltr');
        this.renderer.setAttribute(popupAriaElement, 'id', popupId);
        this.renderer.setAttribute(popupAriaElement, 'role', 'dialog');
        this.buttonElement?.setAttribute('aria-expanded', 'true');
        this.buttonElement?.setAttribute('aria-controls', popupId);
    }
    initPopupProperties() {
        this.popupRef.content.instance.columnInfoService = this.columnInfoService;
        this.popupRef.content.instance.ctx = this.ctx;
        this.popupRef.content.instance.filterService = this.filterService;
        this.popupRef.content.instance.hostButton = this.host;
        this.popupSubs.add(this.popupRef.content.instance.close.subscribe(() => {
            this.closePopup();
        }));
    }
    closePopup() {
        this.buttonElement?.setAttribute('aria-expanded', 'false');
        this.buttonElement?.removeAttribute('aria-controls');
        this.host.selected = false;
        if (this.popupRef) {
            this.popupRef.close();
            this.popupRef = null;
        }
        if (this.popupSubs) {
            this.popupSubs.unsubscribe();
            this.popupSubs = null;
        }
        if (this.removeClickListener) {
            this.removeClickListener();
            this.removeClickListener = null;
        }
    }
    get buttonElement() {
        return this.host.getButton();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FilterCommandToolbarDirective, deps: [{ token: i54.ToolBarButtonComponent }, { token: i2.PopupService }, { token: ContextService }, { token: FilterService }, { token: ColumnInfoService }, { token: i0.NgZone }, { token: i0.Renderer2 }, { token: AdaptiveGridService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: FilterCommandToolbarDirective, isStandalone: true, selector: "[kendoGridFilterTool]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FilterCommandToolbarDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridFilterTool]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i54.ToolBarButtonComponent }, { type: i2.PopupService }, { type: ContextService }, { type: FilterService }, { type: ColumnInfoService }, { type: i0.NgZone }, { type: i0.Renderer2 }, { type: AdaptiveGridService }] });

/**
 * Represents the `edit` command in the Grid. Apply this directive to any `kendo-toolbar-button`
 * element inside a ToolbarComponent used in the Grid.
 *
 * When you click the toolbar button with this directive, the
 * [`edit`]({% slug api_grid_gridcomponent %}#toc-edit) event fires.
 *
 * @example
 * ```html
 * <kendo-grid>
 *   <kendo-toolbar>
 *     <kendo-toolbar-button text="Edit" kendoGridEditTool></kendo-toolbar-button>
 *   </kendo-toolbar>
 * </kendo-grid>
 * ```
 * @remarks
 * Applied to: {@link ToolBarButtonComponent}.
 */
class EditCommandToolbarDirective extends ToolbarEditingToolBase {
    editService;
    constructor(editService, host, selection, ctx, zone, cdr) {
        super(host, ToolbarToolName.edit, ctx, zone, cdr, editService, selection);
        this.editService = editService;
    }
    /**
     * @hidden
     */
    onClick(e) {
        e.preventDefault();
        if (!this.isSelectionPresent) {
            return;
        }
        this.editService.beginEdit(this.lastSelectionIndex);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: EditCommandToolbarDirective, deps: [{ token: EditService }, { token: i54.ToolBarButtonComponent }, { token: SelectionService }, { token: ContextService }, { token: i0.NgZone }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: EditCommandToolbarDirective, isStandalone: true, selector: "[kendoGridEditTool]", usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: EditCommandToolbarDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridEditTool]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: EditService }, { type: i54.ToolBarButtonComponent }, { type: SelectionService }, { type: ContextService }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }] });

/**
 * Represents the `save` command in the Grid. Apply this directive to any `kendo-toolbar-button`
 * element inside a ToolbarComponent used in the Grid.
 *
 * When you click the toolbar button with this directive, the
 * [`save`]({% slug api_grid_gridcomponent %}#toc-save) event fires.
 *
 * @example
 * ```html
 * <kendo-grid>
 *      <kendo-toolbar>
 *         <kendo-toolbar-button text="Save" kendoGridSaveTool></kendo-toolbar-button>
 *      </kendo-toolbar>
 * </kendo-grid>
 * ```
 * @remarks
 * Applied to: {@link ToolBarButtonComponent}.
 */
class SaveCommandToolbarDirective extends ToolbarEditingToolBase {
    editService;
    constructor(editService, host, selection, ctx, zone, cdr) {
        super(host, ToolbarToolName.save, ctx, zone, cdr, editService, selection);
        this.editService = editService;
    }
    /**
     * @hidden
     */
    onClick(e) {
        e.preventDefault();
        if (this.editService.hasNewItem) {
            this.editService.save();
        }
        else if (this.isSelectionPresent && this.editService.isEdited(this.lastSelectionIndex)) {
            this.editService.save(this.lastSelectionIndex);
        }
        else {
            this.editService.editedIndices.forEach(i => this.editService.save(i.index));
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SaveCommandToolbarDirective, deps: [{ token: EditService }, { token: i54.ToolBarButtonComponent }, { token: SelectionService }, { token: ContextService }, { token: i0.NgZone }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: SaveCommandToolbarDirective, isStandalone: true, selector: "[kendoGridSaveTool]", usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SaveCommandToolbarDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridSaveTool]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: EditService }, { type: i54.ToolBarButtonComponent }, { type: SelectionService }, { type: ContextService }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }] });

/**
 * Represents the `remove` command in the Grid. Apply this directive to any `kendo-toolbar-button`
 * element inside a ToolbarComponent used in the Grid.
 *
 * When you click the toolbar button with this directive, the
 * [`remove`]({% slug api_grid_gridcomponent %}#toc-remove) event fires.
 *
 * @example
 * ```html
 * <kendo-grid>
 *   <kendo-toolbar>
 *      <kendo-toolbar-button text="Remove row" kendoGridRemoveTool></kendo-toolbar-button>
 *   </kendo-toolbar>
 * </kendo-grid>
 * ```
 * @remarks
 * Applied to: {@link ToolBarButtonComponent}.
 */
class RemoveCommandToolbarDirective extends ToolbarEditingToolBase {
    editService;
    selection;
    constructor(editService, host, selection, ctx, zone, cdr) {
        super(host, ToolbarToolName.remove, ctx, zone, cdr, editService, selection);
        this.editService = editService;
        this.selection = selection;
    }
    /**
     * @hidden
     */
    onClick(e) {
        e.preventDefault();
        if (this.isSelectionPresent) {
            this.editService.remove(this.lastSelectionIndex);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: RemoveCommandToolbarDirective, deps: [{ token: EditService }, { token: i54.ToolBarButtonComponent }, { token: SelectionService }, { token: ContextService }, { token: i0.NgZone }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: RemoveCommandToolbarDirective, isStandalone: true, selector: "[kendoGridRemoveTool]", usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: RemoveCommandToolbarDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridRemoveTool]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: EditService }, { type: i54.ToolBarButtonComponent }, { type: SelectionService }, { type: ContextService }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }] });

/**
 * Represents the `cancel` command in the Grid.
 * Apply this directive to any `kendo-toolbar-button` element inside a ToolbarComponent in the Grid.
 *
 * When you click the toolbar button with this directive, the [`cancel`]({% slug api_grid_gridcomponent %}#toc-cancel) event triggers.
 *
 * @example
 * ```html
 * <kendo-grid>
 *      <kendo-toolbar>
 *         <kendo-toolbar-button text="Cancel" kendoGridCancelTool></kendo-toolbar-button>
 *      </kendo-toolbar>
 * </kendo-grid>
 * ```
 * @remarks
 * Applied to: {@link ToolBarButtonComponent}.
 */
class CancelCommandToolbarDirective extends ToolbarEditingToolBase {
    editService;
    constructor(editService, host, selection, ctx, zone, cdr) {
        super(host, ToolbarToolName.cancel, ctx, zone, cdr, editService, selection);
        this.editService = editService;
    }
    /**
     * @hidden
     */
    onClick(e) {
        e.preventDefault();
        if (this.editService.hasNewItem) {
            this.editService.endEdit();
        }
        else if (this.isSelectionPresent && this.editService.isEdited(this.lastSelectionIndex)) {
            this.editService.endEdit(this.lastSelectionIndex);
        }
        else {
            this.editService.editedIndices.forEach(i => this.editService.endEdit(i.index));
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CancelCommandToolbarDirective, deps: [{ token: EditService }, { token: i54.ToolBarButtonComponent }, { token: SelectionService }, { token: ContextService }, { token: i0.NgZone }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: CancelCommandToolbarDirective, isStandalone: true, selector: "[kendoGridCancelTool]", usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CancelCommandToolbarDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridCancelTool]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: EditService }, { type: i54.ToolBarButtonComponent }, { type: SelectionService }, { type: ContextService }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }] });

let incrementingId = 0;
/**
 * Represents the toolbar tool for grouping columns of the Grid.
 * Use this directive on any `kendo-toolbar-button` inside a ToolbarComponent in the Grid.
 * When you click the toolbar button with this directive, the `group` event is triggered.
 *
 * @example
 * ```html
 * <kendo-grid>
 *      <kendo-toolbar>
 *         <kendo-toolbar-button text="Group" kendoGridGroupTool></kendo-toolbar-button>
 *      </kendo-toolbar>
 * </kendo-grid>
 * ```
 * @remarks
 * Applied to: {@link ToolBarButtonComponent}.
 */
class GroupCommandToolbarDirective {
    host;
    popupService;
    ctx;
    ngZone;
    renderer;
    adaptiveGridService;
    popupRef;
    nextId = incrementingId++;
    toolSubs = new Subscription();
    popupSubs;
    actionSheetCloseSub;
    removeClickListener;
    constructor(host, popupService, ctx, ngZone, renderer, adaptiveGridService) {
        this.host = host;
        this.popupService = popupService;
        this.ctx = ctx;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.adaptiveGridService = adaptiveGridService;
    }
    ngOnInit() {
        this.toolSubs = this.host.click.subscribe(e => this.onClick(e));
        this.toolSubs.add(this.ctx.grid.groupChange.subscribe(group => {
            this.host.showBadge = this.isGroupingApplied(group);
        }));
        this.host.hasBadgeContainer = true;
        this.host.showBadge = this.isGroupingApplied(this.ctx.grid.group);
        const hasToolbarIcon = isPresent$1(this.host.toolbarOptions.icon) && this.host.toolbarOptions.icon !== '';
        const hasOverflowIcon = isPresent$1(this.host.overflowOptions.icon) && this.host.overflowOptions.icon !== '';
        const hasIcon = hasToolbarIcon && hasOverflowIcon;
        const hasSvgIcon = isPresent$1(this.host.toolbarOptions.svgIcon) && isPresent$1(this.host.overflowOptions.svgIcon);
        if (!hasIcon) {
            this.host.icon = 'group';
        }
        if (!hasSvgIcon) {
            this.host.svgIcon = groupIcon;
        }
    }
    ngAfterViewInit() {
        if (!isPresent$1(this.host.text)) {
            this.ngZone.onStable.pipe(take(1)).subscribe(() => {
                this.host.text = this.ctx.localization.get(`groupToolbarToolText`);
            });
        }
        this.buttonElement?.setAttribute('aria-haspopup', 'dialog');
        this.buttonElement?.setAttribute('aria-expanded', 'false');
        this.buttonElement?.setAttribute('title', this.ctx.localization.get('groupToolbarToolText'));
    }
    ngOnDestroy() {
        if (this.toolSubs) {
            this.toolSubs.unsubscribe();
        }
        if (this.popupSubs) {
            this.popupSubs.unsubscribe();
        }
        if (this.popupRef) {
            this.popupRef.close();
            this.popupRef = null;
        }
        if (this.actionSheetCloseSub) {
            this.actionSheetCloseSub.unsubscribe();
            this.actionSheetCloseSub = null;
        }
        if (this.removeClickListener) {
            this.removeClickListener();
            this.removeClickListener = null;
        }
    }
    onClick(e) {
        e.preventDefault();
        if (this.ctx.grid.adaptiveMode === 'auto' && this.adaptiveGridService.windowSize !== 'large') {
            if (!this.ctx.grid.isActionSheetExpanded) {
                this.adaptiveGridService.viewType = 'groupToolbarTool';
                this.ctx.grid.adaptiveRenderer.actionSheet.toggle(true);
                this.host.selected = true;
                this.actionSheetCloseSub = this.ctx.grid.adaptiveRenderer.actionSheet.collapse.subscribe(() => this.host.selected = false);
            }
        }
        else {
            if (this.popupRef) {
                this.closePopup();
                return;
            }
            this.openPopup();
        }
    }
    openPopup() {
        const direction = this.ctx.localization.rtl ? 'right' : 'left';
        this.popupRef = this.popupService.open({
            anchor: this.buttonElement,
            content: GroupToolbarToolComponent,
            popupClass: 'k-grid-columnmenu-popup',
            positionMode: 'absolute',
            anchorAlign: { vertical: 'bottom', horizontal: direction },
            popupAlign: { vertical: 'top', horizontal: direction }
        });
        this.adaptiveGridService.popupRef = this.popupRef;
        this.setPopupAttributes();
        this.host.selected = true;
        this.ngZone.runOutsideAngular(() => {
            if (!isDocumentAvailable()) {
                return;
            }
            this.removeClickListener = this.renderer.listen('document', 'click', (e) => {
                if (this.popupRef && !closest$1(e.target, node => node === this.popupRef.popupElement || node === this.buttonElement)) {
                    this.ngZone.run(() => {
                        this.closePopup();
                    });
                }
            });
        });
        this.popupSubs = this.popupRef.popup.instance.anchorViewportLeave.subscribe(() => {
            this.popupSubs?.unsubscribe();
            this.popupSubs = null;
            this.closePopup();
        });
        this.initPopupProperties();
    }
    setPopupAttributes() {
        const popupElement = this.popupRef.popupElement;
        const popupId = `k-group-tool-${this.nextId}-popup`;
        const popupAriaElement = popupElement.querySelector('.k-popup');
        this.renderer.setAttribute(popupElement, 'dir', this.ctx.localization.rtl ? 'rtl' : 'ltr');
        this.renderer.setAttribute(popupAriaElement, 'id', popupId);
        this.renderer.setAttribute(popupAriaElement, 'role', 'dialog');
        this.buttonElement?.setAttribute('aria-expanded', 'true');
        this.buttonElement?.setAttribute('aria-controls', popupId);
    }
    initPopupProperties() {
        this.popupRef.content.instance.ctx = this.ctx;
        this.popupRef.content.instance.hostButton = this.host;
        this.popupSubs.add(this.popupRef.content.instance.groupClear.subscribe(() => {
            this.closePopup();
        }));
        this.popupSubs.add(this.popupRef.content.instance.close.subscribe(() => {
            this.closePopup();
        }));
    }
    closePopup() {
        this.buttonElement?.setAttribute('aria-expanded', 'false');
        this.buttonElement?.removeAttribute('aria-controls');
        this.host.selected = false;
        if (this.popupRef) {
            this.popupRef.close();
            this.popupRef = null;
        }
        if (this.popupSubs) {
            this.popupSubs.unsubscribe();
            this.popupSubs = null;
        }
        if (this.removeClickListener) {
            this.removeClickListener();
            this.removeClickListener = null;
        }
    }
    get buttonElement() {
        return this.host.getButton();
    }
    isGroupingApplied(group) {
        return isPresent$1(group) && group.length > 0;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GroupCommandToolbarDirective, deps: [{ token: i54.ToolBarButtonComponent }, { token: i2.PopupService }, { token: ContextService }, { token: i0.NgZone }, { token: i0.Renderer2 }, { token: AdaptiveGridService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: GroupCommandToolbarDirective, isStandalone: true, selector: "[kendoGridGroupTool]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GroupCommandToolbarDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridGroupTool]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i54.ToolBarButtonComponent }, { type: i2.PopupService }, { type: ContextService }, { type: i0.NgZone }, { type: i0.Renderer2 }, { type: AdaptiveGridService }] });

/**
 * Stores the row and cell highlight state of the Grid.
 *
 * @example
 * ```typescript
 * <kendo-grid kendoGridHighlight="ProductID"></kendo-grid>
 *
 * <kendo-grid [kendoGridHighlight]="myKey"></kendo-grid>
 * ```
 * @remarks
 * Applied to: {@link GridComponent}.
 */
class HighlightDirective {
    ctx;
    /**
     * Stores the highlighted items keys.
     * @default []
     */
    highlightedKeys = [];
    /**
     * Sets the item key to store in `highlightedKeys`. The Grid uses the row index as the default item key.
     */
    highlightItemKey;
    /**
     * Sets the column key for a data cell. The Grid uses the column index as the default column key.
     */
    highlightColumnKey;
    rowHighlightState = new Set();
    cellHighlightState = new PairSet();
    constructor(ctx) {
        this.ctx = ctx;
        this.ctx.highlightDirective = this;
    }
    ngOnChanges(changes) {
        if (isPresent$1(changes['highlightedKeys'])) {
            this.setState(this.highlightedKeys);
        }
    }
    ngOnDestroy() {
        this.reset();
        this.ctx.highlightDirective = null;
    }
    /**
     * @hidden
     */
    isRowHighlighted(row) {
        return this.rowHighlightState.has(this.getItemKey(row));
    }
    /**
     * @hidden
     */
    isCellHighlighted(row, column, colIndex) {
        const highlightItem = this.getHighlightItem(row, column, colIndex);
        return this.cellHighlightState.has(highlightItem.itemKey, highlightItem.columnKey);
    }
    getItemKey(row) {
        if (this.highlightItemKey) {
            if (typeof this.highlightItemKey === "string") {
                return row.data?.[this.highlightItemKey];
            }
            if (typeof this.highlightItemKey === "function") {
                return this.highlightItemKey(row);
            }
        }
        return row.index;
    }
    getHighlightItem(row, col, colIndex) {
        const itemIdentifiers = {};
        itemIdentifiers.itemKey = this.getItemKey(row);
        if (!isPresent$1(col) && !isPresent$1(colIndex)) {
            return itemIdentifiers;
        }
        if (this.highlightColumnKey) {
            if (typeof this.highlightColumnKey === "string") {
                itemIdentifiers.columnKey = row.dataItem[this.highlightColumnKey];
            }
            if (typeof this.highlightColumnKey === "function") {
                itemIdentifiers.columnKey = this.highlightColumnKey(col, colIndex);
            }
        }
        return {
            itemKey: itemIdentifiers.itemKey,
            columnKey: itemIdentifiers.columnKey ? itemIdentifiers.columnKey : colIndex
        };
    }
    setState(highlightedKeys) {
        this.reset();
        if (!highlightedKeys || highlightedKeys.length === 0) {
            return;
        }
        const rowHighlights = highlightedKeys.filter(item => !isPresent$1(item.columnKey));
        const cellHighlights = highlightedKeys.filter(item => isPresent$1(item.columnKey));
        if (cellHighlights.length > 0) {
            this.cellHighlightState = new PairSet(cellHighlights, 'itemKey', 'columnKey');
        }
        if (rowHighlights.length > 0) {
            rowHighlights.forEach(item => {
                this.rowHighlightState.add(item.itemKey);
            });
        }
    }
    reset() {
        this.rowHighlightState.clear();
        this.cellHighlightState.clear();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: HighlightDirective, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: HighlightDirective, isStandalone: true, selector: "[kendoGridHighlight]", inputs: { highlightedKeys: "highlightedKeys", highlightItemKey: ["kendoGridHighlight", "highlightItemKey"], highlightColumnKey: "highlightColumnKey" }, usesOnChanges: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: HighlightDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridHighlight]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: ContextService }], propDecorators: { highlightedKeys: [{
                type: Input
            }], highlightItemKey: [{
                type: Input,
                args: ["kendoGridHighlight"]
            }], highlightColumnKey: [{
                type: Input
            }] } });

/**
 * @hidden
 */
const DEFAULT_AI_REQUEST_OPTIONS = {
    headers: new HttpHeaders({
        'Content-Type': 'application/json'
    }),
    role: 'user',
    method: 'POST',
    responseType: 'json'
};
/**
 * Represents the event data when the AI Assistant request completes successfully.
 */
class GridAIAssistantResponseSuccessEvent extends PreventableEvent$1 {
    /**
     * The HTTP response from the AI service.
     */
    response;
    constructor(response) {
        super();
        this.response = response;
    }
}
/**
 * Represents the event data when the AI Assistant request completes with an error.
 */
class GridAIAssistantResponseErrorEvent extends PreventableEvent$1 {
    /**
     * The HTTP error response from the AI service.
     */
    error;
    constructor(error) {
        super();
        this.error = error;
    }
}

/**
 * @hidden
 */
class AiAssistantComponent {
    http;
    ctx;
    columnInfoService;
    zone;
    aiRequestResponseService;
    aiPrompt;
    activeView = 0;
    requestUrl;
    requestOptions;
    aiPromptSettings;
    aiToolDirective;
    streaming = false;
    disabledGenerateButton = false;
    lastMessage;
    requestData;
    currentRequestSubscription = null;
    //Remove this when the AI Assistant has a built-in loading indicator
    loadingOutput = { id: 'k-loading-item', output: '', prompt: '' };
    // flat columns used for highlight utilities (expects { field })
    columns = [];
    leafColumns = [];
    idCounter = 0;
    constructor(http, ctx, columnInfoService, zone, aiRequestResponseService) {
        this.http = http;
        this.ctx = ctx;
        this.columnInfoService = columnInfoService;
        this.zone = zone;
        this.aiRequestResponseService = aiRequestResponseService;
    }
    ngAfterViewInit() {
        // Preserve a flat columns array (fields) for highlight utilities.
        // Use leafNamedColumns as the canonical list of leaf columns with display titles.
        this.leafColumns = this.columnInfoService.leafNamedColumns || [];
        this.columns = this.leafColumns.map((col) => ({ field: col.field }));
    }
    ngOnDestroy() {
        this.unsubscribeCurrentRequest();
    }
    message(message) {
        return this.ctx.localization.get(message);
    }
    cancelRequest() {
        this.aiToolDirective.cancelRequest.emit();
        this.unsubscribeCurrentRequest();
        this.streaming = false;
    }
    onPromptRequest(ev) {
        if (this.aiToolDirective.promptOutputs.length === 0) {
            this.aiToolDirective.promptOutputs.push(this.loadingOutput);
        }
        this.unsubscribeCurrentRequest();
        this.streaming = true;
        this.activeView = 1;
        if (ev.prompt) {
            this.lastMessage = ev.prompt;
        }
        this.requestData = {
            columns: [], // Will be populated by service
            promptMessage: ev.prompt,
            url: this.requestUrl,
            requestOptions: {
                ...this.requestOptions
            }
        };
        if (!this.requestOptions.body) {
            this.requestData.requestOptions.body = this.aiRequestResponseService.buildRequestBody(this.requestData.promptMessage, this.requestData.requestOptions.role);
        }
        this.aiToolDirective.promptRequest.emit({ requestData: this.requestData, isRetry: ev.isRetry });
        if (!this.requestUrl) {
            return;
        }
        this.currentRequestSubscription = this.sendPromptRequest().subscribe((res) => {
            if (res.body) {
                this.processResponse(res);
                this.streaming = false;
            }
            this.currentRequestSubscription = null;
        }, (error) => {
            this.handleError(error);
            this.streaming = false;
            this.currentRequestSubscription = null;
        });
    }
    sendPromptRequest() {
        const request = new HttpRequest(this.requestData.requestOptions.method, this.requestData.url, this.requestData.requestOptions.body, this.requestData.requestOptions);
        return this.http.request(request);
    }
    processResponse(response) {
        if (this.aiToolDirective.autoClose) {
            this.aiToolDirective.emitOpenClose = true;
            this.aiToolDirective.toggleWindow();
        }
        const responseBody = response.body || { commands: [] };
        const responseSuccessEvent = new GridAIAssistantResponseSuccessEvent(response);
        this.aiToolDirective.responseSuccess.emit(responseSuccessEvent);
        if (responseSuccessEvent.isDefaultPrevented()) {
            this.deleteLoadingOutput();
            return;
        }
        const messages = [];
        if (responseBody.message) {
            messages.push(responseBody.message);
        }
        const commandMessages = this.aiRequestResponseService.processCommands(responseBody.commands || [], this.columns, this.leafColumns);
        messages.push(...commandMessages);
        const responseContentStart = [`${this.ctx.localization.get('aiAssistantOutputCardBodyContent')} \n`];
        const responseContentBody = messages
            .map((output, idx) => `${idx + 1} ${output}`)
            .join('\n');
        const output = {
            id: this.idCounter++,
            title: this.ctx.localization.get('aiAssistantOutputCardTitle'),
            prompt: this.lastMessage,
            output: responseContentStart.concat(responseContentBody).join(''),
        };
        this.deleteLoadingOutput();
        this.aiToolDirective.promptOutputs.unshift(output);
    }
    handleError(error) {
        const responseErrorEvent = new GridAIAssistantResponseErrorEvent(error);
        this.aiToolDirective.responseError.emit(responseErrorEvent);
        if (responseErrorEvent.isDefaultPrevented()) {
            this.deleteLoadingOutput();
            return;
        }
        const output = {
            id: this.idCounter++,
            prompt: this.lastMessage,
            output: error.message
        };
        this.deleteLoadingOutput();
        this.aiToolDirective.promptOutputs.unshift(output);
    }
    deleteLoadingOutput() {
        if (this.aiToolDirective.promptOutputs[0]?.id === this.loadingOutput.id) {
            this.aiToolDirective.promptOutputs.splice(0, 1);
        }
    }
    unsubscribeCurrentRequest() {
        if (this.currentRequestSubscription) {
            this.currentRequestSubscription.unsubscribe();
            this.currentRequestSubscription = null;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AiAssistantComponent, deps: [{ token: i1$8.HttpClient }, { token: ContextService }, { token: ColumnInfoService }, { token: i0.NgZone }, { token: GridAIRequestResponseService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: AiAssistantComponent, isStandalone: true, selector: "ng-component", viewQueries: [{ propertyName: "aiPrompt", first: true, predicate: AIPromptComponent, descendants: true }], ngImport: i0, template: `
        <kendo-aiprompt
          #aiPrompt
          [promptSuggestions]="aiPromptSettings?.promptSuggestions"
          [showOutputRating]="aiPromptSettings?.showOutputRating"
          [streaming]="streaming"
          [speechToTextButton]="aiPromptSettings?.speechToTextButton"
          [(activeView)]="activeView"
          [generateButtonSVGIcon]="aiPromptSettings?.generateButtonSVGIcon"
          [generateButtonIcon]="aiPromptSettings?.generateButtonIcon"
          [disabledGenerateButton]="disabledGenerateButton || promptView.textAreaValue?.length === 0"
          [promptOutputs]="aiPromptSettings?.promptOutputs"
          [textAreaSettings]="aiPromptSettings?.textAreaSettings"
          (promptRequest)="onPromptRequest($event)"
          (promptRequestCancel)="cancelRequest()"
          >
          <kendo-aiprompt-prompt-view #promptView></kendo-aiprompt-prompt-view>
          <kendo-aiprompt-output-view></kendo-aiprompt-output-view>
          @if (streaming && aiPrompt.streaming; as output) {
            <ng-template kendoAIPromptOutputTemplate let-output>
              <div class="k-card">
                <div class="k-card-header">
                  <div class="k-card-title">
                    <span class="k-skeleton k-skeleton-text k-skeleton-pulse" [style.width.px]="200"></span>
                  </div>
                  <div class="k-card-subtitle">
                    <span class="k-skeleton k-skeleton-text k-skeleton-pulse" style="width: 100%;"></span>
                  </div>
                </div>
                <div class="k-card-body">
                  <span class="k-skeleton k-skeleton-rect k-skeleton-pulse" style="height: 80px;"></span>
                </div>
                <div class="k-card-actions">
                  <span class="k-skeleton k-skeleton-text k-skeleton-pulse" style="width: 100%;"></span>
                </div>
              </div>
            </ng-template>
          }
          @if (!(streaming && aiPrompt.streaming); as output) {
            <ng-template kendoAIPromptOutputBodyTemplate let-output>
              <p>{{output.output}}</p>
            </ng-template>
          }
          <kendo-aiprompt-messages
            [generateOutput]="message('aiAssistantApplyButtonText')"
          ></kendo-aiprompt-messages>
        </kendo-aiprompt>
        `, isInline: true, dependencies: [{ kind: "component", type: AIPromptComponent, selector: "kendo-aiprompt", inputs: ["activeView", "promptCommands", "promptSuggestions", "promptOutputs", "showOutputRating", "streaming", "speechToTextButton", "textAreaSettings", "generateButtonSVGIcon", "generateButtonIcon", "disabledGenerateButton"], outputs: ["activeViewChange", "promptRequest", "commandExecute", "outputCopy", "outputRatingChange", "promptRequestCancel"], exportAs: ["kendoAIPrompt"] }, { kind: "component", type: AIPromptCustomMessagesComponent, selector: "kendo-aiprompt-messages" }, { kind: "component", type: PromptViewComponent, selector: "kendo-aiprompt-prompt-view" }, { kind: "component", type: OutputViewComponent, selector: "kendo-aiprompt-output-view" }, { kind: "directive", type: AIPromptOutputTemplateDirective, selector: "[kendoAIPromptOutputTemplate]" }, { kind: "directive", type: AIPromptOutputBodyTemplateDirective, selector: "[kendoAIPromptOutputBodyTemplate]" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AiAssistantComponent, decorators: [{
            type: Component,
            args: [{
                    standalone: true,
                    imports: [AIPromptComponent, AIPromptCustomMessagesComponent, PromptViewComponent, OutputViewComponent, AIPromptOutputTemplateDirective, AIPromptOutputBodyTemplateDirective],
                    template: `
        <kendo-aiprompt
          #aiPrompt
          [promptSuggestions]="aiPromptSettings?.promptSuggestions"
          [showOutputRating]="aiPromptSettings?.showOutputRating"
          [streaming]="streaming"
          [speechToTextButton]="aiPromptSettings?.speechToTextButton"
          [(activeView)]="activeView"
          [generateButtonSVGIcon]="aiPromptSettings?.generateButtonSVGIcon"
          [generateButtonIcon]="aiPromptSettings?.generateButtonIcon"
          [disabledGenerateButton]="disabledGenerateButton || promptView.textAreaValue?.length === 0"
          [promptOutputs]="aiPromptSettings?.promptOutputs"
          [textAreaSettings]="aiPromptSettings?.textAreaSettings"
          (promptRequest)="onPromptRequest($event)"
          (promptRequestCancel)="cancelRequest()"
          >
          <kendo-aiprompt-prompt-view #promptView></kendo-aiprompt-prompt-view>
          <kendo-aiprompt-output-view></kendo-aiprompt-output-view>
          @if (streaming && aiPrompt.streaming; as output) {
            <ng-template kendoAIPromptOutputTemplate let-output>
              <div class="k-card">
                <div class="k-card-header">
                  <div class="k-card-title">
                    <span class="k-skeleton k-skeleton-text k-skeleton-pulse" [style.width.px]="200"></span>
                  </div>
                  <div class="k-card-subtitle">
                    <span class="k-skeleton k-skeleton-text k-skeleton-pulse" style="width: 100%;"></span>
                  </div>
                </div>
                <div class="k-card-body">
                  <span class="k-skeleton k-skeleton-rect k-skeleton-pulse" style="height: 80px;"></span>
                </div>
                <div class="k-card-actions">
                  <span class="k-skeleton k-skeleton-text k-skeleton-pulse" style="width: 100%;"></span>
                </div>
              </div>
            </ng-template>
          }
          @if (!(streaming && aiPrompt.streaming); as output) {
            <ng-template kendoAIPromptOutputBodyTemplate let-output>
              <p>{{output.output}}</p>
            </ng-template>
          }
          <kendo-aiprompt-messages
            [generateOutput]="message('aiAssistantApplyButtonText')"
          ></kendo-aiprompt-messages>
        </kendo-aiprompt>
        `
                }]
        }], ctorParameters: () => [{ type: i1$8.HttpClient }, { type: ContextService }, { type: ColumnInfoService }, { type: i0.NgZone }, { type: GridAIRequestResponseService }], propDecorators: { aiPrompt: [{
                type: ViewChild,
                args: [AIPromptComponent]
            }] } });

/**
 * Represents an AI Assistant tool of the Grid.
 * Use this directive on any `kendo-toolbar-button` inside a ToolbarComponent in the Grid.
 *
 * @example
 * ```html-no-run
 * <kendo-grid>
 *      <kendo-toolbar>
 *         <kendo-toolbar-button kendoGridAIAssistantTool></kendo-toolbar-button>
 *      </kendo-toolbar>
 * </kendo-grid>
 * ```
 * @remarks
 * Applied to: {@link ToolBarButtonComponent}.
 */
class AIAssistantToolbarDirective extends ToolbarToolBase {
    windowService;
    host;
    ctx;
    zone;
    refresh;
    /**
     * The URL to which the AI Assistant tool sends the AI request.
     * - When you set this property, the AI Assistant tool sends and handles an HTTP request to the provided `requestUrl`. You can handle the `promptRequest` event to modify the request options before the tool sends it.
     * - When you do not set this property, the AI Assistant tool does not send an HTTP request. You should handle the `promptRequest` event to send and handle a custom HTTP request.
     */
    requestUrl;
    /**
     * Configures the request options that the AI Assistant tool sends with the AI request.
     *
     * @default { headers: new HttpHeaders({ 'Content-Type': 'application/json' }), role: 'user', method: 'POST', responseType: 'json', withCredentials: false }
     */
    requestOptions;
    /**
     * Configures the initial settings for the AI Assistant Window when opened.
     */
    aiWindowSettings;
    /**
     * Configures the initial settings for the AI Prompt component that the AI Assistant Window component uses when opened.
     */
    aiPromptSettings;
    /**
     * Determines whether to close the AI Assistant Window automatically after a successful request.
     * @default true
     */
    autoClose = true;
    /**
     * Determines whether to keep the AI Prompt's outputs after closing the AI Assistant Window.
     * @default false
     */
    keepOutputHistory = false;
    /**
     * Emits an event before the AI Assistant tool sends the AI request.
     *  - When you provide a `requestUrl`, you can handle the event to modify the request options.
     *  - When you do not provide a `requestUrl`, you can handle the event to perform an entirely custom request.
     */
    promptRequest = new EventEmitter();
    /**
     * Emits an event when the user clicks the cancel button.
     */
    cancelRequest = new EventEmitter();
    /**
     * Emits an event when the AI Assistant tool completes the AI request successfully.
     * The event contains the response from the AI service and is preventable to allow stopping the default response handling.
     */
    responseSuccess = new EventEmitter();
    /**
     * Emits an event when the AI Assistant tool completes the AI request with an error.
     * The event contains the error response from the AI service and is preventable to allow stopping the default error handling.
     */
    responseError = new EventEmitter();
    /**
     * Emits an event when the AI Assistant tool closes.
     */
    close = new EventEmitter();
    /**
     * Emits an event when the AI Assistant tool opens.
     */
    open = new EventEmitter();
    tableWizardIcon = tableWizardIcon;
    emitOpenClose = false;
    promptOutputs = [];
    windowRef;
    subs = new Subscription();
    defaultAiPromptSettings = {
        speechToTextButton: true,
        generateButtonSVGIcon: this.tableWizardIcon,
        generateButtonIcon: 'table-wizard'
    };
    constructor(windowService, host, ctx, zone, refresh, cdr) {
        super(host, ToolbarToolName.aiAssistant, ctx, zone, cdr);
        this.windowService = windowService;
        this.host = host;
        this.ctx = ctx;
        this.zone = zone;
        this.refresh = refresh;
        this.host.rounded = 'full';
        this.host.themeColor = 'primary';
        this.host.showText = 'never';
    }
    ngOnInit() {
        this.subs.add(this.host.click.subscribe(() => this.onClick()));
        const hasToolbarIcon = isPresent$1(this.host.toolbarOptions.icon) && this.host.toolbarOptions.icon !== '';
        const hasOverflowIcon = isPresent$1(this.host.overflowOptions.icon) && this.host.overflowOptions.icon !== '';
        const hasIcon = hasToolbarIcon && hasOverflowIcon;
        const hasSvgIcon = isPresent$1(this.host.toolbarOptions.svgIcon) && isPresent$1(this.host.overflowOptions.svgIcon);
        if (!hasIcon) {
            this.host.icon = 'sparkles';
        }
        if (!hasSvgIcon) {
            this.host.svgIcon = sparklesIcon;
        }
        this.requestOptions = { ...DEFAULT_AI_REQUEST_OPTIONS, ...this.requestOptions };
    }
    ngAfterViewInit() {
        super.ngAfterViewInit();
        this.zone.onStable.pipe(take(1)).subscribe(() => {
            this.buttonElement?.setAttribute('aria-haspopup', 'dialog');
            this.buttonElement?.setAttribute('aria-expanded', 'false');
            const needsTitle = this.host.showText !== 'always' && this.host.showText !== 'toolbar';
            if (needsTitle && !this.host.title) {
                this.buttonElement?.setAttribute('title', this.ctx.localization.get('aiAssistantToolbarToolText'));
            }
        });
        this.subs.add(this.refresh.onRefresh.pipe(filter((tool) => tool === this.host)).subscribe((tool) => {
            if (tool.overflows && this.windowRef) {
                this.windowRef.close();
            }
        }));
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        this.subs.unsubscribe();
        this.promptOutputs = [];
    }
    /**
     * @hidden
     */
    onClick() {
        this.emitOpenClose = true;
        this.toggleWindow();
    }
    /**
     * Toggles the AI Assistant window.
     */
    toggleWindow() {
        if (!this.windowRef) {
            this.openWindow();
        }
        else {
            this.closeWindow();
        }
    }
    openWindow() {
        if (!this.keepOutputHistory) {
            this.promptOutputs = [];
        }
        const defaultWindowWidth = 437;
        const rtl = this.ctx.localization.rtl;
        const defaultWindowSettings = {
            left: rtl ? this.buttonElement.offsetLeft - (this.aiWindowSettings.width || defaultWindowWidth) : this.buttonElement.offsetLeft + this.buttonElement.offsetWidth,
            top: this.buttonElement.offsetTop + this.buttonElement.offsetHeight,
            width: defaultWindowWidth,
            title: this.ctx.localization.get('aiAssistantWindowTitle'),
            cssClass: 'k-grid-assistant-window',
            content: AiAssistantComponent,
            autoFocusedElement: '.k-input-inner',
            appendTo: this.ctx.grid.windowContainer
        };
        this.aiWindowSettings = {
            ...defaultWindowSettings,
            ...this.aiWindowSettings
        };
        this.windowRef = this.windowService.open(this.aiWindowSettings);
        this.windowRef.window.instance.messages = {
            closeTitle: this.ctx.localization.get('aiAssistantWindowCloseTitle'),
            maximizeTitle: this.ctx.localization.get('aiAssistantWindowMaximizeTitle'),
            minimizeTitle: this.ctx.localization.get('aiAssistantWindowMinimizeTitle'),
            restoreTitle: this.ctx.localization.get('aiAssistantWindowRestoreTitle')
        };
        const aiPrompt = this.windowRef.content.instance;
        aiPrompt.requestUrl = this.requestUrl;
        aiPrompt.requestOptions = this.requestOptions;
        aiPrompt.aiToolDirective = this;
        aiPrompt.disabledGenerateButton = this.aiPromptSettings?.disabledGenerateButton;
        aiPrompt.streaming = this.aiPromptSettings?.streaming || false;
        aiPrompt.activeView = this.aiPromptSettings?.activeView || 0;
        aiPrompt.aiPromptSettings = { ...this.defaultAiPromptSettings, ...this.aiPromptSettings };
        if (!aiPrompt.aiPromptSettings.promptOutputs) {
            aiPrompt.aiPromptSettings.promptOutputs = this.promptOutputs;
        }
        if (this.emitOpenClose) {
            this.zone.onStable.pipe(take(1)).subscribe(() => {
                const event = {
                    aiWindow: this.windowRef.window.instance,
                    aiPrompt: this.windowRef.content.instance.aiPrompt
                };
                this.open.emit(event);
                this.emitOpenClose = false;
            });
        }
        this.subs.add(this.windowRef.window.instance.close.subscribe(() => {
            this.emitOpenClose = true;
            this.closeWindow(true);
        }));
        this.host.selected = true;
    }
    closeWindow(focusAnchor = false) {
        this.windowRef.close();
        if (this.emitOpenClose) {
            this.close.emit();
            this.emitOpenClose = false;
        }
        this.windowRef = null;
        this.buttonElement?.setAttribute('aria-expanded', 'false');
        this.buttonElement?.removeAttribute('aria-controls');
        this.host.selected = false;
        focusAnchor && this.buttonElement?.focus();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AIAssistantToolbarDirective, deps: [{ token: i1$7.WindowService }, { token: i54.ToolBarButtonComponent }, { token: ContextService }, { token: i0.NgZone }, { token: i54.RefreshService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: AIAssistantToolbarDirective, isStandalone: true, selector: "[kendoGridAIAssistantTool]", inputs: { requestUrl: "requestUrl", requestOptions: "requestOptions", aiWindowSettings: "aiWindowSettings", aiPromptSettings: "aiPromptSettings", autoClose: "autoClose", keepOutputHistory: "keepOutputHistory" }, outputs: { promptRequest: "promptRequest", cancelRequest: "cancelRequest", responseSuccess: "responseSuccess", responseError: "responseError", close: "close", open: "open" }, usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AIAssistantToolbarDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridAIAssistantTool]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1$7.WindowService }, { type: i54.ToolBarButtonComponent }, { type: ContextService }, { type: i0.NgZone }, { type: i54.RefreshService }, { type: i0.ChangeDetectorRef }], propDecorators: { requestUrl: [{
                type: Input
            }], requestOptions: [{
                type: Input
            }], aiWindowSettings: [{
                type: Input
            }], aiPromptSettings: [{
                type: Input
            }], autoClose: [{
                type: Input
            }], keepOutputHistory: [{
                type: Input
            }], promptRequest: [{
                type: Output
            }], cancelRequest: [{
                type: Output
            }], responseSuccess: [{
                type: Output
            }], responseError: [{
                type: Output
            }], close: [{
                type: Output
            }], open: [{
                type: Output
            }] } });

/**
 * Represents the toolbar tool for showing a select-all `kendoGridSelectAllCheckbox` checkbox.
 * Use this component inside a ToolbarComponent in the Grid.
 *
 * @example
 * ```html
 * <kendo-grid>
 *      <kendo-toolbar>
 *         <kendo-grid-select-all-tool text="Select All"></kendo-grid-select-all-tool>
 *      </kendo-toolbar>
 * </kendo-grid>
 * ```
 */
class SelectAllToolbarToolComponent extends ToolBarToolComponent {
    idService;
    ctx;
    constructor(idService, ctx) {
        super();
        this.idService = idService;
        this.ctx = ctx;
    }
    /**
     * @hidden
     */
    selectAllCheckboxId() {
        return this.idService.selectAllCheckboxId();
    }
    /**
     * @hidden
     */
    get selectAllCheckboxLabel() {
        return this.ctx.localization.get('selectAllCheckboxLabel');
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SelectAllToolbarToolComponent, deps: [{ token: IdService }, { token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: SelectAllToolbarToolComponent, isStandalone: true, selector: "kendo-grid-select-all-tool", providers: [
            {
                provide: ToolBarToolComponent,
                useExisting: forwardRef(() => SelectAllToolbarToolComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: `
        <ng-template #toolbarTemplate #sectionTemplate #popupTemplate>
            <kendo-checkbox #checkbox
                [attr.id]="selectAllCheckboxId()"
                size="large"
                [inputAttributes]="{'aria-label': selectAllCheckboxLabel}"
                kendoGridSelectAllCheckbox
                kendoGridFocusable
            ></kendo-checkbox>
            <label class="k-checkbox-label" [for]="checkbox.focusableId">{{selectAllCheckboxLabel}}</label>
        </ng-template>
    `, isInline: true, dependencies: [{ kind: "component", type: CheckBoxComponent, selector: "kendo-checkbox", inputs: ["checkedState", "rounded"], outputs: ["checkedStateChange"], exportAs: ["kendoCheckBox"] }, { kind: "directive", type: SelectAllCheckboxDirective, selector: "[kendoGridSelectAllCheckbox]", inputs: ["state"], outputs: ["selectAllChange"] }, { kind: "directive", type: FocusableDirective, selector: "[kendoGridFocusable],\n        [kendoGridEditCommand],\n        [kendoGridRemoveCommand],\n        [kendoGridSaveCommand],\n        [kendoGridCancelCommand],\n        [kendoGridSelectionCheckbox]\n    ", inputs: ["kendoGridFocusable"] }, { kind: "directive", type: LabelDirective, selector: "label[for]", inputs: ["for", "labelClass"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SelectAllToolbarToolComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: ToolBarToolComponent,
                            useExisting: forwardRef(() => SelectAllToolbarToolComponent)
                        }
                    ],
                    selector: 'kendo-grid-select-all-tool',
                    template: `
        <ng-template #toolbarTemplate #sectionTemplate #popupTemplate>
            <kendo-checkbox #checkbox
                [attr.id]="selectAllCheckboxId()"
                size="large"
                [inputAttributes]="{'aria-label': selectAllCheckboxLabel}"
                kendoGridSelectAllCheckbox
                kendoGridFocusable
            ></kendo-checkbox>
            <label class="k-checkbox-label" [for]="checkbox.focusableId">{{selectAllCheckboxLabel}}</label>
        </ng-template>
    `,
                    standalone: true,
                    imports: [CheckBoxComponent, SelectAllCheckboxDirective, FocusableDirective, LabelDirective]
                }]
        }], ctorParameters: () => [{ type: IdService }, { type: ContextService }] });

// DRAGGABLE COLUMN
/**
 * @hidden
 *
 * Utility array that contains all column dragging components and directives
 */
const KENDO_GRID_COLUMN_DRAGANDDROP = [
    DraggableColumnDirective,
    DropTargetDirective
];
/**
 * @hidden
 *
 * Utility array that contains the former Shared module exports
 */
const KENDO_GRID_SHARED = [
    ColumnComponent,
    ColumnGroupComponent,
    LogicalCellDirective,
    LogicalRowDirective,
    FocusableDirective,
    FooterTemplateDirective,
    ColGroupComponent,
    ResizableContainerDirective,
    TemplateContextDirective,
    FieldAccessorPipe,
    DetailTemplateDirective,
    SpanColumnComponent,
    LoadingComponent,
    GridTableDirective
];
/**
 * @hidden
 *
 * Utility array that contains the former Group module exports
 */
const KENDO_GRID_GROUP_EXPORTS = [
    GroupHeaderTemplateDirective,
    GroupHeaderColumnTemplateDirective,
    GroupFooterTemplateDirective,
    GroupHeaderComponent,
    GroupPanelComponent,
];
/**
 * @hidden
 *
 * Utility array that contains the filter operator components
 */
const KENDO_GRID_FILTER_OPERATORS = [
    FilterCellOperatorsComponent,
    ContainsFilterOperatorComponent,
    DoesNotContainFilterOperatorComponent,
    EndsWithFilterOperatorComponent,
    EqualFilterOperatorComponent,
    IsEmptyFilterOperatorComponent,
    IsNotEmptyFilterOperatorComponent,
    IsNotNullFilterOperatorComponent,
    IsNullFilterOperatorComponent,
    NotEqualFilterOperatorComponent,
    StartsWithFilterOperatorComponent,
    GreaterFilterOperatorComponent,
    GreaterOrEqualToFilterOperatorComponent,
    LessFilterOperatorComponent,
    LessOrEqualToFilterOperatorComponent,
    AfterFilterOperatorComponent,
    AfterEqFilterOperatorComponent,
    BeforeEqFilterOperatorComponent,
    BeforeFilterOperatorComponent
];
/**
 * @hidden
 *
 * Utility array that contains the former SharedFilterModule exports
 */
const KENDO_GRID_FILTER_SHARED = [
    ...KENDO_GRID_SHARED,
    ...KENDO_GRID_FILTER_OPERATORS,
    FilterInputDirective,
];
/**
 * @hidden
 *
 * Utility array that contains the former FilterMenuModule declarations
 */
const KENDO_GRID_FILTER_MENU_EXPORTS = [
    FilterMenuComponent,
    FilterMenuContainerComponent,
    FilterMenuInputWrapperComponent,
    StringFilterMenuInputComponent,
    StringFilterMenuComponent,
    FilterMenuTemplateDirective,
    NumericFilterMenuComponent,
    NumericFilterMenuInputComponent,
    DateFilterMenuInputComponent,
    DateFilterMenuComponent,
    FilterMenuHostDirective,
    BooleanFilterMenuComponent,
    FilterMenuDropDownListDirective,
    BooleanFilterRadioButtonDirective
];
/**
 * @hidden
 *
 * Utility array that contains the former FilterMenuModule exports
 */
const KENDO_GRID_FILTER_MENU = [
    ...KENDO_GRID_FILTER_SHARED,
    ...KENDO_GRID_FILTER_MENU_EXPORTS
];
/**
 * @hidden
 *
 * Utility array that contains the former RowFilterModule declarations
 */
const KENDO_GRID_FILTER_ROW_EXPORTS = [
    FilterRowComponent,
    FilterCellComponent,
    FilterCellTemplateDirective,
    StringFilterCellComponent,
    NumericFilterCellComponent,
    AutoCompleteFilterCellComponent,
    BooleanFilterCellComponent,
    FilterCellHostDirective,
    FilterCellWrapperComponent,
    DateFilterCellComponent
];
/**
 * @hidden
 *
 * Utility array that contains the former RowFilterModule exports
 */
const KENDO_GRID_FILTER_ROW = [
    ...KENDO_GRID_FILTER_ROW_EXPORTS,
    ...KENDO_GRID_FILTER_SHARED
];
/**
 * @hidden
 *
 * Utility array that contains the former ColumnMenu module declarations
 */
const KENDO_GRID_COLUMN_MENU_DECLARATIONS = [
    ColumnListComponent,
    ColumnChooserComponent,
    ColumnChooserToolbarDirective,
    ColumnMenuChooserComponent,
    ColumnMenuFilterComponent,
    ColumnMenuItemComponent,
    ColumnMenuItemContentTemplateDirective,
    ColumnMenuSortComponent,
    ColumnMenuComponent,
    ColumnMenuLockComponent,
    ColumnMenuTemplateDirective,
    ColumnMenuContainerComponent,
    ColumnMenuItemDirective,
    ColumnMenuStickComponent,
    ColumnMenuPositionComponent,
    ColumnMenuAutoSizeColumnComponent,
    ColumnMenuAutoSizeAllColumnsComponent
];
/**
 * @hidden
 *
 * Utility array that contains the former ColumnMenu module exports
 */
const KENDO_GRID_COLUMN_MENU_EXPORTS = [
    ColumnChooserComponent,
    ColumnChooserToolbarDirective,
    ColumnMenuFilterComponent,
    ColumnMenuItemComponent,
    ColumnMenuItemContentTemplateDirective,
    ColumnMenuSortComponent,
    ColumnMenuLockComponent,
    ColumnMenuStickComponent,
    ColumnMenuPositionComponent,
    ColumnMenuChooserComponent,
    ColumnMenuTemplateDirective,
    ColumnMenuContainerComponent,
    ColumnMenuItemDirective,
    ColumnMenuComponent,
    ColumnMenuAutoSizeColumnComponent,
    ColumnMenuAutoSizeAllColumnsComponent
];
/**
 * @hidden
 */
const KENDO_GRID_HEADER_EXPORTS = [
    HeaderComponent,
    HeaderTemplateDirective,
    ColumnHandleDirective,
    SelectAllCheckboxDirective
];
/**
 * @hidden
 *
 * Utility array that contains the Footer module exports
 */
const KENDO_GRID_FOOTER_EXPORTS = [FooterComponent];
/**
 * @hidden
 *
 * Utility array that contains the Body module exports
 */
const KENDO_GRID_BODY_EXPORTS = [
    CommandColumnComponent,
    CheckboxColumnComponent,
    SelectionCheckboxDirective,
    CellTemplateDirective,
    EditTemplateDirective,
    RowDragHandleTemplateDirective,
    RowDragHintTemplateDirective,
    TableBodyComponent,
    NoRecordsTemplateDirective,
    CellComponent,
    EditCommandDirective,
    CancelCommandDirective,
    SaveCommandDirective,
    RemoveCommandDirective,
    AddCommandDirective,
    AddCommandToolbarDirective,
    EditCommandToolbarDirective,
    SaveCommandToolbarDirective,
    RemoveCommandToolbarDirective,
    CancelCommandToolbarDirective,
    CellLoadingTemplateDirective,
    LoadingTemplateDirective,
    RowReorderColumnComponent,
    SortCommandToolbarDirective,
    FilterCommandToolbarDirective,
    AIAssistantToolbarDirective,
    GroupCommandToolbarDirective,
    SelectAllToolbarToolComponent
];
/**
 * @hidden
 *
 * Utility array that contains the Grid module declarations
 */
const KENDO_GRID_DECLARATIONS = [
    GridComponent,
    ListComponent,
    ToolbarComponent,
    LocalizedMessagesDirective,
    CustomMessagesComponent,
    DataBindingDirective,
    ToolbarTemplateDirective,
    SelectionDirective,
    HighlightDirective,
    TemplateEditingDirective,
    ReactiveEditingDirective,
    InCellEditingDirective,
    ExternalEditingDirective,
    ExpandDetailsDirective,
    ExpandGroupDirective,
    GridMarqueeDirective,
    GridSpacerComponent,
    GridToolbarFocusableDirective,
    StatusBarComponent,
    StatusBarTemplateDirective,
    GridClipboardDirective,
    FormComponent,
    DialogFormComponent,
    FormFormFieldComponent,
    UndoRedoDirective,
];
/**
 * @hidden
 *
 * Utility array that contains the Grid module exports
 */
const KENDO_GRID_EXPORTS = [
    GridComponent,
    ToolbarTemplateDirective,
    ToolbarComponent,
    GridSpacerComponent,
    StatusBarTemplateDirective,
    DataBindingDirective,
    SelectionDirective,
    HighlightDirective,
    CustomMessagesComponent,
    TemplateEditingDirective,
    ReactiveEditingDirective,
    InCellEditingDirective,
    ExternalEditingDirective,
    ExpandDetailsDirective,
    ExpandGroupDirective,
    GridToolbarFocusableDirective,
    ...KENDO_GRID_GROUP_EXPORTS,
    ...KENDO_GRID_SHARED,
    ...KENDO_GRID_BODY_EXPORTS,
    ...KENDO_GRID_HEADER_EXPORTS,
    ...KENDO_GRID_FILTER_ROW_EXPORTS,
    ...KENDO_GRID_FILTER_OPERATORS,
    ...KENDO_GRID_FILTER_MENU_EXPORTS,
    ...KENDO_GRID_COLUMN_MENU_EXPORTS,
    GridClipboardDirective,
    UndoRedoDirective,
    UndoCommandToolbarDirective,
    RedoCommandToolbarDirective,
];
/**
 * @hidden
 *
 * Utility array that contains the ExcelExport module exports
 */
const KENDO_GRID_EXCEL_EXPORT = [
    ExcelComponent,
    ExcelCommandDirective,
    ExcelCommandToolbarDirective,
    ColumnComponent$1,
    ColumnGroupComponent$1,
    FooterTemplateDirective$1,
    GroupFooterTemplateDirective$1,
    GroupHeaderColumnTemplateDirective$1,
    GroupHeaderTemplateDirective$1
];
/**
 * @hidden
 *
 * Utility array that contains the PDFModule declarations and exports
 */
const KENDO_GRID_PDF_EXPORT = [
    PDFComponent,
    PDFMarginComponent,
    PDFCommandDirective,
    PDFTemplateDirective,
    PDFCommandToolbarDirective
];
/**
 * Contains all Grid-related components and directives.
 *
 * @example
 * ```typescript
 * import { KENDO_GRID } from '@progress/kendo-angular-grid';
 * @NgModule({
 *   imports: [KENDO_GRID]
 * })
 * export class AppModule {}
 * ```
 */
const KENDO_GRID = [
    ...KENDO_GRID_EXPORTS,
    ...KENDO_GRID_EXCEL_EXPORT,
    ...KENDO_GRID_PDF_EXPORT
];

// IMPORTANT: NgModule export kept for backwards compatibility
/**
 * Defines the [`NgModule`](link:site.data.urls.angular['ngmoduleapi']) for the Grid component.
 *
 * Use this module to import the Grid in your NgModule-based Angular application.
 *
 * @example
 *
 * ```ts
 * import { NgModule } from '@angular/core';
 * import { GridModule } from '@progress/kendo-angular-grid';
 * import { BrowserModule } from "@angular/platform-browser";
 * import { AppComponent } from './app.component';
 *
 * @NgModule({
 *     declarations: [AppComponent],
 *     imports:      [BrowserModule, GridModule],
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * ```
 */
class GridModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GridModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.18", ngImport: i0, type: GridModule, imports: [GroupHeaderTemplateDirective, GroupHeaderColumnTemplateDirective, GroupFooterTemplateDirective, GroupHeaderComponent, GroupPanelComponent, ColumnComponent, ColumnGroupComponent, LogicalCellDirective, LogicalRowDirective, FocusableDirective, FooterTemplateDirective, ColGroupComponent, ResizableContainerDirective, i1$3.TemplateContextDirective, FieldAccessorPipe, DetailTemplateDirective, SpanColumnComponent, LoadingComponent, GridTableDirective, CommandColumnComponent, CheckboxColumnComponent, SelectionCheckboxDirective, CellTemplateDirective, EditTemplateDirective, RowDragHandleTemplateDirective, RowDragHintTemplateDirective, TableBodyComponent, NoRecordsTemplateDirective, CellComponent, EditCommandDirective, CancelCommandDirective, SaveCommandDirective, RemoveCommandDirective, AddCommandDirective, AddCommandToolbarDirective, EditCommandToolbarDirective, SaveCommandToolbarDirective, RemoveCommandToolbarDirective, CancelCommandToolbarDirective, CellLoadingTemplateDirective, LoadingTemplateDirective, RowReorderColumnComponent, SortCommandToolbarDirective, FilterCommandToolbarDirective, AIAssistantToolbarDirective, GroupCommandToolbarDirective, SelectAllToolbarToolComponent, HeaderComponent, HeaderTemplateDirective, ColumnHandleDirective, SelectAllCheckboxDirective, FooterComponent, i53.CustomMessagesComponent, i53.PagerFocusableDirective, i53.PagerInfoComponent, i53.PagerInputComponent, i53.PagerNextButtonsComponent, i53.PagerNumericButtonsComponent, i53.PagerPageSizesComponent, i53.PagerPrevButtonsComponent, i53.PagerTemplateDirective, i53.PagerComponent, i53.PagerSpacerComponent, i54.ToolBarComponent, i54.ToolbarCustomMessagesComponent, i54.ToolBarButtonComponent, i54.ToolBarButtonGroupComponent, i54.ToolBarDropDownButtonComponent, i54.ToolBarSeparatorComponent, i54.ToolBarSpacerComponent, i54.ToolBarSplitButtonComponent, i54.ToolBarToolComponent, FilterRowComponent, FilterCellComponent, FilterCellTemplateDirective, StringFilterCellComponent, NumericFilterCellComponent, AutoCompleteFilterCellComponent, BooleanFilterCellComponent, FilterCellHostDirective, FilterCellWrapperComponent, DateFilterCellComponent, ColumnComponent, ColumnGroupComponent, LogicalCellDirective, LogicalRowDirective, FocusableDirective, FooterTemplateDirective, ColGroupComponent, ResizableContainerDirective, i1$3.TemplateContextDirective, FieldAccessorPipe, DetailTemplateDirective, SpanColumnComponent, LoadingComponent, GridTableDirective, FilterCellOperatorsComponent, ContainsFilterOperatorComponent, DoesNotContainFilterOperatorComponent, EndsWithFilterOperatorComponent, EqualFilterOperatorComponent, IsEmptyFilterOperatorComponent, IsNotEmptyFilterOperatorComponent, IsNotNullFilterOperatorComponent, IsNullFilterOperatorComponent, NotEqualFilterOperatorComponent, StartsWithFilterOperatorComponent, GreaterFilterOperatorComponent, GreaterOrEqualToFilterOperatorComponent, LessFilterOperatorComponent, LessOrEqualToFilterOperatorComponent, AfterFilterOperatorComponent, AfterEqFilterOperatorComponent, BeforeEqFilterOperatorComponent, BeforeFilterOperatorComponent, FilterInputDirective, ColumnComponent, ColumnGroupComponent, LogicalCellDirective, LogicalRowDirective, FocusableDirective, FooterTemplateDirective, ColGroupComponent, ResizableContainerDirective, i1$3.TemplateContextDirective, FieldAccessorPipe, DetailTemplateDirective, SpanColumnComponent, LoadingComponent, GridTableDirective, FilterCellOperatorsComponent, ContainsFilterOperatorComponent, DoesNotContainFilterOperatorComponent, EndsWithFilterOperatorComponent, EqualFilterOperatorComponent, IsEmptyFilterOperatorComponent, IsNotEmptyFilterOperatorComponent, IsNotNullFilterOperatorComponent, IsNullFilterOperatorComponent, NotEqualFilterOperatorComponent, StartsWithFilterOperatorComponent, GreaterFilterOperatorComponent, GreaterOrEqualToFilterOperatorComponent, LessFilterOperatorComponent, LessOrEqualToFilterOperatorComponent, AfterFilterOperatorComponent, AfterEqFilterOperatorComponent, BeforeEqFilterOperatorComponent, BeforeFilterOperatorComponent, FilterInputDirective, FilterMenuComponent, FilterMenuContainerComponent, FilterMenuInputWrapperComponent, StringFilterMenuInputComponent, StringFilterMenuComponent, FilterMenuTemplateDirective, NumericFilterMenuComponent, NumericFilterMenuInputComponent, DateFilterMenuInputComponent, DateFilterMenuComponent, FilterMenuHostDirective, BooleanFilterMenuComponent, FilterMenuDropDownListDirective, BooleanFilterRadioButtonDirective, ColumnListComponent, ColumnChooserComponent, ColumnChooserToolbarDirective, ColumnMenuChooserComponent, ColumnMenuFilterComponent, ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, ColumnMenuSortComponent, ColumnMenuComponent, ColumnMenuLockComponent, ColumnMenuTemplateDirective, ColumnMenuContainerComponent, ColumnMenuItemDirective, ColumnMenuStickComponent, ColumnMenuPositionComponent, ColumnMenuAutoSizeColumnComponent, ColumnMenuAutoSizeAllColumnsComponent, GridComponent, ListComponent, ToolbarComponent, LocalizedMessagesDirective, CustomMessagesComponent, DataBindingDirective, ToolbarTemplateDirective, SelectionDirective, HighlightDirective, TemplateEditingDirective, ReactiveEditingDirective, InCellEditingDirective, ExternalEditingDirective, ExpandDetailsDirective, ExpandGroupDirective, GridMarqueeDirective, GridSpacerComponent, GridToolbarFocusableDirective, StatusBarComponent, StatusBarTemplateDirective, GridClipboardDirective, FormComponent, DialogFormComponent, FormFormFieldComponent, UndoRedoDirective, i54.ToolBarComponent, i54.ToolbarCustomMessagesComponent, i54.ToolBarButtonComponent, i54.ToolBarButtonGroupComponent, i54.ToolBarDropDownButtonComponent, i54.ToolBarSeparatorComponent, i54.ToolBarSpacerComponent, i54.ToolBarSplitButtonComponent, i54.ToolBarToolComponent, TableDirective,
            UndoCommandToolbarDirective,
            RedoCommandToolbarDirective], exports: [GridComponent, ToolbarTemplateDirective, ToolbarComponent, GridSpacerComponent, StatusBarTemplateDirective, DataBindingDirective, SelectionDirective, HighlightDirective, CustomMessagesComponent, TemplateEditingDirective, ReactiveEditingDirective, InCellEditingDirective, ExternalEditingDirective, ExpandDetailsDirective, ExpandGroupDirective, GridToolbarFocusableDirective, GroupHeaderTemplateDirective, GroupHeaderColumnTemplateDirective, GroupFooterTemplateDirective, GroupHeaderComponent, GroupPanelComponent, ColumnComponent, ColumnGroupComponent, LogicalCellDirective, LogicalRowDirective, FocusableDirective, FooterTemplateDirective, ColGroupComponent, ResizableContainerDirective, i1$3.TemplateContextDirective, FieldAccessorPipe, DetailTemplateDirective, SpanColumnComponent, LoadingComponent, GridTableDirective, CommandColumnComponent, CheckboxColumnComponent, SelectionCheckboxDirective, CellTemplateDirective, EditTemplateDirective, RowDragHandleTemplateDirective, RowDragHintTemplateDirective, TableBodyComponent, NoRecordsTemplateDirective, CellComponent, EditCommandDirective, CancelCommandDirective, SaveCommandDirective, RemoveCommandDirective, AddCommandDirective, AddCommandToolbarDirective, EditCommandToolbarDirective, SaveCommandToolbarDirective, RemoveCommandToolbarDirective, CancelCommandToolbarDirective, CellLoadingTemplateDirective, LoadingTemplateDirective, RowReorderColumnComponent, SortCommandToolbarDirective, FilterCommandToolbarDirective, AIAssistantToolbarDirective, GroupCommandToolbarDirective, SelectAllToolbarToolComponent, HeaderComponent, HeaderTemplateDirective, ColumnHandleDirective, SelectAllCheckboxDirective, FilterRowComponent, FilterCellComponent, FilterCellTemplateDirective, StringFilterCellComponent, NumericFilterCellComponent, AutoCompleteFilterCellComponent, BooleanFilterCellComponent, FilterCellHostDirective, FilterCellWrapperComponent, DateFilterCellComponent, FilterCellOperatorsComponent, ContainsFilterOperatorComponent, DoesNotContainFilterOperatorComponent, EndsWithFilterOperatorComponent, EqualFilterOperatorComponent, IsEmptyFilterOperatorComponent, IsNotEmptyFilterOperatorComponent, IsNotNullFilterOperatorComponent, IsNullFilterOperatorComponent, NotEqualFilterOperatorComponent, StartsWithFilterOperatorComponent, GreaterFilterOperatorComponent, GreaterOrEqualToFilterOperatorComponent, LessFilterOperatorComponent, LessOrEqualToFilterOperatorComponent, AfterFilterOperatorComponent, AfterEqFilterOperatorComponent, BeforeEqFilterOperatorComponent, BeforeFilterOperatorComponent, FilterMenuComponent, FilterMenuContainerComponent, FilterMenuInputWrapperComponent, StringFilterMenuInputComponent, StringFilterMenuComponent, FilterMenuTemplateDirective, NumericFilterMenuComponent, NumericFilterMenuInputComponent, DateFilterMenuInputComponent, DateFilterMenuComponent, FilterMenuHostDirective, BooleanFilterMenuComponent, FilterMenuDropDownListDirective, BooleanFilterRadioButtonDirective, ColumnChooserComponent, ColumnChooserToolbarDirective, ColumnMenuFilterComponent, ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, ColumnMenuSortComponent, ColumnMenuLockComponent, ColumnMenuStickComponent, ColumnMenuPositionComponent, ColumnMenuChooserComponent, ColumnMenuTemplateDirective, ColumnMenuContainerComponent, ColumnMenuItemDirective, ColumnMenuComponent, ColumnMenuAutoSizeColumnComponent, ColumnMenuAutoSizeAllColumnsComponent, GridClipboardDirective, UndoRedoDirective, UndoCommandToolbarDirective, RedoCommandToolbarDirective, i54.ToolBarComponent, i54.ToolbarCustomMessagesComponent, i54.ToolBarButtonComponent, i54.ToolBarButtonGroupComponent, i54.ToolBarDropDownButtonComponent, i54.ToolBarSeparatorComponent, i54.ToolBarSpacerComponent, i54.ToolBarSplitButtonComponent, i54.ToolBarToolComponent, i53.CustomMessagesComponent, i53.PagerFocusableDirective, i53.PagerInfoComponent, i53.PagerInputComponent, i53.PagerNextButtonsComponent, i53.PagerNumericButtonsComponent, i53.PagerPageSizesComponent, i53.PagerPrevButtonsComponent, i53.PagerTemplateDirective, i53.PagerComponent, i53.PagerSpacerComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GridModule, providers: [
            PopupService,
            ResizeBatchService,
            IconsService,
            DialogContainerService,
            DialogService,
            WindowService,
            WindowContainerService,
            CalendarDOMService,
            CenturyViewService,
            DecadeViewService,
            MonthViewService,
            YearViewService,
            NavigationService$1
        ], imports: [GroupHeaderComponent, GroupPanelComponent, TableBodyComponent, CellComponent, EditCommandDirective, CancelCommandDirective, SaveCommandDirective, RemoveCommandDirective, AddCommandDirective, SelectAllToolbarToolComponent, HeaderComponent, i53.CustomMessagesComponent, i53.PagerInfoComponent, i53.PagerInputComponent, i53.PagerNextButtonsComponent, i53.PagerNumericButtonsComponent, i53.PagerPageSizesComponent, i53.PagerPrevButtonsComponent, i53.PagerComponent, i53.PagerSpacerComponent, i54.ToolBarComponent, i54.ToolbarCustomMessagesComponent, i54.ToolBarButtonComponent, i54.ToolBarButtonGroupComponent, i54.ToolBarDropDownButtonComponent, i54.ToolBarSeparatorComponent, i54.ToolBarSpacerComponent, i54.ToolBarSplitButtonComponent, StringFilterCellComponent, NumericFilterCellComponent, AutoCompleteFilterCellComponent, BooleanFilterCellComponent, FilterCellWrapperComponent, DateFilterCellComponent, FilterCellOperatorsComponent, FilterCellOperatorsComponent, FilterMenuComponent, FilterMenuContainerComponent, FilterMenuInputWrapperComponent, StringFilterMenuInputComponent, StringFilterMenuComponent, NumericFilterMenuComponent, NumericFilterMenuInputComponent, DateFilterMenuInputComponent, DateFilterMenuComponent, BooleanFilterMenuComponent, ColumnListComponent, ColumnChooserComponent, ColumnMenuChooserComponent, ColumnMenuFilterComponent, ColumnMenuItemComponent, ColumnMenuSortComponent, ColumnMenuComponent, ColumnMenuLockComponent, ColumnMenuStickComponent, ColumnMenuPositionComponent, ColumnMenuAutoSizeColumnComponent, ColumnMenuAutoSizeAllColumnsComponent, GridComponent, ListComponent, FormComponent, DialogFormComponent, FormFormFieldComponent, i54.ToolBarComponent, i54.ToolbarCustomMessagesComponent, i54.ToolBarButtonComponent, i54.ToolBarButtonGroupComponent, i54.ToolBarDropDownButtonComponent, i54.ToolBarSeparatorComponent, i54.ToolBarSpacerComponent, i54.ToolBarSplitButtonComponent] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GridModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [...KENDO_GRID_EXPORTS, ...KENDO_TOOLBAR, ...KENDO_PAGER],
                    imports: [
                        ...KENDO_GRID_GROUP_EXPORTS,
                        ...KENDO_GRID_SHARED,
                        ...KENDO_GRID_BODY_EXPORTS,
                        ...KENDO_GRID_HEADER_EXPORTS,
                        ...KENDO_GRID_FOOTER_EXPORTS,
                        ...KENDO_PAGER,
                        ...KENDO_TOOLBAR,
                        ...KENDO_GRID_FILTER_ROW,
                        ...KENDO_GRID_FILTER_MENU,
                        ...KENDO_GRID_COLUMN_MENU_DECLARATIONS,
                        ...KENDO_GRID_DECLARATIONS,
                        ...KENDO_TOOLBAR,
                        TableDirective,
                        UndoCommandToolbarDirective,
                        RedoCommandToolbarDirective
                    ],
                    providers: [
                        PopupService,
                        ResizeBatchService,
                        IconsService,
                        DialogContainerService,
                        DialogService,
                        WindowService,
                        WindowContainerService,
                        CalendarDOMService,
                        CenturyViewService,
                        DecadeViewService,
                        MonthViewService,
                        YearViewService,
                        NavigationService$1
                    ]
                }]
        }] });

// IMPORTANT: NgModule export kept for backwards compatibility
/**
 * Represents the [`NgModule`](link:site.data.urls.angular['ngmoduleapi']) definition for the Grid PDF component.
 * Use this module to enable PDF export in the Grid for NgModule-based applications.
 *
 * @example
 * ```typescript
 * import { NgModule } from '@angular/core';
 * import { BrowserModule } from "@angular/platform-browser";
 * import { GridModule, PDFModule } from '@progress/kendo-angular-grid';
 * import { AppComponent } from './app.component';
 *
 * @NgModule({
 *     declarations: [AppComponent],
 *     imports:      [BrowserModule, GridModule, PDFModule],
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 * ```
 */
class PDFModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PDFModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.18", ngImport: i0, type: PDFModule, imports: [i1$1.IconComponent, i1$1.SVGIconComponent, PDFComponent, PDFMarginComponent, PDFCommandDirective, PDFTemplateDirective, PDFCommandToolbarDirective], exports: [PDFComponent, PDFMarginComponent, PDFCommandDirective, PDFTemplateDirective, PDFCommandToolbarDirective] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PDFModule, providers: [IconsService], imports: [KENDO_ICONS, PDFCommandDirective] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PDFModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [...KENDO_ICONS, ...KENDO_GRID_PDF_EXPORT],
                    exports: [...KENDO_GRID_PDF_EXPORT],
                    providers: [IconsService]
                }]
        }] });

// IMPORTANT: NgModule export kept for backwards compatibility
/**
 * Defines the [`NgModule`](link:site.data.urls.angular['ngmoduleapi']) for the Excel component of the Grid.
 *
 * @example
 * ```ts
 * import { NgModule } from '@angular/core';
 * import { BrowserModule } from "@angular/platform-browser";
 * import { GridModule, ExcelModule } from '@progress/kendo-angular-grid';
 * import { AppComponent } from './app.component';
 *
 * _@NgModule({
 *   declarations: [AppComponent],
 *   imports: [BrowserModule, GridModule, ExcelModule],
 *   bootstrap: [AppComponent]
 * })
 * export class AppModule {}
 * ```
 */
class ExcelModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ExcelModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.18", ngImport: i0, type: ExcelModule, imports: [i1$1.IconComponent, i1$1.SVGIconComponent, ExcelComponent, ExcelCommandDirective, ExcelCommandToolbarDirective, i5$1.ColumnComponent, i5$1.ColumnGroupComponent, i5$1.FooterTemplateDirective, i5$1.GroupFooterTemplateDirective, i5$1.GroupHeaderColumnTemplateDirective, i5$1.GroupHeaderTemplateDirective], exports: [ExcelComponent, ExcelCommandDirective, ExcelCommandToolbarDirective, i5$1.ColumnComponent, i5$1.ColumnGroupComponent, i5$1.FooterTemplateDirective, i5$1.GroupFooterTemplateDirective, i5$1.GroupHeaderColumnTemplateDirective, i5$1.GroupHeaderTemplateDirective] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ExcelModule, providers: [IconsService], imports: [KENDO_ICONS, ExcelCommandDirective, i5$1.ColumnComponent, i5$1.ColumnGroupComponent] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ExcelModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [...KENDO_ICONS, ...KENDO_GRID_EXCEL_EXPORT],
                    exports: [...KENDO_GRID_EXCEL_EXPORT],
                    providers: [IconsService]
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { AIAssistantToolbarDirective, AdaptiveGridService, AddCommandDirective, AddCommandToolbarDirective, AfterEqFilterOperatorComponent, AfterFilterOperatorComponent, AutoCompleteFilterCellComponent, BaseFilterCellComponent, BeforeEqFilterOperatorComponent, BeforeFilterOperatorComponent, BooleanFilterCellComponent, BooleanFilterComponent, BooleanFilterMenuComponent, BooleanFilterRadioButtonDirective, BrowserSupportService, CELL_CONTEXT, CancelCommandDirective, CancelCommandToolbarDirective, CellCloseEvent, CellComponent, CellLoadingTemplateDirective, CellSelectionAggregateService, CellSelectionService, CellTemplateDirective, ChangeNotificationService, CheckboxColumnComponent, ColGroupComponent, ColumnBase, ColumnChooserComponent, ColumnChooserToolbarDirective, ColumnComponent, ColumnGroupComponent, ColumnHandleDirective, ColumnInfoService, ColumnListComponent, ColumnLockedChangeEvent, ColumnMenuAutoSizeAllColumnsComponent, ColumnMenuAutoSizeColumnComponent, ColumnMenuChooserComponent, ColumnMenuComponent, ColumnMenuContainerComponent, ColumnMenuFilterComponent, ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, ColumnMenuItemDirective, ColumnMenuLockComponent, ColumnMenuPositionComponent, ColumnMenuService, ColumnMenuSortComponent, ColumnMenuStickComponent, ColumnMenuTemplateDirective, ColumnReorderEvent, ColumnReorderService, ColumnResizingService, ColumnStickyChangeEvent, ColumnVisibilityChangeEvent, ColumnsContainer, CommandColumnComponent, ContainsFilterOperatorComponent, ContextService, CustomMessagesComponent, DEFAULT_AI_REQUEST_OPTIONS, DEFAULT_SCROLLER_FACTORY, DataBindingDirective, DateFilterCellComponent, DateFilterComponent, DateFilterMenuComponent, DateFilterMenuInputComponent, DetailCollapseEvent, DetailExpandEvent, DetailTemplateDirective, DetailsService, DoesNotContainFilterOperatorComponent, DomEventsService, DragAndDropService, DragHintService, DropCueService, EditCommandDirective, EditCommandToolbarDirective, EditService as EditServiceClass, EditTemplateDirective, EditingDirectiveBase, EndsWithFilterOperatorComponent, EqualFilterOperatorComponent, ExcelCommandDirective, ExcelCommandToolbarDirective, ExcelComponent, ExcelExportEvent, ExcelModule, ExcelService, ExpandDetailsDirective, ExpandGroupDirective, ExternalEditingDirective, FieldAccessorPipe, FilterCellComponent, FilterCellHostDirective, FilterCellOperatorsComponent, FilterCellTemplateDirective, FilterCellWrapperComponent, FilterCommandToolbarDirective, FilterInputDirective, FilterMenuComponent, FilterMenuContainerComponent, FilterMenuDropDownListDirective, FilterMenuHostDirective, FilterMenuInputWrapperComponent, FilterMenuTemplateDirective, FilterOperatorBase, FilterRowComponent, FilterService, FocusRoot, FocusableDirective, FooterComponent, FooterTemplateDirective, GreaterFilterOperatorComponent, GreaterOrEqualToFilterOperatorComponent, GridAIAssistantResponseErrorEvent, GridAIAssistantResponseSuccessEvent, GridClipboardDirective, GridComponent, GridModule, GridSpacerComponent, GridTableDirective, GridToolbarFocusableDirective, GridToolbarNavigationService, GroupCommandToolbarDirective, GroupFooterTemplateDirective, GroupHeaderColumnTemplateDirective, GroupHeaderComponent, GroupHeaderTemplateDirective, GroupInfoService, GroupPanelComponent, GroupsService, HeaderComponent, HeaderTemplateDirective, HighlightDirective, IdService, InCellEditingDirective, IsEmptyFilterOperatorComponent, IsNotEmptyFilterOperatorComponent, IsNotNullFilterOperatorComponent, IsNullFilterOperatorComponent, KENDO_GRID, KENDO_GRID_BODY_EXPORTS, KENDO_GRID_COLUMN_DRAGANDDROP, KENDO_GRID_COLUMN_MENU_DECLARATIONS, KENDO_GRID_COLUMN_MENU_EXPORTS, KENDO_GRID_DECLARATIONS, KENDO_GRID_EXCEL_EXPORT, KENDO_GRID_EXPORTS, KENDO_GRID_FILTER_MENU, KENDO_GRID_FILTER_MENU_EXPORTS, KENDO_GRID_FILTER_OPERATORS, KENDO_GRID_FILTER_ROW, KENDO_GRID_FILTER_ROW_EXPORTS, KENDO_GRID_FILTER_SHARED, KENDO_GRID_FOOTER_EXPORTS, KENDO_GRID_GROUP_EXPORTS, KENDO_GRID_HEADER_EXPORTS, KENDO_GRID_PDF_EXPORT, KENDO_GRID_SHARED, LessFilterOperatorComponent, LessOrEqualToFilterOperatorComponent, ListComponent, LoadingComponent, LoadingTemplateDirective, LocalDataChangesService, LogicalCellDirective, LogicalRowDirective, MenuTabbingService, MultiCheckboxFilterComponent, NavigationService, NoRecordsTemplateDirective, NotEqualFilterOperatorComponent, NumericFilterCellComponent, NumericFilterComponent, NumericFilterMenuComponent, NumericFilterMenuInputComponent, PDFCommandDirective, PDFCommandToolbarDirective, PDFComponent, PDFMarginComponent, PDFModule, PDFService, PDFTemplateDirective, PopupCloseEvent, ReactiveEditingDirective, RedoCommandToolbarDirective, RemoveCommandDirective, RemoveCommandToolbarDirective, ResizableContainerDirective, ResizeService, ResponsiveService, RowDragHandleTemplateDirective, RowDragHintTemplateDirective, RowEditingDirectiveBase, RowReorderColumnComponent, RowReorderService, SaveCommandDirective, SaveCommandToolbarDirective, ScrollRequestService, ScrollSyncService, SelectAllCheckboxDirective, SelectAllToolbarToolComponent, SelectionCheckboxDirective, SelectionDirective, SelectionService, SinglePopupService, SizingOptionsService, Skip, SortCommandToolbarDirective, SortService, SpanColumnComponent, StartsWithFilterOperatorComponent, StatusBarTemplateDirective, StringFilterCellComponent, StringFilterComponent, StringFilterMenuComponent, StringFilterMenuInputComponent, SuspendService, TableBodyComponent, TableDirective, TemplateEditingDirective, ToolbarComponent, ToolbarTemplateDirective, UndoCommandToolbarDirective, UndoRedoDirective, UndoRedoEvent, defaultTrackBy, hasFilterMenu, hasFilterRow, isFilterable };

