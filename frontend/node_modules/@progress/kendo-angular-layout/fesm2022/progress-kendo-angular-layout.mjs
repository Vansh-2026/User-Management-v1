/**-----------------------------------------------------------------------------------------
* Copyright © 2026 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import * as i0 from '@angular/core';
import { Injectable, Directive, Optional, isDevMode, ContentChildren, ViewChildren, HostBinding, ViewChild, Input, SkipSelf, Host, Component, EventEmitter, HostListener, ContentChild, Output, Inject, QueryList, NgZone, forwardRef, ElementRef, ViewEncapsulation, TemplateRef, NgModule } from '@angular/core';
import * as i1 from '@progress/kendo-angular-l10n';
import { LocalizationService, L10N_PREFIX, ComponentMessages } from '@progress/kendo-angular-l10n';
import * as i1$1 from '@progress/kendo-angular-common';
import { Keys, getLicenseMessage, shouldShowValidationUI, normalizeKeys, WatermarkOverlayComponent, isDocumentAvailable, anyChanged, isObjectPresent, removeHTMLAttributes, parseAttributes, setHTMLAttributes, DraggableDirective, PreventableEvent as PreventableEvent$1, guid, ResizeSensorComponent, hasObservers, isPresent as isPresent$1, focusableSelector, isChanged } from '@progress/kendo-angular-common';
import { validatePackage } from '@progress/kendo-licensing';
import * as i1$2 from '@angular/animations';
import { trigger, state, transition, style, animate, AUTO_STYLE } from '@angular/animations';
import { Subject, BehaviorSubject, Subscription, of } from 'rxjs';
import { chevronUpIcon, chevronDownIcon, caretAltLeftIcon, caretAltRightIcon, caretAltUpIcon, caretAltDownIcon, xIcon, checkCircleIcon, exclamationCircleIcon, chevronRightIcon } from '@progress/kendo-svg-icons';
import { IconWrapperComponent } from '@progress/kendo-angular-icons';
import { NgTemplateOutlet, NgStyle, NgClass } from '@angular/common';
import { delay, takeUntil, map, tap, filter, switchMap, take } from 'rxjs/operators';
import { ProgressBarComponent } from '@progress/kendo-angular-progressbar';
import { Draggable } from '@progress/kendo-draggable';
import { ButtonComponent } from '@progress/kendo-angular-buttons';
import { DatePipe } from '@progress/kendo-angular-intl';

/**
 * @hidden
 */
const packageMetadata = {
    name: '@progress/kendo-angular-layout',
    productName: 'Kendo UI for Angular',
    productCode: 'KENDOUIANGULAR',
    productCodes: ['KENDOUIANGULAR'],
    publishDate: 1645546576,
    version: '22.0.1',
    licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/?utm_medium=product&utm_source=kendoangular&utm_campaign=kendo-ui-angular-purchase-license-keys-warning'
};

/**
 * Defines the expand modes of the PanelBar.
 */
var PanelBarExpandMode;
(function (PanelBarExpandMode) {
    /**
     * Allows you to expand only one item at a time.
     * When you expand an item, the item that was previously expanded is collapsed.
     */
    PanelBarExpandMode[PanelBarExpandMode["Single"] = 0] = "Single";
    /**
     * Allows you to expand only one item at a time and requires you to set the `height` property.
     * The expanded area occupies the entire height of the PanelBar.
     */
    PanelBarExpandMode[PanelBarExpandMode["Full"] = 1] = "Full";
    /**
     * The default mode of the PanelBar.
     * Allows you to expand more than one item at a time. Items can also be toggled.
     */
    PanelBarExpandMode[PanelBarExpandMode["Multiple"] = 2] = "Multiple";
    /**
     * The default expand mode set to `multiple`.
     */
    PanelBarExpandMode[PanelBarExpandMode["Default"] = 2] = "Default";
})(PanelBarExpandMode || (PanelBarExpandMode = {}));

/**
 * @hidden
 */
let nextPanelbarId = 0;
/**
 * @hidden
 */
class PanelBarService {
    children$;
    keepContent$;
    parent$;
    pbId;
    animate;
    expandMode;
    itemClick;
    childSource;
    keepContentSource;
    parentSource;
    onKeepContent(keepContent) {
        this.keepContentSource.next(keepContent);
    }
    onSelect(event) {
        this.childSource.next(event);
    }
    onFocus() {
        this.parentSource.next(true);
    }
    onBlur() {
        this.parentSource.next(false);
    }
    constructor() {
        this.parentSource = new Subject();
        this.keepContentSource = new BehaviorSubject(false);
        this.childSource = new Subject();
        this.itemClick = new Subject();
        this.parent$ = this.parentSource.asObservable();
        this.children$ = this.childSource.asObservable();
        this.keepContent$ = this.keepContentSource.asObservable();
        this.pbId = nextPanelbarId++;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PanelBarService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PanelBarService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PanelBarService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [] });

/**
 * Defines the content template of the declaratively initialized PanelBar items.
 * To define the content template, nest an `<ng-template>` tag
 * with the `kendoPanelBarContent` directive inside the `<kendo-panelbar-item>` tag.
 * The content can be expanded or collapsed through the item.
 *
 * @example
 * ```html
 * <kendo-panelbar-item title="Item">
 *   <div kendoPanelBarContent>
 *     <p>Item content goes here</p>
 *   </div>
 * </kendo-panelbar-item>
 * ```
 */
class PanelBarContentDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PanelBarContentDirective, deps: [{ token: i0.TemplateRef }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: PanelBarContentDirective, isStandalone: true, selector: "[kendoPanelBarContent]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PanelBarContentDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: "[kendoPanelBarContent]",
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef }] });

/**
 * Defines the template directive of the PanelBar which helps to customize the item title
 * ([more information and example]({% slug templates_panelbar %}#toc-customizing-the-appearance-of-the-title)).
 * To define the template, nest an `<ng-template>` tag
 * with the `kendoPanelBarItemTitle` directive inside the `<kendo-panelbar-item>` tag.
 *
 * The `kendoPanelBarItemTitle` directive overrides the PanelBarItem [title]({% slug api_layout_panelbaritemcomponent %}#toc-title) option.
 *
 * @example
 * ```html
 * <kendo-panelbar>
 *   <kendo-panelbar-item [expanded]="true">
 *     <ng-template kendoPanelBarItemTitle>
 *       Item Title
 *     </ng-template>
 *   </kendo-panelbar-item>
 * </kendo-panelbar>
 * ```
 */
class PanelBarItemTitleDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PanelBarItemTitleDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: PanelBarItemTitleDirective, isStandalone: true, selector: "[kendoPanelBarItemTitle]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PanelBarItemTitleDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoPanelBarItemTitle]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }] });

let nextId$1 = 0;
const SIZES = {
    small: 'sm',
    medium: 'md',
    large: 'lg'
};
const ROUNDNESS = {
    small: 'sm',
    medium: 'md',
    large: 'lg',
    full: 'full'
};
const SHAPE_TO_ROUNDED = {
    rounded: 'large',
    circle: 'full'
};
/**
 * @hidden
 */
const parsePanelBarItems = (data) => {
    return data.map((item) => {
        if (!isPresent(item.id)) {
            item.id = `default-${nextId$1++}`;
        }
        if (item.children) {
            item.children = parsePanelBarItems(item.children);
        }
        return item;
    });
};
/**
 * @hidden
 */
const isPresent = (value) => value !== null && value !== undefined;
/**
 * @hidden
 */
const isHorizontalArrowKey = keyCode => keyCode === Keys.ArrowLeft || keyCode === Keys.ArrowRight;
/**
 * @hidden
 */
const isVerticalArrowKey = keyCode => keyCode === Keys.ArrowUp || keyCode === Keys.ArrowDown;
/**
 * @hidden
 */
const isArrowKey = keyCode => isHorizontalArrowKey(keyCode) || isVerticalArrowKey(keyCode);
/**
 * @hidden
 */
const isNavigationKey = keyCode => keyCode === Keys.PageUp || keyCode === Keys.PageDown ||
    keyCode === Keys.Home || keyCode === Keys.End;
/**
 * @hidden
 *
 * Returns the styling classes to be added and removed
 */
const getStylingClasses = (componentType, stylingOption, previousValue, newValue) => {
    switch (stylingOption) {
        case 'size':
            return {
                toRemove: `k-${componentType}-${SIZES[previousValue]}`,
                toAdd: newValue !== 'none' ? `k-${componentType}-${SIZES[newValue]}` : ''
            };
        case 'rounded':
            return {
                toRemove: `k-rounded-${ROUNDNESS[previousValue]}`,
                toAdd: newValue !== 'none' ? `k-rounded-${ROUNDNESS[newValue]}` : ''
            };
        default:
            break;
    }
};
/**
 * @hidden
 */
const mapShapeToRounded = (shape) => SHAPE_TO_ROUNDED[shape] || 'none';
/**
 * @hidden
 */
const isNumber = (value) => typeof value === 'number' && isFinite(value);

const focusableRegex = /^(?:a|input|select|option|textarea|button|object)$/i;
const toClassList = (classNames) => String(classNames).trim().split(' ');
/**
 * @hidden
 */
const isFocusable = (element) => {
    if (element.tagName) {
        const tagName = element.tagName.toLowerCase();
        const tabIndex = element.getAttribute('tabindex');
        const skipTab = tabIndex === '-1';
        let focusable = tabIndex !== null && !skipTab;
        if (focusableRegex.test(tagName)) {
            focusable = !element.disabled && !skipTab;
        }
        return focusable;
    }
    return false;
};
/**
 * @hidden
 */
const hasClass = (element, className) => Boolean(toClassList(element.className).find((name) => name === className));
/**
 * @hidden
 */
const closestInScope = (target, predicate, scope, targetAttr) => {
    while (target && target !== scope && !predicate(target, targetAttr)) {
        target = target.parentNode;
    }
    if (target !== scope) {
        return target;
    }
};
/**
 * @hidden
 */
const itemIndex = (item, indexAttr) => +item.getAttribute(indexAttr);
const hasItemIndex = (item, indexAttr) => isPresent(item.getAttribute(indexAttr));
/**
 * @hidden
 */
const closestItem = (target, targetAttr, scope) => closestInScope(target, hasItemIndex, scope, targetAttr);

/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * @hidden
 */
let nextId = 0;
/**
 * Represents the PanelBar item component for Angular. Defines the items of the PanelBar.
 *
 * @example
 * ```html
 * <kendo-panelbar-item title="Item 1" [expanded]="true">
 *   <kendo-panelbar-item title="Sub Item 1"></kendo-panelbar-item>
 * </kendo-panelbar-item>
 * ```
 */
class PanelBarItemComponent {
    parent;
    eventService;
    element;
    renderer;
    /**
     * Sets the title of the PanelBar item ([see example]({% slug items_panelbar %}#toc-titles)).
     */
    title;
    /**
     * Allows the component to set the `"id"` property to each item.
     * Used to set the `id` attributes of the nested elements and to enable the WAI-ARIA support.
     */
    id = `default-${nextId++}`;
    /**
     * Defines the icon that renders next to the title ([see example]({% slug items_panelbar %}#toc-title-icons)).
     *
     * @default ''
     */
    icon = '';
    /**
     * Defines the icon that renders next to the title by using a custom CSS class
     * ([see example]({% slug items_panelbar %}#toc-title-icons)).
     *
     * @default ''
     */
    iconClass = '';
    /**
     * Defines an SVG icon to render.
     * You can use either an [existing Kendo SVG icon](slug:svgicon_list) or a custom one.
     */
    set svgIcon(icon) {
        if (isDevMode() && icon && this.icon && this.iconClass) {
            throw new Error('Setting both icon/svgIcon and iconClass options at the same time is not supported.');
        }
        this._svgIcon = icon;
    }
    get svgIcon() {
        return this._svgIcon;
    }
    /**
     * Defines the location of the image that displays next to the title
     * ([see example]({% slug items_panelbar %}#toc-title-images)).
     *
     * @default ''
     */
    imageUrl = '';
    /**
     * When set to `true`, disables a PanelBar item ([see example]({% slug items_panelbar %}#toc-disabled-state)).
     *
     * @default false
     */
    disabled = false;
    /**
     * When set to `true`, expands the PanelBar item ([see example]({% slug items_panelbar %}#toc-expanded-state)).
     */
    set expanded(value) {
        const activeState = this.animate ? "active" : "activeWithoutAnimation";
        this.state = value ? activeState : "inactive";
        if (!this.keepContent) {
            this.toggleExpandedChildAnimations(value);
        }
        this._expanded = value;
    }
    get expanded() {
        return this._expanded;
    }
    /**
     * Sets the selected state of a PanelBar item ([see example]({% slug items_panelbar %}#toc-selected-state)).
     *
     * @default false
     */
    selected = false;
    /**
     * Sets the content of the PanelBar item.
     * It is used when the [`items`]({% slug api_layout_panelbarcomponent %}#toc-items) property of the PanelBar is set.
     */
    content;
    /**
     * @hidden
     */
    items;
    /**
     * @hidden
     */
    template;
    header;
    contentWrapper;
    contentHeight;
    contentOverflow;
    keepContent = false;
    childrenItems;
    hasChildItems = false;
    hasItems = false;
    hasContent = false;
    state = "inactive";
    get animate() {
        return this.eventService.animate;
    }
    role = "treeitem";
    titleAttribute = null; // eslint-disable-line
    kItemClass = true;
    get kStateExpandedClass() {
        return !this.disabled && this.expanded && (this.hasChildItems || this.hasContent);
    }
    get itemId() {
        return 'k-panelbar-' + this.eventService.pbId + '-item-' + this.id;
    }
    get ariaExpanded() {
        return (this.hasChildItems || this.hasContent) ? !this.disabled && this.expanded : null;
    }
    get ariaSelected() {
        return !this.disabled && this.selected;
    }
    get ariaDisabled() {
        return this.disabled ? true : null;
    }
    get headerClass() {
        return this.parent ? null : true;
    }
    /**
     * @hidden
     */
    get titleTemplate() {
        return this.titleTemplates.length > 0 ? this.titleTemplates.toArray()[0].templateRef : undefined;
    }
    viewChildItems;
    contentItems;
    //ContentChild does not support descendants property, so we use ContentChildren for contentTemplate instead
    contentTemplate;
    titleTemplates;
    focused = false;
    wrapperFocused = false;
    subscriptions = new Subscription(() => { });
    _expanded = false;
    level;
    _svgIcon;
    constructor(parent, eventService, element, renderer) {
        this.parent = parent;
        this.eventService = eventService;
        this.element = element;
        this.renderer = renderer;
        this.subscriptions.add(eventService.parent$.subscribe(focused => this.onWrapperFocusChange(focused)));
        this.subscriptions.add(eventService.keepContent$.subscribe(keepContent => this.keepContent = keepContent));
        this.wrapperFocused = parent ? parent.focused : false;
        this.level = this.parent ? this.parent.level + 1 : 0;
    }
    /**
     * @hidden
     */
    headerHeight() {
        return this.element.nativeElement.offsetHeight - (this.contentWrapper ? this.contentWrapper.nativeElement.offsetHeight : 0);
    }
    ngOnInit() {
        this.addLevelClass();
    }
    ngAfterContentChecked() {
        this.hasItems = this.items && this.items.filter(item => !item.hidden).length > 0;
        this.hasChildItems = this.contentItems.filter(item => item !== this).length > 0 || this.hasItems;
        this.hasContent = (this.contentTemplate !== undefined && this.contentTemplate.length > 0) ||
            this.content !== undefined;
        this.validateConfiguration();
    }
    ngAfterViewChecked() {
        if (this.items) {
            this.childrenItems = this.viewChildItems.toArray();
        }
        else {
            this.childrenItems = this.contentItems.filter(item => item !== this);
        }
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    /**
     * @hidden
     */
    onItemAction() {
        if (!this.disabled) {
            this.eventService.onSelect(this);
        }
    }
    /**
     * @hidden
     */
    onItemClick(e) {
        if (!isFocusable(e.target)) {
            this.eventService.itemClick.next({ item: this.serialize(), originalEvent: e });
            this.onItemAction();
        }
    }
    /**
     * @hidden
     */
    get iconClasses() {
        if (this.icon) {
            return `${this.icon}`;
        }
    }
    /**
     * @hidden
     */
    get customIconClasses() {
        if (this.iconClass) {
            return `${this.iconClass}`;
        }
    }
    /**
     * @hidden
     */
    get dirInnerCssClasses() {
        const dirClass = this.expanded ? 'k-panelbar-collapse' : 'k-panelbar-expand';
        return `k-panelbar-toggle ${dirClass}`;
    }
    /**
     * @hidden
     */
    get expanderSVGIcon() {
        return this.expanded ? chevronUpIcon : chevronDownIcon;
    }
    /**
     * @hidden
     */
    serialize() {
        return {
            content: this.content,
            disabled: this.disabled,
            expanded: this.expanded,
            focused: this.focused,
            icon: this.icon,
            iconClass: this.iconClass,
            svgIcon: this.svgIcon,
            id: this.id,
            imageUrl: this.imageUrl,
            selected: this.selected,
            title: this.title,
            children: this.items
        };
    }
    /**
     * @hidden
     */
    subTreeViewItems() {
        let subTree = [];
        this.viewChildItems.forEach(item => {
            subTree = subTree.concat(item.subTreeViewItems());
            subTree.push(item);
        });
        return subTree;
    }
    /**
     * @hidden
     */
    validateConfiguration() {
        if (isDevMode()) {
            if (this.content && (this.contentTemplate !== undefined && this.contentTemplate.length > 0)) {
                throw new Error("Invalid configuration: mixed template components and component property.");
            }
        }
    }
    /**
     * @hidden
     */
    toggleAnimationState(value) {
        if (!this.animate) {
            return;
        }
        this.state = value && this.eventService.expandMode !== PanelBarExpandMode.Single ? 'active' : 'activeWithoutAnimation';
    }
    /**
     * @hidden
     */
    toggleExpandedChildAnimations(value) {
        if (this.childrenItems) {
            this.childrenItems.forEach(child => {
                if (child.expanded) {
                    child.toggleAnimationState(value);
                    child.toggleExpandedChildAnimations(value);
                }
            });
        }
    }
    /**
     * @hidden
     */
    addLevelClass() {
        if (this.level >= 0) {
            this.renderer.addClass(this.element.nativeElement, `k-level-${this.level}`);
        }
    }
    onWrapperFocusChange(focused) {
        this.wrapperFocused = focused;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PanelBarItemComponent, deps: [{ token: PanelBarItemComponent, host: true, optional: true, skipSelf: true }, { token: PanelBarService }, { token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: PanelBarItemComponent, isStandalone: true, selector: "kendo-panelbar-item", inputs: { title: "title", id: "id", icon: "icon", iconClass: "iconClass", svgIcon: "svgIcon", imageUrl: "imageUrl", disabled: "disabled", expanded: "expanded", selected: "selected", content: "content", items: "items", template: "template" }, host: { properties: { "attr.role": "this.role", "attr.title": "this.titleAttribute", "class.k-panelbar-item": "this.kItemClass", "class.k-expanded": "this.kStateExpandedClass", "id": "this.itemId", "attr.aria-expanded": "this.ariaExpanded", "attr.aria-selected": "this.ariaSelected", "attr.aria-disabled": "this.ariaDisabled", "class.k-panelbar-header": "this.headerClass" } }, queries: [{ propertyName: "contentItems", predicate: PanelBarItemComponent }, { propertyName: "contentTemplate", predicate: PanelBarContentDirective }, { propertyName: "titleTemplates", predicate: PanelBarItemTitleDirective }], viewQueries: [{ propertyName: "header", first: true, predicate: ["header"], descendants: true }, { propertyName: "contentWrapper", first: true, predicate: ["contentWrapper"], descendants: true }, { propertyName: "viewChildItems", predicate: PanelBarItemComponent, descendants: true }], exportAs: ["kendoPanelbarItem"], ngImport: i0, template: `
            <span
              #header
              [class.k-link]="true"
              [class.k-selected]="!disabled && selected"
              [class.k-focus]="focused && wrapperFocused"
              [class.k-disabled]="disabled"
              (click)="onItemClick($event)">
              @if (icon || iconClass || svgIcon) {
                <kendo-icon-wrapper
                  [name]="iconClasses"
                  [customFontClass]="customIconClasses"
                  [svgIcon]="svgIcon"
                  innerCssClass="k-panelbar-item-icon"
                  >
                </kendo-icon-wrapper>
              }
              @if (imageUrl) {
                <img
                  class="k-image k-panelbar-item-icon"
                  [src]="imageUrl"
                  alt="">
              }
              @if (!titleTemplate) {
                <span class="k-panelbar-item-text">{{title}}</span>
              }
              @if (titleTemplate) {
                <ng-template
                  [ngTemplateOutlet]="titleTemplate"
                [ngTemplateOutletContext]="{
                    item: {
                        title: title,
                        id: id,
                        icon: icon,
                        iconClass: iconClass,
                        svgIcon: svgIcon,
                        imageUrl: imageUrl,
                        selected: selected,
                        expanded: expanded,
                        disabled: disabled,
                        focused: focused,
                        content: content
                    }
                }"></ng-template>
            }
            @if (hasChildItems || hasContent) {
              <kendo-icon-wrapper
                [name]="expanded ? 'chevron-up' : 'chevron-down'"
                [svgIcon]="expanderSVGIcon"
                [innerCssClass]="dirInnerCssClasses"
                >
              </kendo-icon-wrapper>
            }
            </span>
            @if ((!disabled && expanded) || keepContent !== false) {
              @defer (when ((!disabled && expanded && keepContent !== true) || keepContent === true); prefetch on idle) {
                <div
                  #contentWrapper
                  [@toggle]="state"
                  [attr.role]="'group'"
                  [attr.aria-hidden]="!disabled && !expanded"
                  >
                @if (hasChildItems && !items?.length) {
                  <div
                    [style.overflow]="contentOverflow"
                    [style.height]="contentHeight"
                    class="k-panelbar-group"
                    >
                    <ng-content select="kendo-panelbar-item"></ng-content>
                  </div>
                }
                @if (hasContent && !content) {
                  <div
                    [style.overflow]="contentOverflow"
                    [style.height]="contentHeight"
                    class="k-panelbar-content">
                    <ng-template
                      [ngTemplateOutlet]="contentTemplate.first.templateRef"
                        [ngTemplateOutletContext]="{
                            $implicit: {
                                title: title,
                                id: id,
                                icon: icon,
                                imageUrl: imageUrl,
                                disabled: disabled,
                                content: content
                            }
                        }">
                  </ng-template>
                </div>
              }
              @if (hasItems) {
                <div
                  [style.overflow]="contentOverflow"
                  [style.height]="contentHeight"
                  class="k-panelbar-group">
                  @for (item of items; track item) {
                    @if (!item.hidden) {
                      <kendo-panelbar-item
                        [title]="item.title"
                        [id]="item.id"
                        [icon]="item.icon"
                        [iconClass]="item.iconClass"
                        [svgIcon]="item.svgIcon"
                        [imageUrl]="item.imageUrl"
                        [selected]="!!item.selected"
                        [expanded]="!!item.expanded"
                        [disabled]="!!item.disabled"
                        [template]="template"
                        [items]="item.children"
                        [content]="item.content">
                      </kendo-panelbar-item>
                    }
                  }
                </div>
              }
              @if (content) {
                <div
                  [style.overflow]="contentOverflow"
                  [style.height]="contentHeight"
                  class="k-panelbar-content">
                  <ng-template
                    [ngTemplateOutlet]="template"
                        [ngTemplateOutletContext]="{
                            $implicit: {
                                title: title,
                                id: id,
                                icon: icon,
                                imageUrl: imageUrl,
                                disabled: disabled,
                                content: content
                            }
                        }">
                </ng-template>
                @if (!template) {
                  {{content}}
                }
              </div>
            }
            </div>
              }
            }
    `, isInline: true, dependencies: [{ kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }], animations: [
            trigger('toggle', [
                state('inactive', style({ display: 'none' })),
                transition('* => active', [
                    style({ overflow: 'hidden', display: 'block', height: 0 }),
                    animate(200, style({ height: AUTO_STYLE }))
                ]),
                transition('active => *', [
                    style({ overflow: 'hidden', height: AUTO_STYLE }),
                    animate(200, style({ height: 0, display: 'none' }))
                ])
            ])
        ], deferBlockDependencies: [() => [PanelBarItemComponent, NgTemplateOutlet]] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PanelBarItemComponent, decorators: [{
            type: Component,
            args: [{
                    animations: [
                        trigger('toggle', [
                            state('inactive', style({ display: 'none' })),
                            transition('* => active', [
                                style({ overflow: 'hidden', display: 'block', height: 0 }),
                                animate(200, style({ height: AUTO_STYLE }))
                            ]),
                            transition('active => *', [
                                style({ overflow: 'hidden', height: AUTO_STYLE }),
                                animate(200, style({ height: 0, display: 'none' }))
                            ])
                        ])
                    ],
                    exportAs: 'kendoPanelbarItem',
                    selector: "kendo-panelbar-item",
                    template: `
            <span
              #header
              [class.k-link]="true"
              [class.k-selected]="!disabled && selected"
              [class.k-focus]="focused && wrapperFocused"
              [class.k-disabled]="disabled"
              (click)="onItemClick($event)">
              @if (icon || iconClass || svgIcon) {
                <kendo-icon-wrapper
                  [name]="iconClasses"
                  [customFontClass]="customIconClasses"
                  [svgIcon]="svgIcon"
                  innerCssClass="k-panelbar-item-icon"
                  >
                </kendo-icon-wrapper>
              }
              @if (imageUrl) {
                <img
                  class="k-image k-panelbar-item-icon"
                  [src]="imageUrl"
                  alt="">
              }
              @if (!titleTemplate) {
                <span class="k-panelbar-item-text">{{title}}</span>
              }
              @if (titleTemplate) {
                <ng-template
                  [ngTemplateOutlet]="titleTemplate"
                [ngTemplateOutletContext]="{
                    item: {
                        title: title,
                        id: id,
                        icon: icon,
                        iconClass: iconClass,
                        svgIcon: svgIcon,
                        imageUrl: imageUrl,
                        selected: selected,
                        expanded: expanded,
                        disabled: disabled,
                        focused: focused,
                        content: content
                    }
                }"></ng-template>
            }
            @if (hasChildItems || hasContent) {
              <kendo-icon-wrapper
                [name]="expanded ? 'chevron-up' : 'chevron-down'"
                [svgIcon]="expanderSVGIcon"
                [innerCssClass]="dirInnerCssClasses"
                >
              </kendo-icon-wrapper>
            }
            </span>
            @if ((!disabled && expanded) || keepContent !== false) {
              @defer (when ((!disabled && expanded && keepContent !== true) || keepContent === true); prefetch on idle) {
                <div
                  #contentWrapper
                  [@toggle]="state"
                  [attr.role]="'group'"
                  [attr.aria-hidden]="!disabled && !expanded"
                  >
                @if (hasChildItems && !items?.length) {
                  <div
                    [style.overflow]="contentOverflow"
                    [style.height]="contentHeight"
                    class="k-panelbar-group"
                    >
                    <ng-content select="kendo-panelbar-item"></ng-content>
                  </div>
                }
                @if (hasContent && !content) {
                  <div
                    [style.overflow]="contentOverflow"
                    [style.height]="contentHeight"
                    class="k-panelbar-content">
                    <ng-template
                      [ngTemplateOutlet]="contentTemplate.first.templateRef"
                        [ngTemplateOutletContext]="{
                            $implicit: {
                                title: title,
                                id: id,
                                icon: icon,
                                imageUrl: imageUrl,
                                disabled: disabled,
                                content: content
                            }
                        }">
                  </ng-template>
                </div>
              }
              @if (hasItems) {
                <div
                  [style.overflow]="contentOverflow"
                  [style.height]="contentHeight"
                  class="k-panelbar-group">
                  @for (item of items; track item) {
                    @if (!item.hidden) {
                      <kendo-panelbar-item
                        [title]="item.title"
                        [id]="item.id"
                        [icon]="item.icon"
                        [iconClass]="item.iconClass"
                        [svgIcon]="item.svgIcon"
                        [imageUrl]="item.imageUrl"
                        [selected]="!!item.selected"
                        [expanded]="!!item.expanded"
                        [disabled]="!!item.disabled"
                        [template]="template"
                        [items]="item.children"
                        [content]="item.content">
                      </kendo-panelbar-item>
                    }
                  }
                </div>
              }
              @if (content) {
                <div
                  [style.overflow]="contentOverflow"
                  [style.height]="contentHeight"
                  class="k-panelbar-content">
                  <ng-template
                    [ngTemplateOutlet]="template"
                        [ngTemplateOutletContext]="{
                            $implicit: {
                                title: title,
                                id: id,
                                icon: icon,
                                imageUrl: imageUrl,
                                disabled: disabled,
                                content: content
                            }
                        }">
                </ng-template>
                @if (!template) {
                  {{content}}
                }
              </div>
            }
            </div>
              }
            }
    `,
                    standalone: true,
                    imports: [IconWrapperComponent, NgTemplateOutlet]
                }]
        }], ctorParameters: () => [{ type: PanelBarItemComponent, decorators: [{
                    type: SkipSelf
                }, {
                    type: Host
                }, {
                    type: Optional
                }] }, { type: PanelBarService }, { type: i0.ElementRef }, { type: i0.Renderer2 }], propDecorators: { title: [{
                type: Input
            }], id: [{
                type: Input
            }], icon: [{
                type: Input
            }], iconClass: [{
                type: Input
            }], svgIcon: [{
                type: Input
            }], imageUrl: [{
                type: Input
            }], disabled: [{
                type: Input
            }], expanded: [{
                type: Input
            }], selected: [{
                type: Input
            }], content: [{
                type: Input
            }], items: [{
                type: Input
            }], template: [{
                type: Input
            }], header: [{
                type: ViewChild,
                args: ['header', { static: false }]
            }], contentWrapper: [{
                type: ViewChild,
                args: ['contentWrapper', { static: false }]
            }], role: [{
                type: HostBinding,
                args: ['attr.role']
            }], titleAttribute: [{
                type: HostBinding,
                args: ['attr.title']
            }], kItemClass: [{
                type: HostBinding,
                args: ['class.k-panelbar-item']
            }], kStateExpandedClass: [{
                type: HostBinding,
                args: ['class.k-expanded']
            }], itemId: [{
                type: HostBinding,
                args: ['id']
            }], ariaExpanded: [{
                type: HostBinding,
                args: ['attr.aria-expanded']
            }], ariaSelected: [{
                type: HostBinding,
                args: ['attr.aria-selected']
            }], ariaDisabled: [{
                type: HostBinding,
                args: ['attr.aria-disabled']
            }], headerClass: [{
                type: HostBinding,
                args: ['class.k-panelbar-header']
            }], viewChildItems: [{
                type: ViewChildren,
                args: [PanelBarItemComponent]
            }], contentItems: [{
                type: ContentChildren,
                args: [PanelBarItemComponent]
            }], contentTemplate: [{
                type: ContentChildren,
                args: [PanelBarContentDirective, { descendants: false }]
            }], titleTemplates: [{
                type: ContentChildren,
                args: [PanelBarItemTitleDirective, { descendants: false }]
            }] } });

/**
 * Defines the template directive of the PanelBar which helps to customize the item content.
 * To define the template, nest an `<ng-template>` tag
 * with the `kendoPanelBarItemTemplate` directive inside the `<kendo-panelbar>` tag.
 *
 * @example
 * ```html
 * <kendo-panelbar>
 *   <ng-template kendoPanelBarItemTemplate let-dataItem>
 *     <span>{{ dataItem.title }}</span>
 *   </ng-template>
 * </kendo-panelbar>
 * ```
 */
class PanelBarItemTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PanelBarItemTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: PanelBarItemTemplateDirective, isStandalone: true, selector: "[kendoPanelBarItemTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PanelBarItemTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoPanelBarItemTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }] });

/**
 * @hidden
 */
class PreventableEvent {
    prevented = false;
    /**
     * Prevents the default action for a specified event.
     * The source component suppresses the built-in behavior that follows the event.
     */
    preventDefault() {
        this.prevented = true;
    }
    /**
     * Returns `true` if the event was prevented by any of its subscribers.
     *
     * @returns `true` if the default action was prevented. Otherwise, returns `false`.
     */
    isDefaultPrevented() {
        return this.prevented;
    }
    /**
     * @hidden
     */
    constructor(args) {
        Object.assign(this, args);
    }
}

/**
 * Defines the arguments for the `collapse` event of the PanelBar.
 */
class PanelBarCollapseEvent extends PreventableEvent {
    /**
     * Defines the item that will be collapsed.
     */
    item;
}

/**
 * Defines the arguments for the `expand` event of the PanelBar.
 */
class PanelBarExpandEvent extends PreventableEvent {
    /**
     * Defines the item that will be expanded.
     */
    item;
}

/**
 * Defines the arguments for the `select` event of the PanelBar.
 */
class PanelBarSelectEvent extends PreventableEvent {
    /**
     * Defines the item that will be selected.
     */
    item;
}

/**
 * Defines the arguments for the `stateChange` event of the PanelBar.
 */
class PanelBarStateChangeEvent {
    /**
     * Defines a collection of all modified items.
     */
    items;
}

/**
 * Defines the arguments for the `itemClick` event of the PanelBar.
 */
class PanelBarItemClickEvent {
    /**
     * Defines the clicked item.
     */
    item;
    /**
     * Defines the DOM event that triggered the `itemClick` event.
     */
    originalEvent;
}

/**
 * Represents the Kendo UI PanelBar component for Angular.
 * Displays hierarchical data as an expandable and collapsible accordion-style interface ([see overview]({% slug overview_panelbar %})).
 *
 * @example
 * ```typescript
 * @Component({
 *   selector: 'my-app',
 *   template: `
 *     <kendo-panelbar [items]="items" expandMode="single">
 *     </kendo-panelbar>
 *   `
 * })
 * class AppComponent {
 *   items = [
 *     { title: 'Item 1', expanded: true, content: 'Content 1' },
 *     { title: 'Item 2', content: 'Content 2' }
 *   ];
 * }
 * ```
 * @remarks
 * Supported children components are: {@link PanelBarItemComponent}.
 */
// TODO: add styles as input prop
class PanelBarComponent {
    localization;
    /**
     * Sets the expand mode of the PanelBar through the `PanelBarExpandMode` enum ([see example]({% slug expandmodes_panelbar %})).
     *
     * @default 'multiple
     */
    expandMode = PanelBarExpandMode.Default;
    /**
     * Allows the PanelBar to modify the selected state of the items.
     *
     * @default true
     */
    selectable = true;
    /**
     * Sets the animate state of the PanelBar ([see example]({% slug animations_panelbar %})).
     *
     * @default true
     */
    animate = true;
    /**
     * Sets the height of the component when the `"full"` expand mode is used.
     * This option is ignored when the `"multiple"` or `"single"` expand modes are used.
     *
     * @default '400px'
     */
    height = '400px';
    /**
    * Controls how the PanelBar renders item content.
    *
    * The available options are:
    *
    * * `true`&mdash;Renders all items' content and persists them in the DOM.
    * * `false`&mdash;Removes collapsed items' content from the DOM.
    * * `"loadOnDemand"`&mdash;Loads items' content only when expanded for the first time. Collapsed items' content is not rendered until the item is expanded.
    *
    * For more information, refer to the [Rendering Modes](slug:rendering_panelbar) article.
    *
    * @default false
    */
    get keepItemContent() {
        return this._keepItemContent;
    }
    set keepItemContent(keepItemContent) {
        this._keepItemContent = keepItemContent;
        this.eventService.onKeepContent(keepItemContent);
    }
    /**
     * Sets the items of the PanelBar as an array of `PanelBarItemModel` instances
     * ([see example]({% slug items_panelbar %})).
     */
    set items(data) {
        if (data) {
            this._items = parsePanelBarItems(data);
        }
    }
    get items() {
        return this._items;
    }
    /**
     * Fires when the state of the PanelBar changes.
     * This event is triggered when an item is selected, expanded, or collapsed.
     * ([see example](slug:routing_panelbar#using-router-service)).
     * The event data contains a collection of all items that are modified.
     */
    stateChange = new EventEmitter();
    /**
     * Fires when an item is about to be selected.
     * This event is preventable. If you cancel it, the item will not be selected
     * ([see example]({% slug events_panelbar %})).
     */
    select = new EventEmitter();
    /**
     * Fires when an item is about to be expanded.
     * This event is preventable. If you cancel it, the item will remain collapsed
     * ([see example]({% slug events_panelbar %})).
     */
    expand = new EventEmitter();
    /**
     * Fires when an item is about to be collapsed.
     * This event is preventable. If you cancel it, the item will remain expanded
     * ([see example]({% slug events_panelbar %})).
     */
    collapse = new EventEmitter();
    /**
     * Fires when an item is clicked ([see example]({% slug events_panelbar %})).
     */
    itemClick = new EventEmitter();
    hostClasses = true;
    tabIndex = 0;
    role = 'tree';
    activeDescendant = '';
    get hostHeight() {
        return this.expandMode === PanelBarExpandMode.Full ? this.height : 'auto';
    }
    get overflow() {
        return this.expandMode === PanelBarExpandMode.Full ? 'hidden' : 'visible';
    }
    get dir() {
        return this.localization.rtl ? 'rtl' : 'ltr';
    }
    template;
    contentItems;
    contentChildItems;
    viewChildItems;
    /**
     * @hidden
     */
    showLicenseWatermark = false;
    /**
     * @hidden
     */
    licenseMessage;
    allItems;
    childrenItems;
    isViewInit = true;
    focused = false;
    _items;
    _keepItemContent = false;
    elementRef;
    eventService;
    keyBindings;
    subs = new Subscription();
    constructor(elementRef, eventService, localization) {
        this.localization = localization;
        const isValid = validatePackage(packageMetadata);
        this.licenseMessage = getLicenseMessage(packageMetadata);
        this.showLicenseWatermark = shouldShowValidationUI(isValid);
        /* eslint-disable-line*/
        this.keyBindings = this.computedKeys;
        this.elementRef = elementRef;
        this.eventService = eventService;
        this.subs.add(this.eventService.children$.subscribe(event => this.onItemAction(event)));
        this.subs.add(this.eventService.itemClick.subscribe(ev => this.itemClick.emit(ev)));
    }
    /**
     * @hidden
     */
    invertKeys(original, inverted) {
        return this.localization.rtl ? inverted : original;
    }
    get computedKeys() {
        return {
            [Keys.Space]: () => this.selectFocusedItem(),
            [Keys.Enter]: () => this.selectFocusedItem(),
            [Keys.NumpadEnter]: () => this.selectFocusedItem(),
            [Keys.ArrowUp]: () => this.focusPreviousItem(),
            [this.invertKeys(Keys.ArrowLeft, Keys.ArrowRight)]: () => this.collapseItem(),
            [Keys.ArrowDown]: () => this.focusNextItem(),
            [this.invertKeys(Keys.ArrowRight, Keys.ArrowLeft)]: () => this.expandItem(),
            [Keys.End]: () => this.focusLastItem(),
            [Keys.Home]: () => this.focusFirstItem()
        };
    }
    ngOnDestroy() {
        this.subs.unsubscribe();
    }
    ngOnInit() {
        this.subs.add(this.localization.changes.subscribe(() => this.keyBindings = this.computedKeys));
        this.eventService.animate = this.animate;
        this.eventService.expandMode = this.expandMode;
    }
    ngAfterViewChecked() {
        if (this.items) {
            this.childrenItems = this.viewChildItems.toArray();
            this.allItems = this.viewItems;
        }
        else {
            this.childrenItems = this.contentChildItems.toArray();
            this.allItems = this.contentItems.toArray();
        }
        if (this.isViewInit && this.childrenItems.length) {
            this.isViewInit = false;
            setTimeout(() => this.updateChildrenHeight());
        }
        this.validateConfiguration();
    }
    ngOnChanges(changes) {
        if (changes['height'] || changes['expandMode'] || changes['items']) { // eslint-disable-line
            if (this.childrenItems) {
                setTimeout(this.updateChildrenHeight);
            }
        }
        if (changes['animate']) {
            this.eventService.animate = this.animate;
        }
        if (changes['expandMode']) {
            this.eventService.expandMode = this.expandMode;
        }
    }
    get templateRef() {
        return this.template ? this.template.templateRef : undefined;
    }
    /**
     * @hidden
     */
    onComponentClick(event) {
        const itemClicked = this.visibleItems().some((item) => {
            return item.header.nativeElement.contains(event.target);
        });
        if (!isFocusable(event.target) && !this.focused && itemClicked) {
            this.elementRef.nativeElement.focus();
        }
    }
    /**
     * @hidden
     */
    onComponentFocus() {
        this.eventService.onFocus();
        this.focused = true;
        if (this.allItems.length > 0) {
            const visibleItems = this.visibleItems();
            const focusedItems = visibleItems.filter(item => item.focused);
            if (!focusedItems.length && visibleItems.length > 0) {
                visibleItems[0].focused = true;
                this.activeDescendant = visibleItems[0].itemId;
            }
        }
    }
    /**
     * @hidden
     */
    onComponentBlur() {
        this.eventService.onBlur();
        this.focused = false;
        this.activeDescendant = '';
    }
    /**
     * @hidden
     */
    onComponentKeyDown(event) {
        if (event.target === this.elementRef.nativeElement) {
            // on some keyboards arrow keys, PageUp/Down, and Home/End are mapped to Numpad keys
            const code = normalizeKeys(event);
            if (code === Keys.Space || code === Keys.ArrowUp || code === Keys.ArrowDown ||
                code === Keys.ArrowLeft || code === Keys.ArrowRight || code === Keys.Home ||
                code === Keys.End || code === Keys.PageUp || code === Keys.PageDown) {
                event.preventDefault();
            }
            const handler = this.keyBindings[code];
            //TODO: check if next item is disabled and skip operation?
            if (handler) {
                handler();
            }
        }
    }
    /**
     * @hidden
     */
    emitEvent(event, item) {
        let eventArgs;
        switch (event) {
            case 'select':
                eventArgs = new PanelBarSelectEvent();
                break;
            case 'collapse':
                eventArgs = new PanelBarCollapseEvent();
                break;
            default:
                eventArgs = new PanelBarExpandEvent();
                break;
        }
        eventArgs.item = item.serialize();
        this[event].emit(eventArgs);
        return eventArgs;
    }
    get viewItems() {
        let treeItems = [];
        this.viewChildItems.toArray().forEach(item => {
            treeItems.push(item);
            treeItems = treeItems.concat(item.subTreeViewItems());
        });
        return treeItems;
    }
    validateConfiguration() {
        if (isDevMode()) {
            if (this.items && (this.contentItems && this.contentItems.length > 0)) {
                throw new Error('Invalid configuration: mixed template components and items property.');
            }
        }
    }
    updateChildrenHeight = () => {
        let childrenHeight = 0;
        const panelbarHeight = this.elementRef.nativeElement.offsetHeight;
        const contentOverflow = this.expandMode === PanelBarExpandMode.Full ? 'auto' : 'visible';
        this.childrenItems.forEach(item => {
            childrenHeight += item.headerHeight();
        });
        this.childrenItems.forEach(item => {
            item.contentHeight = PanelBarExpandMode.Full === this.expandMode ? (panelbarHeight - childrenHeight) + 'px' : 'auto';
            item.contentOverflow = contentOverflow;
        });
    };
    onItemAction(item) {
        if (!item) {
            return;
        }
        const modifiedItems = new Array();
        const selectPreventedItems = [];
        let isSelectPrevented = false;
        if (this.selectable && !item.selected) {
            isSelectPrevented = this.emitEvent('select', item).isDefaultPrevented();
        }
        if (!isSelectPrevented) {
            this.allItems.forEach((currentItem) => {
                let selectedState = currentItem === item;
                const focusedState = selectedState;
                selectedState = this.selectable ? selectedState : currentItem.selected;
                if (currentItem.selected !== selectedState || currentItem.focused !== focusedState) {
                    currentItem.selected = selectedState;
                    currentItem.focused = focusedState;
                    this.activeDescendant = focusedState ? currentItem.itemId : '';
                    modifiedItems.push(currentItem);
                }
            });
        }
        else {
            selectPreventedItems.push(item);
            this.allItems.forEach((currentItem) => {
                const focusedState = currentItem === item;
                if (currentItem.focused !== focusedState) {
                    currentItem.focused = focusedState;
                    this.activeDescendant = focusedState ? currentItem.itemId : '';
                    modifiedItems.push(currentItem);
                }
            });
        }
        if (this.expandMode === PanelBarExpandMode.Multiple) {
            if ((item.hasChildItems || item.hasContent) && !selectPreventedItems.includes(item)) {
                const isEventPrevented = item.expanded ?
                    this.emitEvent('collapse', item).isDefaultPrevented() :
                    this.emitEvent('expand', item).isDefaultPrevented();
                if (!isEventPrevented) {
                    item.expanded = !item.expanded;
                    if (modifiedItems.indexOf(item) < 0) {
                        modifiedItems.push(item);
                    }
                }
            }
        }
        else {
            const siblings = item.parent ? item.parent.childrenItems : this.childrenItems;
            let preventedCollapseItem;
            const expandedItems = [];
            if ((item.hasChildItems || item.hasContent) && !selectPreventedItems.includes(item)) {
                siblings
                    .forEach((currentItem) => {
                    const expandedState = currentItem === item;
                    if (currentItem.expanded !== expandedState) {
                        const isEventPrevented = currentItem.expanded ?
                            this.emitEvent('collapse', currentItem).isDefaultPrevented() :
                            this.emitEvent('expand', currentItem).isDefaultPrevented();
                        if (!isEventPrevented) {
                            currentItem.expanded = expandedState;
                            if (currentItem.expanded) {
                                expandedItems.push(currentItem);
                            }
                            if (modifiedItems.indexOf(currentItem) < 0) {
                                modifiedItems.push(currentItem);
                            }
                        }
                        else if (isEventPrevented && currentItem.expanded) {
                            preventedCollapseItem = currentItem;
                        }
                    }
                    else if (currentItem.expanded === expandedState && expandedState) {
                        const isCollapsePrevented = this.emitEvent('collapse', currentItem).isDefaultPrevented();
                        if (!isCollapsePrevented) {
                            currentItem.expanded = !currentItem.expanded;
                            if (modifiedItems.indexOf(currentItem) < 0) {
                                modifiedItems.push(currentItem);
                            }
                        }
                    }
                });
                expandedItems.forEach(item => {
                    if (preventedCollapseItem && item.id !== preventedCollapseItem.id) {
                        item.expanded = false;
                        if (isDevMode()) {
                            const expandMode = PanelBarExpandMode[this.expandMode].toLowerCase();
                            console.warn(`
                            The ${expandMode} expandMode allows the expansion of only one item at a time.
                            See https://www.telerik.com/kendo-angular-ui/components/layout/panelbar/expand-modes/`);
                        }
                    }
                });
            }
        }
        if (modifiedItems.length > 0) {
            const eventArgs = new PanelBarStateChangeEvent();
            eventArgs.items = modifiedItems.map(currentItem => currentItem.serialize());
            this.stateChange.emit(eventArgs);
        }
    }
    isVisible(item) {
        const visibleItems = this.visibleItems();
        return visibleItems.some(i => i === item);
    }
    getVisibleParent(item) {
        const visibleItems = this.visibleItems();
        if (!item.parent) {
            return item;
        }
        return visibleItems.some(i => i === item.parent) ? item.parent : this.getVisibleParent(item.parent);
    }
    focusItem(action) {
        const visibleItems = this.visibleItems();
        let currentIndex = visibleItems.findIndex(item => item.focused);
        let currentItem = visibleItems[currentIndex];
        let nextItem;
        if (currentIndex === -1) {
            const focusedItem = this.allItems.find(item => item.focused);
            focusedItem.focused = false;
            currentItem = this.getVisibleParent(focusedItem);
            currentIndex = visibleItems.findIndex(item => item === currentItem);
        }
        switch (action) {
            case 'lastItem':
                nextItem = visibleItems[visibleItems.length - 1];
                break;
            case 'firstItem':
                nextItem = visibleItems[0];
                break;
            case 'nextItem':
                nextItem = visibleItems[currentIndex < visibleItems.length - 1 ? currentIndex + 1 : 0];
                break;
            case 'previousItem':
                nextItem = visibleItems[currentIndex > 0 ? currentIndex - 1 : visibleItems.length - 1];
                break;
            default:
        }
        if (currentItem && nextItem && currentItem !== nextItem) {
            this.moveFocus(currentItem, nextItem);
        }
    }
    moveFocus(from, to) {
        if (!from || !to) {
            return;
        }
        from.focused = false;
        to.focused = true;
        this.activeDescendant = to.itemId;
        const modifiedItems = new Array(from.serialize(), to.serialize());
        const eventArgs = new PanelBarStateChangeEvent();
        eventArgs.items = modifiedItems;
        this.stateChange.emit(eventArgs);
    }
    focusLastItem() {
        this.focusItem('lastItem');
    }
    focusFirstItem() {
        this.focusItem('firstItem');
    }
    focusNextItem() {
        this.focusItem('nextItem');
    }
    focusPreviousItem() {
        this.focusItem('previousItem');
    }
    expandItem() {
        let currentItem = this.allItems.filter(item => item.focused)[0];
        if (!this.isVisible(currentItem)) {
            currentItem.focused = false;
            currentItem = this.getVisibleParent(currentItem);
        }
        if (currentItem.hasChildItems || currentItem.hasContent) {
            if (!currentItem.expanded) {
                this.onItemAction(currentItem);
            }
            else if (currentItem.hasChildItems) {
                const firstChildIndex = currentItem.childrenItems.findIndex(item => !item.disabled);
                if (firstChildIndex > -1) {
                    this.moveFocus(currentItem, currentItem.childrenItems[firstChildIndex]);
                }
            }
        }
    }
    collapseItem() {
        const currentItem = this.allItems.filter(item => item.focused)[0];
        if (currentItem.expanded) {
            this.onItemAction(currentItem);
        }
        else if (currentItem.parent) {
            this.moveFocus(currentItem, currentItem.parent);
        }
    }
    selectFocusedItem() {
        let focusedItem = this.allItems.filter(item => item.focused)[0];
        if (!this.isVisible(focusedItem)) {
            focusedItem.focused = false;
            focusedItem = this.getVisibleParent(focusedItem);
        }
        if (focusedItem) {
            focusedItem.onItemAction();
        }
    }
    visibleItems() {
        return this.flatVisibleItems(this.childrenItems);
    }
    flatVisibleItems(listOfItems = new Array(), flattedItems = new Array()) {
        listOfItems.forEach(item => {
            flattedItems.push(item);
            if (item.expanded && item.hasChildItems) {
                this.flatVisibleItems(item.childrenItems, flattedItems);
            }
        });
        return flattedItems;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PanelBarComponent, deps: [{ token: i0.ElementRef }, { token: PanelBarService }, { token: i1.LocalizationService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: PanelBarComponent, isStandalone: true, selector: "kendo-panelbar", inputs: { expandMode: "expandMode", selectable: "selectable", animate: "animate", height: "height", keepItemContent: "keepItemContent", items: "items" }, outputs: { stateChange: "stateChange", select: "select", expand: "expand", collapse: "collapse", itemClick: "itemClick" }, host: { listeners: { "click": "onComponentClick($event)", "focus": "onComponentFocus()", "blur": "onComponentBlur()", "keydown": "onComponentKeyDown($event)" }, properties: { "class.k-panelbar": "this.hostClasses", "attr.tabIndex": "this.tabIndex", "attr.role": "this.role", "attr.aria-activedescendant": "this.activeDescendant", "style.height": "this.hostHeight", "style.overflow": "this.overflow", "attr.dir": "this.dir" } }, providers: [
            PanelBarService,
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.panelbar'
            }
        ], queries: [{ propertyName: "template", first: true, predicate: PanelBarItemTemplateDirective, descendants: true }, { propertyName: "contentItems", predicate: PanelBarItemComponent, descendants: true }, { propertyName: "contentChildItems", predicate: PanelBarItemComponent }], viewQueries: [{ propertyName: "viewChildItems", predicate: PanelBarItemComponent, descendants: true }], exportAs: ["kendoPanelbar"], usesOnChanges: true, ngImport: i0, template: `
        @if (contentChildItems && !items) {
          <ng-content select="kendo-panelbar-item"></ng-content>
        }
        @if (items?.length) {
          @for (item of items; track item) {
            @if (!item.hidden) {
              <kendo-panelbar-item
                [title]="item.title"
                [id]="item.id"
                [icon]="item.icon"
                [iconClass]="item.iconClass"
                [svgIcon]="item.svgIcon"
                [imageUrl]="item.imageUrl"
                [selected]="!!item.selected"
                [expanded]="!!item.expanded"
                [disabled]="!!item.disabled"
                [template]="templateRef"
                [items]="item.children"
                [content]="item.content"
                >
              </kendo-panelbar-item>
            }
          }
        }

        @if (showLicenseWatermark) {
          <div kendoWatermarkOverlay [licenseMessage]="licenseMessage"></div>
        }
        `, isInline: true, dependencies: [{ kind: "component", type: PanelBarItemComponent, selector: "kendo-panelbar-item", inputs: ["title", "id", "icon", "iconClass", "svgIcon", "imageUrl", "disabled", "expanded", "selected", "content", "items", "template"], exportAs: ["kendoPanelbarItem"] }, { kind: "component", type: WatermarkOverlayComponent, selector: "div[kendoWatermarkOverlay]", inputs: ["licenseMessage"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PanelBarComponent, decorators: [{
            type: Component,
            args: [{
                    exportAs: 'kendoPanelbar',
                    providers: [
                        PanelBarService,
                        LocalizationService,
                        {
                            provide: L10N_PREFIX,
                            useValue: 'kendo.panelbar'
                        }
                    ],
                    selector: 'kendo-panelbar',
                    template: `
        @if (contentChildItems && !items) {
          <ng-content select="kendo-panelbar-item"></ng-content>
        }
        @if (items?.length) {
          @for (item of items; track item) {
            @if (!item.hidden) {
              <kendo-panelbar-item
                [title]="item.title"
                [id]="item.id"
                [icon]="item.icon"
                [iconClass]="item.iconClass"
                [svgIcon]="item.svgIcon"
                [imageUrl]="item.imageUrl"
                [selected]="!!item.selected"
                [expanded]="!!item.expanded"
                [disabled]="!!item.disabled"
                [template]="templateRef"
                [items]="item.children"
                [content]="item.content"
                >
              </kendo-panelbar-item>
            }
          }
        }

        @if (showLicenseWatermark) {
          <div kendoWatermarkOverlay [licenseMessage]="licenseMessage"></div>
        }
        `,
                    standalone: true,
                    imports: [PanelBarItemComponent, WatermarkOverlayComponent]
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: PanelBarService }, { type: i1.LocalizationService }], propDecorators: { expandMode: [{
                type: Input
            }], selectable: [{
                type: Input
            }], animate: [{
                type: Input
            }], height: [{
                type: Input
            }], keepItemContent: [{
                type: Input
            }], items: [{
                type: Input
            }], stateChange: [{
                type: Output
            }], select: [{
                type: Output
            }], expand: [{
                type: Output
            }], collapse: [{
                type: Output
            }], itemClick: [{
                type: Output
            }], hostClasses: [{
                type: HostBinding,
                args: ['class.k-panelbar']
            }], tabIndex: [{
                type: HostBinding,
                args: ['attr.tabIndex']
            }], role: [{
                type: HostBinding,
                args: ['attr.role']
            }], activeDescendant: [{
                type: HostBinding,
                args: ['attr.aria-activedescendant']
            }], hostHeight: [{
                type: HostBinding,
                args: ['style.height']
            }], overflow: [{
                type: HostBinding,
                args: ['style.overflow']
            }], dir: [{
                type: HostBinding,
                args: ['attr.dir']
            }], template: [{
                type: ContentChild,
                args: [PanelBarItemTemplateDirective, { static: false }]
            }], contentItems: [{
                type: ContentChildren,
                args: [PanelBarItemComponent, { descendants: true }]
            }], contentChildItems: [{
                type: ContentChildren,
                args: [PanelBarItemComponent]
            }], viewChildItems: [{
                type: ViewChildren,
                args: [PanelBarItemComponent]
            }], onComponentClick: [{
                type: HostListener,
                args: ['click', ['$event']]
            }], onComponentFocus: [{
                type: HostListener,
                args: ['focus']
            }], onComponentBlur: [{
                type: HostListener,
                args: ['blur']
            }], onComponentKeyDown: [{
                type: HostListener,
                args: ['keydown', ['$event']]
            }] } });

/**
 * @hidden
 */
const shouldTogglePrev = (keyCode, prev, next) => {
    const leftArrow = keyCode === Keys.ArrowLeft;
    const upArrow = keyCode === Keys.ArrowUp;
    const collapsePrev = !prev.collapsed && !next.collapsed && (leftArrow || upArrow);
    const expandPrev = prev.collapsed && !(leftArrow || upArrow);
    return collapsePrev || expandPrev;
};
/**
 * @hidden
 */
const shouldToggleNext = (keyCode, prev, next) => {
    const leftArrow = keyCode === Keys.ArrowLeft;
    const upArrow = keyCode === Keys.ArrowUp;
    const collapseNext = !next.collapsed && !prev.collapsed && !(leftArrow || upArrow);
    const expandNext = next.collapsed && (leftArrow || upArrow);
    return collapseNext || expandNext;
};
/**
 * @hidden
 */
const shouldToggleOrResize = (keyCode, orientation) => {
    const isHorizontal = orientation === 'horizontal';
    const isHorizontalChange = isHorizontal && (keyCode === Keys.ArrowLeft || keyCode === Keys.ArrowRight);
    const isVerticalChange = !isHorizontal && (keyCode === Keys.ArrowUp || keyCode === Keys.ArrowDown);
    return isHorizontalChange || isVerticalChange;
};

const MAX_PANE_HEIGHT = 33554400;
/**
 * @hidden
 */
class SplitterService {
    zone;
    panes;
    splitterBars;
    layoutChange = new EventEmitter();
    resizeStep = 10;
    fixedHeight;
    constructor(zone) {
        this.zone = zone;
    }
    tryToggle(paneIndex) {
        const pane = this.pane(paneIndex);
        if (pane.collapsible) {
            pane.collapsed = !pane.collapsed;
            pane.collapsedChange.emit(pane.collapsed);
            this.emit(this.layoutChange, {});
            if (pane.collapsed) {
                pane.detectChanges();
            }
        }
        const notCollapsed = this.panes.filter(p => !p.collapsed);
        const allHaveFixedSize = notCollapsed.every(p => p.fixedSize);
        notCollapsed.filter(p => p.fixedSize).forEach(pane => {
            pane.forceExpand = allHaveFixedSize ? true : false;
        });
        return pane.collapsible;
    }
    togglePane(keyCode, index) {
        const prev = this.pane(index);
        const next = this.pane(index + 1);
        if (shouldTogglePrev(keyCode, prev, next)) {
            this.tryToggle(index);
        }
        else if (shouldToggleNext(keyCode, prev, next)) {
            this.tryToggle(index + 1);
        }
    }
    resizePane(keyCode, index) {
        const state = this.dragState(index);
        const direction = keyCode === Keys.ArrowLeft || keyCode === (this.rtl ? Keys.ArrowDown : Keys.ArrowUp);
        let step = direction ? (-this.resizeStep) : this.resizeStep;
        if (this.rtl) {
            step = -step;
        }
        this.setSize(state, step);
    }
    toggleContentOverlay(index, show) {
        this.pane(index).toggleOverlay(show);
        this.pane(index + 1).toggleOverlay(show);
    }
    dragState(splitbarIndex) {
        const prev = this.pane(splitbarIndex);
        const next = this.pane(splitbarIndex + 1);
        const total = prev.computedSize + next.computedSize;
        const px = s => this.toPixels(s);
        return {
            prev: {
                index: splitbarIndex,
                initialSize: prev.computedSize,
                min: px(prev.min) || total - px(next.max) || 0,
                max: px(prev.max) || total - px(next.min) || total
            },
            next: {
                index: splitbarIndex + 1,
                initialSize: next.computedSize,
                min: px(next.min) || total - px(prev.max) || 0,
                max: px(next.max) || total - px(prev.min) || total
            }
        };
    }
    setSize(state, delta) {
        const clamp = (min, max, v) => Math.min(max, Math.max(min, v));
        const resize = (paneState, change, modifyMax = false) => {
            const pane = this.pane(paneState.index);
            const splitterSize = this.containerSize();
            const newSize = clamp(paneState.min, modifyMax ? MAX_PANE_HEIGHT : paneState.max, paneState.initialSize + change);
            let size = "";
            if (this.isPercent(pane.size)) {
                size = (100 * newSize / splitterSize) + "%";
            }
            else {
                size = newSize + "px";
            }
            pane.size = size;
            pane.isResized = true;
            this.emit(pane.sizeChange, size);
        };
        const prevPane = this.pane(state.prev.index);
        const nextPane = this.pane(state.next.index);
        const canResizeBothPanes = this.panes.length > 2;
        const modifyPrevMax = prevPane.orientation === 'vertical' && !this.fixedHeight && !prevPane.max;
        const modifyNextMax = prevPane.orientation === 'vertical' && !this.fixedHeight && !nextPane.max;
        if (prevPane.fixedSize && nextPane.fixedSize || canResizeBothPanes) {
            const bothVertical = prevPane.orientation === 'vertical' && nextPane.orientation === 'vertical';
            if (bothVertical) {
                if (modifyNextMax) {
                    resize(state.prev, delta, modifyPrevMax);
                }
                else if (modifyPrevMax) {
                    resize(state.next, -delta, modifyNextMax);
                }
                else {
                    resize(state.prev, delta, modifyNextMax);
                    resize(state.next, -delta, modifyPrevMax);
                }
            }
            else {
                resize(state.prev, delta);
                resize(state.next, -delta);
            }
        }
        else if (nextPane.fixedSize || nextPane.collapsible) {
            resize(state.next, -delta, modifyNextMax);
        }
        else {
            resize(state.prev, delta, modifyPrevMax);
        }
        this.emit(this.layoutChange, {});
    }
    isDraggable(splitBarIndex) {
        const prev = this.pane(splitBarIndex);
        const next = this.pane(splitBarIndex + 1);
        const betweenResizablePanes = prev?.resizable && next?.resizable;
        const nearCollapsedPane = prev?.collapsed || next?.collapsed;
        return betweenResizablePanes && !nearCollapsedPane;
    }
    isStatic(splitBarIndex) {
        const prev = this.pane(splitBarIndex);
        const next = this.pane(splitBarIndex + 1);
        const betweenResizablePanes = prev?.resizable && next?.resizable;
        const nearCollapsiblePane = prev?.collapsible || next?.collapsible;
        return !betweenResizablePanes && !nearCollapsiblePane;
    }
    pane(index) {
        if (!isDocumentAvailable()) {
            return;
        }
        if (!this.panes) {
            throw new Error("Panes not initialized");
        }
        if (index < 0 || index >= this.panes.length) {
            throw new Error("Index out of range");
        }
        return this.panes[index];
    }
    paneByIndex(pane) {
        if (!this.panes) {
            return -1;
        }
        return this.panes.findIndex(splitterPane => splitterPane === pane);
    }
    getPaneSplitterBar(pane) {
        if (!this.splitterBars) {
            return;
        }
        const paneIndex = this.paneByIndex(pane);
        if (paneIndex < 0 || paneIndex >= this.splitterBars.length) {
            return null;
        }
        return this.splitterBars[paneIndex];
    }
    configure({ panes, orientation, containerSize, direction }) {
        this.panes = panes;
        this.panes.forEach((pane, index) => {
            pane.order = index * 2;
            pane.orientation = orientation;
        });
        this.containerSize = containerSize;
        this.rtl = direction === 'rtl';
    }
    containerSize = () => { };
    rtl;
    isPercent(size) {
        return /%$/.test(size);
    }
    toPixels(size) {
        let result = parseFloat(size);
        if (this.isPercent(size)) {
            result = (this.containerSize() * result / 100);
        }
        return result;
    }
    emit(emitter, args) {
        if (emitter.observers.length) {
            this.zone.run(() => emitter.emit(args));
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SplitterService, deps: [{ token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SplitterService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SplitterService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: i0.NgZone }] });

/**
 * Represents the pane component of the Splitter.
 *
 * @example
 * ```html
 * <kendo-splitter>
 *   <kendo-splitter-pane size="30%" [collapsible]="true">
 *     Left pane content
 *   </kendo-splitter-pane>
 *   <kendo-splitter-pane>
 *     Right pane content
 *   </kendo-splitter-pane>
 * </kendo-splitter>
 * ```
 */
class SplitterPaneComponent {
    element;
    renderer;
    cdr;
    splitterService;
    /**
     * @hidden
     */
    set order(paneOrder) {
        this._order = paneOrder;
        this.setOrderStyles();
    }
    get order() {
        return this._order;
    }
    /**
     * Defines the initial size of the pane.
     * Accepts values in pixels and percentages.
     * The value must be between the `min` and `max` properties.
     */
    set size(newSize) {
        this._size = newSize;
        // Only set flex-basis if the pane is not collapsed
        if (!this._collapsed) {
            this.renderer.setStyle(this.nativeElement, '-ms-flex-preferred-size', newSize);
            this.renderer.setStyle(this.nativeElement, 'flex-basis', newSize);
        }
        this.setStaticPaneClass();
    }
    get size() {
        return this._size;
    }
    /**
     * Defines the HTML attributes of the splitter bar.
     * Accepts string key-value pairs.
     * You cannot change attributes that are essential for certain functionalities.
     */
    set splitterBarAttributes(attributes) {
        this._splitterBarAttributes = attributes;
        const splitterBar = this.splitterService.getPaneSplitterBar(this);
        if (splitterBar) {
            splitterBar.htmlAttributes = attributes;
        }
    }
    get splitterBarAttributes() {
        return this._splitterBarAttributes;
    }
    /**
     * Defines the CSS classes that are rendered on the splitter bar.
     * Supports the same values as [`ngClass`](link:site.data.urls.angular['ngclassapi']).
     */
    splitterBarClass;
    /**
     * Defines the minimum possible size of the pane.
     * Accepts values in pixels and percentages.
     */
    min;
    /**
     * Defines the maximum possible size of the pane.
     * Accepts values in pixels and percentages.
     */
    max;
    /**
     * Determines if you can resize the pane and provide space for other panes.
     *
     * @default true
     */
    resizable = true;
    /**
     * Determines if you can hide the pane and provide space for other panes.
     *
     * @default false
     */
    collapsible = false;
    /**
     * Determines if overflowing content is scrollable or hidden.
     *
     * @default true
     */
    scrollable = true;
    /**
     * Determines if the pane is initially collapsed.
     *
     * @default false
     */
    set collapsed(value) {
        const hasChanged = this._collapsed !== value;
        this._collapsed = value;
        if (hasChanged && this.nativeElement) {
            if (this._collapsed) {
                // When collapsing, clear the flex-basis to allow other panes to expand
                this.renderer.setStyle(this.nativeElement, '-ms-flex-preferred-size', '0');
                this.renderer.setStyle(this.nativeElement, 'flex-basis', '0');
            }
            else if (this._size) {
                // When expanding, restore the size if it was set
                this.renderer.setStyle(this.nativeElement, '-ms-flex-preferred-size', this._size);
                this.renderer.setStyle(this.nativeElement, 'flex-basis', this._size);
            }
            // Trigger the same forceExpand logic that tryToggle does
            // This ensures remaining panes expand when a pane is collapsed
            if (this.splitterService?.panes) {
                const notCollapsed = this.splitterService.panes.filter(p => !p.collapsed);
                const allHaveFixedSize = notCollapsed.every(p => p.fixedSize);
                notCollapsed.filter(p => p.fixedSize).forEach(pane => {
                    pane.forceExpand = allHaveFixedSize;
                });
            }
        }
    }
    get collapsed() {
        return this._collapsed;
    }
    /**
     * @hidden
     */
    orientation = 'horizontal';
    /**
     * @hidden
     */
    set containsSplitter(value) {
        if (value) {
            this.renderer.addClass(this.nativeElement, 'k-pane-flex');
        }
        else {
            this.renderer.removeClass(this.nativeElement, 'k-pane-flex');
        }
    }
    /**
     * @hidden
     */
    overlayContent = false;
    /**
     * Fires when the Splitter pane size changes.
     * The event data contains the new pane size.
     * Enables two-way binding of the pane `size` property.
     */
    sizeChange = new EventEmitter();
    /**
     * Fires when the Splitter pane collapses or expands.
     * The event data contains the new property state.
     * Enables two-way binding of the `collapsed` pane property.
     */
    collapsedChange = new EventEmitter();
    get isHidden() {
        return this.collapsed;
    }
    ariaRole = 'group';
    hostClass = true;
    get scrollablePaneClass() {
        return this.scrollable;
    }
    get fixedSize() {
        return this.size && this.size.length > 0;
    }
    /**
     * @hidden
     */
    forceExpand = false;
    /**
     * @hidden
     */
    isResized = false;
    _size;
    _order;
    _splitterBarAttributes;
    _collapsed = false;
    constructor(element, renderer, cdr, splitterService) {
        this.element = element;
        this.renderer = renderer;
        this.cdr = cdr;
        this.splitterService = splitterService;
    }
    ngAfterViewChecked() {
        if (this.isHidden) {
            this.renderer.addClass(this.nativeElement, 'k-hidden');
            this.renderer.addClass(this.nativeElement, 'hidden');
        }
        else {
            this.renderer.removeClass(this.nativeElement, 'k-hidden');
            this.renderer.removeClass(this.nativeElement, 'hidden');
        }
        this.setStaticPaneClass();
    }
    ngOnChanges(changes) {
        if (anyChanged(['resizable', 'collapsible'], changes)) {
            this.setStaticPaneClass();
        }
    }
    /**
     * @hidden
     */
    get computedSize() {
        if (this.orientation === 'vertical') {
            return this.nativeElement.offsetHeight;
        }
        else {
            return this.nativeElement.offsetWidth;
        }
    }
    /**
     * @hidden
     */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /**
     * @hidden
     */
    toggleOverlay(show) {
        this.overlayContent = show;
        this.cdr.detectChanges();
    }
    /**
     * @hidden
     */
    detectChanges() {
        this.cdr.detectChanges();
    }
    setOrderStyles() {
        this.renderer.setStyle(this.nativeElement, '-ms-flex-order', this.order);
        this.renderer.setStyle(this.nativeElement, 'order', this.order);
    }
    setStaticPaneClass() {
        if (this.forceExpand) {
            this.renderer.removeClass(this.nativeElement, 'k-pane-static');
            return;
        }
        if (!this.resizable && !this.collapsible || this.fixedSize) {
            this.renderer.addClass(this.nativeElement, 'k-pane-static');
        }
        else {
            this.renderer.removeClass(this.nativeElement, 'k-pane-static');
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SplitterPaneComponent, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }, { token: i0.ChangeDetectorRef }, { token: SplitterService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: SplitterPaneComponent, isStandalone: true, selector: "kendo-splitter-pane", inputs: { order: "order", size: "size", splitterBarAttributes: "splitterBarAttributes", splitterBarClass: "splitterBarClass", min: "min", max: "max", resizable: "resizable", collapsible: "collapsible", scrollable: "scrollable", collapsed: "collapsed", orientation: "orientation", containsSplitter: "containsSplitter", overlayContent: "overlayContent" }, outputs: { sizeChange: "sizeChange", collapsedChange: "collapsedChange" }, host: { properties: { "attr.role": "this.ariaRole", "class.k-pane": "this.hostClass", "class.k-scrollable": "this.scrollablePaneClass" } }, exportAs: ["kendoSplitterPane"], usesOnChanges: true, ngImport: i0, template: `
        @if (!collapsed) {
          <ng-content></ng-content>
        }
        @if (overlayContent) {
          <div class="k-splitter-overlay k-overlay"></div>
        }
        `, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SplitterPaneComponent, decorators: [{
            type: Component,
            args: [{
                    exportAs: 'kendoSplitterPane',
                    selector: 'kendo-splitter-pane',
                    template: `
        @if (!collapsed) {
          <ng-content></ng-content>
        }
        @if (overlayContent) {
          <div class="k-splitter-overlay k-overlay"></div>
        }
        `,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i0.ChangeDetectorRef }, { type: SplitterService }], propDecorators: { order: [{
                type: Input
            }], size: [{
                type: Input
            }], splitterBarAttributes: [{
                type: Input
            }], splitterBarClass: [{
                type: Input
            }], min: [{
                type: Input
            }], max: [{
                type: Input
            }], resizable: [{
                type: Input
            }], collapsible: [{
                type: Input
            }], scrollable: [{
                type: Input
            }], collapsed: [{
                type: Input
            }], orientation: [{
                type: Input
            }], containsSplitter: [{
                type: Input
            }], overlayContent: [{
                type: Input
            }], sizeChange: [{
                type: Output
            }], collapsedChange: [{
                type: Output
            }], ariaRole: [{
                type: HostBinding,
                args: ['attr.role']
            }], hostClass: [{
                type: HostBinding,
                args: ['class.k-pane']
            }], scrollablePaneClass: [{
                type: HostBinding,
                args: ['class.k-scrollable']
            }] } });

/* eslint-disable @typescript-eslint/no-explicit-any */
const stopPropagation = ({ originalEvent: event }) => {
    event.stopPropagation();
    event.preventDefault();
};
const preventOnDblClick = release => mouseDown => of(mouseDown).pipe(delay(150), takeUntil(release));
const classFromObject = classes => Object.keys(classes).filter(c => classes[c]).join(' ');
const createMoveStream = (draggable) => mouseDown => draggable.kendoDrag
    .pipe(takeUntil(draggable.kendoRelease), map(({ pageX, pageY }) => ({
    originalX: mouseDown.pageX,
    originalY: mouseDown.pageY,
    pageX,
    pageY
})));
/**
 * @hidden
 */
class SplitterBarComponent {
    draggable;
    localization;
    splitterService;
    element;
    renderer;
    cdr;
    ariaRole = 'separator';
    ariaLabel = 'Splitter pane';
    focused = false;
    get hostOrientation() {
        return this.orientation === 'horizontal' ? 'vertical' : 'horizontal';
    }
    get tabIndex() {
        return this.splitterService.isStatic(this.index) ? -1 : 0;
    }
    get hostClasses() {
        const isHorizontal = this.orientation === 'horizontal';
        const isDraggable = this.splitterService.isDraggable(this.index);
        const isStatic = this.splitterService.isStatic(this.index);
        return classFromObject({
            'k-focus': this.focused,
            'k-splitbar': true,
            'k-splitbar-horizontal': isHorizontal,
            'k-splitbar-vertical': !isHorizontal,
            'k-splitbar-draggable-horizontal': isHorizontal && isDraggable,
            'k-splitbar-draggable-vertical': !isHorizontal && isDraggable,
            'k-splitbar-static-horizontal': isHorizontal && isStatic,
            'k-splitbar-static-vertical': !isHorizontal && isStatic,
            'k-touch-action-none': isDraggable
        });
    }
    get order() {
        return 2 * this.index + 1;
    }
    orientation = 'horizontal';
    index = 0;
    set htmlAttributes(attributes) {
        if (isObjectPresent(this.parsedAttributes)) {
            removeHTMLAttributes(this.parsedAttributes, this.renderer, this.element.nativeElement);
        }
        this._htmlAttributes = attributes;
        this.parsedAttributes = this.htmlAttributes ?
            parseAttributes(this.htmlAttributes, this.defaultAttributes) :
            this.htmlAttributes;
        this.setHtmlAttributes();
    }
    get htmlAttributes() {
        return this._htmlAttributes;
    }
    subscriptions = new Subscription();
    _htmlAttributes;
    parsedAttributes = {};
    get defaultAttributes() {
        return {
            'aria-orientation': this.hostOrientation,
            role: this.ariaRole
        };
    }
    get mutableAttributes() {
        return { 'tabindex': this.tabIndex };
    }
    constructor(draggable, localization, splitterService, element, renderer, cdr) {
        this.draggable = draggable;
        this.localization = localization;
        this.splitterService = splitterService;
        this.element = element;
        this.renderer = renderer;
        this.cdr = cdr;
    }
    ngOnInit() {
        let state;
        const listener = this.draggable.kendoPress.pipe(tap(stopPropagation), filter(() => this.splitterService.isDraggable(this.index)), tap(() => state = this.splitterService.dragState(this.index)), tap(() => this.splitterService.toggleContentOverlay(this.index, true)), switchMap(preventOnDblClick(this.draggable.kendoRelease)), switchMap(createMoveStream(this.draggable))).subscribe(({ pageX, pageY, originalX, originalY }) => {
            let delta;
            if (this.orientation === 'vertical') {
                delta = pageY - originalY;
            }
            else if (this.direction === 'rtl') {
                delta = originalX - pageX;
            }
            else {
                delta = pageX - originalX;
            }
            this.splitterService.setSize(state, delta);
        });
        this.subscriptions.add(listener);
        this.subscriptions.add(this.draggable.kendoRelease.subscribe(() => this.splitterService.toggleContentOverlay(this.index, false)));
        const element = this.element.nativeElement;
        this.subscriptions.add(this.renderer.listen(element, 'keydown', event => this.onKeyDown(event)));
        this.subscriptions.add(this.renderer.listen(element, 'focusin', () => this.focused = true));
        this.subscriptions.add(this.renderer.listen(element, 'focusout', () => this.focused = false));
        this.subscriptions.add(this.renderer.listen(element, 'dblclick', () => this.togglePane()));
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    }
    togglePrevious() {
        this.splitterService.tryToggle(this.index);
    }
    toggleNext() {
        this.splitterService.tryToggle(this.index + 1);
    }
    get direction() {
        return this.localization.rtl ? 'rtl' : 'ltr';
    }
    shouldShowIcon(iconName) {
        const paneIndex = iconName === 'prev' ? this.index : this.index + 1;
        const relatedPaneIndex = iconName === 'prev' ? this.index + 1 : this.index;
        const pane = this.splitterService.pane(paneIndex);
        const relatedPane = this.splitterService.pane(relatedPaneIndex);
        const isCollapsible = pane?.collapsible;
        return isCollapsible && !relatedPane?.isHidden;
    }
    previousArrowClass() {
        const pane = this.splitterService.pane(this.index);
        const isCollapsible = pane?.collapsible;
        const isCollapsed = pane?.collapsed;
        const isHorizontal = this.orientation === 'horizontal';
        const isRTL = this.direction === 'rtl';
        return classFromObject({
            'caret-alt-left': isCollapsible && isHorizontal && ((!isCollapsed && !isRTL) || (isCollapsed && isRTL)),
            'caret-alt-right': isCollapsible && isHorizontal && ((isCollapsed && !isRTL) || (!isCollapsed && isRTL)),
            'caret-alt-up': isCollapsible && !isHorizontal && !isCollapsed,
            'caret-alt-down': isCollapsible && !isHorizontal && isCollapsed
        });
    }
    previousSVGArrowClass() {
        const pane = this.splitterService.pane(this.index);
        const isCollapsible = pane?.collapsible;
        const isCollapsed = pane?.collapsed;
        const isHorizontal = this.orientation === 'horizontal';
        const isRTL = this.direction === 'rtl';
        if (isCollapsible && isHorizontal && ((!isCollapsed && !isRTL) || (isCollapsed && isRTL))) {
            return caretAltLeftIcon;
        }
        if (isCollapsible && isHorizontal && ((isCollapsed && !isRTL) || (!isCollapsed && isRTL))) {
            return caretAltRightIcon;
        }
        if (isCollapsible && !isHorizontal && !isCollapsed) {
            return caretAltUpIcon;
        }
        if (isCollapsible && !isHorizontal && isCollapsed) {
            return caretAltDownIcon;
        }
    }
    nextArrowClass() {
        const pane = this.splitterService.pane(this.index + 1);
        const isCollapsible = pane?.collapsible;
        const isCollapsed = pane?.collapsed;
        const isHorizontal = this.orientation === 'horizontal';
        const isRTL = this.direction === 'rtl';
        return classFromObject({
            'caret-alt-right': isCollapsible && isHorizontal && ((!isCollapsed && !isRTL) || (isCollapsed && isRTL)),
            'caret-alt-left': isCollapsible && isHorizontal && ((isCollapsed && !isRTL) || (!isCollapsed && isRTL)),
            'caret-alt-down': isCollapsible && !isHorizontal && !isCollapsed,
            'caret-alt-up': isCollapsible && !isHorizontal && isCollapsed
        });
    }
    nextSVGArrowClass() {
        const pane = this.splitterService.pane(this.index + 1);
        const isCollapsible = pane?.collapsible;
        const isCollapsed = pane?.collapsed;
        const isHorizontal = this.orientation === 'horizontal';
        const isRTL = this.direction === 'rtl';
        if (isCollapsible && isHorizontal && ((!isCollapsed && !isRTL) || (isCollapsed && isRTL))) {
            return caretAltRightIcon;
        }
        if (isCollapsible && isHorizontal && ((isCollapsed && !isRTL) || (!isCollapsed && isRTL))) {
            return caretAltLeftIcon;
        }
        if (isCollapsible && !isHorizontal && !isCollapsed) {
            return caretAltDownIcon;
        }
        if (isCollapsible && !isHorizontal && isCollapsed) {
            return caretAltUpIcon;
        }
    }
    togglePane() {
        if (this.expandLast) {
            this.toggleNext();
        }
        else {
            this.tryToggleNearest();
        }
        this.cdr.markForCheck();
    }
    get expandLast() {
        const panes = this.splitterService.panes;
        return panes.length === 2 && panes[1].collapsed;
    }
    onKeyDown(event) {
        const keyCode = normalizeKeys(event);
        const shouldToggle = event.ctrlKey || event.metaKey;
        if (keyCode === Keys.Enter || keyCode === Keys.NumpadEnter) {
            event.preventDefault();
            this.togglePane();
        }
        else if (shouldToggleOrResize(keyCode, this.orientation)) {
            event.preventDefault();
            if (shouldToggle) {
                this.splitterService.togglePane(keyCode, this.index);
            }
            else {
                this.splitterService.resizePane(keyCode, this.index);
            }
        }
    }
    tryToggleNearest() {
        const prev = this.index;
        const next = this.index + 1;
        if (!this.splitterService.tryToggle(prev)) {
            this.splitterService.tryToggle(next);
        }
    }
    setHtmlAttributes() {
        const attributesToRender = { ...this.mutableAttributes, ...this.parsedAttributes };
        setHTMLAttributes(attributesToRender, this.renderer, this.element.nativeElement);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SplitterBarComponent, deps: [{ token: i1$1.DraggableDirective, host: true }, { token: i1.LocalizationService }, { token: SplitterService }, { token: i0.ElementRef }, { token: i0.Renderer2 }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: SplitterBarComponent, isStandalone: true, selector: "kendo-splitter-bar", inputs: { orientation: "orientation", index: "index", htmlAttributes: "htmlAttributes" }, host: { properties: { "attr.role": "this.ariaRole", "attr.aria-label": "this.ariaLabel", "class.k-focus": "this.focused", "attr.aria-orientation": "this.hostOrientation", "attr.tabindex": "this.tabIndex", "class": "this.hostClasses", "style.-ms-flex-order": "this.order", "style.order": "this.order" } }, ngImport: i0, template: `
        @if (shouldShowIcon('prev')) {
          <div class="k-collapse-prev" (click)="togglePrevious()">
            <kendo-icon-wrapper
              size="xsmall"
              [name]="previousArrowClass()"
              [svgIcon]="previousSVGArrowClass()"
            ></kendo-icon-wrapper>
          </div>
        }
        <div class="k-resize-handle"></div>
        @if (shouldShowIcon('next')) {
          <div class="k-collapse-next" (click)="toggleNext()">
            <kendo-icon-wrapper
              size="xsmall"
              [name]="nextArrowClass()"
              [svgIcon]="nextSVGArrowClass()"
            ></kendo-icon-wrapper>
          </div>
        }
        `, isInline: true, dependencies: [{ kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SplitterBarComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-splitter-bar',
                    template: `
        @if (shouldShowIcon('prev')) {
          <div class="k-collapse-prev" (click)="togglePrevious()">
            <kendo-icon-wrapper
              size="xsmall"
              [name]="previousArrowClass()"
              [svgIcon]="previousSVGArrowClass()"
            ></kendo-icon-wrapper>
          </div>
        }
        <div class="k-resize-handle"></div>
        @if (shouldShowIcon('next')) {
          <div class="k-collapse-next" (click)="toggleNext()">
            <kendo-icon-wrapper
              size="xsmall"
              [name]="nextArrowClass()"
              [svgIcon]="nextSVGArrowClass()"
            ></kendo-icon-wrapper>
          </div>
        }
        `,
                    standalone: true,
                    imports: [IconWrapperComponent]
                }]
        }], ctorParameters: () => [{ type: i1$1.DraggableDirective, decorators: [{
                    type: Host
                }] }, { type: i1.LocalizationService }, { type: SplitterService }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i0.ChangeDetectorRef }], propDecorators: { ariaRole: [{
                type: HostBinding,
                args: ['attr.role']
            }], ariaLabel: [{
                type: HostBinding,
                args: ['attr.aria-label']
            }], focused: [{
                type: HostBinding,
                args: ['class.k-focus']
            }], hostOrientation: [{
                type: HostBinding,
                args: ['attr.aria-orientation']
            }], tabIndex: [{
                type: HostBinding,
                args: ['attr.tabindex']
            }], hostClasses: [{
                type: HostBinding,
                args: ['class']
            }], order: [{
                type: HostBinding,
                args: ['style.-ms-flex-order']
            }, {
                type: HostBinding,
                args: ['style.order']
            }], orientation: [{
                type: Input
            }], index: [{
                type: Input
            }], htmlAttributes: [{
                type: Input
            }] } });

const SIZING_DOC_LINK = 'https://www.telerik.com/kendo-angular-ui/components/layout/splitter/panes/#specifying-the-dimensions';
/**
 * Represents the [Kendo UI Splitter component for Angular]({% slug overview_splitter %}).
 *
 * @example
 * ```html
 * <kendo-splitter [style.height.px]="280">
 *   <kendo-splitter-pane [collapsible]="true" size="30%">
 *     <h3>Left pane</h3>
 *   </kendo-splitter-pane>
 *   <kendo-splitter-pane>
 *     <h3>Right pane</h3>
 *   </kendo-splitter-pane>
 * </kendo-splitter>
 * ```
 * @remarks
 * Supported children components are: {@link SplitterPaneComponent}.
 */
class SplitterComponent {
    element;
    splitterService;
    localization;
    renderer;
    ngZone;
    enclosingPane;
    /**
     * Defines the orientation of the panes within the Splitter.
     * Use `horizontal` to place panes horizontally or `vertical` to place them vertically.
     *
     * @default 'horizontal'
     */
    orientation = 'horizontal';
    /**
     * Defines the width or height of the Splitter splitbars in pixels.
     * The dimension depends on the orientation of the Splitter.
     */
    splitbarWidth;
    /**
     * Defines the distance in pixels that you move the separator during keyboard navigation.
     *
     * @default 10
     */
    set resizeStep(value) {
        this.splitterService.resizeStep = value;
    }
    get resizeStep() {
        return this.splitterService.resizeStep;
    }
    /**
     * Defines the CSS classes that are rendered on the splitter bars.
     * Supports the same values as [`ngClass`](link:site.data.urls.angular['ngclassapi']).
     */
    splitterBarClass;
    /**
     * Fires when the layout of the Splitter changes.
     * Use this event to trigger layout calculations on components that are positioned inside the panes.
     */
    layoutChange;
    get hostClasses() {
        return true;
    }
    get horizontalHostClasses() {
        return this.orientation === 'horizontal';
    }
    get verticalHostClasses() {
        return this.orientation === 'vertical';
    }
    get dir() {
        return this.direction;
    }
    set splitbars(splitbars) {
        this.splitterService.splitterBars = splitbars ? splitbars.toArray() : [];
        if (!isPresent(splitbars) || !isPresent(this.panes)) {
            return;
        }
        if (!isDocumentAvailable()) {
            return;
        }
        const panesArray = this.panes.toArray();
        const splitBarsArray = splitbars.toArray();
        const components = [...panesArray, ...splitBarsArray]
            .sort((a, b) => a.order - b.order);
        const elements = components.map(component => component.element.nativeElement);
        panesArray.forEach((pane, i) => {
            const splitbar = splitBarsArray[i];
            if (splitbar && pane.splitterBarAttributes) {
                splitbar.htmlAttributes = pane.splitterBarAttributes;
            }
        });
        elements.forEach(element => this.renderer.appendChild(this.element.nativeElement, element));
    }
    /**
     * @hidden
     */
    panes;
    paneChangesSubscription;
    _styleObserver;
    constructor(element, splitterService, localization, renderer, ngZone, enclosingPane) {
        this.element = element;
        this.splitterService = splitterService;
        this.localization = localization;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.enclosingPane = enclosingPane;
        validatePackage(packageMetadata);
        if (enclosingPane) {
            enclosingPane.containsSplitter = true;
        }
        // the handler only runs in NgZone if there are bound handlers
        // this line merges both streams
        this.layoutChange = this.splitterService.layoutChange;
        this.configure = this.configure.bind(this);
    }
    ngAfterContentInit() {
        if (!isDocumentAvailable()) {
            return;
        }
        this.reconfigure();
        this.setFixedHeight();
        const allHaveFixedSize = this.panes.length && Array.from(this.panes).every(p => p.fixedSize);
        if (allHaveFixedSize && isDevMode()) {
            throw new Error(`
                The Splitter should have at least one pane without a set size.
                See ${SIZING_DOC_LINK} for more information.
            `);
        }
        this._styleObserver = new MutationObserver(() => {
            this.ngZone.runOutsideAngular(() => {
                this.setFixedHeight();
            });
        });
        this._styleObserver.observe(this.element.nativeElement, { attributeFilter: ['style'] });
    }
    ngOnChanges(changes) {
        if (changes.orientation && !changes.orientation.isFirstChange()) {
            this.reconfigure();
        }
    }
    ngOnDestroy() {
        if (this.enclosingPane) {
            this.enclosingPane.containsSplitter = false;
        }
        if (this._styleObserver) {
            this._styleObserver.disconnect();
            this._styleObserver = null;
        }
        this.unsubscribeChanges();
    }
    reconfigure() {
        this.unsubscribeChanges();
        this.configure();
        this.paneChangesSubscription = this.panes.changes.subscribe(this.configure);
    }
    unsubscribeChanges() {
        if (this.paneChangesSubscription) {
            this.paneChangesSubscription.unsubscribe();
            this.paneChangesSubscription = null;
        }
    }
    configure() {
        this.splitterService.configure({
            panes: this.panes.toArray(),
            orientation: this.orientation,
            containerSize: () => {
                if (this.orientation === 'vertical') {
                    return this.element.nativeElement.clientHeight;
                }
                else {
                    return this.element.nativeElement.clientWidth;
                }
            },
            direction: this.direction
        });
    }
    get direction() {
        return this.localization.rtl ? 'rtl' : 'ltr';
    }
    setFixedHeight() {
        this.splitterService.fixedHeight = getComputedStyle(this.element.nativeElement).getPropertyValue('height') !== 'auto';
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SplitterComponent, deps: [{ token: i0.ElementRef }, { token: SplitterService }, { token: i1.LocalizationService }, { token: i0.Renderer2 }, { token: i0.NgZone }, { token: SplitterPaneComponent, host: true, optional: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: SplitterComponent, isStandalone: true, selector: "kendo-splitter", inputs: { orientation: "orientation", splitbarWidth: "splitbarWidth", resizeStep: "resizeStep", splitterBarClass: "splitterBarClass" }, outputs: { layoutChange: "layoutChange" }, host: { properties: { "class.k-splitter": "this.hostClasses", "class.k-splitter-flex": "this.hostClasses", "class.k-splitter-horizontal": "this.horizontalHostClasses", "class.k-splitter-vertical": "this.verticalHostClasses", "attr.dir": "this.dir" } }, providers: [
            SplitterService,
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.spliter'
            }
        ], queries: [{ propertyName: "panes", predicate: SplitterPaneComponent }], viewQueries: [{ propertyName: "splitbars", predicate: SplitterBarComponent, descendants: true }], exportAs: ["kendoSplitter"], usesOnChanges: true, ngImport: i0, template: `
      <ng-content select="kendo-splitter-pane"></ng-content>
      @for (
        pane of panes; track
        pane; let index = $index; let last = $last) {
        @if (!last) {
          <kendo-splitter-bar
            kendoDraggable
            [index]="index"
            [orientation]="orientation"
            [ngClass]="pane.splitterBarClass || splitterBarClass"
          [ngStyle]="{
            width: orientation === 'horizontal' ? splitbarWidth + 'px' : undefined,
            height: orientation === 'vertical' ? splitbarWidth + 'px' : undefined
          }">
          </kendo-splitter-bar>
        }
      }
      `, isInline: true, dependencies: [{ kind: "component", type: SplitterBarComponent, selector: "kendo-splitter-bar", inputs: ["orientation", "index", "htmlAttributes"] }, { kind: "directive", type: DraggableDirective, selector: "[kendoDraggable]", inputs: ["enableDrag"], outputs: ["kendoPress", "kendoDrag", "kendoRelease"] }, { kind: "directive", type: NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SplitterComponent, decorators: [{
            type: Component,
            args: [{
                    exportAs: 'kendoSplitter',
                    selector: 'kendo-splitter',
                    providers: [
                        SplitterService,
                        LocalizationService,
                        {
                            provide: L10N_PREFIX,
                            useValue: 'kendo.spliter'
                        }
                    ],
                    template: `
      <ng-content select="kendo-splitter-pane"></ng-content>
      @for (
        pane of panes; track
        pane; let index = $index; let last = $last) {
        @if (!last) {
          <kendo-splitter-bar
            kendoDraggable
            [index]="index"
            [orientation]="orientation"
            [ngClass]="pane.splitterBarClass || splitterBarClass"
          [ngStyle]="{
            width: orientation === 'horizontal' ? splitbarWidth + 'px' : undefined,
            height: orientation === 'vertical' ? splitbarWidth + 'px' : undefined
          }">
          </kendo-splitter-bar>
        }
      }
      `,
                    standalone: true,
                    imports: [SplitterBarComponent, DraggableDirective, NgStyle, NgClass]
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: SplitterService }, { type: i1.LocalizationService }, { type: i0.Renderer2 }, { type: i0.NgZone }, { type: SplitterPaneComponent, decorators: [{
                    type: Optional
                }, {
                    type: Host
                }, {
                    type: Inject,
                    args: [SplitterPaneComponent]
                }] }], propDecorators: { orientation: [{
                type: Input
            }], splitbarWidth: [{
                type: Input
            }], resizeStep: [{
                type: Input
            }], splitterBarClass: [{
                type: Input
            }], layoutChange: [{
                type: Output
            }], hostClasses: [{
                type: HostBinding,
                args: ['class.k-splitter']
            }, {
                type: HostBinding,
                args: ['class.k-splitter-flex']
            }], horizontalHostClasses: [{
                type: HostBinding,
                args: ['class.k-splitter-horizontal']
            }], verticalHostClasses: [{
                type: HostBinding,
                args: ['class.k-splitter-vertical']
            }], dir: [{
                type: HostBinding,
                args: ['attr.dir']
            }], splitbars: [{
                type: ViewChildren,
                args: [SplitterBarComponent]
            }], panes: [{
                type: ContentChildren,
                args: [SplitterPaneComponent]
            }] } });

/**
 * Represents the content template of the Kendo UI TabStrip.
 * To define the template, nest an `<ng-template>` tag with the `kendoTabContent` directive inside the component tag.
 *
 * @example
 * ```html
 * <kendo-tabstrip>
 *   <kendo-tabstrip-tab title="First Tab">
 *     <ng-template kendoTabContent>
 *       <div class="tab-content">
 *         <h2>Welcome</h2>
 *         <p>This is the content of the first tab.</p>
 *       </div>
 *     </ng-template>
 *   </kendo-tabstrip-tab>
 * </kendo-tabstrip>
 * ```
 */
class TabContentDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TabContentDirective, deps: [{ token: i0.TemplateRef }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: TabContentDirective, isStandalone: true, selector: "[kendoTabContent]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TabContentDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoTabContent]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef }] });

/**
 * Represents the title template of the Kendo UI TabStrip.
 * To define the template, nest an `<ng-template>` tag with the `kendoTabTitle` directive inside the component tag.
 * The `kendoTabTitle` directive overrides the TabStripTab [`title`]({% slug api_layout_tabstriptabcomponent %}#toc-title) option.
 *
 * @example
 * ```html
 * <kendo-tabstrip>
 *   <kendo-tabstrip-tab>
 *     <ng-template kendoTabTitle>
 *       <span class="custom-title">My Custom Title</span>
 *     </ng-template>
 *   </kendo-tabstrip-tab>
 * </kendo-tabstrip>
 * ```
 */
class TabTitleDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TabTitleDirective, deps: [{ token: i0.TemplateRef }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: TabTitleDirective, isStandalone: true, selector: "[kendoTabTitle]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TabTitleDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoTabTitle]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef }] });

/**
 * @hidden
 */
class TabTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TabTemplateDirective, deps: [{ token: i0.TemplateRef }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: TabTemplateDirective, isStandalone: true, selector: "[kendoTabTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TabTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoTabTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef }] });

/**
 * Represents the Kendo UI TabStrip tab component.
 * Use this component to define individual tabs within a TabStrip.
 *
 * @example
 * ```html
 * <kendo-tabstrip>
 *   <kendo-tabstrip-tab title="Home" [selected]="true">
 *     <ng-template kendoTabContent>
 *       Home content here
 *     </ng-template>
 *   </kendo-tabstrip-tab>
 * </kendo-tabstrip>
 * ```
 */
class TabStripTabComponent {
    /**
     * Sets the title text for the tab ([see example](slug:tabs_tabstrip#toc-tab-titles)).
     */
    title;
    /**
     * Disables the tab and prevents user interaction ([see example]({% slug tabs_tabstrip %}#toc-disabled-tabs)).
     *
     * @default false
     */
    disabled = false;
    /**
     * Specifies the CSS classes to apply to the `tab` element.
     * Accepts the same values as [`ngClass`](link:site.data.urls.angular['ngclassapi']).
     */
    cssClass;
    /**
     * Specifies the CSS styles to apply to the `tab` element.
     * Accepts the same values as [`ngStyle`](link:site.data.urls.angular['ngstyleapi']).
     */
    cssStyle;
    /**
     * Selects the tab when the TabStrip loads
     * ([see example](slug:tabs_tabstrip#toc-selected-tab)).
     */
    selected;
    /**
     * Shows a close button inside the tab when set to `true`.
     * This setting overrides the TabStrip `closable` option.
     */
    closable;
    /**
     * Sets the name of an existing font icon in the Kendo UI theme for the close button.
     * This setting overrides the TabStrip `closeIcon` option.
     */
    closeIcon;
    /**
     * Sets custom CSS classes for the close button icon.
     * You can define a single class or multiple classes separated by spaces.
     * This setting overrides the TabStrip `closeIcon` option.
     */
    closeIconClass;
    /**
     * Sets an SVG icon for the close button.
     * You can use an [existing Kendo SVG icon](slug:svgicon_list) or provide a custom one.
     */
    closeSVGIcon;
    get tabContent() {
        return this._tabContent.first;
    }
    get tabTitle() {
        return this._tabTitleDirective.first;
    }
    get tabTemplate() {
        return this._tabDirective.first;
    }
    _tabDirective = new QueryList();
    _tabContent = new QueryList();
    // guards against nested tabstrip components; `descendants` is not defined by default;
    _tabTitleDirective;
    /**
     * @hidden
     *
     * Currently only disabled tabs can be focused. Otherwise they will be
     * immediately selected
     */
    focused = false;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TabStripTabComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: TabStripTabComponent, isStandalone: true, selector: "kendo-tabstrip-tab", inputs: { title: "title", disabled: "disabled", cssClass: "cssClass", cssStyle: "cssStyle", selected: "selected", closable: "closable", closeIcon: "closeIcon", closeIconClass: "closeIconClass", closeSVGIcon: "closeSVGIcon" }, queries: [{ propertyName: "_tabDirective", predicate: TabTemplateDirective }, { propertyName: "_tabContent", predicate: TabContentDirective }, { propertyName: "_tabTitleDirective", predicate: TabTitleDirective }], exportAs: ["kendoTabStripTab"], ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TabStripTabComponent, decorators: [{
            type: Component,
            args: [{
                    exportAs: 'kendoTabStripTab',
                    selector: 'kendo-tabstrip-tab',
                    template: ``,
                    standalone: true
                }]
        }], propDecorators: { title: [{
                type: Input
            }], disabled: [{
                type: Input
            }], cssClass: [{
                type: Input
            }], cssStyle: [{
                type: Input
            }], selected: [{
                type: Input
            }], closable: [{
                type: Input
            }], closeIcon: [{
                type: Input
            }], closeIconClass: [{
                type: Input
            }], closeSVGIcon: [{
                type: Input
            }], _tabDirective: [{
                type: ContentChildren,
                args: [TabTemplateDirective]
            }], _tabContent: [{
                type: ContentChildren,
                args: [TabContentDirective]
            }], _tabTitleDirective: [{
                type: ContentChildren,
                args: [TabTitleDirective]
            }] } });

/**
 * Arguments for the `tabClose` event of the TabStrip.
 * The `tabClose` event fires when a tab is closed (clicked on the close button).
 *
 */
class TabCloseEvent {
    index;
    tab;
    /**
     * Constructs the event arguments for the `tabClose` event.
     * @param index - The index of the closed tab.
     * @param tab - The closed tab instance
     * @hidden
     */
    constructor(index, tab) {
        this.index = index;
        this.tab = tab;
    }
}

/**
 * Arguments for the `tabScroll` event of the TabStrip.
 * The `tabScroll` event fires when you scroll the tabs.
 *
 */
class TabScrollEvent extends PreventableEvent$1 {
    /**
     * The original DOM event that caused the tab scroll.
     */
    originalEvent;
    /**
     * @hidden
     */
    constructor(args) {
        super();
        Object.assign(this, args);
    }
}

/**
 * Arguments for the `select` event of the TabStrip.
 * The `select` event fires when tab is selected (clicked).
 */
class SelectEvent extends PreventableEvent$1 {
    index;
    title;
    /**
     * Constructs the event arguments for the `select` event.
     * @param index - The index of the selected tab.
     * @param title - The title of the selected tab.
     *
     * @hidden
     */
    constructor(index, title) {
        super();
        this.index = index;
        this.title = title;
    }
}

/**
 * @hidden
 *
 * Checks if the current target is a TabStrip tab element
 */
const isTabElement = (target) => {
    const targetId = target.getAttribute('id');
    if (isPresent(targetId) || targetId?.indexOf('k-tabstrip-tab-') >= 0) {
        return true;
    }
    return false;
};
/**
 * @hidden
 *
 * Checks if the current tab is closable. Depends on the value of the TabStrip closable property.
 */
const isTabClosable = (tab, tabStripClosable) => {
    if (tab.closable !== undefined) {
        return tab.closable;
    }
    return tabStripClosable;
};
/**
 * @hidden
 *
 * Checks if the TabStrip scroll buttons will be rendered. Depends on the value of the TabStrip scrollable settings.
 */
const tabStripHasScrollButtons = (scrollableSettings) => {
    const visible = scrollableSettings.enabled && scrollableSettings.scrollButtons !== 'hidden';
    const position = scrollableSettings.scrollButtonsPosition;
    return {
        visible,
        position
    };
};
/**
 * @hidden
 *
 * Checks if the TabStrip mouse scroll will be enabled. Depends on the value of the TabStrip scrollable settings.
 */
const mouseScrollEnabled = (scrollableSettings) => {
    return scrollableSettings.enabled && scrollableSettings.mouseScroll;
};
/**
 * @hidden
 *
 * Retrieves the current active tab element and its index.
 * This could either be the currently selected tab or the currently focused tab.
 */
const getActiveTab = (tabs) => {
    let focusedTab;
    let selectedTab;
    let focusedIndex = -1;
    let selectedIndex = -1;
    tabs.forEach((tab, index) => {
        if (tab.selected) {
            selectedTab = tab;
            selectedIndex = index;
        }
        else if (tab.focused) {
            focusedTab = tab;
            focusedIndex = index;
        }
    });
    return focusedIndex >= 0 ?
        { tab: focusedTab, index: focusedIndex } :
        { tab: selectedTab, index: selectedIndex };
};
/**
 * @hidden
 */
const getTabByIndex = (tabs, index) => {
    const filtered = tabs.filter((_tab, i) => i === index);
    if (filtered.length > 0) {
        return filtered[0];
    }
    return null;
};
/**
 * @hidden
 */
const getTabHeaderByIndex = (tabHeaderContainers, index) => {
    const filtered = tabHeaderContainers.filter((_tabHeader, i) => i === index);
    if (filtered.length > 0) {
        return filtered[0];
    }
    return null;
};
/**
 * @hidden
 */
const resetTabFocus = (tabs) => {
    tabs.forEach((tab) => {
        tab.focused = false;
    });
};
/**
 * @hidden
 */
const resetTabSelection = (tabs) => {
    tabs.forEach((tab) => {
        tab.selected = false;
    });
};
/**
 * @hidden
 */
const isTablistHorizontal = (tabPosition) => tabPosition === 'top' || tabPosition === 'bottom';
/**
 * @hidden
 */
const getId$1 = (prefix, tabStripId, tabIndex) => {
    return `${prefix}-${tabStripId}-${tabIndex}`;
};

/**
 * @hidden
 */
class TabStripService {
    localization;
    ngZone;
    owner;
    constructor(localization, ngZone) {
        this.localization = localization;
        this.ngZone = ngZone;
    }
    onKeyDown(event) {
        if (!isTabElement(event.target)) {
            return;
        }
        // on some keyboards arrow keys, PageUp/Down, and Home/End are mapped to Numpad keys
        const code = normalizeKeys(event);
        if (this.shouldHandleKey(code)) {
            event.preventDefault();
        }
        else {
            return;
        }
        if (isNavigationKey(code) || isArrowKey(code)) {
            this.onNavigate(code);
        }
        else if (code === Keys.Delete || code === Keys.Backspace) {
            this.onDelete();
        }
    }
    onTabSelect(tab, index) {
        const selectArgs = new SelectEvent(index, tab.title);
        this.owner.tabSelect.emit(selectArgs);
        if (!selectArgs.isDefaultPrevented()) {
            if (tab.selected) {
                this.focusTabHeader(index);
                return;
            }
            this.selectTab(tab, index);
        }
    }
    selectTab(tab, index) {
        resetTabSelection(this.owner.tabs);
        this.focusTabHeader(index);
        tab.selected = true;
        if (this.owner.isScrollable) {
            this.owner.scrollToSelectedTab();
        }
    }
    onNavigate(keyCode) {
        const { tab: activeTab, index: activeIndex } = getActiveTab(this.owner.tabs);
        if (!NgZone.isInAngularZone()) {
            this.ngZone.run(() => {
                if (activeIndex < 0) {
                    this.owner.selectTab(this.firstNavigableIndex());
                    return;
                }
                activeTab.focused = false;
                const nextIndex = this.computeNextIndex(activeIndex, keyCode);
                this.activateTab(nextIndex);
            });
        }
    }
    onDelete() {
        const { tab: activeTab, index: activeTabIndex } = getActiveTab(this.owner.tabs);
        if (isTabClosable(activeTab, this.owner.closable) && !activeTab.disabled) {
            this.ngZone.run(() => {
                this.owner.tabClose.emit({ tab: activeTab, index: activeTabIndex });
            });
        }
    }
    activateTab(index) {
        const tab = getTabByIndex(this.owner.tabs, index);
        if (tab.disabled) {
            this.focusTabHeader(index);
            tab.focused = true;
        }
        else {
            this.onTabSelect(tab, index);
        }
    }
    focusTabHeader(index) {
        const tabHeader = getTabHeaderByIndex(this.owner.tabHeaderContainers, index);
        tabHeader.nativeElement.focus();
    }
    shouldHandleKey(keyCode) {
        if (isNavigationKey(keyCode)) {
            return true;
        }
        if (isTablistHorizontal(this.owner.tabPosition) && isHorizontalArrowKey(keyCode)) {
            return true;
        }
        if (!isTablistHorizontal(this.owner.tabPosition) && isVerticalArrowKey(keyCode)) {
            return true;
        }
        if (keyCode === Keys.Delete || keyCode === Keys.Backspace) {
            return true;
        }
        return false;
    }
    computeNextIndex(activeIndex, keyCode) {
        switch (keyCode) {
            case this.invertKeys(Keys.ArrowLeft, Keys.ArrowRight):
            case this.invertKeys(Keys.ArrowUp, Keys.ArrowDown):
                return this.prevNavigableIndex(activeIndex);
            case this.invertKeys(Keys.ArrowRight, Keys.ArrowLeft):
            case this.invertKeys(Keys.ArrowDown, Keys.ArrowUp):
                return this.nextNavigableIndex(activeIndex);
            case Keys.Home:
                return this.firstNavigableIndex();
            case Keys.End:
                return this.lastNavigableIndex();
            default:
                return;
        }
    }
    invertKeys(original, inverted) {
        return this.localization.rtl ? inverted : original;
    }
    firstNavigableIndex() {
        return 0;
    }
    lastNavigableIndex() {
        return this.owner.tabs.length - 1;
    }
    prevNavigableIndex(selectedIndex) {
        if (selectedIndex - 1 < 0) {
            return this.lastNavigableIndex();
        }
        return selectedIndex - 1;
    }
    nextNavigableIndex(selectedIndex) {
        if (selectedIndex + 1 >= this.owner.tabs.length) {
            return this.firstNavigableIndex();
        }
        return selectedIndex + 1;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TabStripService, deps: [{ token: i1.LocalizationService }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TabStripService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TabStripService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: i1.LocalizationService }, { type: i0.NgZone }] });

/**
 * @hidden
 */
const BUTTON_SCROLL_SPEED = 100;
/**
 * @hidden
 */
const SCROLLABLE_CLASS = 'k-tabstrip-scrollable';
/**
 * @hidden
 */
const HIDDEN_CLASS = 'k-hidden';
/**
 * @hidden
 */
const DIRECTION_CLASSES = {
    left: 'caret-alt-left',
    right: 'caret-alt-right',
    up: 'caret-alt-up',
    down: 'caret-alt-down'
};
/**
 * @hidden
 */
const DEFAULT_SCROLL_BEHAVIOR = 'smooth';

/**
 * @hidden
 */
class ScrollService {
    ngZone;
    localization;
    owner;
    position = 0;
    scrollButtonActiveStateChange = new Subject();
    get tablistElement() {
        return this.owner.tablist.nativeElement;
    }
    get tabstripSize() {
        const hostElement = this.owner.wrapper.nativeElement;
        const wrapperWidth = parseFloat(getComputedStyle(hostElement).width);
        const wrapperHeight = parseFloat(getComputedStyle(hostElement).height);
        return isTablistHorizontal(this.owner.tabPosition) ? wrapperWidth : wrapperHeight;
    }
    get tablistOverflowSize() {
        if (!isDocumentAvailable()) {
            return 0;
        }
        const isHorizontal = isTablistHorizontal(this.owner.tabPosition);
        const overflowSize = Math.floor(this.tablistElement[isHorizontal ? 'scrollWidth' : 'scrollHeight']
            - this.tablistElement.getBoundingClientRect()[isHorizontal ? 'width' : 'height']);
        return overflowSize < 0 ? 0 : overflowSize;
    }
    get tabsOverflow() {
        return this.tablistOverflowSize > 0;
    }
    constructor(ngZone, localization) {
        this.ngZone = ngZone;
        this.localization = localization;
    }
    toggleScrollButtonsState() {
        const tabStrip = this.owner;
        if (!tabStrip.hasScrollButtons) {
            return;
        }
        const currentPrevButtonActive = !this.isDisabled('prev');
        const currentNextButtonActive = !this.isDisabled('next');
        const isHorizontal = isTablistHorizontal(this.owner.tabPosition);
        const rtlDelta = this.localization.rtl && isHorizontal ? -1 : 1;
        const calculatedPrevButtonActive = (this.position * rtlDelta) > 0 && this.tablistOverflowSize > 0;
        const calculatedNextButtonActive = (this.position * rtlDelta) < this.tablistOverflowSize && this.tablistOverflowSize > 0;
        if (calculatedPrevButtonActive !== currentPrevButtonActive) {
            this.ngZone.run(() => this.toggleButtonActiveState('prev', calculatedPrevButtonActive));
        }
        if (calculatedNextButtonActive !== currentNextButtonActive) {
            this.ngZone.run(() => this.toggleButtonActiveState('next', calculatedNextButtonActive));
        }
    }
    scrollToSelectedTab() {
        if (!this.tabsOverflow) {
            return;
        }
        const { index: activeIndex } = getActiveTab(this.owner.tabs);
        if (activeIndex === -1) {
            return;
        }
        this.position += this.getScrollOffset(activeIndex);
        if (isTablistHorizontal(this.owner.tabPosition)) {
            this.tablistElement.scrollLeft = this.position;
        }
        else {
            this.tablistElement.scrollTop = this.position;
        }
        this.toggleScrollButtonsState();
        const tabStrip = this.owner;
        if (!tabStrip.hasScrollButtons) {
            return;
        }
        const isFirstTabActive = activeIndex === 0;
        const isLastTabActive = activeIndex === this.owner.tabs.length - 1;
        if (isFirstTabActive && !this.isDisabled('prev')) {
            this.ngZone.run(() => this.toggleButtonActiveState('prev', false));
        }
        if (isLastTabActive && !this.isDisabled('next')) {
            this.ngZone.run(() => this.toggleButtonActiveState('next', false));
        }
    }
    getScrollOffset(activeIndex) {
        if (!isDocumentAvailable()) {
            return 0;
        }
        const isHorizontal = isTablistHorizontal(this.owner.tabPosition);
        this.tablistElement[`scroll${isHorizontal ? 'Left' : 'Top'}`] = this.position;
        const activeTabRect = this.tablistElement.children[activeIndex].getBoundingClientRect();
        const tablistRect = this.tablistElement.getBoundingClientRect();
        const end = isHorizontal ? 'right' : 'bottom';
        const start = isHorizontal ? 'left' : 'top';
        const activeTabStart = activeTabRect[start];
        const activeTabEnd = activeTabRect[end];
        const tablistStart = tablistRect[start];
        const tablistEnd = tablistRect[end];
        const tabEndIsInVisibleRange = activeTabEnd <= tablistEnd;
        const tabStartIsInVisibleRange = activeTabStart >= tablistStart;
        const isWholeTabVisible = tabEndIsInVisibleRange && tabStartIsInVisibleRange;
        if (isWholeTabVisible) {
            return 0;
        }
        if (!tabEndIsInVisibleRange) {
            return activeTabEnd - tablistEnd;
        }
        if (!tabStartIsInVisibleRange) {
            return activeTabStart - tablistStart;
        }
    }
    onScroll(e) {
        this.position = isTablistHorizontal(this.owner.tabPosition) ? e.target.scrollLeft : e.target.scrollTop;
        this.toggleScrollButtonsState();
    }
    scrollTabs(direction) {
        this.calculateListPosition(direction, this.owner.scrollable.buttonScrollSpeed);
        if (isTablistHorizontal(this.owner.tabPosition) && this.tablistElement) {
            this.tablistElement.scrollTo({ left: this.position, behavior: DEFAULT_SCROLL_BEHAVIOR });
        }
        else {
            this.tablistElement.scrollTo({ top: this.position, behavior: DEFAULT_SCROLL_BEHAVIOR });
        }
        this.toggleScrollButtonsState();
    }
    calculateListPosition(direction, scrollSpeed) {
        const isHorizontal = isTablistHorizontal(this.owner.tabPosition);
        if (direction === 'prev') {
            if (this.localization.rtl && isHorizontal) {
                this.position = this.position + scrollSpeed >= 0 ? 0 : this.position + scrollSpeed;
            }
            else {
                this.position = this.position - scrollSpeed <= 0 ? 0 : this.position - scrollSpeed;
            }
        }
        else if (direction === 'next' && this.position < this.tablistOverflowSize) {
            if (this.position + scrollSpeed > this.tablistOverflowSize) {
                this.position = this.tablistOverflowSize;
                return;
            }
            if (this.localization.rtl && isHorizontal) {
                this.position -= scrollSpeed;
            }
            else {
                this.position += scrollSpeed;
            }
        }
    }
    restoreScrollPosition() {
        if (isTablistHorizontal(this.owner.tabPosition)) {
            this.tablistElement.scrollLeft = this.position;
        }
        else {
            this.tablistElement.scrollTop = this.position;
        }
        this.toggleScrollButtonsState();
    }
    toggleButtonActiveState(buttonType, active) {
        this.scrollButtonActiveStateChange.next({ buttonType, active });
    }
    isDisabled = (buttonType) => this.owner[`${buttonType}ScrollButton`]?.host.nativeElement.classList.contains('k-disabled');
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ScrollService, deps: [{ token: i0.NgZone }, { token: i1.LocalizationService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ScrollService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ScrollService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: i0.NgZone }, { type: i1.LocalizationService }] });

/**
 * @hidden
 */
const normalizeSettings = ({ enabled = true, scrollButtons = 'auto', mouseScroll = true, buttonScrollSpeed = BUTTON_SCROLL_SPEED, scrollButtonsPosition = 'split', prevButtonIcon, nextButtonIcon, prevSVGButtonIcon, nextSVGButtonIcon }) => ({
    enabled,
    scrollButtons,
    mouseScroll,
    buttonScrollSpeed,
    scrollButtonsPosition,
    prevButtonIcon,
    nextButtonIcon,
    prevSVGButtonIcon,
    nextSVGButtonIcon
});
/**
 * @hidden
 */
const normalizeScrollableSettings = (settings) => normalizeSettings(settings === false ? { enabled: false } : settings);

/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * @hidden
 */
class TabStripScrollableButtonComponent {
    host;
    renderer;
    ngZone;
    localization;
    get prevClass() {
        return this.prev;
    }
    get nextClass() {
        return !this.prev;
    }
    prev = false;
    tabPosition;
    scrollable;
    tabScroll = new EventEmitter();
    onClick = new EventEmitter();
    get hostBoundingClientRect() {
        return this.host.nativeElement.getBoundingClientRect();
    }
    get iconClass() {
        return this.scrollButtonIconClass;
    }
    get customIconClass() {
        return this.customScrollButtonIconClass;
    }
    get svgIcon() {
        return this.scrollButtonSVGIcon;
    }
    caretAltLeftIcon = caretAltLeftIcon;
    caretAltRightIcon = caretAltRightIcon;
    caretAltUpIcon = caretAltUpIcon;
    caretAltDownIcon = caretAltDownIcon;
    subs = new Subscription();
    constructor(host, renderer, ngZone, localization) {
        this.host = host;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.localization = localization;
    }
    ngAfterViewInit() {
        this.ngZone.runOutsideAngular(() => {
            this.subs.add(this.renderer.listen(this.host.nativeElement, 'click', this.clickHandler));
        });
    }
    ngOnDestroy() {
        this.subs.unsubscribe();
    }
    toggle(show) {
        this.renderer[show ? 'removeClass' : 'addClass'](this.host.nativeElement, HIDDEN_CLASS);
    }
    clickHandler = (scrollEvent) => {
        const tabStripScrollEvent = this.emitScrollEvent(scrollEvent);
        const isTabStripScrollEventPrevented = tabStripScrollEvent.isDefaultPrevented();
        if (isTabStripScrollEventPrevented) {
            return;
        }
        const buttonType = this.prev ? 'prev' : 'next';
        this.onClick.emit(buttonType);
    };
    get scrollButtonIconClass() {
        const defaultPrevIcon = isTablistHorizontal(this.tabPosition) ?
            !this.localization.rtl ?
                DIRECTION_CLASSES.left :
                DIRECTION_CLASSES.right :
            DIRECTION_CLASSES.up;
        const defaultNextIcon = isTablistHorizontal(this.tabPosition) ?
            !this.localization.rtl ?
                DIRECTION_CLASSES.right :
                DIRECTION_CLASSES.left :
            DIRECTION_CLASSES.down;
        if (typeof this.scrollable === 'object') {
            const prevIcon = typeof this.scrollable.prevButtonIcon === 'undefined' ? defaultPrevIcon : '';
            const nextIcon = typeof this.scrollable.nextButtonIcon === 'undefined' ? defaultNextIcon : '';
            if (prevIcon && this.prev) {
                return prevIcon;
            }
            else if (nextIcon && !this.prev) {
                return nextIcon;
            }
        }
    }
    get customScrollButtonIconClass() {
        if (typeof this.scrollable === 'object') {
            const prevIcon = this.scrollable.prevButtonIcon;
            const nextIcon = this.scrollable.nextButtonIcon;
            if (prevIcon && this.prev) {
                return `k-icon ${prevIcon}`;
            }
            if (nextIcon && !this.prev) {
                return `k-icon ${nextIcon}`;
            }
        }
    }
    get scrollButtonSVGIcon() {
        const defaultPrevSVGIcon = isTablistHorizontal(this.tabPosition) ?
            !this.localization.rtl ?
                this.caretAltLeftIcon :
                this.caretAltRightIcon :
            this.caretAltUpIcon;
        const defaultNextSVGIcon = isTablistHorizontal(this.tabPosition) ?
            !this.localization.rtl ?
                this.caretAltRightIcon :
                this.caretAltLeftIcon :
            this.caretAltDownIcon;
        if (typeof this.scrollable === 'object') {
            const prevIcon = this.scrollable.prevSVGButtonIcon !== undefined ? this.scrollable.prevSVGButtonIcon : defaultPrevSVGIcon;
            const nextIcon = this.scrollable.nextSVGButtonIcon !== undefined ? this.scrollable.nextSVGButtonIcon : defaultNextSVGIcon;
            if (prevIcon || nextIcon) {
                return this.prev ? prevIcon : nextIcon;
            }
        }
    }
    emitScrollEvent(event) {
        const scrollEvent = new TabScrollEvent({
            originalEvent: event
        });
        this.tabScroll.emit(scrollEvent);
        return scrollEvent;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TabStripScrollableButtonComponent, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }, { token: i0.NgZone }, { token: i1.LocalizationService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: TabStripScrollableButtonComponent, isStandalone: true, selector: "[kendoTabStripScrollableButton]", inputs: { prev: "prev", tabPosition: "tabPosition", scrollable: "scrollable" }, outputs: { tabScroll: "tabScroll", onClick: "onClick" }, host: { properties: { "class.k-tabstrip-prev": "this.prevClass", "class.k-tabstrip-next": "this.nextClass" } }, ngImport: i0, template: `
        <kendo-icon-wrapper
            [name]="iconClass"
            [customFontClass]="customIconClass"
            [svgIcon]="svgIcon"
            innerCssClass="k-button-icon"
        >
        </kendo-icon-wrapper>
    `, isInline: true, dependencies: [{ kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TabStripScrollableButtonComponent, decorators: [{
            type: Component,
            args: [{
                    template: `
        <kendo-icon-wrapper
            [name]="iconClass"
            [customFontClass]="customIconClass"
            [svgIcon]="svgIcon"
            innerCssClass="k-button-icon"
        >
        </kendo-icon-wrapper>
    `,
                    // eslint-disable-next-line @angular-eslint/component-selector
                    selector: '[kendoTabStripScrollableButton]',
                    standalone: true,
                    imports: [IconWrapperComponent]
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i0.NgZone }, { type: i1.LocalizationService }], propDecorators: { prevClass: [{
                type: HostBinding,
                args: ['class.k-tabstrip-prev']
            }], nextClass: [{
                type: HostBinding,
                args: ['class.k-tabstrip-next']
            }], prev: [{
                type: Input
            }], tabPosition: [{
                type: Input
            }], scrollable: [{
                type: Input
            }], tabScroll: [{
                type: Output
            }], onClick: [{
                type: Output
            }] } });

/**
 * @hidden
 */
class TabComponent {
    localization;
    tab;
    index;
    tabStripClosable;
    tabStripCloseIcon;
    customTabstripCloseIcon;
    closeSVGIcon;
    tabClose = new EventEmitter();
    hostClasses = true;
    get activeClass() {
        return this.tab.selected;
    }
    get disabledClass() {
        return this.tab.disabled;
    }
    get focusedClass() {
        return this.tab.focused;
    }
    get tabIndex() {
        return this.tab.selected || this.tab.focused ? 0 : -1;
    }
    constructor(localization) {
        this.localization = localization;
    }
    get tabClosable() {
        if (this.tab.closable !== undefined) {
            return this.tab.closable;
        }
        return this.tabStripClosable;
    }
    get closeSVGIconClass() {
        if (this.customCloseIconClasses) {
            return;
        }
        if (this.tab.closeSVGIcon) {
            return this.tab.closeSVGIcon;
        }
        if (this.closeSVGIcon) {
            return this.closeSVGIcon;
        }
        return xIcon;
    }
    get closeIconClasses() {
        if (!this.customTabstripCloseIcon && this.tabStripCloseIcon && !this.tab.closeIconClass) {
            if (this.tab.closeIcon) {
                return this.tab.closeIcon;
            }
            return this.tabStripCloseIcon;
        }
    }
    get customCloseIconClasses() {
        if (this.customTabstripCloseIcon || this.tab.closeIconClass) {
            if (this.tab.closeIconClass) {
                return this.tab.closeIconClass;
            }
            return this.customTabstripCloseIcon;
        }
    }
    get closeButtonTitle() {
        return this.localization.get('closeTitle');
    }
    closeTab(index) {
        const closeArgs = new TabCloseEvent(index, this.tab);
        this.tabClose.emit(closeArgs);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TabComponent, deps: [{ token: i1.LocalizationService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: TabComponent, isStandalone: true, selector: "[kendoTabStripTab]", inputs: { tab: "tab", index: "index", tabStripClosable: "tabStripClosable", tabStripCloseIcon: "tabStripCloseIcon", customTabstripCloseIcon: "customTabstripCloseIcon", closeSVGIcon: "closeSVGIcon" }, outputs: { tabClose: "tabClose" }, host: { properties: { "class.k-tabstrip-item": "this.hostClasses", "attr.aria-selected": "this.activeClass", "class.k-active": "this.activeClass", "attr.aria-disabled": "this.disabledClass", "class.k-disabled": "this.disabledClass", "class.k-focus": "this.focusedClass", "attr.tabindex": "this.tabIndex" } }, ngImport: i0, template: `
        @if (!tab.tabTemplate) {
          @if (!tab.tabTitle) {
            <span class="k-link">
              <span class="k-link-text">{{ tab.title }}</span>
            </span>
          }
          @if (tab.tabTitle) {
            <span class="k-link">
              <ng-template [ngTemplateOutlet]="tab.tabTitle.templateRef">
              </ng-template>
            </span>
          }
        } @else {
          <ng-template #tabTemplate [ngTemplateOutlet]="tab.tabTemplate?.templateRef">
          </ng-template>
        }

        @if (tabClosable) {
          <span class="k-remove-tab k-icon-button k-button k-button-md k-rounded-md k-button-flat-base k-button-flat"
            (click)="closeTab(index)" [title]="closeButtonTitle">
            <kendo-icon-wrapper
              [svgIcon]="closeSVGIconClass" [name]="closeIconClasses"
            innerCssClass="k-button-icon" [customFontClass]="customCloseIconClasses"></kendo-icon-wrapper>
          </span>
        }
        `, isInline: true, dependencies: [{ kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TabComponent, decorators: [{
            type: Component,
            args: [{
                    // eslint-disable-next-line @angular-eslint/component-selector
                    selector: '[kendoTabStripTab]',
                    template: `
        @if (!tab.tabTemplate) {
          @if (!tab.tabTitle) {
            <span class="k-link">
              <span class="k-link-text">{{ tab.title }}</span>
            </span>
          }
          @if (tab.tabTitle) {
            <span class="k-link">
              <ng-template [ngTemplateOutlet]="tab.tabTitle.templateRef">
              </ng-template>
            </span>
          }
        } @else {
          <ng-template #tabTemplate [ngTemplateOutlet]="tab.tabTemplate?.templateRef">
          </ng-template>
        }

        @if (tabClosable) {
          <span class="k-remove-tab k-icon-button k-button k-button-md k-rounded-md k-button-flat-base k-button-flat"
            (click)="closeTab(index)" [title]="closeButtonTitle">
            <kendo-icon-wrapper
              [svgIcon]="closeSVGIconClass" [name]="closeIconClasses"
            innerCssClass="k-button-icon" [customFontClass]="customCloseIconClasses"></kendo-icon-wrapper>
          </span>
        }
        `,
                    standalone: true,
                    imports: [NgTemplateOutlet, IconWrapperComponent]
                }]
        }], ctorParameters: () => [{ type: i1.LocalizationService }], propDecorators: { tab: [{
                type: Input
            }], index: [{
                type: Input
            }], tabStripClosable: [{
                type: Input
            }], tabStripCloseIcon: [{
                type: Input
            }], customTabstripCloseIcon: [{
                type: Input
            }], closeSVGIcon: [{
                type: Input
            }], tabClose: [{
                type: Output
            }], hostClasses: [{
                type: HostBinding,
                args: ['class.k-tabstrip-item']
            }], activeClass: [{
                type: HostBinding,
                args: ['attr.aria-selected']
            }, {
                type: HostBinding,
                args: ['class.k-active']
            }], disabledClass: [{
                type: HostBinding,
                args: ['attr.aria-disabled']
            }, {
                type: HostBinding,
                args: ['class.k-disabled']
            }], focusedClass: [{
                type: HostBinding,
                args: ['class.k-focus']
            }], tabIndex: [{
                type: HostBinding,
                args: ['attr.tabindex']
            }] } });

/**
 * @hidden
 */
class TabStripMessages extends ComponentMessages {
    /**
     * Sets the title for the **Close** button in the TabStrip tab.
     */
    closeTitle;
    /**
     * Sets the title for the **Previous Tab** button when the TabStrip is scrollable.
     */
    previousTabButton;
    /**
     * Sets the title for the **Next Tab** button when the TabStrip is scrollable.
     */
    nextTabButton;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TabStripMessages, deps: null, target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: TabStripMessages, isStandalone: true, selector: "kendo-tabstrip-messages-base", inputs: { closeTitle: "closeTitle", previousTabButton: "previousTabButton", nextTabButton: "nextTabButton" }, usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TabStripMessages, decorators: [{
            type: Directive,
            args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: 'kendo-tabstrip-messages-base'
                }]
        }], propDecorators: { closeTitle: [{
                type: Input
            }], previousTabButton: [{
                type: Input
            }], nextTabButton: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class LocalizedTabStripMessagesDirective extends TabStripMessages {
    service;
    constructor(service) {
        super();
        this.service = service;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: LocalizedTabStripMessagesDirective, deps: [{ token: i1.LocalizationService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: LocalizedTabStripMessagesDirective, isStandalone: true, selector: "[kendoTabStripLocalizedMessages]", providers: [
            {
                provide: TabStripMessages,
                useExisting: forwardRef(() => LocalizedTabStripMessagesDirective)
            }
        ], usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: LocalizedTabStripMessagesDirective, decorators: [{
            type: Directive,
            args: [{
                    providers: [
                        {
                            provide: TabStripMessages,
                            useExisting: forwardRef(() => LocalizedTabStripMessagesDirective)
                        }
                    ],
                    selector: `[kendoTabStripLocalizedMessages]`,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1.LocalizationService }] });

/**
 * Represents the [Kendo UI TabStrip component for Angular]({% slug overview_tabstrip %}).
 *
 * @example
 * ```html
 * <kendo-tabstrip>
 *   <kendo-tabstrip-tab [title]="'First Tab'">
 *     <ng-template kendoTabContent>
 *       <p>Content of the first tab.</p>
 *     </ng-template>
 *   </kendo-tabstrip-tab>
 *   <kendo-tabstrip-tab [title]="'Second Tab'">
 *     <ng-template kendoTabContent>
 *       <p>Content of the second tab.</p>
 *     </ng-template>
 *   </kendo-tabstrip-tab>
 * </kendo-tabstrip>
 * ```
 * @remarks
 * Supported children components are: {@link TabStripCustomMessagesComponent}, {@link TabStripTabComponent}.
 */
class TabStripComponent {
    localization;
    renderer;
    wrapper;
    tabstripService;
    scrollService;
    ngZone;
    /**
     * Sets the height of the TabStrip.
     * Accepts a CSS size value, such as `100px`, `50%`, or `auto`.
     */
    set height(value) {
        this._height = value;
        this.renderer.setStyle(this.wrapper.nativeElement, 'height', value);
    }
    get height() {
        return this._height;
    }
    /**
     * Sets whether the TabStrip should animate when switching tabs.
     *
     * @default true
     */
    animate = true;
    /**
     * Sets the alignment of the tabs.
     *
     * @default 'start'
     */
    tabAlignment = 'start';
    /**
     * Sets the position of the tabs.
     *
     * @default 'top'
     */
    tabPosition = 'top';
    /**
    * Controls how the TabStrip renders tab content.
    *
    * The available options are:
    *
    * * `true`&mdash;Renders all tabs' content and persists them in the DOM.
    * * `false`&mdash;Removes inactive tabs' content from the DOM.
    * * `"loadOnDemand"`&mdash;Loads tabs' content only when activated for the first time. Inactive tabs' content is not rendered until the tab is activated.
    *
    * For more information, refer to the [Rendering Modes](slug:rendering_tabstrip) article.
    *
    * @default false
    */
    keepTabContent = false;
    /**
     * When set to `true`, renders a close button inside each tab.
     *
     * @default false
     */
    closable = false;
    /**
     * Enables scrolling of the tab list.
     * When set to `true` and the total size of all tabs exceeds the size of the TabStrip container, scroll buttons appear on each end of the tab list.
     *
     * @default false
     */
    set scrollable(value) {
        this._scrollableSettings = normalizeScrollableSettings(value);
        if (this.tablist) {
            this.toggleScrollButtons(this.scrollService.tabsOverflow);
            if (this.isScrollable && this.mouseScrollEnabled) {
                this.attachTablistScrollHandler(this.tablist.nativeElement);
            }
        }
    }
    get scrollable() {
        return this._scrollableSettings;
    }
    /**
     * Sets the size of the TabStrip.
     * [See example](slug:api_layout_tabstripcomponent#toc-size).
     * @default 'medium'
     */
    set size(value) {
        switch (value) {
            case 'small':
                this.renderer.removeClass(this.wrapper.nativeElement, 'k-tabstrip-md');
                this.renderer.removeClass(this.wrapper.nativeElement, 'k-tabstrip-lg');
                this.renderer.addClass(this.wrapper.nativeElement, 'k-tabstrip-sm');
                break;
            case 'medium':
                this.renderer.removeClass(this.wrapper.nativeElement, 'k-tabstrip-sm');
                this.renderer.removeClass(this.wrapper.nativeElement, 'k-tabstrip-lg');
                this.renderer.addClass(this.wrapper.nativeElement, 'k-tabstrip-md');
                break;
            case 'large':
                this.renderer.removeClass(this.wrapper.nativeElement, 'k-tabstrip-md');
                this.renderer.removeClass(this.wrapper.nativeElement, 'k-tabstrip-sm');
                this.renderer.addClass(this.wrapper.nativeElement, 'k-tabstrip-lg');
                break;
            case 'none':
                this.renderer.removeClass(this.wrapper.nativeElement, 'k-tabstrip-md');
                this.renderer.removeClass(this.wrapper.nativeElement, 'k-tabstrip-lg');
                this.renderer.removeClass(this.wrapper.nativeElement, 'k-tabstrip-sm');
        }
        this._size = value;
        this.ngZone.onStable.pipe(take(1)).subscribe(() => this.onResize());
    }
    get size() {
        return this._size;
    }
    /**
     * Defines the name of an existing font icon in the Kendo UI theme for the close icon.
     * @default 'x'
     */
    closeIcon = 'x';
    /**
     * Defines a custom CSS class, or multiple classes separated by spaces, applied to the close button.
     */
    closeIconClass;
    /**
     * Defines an SVGIcon to render for the close icon.
     * The input accepts either an [existing Kendo SVG icon](slug:svgicon_list) or a custom one.
     */
    set closeSVGIcon(icon) {
        if (isDevMode() && icon && this.closeIcon && this.closeIcon !== 'x') {
            throw new Error('Setting both closeIcon and svgIcon options at the same time is not supported.');
        }
        this._closeSVGIcon = icon;
    }
    get closeSVGIcon() {
        return this._closeSVGIcon;
    }
    /**
     * If set to `false`, the content area is hidden, but the tab headers are still visible.
     *
     * @default true
     */
    showContentArea = true;
    /**
     * Fires each time a tab is selected.
     * The event data contains the index of the selected tab and its title.
     */
    tabSelect = new EventEmitter();
    /**
     * Fires each time a tab is closed.
     * The event data contains the index of the closed tab and its instance.
     */
    tabClose = new EventEmitter();
    /**
     * Fires when the tab list is scrolled.
     * The event is preventable.
     */
    tabScroll = new EventEmitter();
    hostClasses = true;
    get tabsAtTop() {
        return this.tabPosition === 'top';
    }
    get tabsAtRight() {
        return this.tabPosition === 'right';
    }
    get tabsAtBottom() {
        return this.tabPosition === 'bottom';
    }
    get tabsAtLeft() {
        return this.tabPosition === 'left';
    }
    get dir() {
        return this.localization.rtl ? 'rtl' : 'ltr';
    }
    get tabStripScrollable() {
        return this._scrollableSettings.enabled;
    }
    get tabStripScrollableOverlay() {
        return this._scrollableSettings.enabled && !this.hasScrollButtons.visible;
    }
    /**
     * A query list of all declared tabs.
     */
    tabs = new QueryList();
    /**
     * @hidden
     */
    tablist;
    /**
     * @hidden
     */
    tabHeaderContainers;
    /**
     * @hidden
     */
    prevScrollButton;
    /**
     * @hidden
     */
    nextScrollButton;
    /**
     * @hidden
     */
    localizationChangeSubscription;
    /**
     * @hidden
     */
    showLicenseWatermark = false;
    /**
     * @hidden
     */
    licenseMessage;
    _height;
    _scrollableSettings = normalizeScrollableSettings(false);
    subscriptions = new Subscription();
    subscriptionsArePresent = false;
    _closeSVGIcon;
    tabStripId = guid();
    tabsChangesSub;
    activeStateChangeSub;
    _size = 'medium';
    constructor(localization, renderer, wrapper, tabstripService, scrollService, ngZone) {
        this.localization = localization;
        this.renderer = renderer;
        this.wrapper = wrapper;
        this.tabstripService = tabstripService;
        this.scrollService = scrollService;
        this.ngZone = ngZone;
        const isValid = validatePackage(packageMetadata);
        this.licenseMessage = getLicenseMessage(packageMetadata);
        this.showLicenseWatermark = shouldShowValidationUI(isValid);
        this.tabstripService.owner = this;
        this.scrollService.owner = this;
        this.subscriptions.add(this.scrollService.scrollButtonActiveStateChange.subscribe((activeButtonSettings) => {
            if (this.hasScrollButtons.visible) {
                const action = activeButtonSettings.active ? 'remove' : 'add';
                this.renderer[`${action}Class`](this[`${activeButtonSettings.buttonType}ScrollButton`].host.nativeElement, 'k-disabled');
            }
        }));
    }
    ngAfterViewInit() {
        if (!isDocumentAvailable()) {
            return;
        }
        this.ngZone.runOutsideAngular(() => {
            if (this.scrollService.tabsOverflow) {
                this.toggleScrollButtons(true);
            }
            else {
                this.toggleScrollButtons(false);
            }
            setTimeout(() => {
                this.scrollToSelectedTab();
            });
        });
        this.initDomEvents();
        this.tabsChangesSub = this.tabs.changes.subscribe(() => {
            this.ngZone.onStable.pipe(take(1)).subscribe(() => {
                this.toggleScrollButtons(this.scrollService.tabsOverflow);
                this.scrollService.toggleScrollButtonsState();
            });
        });
        this.isScrollable && !this.hasScrollButtons.visible && this.setScrollableOverlayClasses();
    }
    ngOnChanges(changes) {
        if (!isDocumentAvailable()) {
            return;
        }
        const positionChange = changes['tabPosition'];
        if (positionChange) {
            const tabsAtBottomChanged = positionChange.previousValue === 'bottom' || positionChange.currentValue === 'bottom';
            this.ngZone.onStable.pipe(take(1)).subscribe(() => {
                if (tabsAtBottomChanged) {
                    if (this.subscriptionsArePresent) {
                        this.subscriptions.unsubscribe();
                        this.subscriptions = new Subscription();
                        this.subscriptionsArePresent = false;
                        this.activeStateChangeSub = this.scrollService.scrollButtonActiveStateChange.subscribe((activeButtonSettings) => {
                            if (this.hasScrollButtons.visible) {
                                const action = activeButtonSettings.active ? 'remove' : 'add';
                                this.renderer[`${action}Class`](this[`${activeButtonSettings.buttonType}ScrollButton`].host.nativeElement, 'k-disabled');
                            }
                        });
                    }
                    this.initDomEvents();
                }
                this.scrollService.restoreScrollPosition();
            });
        }
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
        if (this.tabsChangesSub) {
            this.tabsChangesSub.unsubscribe();
        }
        if (this.activeStateChangeSub) {
            this.activeStateChangeSub.unsubscribe();
        }
    }
    /**
     * @hidden
     */
    get isScrollable() {
        return this._scrollableSettings.enabled;
    }
    /**
     * @hidden
     */
    get hasScrollButtons() {
        return tabStripHasScrollButtons(this._scrollableSettings);
    }
    /**
     * @hidden
     */
    get mouseScrollEnabled() {
        return mouseScrollEnabled(this._scrollableSettings);
    }
    /**
     * @hidden
     */
    get itemsWrapperClass() {
        return isTablistHorizontal(this.tabPosition) ? 'k-hstack' : 'k-vstack';
    }
    /**
     * Allows you to programmatically select a tab by its index.
     * If the tab is disabled, it will not be selected. The `tabSelect` event will not be fired.
     * @param {number} index The index of the tab that will be selected.
     */
    selectTab(index) {
        const tab = getTabByIndex(this.tabs, index);
        if (!tab || tab.disabled) {
            return;
        }
        this.tabstripService.selectTab(tab, index);
        this.scrollToSelectedTab();
    }
    /**
     * @hidden
     */
    getTabId(idx) {
        return getId$1('k-tabstrip-tab', this.tabStripId, idx);
    }
    /**
     * @hidden
     */
    getTabPanelId(idx) {
        return getId$1('k-tabstrip-tabpanel', this.tabStripId, idx);
    }
    /**
     * @hidden
     */
    onTabClick(originalEvent, tabIndex) {
        if (isFocusable(originalEvent.target)) {
            return;
        }
        const targetElement = originalEvent.target;
        const isTargetCloseButton = hasClass(targetElement, 'k-remove-tab') || hasClass(targetElement.parentElement, 'k-remove-tab');
        if (isTargetCloseButton) {
            return;
        }
        const tab = getTabByIndex(this.tabs, tabIndex);
        this.tabstripService.onTabSelect(tab, tabIndex);
        this.scrollToSelectedTab();
    }
    /**
     * @hidden
     */
    onResize() {
        if (this.scrollService.tabsOverflow) {
            this.toggleScrollButtons(true);
        }
        else {
            this.toggleScrollButtons(false);
        }
        this.ngZone.runOutsideAngular(() => {
            this.scrollService.toggleScrollButtonsState();
        });
    }
    /**
     * @hidden
     */
    scrollToSelectedTab() {
        if (this._scrollableSettings.enabled) {
            this.scrollService.scrollToSelectedTab();
        }
    }
    /**
     * @hidden
     */
    onScrollButtonClick(buttonType) {
        this.scrollService.scrollTabs(buttonType);
    }
    initDomEvents() {
        if (!this.wrapper || this.subscriptionsArePresent) {
            return;
        }
        const tablist = this.tablist.nativeElement;
        this.ngZone.runOutsideAngular(() => {
            this.subscriptions.add(this.renderer.listen(tablist, 'keydown', (ev) => {
                this.tabstripService.onKeyDown(ev);
            }));
        });
        this.subscriptions.add(this.renderer.listen(tablist, 'focusout', () => {
            resetTabFocus(this.tabs);
        }));
        if (this.isScrollable && this.mouseScrollEnabled) {
            this.attachTablistScrollHandler(tablist);
        }
        this.subscriptionsArePresent = true;
    }
    toggleScrollButtons(tabsOverflow) {
        this.ngZone.onStable.pipe(take(1)).subscribe(() => {
            const scrollButtonsSetting = this._scrollableSettings.scrollButtons;
            const scrollButtonsArePresent = this.prevScrollButton && this.nextScrollButton;
            const shouldShowButtons = scrollButtonsArePresent && tabsOverflow;
            const shouldHideButtons = scrollButtonsArePresent &&
                !tabsOverflow &&
                scrollButtonsSetting !== 'visible';
            const alwaysVisible = scrollButtonsSetting === 'visible';
            if (shouldHideButtons) {
                this.prevScrollButton.toggle(false);
                this.nextScrollButton.toggle(false);
            }
            else if (shouldShowButtons || alwaysVisible) {
                this.prevScrollButton.toggle(true);
                this.nextScrollButton.toggle(true);
            }
            if (scrollButtonsArePresent) {
                this.ngZone.runOutsideAngular(() => {
                    this.scrollService.toggleScrollButtonsState();
                });
            }
        });
    }
    attachTablistScrollHandler(tablist) {
        this.ngZone.runOutsideAngular(() => {
            this.subscriptions.add(this.renderer.listen(tablist, 'scroll', (e) => {
                const scrollEvent = new TabScrollEvent({
                    originalEvent: e
                });
                this.tabScroll.emit(scrollEvent);
                const isTabStripScrollEventPrevented = scrollEvent.isDefaultPrevented();
                if (isTabStripScrollEventPrevented || !this.scrollService.tabsOverflow) {
                    return;
                }
                if (!this.hasScrollButtons.visible) {
                    this.setScrollableOverlayClasses();
                }
                this.scrollService.onScroll(e);
            }));
        });
    }
    setScrollableOverlayClasses() {
        const wrapper = this.wrapper.nativeElement;
        const container = this.tablist?.nativeElement;
        if (!container) {
            return;
        }
        const scrollOffset = isTablistHorizontal(this.tabPosition) ? container.scrollLeft : container.scrollTop;
        if (scrollOffset === 0) {
            this.renderer.removeClass(wrapper, 'k-tabstrip-scrollable-end');
            this.renderer.addClass(wrapper, 'k-tabstrip-scrollable-start');
        }
        else if (scrollOffset > 0 && scrollOffset < this.scrollService.tablistOverflowSize) {
            this.renderer.removeClass(wrapper, 'k-tabstrip-scrollable-end');
            this.renderer.removeClass(wrapper, 'k-tabstrip-scrollable-start');
        }
        else {
            this.renderer.removeClass(wrapper, 'k-tabstrip-scrollable-start');
            this.renderer.addClass(wrapper, 'k-tabstrip-scrollable-end');
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TabStripComponent, deps: [{ token: i1.LocalizationService }, { token: i0.Renderer2 }, { token: i0.ElementRef }, { token: TabStripService }, { token: ScrollService }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: TabStripComponent, isStandalone: true, selector: "kendo-tabstrip", inputs: { height: "height", animate: "animate", tabAlignment: "tabAlignment", tabPosition: "tabPosition", keepTabContent: "keepTabContent", closable: "closable", scrollable: "scrollable", size: "size", closeIcon: "closeIcon", closeIconClass: "closeIconClass", closeSVGIcon: "closeSVGIcon", showContentArea: "showContentArea" }, outputs: { tabSelect: "tabSelect", tabClose: "tabClose", tabScroll: "tabScroll" }, host: { properties: { "class.k-tabstrip": "this.hostClasses", "class.k-tabstrip-md": "this.hostClasses", "class.k-tabstrip-top": "this.tabsAtTop", "class.k-tabstrip-right": "this.tabsAtRight", "class.k-tabstrip-bottom": "this.tabsAtBottom", "class.k-tabstrip-left": "this.tabsAtLeft", "attr.dir": "this.dir", "class.k-tabstrip-scrollable": "this.tabStripScrollable", "class.k-tabstrip-scrollable-overlay": "this.tabStripScrollableOverlay" } }, providers: [
            TabStripService,
            ScrollService,
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.tabstrip'
            }
        ], queries: [{ propertyName: "tabs", predicate: TabStripTabComponent }], viewQueries: [{ propertyName: "tablist", first: true, predicate: ["tablist"], descendants: true }, { propertyName: "prevScrollButton", first: true, predicate: ["prevScrollButton"], descendants: true }, { propertyName: "nextScrollButton", first: true, predicate: ["nextScrollButton"], descendants: true }, { propertyName: "tabHeaderContainers", predicate: ["tabHeaderContainer"], descendants: true, read: ElementRef }], exportAs: ["kendoTabStrip"], usesOnChanges: true, ngImport: i0, template: `
        <ng-container kendoTabStripLocalizedMessages
          i18n-closeTitle="kendo.tabstrip.closeTitle|The title for the **Close** button in the TabStrip tab."
          closeTitle="Close"

          i18n-previousTabButton="kendo.tabstrip.previousTabButton|The title for the **Previous Tab** button when the Tabstrip is scrollable."
          previousTabButton="Previous Tab"

          i18n-nextTabButton="kendo.tabstrip.nextTabButton|The title for the **Next Tab** button when the Tabstrip is scrollable."
          nextTabButton="Next Tab"
          >
        </ng-container>
        @if (!tabsAtBottom) {
          <ng-container *ngTemplateOutlet="heading"></ng-container>
          @if (showContentArea) {
            <ng-container *ngTemplateOutlet="content"></ng-container>
          }
        }

        @if (tabsAtBottom) {
          @if (showContentArea) {
            <ng-container *ngTemplateOutlet="content"></ng-container>
          }
          <ng-container *ngTemplateOutlet="heading"></ng-container>
        }
        <ng-template #heading>
          <div class="k-tabstrip-items-wrapper" [class.k-tabstrip-items-wrapper-scroll]="mouseScrollEnabled" [ngClass]="itemsWrapperClass">
            @if (hasScrollButtons.visible && hasScrollButtons.position !== 'end') {
              <span
                role="button"
                #prevScrollButton
                kendoTabStripScrollableButton
                [scrollable]="scrollable"
                [tabPosition]="tabPosition"
                [prev]="true"
                [title]="localization.get('previousTabButton')"
                (tabScroll)="tabScroll.emit($event)"
                class="k-icon-button k-button k-button-flat k-button-flat-base"
                    [ngClass]="{
                        'k-button-sm': size === 'small',
                        'k-button-md': size === 'medium' || !size,
                        'k-button-lg': size === 'large'
                    }"
              (onClick)="onScrollButtonClick($event)"></span>
            }
            @if (hasScrollButtons.visible && hasScrollButtons.position === 'start') {
              <span
                role="button"
                #nextScrollButton
                kendoTabStripScrollableButton
                [scrollable]="scrollable"
                [tabPosition]="tabPosition"
                [prev]="false"
                [title]="localization.get('nextTabButton')"
                (tabScroll)="tabScroll.emit($event)"
                class="k-icon-button k-button k-button-flat k-button-flat-base"
                    [ngClass]="{
                        'k-button-sm': size === 'small',
                        'k-button-md': size === 'medium' || !size,
                        'k-button-lg': size === 'large'
                    }"
              (onClick)="onScrollButtonClick($event)"></span>
            }
            <ul role="tablist" #tablist
              class="k-reset k-tabstrip-items"
                    [ngClass]="{
                        'k-tabstrip-items-start': tabAlignment === 'start',
                        'k-tabstrip-items-center': tabAlignment === 'center',
                        'k-tabstrip-items-end': tabAlignment === 'end',
                        'k-tabstrip-items-stretched': tabAlignment === 'stretched',
                        'k-tabstrip-items-justify': tabAlignment === 'justify',
                        'k-tabstrip-items-scroll': mouseScrollEnabled
                    }"
              [attr.aria-orientation]="tabPosition === 'left' || tabPosition === 'right' ? 'vertical' : 'horizontal'"
              >
              @for (tab of tabs; track tab; let i = $index) {
                <li
                    #tabHeaderContainer
                    kendoTabStripTab
                    [class.k-first]="i === 0"
                    [class.k-last]="i === tabs.length - 1"
                    [ngClass]="tab.cssClass"
                    [ngStyle]="tab.cssStyle"
                    [tab]="tab"
                    [index]="i"
                    role="tab"
                    [tabStripClosable]="closable"
                    [tabStripCloseIcon]="closeIcon"
                    [customTabstripCloseIcon]="closeIconClass"
                    [closeSVGIcon]="closeSVGIcon"
                    (tabClose)="tabClose.emit($event)"
                    (click)="onTabClick($event, i)"
                    [id]="getTabId(i)"
                    [attr.aria-controls]="(showContentArea && tab.selected) ? getTabPanelId(i) : undefined"></li>
              }
            </ul>
            @if (hasScrollButtons.visible && hasScrollButtons.position === 'end') {
              <span
                role="button"
                #prevScrollButton
                kendoTabStripScrollableButton
                [scrollable]="scrollable"
                [tabPosition]="tabPosition"
                [prev]="true"
                [title]="localization.get('previousTabButton')"
                (tabScroll)="tabScroll.emit($event)"
                class="k-icon-button k-button k-button-flat k-button-flat-base"
                    [ngClass]="{
                        'k-button-sm': size === 'small',
                        'k-button-md': size === 'medium' || !size,
                        'k-button-lg': size === 'large'
                    }"
              (onClick)="onScrollButtonClick($event)"></span>
            }
            @if (hasScrollButtons.visible && hasScrollButtons.position !== 'start') {
              <span
                role="button"
                #nextScrollButton
                kendoTabStripScrollableButton
                [scrollable]="scrollable"
                [tabPosition]="tabPosition"
                [prev]="false"
                [title]="localization.get('nextTabButton')"
                (tabScroll)="tabScroll.emit($event)"
                class="k-icon-button k-button k-button-flat k-button-flat-base"
                    [ngClass]="{
                        'k-button-sm': size === 'small',
                        'k-button-md': size === 'medium' || !size,
                        'k-button-lg': size === 'large'
                    }"
              (onClick)="onScrollButtonClick($event)"></span>
            }
          </div>
        </ng-template>
        <ng-template #content>
            @for (tab of tabs; track tab; let i = $index) {
                @if (tab.selected || keepTabContent !== false) {
                    @defer (when tab.selected || keepTabContent === true; prefetch on idle) {
                        <div
                            [@state]="tab.selected && animate ? 'active' : 'inactive'"
                            [ngClass]="!this.keepTabContent || tab.selected ? 'k-tabstrip-content k-active' : 'k-tabstrip-content'"
                            [tabIndex]="0"
                            role="tabpanel"
                            [id]="getTabPanelId(i)"
                            [attr.aria-hidden]="!tab.selected"
                            [attr.aria-labelledby]="getTabId(i)"
                            [attr.aria-disabled]="tab.disabled"
                        >
                            <ng-template [ngTemplateOutlet]="tab.tabContent?.templateRef"></ng-template>
                        </div>
                    }
                }
            }
        </ng-template>
        @if (isScrollable) {
          <kendo-resize-sensor (resize)="onResize()"></kendo-resize-sensor>
        }
        @if (showLicenseWatermark) {
          <div kendoWatermarkOverlay [licenseMessage]="licenseMessage"></div>
        }
        `, isInline: true, dependencies: [{ kind: "directive", type: LocalizedTabStripMessagesDirective, selector: "[kendoTabStripLocalizedMessages]" }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "component", type: TabStripScrollableButtonComponent, selector: "[kendoTabStripScrollableButton]", inputs: ["prev", "tabPosition", "scrollable"], outputs: ["tabScroll", "onClick"] }, { kind: "component", type: TabComponent, selector: "[kendoTabStripTab]", inputs: ["tab", "index", "tabStripClosable", "tabStripCloseIcon", "customTabstripCloseIcon", "closeSVGIcon"], outputs: ["tabClose"] }, { kind: "directive", type: NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "component", type: ResizeSensorComponent, selector: "kendo-resize-sensor", inputs: ["rateLimit"], outputs: ["resize"] }, { kind: "component", type: WatermarkOverlayComponent, selector: "div[kendoWatermarkOverlay]", inputs: ["licenseMessage"] }], animations: [
            trigger('state', [
                state('active', style({ opacity: 1 })),
                transition('* => active', [
                    style({ opacity: 0 }),
                    animate('400ms ease-in')
                ])
            ])
        ], deferBlockDependencies: [() => [NgTemplateOutlet, NgClass]] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TabStripComponent, decorators: [{
            type: Component,
            args: [{
                    animations: [
                        trigger('state', [
                            state('active', style({ opacity: 1 })),
                            transition('* => active', [
                                style({ opacity: 0 }),
                                animate('400ms ease-in')
                            ])
                        ])
                    ],
                    providers: [
                        TabStripService,
                        ScrollService,
                        LocalizationService,
                        {
                            provide: L10N_PREFIX,
                            useValue: 'kendo.tabstrip'
                        }
                    ],
                    exportAs: 'kendoTabStrip',
                    selector: 'kendo-tabstrip',
                    template: `
        <ng-container kendoTabStripLocalizedMessages
          i18n-closeTitle="kendo.tabstrip.closeTitle|The title for the **Close** button in the TabStrip tab."
          closeTitle="Close"

          i18n-previousTabButton="kendo.tabstrip.previousTabButton|The title for the **Previous Tab** button when the Tabstrip is scrollable."
          previousTabButton="Previous Tab"

          i18n-nextTabButton="kendo.tabstrip.nextTabButton|The title for the **Next Tab** button when the Tabstrip is scrollable."
          nextTabButton="Next Tab"
          >
        </ng-container>
        @if (!tabsAtBottom) {
          <ng-container *ngTemplateOutlet="heading"></ng-container>
          @if (showContentArea) {
            <ng-container *ngTemplateOutlet="content"></ng-container>
          }
        }

        @if (tabsAtBottom) {
          @if (showContentArea) {
            <ng-container *ngTemplateOutlet="content"></ng-container>
          }
          <ng-container *ngTemplateOutlet="heading"></ng-container>
        }
        <ng-template #heading>
          <div class="k-tabstrip-items-wrapper" [class.k-tabstrip-items-wrapper-scroll]="mouseScrollEnabled" [ngClass]="itemsWrapperClass">
            @if (hasScrollButtons.visible && hasScrollButtons.position !== 'end') {
              <span
                role="button"
                #prevScrollButton
                kendoTabStripScrollableButton
                [scrollable]="scrollable"
                [tabPosition]="tabPosition"
                [prev]="true"
                [title]="localization.get('previousTabButton')"
                (tabScroll)="tabScroll.emit($event)"
                class="k-icon-button k-button k-button-flat k-button-flat-base"
                    [ngClass]="{
                        'k-button-sm': size === 'small',
                        'k-button-md': size === 'medium' || !size,
                        'k-button-lg': size === 'large'
                    }"
              (onClick)="onScrollButtonClick($event)"></span>
            }
            @if (hasScrollButtons.visible && hasScrollButtons.position === 'start') {
              <span
                role="button"
                #nextScrollButton
                kendoTabStripScrollableButton
                [scrollable]="scrollable"
                [tabPosition]="tabPosition"
                [prev]="false"
                [title]="localization.get('nextTabButton')"
                (tabScroll)="tabScroll.emit($event)"
                class="k-icon-button k-button k-button-flat k-button-flat-base"
                    [ngClass]="{
                        'k-button-sm': size === 'small',
                        'k-button-md': size === 'medium' || !size,
                        'k-button-lg': size === 'large'
                    }"
              (onClick)="onScrollButtonClick($event)"></span>
            }
            <ul role="tablist" #tablist
              class="k-reset k-tabstrip-items"
                    [ngClass]="{
                        'k-tabstrip-items-start': tabAlignment === 'start',
                        'k-tabstrip-items-center': tabAlignment === 'center',
                        'k-tabstrip-items-end': tabAlignment === 'end',
                        'k-tabstrip-items-stretched': tabAlignment === 'stretched',
                        'k-tabstrip-items-justify': tabAlignment === 'justify',
                        'k-tabstrip-items-scroll': mouseScrollEnabled
                    }"
              [attr.aria-orientation]="tabPosition === 'left' || tabPosition === 'right' ? 'vertical' : 'horizontal'"
              >
              @for (tab of tabs; track tab; let i = $index) {
                <li
                    #tabHeaderContainer
                    kendoTabStripTab
                    [class.k-first]="i === 0"
                    [class.k-last]="i === tabs.length - 1"
                    [ngClass]="tab.cssClass"
                    [ngStyle]="tab.cssStyle"
                    [tab]="tab"
                    [index]="i"
                    role="tab"
                    [tabStripClosable]="closable"
                    [tabStripCloseIcon]="closeIcon"
                    [customTabstripCloseIcon]="closeIconClass"
                    [closeSVGIcon]="closeSVGIcon"
                    (tabClose)="tabClose.emit($event)"
                    (click)="onTabClick($event, i)"
                    [id]="getTabId(i)"
                    [attr.aria-controls]="(showContentArea && tab.selected) ? getTabPanelId(i) : undefined"></li>
              }
            </ul>
            @if (hasScrollButtons.visible && hasScrollButtons.position === 'end') {
              <span
                role="button"
                #prevScrollButton
                kendoTabStripScrollableButton
                [scrollable]="scrollable"
                [tabPosition]="tabPosition"
                [prev]="true"
                [title]="localization.get('previousTabButton')"
                (tabScroll)="tabScroll.emit($event)"
                class="k-icon-button k-button k-button-flat k-button-flat-base"
                    [ngClass]="{
                        'k-button-sm': size === 'small',
                        'k-button-md': size === 'medium' || !size,
                        'k-button-lg': size === 'large'
                    }"
              (onClick)="onScrollButtonClick($event)"></span>
            }
            @if (hasScrollButtons.visible && hasScrollButtons.position !== 'start') {
              <span
                role="button"
                #nextScrollButton
                kendoTabStripScrollableButton
                [scrollable]="scrollable"
                [tabPosition]="tabPosition"
                [prev]="false"
                [title]="localization.get('nextTabButton')"
                (tabScroll)="tabScroll.emit($event)"
                class="k-icon-button k-button k-button-flat k-button-flat-base"
                    [ngClass]="{
                        'k-button-sm': size === 'small',
                        'k-button-md': size === 'medium' || !size,
                        'k-button-lg': size === 'large'
                    }"
              (onClick)="onScrollButtonClick($event)"></span>
            }
          </div>
        </ng-template>
        <ng-template #content>
            @for (tab of tabs; track tab; let i = $index) {
                @if (tab.selected || keepTabContent !== false) {
                    @defer (when tab.selected || keepTabContent === true; prefetch on idle) {
                        <div
                            [@state]="tab.selected && animate ? 'active' : 'inactive'"
                            [ngClass]="!this.keepTabContent || tab.selected ? 'k-tabstrip-content k-active' : 'k-tabstrip-content'"
                            [tabIndex]="0"
                            role="tabpanel"
                            [id]="getTabPanelId(i)"
                            [attr.aria-hidden]="!tab.selected"
                            [attr.aria-labelledby]="getTabId(i)"
                            [attr.aria-disabled]="tab.disabled"
                        >
                            <ng-template [ngTemplateOutlet]="tab.tabContent?.templateRef"></ng-template>
                        </div>
                    }
                }
            }
        </ng-template>
        @if (isScrollable) {
          <kendo-resize-sensor (resize)="onResize()"></kendo-resize-sensor>
        }
        @if (showLicenseWatermark) {
          <div kendoWatermarkOverlay [licenseMessage]="licenseMessage"></div>
        }
        `,
                    standalone: true,
                    imports: [LocalizedTabStripMessagesDirective, NgTemplateOutlet, NgClass, TabStripScrollableButtonComponent, TabComponent, NgStyle, ResizeSensorComponent, WatermarkOverlayComponent]
                }]
        }], ctorParameters: () => [{ type: i1.LocalizationService }, { type: i0.Renderer2 }, { type: i0.ElementRef }, { type: TabStripService }, { type: ScrollService }, { type: i0.NgZone }], propDecorators: { height: [{
                type: Input
            }], animate: [{
                type: Input
            }], tabAlignment: [{
                type: Input
            }], tabPosition: [{
                type: Input
            }], keepTabContent: [{
                type: Input
            }], closable: [{
                type: Input
            }], scrollable: [{
                type: Input
            }], size: [{
                type: Input
            }], closeIcon: [{
                type: Input
            }], closeIconClass: [{
                type: Input
            }], closeSVGIcon: [{
                type: Input
            }], showContentArea: [{
                type: Input
            }], tabSelect: [{
                type: Output
            }], tabClose: [{
                type: Output
            }], tabScroll: [{
                type: Output
            }], hostClasses: [{
                type: HostBinding,
                args: ['class.k-tabstrip']
            }, {
                type: HostBinding,
                args: ['class.k-tabstrip-md']
            }], tabsAtTop: [{
                type: HostBinding,
                args: ['class.k-tabstrip-top']
            }], tabsAtRight: [{
                type: HostBinding,
                args: ['class.k-tabstrip-right']
            }], tabsAtBottom: [{
                type: HostBinding,
                args: ['class.k-tabstrip-bottom']
            }], tabsAtLeft: [{
                type: HostBinding,
                args: ['class.k-tabstrip-left']
            }], dir: [{
                type: HostBinding,
                args: ['attr.dir']
            }], tabStripScrollable: [{
                type: HostBinding,
                args: ['class.k-tabstrip-scrollable']
            }], tabStripScrollableOverlay: [{
                type: HostBinding,
                args: ['class.k-tabstrip-scrollable-overlay']
            }], tabs: [{
                type: ContentChildren,
                args: [TabStripTabComponent]
            }], tablist: [{
                type: ViewChild,
                args: ['tablist']
            }], tabHeaderContainers: [{
                type: ViewChildren,
                args: ['tabHeaderContainer', { read: ElementRef }]
            }], prevScrollButton: [{
                type: ViewChild,
                args: ['prevScrollButton']
            }], nextScrollButton: [{
                type: ViewChild,
                args: ['nextScrollButton']
            }] } });

/**
 * Represents the custom messages component for the TabStrip.
 * It allows you to override the default messages used in the TabStrip component ([see example]({% slug rtl_layout %})).
 *
 * ```html
 * <kendo-tabstrip>
 *   <kendo-tabstrip-messages
 *     closeTitle="Close this tab"
 *     previousTabButton="Go to previous tab"
 *   </kendo-tabstrip-messages>
 * </kendo-tabstrip>
 * ```
 */
class TabStripCustomMessagesComponent extends TabStripMessages {
    service;
    constructor(service) {
        super();
        this.service = service;
    }
    get override() {
        return true;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TabStripCustomMessagesComponent, deps: [{ token: i1.LocalizationService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: TabStripCustomMessagesComponent, isStandalone: true, selector: "kendo-tabstrip-messages", providers: [
            {
                provide: TabStripMessages,
                useExisting: forwardRef(() => TabStripCustomMessagesComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TabStripCustomMessagesComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: TabStripMessages,
                            useExisting: forwardRef(() => TabStripCustomMessagesComponent)
                        }
                    ],
                    selector: 'kendo-tabstrip-messages',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1.LocalizationService }] });

/**
 * Defines a template that specifies the content of the Drawer.
 * To define the template, nest an `<ng-template>` tag with the `kendoDrawerTemplate` directive inside the `<kendo-drawer>` tag.
 * Using this template directive overrides all other templates, for example, `kendoDrawerHeaderTemplate` and `kendoDrawerItemTemplate`.
 *
 * @example
 * ```html
 * <kendo-drawer>
 *   <ng-template kendoDrawerTemplate>
 *     <div class="custom-drawer-content">
 *       <h3>Custom Drawer</h3>
 *       <ul>
 *         <li>Custom Item 1</li>
 *         <li>Custom Item 2</li>
 *       </ul>
 *     </div>
 *   </ng-template>
 * </kendo-drawer>
 * ```
 */
class DrawerTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DrawerTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: DrawerTemplateDirective, isStandalone: true, selector: "[kendoDrawerTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DrawerTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoDrawerTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }] });

/**
 * Defines a template that specifies the item content of the Drawer.
 * To define the template, nest an `<ng-template>` tag with the `kendoDrawerItemTemplate` directive inside the `<kendo-drawer>` tag.
 *
 * The `let-item` context variable provides access to the item data.
 *
 * For the Hierarchical Drawer, the `kendoDrawerItemTemplate` directive provides additional context fields:
 *
 * * `level`&mdash;A number that indicates the nesting level of the current item. Use the `let-level="level"` syntax to access the nesting level.
 * * `hasChildren`&mdash;A boolean that indicates whether the current item has nested items. Use the `let-hasChildren="hasChildren"` syntax to access the value.
 * * `isItemExpanded`&mdash;A boolean that holds information about the expanded state of the current item, which indicates whether its children are visible or not. Use the `let-isItemExpanded="isItemExpanded"` syntax to access the value of the expanded state.
 *
 * @example
 * ```html
 * <kendo-drawer>
 *   <ng-template kendoDrawerItemTemplate let-item>
 *     <span class="custom-item">{{ item.text }}</span>
 *   </ng-template>
 * </kendo-drawer>
 * ```
 */
class DrawerItemTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DrawerItemTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: DrawerItemTemplateDirective, isStandalone: true, selector: "[kendoDrawerItemTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DrawerItemTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoDrawerItemTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }] });

/**
 * Defines a template that specifies the header content of the Drawer.
 * To define the template, nest an `<ng-template>` tag with the `kendoDrawerHeaderTemplate` directive inside the `<kendo-drawer>` tag.
 *
 * @example
 * ```html
 * <kendo-drawer>
 *   <ng-template kendoDrawerHeaderTemplate>
 *     <h3>Navigation Menu</h3>
 *   </ng-template>
 * </kendo-drawer>
 * ```
 */
class DrawerHeaderTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DrawerHeaderTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: DrawerHeaderTemplateDirective, isStandalone: true, selector: "[kendoDrawerHeaderTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DrawerHeaderTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoDrawerHeaderTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }] });

/**
 * Defines a template that specifies the footer content of the Drawer.
 * To define the template, nest an `<ng-template>` tag with the `kendoDrawerFooterTemplate` directive inside the `<kendo-drawer>` tag.
 *
 * @example
 * ```html
 * <kendo-drawer>
 *   <ng-template kendoDrawerFooterTemplate>
 *     <p>© 2023 Company Name</p>
 *   </ng-template>
 * </kendo-drawer>
 * ```
 */
class DrawerFooterTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DrawerFooterTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: DrawerFooterTemplateDirective, isStandalone: true, selector: "[kendoDrawerFooterTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DrawerFooterTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoDrawerFooterTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }] });

/**
 * @hidden
 */
const defaultIsItemExpanded = (_item) => false;
/**
 * @hidden
 */
class DrawerService {
    owner;
    selectedIndices = [];
    viewData;
    focusIndex = 0;
    originalItems = [];
    idxCounter = 0;
    init() {
        this.resetViewData();
        this.originalItems = this.owner.items || [];
        const rootItems = this.originalItems.filter(item => !isPresent(item.parentId));
        this.populateViewData(rootItems);
    }
    get view() {
        return Array.from(this.viewData);
    }
    changeFocusedItem(items, keyName, renderer) {
        const currentItem = items.get(this.focusIndex);
        let nextItem;
        if (keyName === 'arrowUp') {
            if (this.focusIndex === 0) {
                nextItem = items.get(items.length - 1);
                this.focusIndex = items.length - 1;
            }
            else {
                nextItem = items.get(this.focusIndex - 1);
                this.focusIndex = this.focusIndex - 1;
            }
        }
        else if (keyName === 'arrowDown') {
            if (this.focusIndex === items.length - 1) {
                nextItem = items.get(0);
                this.focusIndex = 0;
            }
            else {
                nextItem = items.get(this.focusIndex + 1);
                this.focusIndex = this.focusIndex + 1;
            }
        }
        renderer.setAttribute(currentItem.nativeElement, 'tabindex', '-1');
        renderer.setAttribute(nextItem.nativeElement, 'tabindex', '0');
        nextItem.nativeElement.focus();
    }
    populateViewData(items, level = 0) {
        items.forEach((item) => {
            this.setSelection(item);
            const children = this.loadChildren(item);
            const isExpanded = this.isItemExpanded(item);
            this.viewData.add({
                item: item,
                index: this.idxCounter++,
                level: level,
                hasChildren: children.length > 0,
                isExpanded: isExpanded
            });
            if (children.length > 0 && isExpanded) {
                this.populateViewData(children, level + 1);
            }
        });
    }
    resetViewData() {
        this.idxCounter = 0;
        this.viewData = new Set();
    }
    loadChildren(item) {
        return this.originalItems.filter(i => {
            return isPresent(i.parentId) && (i.parentId === item.id);
        });
    }
    isItemExpanded = defaultIsItemExpanded;
    onSelect(selectedIdx) {
        this.selectedIndices = [selectedIdx];
        const drawer = this.owner;
        if (drawer.autoCollapse && !drawer.minimized) {
            drawer.toggle(false);
        }
    }
    setSelection(item) {
        if (this.selectedIndices.length === 0 && item.selected) {
            this.selectedIndices.push(this.idxCounter);
        }
    }
    resetSelection() {
        this.selectedIndices = [];
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DrawerService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DrawerService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DrawerService, decorators: [{
            type: Injectable
        }] });

/**
 * @hidden
 */
function miniExpandPush(duration, width, miniWidth) {
    return [
        style({ overflow: 'hidden', flexBasis: `${miniWidth}px` }),
        animate(`${duration}ms ease-in`, style({ flexBasis: `${width}px` }))
    ];
}
/**
 * @hidden
 */
function miniCollapsePush(duration, width, miniWidth) {
    return [
        style({ overflow: 'hidden', flexBasis: `${width}px` }),
        animate(`${duration}ms ease-in`, style({ flexBasis: `${miniWidth}px` }))
    ];
}
/**
 * @hidden
 *
 */
function miniExpandOverlay(duration, width, miniWidth) {
    return [
        style({ width: `${miniWidth}px` }),
        animate(`${duration}ms ease-in`, style({ overflow: 'hidden', width: `${width}px` }))
    ];
}
/**
 * @hidden
 */
function expandPush(duration, width) {
    return [
        style({ overflow: 'hidden', flexBasis: '0px' }),
        animate(`${duration}ms ease-in`, style({ flexBasis: `${width}px` }))
    ];
}
/**
 * @hidden
 */
function collapsePush(duration, width) {
    return [
        style({ flexBasis: `${width}px` }),
        animate(`${duration}ms ease-in`, style({ overflow: 'hidden', flexBasis: `0px` }))
    ];
}
/**
 * @hidden
 */
function expandRTLOverlay(duration) {
    return [
        style({ transform: `translateX(100%)` }),
        animate(`${duration}ms ease-in`, style({ overflow: 'hidden', transform: `translateX(0)` }))
    ];
}
/**
 * @hidden
 */
function expandOverlay(duration, position) {
    const translateDir = position !== 'end' ? `-100%` : `100%`;
    return [
        style({ transform: `translateX(${translateDir})` }),
        animate(`${duration}ms ease-in`, style({ overflow: 'hidden', transform: `translateX(0)` }))
    ];
}
/**
 * @hidden
 */
function miniCollapseOverlay(duration, width, miniWidth) {
    return [
        style({ width: `${width}px` }),
        animate(`${duration}ms ease-in`, style({ overflow: 'hidden', width: `${miniWidth}px` }))
    ];
}
/**
 * @hidden
 */
function collapseOverlay(duration, position) {
    const translateDir = position !== 'end' ? '-100%' : '100%';
    return [
        style({ transform: `translateX(0)` }),
        animate(`${duration}ms ease-in`, style({ overflow: 'hidden', transform: `translateX(${translateDir})` }))
    ];
}
/**
 * @hidden
 */
function collapseRTLOverlay(duration) {
    return [
        style({ transform: `translateX(0)` }),
        animate(`${duration}ms ease-in`, style({ overflow: 'hidden', transform: `translateX(100%)` }))
    ];
}
/**
 * @hidden
 */
function expandAnimation(settings) {
    const duration = settings.animation.duration;
    const width = settings.width;
    const miniWidth = settings.miniWidth;
    const mode = settings.mode;
    const mini = settings.mini;
    const rtl = settings.rtl;
    const position = settings.position;
    if (mini && mode === 'push') {
        return miniExpandPush(duration, width, miniWidth);
    }
    if (!mini && mode === 'push') {
        return expandPush(duration, width);
    }
    if (!mini && mode === 'overlay') {
        return rtl ? expandRTLOverlay(duration) : expandOverlay(duration, position);
    }
    if (mini && mode === 'overlay') {
        return miniExpandOverlay(duration, width, miniWidth);
    }
}
/**
 * @hidden
 */
function collapseAnimation(settings) {
    const duration = settings.animation.duration;
    const width = settings.width;
    const miniWidth = settings.miniWidth;
    const mode = settings.mode;
    const mini = settings.mini;
    const rtl = settings.rtl;
    const position = settings.position;
    if (mini && mode === 'push') {
        return miniCollapsePush(duration, width, miniWidth);
    }
    if (!mini && mode === 'push') {
        return collapsePush(duration, width);
    }
    if (!mini && mode === 'overlay') {
        return rtl ? collapseRTLOverlay(duration) : collapseOverlay(duration, position);
    }
    if (mini && mode === 'overlay') {
        return miniCollapseOverlay(duration, width, miniWidth);
    }
}

/**
 * @hidden
 */
const DRAWER_ITEM_INDEX = 'data-kendo-drawer-index';

/**
 * @hidden
 */
const DRAWER_LINK_SELECTOR = '.k-drawer-link';
/**
 * @hidden
 */
const ACTIVE_NESTED_LINK_SELECTOR = ':focus:not(.k-disabled) .k-drawer-link';
/**
 * @hidden
 */
const nestedLink = (element, selector) => element.querySelector(selector);

/**
 * @hidden
 */
class DrawerListSelectEvent extends PreventableEvent$1 {
    /**
     * The index of the selected item in the `items` collection.
     */
    index;
    /**
     * The selected Drawer item.
     */
    item;
    /**
     * The DOM event that triggered the selection.
     */
    originalEvent;
    /**
     * @hidden
     */
    constructor(args) {
        super();
        Object.assign(this, args);
    }
}

/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * @hidden
 */
class DrawerItemComponent {
    drawerService;
    element;
    renderer;
    viewItem;
    index;
    itemTemplate;
    mini;
    expanded;
    disabled;
    cssClass;
    cssStyle;
    get disabledClass() {
        return this.item.disabled;
    }
    get selectedClass() {
        return this.drawerService.selectedIndices.indexOf(this.index) >= 0;
    }
    get label() {
        return this.item.text ? this.item.text : null;
    }
    arrowUpIcon = chevronUpIcon;
    arrowDownIcon = chevronDownIcon;
    constructor(drawerService, element, renderer) {
        this.drawerService = drawerService;
        this.element = element;
        this.renderer = renderer;
    }
    ngAfterViewInit() {
        const elem = this.element.nativeElement;
        const link = nestedLink(elem, DRAWER_LINK_SELECTOR);
        if (link) {
            this.renderer.removeAttribute(link, 'tabindex');
        }
    }
    get iconClasses() {
        if (this.item.icon) {
            const stripIcon = this.item.icon.replace('k-i-', '');
            return `${stripIcon}`;
        }
    }
    get innerCssClasses() {
        if (this.item.iconClass && this.item.icon) {
            return `${this.item.iconClass}`;
        }
    }
    get customIconClasses() {
        if (!this.item.icon && this.item.iconClass) {
            return this.item.iconClass;
        }
    }
    get item() {
        return this.viewItem.item;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DrawerItemComponent, deps: [{ token: DrawerService }, { token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: DrawerItemComponent, isStandalone: true, selector: "[kendoDrawerItem]", inputs: { viewItem: "viewItem", index: "index", itemTemplate: "itemTemplate", mini: "mini", expanded: "expanded", disabled: "disabled", cssClass: "cssClass", cssStyle: "cssStyle" }, host: { properties: { "attr.aria-disabled": "this.disabledClass", "class.k-disabled": "this.disabledClass", "attr.aria-current": "this.selectedClass", "class.k-selected": "this.selectedClass", "attr.aria-label": "this.label" } }, ngImport: i0, template: `
        @if (itemTemplate) {
          <ng-template
            [ngTemplateOutlet]="itemTemplate"
            [ngTemplateOutletContext]="{
                $implicit: item,
                isItemExpanded: viewItem.isExpanded,
                hasChildren: viewItem.hasChildren,
                level: viewItem.level
            }">
          </ng-template>
        } @else {
          @if (expanded) {
            @if (item.icon || item.iconClass || item.svgIcon) {
              <kendo-icon-wrapper
                [name]="iconClasses"
                [customFontClass]="customIconClasses"
                [svgIcon]="item.svgIcon"
                [innerCssClass]="innerCssClasses"
                >
              </kendo-icon-wrapper>
            }
            <span class="k-item-text">{{ item.text }}</span>
            @if (viewItem.hasChildren) {
              <span class="k-spacer"></span>
            }
            @if (viewItem.hasChildren) {
              <kendo-icon-wrapper
                [name]="viewItem.isExpanded ? 'arrow-chevron-up' : 'arrow-chevron-down'"
                innerCssClass="k-drawer-toggle"
                [svgIcon]="viewItem.isExpanded ? arrowUpIcon : arrowDownIcon"
                >
              </kendo-icon-wrapper>
            }
          }
          @if (mini && !expanded) {
            @if (item.icon || item.iconClass || item.svgIcon) {
              <kendo-icon-wrapper
                [name]="iconClasses"
                [customFontClass]="customIconClasses"
                [svgIcon]="item.svgIcon"
                [innerCssClass]="innerCssClasses"
                >
              </kendo-icon-wrapper>
            }
          }
        }
        
        `, isInline: true, dependencies: [{ kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DrawerItemComponent, decorators: [{
            type: Component,
            args: [{
                    // eslint-disable-next-line @angular-eslint/component-selector
                    selector: '[kendoDrawerItem]',
                    template: `
        @if (itemTemplate) {
          <ng-template
            [ngTemplateOutlet]="itemTemplate"
            [ngTemplateOutletContext]="{
                $implicit: item,
                isItemExpanded: viewItem.isExpanded,
                hasChildren: viewItem.hasChildren,
                level: viewItem.level
            }">
          </ng-template>
        } @else {
          @if (expanded) {
            @if (item.icon || item.iconClass || item.svgIcon) {
              <kendo-icon-wrapper
                [name]="iconClasses"
                [customFontClass]="customIconClasses"
                [svgIcon]="item.svgIcon"
                [innerCssClass]="innerCssClasses"
                >
              </kendo-icon-wrapper>
            }
            <span class="k-item-text">{{ item.text }}</span>
            @if (viewItem.hasChildren) {
              <span class="k-spacer"></span>
            }
            @if (viewItem.hasChildren) {
              <kendo-icon-wrapper
                [name]="viewItem.isExpanded ? 'arrow-chevron-up' : 'arrow-chevron-down'"
                innerCssClass="k-drawer-toggle"
                [svgIcon]="viewItem.isExpanded ? arrowUpIcon : arrowDownIcon"
                >
              </kendo-icon-wrapper>
            }
          }
          @if (mini && !expanded) {
            @if (item.icon || item.iconClass || item.svgIcon) {
              <kendo-icon-wrapper
                [name]="iconClasses"
                [customFontClass]="customIconClasses"
                [svgIcon]="item.svgIcon"
                [innerCssClass]="innerCssClasses"
                >
              </kendo-icon-wrapper>
            }
          }
        }
        
        `,
                    standalone: true,
                    imports: [NgTemplateOutlet, IconWrapperComponent]
                }]
        }], ctorParameters: () => [{ type: DrawerService }, { type: i0.ElementRef }, { type: i0.Renderer2 }], propDecorators: { viewItem: [{
                type: Input
            }], index: [{
                type: Input
            }], itemTemplate: [{
                type: Input
            }], mini: [{
                type: Input
            }], expanded: [{
                type: Input
            }], disabled: [{
                type: Input
            }], cssClass: [{
                type: Input
            }], cssStyle: [{
                type: Input
            }], disabledClass: [{
                type: HostBinding,
                args: ['attr.aria-disabled']
            }, {
                type: HostBinding,
                args: ['class.k-disabled']
            }], selectedClass: [{
                type: HostBinding,
                args: ['attr.aria-current']
            }, {
                type: HostBinding,
                args: ['class.k-selected']
            }], label: [{
                type: HostBinding,
                args: ['attr.aria-label']
            }] } });

/**
 * @hidden
 */
class DrawerListComponent {
    drawerService;
    renderer;
    ngZone;
    element;
    itemTemplate;
    mini;
    expanded;
    view = [];
    select = new EventEmitter();
    items;
    subscriptions = new Subscription();
    constructor(drawerService, renderer, ngZone, element) {
        this.drawerService = drawerService;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.element = element;
    }
    ngOnInit() {
        this.initDomEvents();
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    identifyItem(_index, viewItem) {
        return viewItem.item.id ?? viewItem.index;
    }
    initDomEvents() {
        if (!this.element) {
            return;
        }
        this.ngZone.runOutsideAngular(() => {
            const nativeElement = this.element.nativeElement;
            this.subscriptions.add(this.renderer.listen(nativeElement, 'click', this.clickHandler.bind(this)));
            this.subscriptions.add(this.renderer.listen(nativeElement, 'keydown', (e) => {
                const code = normalizeKeys(e);
                const isEnterOrSpace = code === Keys.Enter || code === Keys.Space;
                const isArrowUpOrDown = code === Keys.ArrowUp || code === Keys.ArrowDown;
                if (isEnterOrSpace) {
                    this.onEnterOrSpaceKeyDown(e);
                }
                else if (isArrowUpOrDown) {
                    if (e.target.classList.contains('k-drawer-item')) {
                        e.preventDefault();
                        const keyName = code === Keys.ArrowUp ? 'arrowUp' : 'arrowDown';
                        this.drawerService.changeFocusedItem(this.items, keyName, this.renderer);
                    }
                }
            }));
        });
    }
    clickHandler(e) {
        const viewItemIdx = this.getDrawerItemIndex(e.target);
        const viewItem = this.view[viewItemIdx];
        const filterItems = this.view.filter(items => !items.item.separator);
        const selectedItemIndex = filterItems.findIndex(item => item.index === viewItemIdx);
        if (!viewItem) {
            return;
        }
        if (viewItem.item.disabled) {
            e.preventDefault();
            return;
        }
        const args = {
            index: viewItem.index,
            item: viewItem.item,
            originalEvent: e
        };
        this.ngZone.run(() => {
            const event = new DrawerListSelectEvent(args);
            this.select.emit(event);
            if (!event.isDefaultPrevented()) {
                this.drawerService.focusIndex = selectedItemIndex;
                this.drawerService.onSelect(viewItemIdx);
                this.drawerService.init();
                this.view = this.drawerService.view;
            }
        });
    }
    onEnterOrSpaceKeyDown(e) {
        this.clickHandler(e);
        const link = nestedLink(this.element.nativeElement, ACTIVE_NESTED_LINK_SELECTOR);
        if (link) {
            link.click();
        }
        return false;
    }
    getDrawerItemIndex(target) {
        const item = closestItem(target, DRAWER_ITEM_INDEX, this.element.nativeElement);
        if (item) {
            return itemIndex(item, DRAWER_ITEM_INDEX);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DrawerListComponent, deps: [{ token: DrawerService }, { token: i0.Renderer2 }, { token: i0.NgZone }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: DrawerListComponent, isStandalone: true, selector: "[kendoDrawerList]", inputs: { itemTemplate: "itemTemplate", mini: "mini", expanded: "expanded", view: "view" }, outputs: { select: "select" }, viewQueries: [{ propertyName: "items", predicate: DrawerItemComponent, descendants: true, read: ElementRef }], ngImport: i0, template: "\n        @for (v of view; track identifyItem(idx, v); let idx = $index) {\n          @if (!v.item.separator) {\n            <li kendoDrawerItem\n              class=\"k-drawer-item {{expanded ? ' k-level-' + v.level : ''}}\"\n              role=\"menuitem\"\n              [viewItem]=\"v\"\n              [index]=\"idx\"\n              [mini]=\"mini\"\n              [expanded]=\"expanded\"\n              [itemTemplate]=\"itemTemplate\"\n              [attr.data-kendo-drawer-index]=\"v.index\"\n              [ngClass]=\"v.item.cssClass\"\n              [ngStyle]=\"v.item.cssStyle\"\n              [tabindex]=\"v.index === 0 ? '0' : '-1'\">\n            </li>\n          }\n          @if (v.item.separator) {\n            <li\n              role=\"separator\"\n              class=\"k-drawer-item k-drawer-separator\"\n              [ngClass]=\"v.item.cssClass\"\n              [ngStyle]=\"v.item.cssStyle\">\n              &nbsp;\n            </li>\n          }\n        }\n        ", isInline: true, dependencies: [{ kind: "component", type: DrawerItemComponent, selector: "[kendoDrawerItem]", inputs: ["viewItem", "index", "itemTemplate", "mini", "expanded", "disabled", "cssClass", "cssStyle"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DrawerListComponent, decorators: [{
            type: Component,
            args: [{
                    // eslint-disable-next-line @angular-eslint/component-selector
                    selector: '[kendoDrawerList]',
                    template: `
        @for (v of view; track identifyItem(idx, v); let idx = $index) {
          @if (!v.item.separator) {
            <li kendoDrawerItem
              class="k-drawer-item {{expanded ? ' k-level-' + v.level : ''}}"
              role="menuitem"
              [viewItem]="v"
              [index]="idx"
              [mini]="mini"
              [expanded]="expanded"
              [itemTemplate]="itemTemplate"
              [attr.${DRAWER_ITEM_INDEX}]="v.index"
              [ngClass]="v.item.cssClass"
              [ngStyle]="v.item.cssStyle"
              [tabindex]="v.index === 0 ? '0' : '-1'">
            </li>
          }
          @if (v.item.separator) {
            <li
              role="separator"
              class="k-drawer-item k-drawer-separator"
              [ngClass]="v.item.cssClass"
              [ngStyle]="v.item.cssStyle">
              &nbsp;
            </li>
          }
        }
        `,
                    standalone: true,
                    imports: [DrawerItemComponent, NgClass, NgStyle]
                }]
        }], ctorParameters: () => [{ type: DrawerService }, { type: i0.Renderer2 }, { type: i0.NgZone }, { type: i0.ElementRef }], propDecorators: { itemTemplate: [{
                type: Input
            }], mini: [{
                type: Input
            }], expanded: [{
                type: Input
            }], view: [{
                type: Input
            }], select: [{
                type: Output
            }], items: [{
                type: ViewChildren,
                args: [DrawerItemComponent, { read: ElementRef }]
            }] } });

/* eslint-disable @typescript-eslint/no-explicit-any */
const DEFAULT_ANIMATION = { type: 'slide', duration: 200 };
/**
 * Represents the [Kendo UI Drawer component for Angular]({% slug overview_drawer %}).
 * Provides a dismissible or permanently visible panel for navigation in responsive web applications.
 *
 * @example
 * ```typescript
 * @Component({
 *   selector: 'my-app',
 *   template: `
 *     <kendo-drawer-container>
 *       <kendo-drawer #drawer
 *         [items]="items"
 *         mode="overlay"
 *         [(expanded)]="expanded">
 *       </kendo-drawer>
 *       <kendo-drawer-content>
 *         <button class="k-button" (click)="drawer.toggle()">Open the Drawer</button>
 *       </kendo-drawer-content>
 *     </kendo-drawer-container>
 *   `
 * })
 * class AppComponent {
 *   public expanded = false;
 *   public items = [
 *     { text: 'Inbox', icon: 'inbox' },
 *     { text: 'Notifications', icon: 'bell' }
 *   ];
 * }
 * ```
 */
class DrawerComponent {
    element;
    builder;
    localizationService;
    drawerService;
    hostClasses = true;
    get startPositionClass() {
        return this.position === 'start';
    }
    get endPositionClass() {
        return this.position === 'end';
    }
    get overlayTransofrmStyles() {
        if (this.mode === 'push') {
            return;
        }
        if (this.expanded || this.minimized) {
            return `translateX(0px)`;
        }
        return `translateX(-100%)`;
    }
    get flexStyles() {
        if (this.mode === 'overlay') {
            return;
        }
        if (!this.expanded && !this.minimized) {
            return 0;
        }
        return this.drawerWidth;
    }
    /**
     * Specifies the mode in which the Drawer displays.
     *
     * @default 'overlay'
     */
    mode = 'overlay';
    /**
     * Specifies the position of the Drawer
     * ([see example]({% slug positioning_drawer %})).
     *
     * @default 'start'
     */
    position = 'start';
    /**
     * Enables the mini (compact) view of the Drawer which displays when the component is collapsed
     * ([see example]({% slug expandmodespositions_drawer %}#toc-mini-view)).
     *
     * @default false
     */
    mini = false;
    /**
     * Specifies the state of the Drawer.
     *
     * @default false
     */
    expanded = false;
    /**
     * Defines the width of the Drawer when it is expanded.
     *
     * @default 240
     */
    width = 240;
    /**
     * Defines the width of the Drawer when the mini view is enabled and the component is collapsed.
     *
     * @default 50
     */
    miniWidth = 50;
    /**
     * Specifies if the Drawer automatically collapses when an item or the overlay is clicked.
     *
     * @default true
     */
    autoCollapse = true;
    /**
     * Defines the collection of items that render in the Drawer.
     *
     * @default []
     */
    items = [];
    /**
     * Defines a callback function which determines if an item should be expanded.
     * This is useful for hierarchical data structures where the expansion state of an item depends on its parent or other items.
     */
    set isItemExpanded(fn) {
        if (isDevMode && isPresent(fn) && typeof fn !== 'function') {
            throw new Error(`isItemExpanded must be a function, but received ${JSON.stringify(fn)}.`);
        }
        this.drawerService.isItemExpanded = fn;
    }
    get isItemExpanded() {
        return this.drawerService.isItemExpanded;
    }
    /**
     * @hidden
     */
    direction;
    /**
     * Specifies the animation settings of the Drawer
     * ([see example]({% slug interaction_drawer %}#toc-toggling-between-states)).
     *
     * @default { type: 'slide', duration: 200 }
     */
    animation = DEFAULT_ANIMATION;
    /**
     * Fires when the Drawer is expanded and its animation is complete.
     */
    expand = new EventEmitter();
    /**
     * Fires when the Drawer is collapsed and its animation is complete.
     */
    collapse = new EventEmitter();
    /**
     * Fires when an item in the Drawer is selected.
     * This event is preventable.
     */
    select = new EventEmitter();
    /**
     * Fires when the `expanded` property of the component is updated.
     * Used to provide a two-way binding for the `expanded` property.
     */
    expandedChange = new EventEmitter();
    /**
     * @hidden
     */
    drawerTemplate;
    /**
     * @hidden
     */
    footerTemplate;
    /**
     * @hidden
     */
    headerTemplate;
    /**
     * @hidden
     */
    itemTemplate;
    /**
     * @hidden
     */
    showLicenseWatermark = false;
    /**
     * @hidden
     */
    licenseMessage;
    viewItems;
    animationEnd = new EventEmitter();
    dynamicRTLSubscription;
    rtl = false;
    constructor(element, builder, localizationService, drawerService) {
        this.element = element;
        this.builder = builder;
        this.localizationService = localizationService;
        this.drawerService = drawerService;
        const isValid = validatePackage(packageMetadata);
        this.licenseMessage = getLicenseMessage(packageMetadata);
        this.showLicenseWatermark = shouldShowValidationUI(isValid);
        this.dynamicRTLSubscription = this.localizationService.changes.subscribe(({ rtl }) => {
            this.rtl = rtl;
            this.direction = this.rtl ? 'rtl' : 'ltr';
        });
        this.drawerService.owner = this;
    }
    ngOnChanges(changes) {
        if (changes && changes['items']) {
            this.drawerService.resetSelection();
            this.drawerService.init();
            this.viewItems = this.drawerService.view;
        }
    }
    ngOnDestroy() {
        if (this.dynamicRTLSubscription) {
            this.dynamicRTLSubscription.unsubscribe();
        }
    }
    /**
     * @hidden
     */
    get minimized() {
        return this.mini && !this.expanded;
    }
    /**
     * @hidden
     */
    get drawerWidth() {
        return this.minimized ? this.miniWidth : this.width;
    }
    /**
     * Toggles the visibility of the Drawer.
     * If the `expanded` parameter is not provided, the Drawer will toggle between expanded and collapsed states.
     *
     * @param expanded Specifies if the Drawer will be expanded or collapsed.
     */
    toggle(expanded) {
        const previous = this.expanded;
        const current = isPresent(expanded) ? expanded : !previous;
        if (current === previous) {
            return;
        }
        if (current === true) {
            this.setExpanded(true);
        }
        else if (current === false && !this.animation) {
            this.setExpanded(false);
        }
        if (this.animation) {
            this.animationEnd.pipe(take(1))
                .subscribe(() => { this.onAnimationEnd(current); });
            this.animate(current);
        }
        else {
            this[current ? 'expand' : 'collapse'].emit();
        }
    }
    /**
     * @hidden
     */
    onSelect(e) {
        this.select.emit(Object.assign(e, { sender: this }));
    }
    onAnimationEnd(currentExpanded) {
        if (currentExpanded) {
            this.expand.emit();
        }
        else {
            this.setExpanded(false);
            this.collapse.emit();
        }
    }
    setExpanded(value) {
        this.expanded = value;
        this.expandedChange.emit(value);
    }
    animate(expanded) {
        const settings = {
            mode: this.mode,
            mini: this.mini,
            miniWidth: this.miniWidth,
            width: this.width,
            rtl: this.rtl,
            position: this.position,
            animation: (typeof this.animation !== 'boolean') ? this.animation : DEFAULT_ANIMATION
        };
        const animation = expanded ? expandAnimation(settings) : collapseAnimation(settings);
        const player = this.createPlayer(animation, this.element.nativeElement);
        player.play();
    }
    createPlayer(animation, animatedElement) {
        const factory = this.builder.build(animation);
        let player = factory.create(animatedElement);
        player.onDone(() => {
            if (player) {
                this.animationEnd.emit();
                player.destroy();
                player = null;
            }
        });
        return player;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DrawerComponent, deps: [{ token: i0.ElementRef }, { token: i1$2.AnimationBuilder }, { token: i1.LocalizationService }, { token: DrawerService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: DrawerComponent, isStandalone: true, selector: "kendo-drawer", inputs: { mode: "mode", position: "position", mini: "mini", expanded: "expanded", width: "width", miniWidth: "miniWidth", autoCollapse: "autoCollapse", items: "items", isItemExpanded: "isItemExpanded", animation: "animation" }, outputs: { expand: "expand", collapse: "collapse", select: "select", expandedChange: "expandedChange" }, host: { properties: { "class.k-drawer": "this.hostClasses", "class.k-drawer-start": "this.startPositionClass", "class.k-drawer-end": "this.endPositionClass", "style.transform": "this.overlayTransofrmStyles", "style.flexBasis.px": "this.flexStyles", "attr.dir": "this.direction" } }, providers: [
            LocalizationService,
            DrawerService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.drawer'
            }
        ], queries: [{ propertyName: "drawerTemplate", first: true, predicate: DrawerTemplateDirective, descendants: true }, { propertyName: "footerTemplate", first: true, predicate: DrawerFooterTemplateDirective, descendants: true }, { propertyName: "headerTemplate", first: true, predicate: DrawerHeaderTemplateDirective, descendants: true }, { propertyName: "itemTemplate", first: true, predicate: DrawerItemTemplateDirective, descendants: true }], exportAs: ["kendoDrawer"], usesOnChanges: true, ngImport: i0, template: `
        @if (expanded || mini) {
          <div class="k-drawer-wrapper" [style.width.px]="drawerWidth">
            @if (!drawerTemplate) {
              @if (headerTemplate) {
                <ng-template
                  [ngTemplateOutlet]="headerTemplate?.templateRef">
                </ng-template>
              }
              <ul kendoDrawerList
                role="menubar"
                aria-orientation="vertical"
                (select)="onSelect($event)"
                [mini]="mini"
                [expanded]="expanded"
                [view]="viewItems"
                [itemTemplate]="itemTemplate?.templateRef"
                class="k-drawer-items">
              </ul>
              @if (footerTemplate) {
                <ng-template
                  [ngTemplateOutlet]="footerTemplate?.templateRef">
                </ng-template>
              }
            }
            @if (drawerTemplate) {
              <ng-template
                [ngTemplateOutlet]="drawerTemplate?.templateRef">
              </ng-template>
            }
          </div>
        }
        
        @if (showLicenseWatermark) {
          <div kendoWatermarkOverlay [licenseMessage]="licenseMessage"></div>
        }
        `, isInline: true, dependencies: [{ kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: DrawerListComponent, selector: "[kendoDrawerList]", inputs: ["itemTemplate", "mini", "expanded", "view"], outputs: ["select"] }, { kind: "component", type: WatermarkOverlayComponent, selector: "div[kendoWatermarkOverlay]", inputs: ["licenseMessage"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DrawerComponent, decorators: [{
            type: Component,
            args: [{
                    exportAs: 'kendoDrawer',
                    providers: [
                        LocalizationService,
                        DrawerService,
                        {
                            provide: L10N_PREFIX,
                            useValue: 'kendo.drawer'
                        }
                    ],
                    selector: 'kendo-drawer',
                    template: `
        @if (expanded || mini) {
          <div class="k-drawer-wrapper" [style.width.px]="drawerWidth">
            @if (!drawerTemplate) {
              @if (headerTemplate) {
                <ng-template
                  [ngTemplateOutlet]="headerTemplate?.templateRef">
                </ng-template>
              }
              <ul kendoDrawerList
                role="menubar"
                aria-orientation="vertical"
                (select)="onSelect($event)"
                [mini]="mini"
                [expanded]="expanded"
                [view]="viewItems"
                [itemTemplate]="itemTemplate?.templateRef"
                class="k-drawer-items">
              </ul>
              @if (footerTemplate) {
                <ng-template
                  [ngTemplateOutlet]="footerTemplate?.templateRef">
                </ng-template>
              }
            }
            @if (drawerTemplate) {
              <ng-template
                [ngTemplateOutlet]="drawerTemplate?.templateRef">
              </ng-template>
            }
          </div>
        }
        
        @if (showLicenseWatermark) {
          <div kendoWatermarkOverlay [licenseMessage]="licenseMessage"></div>
        }
        `,
                    standalone: true,
                    imports: [NgTemplateOutlet, DrawerListComponent, WatermarkOverlayComponent]
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i1$2.AnimationBuilder }, { type: i1.LocalizationService }, { type: DrawerService }], propDecorators: { hostClasses: [{
                type: HostBinding,
                args: ['class.k-drawer']
            }], startPositionClass: [{
                type: HostBinding,
                args: ['class.k-drawer-start']
            }], endPositionClass: [{
                type: HostBinding,
                args: ['class.k-drawer-end']
            }], overlayTransofrmStyles: [{
                type: HostBinding,
                args: ['style.transform']
            }], flexStyles: [{
                type: HostBinding,
                args: ['style.flexBasis.px']
            }], mode: [{
                type: Input
            }], position: [{
                type: Input
            }], mini: [{
                type: Input
            }], expanded: [{
                type: Input
            }], width: [{
                type: Input
            }], miniWidth: [{
                type: Input
            }], autoCollapse: [{
                type: Input
            }], items: [{
                type: Input
            }], isItemExpanded: [{
                type: Input
            }], direction: [{
                type: HostBinding,
                args: ['attr.dir']
            }], animation: [{
                type: Input
            }], expand: [{
                type: Output
            }], collapse: [{
                type: Output
            }], select: [{
                type: Output
            }], expandedChange: [{
                type: Output
            }], drawerTemplate: [{
                type: ContentChild,
                args: [DrawerTemplateDirective]
            }], footerTemplate: [{
                type: ContentChild,
                args: [DrawerFooterTemplateDirective]
            }], headerTemplate: [{
                type: ContentChild,
                args: [DrawerHeaderTemplateDirective]
            }], itemTemplate: [{
                type: ContentChild,
                args: [DrawerItemTemplateDirective]
            }] } });

/**
 * Serves as a container for the [Drawer component]({% slug overview_drawer %}) and its content.
 *
 * @example
 * ```html
 * <kendo-drawer-container>
 *   <kendo-drawer [items]="items"></kendo-drawer>
 *   <kendo-drawer-content>
 *     <h1>Main Content</h1>
 *   </kendo-drawer-content>
 * </kendo-drawer-container>
 * ```
 * @remarks
 * Supported children components are: {@link DrawerComponent}, {@link DrawerContentComponent}.
 */
class DrawerContainerComponent {
    localizationService;
    get hostClass() {
        return true;
    }
    get overlayClass() {
        return this.drawer.mode === 'overlay';
    }
    get miniClass() {
        return this.drawer.mini && !this.drawer.expanded;
    }
    get pushClass() {
        return this.drawer.mode === 'push';
    }
    get isExpandedClass() {
        return this.drawer.expanded;
    }
    /**
     * @hidden
     */
    direction;
    /**
     * @hidden
     */
    drawer;
    dynamicRTLSubscription;
    rtl = false;
    constructor(localizationService) {
        this.localizationService = localizationService;
        this.dynamicRTLSubscription = this.localizationService.changes.subscribe(({ rtl }) => {
            this.rtl = rtl;
            this.direction = this.rtl ? 'rtl' : 'ltr';
        });
    }
    ngOnDestroy() {
        if (this.dynamicRTLSubscription) {
            this.dynamicRTLSubscription.unsubscribe();
        }
    }
    /**
     * @hidden
     */
    get overlay() {
        return isPresent(this.drawer) &&
            this.drawer.expanded &&
            this.drawer.mode === 'overlay';
    }
    /**
     * @hidden
     */
    closeDrawer() {
        if (this.overlay && this.drawer.autoCollapse) {
            this.drawer.toggle(false);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DrawerContainerComponent, deps: [{ token: i1.LocalizationService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: DrawerContainerComponent, isStandalone: true, selector: "kendo-drawer-container", host: { properties: { "class.k-drawer-container": "this.hostClass", "class.k-drawer-overlay": "this.overlayClass", "class.k-drawer-mini": "this.miniClass", "class.k-drawer-push": "this.pushClass", "class.k-drawer-expanded": "this.isExpandedClass", "attr.dir": "this.direction" } }, providers: [
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.drawer.container'
            }
        ], queries: [{ propertyName: "drawer", first: true, predicate: DrawerComponent, descendants: true }], ngImport: i0, template: `
        @if (overlay) {
          <div class="k-overlay" (click)="closeDrawer()"></div>
        }
        <ng-content></ng-content>
        `, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DrawerContainerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-drawer-container',
                    providers: [
                        LocalizationService,
                        {
                            provide: L10N_PREFIX,
                            useValue: 'kendo.drawer.container'
                        }
                    ],
                    template: `
        @if (overlay) {
          <div class="k-overlay" (click)="closeDrawer()"></div>
        }
        <ng-content></ng-content>
        `,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1.LocalizationService }], propDecorators: { hostClass: [{
                type: HostBinding,
                args: ['class.k-drawer-container']
            }], overlayClass: [{
                type: HostBinding,
                args: ['class.k-drawer-overlay']
            }], miniClass: [{
                type: HostBinding,
                args: ['class.k-drawer-mini']
            }], pushClass: [{
                type: HostBinding,
                args: ['class.k-drawer-push']
            }], isExpandedClass: [{
                type: HostBinding,
                args: ['class.k-drawer-expanded']
            }], direction: [{
                type: HostBinding,
                args: ['attr.dir']
            }], drawer: [{
                type: ContentChild,
                args: [DrawerComponent]
            }] } });

/**
 * Defines the content of the Drawer component.
 *
 * @example
 * ```html
 * <kendo-drawer-content>
 *   <h1>Main Content Area</h1>
 *   <p>Your application content goes here.</p>
 * </kendo-drawer-content>
 * ```
 */
class DrawerContentComponent {
    hostClasses = true;
    constructor() { }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DrawerContentComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: DrawerContentComponent, isStandalone: true, selector: "kendo-drawer-content", host: { properties: { "class.k-drawer-content": "this.hostClasses" } }, ngImport: i0, template: `
        <ng-content></ng-content>
    `, isInline: true, encapsulation: i0.ViewEncapsulation.None });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DrawerContentComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-drawer-content',
                    template: `
        <ng-content></ng-content>
    `,
                    encapsulation: ViewEncapsulation.None,
                    standalone: true
                }]
        }], ctorParameters: () => [], propDecorators: { hostClasses: [{
                type: HostBinding,
                args: ['class.k-drawer-content']
            }] } });

/**
 * Defines the arguments for the `select` event of the Drawer.
 */
class DrawerSelectEvent extends PreventableEvent$1 {
    /**
     * Defines the index of the selected item in the `items` collection.
     */
    index;
    /**
     * Defines the selected Drawer item.
     */
    item;
    /**
     * Defines the DOM event that triggered the selection.
     */
    originalEvent;
    /**
     * Defines the Drawer that triggered the event.
     */
    sender;
    /**
     * @hidden
     */
    constructor(args) {
        super();
        Object.assign(this, args);
    }
}

/**
 * Use this template to define custom content for the entire step.
 * To define the template, nest an `<ng-template>` tag
 * with the `kendoStepperStepTemplate` directive inside the `<kendo-stepper>` tag.
 *
 * @example
 * ```html
 * <kendo-stepper>
 *   <ng-template kendoStepperStepTemplate let-step="step" let-index="index">
 *     <div class="custom-step">
 *       <span>{{ step.label }}</span>
 *     </div>
 *   </ng-template>
 * </kendo-stepper>
 * ```
 */
class StepperStepTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: StepperStepTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: StepperStepTemplateDirective, isStandalone: true, selector: "[kendoStepperStepTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: StepperStepTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoStepperStepTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }] });

/**
 * Use this template to define custom content for the step label.
 * To define the template, nest an `<ng-template>` tag
 * with the `kendoStepperLabelTemplate` directive inside the `<kendo-stepper>` tag.
 *
 * @example
 * ```html
 * <kendo-stepper>
 *   <ng-template kendoStepperLabelTemplate let-step="step" let-index="index">
 *     <span class="custom-label">{{ step.label }}</span>
 *   </ng-template>
 * </kendo-stepper>
 * ```
 */
class StepperLabelTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: StepperLabelTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: StepperLabelTemplateDirective, isStandalone: true, selector: "[kendoStepperLabelTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: StepperLabelTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoStepperLabelTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }] });

/**
 * Use this template to define custom content for the step indicator.
 * To define the template, nest an `<ng-template>` tag
 * with the `kendoStepperIndicatorTemplate` directive inside the `<kendo-stepper>` tag.
 *
 * @example
 * ```html
 * <kendo-stepper>
 *   <ng-template kendoStepperIndicatorTemplate let-step="step" let-index="index">
 *     <span>{{ index + 1 }}</span>
 *   </ng-template>
 * </kendo-stepper>
 * ```
 */
class StepperIndicatorTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: StepperIndicatorTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: StepperIndicatorTemplateDirective, isStandalone: true, selector: "[kendoStepperIndicatorTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: StepperIndicatorTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoStepperIndicatorTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }] });

const DEFAULT_CURRENT_STEP = 0;
const handlers = {};
handlers[Keys.ArrowLeft] = 'left';
handlers[Keys.ArrowRight] = 'right';
handlers[Keys.ArrowUp] = 'up';
handlers[Keys.ArrowDown] = 'down';
handlers[Keys.Home] = 'home';
handlers[Keys.End] = 'end';
handlers[Keys.Enter] = 'enter';
handlers[Keys.NumpadEnter] = 'enter';
handlers[Keys.Space] = 'enter';
const handlersRTL = Object.assign({}, handlers);
handlersRTL[Keys.ArrowLeft] = 'right';
handlersRTL[Keys.ArrowRight] = 'left';
// error NG3003: One or more import cycles would need to be created to compile this component,
// which is not supported by the current compiler configuration
/**
 * @hidden
 */
let StepperActivateEvent$1 = class StepperActivateEvent extends PreventableEvent$1 {
    /**
     * Specifies the index of the activated step in the `steps` collection.
     */
    index;
    /**
     * Specifies the activated step.
     */
    step;
    /**
     * Specifies the DOM event that triggered the step activation.
     */
    originalEvent;
    /**
     * Specifies the Stepper that triggered the event.
     */
    sender;
    /**
     * @hidden
     */
    constructor(args) {
        super();
        Object.assign(this, args);
    }
};
/**
 * @hidden
 */
class StepperService {
    localization;
    ngZone;
    changeDetector;
    owner;
    currentStep = DEFAULT_CURRENT_STEP;
    focusedStep;
    triggerValidation = new EventEmitter();
    focusedStepChange = new EventEmitter();
    get handlers() {
        return this.localization.rtl ? handlersRTL : handlers;
    }
    constructor(localization, ngZone, changeDetector) {
        this.localization = localization;
        this.ngZone = ngZone;
        this.changeDetector = changeDetector;
    }
    emit(event, eventArgs) {
        const stepper = this.owner;
        if (hasObservers(stepper[event])) {
            stepper[event].emit(eventArgs);
        }
        return eventArgs.isDefaultPrevented();
    }
    onActivate(currentIdx, originalEvent) {
        const eventArgs = new StepperActivateEvent$1({
            index: currentIdx,
            step: this.owner.steps[currentIdx],
            originalEvent: originalEvent,
            sender: this.owner
        });
        this.ngZone.run(() => {
            if (!this.emit('activate', eventArgs)) {
                this.currentStep = currentIdx;
                this.owner['currentStepChange'].emit(currentIdx);
                this.changeDetector.detectChanges();
            }
        });
    }
    validateSteps() {
        this.triggerValidation.emit();
    }
    keydown(e) {
        const current = this.focusedStep || this.currentStep;
        // on some keyboards arrow keys, PageUp/Down, and Home/End are mapped to Numpad keys
        const code = normalizeKeys(e);
        const handler = this.handlers[code];
        if (!isPresent(current)) {
            return;
        }
        if (handler) {
            e.preventDefault();
            this[handler](e);
        }
    }
    left() {
        if (!this.isHorizontal) {
            return;
        }
        this.focusPrevStep();
    }
    right() {
        if (!this.isHorizontal) {
            return;
        }
        this.focusNextStep();
    }
    up() {
        if (this.isHorizontal) {
            return;
        }
        this.focusPrevStep();
    }
    down() {
        if (this.isHorizontal) {
            return;
        }
        this.focusNextStep();
    }
    home() {
        this.focusedStep = 0;
        this.focusedStepChange.emit();
    }
    end() {
        this.focusedStep = this.owner.steps.length - 1;
        this.focusedStepChange.emit();
    }
    enter(event) {
        if (this.focusedStep === this.currentStep) {
            return;
        }
        if (this.isStepDisabled(this.focusedStep)) {
            return;
        }
        if (this.owner.linear && this.isPrevOrNextStep(this.focusedStep) === false) {
            return;
        }
        this.onActivate(this.focusedStep, event);
    }
    focus(focusedIdx) {
        this.focusedStep = focusedIdx;
    }
    focusNextStep() {
        if (this.focusedStep < this.owner.steps.length) {
            this.focusedStep += 1;
            this.focusedStepChange.emit();
        }
    }
    focusPrevStep() {
        if (this.focusedStep > 0) {
            this.focusedStep -= 1;
            this.focusedStepChange.emit();
        }
    }
    isStepDisabled(index) {
        return this.owner.steps[index].disabled;
    }
    isPrevOrNextStep(index) {
        return index === this.currentStep + 1 || index === this.currentStep - 1;
    }
    get isHorizontal() {
        return this.owner.orientation === 'horizontal';
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: StepperService, deps: [{ token: i1.LocalizationService }, { token: i0.NgZone }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: StepperService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: StepperService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: i1.LocalizationService }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }] });

/**
 * @hidden
 */
const STEPPER_STEP_INDEX = 'data-kendo-stepper-index';

/**
 * @hidden
 */
class StepperStepComponent {
    service;
    localization;
    ngZone;
    step;
    index;
    current;
    type;
    successIcon;
    successSVGIcon;
    errorIcon;
    errorSVGIcon;
    svgIcon;
    indicatorTemplate;
    labelTemplate;
    stepTemplate;
    stepLink;
    isStepValid = undefined;
    shouldCheckValidity = undefined;
    checkCircleIcon = checkCircleIcon;
    exclamationCircleIcon = exclamationCircleIcon;
    subs;
    constructor(service, localization, ngZone) {
        this.service = service;
        this.localization = localization;
        this.ngZone = ngZone;
        validatePackage(packageMetadata);
        this.subs = this.service.focusedStepChange.subscribe(() => {
            this.onFocusedStepChange();
        });
        this.subs.add(this.service.triggerValidation.subscribe(() => {
            this.handleValidityChecks();
        }));
    }
    get errorStepClass() {
        if (isPresent(this.isStepValid)) {
            return !this.isStepValid;
        }
        return false;
    }
    get successStepClass() {
        if (isPresent(this.isStepValid)) {
            return this.isStepValid;
        }
        return false;
    }
    ngOnInit() {
        this.handleValidityChecks();
    }
    ngOnChanges(changes) {
        if (changes['current'] && !changes['current'].firstChange) {
            this.handleValidityChecks();
        }
    }
    ngOnDestroy() {
        if (this.subs) {
            this.subs.unsubscribe();
        }
    }
    onFocusedStepChange() {
        this.ngZone.runOutsideAngular(() => {
            if (this.index === this.service.focusedStep) {
                this.stepLink.nativeElement.focus();
            }
        });
    }
    onFocus() {
        this.service.focus(this.index);
    }
    get tabIndexAttr() {
        const active = this.service.focusedStep || this.service.currentStep;
        return this.index === active ? 0 : -1;
    }
    get indicatorIconClass() {
        if (this.step.icon && !this.step.iconClass) {
            return `${this.step.icon}`;
        }
        if (!this.step.icon && !this.step.iconClass && this.shouldCheckValidity) {
            return this.validationIconClasses;
        }
    }
    get customIndicatorIconClass() {
        if (this.step.iconClass) {
            return `${this.step.iconClass}`;
        }
        const renderCustomValidationIcon = !this.step.icon && !this.step.iconClass && this.shouldCheckValidity;
        if (renderCustomValidationIcon) {
            return this.customValidationIconClasses;
        }
    }
    get SVGIndicatorIcon() {
        if (this.step.svgIcon) {
            return this.step.svgIcon;
        }
        if (!this.step.svgIcon && this.shouldCheckValidity) {
            return this.validationSVGIcon;
        }
    }
    get validationIconClasses() {
        if (this.isStepValid) {
            return !this.successIcon ? 'check-circle' : '';
        }
        return !this.errorIcon ? 'exclamation-circle' : '';
    }
    get customValidationIconClasses() {
        if (this.isStepValid) {
            return this.successIcon ? this.successIcon : '';
        }
        return this.errorIcon ? this.errorIcon : '';
    }
    get validationSVGIcon() {
        if (this.isStepValid) {
            return this.successSVGIcon ? this.successSVGIcon : this.checkCircleIcon;
        }
        return this.errorSVGIcon ? this.errorSVGIcon : this.exclamationCircleIcon;
    }
    get showIndicatorIcon() {
        if (this.shouldCheckValidity) {
            return true;
        }
        if (this.step.icon || this.step.iconClass || this.step.svgIcon) {
            return true;
        }
        return false;
    }
    get showLabelIcon() {
        if (this.shouldCheckValidity) {
            if (this.type === 'label') {
                return true;
            }
            if (this.step.icon || this.step.iconClass) {
                return true;
            }
        }
        return false;
    }
    get showLabelText() {
        return this.type === 'label' || this.type === 'full';
    }
    get indicatorText() {
        const text = this.step.text;
        return text ? text : (this.index + 1).toString();
    }
    updateStepValidity() {
        if (typeof this.step.isValid === 'boolean') {
            return this.step.isValid;
        }
        if (typeof this.step.isValid === 'function') {
            return this.step.isValid(this.index);
        }
        return undefined;
    }
    get showIndicator() {
        return this.type === 'indicator' || this.type === 'full';
    }
    get showLabel() {
        if (this.type === 'label' || this.type === 'full') {
            return true;
        }
        return this.step.optional;
    }
    get optionalText() {
        return this.localization.get('optional');
    }
    get transitionDuration() {
        return this.service.owner.animationDuration;
    }
    _shouldCheckValidity() {
        if (isPresent(this.step.validate)) {
            if (typeof this.step.validate === 'boolean') {
                return this.step.validate;
            }
            if (typeof this.step.validate === 'function') {
                return this.step.validate(this.index);
            }
        }
        return isPresent(this.step.isValid) && this.index < this.current;
    }
    handleValidityChecks() {
        this.isStepValid = undefined;
        this.shouldCheckValidity = this._shouldCheckValidity();
        if (this.shouldCheckValidity) {
            this.isStepValid = this.updateStepValidity();
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: StepperStepComponent, deps: [{ token: StepperService }, { token: i1.LocalizationService }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: StepperStepComponent, isStandalone: true, selector: "[kendoStepperStep]", inputs: { step: "step", index: "index", current: "current", type: "type", successIcon: "successIcon", successSVGIcon: "successSVGIcon", errorIcon: "errorIcon", errorSVGIcon: "errorSVGIcon", svgIcon: "svgIcon", indicatorTemplate: "indicatorTemplate", labelTemplate: "labelTemplate", stepTemplate: "stepTemplate" }, host: { properties: { "class.k-step-error": "this.errorStepClass", "class.k-step-success": "this.successStepClass" } }, viewQueries: [{ propertyName: "stepLink", first: true, predicate: ["stepLink"], descendants: true, static: true }], usesOnChanges: true, ngImport: i0, template: `
        <a href='#' class='k-step-link' #stepLink
          [attr.tabindex]='tabIndexAttr'
          [attr.title]='step.label'
          [attr.aria-disabled]='step.disabled'
          [attr.aria-current]='index === current ? "step" : null'
          (focus)='onFocus()'
          >
          @if (stepTemplate) {
            <ng-template
              [ngTemplateOutlet]='stepTemplate'
              [ngTemplateOutletContext]='{ $implicit: step, index: index }'>
            </ng-template>
          }

          @if (!stepTemplate) {
            @if (showIndicator) {
              <span
                class='k-step-indicator'
                aria-hidden='true'
                [style.transition-duration.ms]='transitionDuration'
                >
                @if (indicatorTemplate) {
                  <ng-template
                    [ngTemplateOutlet]='indicatorTemplate'
                    [ngTemplateOutletContext]='{ $implicit: step, index: index }'>
                  </ng-template>
                }
                @if (!indicatorTemplate) {
                  @if (showIndicatorIcon) {
                    <kendo-icon-wrapper
                      [name]='indicatorIconClass'
                      [customFontClass]='customIndicatorIconClass'
                      [svgIcon]='SVGIndicatorIcon'
                      innerCssClass='k-step-indicator-icon'
                      >
                    </kendo-icon-wrapper>
                  }
                  @if (!showIndicatorIcon) {
                    <span class='k-step-indicator-text'>{{ indicatorText }}</span>
                  }
                }
              </span>
            }
            @if (showLabel) {
              <span class='k-step-label'>
                @if (labelTemplate) {
                  <ng-template
                    [ngTemplateOutlet]='labelTemplate'
                    [ngTemplateOutletContext]='{ $implicit: step, index: index }'>
                  </ng-template>
                }
                @if (!labelTemplate) {
                  @if (showLabelText) {
                    <span class='k-step-text'>{{ step.label }}</span>
                  }
                  @if (showLabelIcon) {
                    <kendo-icon-wrapper
                      aria-hidden='true'
                      [name]='validationIconClasses'
                      [customFontClass]='customValidationIconClasses'
                      [svgIcon]='validationSVGIcon'
                      >
                    </kendo-icon-wrapper>
                  }
                  @if (step.optional) {
                    <span class='k-step-label-optional'>({{optionalText}})</span>
                  }
                }
              </span>
            }
          }
        </a>
        `, isInline: true, dependencies: [{ kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: StepperStepComponent, decorators: [{
            type: Component,
            args: [{
                    // eslint-disable-next-line @angular-eslint/component-selector
                    selector: '[kendoStepperStep]',
                    template: `
        <a href='#' class='k-step-link' #stepLink
          [attr.tabindex]='tabIndexAttr'
          [attr.title]='step.label'
          [attr.aria-disabled]='step.disabled'
          [attr.aria-current]='index === current ? "step" : null'
          (focus)='onFocus()'
          >
          @if (stepTemplate) {
            <ng-template
              [ngTemplateOutlet]='stepTemplate'
              [ngTemplateOutletContext]='{ $implicit: step, index: index }'>
            </ng-template>
          }

          @if (!stepTemplate) {
            @if (showIndicator) {
              <span
                class='k-step-indicator'
                aria-hidden='true'
                [style.transition-duration.ms]='transitionDuration'
                >
                @if (indicatorTemplate) {
                  <ng-template
                    [ngTemplateOutlet]='indicatorTemplate'
                    [ngTemplateOutletContext]='{ $implicit: step, index: index }'>
                  </ng-template>
                }
                @if (!indicatorTemplate) {
                  @if (showIndicatorIcon) {
                    <kendo-icon-wrapper
                      [name]='indicatorIconClass'
                      [customFontClass]='customIndicatorIconClass'
                      [svgIcon]='SVGIndicatorIcon'
                      innerCssClass='k-step-indicator-icon'
                      >
                    </kendo-icon-wrapper>
                  }
                  @if (!showIndicatorIcon) {
                    <span class='k-step-indicator-text'>{{ indicatorText }}</span>
                  }
                }
              </span>
            }
            @if (showLabel) {
              <span class='k-step-label'>
                @if (labelTemplate) {
                  <ng-template
                    [ngTemplateOutlet]='labelTemplate'
                    [ngTemplateOutletContext]='{ $implicit: step, index: index }'>
                  </ng-template>
                }
                @if (!labelTemplate) {
                  @if (showLabelText) {
                    <span class='k-step-text'>{{ step.label }}</span>
                  }
                  @if (showLabelIcon) {
                    <kendo-icon-wrapper
                      aria-hidden='true'
                      [name]='validationIconClasses'
                      [customFontClass]='customValidationIconClasses'
                      [svgIcon]='validationSVGIcon'
                      >
                    </kendo-icon-wrapper>
                  }
                  @if (step.optional) {
                    <span class='k-step-label-optional'>({{optionalText}})</span>
                  }
                }
              </span>
            }
          }
        </a>
        `,
                    standalone: true,
                    imports: [NgTemplateOutlet, IconWrapperComponent]
                }]
        }], ctorParameters: () => [{ type: StepperService }, { type: i1.LocalizationService }, { type: i0.NgZone }], propDecorators: { step: [{
                type: Input
            }], index: [{
                type: Input
            }], current: [{
                type: Input
            }], type: [{
                type: Input
            }], successIcon: [{
                type: Input
            }], successSVGIcon: [{
                type: Input
            }], errorIcon: [{
                type: Input
            }], errorSVGIcon: [{
                type: Input
            }], svgIcon: [{
                type: Input
            }], indicatorTemplate: [{
                type: Input
            }], labelTemplate: [{
                type: Input
            }], stepTemplate: [{
                type: Input
            }], stepLink: [{
                type: ViewChild,
                args: ['stepLink', { static: true }]
            }], errorStepClass: [{
                type: HostBinding,
                args: ['class.k-step-error']
            }], successStepClass: [{
                type: HostBinding,
                args: ['class.k-step-success']
            }] } });

/**
 * @hidden
 */
class StepperListComponent {
    renderer;
    ngZone;
    service;
    element;
    linear;
    stepType;
    orientation;
    currentStep;
    steps;
    successIcon;
    successSVGIcon;
    errorIcon;
    errorSVGIcon;
    svgIcon;
    indicatorTemplate;
    labelTemplate;
    stepTemplate;
    listKeydown = new EventEmitter();
    listClick = new EventEmitter();
    domSubs;
    constructor(renderer, ngZone, service, element) {
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.service = service;
        this.element = element;
    }
    ngOnInit() {
        this.initDomEvents();
    }
    ngOnDestroy() {
        if (this.domSubs) {
            this.domSubs();
        }
    }
    get maxStepWidth() {
        return this.maxStepDimension('width');
    }
    get maxStepHeight() {
        return this.maxStepDimension('height');
    }
    get focusedStep() {
        return this.service.focusedStep;
    }
    isPresent(arg) {
        return isPresent$1(arg);
    }
    maxStepDimension(dimension) {
        if (dimension === 'width' && this.orientation === 'vertical') {
            return null;
        }
        if (dimension === 'height' && this.orientation === 'horizontal') {
            return null;
        }
        return 100 / this.steps.length;
    }
    initDomEvents() {
        if (!this.element) {
            return;
        }
        this.ngZone.runOutsideAngular(() => {
            const nativeElement = this.element.nativeElement;
            const clickSubscription = this.renderer.listen(nativeElement, 'click', this.clickHandler.bind(this));
            const keydownSubscription = this.renderer.listen(nativeElement, 'keydown', (e) => {
                if (hasClass(e.target, 'k-step-link')) {
                    this.listKeydown.emit(e);
                }
            });
            this.domSubs = () => {
                clickSubscription();
                keydownSubscription();
            };
        });
    }
    clickHandler(e) {
        e.preventDefault();
        const stepIdx = this.getStepIndex(e.target);
        const step = this.steps[stepIdx];
        if (!step || step.disabled) {
            return;
        }
        const eventArgs = {
            stepIdx,
            currentStep: this.currentStep,
            linear: this.linear,
            originalEvent: e
        };
        this.listClick.emit(eventArgs);
    }
    getStepIndex(target) {
        const step = closestItem(target, STEPPER_STEP_INDEX, this.element.nativeElement);
        if (step) {
            return itemIndex(step, STEPPER_STEP_INDEX);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: StepperListComponent, deps: [{ token: i0.Renderer2 }, { token: i0.NgZone }, { token: StepperService }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: StepperListComponent, isStandalone: true, selector: "[kendoStepperList]", inputs: { linear: "linear", stepType: "stepType", orientation: "orientation", currentStep: "currentStep", steps: "steps", successIcon: "successIcon", successSVGIcon: "successSVGIcon", errorIcon: "errorIcon", errorSVGIcon: "errorSVGIcon", svgIcon: "svgIcon", indicatorTemplate: "indicatorTemplate", labelTemplate: "labelTemplate", stepTemplate: "stepTemplate" }, outputs: { listKeydown: "listKeydown", listClick: "listClick" }, ngImport: i0, template: "\n        @for (step of steps; track step; let idx = $index) {\n          <li kendoStepperStep\n            [attr.data-kendo-stepper-index]='idx'\n            [type]='stepType'\n            [step]='step'\n            [index]='idx'\n            [current]='currentStep'\n            [successIcon]='successIcon'\n            [successSVGIcon]='successSVGIcon'\n            [errorIcon]='errorIcon'\n            [errorSVGIcon]='errorSVGIcon'\n            [svgIcon]='svgIcon'\n            [indicatorTemplate]='indicatorTemplate'\n            [labelTemplate]='labelTemplate'\n            [stepTemplate]='stepTemplate'\n            class='k-step'\n            [class.k-step-first]='idx === 0'\n            [class.k-step-last]='idx === steps.length - 1'\n            [class.k-step-done]='idx < currentStep'\n            [class.k-step-current]='idx === currentStep'\n            [class.k-step-optional]='step.optional'\n            [class.k-disabled]='step.disabled'\n            [class.k-focus]='idx === focusedStep || (!isPresent(focusedStep) && idx === currentStep)'\n            [ngClass]='step.cssClass'\n            [ngStyle]='step.cssStyle'\n            [style.max-width.%] = 'maxStepWidth'\n            [style.max-height.%] = 'maxStepHeight'\n            >\n          </li>\n        }\n        ", isInline: true, dependencies: [{ kind: "component", type: StepperStepComponent, selector: "[kendoStepperStep]", inputs: ["step", "index", "current", "type", "successIcon", "successSVGIcon", "errorIcon", "errorSVGIcon", "svgIcon", "indicatorTemplate", "labelTemplate", "stepTemplate"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: StepperListComponent, decorators: [{
            type: Component,
            args: [{
                    // eslint-disable-next-line @angular-eslint/component-selector
                    selector: '[kendoStepperList]',
                    template: `
        @for (step of steps; track step; let idx = $index) {
          <li kendoStepperStep
            [attr.${STEPPER_STEP_INDEX}]='idx'
            [type]='stepType'
            [step]='step'
            [index]='idx'
            [current]='currentStep'
            [successIcon]='successIcon'
            [successSVGIcon]='successSVGIcon'
            [errorIcon]='errorIcon'
            [errorSVGIcon]='errorSVGIcon'
            [svgIcon]='svgIcon'
            [indicatorTemplate]='indicatorTemplate'
            [labelTemplate]='labelTemplate'
            [stepTemplate]='stepTemplate'
            class='k-step'
            [class.k-step-first]='idx === 0'
            [class.k-step-last]='idx === steps.length - 1'
            [class.k-step-done]='idx < currentStep'
            [class.k-step-current]='idx === currentStep'
            [class.k-step-optional]='step.optional'
            [class.k-disabled]='step.disabled'
            [class.k-focus]='idx === focusedStep || (!isPresent(focusedStep) && idx === currentStep)'
            [ngClass]='step.cssClass'
            [ngStyle]='step.cssStyle'
            [style.max-width.%] = 'maxStepWidth'
            [style.max-height.%] = 'maxStepHeight'
            >
          </li>
        }
        `,
                    standalone: true,
                    imports: [StepperStepComponent, NgClass, NgStyle]
                }]
        }], ctorParameters: () => [{ type: i0.Renderer2 }, { type: i0.NgZone }, { type: StepperService }, { type: i0.ElementRef }], propDecorators: { linear: [{
                type: Input
            }], stepType: [{
                type: Input
            }], orientation: [{
                type: Input
            }], currentStep: [{
                type: Input
            }], steps: [{
                type: Input
            }], successIcon: [{
                type: Input
            }], successSVGIcon: [{
                type: Input
            }], errorIcon: [{
                type: Input
            }], errorSVGIcon: [{
                type: Input
            }], svgIcon: [{
                type: Input
            }], indicatorTemplate: [{
                type: Input
            }], labelTemplate: [{
                type: Input
            }], stepTemplate: [{
                type: Input
            }], listKeydown: [{
                type: Output
            }], listClick: [{
                type: Output
            }] } });

/**
 * @hidden
 */
class StepperMessages extends ComponentMessages {
    /**
     * Specifies the optional text.
     */
    optional;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: StepperMessages, deps: null, target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: StepperMessages, isStandalone: true, selector: "kendo-stepper-messages-base", inputs: { optional: "optional" }, usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: StepperMessages, decorators: [{
            type: Directive,
            args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: 'kendo-stepper-messages-base'
                }]
        }], propDecorators: { optional: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class LocalizedStepperMessagesDirective extends StepperMessages {
    service;
    constructor(service) {
        super();
        this.service = service;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: LocalizedStepperMessagesDirective, deps: [{ token: i1.LocalizationService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: LocalizedStepperMessagesDirective, isStandalone: true, selector: "\n      [kendoStepperLocalizedMessages]\n    ", providers: [
            {
                provide: StepperMessages,
                useExisting: forwardRef(() => LocalizedStepperMessagesDirective)
            }
        ], usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: LocalizedStepperMessagesDirective, decorators: [{
            type: Directive,
            args: [{
                    providers: [
                        {
                            provide: StepperMessages,
                            useExisting: forwardRef(() => LocalizedStepperMessagesDirective)
                        }
                    ],
                    selector: `
      [kendoStepperLocalizedMessages]
    `,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1.LocalizationService }] });

const DEFAULT_ANIMATION_DURATION = 400;
/**
 * Represents the [Kendo UI Stepper component for Angular]({% slug overview_stepper %}).
 *
 * @example
 * ```ts
 * @Component({
 *   selector: 'my-app',
 *   template: `
 *     <kendo-stepper [steps]="steps">
 *     </kendo-stepper>
 *   `
 * })
 * class AppComponent {
 *   public steps: Array<StepperStep> = [
 *     { label: 'Step One' }, { label: 'Step Two' }, { label: 'Step Three' }
 *   ];
 * }
 * ```
 * @remarks
 * Supported children components are: {@link StepperCustomMessagesComponent}.
 */
class StepperComponent {
    renderer;
    elem;
    localization;
    stepperService;
    hostClasses = true;
    get linearClass() {
        return this.linear;
    }
    ariaRole = 'navigation';
    direction;
    displayStyle = 'grid';
    /**
     * Specifies the type of the steps in the Stepper.
     *
     * @default 'indicator'
     */
    stepType = 'indicator';
    /**
     * Specifies the linear flow of the Stepper.
     *
     * @default true
     */
    linear = true;
    /**
     * Specifies the orientation of the Stepper
     * ([see example]({% slug orientation_stepper %})).
     *
     * @default 'horizontal'
     */
    orientation = 'horizontal';
    /**
     * Specifies the index of the current step.
     */
    set currentStep(value) {
        this.stepperService.currentStep = value;
    }
    get currentStep() {
        return this.stepperService.currentStep;
    }
    /**
     * Specifies the collection of steps that will be rendered in the Stepper
     * ([see example]({% slug step_appearance_stepper %})).
     */
    set steps(steps) {
        if (isPresent(steps) && steps.length > 0) {
            this._steps = steps;
        }
    }
    get steps() {
        return this._steps;
    }
    /**
     * Specifies an SVG icon to be rendered inside the step indicator instead of the default numeric or text content.
     * You can use either an [existing Kendo SVG icon](slug:svgicon_list) or a custom one.
     */
    set svgIcon(icon) {
        this._svgIcon = icon;
    }
    get svgIcon() {
        return this._svgIcon;
    }
    /**
     * Specifies an SVG icon to be rendered for the success icon.
     * You can use either an [existing Kendo SVG icon](slug:svgicon_list) or a custom one.
     */
    successSVGIcon;
    /**
     * Specifies an SVG icon to be rendered for the error icon.
     * You can use either an [existing Kendo SVG icon](slug:svgicon_list) or a custom one.
     */
    errorSVGIcon;
    /**
     * Specifies an SVG icon that will be rendered inside the step for valid previous steps.
     * You can use either an [existing Kendo SVG icon](slug:svgicon_list) or a custom one.
     */
    successIcon;
    /**
    * Specifies an SVG icon that will be rendered inside the step for invalid previous steps.
    * You can use either an [existing Kendo SVG icon](slug:svgicon_list) or a custom one.
    */
    errorIcon;
    /**
     * Specifies the duration of the progress indicator animation in milliseconds.
     *
     * @default true
     */
    animation = true;
    /**
     * Fires when a step is about to be activated. You can prevent this event.
     */
    activate = new EventEmitter();
    /**
     * Fires when the `currentStep` property of the component was updated.
     * Use this event to provide a two-way binding for the `currentStep` property.
     */
    currentStepChange = new EventEmitter();
    /**
     * @hidden
     */
    stepTemplate;
    /**
     * @hidden
     */
    labelTemplate;
    /**
     * @hidden
     */
    indicatorTemplate;
    dynamicRTLSubscription;
    _steps = [];
    _successSVGIcon;
    _errorSVGIcon;
    _svgIcon;
    constructor(renderer, elem, localization, stepperService) {
        this.renderer = renderer;
        this.elem = elem;
        this.localization = localization;
        this.stepperService = stepperService;
        this.dynamicRTLSubscription = this.localization.changes.subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
        });
        this.stepperService.owner = this;
    }
    ngOnInit() {
        this.applyHostStyling();
    }
    ngOnChanges(changes) {
        if (changes['steps'] && !changes['steps'].firstChange) {
            this.applyHostStyling();
        }
        if (changes['orientation']) {
            this.resetHostStyling();
            this.applyHostStyling();
        }
    }
    ngOnDestroy() {
        if (this.dynamicRTLSubscription) {
            this.dynamicRTLSubscription.unsubscribe();
        }
    }
    /**
     * Manually triggers the validity check configured by the [isValid]({% slug api_layout_stepperstep %}#toc-isvalid) property of the steps ([see example]({% slug step_validation_stepper %}#toc-triggering-the-validation)).
     *
     * Steps that have their [validate]({% slug api_layout_stepperstep %}#toc-validate) property set to `false`, will not be validated.
     */
    validateSteps() {
        this.stepperService.validateSteps();
    }
    applyHostStyling() {
        const stepFramesStyle = this.orientation === 'horizontal' ? 'grid-template-columns' : 'grid-template-rows';
        const stepFramesValue = `repeat(${this.steps.length * 2}, 1fr)`;
        this.renderer.setStyle(this.elem.nativeElement, stepFramesStyle, stepFramesValue);
    }
    resetHostStyling() {
        this.renderer.removeStyle(this.elem.nativeElement, 'grid-template-columns');
        this.renderer.removeStyle(this.elem.nativeElement, 'grid-template-rows');
    }
    /**
     * @hidden
     */
    get progressAnimation() {
        return { duration: this.animationDuration };
    }
    /**
     * @hidden
     */
    get animationDuration() {
        if (typeof this.animation === 'number') {
            return this.animation;
        }
        if (typeof this.animation === 'boolean' && this.animation) {
            return DEFAULT_ANIMATION_DURATION;
        }
        return 0;
    }
    /**
     * @hidden
     */
    get stepsListStyling() {
        if (this.orientation === 'horizontal') {
            return { 'grid-column-start': 1, 'grid-column-end': -1 };
        }
        return { 'grid-row-start': 1, 'grid-row-end': -1 };
    }
    /**
     * @hidden
     */
    get progressBarStyling() {
        if (this.orientation === 'horizontal') {
            return {
                'grid-column-start': 2,
                'grid-column-end': this.steps.length * 2
            };
        }
        return {
            'grid-row-start': 2,
            'grid-row-end': this.steps.length * 2
        };
    }
    /**
     * @hidden
     */
    onListKeydown(e) {
        this.stepperService.keydown(e);
    }
    /**
     * @hidden
     */
    onListClick(e) {
        if (e.stepIdx === e.currentStep) {
            this.stepperService.focus(e.stepIdx);
            return;
        }
        if (e.linear && this.stepperService.isPrevOrNextStep(e.stepIdx) === false) {
            return;
        }
        this.stepperService.onActivate(e.stepIdx, e.originalEvent);
    }
    /**
     * @hidden
     */
    get isHorizontal() {
        return this.orientation === 'horizontal';
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: StepperComponent, deps: [{ token: i0.Renderer2 }, { token: i0.ElementRef }, { token: i1.LocalizationService }, { token: StepperService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: StepperComponent, isStandalone: true, selector: "kendo-stepper", inputs: { stepType: "stepType", linear: "linear", orientation: "orientation", currentStep: "currentStep", steps: "steps", svgIcon: "svgIcon", successSVGIcon: "successSVGIcon", errorSVGIcon: "errorSVGIcon", successIcon: "successIcon", errorIcon: "errorIcon", animation: "animation" }, outputs: { activate: "activate", currentStepChange: "currentStepChange" }, host: { properties: { "class.k-stepper": "this.hostClasses", "class.k-stepper-linear": "this.linearClass", "attr.role": "this.ariaRole", "attr.dir": "this.direction", "style.display": "this.displayStyle" } }, providers: [
            LocalizationService,
            StepperService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.stepper'
            }
        ], queries: [{ propertyName: "stepTemplate", first: true, predicate: StepperStepTemplateDirective, descendants: true }, { propertyName: "labelTemplate", first: true, predicate: StepperLabelTemplateDirective, descendants: true }, { propertyName: "indicatorTemplate", first: true, predicate: StepperIndicatorTemplateDirective, descendants: true }], exportAs: ["kendoStepper"], usesOnChanges: true, ngImport: i0, template: `
        <ng-container kendoStepperLocalizedMessages
          i18n-optional="kendo.stepper.optional|The text for the optional segment of the step label"
          optional="Optional"
          >
        </ng-container>
        <ol kendoStepperList
          [stepType]='stepType'
          [linear]='linear'
          [orientation]='orientation'
          [steps]='steps'
          [currentStep]='currentStep'
          [successIcon]='successIcon'
          [successSVGIcon]='successSVGIcon'
          [errorIcon]='errorIcon'
          [errorSVGIcon]='errorSVGIcon'
          [svgIcon]="svgIcon"
          [indicatorTemplate]='indicatorTemplate?.templateRef'
          [labelTemplate]='labelTemplate?.templateRef'
          [stepTemplate]='stepTemplate?.templateRef'
          class='k-step-list'
          [class.k-step-list-horizontal]='isHorizontal'
          [class.k-step-list-vertical]='!isHorizontal'
          [ngStyle]='stepsListStyling'
          (listKeydown)="onListKeydown($event)"
          (listClick)="onListClick($event)">
        </ol>
        
        @if (steps.length > 0) {
          <kendo-progressbar
            [attr.aria-hidden]='true'
            [animation]='progressAnimation'
            [max]='steps.length - 1'
            [label]='{position: "start", visible: false}'
            [orientation]='orientation'
            [reverse]='!isHorizontal'
            [value]='currentStep'
            [ngStyle]='progressBarStyling'>
          </kendo-progressbar>
        }
        `, isInline: true, dependencies: [{ kind: "directive", type: LocalizedStepperMessagesDirective, selector: "\n      [kendoStepperLocalizedMessages]\n    " }, { kind: "component", type: StepperListComponent, selector: "[kendoStepperList]", inputs: ["linear", "stepType", "orientation", "currentStep", "steps", "successIcon", "successSVGIcon", "errorIcon", "errorSVGIcon", "svgIcon", "indicatorTemplate", "labelTemplate", "stepTemplate"], outputs: ["listKeydown", "listClick"] }, { kind: "directive", type: NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "component", type: ProgressBarComponent, selector: "kendo-progressbar", inputs: ["label", "progressCssStyle", "progressCssClass", "emptyCssStyle", "emptyCssClass", "animation"], outputs: ["animationEnd"], exportAs: ["kendoProgressBar"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: StepperComponent, decorators: [{
            type: Component,
            args: [{
                    exportAs: 'kendoStepper',
                    providers: [
                        LocalizationService,
                        StepperService,
                        {
                            provide: L10N_PREFIX,
                            useValue: 'kendo.stepper'
                        }
                    ],
                    selector: 'kendo-stepper',
                    template: `
        <ng-container kendoStepperLocalizedMessages
          i18n-optional="kendo.stepper.optional|The text for the optional segment of the step label"
          optional="Optional"
          >
        </ng-container>
        <ol kendoStepperList
          [stepType]='stepType'
          [linear]='linear'
          [orientation]='orientation'
          [steps]='steps'
          [currentStep]='currentStep'
          [successIcon]='successIcon'
          [successSVGIcon]='successSVGIcon'
          [errorIcon]='errorIcon'
          [errorSVGIcon]='errorSVGIcon'
          [svgIcon]="svgIcon"
          [indicatorTemplate]='indicatorTemplate?.templateRef'
          [labelTemplate]='labelTemplate?.templateRef'
          [stepTemplate]='stepTemplate?.templateRef'
          class='k-step-list'
          [class.k-step-list-horizontal]='isHorizontal'
          [class.k-step-list-vertical]='!isHorizontal'
          [ngStyle]='stepsListStyling'
          (listKeydown)="onListKeydown($event)"
          (listClick)="onListClick($event)">
        </ol>
        
        @if (steps.length > 0) {
          <kendo-progressbar
            [attr.aria-hidden]='true'
            [animation]='progressAnimation'
            [max]='steps.length - 1'
            [label]='{position: "start", visible: false}'
            [orientation]='orientation'
            [reverse]='!isHorizontal'
            [value]='currentStep'
            [ngStyle]='progressBarStyling'>
          </kendo-progressbar>
        }
        `,
                    standalone: true,
                    imports: [LocalizedStepperMessagesDirective, StepperListComponent, NgStyle, ProgressBarComponent]
                }]
        }], ctorParameters: () => [{ type: i0.Renderer2 }, { type: i0.ElementRef }, { type: i1.LocalizationService }, { type: StepperService }], propDecorators: { hostClasses: [{
                type: HostBinding,
                args: ['class.k-stepper']
            }], linearClass: [{
                type: HostBinding,
                args: ['class.k-stepper-linear']
            }], ariaRole: [{
                type: HostBinding,
                args: ['attr.role']
            }], direction: [{
                type: HostBinding,
                args: ['attr.dir']
            }], displayStyle: [{
                type: HostBinding,
                args: ['style.display']
            }], stepType: [{
                type: Input
            }], linear: [{
                type: Input
            }], orientation: [{
                type: Input
            }], currentStep: [{
                type: Input
            }], steps: [{
                type: Input
            }], svgIcon: [{
                type: Input
            }], successSVGIcon: [{
                type: Input
            }], errorSVGIcon: [{
                type: Input
            }], successIcon: [{
                type: Input
            }], errorIcon: [{
                type: Input
            }], animation: [{
                type: Input
            }], activate: [{
                type: Output
            }], currentStepChange: [{
                type: Output
            }], stepTemplate: [{
                type: ContentChild,
                args: [StepperStepTemplateDirective, { static: false }]
            }], labelTemplate: [{
                type: ContentChild,
                args: [StepperLabelTemplateDirective, { static: false }]
            }], indicatorTemplate: [{
                type: ContentChild,
                args: [StepperIndicatorTemplateDirective, { static: false }]
            }] } });

/**
 * Represents the arguments for the `activate` event of the Stepper.
 */
class StepperActivateEvent extends PreventableEvent$1 {
    /**
     * Specifies the index of the activated step in the `steps` collection.
     */
    index;
    /**
     * Specifies the activated step.
     */
    step;
    /**
     * Specifies the DOM event that triggered the step activation.
     */
    originalEvent;
    /**
     * Specifies the Stepper that triggered the event.
     */
    sender;
    /**
     * @hidden
     */
    constructor(args) {
        super();
        Object.assign(this, args);
    }
}

/**
 * Provides custom component messages that override default component messages
 * ([see example]({% slug rtl_layout %})).
 *
 * ```html
 * <kendo-stepper>
 *   <kendo-stepper-messages
 *     optional="Optional step"
 *   ></kendo-stepper-messages>
 * </kendo-stepper>
 * ```
 */
class StepperCustomMessagesComponent extends StepperMessages {
    service;
    constructor(service) {
        super();
        this.service = service;
    }
    get override() {
        return true;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: StepperCustomMessagesComponent, deps: [{ token: i1.LocalizationService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: StepperCustomMessagesComponent, isStandalone: true, selector: "kendo-stepper-messages", providers: [
            {
                provide: StepperMessages,
                useExisting: forwardRef(() => StepperCustomMessagesComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: StepperCustomMessagesComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: StepperMessages,
                            useExisting: forwardRef(() => StepperCustomMessagesComponent)
                        }
                    ],
                    selector: 'kendo-stepper-messages',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1.LocalizationService }] });

/**
 * @hidden
 */
class Messages extends ComponentMessages {
    /**
     * Defines the alt attribute text of the image in the Avatar.
     */
    avatarAlt;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: Messages, deps: null, target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: Messages, isStandalone: true, selector: "kendoAvatarMessages", inputs: { avatarAlt: "avatarAlt" }, usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: Messages, decorators: [{
            type: Directive,
            args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: 'kendoAvatarMessages'
                }]
        }], propDecorators: { avatarAlt: [{
                type: Input
            }] } });

// eslint-disable no-forward-ref
/**
 * @hidden
 */
class LocalizedAvatarMessagesDirective extends Messages {
    service;
    constructor(service) {
        super();
        this.service = service;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: LocalizedAvatarMessagesDirective, deps: [{ token: i1.LocalizationService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: LocalizedAvatarMessagesDirective, isStandalone: true, selector: "[kendoAvatarLocalizedMessages]", providers: [
            {
                provide: Messages,
                useExisting: forwardRef(() => LocalizedAvatarMessagesDirective)
            }
        ], usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: LocalizedAvatarMessagesDirective, decorators: [{
            type: Directive,
            args: [{
                    providers: [
                        {
                            provide: Messages,
                            useExisting: forwardRef(() => LocalizedAvatarMessagesDirective)
                        }
                    ],
                    selector: '[kendoAvatarLocalizedMessages]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1.LocalizationService }] });

const DEFAULT_ROUNDED = 'full';
const DEFAULT_SIZE = 'medium';
const DEFAULT_THEME_COLOR = 'primary';
const DEFAULT_FILL_MODE = 'solid';
/**
 * Represents the Kendo UI Avatar component for Angular. Displays images, icons, or initials representing people or other entities.
 *
 * @example
 * ```typescript
 * @Component({
 *   selector: 'my-app',
 *   template: `
 *     <kendo-avatar [imageSrc]="userImage" size="large"></kendo-avatar>
 *     <kendo-avatar [initials]="userInitials" themeColor="primary"></kendo-avatar>
 *     <kendo-avatar [icon]="userIcon" fillMode="outline"></kendo-avatar>
 *   `
 * })
 * class AppComponent {
 *   userImage = 'path/to/image.jpg';
 *   userInitials = 'JD';
 *   userIcon = 'user';
 * }
 * ```
 * @remarks
 * Supported children components are: {@link AvatarCustomMessagesComponent}.
 */
class AvatarComponent {
    localization;
    renderer;
    element;
    hostClass = true;
    /**
     * @hidden
     */
    get borderClass() {
        return this.border;
    }
    /**
     * @hidden
     */
    get flexBasis() {
        return this.width;
    }
    /**
     * Sets the shape for the avatar.
     * @hidden
     */
    set shape(shape) {
        this.rounded = mapShapeToRounded(shape);
    }
    /**
     * Specifies the size of the Avatar
     * ([see example]({% slug appearance_avatar %}#toc-size)).
     *
     * @default 'medium'
     */
    set size(size) {
        if (size !== this._size) {
            const newSize = size ? size : DEFAULT_SIZE;
            this.handleClasses('size', newSize);
            this._size = newSize;
        }
    }
    get size() {
        return this._size;
    }
    /**
     * Specifies the rounded styling of the Avatar
     * ([see example](slug:appearance_avatar#toc-roundness)).
     *
     * @default 'full'
     */
    set rounded(rounded) {
        if (rounded !== this._rounded) {
            const newRounded = rounded ? rounded : DEFAULT_ROUNDED;
            this.handleClasses('rounded', newRounded);
            this._rounded = newRounded;
        }
    }
    get rounded() {
        return this._rounded;
    }
    /**
     * Specifies the theme color of the Avatar.
     * The theme color applies as background and border color while adjusting the text color accordingly.
     *
     * @default 'primary'
     */
    set themeColor(themeColor) {
        if (themeColor !== this._themeColor) {
            const newThemeColor = themeColor ? themeColor : DEFAULT_THEME_COLOR;
            this._themeColor = newThemeColor;
            this.handleFillModeAndThemeColorClasses(this.fillMode, this.themeColor);
        }
    }
    get themeColor() {
        return this._themeColor;
    }
    /**
     * Specifies the fill style of the Avatar.
     *
     * @default 'solid'
     */
    set fillMode(fillMode) {
        if (fillMode !== this.fillMode) {
            const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE;
            this._fillMode = newFillMode;
            this.handleFillModeAndThemeColorClasses(this.fillMode, this.themeColor);
        }
    }
    get fillMode() {
        return this._fillMode;
    }
    /**
     * Specifies the appearance fill style of the avatar.
     * Deprecated, left for backward compatibility.
     *
     * @hidden
     */
    set fill(fillMode) {
        this.fillMode = fillMode;
    }
    /**
     * Adds a border to the Avatar.
     *
     * @default false
     */
    border = false;
    /**
     * Defines a CSS class or multiple classes separated by spaces.
     * You can apply these classes to a `span` element inside the Avatar and also use custom icons.
     */
    iconClass;
    /**
     * Sets the width of the Avatar.
     */
    width;
    /**
     * @hidden
     */
    get avatarWidth() {
        return this.width;
    }
    /**
     * Sets the height of the Avatar.
     */
    height;
    /**
     * @hidden
     */
    get avatarHeight() {
        return this.height;
    }
    /**
     * Defines the CSS styles that render on the content element of the Avatar.
     * Supports the type of values that [`ngStyle`](link:site.data.urls.angular['ngstyleapi']) supports.
     */
    cssStyle;
    /**
     * Sets the initials for the Avatar.
     */
    initials;
    /**
     * Sets the icon for the Avatar.
     * All [Kendo UI Icons](slug:icons#icons-list) are supported.
     */
    icon;
    /**
     * Sets the image source of the Avatar.
     */
    imageSrc;
    /**
     * Defines an SVG icon to render.
     * You can use either an [existing Kendo SVG icon](slug:svgicon_list) or a custom one.
     */
    set svgIcon(icon) {
        if (isDevMode() && icon && this.icon && this.iconClass) {
            throw new Error('Setting both icon/svgIcon and iconClass options at the same time is not supported.');
        }
        this._svgIcon = icon;
    }
    get svgIcon() {
        return this._svgIcon;
    }
    _themeColor = DEFAULT_THEME_COLOR;
    _size = DEFAULT_SIZE;
    _fillMode = DEFAULT_FILL_MODE;
    _rounded = DEFAULT_ROUNDED;
    _svgIcon;
    constructor(localization, renderer, element) {
        this.localization = localization;
        this.renderer = renderer;
        this.element = element;
        validatePackage(packageMetadata);
    }
    ngOnInit() {
        this.verifyProperties();
    }
    ngAfterViewInit() {
        const stylingInputs = ['size', 'rounded'];
        stylingInputs.forEach(input => {
            this.handleClasses(input, this[input]);
        });
        this.handleFillModeAndThemeColorClasses(this.fillMode, this.themeColor);
    }
    /**
     * @hidden
     */
    get customAvatar() {
        return !(this.imageSrc || this.initials || this.icon || this.iconClass);
    }
    verifyProperties() {
        if (!isDevMode()) {
            return;
        }
        const inputs = [this.icon || this.iconClass, this.imageSrc, this.initials];
        const inputsLength = inputs.filter((value) => value).length;
        if (inputsLength > 1) {
            throw new Error(`
                Invalid property configuration given.
                The kendo-avatar component can accept only one of:
                icon, imageSrc or initials properties.
            `);
        }
    }
    handleClasses(styleType, value) {
        const elem = this.element.nativeElement;
        const classes = getStylingClasses('avatar', styleType, this[styleType], value);
        if (classes.toRemove) {
            this.renderer.removeClass(elem, classes.toRemove);
        }
        if (classes.toAdd) {
            this.renderer.addClass(elem, classes.toAdd);
        }
    }
    handleFillModeAndThemeColorClasses(fill, themeColor) {
        const wrapperElement = this.element.nativeElement;
        // remove existing fill and theme color classes
        const currentClasses = Array.from(wrapperElement.classList);
        const classesToRemove = currentClasses.filter(cl => {
            return cl.startsWith('k-avatar-solid') || cl.startsWith('k-avatar-outline');
        });
        classesToRemove.forEach((cl => this.renderer.removeClass(wrapperElement, cl)));
        // add fill if needed
        if (fill !== 'none') {
            this.renderer.addClass(wrapperElement, `k-avatar-${fill}`);
        }
        // add theme color class if fill and theme color
        if (fill !== 'none' && themeColor !== 'none') {
            this.renderer.addClass(wrapperElement, `k-avatar-${fill}-${themeColor}`);
        }
    }
    /**
     * @hidden
     */
    textFor(key) {
        return this.localization.get(key);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AvatarComponent, deps: [{ token: i1.LocalizationService }, { token: i0.Renderer2 }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: AvatarComponent, isStandalone: true, selector: "kendo-avatar", inputs: { shape: "shape", size: "size", rounded: "rounded", themeColor: "themeColor", fillMode: "fillMode", fill: "fill", border: "border", iconClass: "iconClass", width: "width", height: "height", cssStyle: "cssStyle", initials: "initials", icon: "icon", imageSrc: "imageSrc", svgIcon: "svgIcon" }, host: { properties: { "class.k-avatar": "this.hostClass", "class.k-avatar-bordered": "this.borderClass", "style.flexBasis": "this.flexBasis", "style.width": "this.avatarWidth", "style.height": "this.avatarHeight" } }, providers: [
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.avatar'
            }
        ], ngImport: i0, template: `
        <ng-container kendoAvatarLocalizedMessages
          i18n-avatarAlt="kendo.avatar.avatarAlt|The alt attribute text of the image in the avatar."
          avatarAlt="Avatar"
          >
        </ng-container>
        
        @if (customAvatar) {
          <ng-content></ng-content>
        }
        
        @if (imageSrc) {
          <span class="k-avatar-image">
            <img src="{{ imageSrc }}" [alt]="textFor('avatarAlt')" [ngStyle]="cssStyle" />
          </span>
        }
        
        @if (initials) {
          <span class="k-avatar-text" [ngStyle]="cssStyle">{{ initials.substring(0, 2) }}</span>
        }
        
        @if (icon || iconClass || svgIcon) {
          <span class="k-avatar-icon">
            <kendo-icon-wrapper
              [ngStyle]="cssStyle"
              [name]="icon"
              [customFontClass]="iconClass"
              [svgIcon]="svgIcon"
              >
            </kendo-icon-wrapper>
          </span>
        }
        `, isInline: true, dependencies: [{ kind: "directive", type: NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "directive", type: LocalizedAvatarMessagesDirective, selector: "[kendoAvatarLocalizedMessages]" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AvatarComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        LocalizationService,
                        {
                            provide: L10N_PREFIX,
                            useValue: 'kendo.avatar'
                        }
                    ],
                    selector: 'kendo-avatar',
                    template: `
        <ng-container kendoAvatarLocalizedMessages
          i18n-avatarAlt="kendo.avatar.avatarAlt|The alt attribute text of the image in the avatar."
          avatarAlt="Avatar"
          >
        </ng-container>
        
        @if (customAvatar) {
          <ng-content></ng-content>
        }
        
        @if (imageSrc) {
          <span class="k-avatar-image">
            <img src="{{ imageSrc }}" [alt]="textFor('avatarAlt')" [ngStyle]="cssStyle" />
          </span>
        }
        
        @if (initials) {
          <span class="k-avatar-text" [ngStyle]="cssStyle">{{ initials.substring(0, 2) }}</span>
        }
        
        @if (icon || iconClass || svgIcon) {
          <span class="k-avatar-icon">
            <kendo-icon-wrapper
              [ngStyle]="cssStyle"
              [name]="icon"
              [customFontClass]="iconClass"
              [svgIcon]="svgIcon"
              >
            </kendo-icon-wrapper>
          </span>
        }
        `,
                    standalone: true,
                    imports: [NgStyle, IconWrapperComponent, LocalizedAvatarMessagesDirective]
                }]
        }], ctorParameters: () => [{ type: i1.LocalizationService }, { type: i0.Renderer2 }, { type: i0.ElementRef }], propDecorators: { hostClass: [{
                type: HostBinding,
                args: ['class.k-avatar']
            }], borderClass: [{
                type: HostBinding,
                args: ['class.k-avatar-bordered']
            }], flexBasis: [{
                type: HostBinding,
                args: ['style.flexBasis']
            }], shape: [{
                type: Input
            }], size: [{
                type: Input
            }], rounded: [{
                type: Input
            }], themeColor: [{
                type: Input
            }], fillMode: [{
                type: Input
            }], fill: [{
                type: Input
            }], border: [{
                type: Input
            }], iconClass: [{
                type: Input
            }], width: [{
                type: Input
            }], avatarWidth: [{
                type: HostBinding,
                args: ['style.width']
            }], height: [{
                type: Input
            }], avatarHeight: [{
                type: HostBinding,
                args: ['style.height']
            }], cssStyle: [{
                type: Input
            }], initials: [{
                type: Input
            }], icon: [{
                type: Input
            }], imageSrc: [{
                type: Input
            }], svgIcon: [{
                type: Input
            }] } });

// eslint-disable no-forward-ref
/**
 * Provides custom component messages that override default component messages
 * ([see example]({% slug rtl_layout %})).
 *
 * ```html
 * <kendo-avatar>
 *   <kendo-avatar-messages
 *     avatarAlt="User's profile picture"
 *   ></kendo-avatar-messages>
 * </kendo-avatar>
 * ```
 */
class AvatarCustomMessagesComponent extends Messages {
    service;
    constructor(service) {
        super();
        this.service = service;
    }
    get override() {
        return true;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AvatarCustomMessagesComponent, deps: [{ token: i1.LocalizationService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: AvatarCustomMessagesComponent, isStandalone: true, selector: "kendo-avatar-messages", providers: [
            {
                provide: Messages,
                useExisting: forwardRef(() => AvatarCustomMessagesComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AvatarCustomMessagesComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: Messages,
                            useExisting: forwardRef(() => AvatarCustomMessagesComponent)
                        }
                    ],
                    selector: 'kendo-avatar-messages',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1.LocalizationService }] });

/**
 * Represents the Kendo UI Card component for Angular.
 * Displays content in a structured container with customizable layout and styling ([Card overview]({% slug overview_card %})).
 *
 * @example
 * ```html
 * <kendo-card orientation="vertical">
 *   <kendo-card-header>
 *     <h5 kendoCardTitle>Card Title</h5>
 *   </kendo-card-header>
 *   <kendo-card-body>
 *     <p>Card content goes here.</p>
 *   </kendo-card-body>
 * </kendo-card>
 * ```
 * @remarks
 * Supported children components are: {@link CardFooterComponent}, {@link CardHeaderComponent}, {@link CardActionsComponent}, {@link CardBodyComponent}.
 */
class CardComponent {
    localizationService;
    hostClass = true;
    get widthStyle() {
        return this.width;
    }
    get vertical() {
        return this.orientation === 'vertical';
    }
    get horizontal() {
        return this.orientation === 'horizontal';
    }
    /**
     * @hidden
     */
    direction;
    /**
     * Specifies the layout of the Card content.
     *
     * @default 'vertical'
     */
    orientation = 'vertical';
    /**
     * Defines the width of the Card.
     *
     * @default '285px'
     */
    width = '285px';
    dynamicRTLSubscription;
    rtl = false;
    constructor(localizationService) {
        this.localizationService = localizationService;
        validatePackage(packageMetadata);
        this.dynamicRTLSubscription = this.localizationService.changes.subscribe(({ rtl }) => {
            this.rtl = rtl;
            this.direction = this.rtl ? 'rtl' : 'ltr';
        });
    }
    ngOnDestroy() {
        if (this.dynamicRTLSubscription) {
            this.dynamicRTLSubscription.unsubscribe();
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CardComponent, deps: [{ token: i1.LocalizationService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: CardComponent, isStandalone: true, selector: "kendo-card", inputs: { orientation: "orientation", width: "width" }, host: { properties: { "class.k-card": "this.hostClass", "style.width": "this.widthStyle", "class.k-card-vertical": "this.vertical", "class.k-card-horizontal": "this.horizontal", "attr.dir": "this.direction" } }, providers: [
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.card.component'
            }
        ], ngImport: i0, template: `
        <ng-content></ng-content>
    `, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CardComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-card',
                    providers: [
                        LocalizationService,
                        {
                            provide: L10N_PREFIX,
                            useValue: 'kendo.card.component'
                        }
                    ],
                    template: `
        <ng-content></ng-content>
    `,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1.LocalizationService }], propDecorators: { hostClass: [{
                type: HostBinding,
                args: ['class.k-card']
            }], widthStyle: [{
                type: HostBinding,
                args: ['style.width']
            }], vertical: [{
                type: HostBinding,
                args: ['class.k-card-vertical']
            }], horizontal: [{
                type: HostBinding,
                args: ['class.k-card-horizontal']
            }], direction: [{
                type: HostBinding,
                args: ['attr.dir']
            }], orientation: [{
                type: Input
            }], width: [{
                type: Input
            }] } });

/**
 * Defines the content in the Card header.
 * The header can include a title, subtitle, and other elements that provide context for the Card's content.
 *
 * @example
 * ```html
 * <kendo-card-header>
 *   <h5 kendoCardTitle>Card Title</h5>
 *   <p kendoCardSubtitle>Card Subtitle</p>
 * </kendo-card-header>
 * ```
 */
class CardHeaderComponent {
    hostClass = true;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CardHeaderComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: CardHeaderComponent, isStandalone: true, selector: "kendo-card-header", host: { properties: { "class.k-card-header": "this.hostClass" } }, ngImport: i0, template: `
        <ng-content></ng-content>
    `, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CardHeaderComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-card-header',
                    template: `
        <ng-content></ng-content>
    `,
                    standalone: true
                }]
        }], propDecorators: { hostClass: [{
                type: HostBinding,
                args: ['class.k-card-header']
            }] } });

/**
 * Defines the content in the Card body.
 * The body is the main area of the Card where the primary content is displayed.
 *
 * @example
 * ```html
 * <kendo-card-body>
 *   <p>Main content of the card.</p>
 * </kendo-card-body>
 * ```
 */
class CardBodyComponent {
    hostClass = true;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CardBodyComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: CardBodyComponent, isStandalone: true, selector: "kendo-card-body", host: { properties: { "class.k-card-body": "this.hostClass" } }, ngImport: i0, template: `
        <ng-content></ng-content>
    `, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CardBodyComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-card-body',
                    template: `
        <ng-content></ng-content>
    `,
                    standalone: true
                }]
        }], propDecorators: { hostClass: [{
                type: HostBinding,
                args: ['class.k-card-body']
            }] } });

/**
 * Defines the content in the Card footer.
 * The footer can include additional information, actions, or links related to the Card's content.
 *
 * @example
 * ```html
 * <kendo-card-footer>
 *   <p>Footer content</p>
 * </kendo-card-footer>
 * ```
 */
class CardFooterComponent {
    hostClass = true;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CardFooterComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: CardFooterComponent, isStandalone: true, selector: "kendo-card-footer", host: { properties: { "class.k-card-footer": "this.hostClass" } }, ngImport: i0, template: `
        <ng-content></ng-content>
    `, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CardFooterComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-card-footer',
                    template: `
        <ng-content></ng-content>
    `,
                    standalone: true
                }]
        }], propDecorators: { hostClass: [{
                type: HostBinding,
                args: ['class.k-card-footer']
            }] } });

/**
 * Defines the action buttons of the Card ([see example]({% slug actions_card %})).
 * The Card actions can be used to perform operations related to the Card's content, such as saving, editing, or deleting.
 *
 * @example
 * ```html
 * <kendo-card-actions
 *   layout="end"
 *   orientation="horizontal">
 * </kendo-card-actions>
 * ```
 */
class CardActionsComponent {
    hostClass = true;
    get stretchedClass() {
        return this.layout === 'stretched';
    }
    get startClass() {
        return this.layout === 'start';
    }
    get endClass() {
        return this.layout === 'end';
    }
    get centerClass() {
        return this.layout === 'center';
    }
    get verticalClass() {
        return this.orientation === 'vertical';
    }
    get horizontalClass() {
        return this.orientation === 'horizontal';
    }
    /**
     * Specifies the orientation of the Card action buttons.
     *
     * @default 'horizontal'
     */
    orientation = 'horizontal';
    /**
     * Specifies the layout of the Card action buttons.
     *
     * @default 'start'
     */
    layout = 'start';
    /**
     * Defines the Card actions declaratively.
     * You can pass an array of `CardAction` objects or a `TemplateRef`.
     */
    set actions(value) {
        if (Array.isArray(value)) {
            this.actionsArray = value;
        }
        else if (value instanceof TemplateRef) {
            this.actionsTemplate = value;
        }
    }
    /**
     * Fires when you click an action button.
     */
    action = new EventEmitter();
    /**
     * @hidden
     */
    actionsArray;
    /**
     * @hidden
     */
    actionsTemplate;
    /**
     * @hidden
     */
    onClick(action) {
        this.action.emit(action);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CardActionsComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: CardActionsComponent, isStandalone: true, selector: "kendo-card-actions", inputs: { orientation: "orientation", layout: "layout", actions: "actions" }, outputs: { action: "action" }, host: { properties: { "class.k-actions": "this.hostClass", "class.k-card-actions": "this.hostClass", "class.k-actions-stretched": "this.stretchedClass", "class.k-actions-start": "this.startClass", "class.k-actions-end": "this.endClass", "class.k-actions-center": "this.centerClass", "class.k-actions-vertical": "this.verticalClass", "class.k-actions-horizontal": "this.horizontalClass" } }, ngImport: i0, template: `
        @if (!actionsArray && !actionsTemplate) {
          <ng-content></ng-content>
        }
        
        @if (actionsArray) {
          @for (action of actionsArray; track action) {
            <button
              type="button"
              class="k-button k-button-md k-rounded-md"
              [class.k-button-solid]="!action.flat"
              [class.k-button-flat]="action.flat"
              [class.k-button-solid-base]="!action.primary && !action.flat"
              [class.k-button-solid-primary]="action.primary && !action.flat"
              [class.k-button-flat-base]="!action.primary && action.flat"
              [class.k-button-flat-primary]="action.primary && action.flat"
              (click)="onClick(action)"
              >
              <span class="k-button-text">{{ action.text }}</span>
            </button>
          }
        }
        
        @if (actionsTemplate) {
          <ng-template [ngTemplateOutlet]="actionsTemplate"></ng-template>
        }
        `, isInline: true, dependencies: [{ kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CardActionsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-card-actions',
                    template: `
        @if (!actionsArray && !actionsTemplate) {
          <ng-content></ng-content>
        }
        
        @if (actionsArray) {
          @for (action of actionsArray; track action) {
            <button
              type="button"
              class="k-button k-button-md k-rounded-md"
              [class.k-button-solid]="!action.flat"
              [class.k-button-flat]="action.flat"
              [class.k-button-solid-base]="!action.primary && !action.flat"
              [class.k-button-solid-primary]="action.primary && !action.flat"
              [class.k-button-flat-base]="!action.primary && action.flat"
              [class.k-button-flat-primary]="action.primary && action.flat"
              (click)="onClick(action)"
              >
              <span class="k-button-text">{{ action.text }}</span>
            </button>
          }
        }
        
        @if (actionsTemplate) {
          <ng-template [ngTemplateOutlet]="actionsTemplate"></ng-template>
        }
        `,
                    standalone: true,
                    imports: [NgTemplateOutlet]
                }]
        }], propDecorators: { hostClass: [{
                type: HostBinding,
                args: ['class.k-actions']
            }, {
                type: HostBinding,
                args: ['class.k-card-actions']
            }], stretchedClass: [{
                type: HostBinding,
                args: ['class.k-actions-stretched']
            }], startClass: [{
                type: HostBinding,
                args: ['class.k-actions-start']
            }], endClass: [{
                type: HostBinding,
                args: ['class.k-actions-end']
            }], centerClass: [{
                type: HostBinding,
                args: ['class.k-actions-center']
            }], verticalClass: [{
                type: HostBinding,
                args: ['class.k-actions-vertical']
            }], horizontalClass: [{
                type: HostBinding,
                args: ['class.k-actions-horizontal']
            }], orientation: [{
                type: Input
            }], layout: [{
                type: Input
            }], actions: [{
                type: Input
            }], action: [{
                type: Output
            }] } });

/**
 * Defines a separator in the content of the Card.
 * The separator can be used to visually divide sections within the Card.
 *
 * ```html
 * <kendo-card>
 *  <div kendoCardSeparator></div>
 *  <p>Content below the separator</p>
 * </kendo-card>
 * ```
 */
class CardSeparatorDirective {
    hostClass = true;
    get verticalClass() {
        return this.orientation === 'vertical';
    }
    get horizontalClass() {
        return this.orientation === 'horizontal';
    }
    /**
     * Sets the color of the Card separator.
     */
    color;
    /**
     * Specifies the orientation of the Card separator.
     *
     * @default 'horizontal'
     */
    orientation = 'horizontal';
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CardSeparatorDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: CardSeparatorDirective, isStandalone: true, selector: "[kendoCardSeparator]", inputs: { color: "color", orientation: "orientation" }, host: { properties: { "class.k-card-separator": "this.hostClass", "class.k-separator-vertical": "this.verticalClass", "class.k-separator-horizontal": "this.horizontalClass", "style.color": "this.color" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CardSeparatorDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoCardSeparator]',
                    standalone: true
                }]
        }], propDecorators: { hostClass: [{
                type: HostBinding,
                args: ['class.k-card-separator']
            }], verticalClass: [{
                type: HostBinding,
                args: ['class.k-separator-vertical']
            }], horizontalClass: [{
                type: HostBinding,
                args: ['class.k-separator-horizontal']
            }], color: [{
                type: HostBinding,
                args: ['style.color']
            }, {
                type: Input
            }], orientation: [{
                type: Input
            }] } });

/**
 * Defines the text and styles for the title of the Card.
 * The title is displayed at the top of the Card, above the subtitle and content.
 *
 * ```html
 * <kendo-card>
 *   <h3 kendoCardTitle>Card Title</h3>
 * </kendo-card>
 * ```
 */
class CardTitleDirective {
    hostClass = true;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CardTitleDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: CardTitleDirective, isStandalone: true, selector: "[kendoCardTitle]", host: { properties: { "class.k-card-title": "this.hostClass" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CardTitleDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoCardTitle]',
                    standalone: true
                }]
        }], propDecorators: { hostClass: [{
                type: HostBinding,
                args: ['class.k-card-title']
            }] } });

/**
 * Defines the text and styles for the subtitle of the Card.
 * The subtitle is displayed below the title and above the content of the Card.
 *
 * ```html
 * <kendo-card>
 *  <h4 kendoCardSubtitle>Card Subtitle</h4>
 * </kendo-card>
 * ```
 */
class CardSubtitleDirective {
    hostClass = true;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CardSubtitleDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: CardSubtitleDirective, isStandalone: true, selector: "[kendoCardSubtitle]", host: { properties: { "class.k-card-subtitle": "this.hostClass" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CardSubtitleDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoCardSubtitle]',
                    standalone: true
                }]
        }], propDecorators: { hostClass: [{
                type: HostBinding,
                args: ['class.k-card-subtitle']
            }] } });

/**
 * Defines any media that displays and aligns in the Card.
 * The media can be an image, video, or any other media type.
 *
 * ```html
 * <kendo-card>
 *  <div kendoCardMedia>
 *   <img src="path/to/image.jpg" alt="Card Media">
 *  </div>
 * </kendo-card>
 * ```
 */
class CardMediaDirective {
    hostClass = true;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CardMediaDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: CardMediaDirective, isStandalone: true, selector: "[kendoCardMedia]", host: { properties: { "class.k-card-media": "this.hostClass" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CardMediaDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoCardMedia]',
                    standalone: true
                }]
        }], propDecorators: { hostClass: [{
                type: HostBinding,
                args: ['class.k-card-media']
            }] } });

/**
 * Defines the settings of the Card action buttons.
 */
class CardAction {
    /**
     * Specifies whether the action button uses primary styling.
     */
    primary;
    /**
     * Specifies whether the action button uses flat styling.
     */
    flat;
    /**
     * Defines the text of the action button.
     */
    text;
}

/**
 * Defines a template that specifies the content of the ExpansionPanel title.
 * To define the template, nest an `<ng-template>` tag with the `kendoExpansionPanelTitleDirective` directive inside the `<kendo-expansionpanel>` tag
 * ([see example]({% slug title_expansionpanel %}#toc-title-template)).
 *
 * @example
 * ```html
 * <kendo-expansionpanel>
 *   <ng-template kendoExpansionPanelTitleDirective>
 *     <h3>Custom Title</h3>
 *   </ng-template>
 *   <p>Panel content</p>
 * </kendo-expansionpanel>
 * ```
 */
class ExpansionPanelTitleDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ExpansionPanelTitleDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: ExpansionPanelTitleDirective, isStandalone: true, selector: "[kendoExpansionPanelTitleDirective]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ExpansionPanelTitleDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoExpansionPanelTitleDirective]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }] });

/**
 * @hidden
 */
function expand(duration, height) {
    return [
        style({ overflow: 'hidden', display: 'block', height: 0 }),
        animate(`${duration}ms ease-in`, style({ height: `${height}` }))
    ];
}
/**
 * @hidden
 */
function collapse(duration, height) {
    return [
        style({ overflow: 'hidden', height: `${height}` }),
        animate(`${duration}ms ease-in`, style({ overflow: 'hidden', height: 0 }))
    ];
}

/**
 * Defines the arguments for the `action` event of the ExpansionPanel.
 */
class ExpansionPanelActionEvent extends PreventableEvent$1 {
    /**
     * Defines the action that takes place upon interaction with the ExpansionPanel.
     */
    action;
    /**
     * @hidden
     */
    constructor(args) {
        super();
        Object.assign(this, args);
    }
}

const DEFAULT_DURATION = 200;
const CONTENT_HIDDEN_CLASS = 'k-hidden';
let incrementingId = 0;
/**
 * Represents the Kendo UI ExpansionPanel component for Angular. Provides an expandable and collapsible content container with customizable header and animation ([see overview]({% slug overview_expansionpanel %})).
 *
 * @example
 * ```html
 * <kendo-expansionpanel
 *   title="Chile"
 *   subtitle="South America"
 *   [expanded]="isExpanded">
 *   There are various theories about the origin of the word Chile.
 * </kendo-expansionpanel>
 * ```
 */
class ExpansionPanelComponent {
    renderer;
    hostElement;
    ngZone;
    localizationService;
    builder;
    /**
     * Specifies the primary text in the header of the ExpansionPanel
     * ([see example](slug:title_expansionpanel#toc-titles-and-subtitles)).
     */
    title = '';
    /**
     * Specifies the secondary text in the header of the ExpansionPanel, which renders next to the collapse/expand icon
     * ([see example](slug:title_expansionpanel#toc-titles-and-subtitles)).
     */
    subtitle = '';
    /**
     * Specifies whether the ExpansionPanel is disabled. If disabled, the ExpansionPanel can be neither expanded nor collapsed
     * ([see example]({% slug disabled_expansionpanel %})).
     *
     * @default false
     */
    disabled = false;
    /**
     * Specifies whether the ExpansionPanel is expanded. The property supports two-way binding
     * ([see example]({% slug interaction_expansionpanel %}#toc-setting-the-initial-state)).
     *
     * @default false
     */
    set expanded(value) {
        if (value === this.expanded) {
            return;
        }
        this._expanded = value;
        if (this.expanded) {
            this.removeContentHiddenClass();
        }
        else {
            this.addContentHiddenClass();
        }
    }
    get expanded() {
        return this._expanded;
    }
    /**
     * Defines an SVG icon for the expanded state of the component.
     * You can use either an [existing Kendo SVG icon](slug:svgicon_list) or a custom one.
     */
    set svgExpandIcon(icon) {
        if (isDevMode() && icon && this.expandIcon) {
            throw new Error('Setting both expandIcon/svgExpandIcon options at the same time is not supported.');
        }
        this._svgExpandIcon = icon;
    }
    get svgExpandIcon() {
        return this._svgExpandIcon;
    }
    /**
     * Defines an SVG icon for the collapsed state of the component.
     * You can use either an [existing Kendo SVG icon](slug:svgicon_list) or a custom one.
     */
    set svgCollapseIcon(icon) {
        if (isDevMode() && icon && this.collapseIcon) {
            throw new Error('Setting both collapseIcon/svgCollapseIcon options at the same time is not supported.');
        }
        this._svgCollapseIcon = icon;
    }
    get svgCollapseIcon() {
        return this._svgCollapseIcon;
    }
    /**
     * Sets a custom icon via CSS class(es) for the collapsed state of the component
     * ([see example]({% slug icons_expansionpanel %}#toc-icons)).
     */
    expandIcon;
    /**
     * Sets a custom icon via CSS class(es) for the expanded state of the component
     * ([see example]({% slug icons_expansionpanel %}#toc-icons)).
     */
    collapseIcon;
    /**
     * Specifies the animation settings of the ExpansionPanel
     * ([see example]({% slug animations_expansionpanel %})).
     *
     * @default true
     */
    animation = true;
    /**
     * Fires when the `expanded` property of the component is updated.
     * Used to provide a two-way binding for the `expanded` property
     * ([see example](slug:events_expansionpanel)).
     */
    expandedChange = new EventEmitter();
    /**
     * Fires when the expanded state of the ExpansionPanel is about to change. This event is preventable
     * ([see example](slug:events_expansionpanel)).
     */
    action = new EventEmitter();
    /**
     * Fires when the ExpansionPanel is expanded. If there is animation it fires when the animation is complete
     * ([see example](slug:events_expansionpanel)).
     */
    expand = new EventEmitter();
    /**
     * Fires when the ExpansionPanel is collapsed. If there is animation it fires when the animation is complete
     * ([see example](slug:events_expansionpanel)).
     */
    collapse = new EventEmitter();
    /**
     * @hidden
     */
    titleTemplate;
    content;
    header;
    hostClass = true;
    get expandedClass() {
        return this.expanded && !this.disabled;
    }
    direction;
    /**
     * @hidden
     */
    focused = false;
    animationEnd = new EventEmitter();
    subscriptions = new Subscription();
    _expanded = false;
    _svgExpandIcon = chevronDownIcon;
    _svgCollapseIcon = chevronUpIcon;
    nextId = incrementingId++;
    constructor(renderer, hostElement, ngZone, localizationService, builder) {
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.ngZone = ngZone;
        this.localizationService = localizationService;
        this.builder = builder;
        validatePackage(packageMetadata);
        this.direction = localizationService.rtl ? 'rtl' : 'ltr';
    }
    ngOnInit() {
        this.renderer.removeAttribute(this.hostElement.nativeElement, 'title');
        this.subscriptions = this.localizationService.changes.subscribe(({ rtl }) => { this.direction = rtl ? 'rtl' : 'ltr'; });
        const elem = this.hostElement.nativeElement;
        const header = this.header.nativeElement;
        this.subscriptions.add(this.renderer.listen(header, 'focus', () => this.focusExpansionPanel(elem)));
        this.subscriptions.add(this.renderer.listen(header, 'blur', () => this.blurExpansionPanel(elem)));
    }
    ngAfterViewInit() {
        this.initDomEvents();
        if (!this.expanded) {
            this.renderer.addClass(this.content.nativeElement, CONTENT_HIDDEN_CLASS);
        }
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    /**
     * @hidden
     */
    initDomEvents() {
        if (!this.hostElement) {
            return;
        }
        this.ngZone.runOutsideAngular(() => {
            const elem = this.hostElement.nativeElement;
            this.subscriptions.add(this.renderer.listen(elem, 'keydown', this.keyDownHandler.bind(this)));
        });
    }
    /**
     * @hidden
     */
    keyDownHandler(ev) {
        const isEnterOrSpace = ev.code === Keys.Enter || ev.code === Keys.NumpadEnter || ev.code === Keys.Space;
        if (this.disabled || !isEnterOrSpace) {
            return;
        }
        if (hasClass(ev.target, 'k-expander-header')) {
            ev.preventDefault();
            this.ngZone.run(() => {
                this.onHeaderAction();
            });
        }
    }
    /**
     * @hidden
     */
    onHeaderClick(ev) {
        const header = this.header.nativeElement;
        if (!isFocusable(ev.target) || (ev.target === header) && !this.disabled) {
            this.onHeaderAction();
        }
    }
    /**
     * @hidden
     */
    onHeaderAction() {
        const eventArgs = new ExpansionPanelActionEvent();
        eventArgs.action = this.expanded ? 'collapse' : 'expand';
        this.action.emit(eventArgs);
        if (!eventArgs.isDefaultPrevented()) {
            this.setExpanded(!this.expanded);
            if (this.expanded) {
                this.removeContentHiddenClass();
            }
            if (this.animation) {
                this.animateContent();
                return;
            }
            if (!this.expanded) {
                this.addContentHiddenClass();
            }
            this.emitExpandCollapseEvent();
        }
    }
    /**
     * @hidden
     */
    get contentWrapperId() {
        return `k-expansion-panel-content-wrapper-${this.nextId}`;
    }
    /**
     * @hidden
     */
    get expanderIndicatorClasses() {
        if (this.expanded) {
            return !this.collapseIcon ? `chevron-up` : '';
        }
        else {
            return !this.expandIcon ? `chevron-down` : '';
        }
    }
    /**
     * @hidden
     */
    get customExpanderIndicatorClasses() {
        if (this.expanded) {
            return this.collapseIcon ? this.collapseIcon : '';
        }
        else {
            return this.expandIcon ? this.expandIcon : '';
        }
    }
    /**
     * @hidden
     */
    get expanderSvgIcon() {
        return this.expanded ? this.svgCollapseIcon : this.svgExpandIcon;
    }
    /**
     * Toggles the visibility of the ExpansionPanel
     * ([see example](slug:interaction_expansionpanel#toggling-between-states)).
     *
     * @param expanded Specifies whether the ExpansionPanel will be expanded or collapsed.
     */
    toggle(expanded) {
        const previous = this.expanded;
        const current = isPresent(expanded) ? expanded : !previous;
        if (current === previous) {
            return;
        }
        this.setExpanded(current);
        if (this.expanded) {
            this.removeContentHiddenClass();
        }
        if (this.animation) {
            this.animateContent();
            return;
        }
        if (!this.expanded) {
            this.addContentHiddenClass();
        }
        this.emitExpandCollapseEvent();
    }
    focusExpansionPanel(el) {
        if (!this.focused) {
            this.focused = true;
            this.renderer.addClass(el, 'k-focus');
        }
    }
    blurExpansionPanel(el) {
        if (this.focused) {
            this.focused = false;
            this.renderer.removeClass(el, 'k-focus');
        }
    }
    setExpanded(value) {
        this._expanded = value;
        this.expandedChange.emit(value);
    }
    animateContent() {
        const duration = typeof this.animation === 'boolean' ? DEFAULT_DURATION : this.animation;
        const contentHeight = getComputedStyle(this.content.nativeElement).height;
        const animation = this.expanded ? expand(duration, contentHeight) : collapse(duration, contentHeight);
        const player = this.createPlayer(animation, this.content.nativeElement);
        this.animationEnd.pipe(take(1)).subscribe(() => {
            if (!this.expanded) {
                this.addContentHiddenClass();
            }
            this.emitExpandCollapseEvent();
        });
        player.play();
    }
    createPlayer(animation, animatedElement) {
        const factory = this.builder.build(animation);
        let player = factory.create(animatedElement);
        player.onDone(() => {
            if (player) {
                this.animationEnd.emit();
                player.destroy();
                player = null;
            }
        });
        return player;
    }
    emitExpandCollapseEvent() {
        this[this.expanded ? 'expand' : 'collapse'].emit();
    }
    addContentHiddenClass() {
        this.renderer.addClass(this.content.nativeElement, CONTENT_HIDDEN_CLASS);
    }
    removeContentHiddenClass() {
        this.renderer.removeClass(this.content.nativeElement, CONTENT_HIDDEN_CLASS);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ExpansionPanelComponent, deps: [{ token: i0.Renderer2 }, { token: i0.ElementRef }, { token: i0.NgZone }, { token: i1.LocalizationService }, { token: i1$2.AnimationBuilder }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: ExpansionPanelComponent, isStandalone: true, selector: "kendo-expansionpanel", inputs: { title: "title", subtitle: "subtitle", disabled: "disabled", expanded: "expanded", svgExpandIcon: "svgExpandIcon", svgCollapseIcon: "svgCollapseIcon", expandIcon: "expandIcon", collapseIcon: "collapseIcon", animation: "animation" }, outputs: { expandedChange: "expandedChange", action: "action", expand: "expand", collapse: "collapse" }, host: { properties: { "class.k-expander": "this.hostClass", "class.k-expanded": "this.expandedClass", "attr.dir": "this.direction" } }, providers: [
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.expansionpanel'
            }
        ], queries: [{ propertyName: "titleTemplate", first: true, predicate: ExpansionPanelTitleDirective, descendants: true }], viewQueries: [{ propertyName: "content", first: true, predicate: ["content"], descendants: true, static: true }, { propertyName: "header", first: true, predicate: ["header"], descendants: true, static: true }], exportAs: ["kendoExpansionPanel"], ngImport: i0, template: `
        <div
          #header
          [class.k-expander-header]="true"
          [class.k-disabled]="disabled"
          [attr.aria-disabled]="disabled"
          [attr.aria-expanded]="expanded && !disabled"
          role="button"
          tabindex="0"
          [attr.aria-controls]="contentWrapperId"
          (click)="onHeaderClick($event)"
          >
          @if (!titleTemplate) {
            @if (title) {
              <div class="k-expander-title">{{ title }}</div>
            }
            <span class="k-spacer"></span>
            @if (subtitle) {
              <div class="k-expander-sub-title">
                {{ subtitle }}
              </div>
            }
          }
          @if (titleTemplate) {
            <ng-template
              [ngTemplateOutlet]="titleTemplate?.templateRef">
            </ng-template>
          }
          <span class="k-expander-indicator">
            <kendo-icon-wrapper
              [name]="expanderIndicatorClasses"
              [customFontClass]="customExpanderIndicatorClasses"
              [svgIcon]="expanderSvgIcon"
              >
            </kendo-icon-wrapper>
          </span>
        </div>
        <div #content [id]="contentWrapperId" class="k-expander-content-wrapper">
          <div class="k-expander-content" [attr.aria-hidden]="!expanded">
            <ng-content></ng-content>
          </div>
        </div>
        `, isInline: true, dependencies: [{ kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ExpansionPanelComponent, decorators: [{
            type: Component,
            args: [{
                    exportAs: 'kendoExpansionPanel',
                    providers: [
                        LocalizationService,
                        {
                            provide: L10N_PREFIX,
                            useValue: 'kendo.expansionpanel'
                        }
                    ],
                    selector: 'kendo-expansionpanel',
                    template: `
        <div
          #header
          [class.k-expander-header]="true"
          [class.k-disabled]="disabled"
          [attr.aria-disabled]="disabled"
          [attr.aria-expanded]="expanded && !disabled"
          role="button"
          tabindex="0"
          [attr.aria-controls]="contentWrapperId"
          (click)="onHeaderClick($event)"
          >
          @if (!titleTemplate) {
            @if (title) {
              <div class="k-expander-title">{{ title }}</div>
            }
            <span class="k-spacer"></span>
            @if (subtitle) {
              <div class="k-expander-sub-title">
                {{ subtitle }}
              </div>
            }
          }
          @if (titleTemplate) {
            <ng-template
              [ngTemplateOutlet]="titleTemplate?.templateRef">
            </ng-template>
          }
          <span class="k-expander-indicator">
            <kendo-icon-wrapper
              [name]="expanderIndicatorClasses"
              [customFontClass]="customExpanderIndicatorClasses"
              [svgIcon]="expanderSvgIcon"
              >
            </kendo-icon-wrapper>
          </span>
        </div>
        <div #content [id]="contentWrapperId" class="k-expander-content-wrapper">
          <div class="k-expander-content" [attr.aria-hidden]="!expanded">
            <ng-content></ng-content>
          </div>
        </div>
        `,
                    standalone: true,
                    imports: [NgTemplateOutlet, IconWrapperComponent]
                }]
        }], ctorParameters: () => [{ type: i0.Renderer2 }, { type: i0.ElementRef }, { type: i0.NgZone }, { type: i1.LocalizationService }, { type: i1$2.AnimationBuilder }], propDecorators: { title: [{
                type: Input
            }], subtitle: [{
                type: Input
            }], disabled: [{
                type: Input
            }], expanded: [{
                type: Input
            }], svgExpandIcon: [{
                type: Input
            }], svgCollapseIcon: [{
                type: Input
            }], expandIcon: [{
                type: Input
            }], collapseIcon: [{
                type: Input
            }], animation: [{
                type: Input
            }], expandedChange: [{
                type: Output
            }], action: [{
                type: Output
            }], expand: [{
                type: Output
            }], collapse: [{
                type: Output
            }], titleTemplate: [{
                type: ContentChild,
                args: [ExpansionPanelTitleDirective, { static: false }]
            }], content: [{
                type: ViewChild,
                args: ['content', { static: true }]
            }], header: [{
                type: ViewChild,
                args: ['header', { static: true }]
            }], hostClass: [{
                type: HostBinding,
                args: ['class.k-expander']
            }], expandedClass: [{
                type: HostBinding,
                args: ['class.k-expanded']
            }], direction: [{
                type: HostBinding,
                args: ['attr.dir']
            }] } });

/**
 * @hidden
 */
let idx = 0;
/**
 * @hidden
 */
const getId = (prefix) => {
    return `${prefix}-${++idx}`;
};
/**
 * @hidden
 */
const normalizeValue = (value, max = Infinity) => {
    const normalizedValue = isPresent(value) ? Math.min(Math.max(+value, 1), max) : value;
    return normalizedValue;
};
/**
 * @hidden
 */
const isRowItemPresent = (items) => {
    return items.some(item => isPresent(item.row));
};
/**
 * @hidden
 */
const propsChanged = (initialProps, newProps) => {
    for (let i = 0; i < initialProps.length; i++) {
        if (initialProps[i] !== newProps[i]) {
            return true;
        }
    }
    return false;
};
/**
 * @hidden
 *
 * Extracts the event target from the viewport coords. Required for touch devices
 * where the `event.target` of a `pointermove` event is always the initially dragged item.
 */
const getDropTarget = (event) => {
    if (!(isDocumentAvailable() && isPresent(document.elementsFromPoint))) {
        return [event.target];
    }
    return document.elementsFromPoint(event.clientX, event.clientY)
        .filter(item => item.classList && (item.classList.contains('k-tilelayout-item') || item.classList.contains('k-layout-item-hint')));
};
/**
 * @hidden
 */
const setElementStyles = (renderer, elem, styles) => {
    const props = Object.keys(styles);
    props.forEach(p => {
        renderer.setStyle(elem, p, styles[p]);
    });
};
/**
 * @hidden
 */
const calculateCellFromPosition = (coordinates, tileLayoutElement, gap, cellSize, columns, rtl = false) => {
    const tileLayoutRect = tileLayoutElement.getBoundingClientRect();
    const totalRows = (tileLayoutRect.height - gap.rows) / (cellSize.height + gap.rows);
    const distanceFromTop = coordinates.y - tileLayoutRect.y;
    const distanceFromLeft = coordinates.x - tileLayoutRect.x;
    const distanceFromRight = tileLayoutRect.right - coordinates.x;
    const distanceToCellWidthRatio = Math.floor((rtl ? distanceFromRight : distanceFromLeft) / (gap.columns + cellSize.width));
    const cappedColumnPosition = Math.min(distanceToCellWidthRatio + 1, columns);
    const distanceToCellHeightRatio = Math.floor(distanceFromTop / (gap.rows + cellSize.height));
    const cappedRowPosition = Math.min(distanceToCellHeightRatio + 1, totalRows);
    const col = Math.max(cappedColumnPosition, 0);
    const row = Math.max(cappedRowPosition, 0);
    return {
        row, col
    };
};
/**
 * @hidden
 */
const calculateOrderFromCell = (row, col, items, draggedItem, tileLayoutElement, gap, cellSize, columns) => {
    let order = 0;
    items.forEach(item => {
        const rect = item.elem.nativeElement.getBoundingClientRect();
        const start = calculateCellFromPosition({
            x: rect.x,
            y: rect.y
        }, tileLayoutElement, gap, cellSize, columns);
        if (item !== draggedItem && ((start.row === row && start.col < col) || start.row < row)) {
            order++;
        }
    });
    return order;
};
/**
 * @hidden
 */
const shouldResize = (keyCode, col, selectedTile, settings) => {
    const resizeRight = keyCode === Keys.ArrowRight && col + selectedTile.colSpan <= settings.columns;
    const resizeLeft = keyCode === Keys.ArrowLeft && selectedTile.colSpan > 1;
    const resizeDown = keyCode === Keys.ArrowDown;
    const resizeUp = keyCode === Keys.ArrowUp && selectedTile.rowSpan > 1;
    return { resizeRight, resizeLeft, resizeDown, resizeUp };
};
/**
 * @hidden
 */
const shouldReorder = (keyCode, col, selectedTile, settings) => {
    let reorderRight;
    let reorderLeft;
    if (selectedTile.col) {
        reorderRight = keyCode === Keys.ArrowRight && selectedTile.colSpan + col <= settings.columns;
        reorderLeft = keyCode === Keys.ArrowLeft && col > 1;
    }
    else {
        reorderRight = keyCode === Keys.ArrowRight && selectedTile.colSpan + selectedTile.order < settings.items.length;
        reorderLeft = keyCode === Keys.ArrowLeft && selectedTile.order > 0;
    }
    return { reorderLeft, reorderRight };
};
/**
 * @hidden
 */
const getCurrentCol = (selectedTile, settings, rtl) => {
    const rects = selectedTile.elem.nativeElement.getBoundingClientRect();
    const targetSize = {
        rowSpan: selectedTile.rowSpan,
        colSpan: selectedTile.colSpan
    };
    const width = (rects.width - ((targetSize.colSpan - 1) * settings.gap.columns)) / targetSize.colSpan;
    const height = (rects.height - ((targetSize.rowSpan - 1) * settings.gap.rows)) / targetSize.rowSpan;
    const { col } = calculateCellFromPosition({ x: rects.x, y: rects.y }, settings.tileLayoutElement, settings.gap, { width: width, height: height }, settings.columns, rtl);
    return col;
};

/**
 * @hidden
 */
const RESIZE_HANDLE_UNIDIRECTIONAL_SIZE = 9;
/**
 * @hidden
 */
const RESIZE_HANDLE_BIDIRECTIONAL_SIZE = 25;
/**
 * @hidden
 */
const RESIZE_HANDLE_UNIDIRECTIONAL_OVERLAP = 5;
/**
 * @hidden
 */
const RESIZE_HANDLE_BIDIRECTIONAL_OVERLAP = 18;
/**
 * @hidden
 */
const DRAGGED_ZINDEX = 10;
/**
 * @hidden
 */
const RESIZE_DIRECTIONS = ['ew', 'ns', 'nwse'];
/**
 * @hidden
 */
const RTL_RESIZE_DIRECTIONS = ['ew', 'ns', 'nesw'];
/**
 * @hidden
 */
const RESIZE_HANDLE_DIMENSIONS = {
    // numeric values represent pixels
    ew: {
        width: RESIZE_HANDLE_UNIDIRECTIONAL_SIZE,
        overlapX: RESIZE_HANDLE_UNIDIRECTIONAL_OVERLAP
    },
    ns: {
        height: RESIZE_HANDLE_UNIDIRECTIONAL_SIZE,
        overlapY: RESIZE_HANDLE_UNIDIRECTIONAL_OVERLAP
    },
    nwse: {
        width: RESIZE_HANDLE_BIDIRECTIONAL_SIZE,
        height: RESIZE_HANDLE_BIDIRECTIONAL_SIZE,
        overlapX: RESIZE_HANDLE_BIDIRECTIONAL_OVERLAP,
        overlapY: RESIZE_HANDLE_BIDIRECTIONAL_OVERLAP
    },
    nesw: {
        width: RESIZE_HANDLE_BIDIRECTIONAL_SIZE,
        height: RESIZE_HANDLE_BIDIRECTIONAL_SIZE,
        overlapX: RESIZE_HANDLE_BIDIRECTIONAL_OVERLAP,
        overlapY: RESIZE_HANDLE_BIDIRECTIONAL_OVERLAP
    }
};
/**
 * @hidden
 */
const OVERLAP_THRESHOLD = 0.3;
/**
 * @hidden
 */
const REVERSE_OVERLAP_THRESHOLD = -0.7;
/**
 * @hidden
 */
const HINT_BORDERS_HEIGHT = 2;

/**
 * Arguments for the `reorder` event.
 * The event fires when you change the order or starting positions of items through the UI.
 * You can prevent this event to cancel the reorder operation.
 */
class TileLayoutReorderEvent extends PreventableEvent$1 {
    item;
    items;
    newIndex;
    oldIndex;
    newCol;
    oldCol;
    newRow;
    oldRow;
    /**
     * Constructs the event arguments for the `reorder` event.
     * @param item - The TileLayoutItem being reordered.
     * @param items - The TileLayoutItem collection that holds the currently rendered items and their internal state.
     * @param newIndex - The new order index of the reordered item used to determine its positioning relative to the other items.
     * @param oldIndex - The initial order index of the reordered item used to determine its positioning relative to the other items.
     * @param newCol - The new start column of the reordered item.
     * @param oldCol - The initial start column of the reordered item.
     * @param newRow - The new start row of the reordered item.
     * @param oldRow - The initial start row of the reordered item.
     * @hidden
     */
    constructor(item, items, newIndex, oldIndex, newCol, oldCol, newRow, oldRow) {
        super();
        this.item = item;
        this.items = items;
        this.newIndex = newIndex;
        this.oldIndex = oldIndex;
        this.newCol = newCol;
        this.oldCol = oldCol;
        this.newRow = newRow;
        this.oldRow = oldRow;
    }
}

/**
 * Arguments for the `resize` event.
 * The `resize` event fires when you change any item size through the UI.
 * You can prevent this event to stop the resize operation.
 */
class TileLayoutResizeEvent extends PreventableEvent$1 {
    item;
    items;
    newRowSpan;
    oldRowSpan;
    newColSpan;
    oldColSpan;
    /**
     * Constructs the event arguments for the `resize` event.
     * @param item - The TileLayoutItem being resized
     * @param items - The TileLayoutItem collection
     * @param newRowSpan - The new rowSpan of the resized item
     * @param oldRowSpan - The initial rowSpan of the resized item
     * @param newColSpan - The new colSpan of the resized item
     * @param oldColSpan - The initial colSpan of the resized item
     * @hidden
     */
    constructor(item, items, newRowSpan, oldRowSpan, newColSpan, oldColSpan) {
        super();
        this.item = item;
        this.items = items;
        this.newRowSpan = newRowSpan;
        this.oldRowSpan = oldRowSpan;
        this.newColSpan = newColSpan;
        this.oldColSpan = oldColSpan;
    }
}

/**
 * @hidden
 */
class TileLayoutDraggingService {
    zone;
    renderer;
    cdr;
    localization;
    reorderable = new BehaviorSubject(null);
    resizable = new BehaviorSubject(null);
    reorder = new Subject();
    resize = new Subject();
    tileLayoutSettings;
    get colStart() {
        return this.currentColStart;
    }
    get rowStart() {
        return this.currentRowStart;
    }
    get itemWrapper() {
        return this.draggedItemWrapper;
    }
    get order() {
        return this.targetOrder;
    }
    draggedItem;
    draggedItemWrapper;
    reordering;
    resizing;
    offset;
    targetSize;
    cellSize;
    targetOrder;
    currentColStart;
    currentRowStart;
    startingPoint;
    currentResizingColSpan;
    currentResizingRowSpan;
    direction;
    lastDragCursorOffset = {
        x: 0,
        y: 0
    };
    localizationSubscription;
    rtl;
    constructor(zone, renderer, cdr, localization) {
        this.zone = zone;
        this.renderer = renderer;
        this.cdr = cdr;
        this.localization = localization;
        this.localizationSubscription = this.localization.changes.subscribe(({ rtl }) => this.rtl = rtl);
    }
    ngOnDestroy() {
        this.localizationSubscription.unsubscribe();
    }
    handlePress(originalEvent) {
        const resizing = !!originalEvent.target.classList.contains('k-resize-handle');
        const closestTile = closestInScope(originalEvent.target, el => el.classList.contains('k-tilelayout-item'), this.tileLayoutSettings.tileLayoutElement);
        const closestHeader = closestInScope(originalEvent.target, el => el.classList.contains('k-tilelayout-item-header'), this.tileLayoutSettings.tileLayoutElement);
        if (!closestTile) {
            return;
        }
        this.zone.run(() => {
            this.draggedItemWrapper = closestTile;
            this.draggedItem = this.tileLayoutSettings.items
                .find(item => item.order === +closestTile.style.order);
        });
        const reordering = !resizing && this.reorderable.getValue() && this.draggedItem.reorderable && closestHeader;
        const focusableTarget = isFocusable(originalEvent.target);
        if (!(reordering || resizing) || focusableTarget) {
            return;
        }
        else {
            originalEvent.preventDefault();
        }
        this.zone.run(() => {
            this.reordering = reordering;
            this.resizing = resizing;
        });
        const tileRect = this.draggedItemWrapper.getBoundingClientRect();
        this.zone.run(() => {
            this.offset = {
                top: originalEvent.clientY - tileRect.top,
                left: originalEvent.clientX - tileRect.left,
                x: tileRect.x,
                y: tileRect.y,
                width: tileRect.width,
                height: tileRect.height
            };
            this.targetSize = {
                rowSpan: this.draggedItem.rowSpan,
                colSpan: this.draggedItem.colSpan
            };
            this.cellSize = {
                width: (tileRect.width - ((this.targetSize.colSpan - 1) * this.tileLayoutSettings.gap.columns)) / this.targetSize.colSpan,
                height: (tileRect.height - ((this.targetSize.rowSpan - 1) * this.tileLayoutSettings.gap.rows)) / this.targetSize.rowSpan
            };
            this.lastDragCursorOffset = {
                x: originalEvent.clientX,
                y: originalEvent.clientY
            };
        });
        setElementStyles(this.renderer, this.draggedItemWrapper, {
            left: tileRect.left + window.pageXOffset - window.scrollX + 'px',
            top: tileRect.top + window.pageYOffset - window.scrollY + 'px',
            width: tileRect.width + 'px',
            height: tileRect.height + 'px',
            zIndex: DRAGGED_ZINDEX
        });
        setElementStyles(this.renderer, this.tileLayoutSettings.hintElement, {
            display: 'flex',
            height: (tileRect.height - HINT_BORDERS_HEIGHT) + 'px'
        });
        this.zone.run(() => this.targetOrder = this.draggedItem.order);
        this.cdr.markForCheck();
        setElementStyles(this.renderer, this.draggedItemWrapper, {
            position: 'fixed'
        });
        if (this.reorderable.getValue() && !resizing) {
            this.zone.run(() => {
                this.currentColStart = this.draggedItem.colStart;
                this.currentRowStart = this.draggedItem.rowStart;
            });
            this.cdr.markForCheck();
        }
        else if (this.resizable && resizing) {
            this.zone.run(() => {
                this.startingPoint = {
                    top: originalEvent.clientY,
                    left: originalEvent.clientX
                };
                this.currentResizingColSpan = this.draggedItem.colSpan;
                this.currentResizingRowSpan = this.draggedItem.rowSpan;
                if (this.draggedItem.col) {
                    this.currentColStart = this.draggedItem.col.toString();
                }
                if (this.draggedItem.row) {
                    this.currentRowStart = this.draggedItem.row.toString();
                }
                this.direction = originalEvent.target.classList[1];
            });
        }
    }
    handleDrag(originalEvent) {
        if (this.draggedItemWrapper) {
            if (this.reordering) {
                this.reorderItems(originalEvent);
            }
            else if (this.resizing) {
                this.resizeItem(originalEvent);
            }
            this.lastDragCursorOffset = {
                x: originalEvent.clientX,
                y: originalEvent.clientY
            };
        }
    }
    handleRelease(originalEvent) {
        originalEvent.preventDefault();
        if (this.reordering) {
            const initialOrder = this.draggedItem.order;
            const initialCol = this.draggedItem.col;
            const initialRow = this.draggedItem.row;
            const targetCol = normalizeValue(this.currentColStart);
            const targetRow = normalizeValue(this.currentRowStart);
            if (propsChanged([this.targetOrder, targetCol, targetRow], [initialOrder, initialCol, initialRow])) {
                const reorderEvent = new TileLayoutReorderEvent(this.draggedItem, this.tileLayoutSettings.items, this.targetOrder, initialOrder, targetCol, initialCol, targetRow, initialRow);
                this.reorder.next(reorderEvent);
                if (!reorderEvent.isDefaultPrevented()) {
                    if (this.targetOrder > initialOrder) {
                        this.zone.run(() => {
                            for (let i = initialOrder + 1; i <= this.targetOrder; i++) {
                                const item = this.tileLayoutSettings.items.find(item => item.order === i);
                                item && (item.order = i - 1);
                            }
                        });
                    }
                    else {
                        this.zone.run(() => {
                            for (let i = initialOrder - 1; i >= this.targetOrder; i--) {
                                const item = this.tileLayoutSettings.items.find(item => item.order === i);
                                item && (item.order = i + 1);
                            }
                        });
                    }
                    this.draggedItem.order = this.targetOrder;
                    if (this.draggedItem.col) {
                        this.draggedItem.col = +this.currentColStart;
                    }
                    if (this.draggedItem.row) {
                        this.draggedItem.row = +this.currentRowStart;
                    }
                }
            }
            this.tileLayoutSettings.tileLayoutElement.appendChild(this.tileLayoutSettings.hintElement);
            this.cdr.markForCheck();
            this.zone.run(() => this.cleanUp());
        }
        else if (!this.reordering && this.resizing) {
            const initialRowSpan = this.draggedItem.rowSpan;
            const initialColSpan = this.draggedItem.colSpan;
            const { targetColSpan, targetRowSpan } = isRowItemPresent(this.tileLayoutSettings.items) ?
                this.targetSpan() :
                { targetColSpan: this.currentResizingColSpan, targetRowSpan: this.currentResizingRowSpan };
            if (propsChanged([initialRowSpan, initialColSpan], [targetRowSpan, targetColSpan])) {
                const resizeEvent = new TileLayoutResizeEvent(this.draggedItem, this.tileLayoutSettings.items, targetRowSpan, initialRowSpan, targetColSpan, initialColSpan);
                this.resize.next(resizeEvent);
                if (!resizeEvent.isDefaultPrevented()) {
                    this.draggedItem.colSpan = this.currentResizingColSpan;
                    this.draggedItem.rowSpan = this.currentResizingRowSpan;
                }
            }
            this.zone.run(() => this.cleanUp());
        }
    }
    reorderItems(event) {
        const targets = getDropTarget(event);
        const closestTile = targets.find(t => t !== this.draggedItemWrapper);
        const tileOrder = closestTile ? +closestTile.style.order : +this.draggedItemWrapper.style.order;
        if (this.tileLayoutSettings.autoFlow !== 'none') {
            const deltaX = event.clientX - this.lastDragCursorOffset.x;
            const deltaY = event.clientY - this.lastDragCursorOffset.y;
            const directionX = deltaX > 0 ? 'right' : deltaX < 0 ? 'left' : undefined;
            const directionY = deltaY > 0 ? 'down' : deltaX < 0 ? 'up' : undefined;
            const rect = this.draggedItemWrapper.getBoundingClientRect();
            const horizontalGap = this.tileLayoutSettings.gap.columns;
            const verticalGap = this.tileLayoutSettings.gap.rows;
            if (directionX && this.draggedItem.col) {
                const { col } = calculateCellFromPosition({
                    x: directionX === 'right' ? rect.right - horizontalGap : rect.left + horizontalGap,
                    y: event.clientY
                }, this.tileLayoutSettings.tileLayoutElement, this.tileLayoutSettings.gap, this.cellSize, this.tileLayoutSettings.columns, this.rtl);
                const targetStartCol = this.getTargetCol(col, directionX);
                this.currentColStart = targetStartCol.toString();
            }
            if (directionY && this.draggedItem.row) {
                const { row } = calculateCellFromPosition({
                    x: event.clientX,
                    y: directionY === 'down' ? rect.bottom - verticalGap : rect.top + verticalGap
                }, this.tileLayoutSettings.tileLayoutElement, this.tileLayoutSettings.gap, this.cellSize, this.tileLayoutSettings.columns, this.rtl);
                const targetStartRow = this.getTargetRow(row, directionY);
                this.currentRowStart = targetStartRow.toString();
            }
        }
        const hintBefore = tileOrder < this.targetOrder;
        const hintAfter = tileOrder > this.targetOrder;
        this.zone.run(() => this.targetOrder = tileOrder);
        if (hintBefore) {
            this.tileLayoutSettings.tileLayoutElement
                .insertBefore(this.tileLayoutSettings.hintElement, this.tileLayoutSettings.tileLayoutElement.firstChild);
        }
        else if (hintAfter) {
            this.tileLayoutSettings.tileLayoutElement.appendChild(this.tileLayoutSettings.hintElement);
        }
        setElementStyles(this.renderer, this.draggedItemWrapper, {
            top: (event.pageY - this.offset.top - window.scrollY) + 'px',
            left: (event.pageX - this.offset.left - window.scrollX) + 'px'
        });
        this.cdr.markForCheck();
    }
    resizeItem(event) {
        setElementStyles(this.renderer, this.tileLayoutSettings.tileLayoutElement, {
            cursor: this.direction.split('k-cursor-')[1]
        });
        const currentWidth = this.rtl ?
            this.offset.width + (this.offset.x - event.clientX) :
            this.offset.width + (event.clientX - this.startingPoint.left);
        const currentHeight = this.offset.height + (event.clientY - this.startingPoint.top);
        const hintRect = this.tileLayoutSettings.hintElement.getBoundingClientRect();
        const hintWidth = hintRect.width;
        const hintHeight = hintRect.height;
        const horizontalDragDirection = event.clientX - this.lastDragCursorOffset.x;
        const verticalDragDirection = event.clientY - this.lastDragCursorOffset.y;
        const startCol = this.draggedItem.col ? this.draggedItem.col : calculateCellFromPosition({
            x: this.rtl ? hintRect.right : hintRect.x,
            y: hintRect.y
        }, this.tileLayoutSettings.tileLayoutElement, this.tileLayoutSettings.gap, this.cellSize, this.tileLayoutSettings.columns, this.rtl).col;
        const maxWidth = (this.tileLayoutSettings.columns - startCol) * (this.cellSize.width + this.tileLayoutSettings.gap.columns) + this.cellSize.width;
        const resizeHorizontally = () => {
            setElementStyles(this.renderer, this.draggedItemWrapper, {
                width: Math.min(Math.max(currentWidth, this.cellSize.width), maxWidth) + 'px'
            });
            if (this.rtl && currentWidth > this.cellSize.width) {
                const totalWidth = this.tileLayoutSettings.columns * (this.cellSize.width + this.tileLayoutSettings.gap.columns);
                const leftBoundary = this.tileLayoutSettings.tileLayoutElement.getBoundingClientRect().right - totalWidth;
                setElementStyles(this.renderer, this.draggedItemWrapper, {
                    left: Math.max(event.clientX, leftBoundary) + 'px'
                });
            }
            const deltaX = currentWidth - hintWidth;
            const { x, y, right } = this.draggedItem.elem.nativeElement.getBoundingClientRect();
            const { col } = calculateCellFromPosition({ x: (this.rtl ? right : x), y: y }, this.tileLayoutSettings.tileLayoutElement, this.tileLayoutSettings.gap, this.cellSize, this.tileLayoutSettings.columns, this.rtl);
            const resizedColSpan = col + this.currentResizingColSpan;
            const expandingCondition = this.rtl ? horizontalDragDirection < 0 : horizontalDragDirection > 0;
            const shrinkingCondition = this.rtl ? horizontalDragDirection > 0 : horizontalDragDirection < 0;
            if (deltaX > OVERLAP_THRESHOLD * this.cellSize.width &&
                expandingCondition &&
                resizedColSpan <= this.tileLayoutSettings.columns) {
                this.currentResizingColSpan++;
            }
            else if (this.currentResizingColSpan > 1 &&
                shrinkingCondition &&
                deltaX < REVERSE_OVERLAP_THRESHOLD * this.cellSize.width) {
                this.currentResizingColSpan--;
            }
            setElementStyles(this.renderer, this.tileLayoutSettings.hintElement, {
                gridColumnEnd: `span ${this.currentResizingColSpan}`
            });
        };
        const resizeVertically = () => {
            setElementStyles(this.renderer, this.draggedItemWrapper, {
                height: Math.max(currentHeight, this.cellSize.height) + 'px'
            });
            const deltaY = currentHeight - hintHeight;
            if (deltaY > OVERLAP_THRESHOLD * this.cellSize.height && verticalDragDirection > 0) {
                this.currentResizingRowSpan++;
            }
            else if (this.currentResizingRowSpan > 1 &&
                verticalDragDirection < 0 && deltaY < REVERSE_OVERLAP_THRESHOLD * this.cellSize.height) {
                this.currentResizingRowSpan--;
            }
            setElementStyles(this.renderer, this.tileLayoutSettings.hintElement, {
                gridRowEnd: `span ${this.currentResizingRowSpan}`
            });
            setElementStyles(this.renderer, this.tileLayoutSettings.hintElement, {
                height: `${this.calculateHintHeight()}px`
            });
        };
        if (this.direction.indexOf('ew') > -1) {
            resizeHorizontally();
        }
        else if (this.direction.indexOf('ns') > -1) {
            resizeVertically();
        }
        else {
            resizeHorizontally();
            resizeVertically();
        }
    }
    cleanUp() {
        this.targetOrder = this.currentResizingColSpan = this.currentColStart = this.currentResizingRowSpan = this.currentRowStart = undefined;
        this.resizing = this.reordering = false;
        this.direction = null;
        if (this.draggedItemWrapper) {
            setElementStyles(this.renderer, this.draggedItemWrapper, {
                top: '',
                left: '',
                display: '',
                width: '',
                height: '',
                zIndex: '',
                position: ''
            });
            setElementStyles(this.renderer, this.tileLayoutSettings.hintElement, {
                display: 'none',
                height: 'auto'
            });
            setElementStyles(this.renderer, this.tileLayoutSettings.tileLayoutElement, {
                cursor: 'default'
            });
            this.draggedItemWrapper =
                this.offset =
                    this.draggedItem =
                        this.resizing =
                            this.reordering =
                                this.currentResizingColSpan =
                                    this.currentResizingRowSpan =
                                        this.startingPoint = undefined;
            this.lastDragCursorOffset = {
                x: 0,
                y: 0
            };
        }
    }
    targetSpan() {
        const itemRect = this.draggedItem.elem.nativeElement.getBoundingClientRect();
        const startingCell = calculateCellFromPosition({ x: this.rtl ? itemRect.right : itemRect.x, y: itemRect.y }, this.tileLayoutSettings.tileLayoutElement, this.tileLayoutSettings.gap, this.cellSize, this.tileLayoutSettings.columns, this.rtl);
        const targetEndCell = calculateCellFromPosition({
            x: this.rtl ? itemRect.x + OVERLAP_THRESHOLD * this.cellSize.width : itemRect.right - OVERLAP_THRESHOLD * this.cellSize.width,
            y: itemRect.bottom - OVERLAP_THRESHOLD * this.cellSize.height
        }, this.tileLayoutSettings.tileLayoutElement, this.tileLayoutSettings.gap, this.cellSize, this.tileLayoutSettings.columns, this.rtl);
        return {
            targetColSpan: targetEndCell.col - startingCell.col + 1,
            targetRowSpan: targetEndCell.row - startingCell.row + 1
        };
    }
    getTargetCol(col, direction) {
        if (this.rtl) {
            return normalizeValue(direction === 'left' ? col - this.draggedItem.colSpan + 1 : col, this.tileLayoutSettings.columns);
        }
        return normalizeValue(direction === 'right' ? col - this.draggedItem.colSpan + 1 : col);
    }
    getTargetRow(row, direction) {
        return direction === 'down' ? row - this.draggedItem.rowSpan + 1 : row;
    }
    calculateHintHeight() {
        const totalHintCellsHeight = this.currentResizingRowSpan * this.cellSize.height;
        const totalHintGapsHeight = (this.currentResizingRowSpan - 1) * this.tileLayoutSettings.gap.rows;
        const hintHeight = totalHintCellsHeight + totalHintGapsHeight - HINT_BORDERS_HEIGHT;
        return hintHeight;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TileLayoutDraggingService, deps: [{ token: i0.NgZone }, { token: i0.Renderer2 }, { token: i0.ChangeDetectorRef }, { token: i1.LocalizationService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TileLayoutDraggingService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TileLayoutDraggingService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: i0.NgZone }, { type: i0.Renderer2 }, { type: i0.ChangeDetectorRef }, { type: i1.LocalizationService }] });

/* eslint-disable no-unused-expressions */
/**
 * @hidden
 */
class TileLayoutKeyboardNavigationService {
    zone;
    renderer;
    localization;
    navigable = new BehaviorSubject(true);
    owner;
    mousedown;
    localizationSubscription;
    rtl;
    lastFocused;
    constructor(zone, renderer, localization) {
        this.zone = zone;
        this.renderer = renderer;
        this.localization = localization;
        this.localizationSubscription = this.localization.changes.subscribe(({ rtl }) => this.rtl = rtl);
    }
    ngOnDestroy() {
        this.localizationSubscription.unsubscribe();
    }
    onKeyDown(event, elem, focusableItems, settings) {
        const keyCode = normalizeKeys(event);
        const isTileFocused = document.activeElement === elem;
        const focusedTile = settings.items.find(item => item.elem.nativeElement === elem);
        const col = getCurrentCol(focusedTile, settings, this.rtl);
        const isArrow = [Keys.ArrowLeft, Keys.ArrowRight, Keys.ArrowDown, Keys.ArrowUp].some(key => key === keyCode);
        this.lastFocused = focusedTile;
        if (keyCode === Keys.Enter && isTileFocused && focusableItems.length > 0) {
            this.changeTabIndex('0', elem, focusableItems);
            focusableItems[0].focus();
        }
        else if (keyCode === Keys.Escape) {
            this.changeTabIndex('-1', elem, focusableItems);
            elem.focus();
        }
        else if (isArrow && (event.ctrlKey || event.metaKey) && isTileFocused && focusedTile.isResizable) {
            event.preventDefault();
            this.zone.run(() => {
                this.resizeItem(keyCode, focusedTile, settings, col);
            });
        }
        else if (isArrow && event.shiftKey && isTileFocused && focusedTile.isReorderable) {
            this.zone.run(() => {
                this.reorderItem(keyCode, focusedTile, settings, col);
            });
        }
        else if (keyCode === Keys.Tab) {
            if (!isTileFocused) {
                this.keepFocusWithinComponent(event, elem);
            }
            else {
                const dir = event.shiftKey ? -1 : 1;
                const nextFocusableTileOrder = focusedTile.order + dir;
                if (nextFocusableTileOrder < 0 || nextFocusableTileOrder >= settings.items.length) {
                    const first = settings.items[0];
                    const last = settings.items[settings.items.length - 1];
                    if (dir > 0) {
                        last.focus();
                    }
                    else {
                        first.focus();
                    }
                    return;
                }
                event.preventDefault();
                this.lastFocused = settings.items.find(item => item.order === nextFocusableTileOrder);
                this.lastFocused?.focus();
            }
        }
    }
    onFocusOut(event, elem, focusableItems) {
        const isTargetFocusable = focusableItems.includes(event.target);
        const isRelatedTargetFocusable = focusableItems.includes(event.relatedTarget);
        if (isTargetFocusable && !isRelatedTargetFocusable) {
            this.changeTabIndex('-1', elem, focusableItems);
            event.relatedTarget?.focus();
        }
    }
    onMousedown(event, elem, focusableItems, tile) {
        this.mousedown = true;
        const isTargetFocusable = focusableItems.includes(event.target);
        this.lastFocused = tile;
        if (isTargetFocusable) {
            this.changeTabIndex('0', elem, focusableItems);
            event.target.focus();
        }
    }
    changeTabIndex(tabIndex, elem, focusableItems) {
        this.renderer.setAttribute(elem, 'tabindex', tabIndex === '0' ? '-1' : '0');
        focusableItems.forEach((focusItem) => {
            this.renderer.setAttribute(focusItem, 'tabindex', tabIndex);
        });
    }
    getAllFocusableChildren(parent) {
        return Array.from(parent.querySelectorAll(focusableSelector)).filter((element) => element.offsetParent !== null);
    }
    returnFocus() {
        this.lastFocused ? this.lastFocused.focus() : this.owner.items.find(item => item.order === 0).focus();
    }
    resizeItem(keyCode, focusedTile, settings, col) {
        const { resizeRight, resizeLeft, resizeDown, resizeUp } = shouldResize(keyCode, col, focusedTile, settings);
        const resizeHorizontal = resizeLeft || resizeRight;
        const resizeVertical = resizeDown || resizeUp;
        const resizeDir = resizeLeft || resizeUp ? -1 : 1;
        if (!(resizeHorizontal || resizeVertical)) {
            return;
        }
        const resizeEvent = new TileLayoutResizeEvent(focusedTile, this.owner.items ? this.owner.items.toArray() : [], focusedTile.rowSpan + resizeDir, focusedTile.rowSpan, focusedTile.colSpan + resizeDir, focusedTile.colSpan);
        this.owner.resize.emit(resizeEvent);
        if (!resizeEvent.isDefaultPrevented()) {
            if (resizeHorizontal) {
                focusedTile.colSpan += resizeDir;
            }
            else if (resizeVertical) {
                focusedTile.rowSpan += resizeDir;
            }
        }
    }
    reorderItem(keyCode, focusedTile, settings, col) {
        const { reorderLeft, reorderRight } = shouldReorder(keyCode, col, focusedTile, settings);
        if (!(reorderLeft || reorderRight)) {
            return;
        }
        const reorder = (dir) => {
            const relatedTile = this.targetTile(focusedTile, settings.items, dir);
            if (relatedTile) {
                relatedTile.order -= dir;
                if (relatedTile.col) {
                    relatedTile.col -= dir;
                }
                focusedTile.order += dir;
                if (focusedTile.col) {
                    focusedTile.col += dir;
                }
            }
        };
        const reorderDir = reorderRight ? 1 : -1;
        const reorderEvent = new TileLayoutReorderEvent(focusedTile, this.owner.items ? this.owner.items.toArray() : [], focusedTile.order + reorderDir, focusedTile.order, focusedTile.col ? focusedTile.col + reorderDir : undefined, focusedTile.col, focusedTile.row, focusedTile.row);
        this.owner.reorder.next(reorderEvent);
        if (!reorderEvent.isDefaultPrevented()) {
            reorder(reorderDir);
        }
    }
    keepFocusWithinComponent(event, wrapper) {
        const [firstFocusable, lastFocusable] = this.getFirstAndLastFocusable(wrapper);
        const tabAfterLastFocusable = !event.shiftKey && event.target === lastFocusable;
        const shiftTabAfterFirstFocusable = event.shiftKey && event.target === firstFocusable;
        if (tabAfterLastFocusable) {
            event.preventDefault();
            firstFocusable.focus();
            wrapper.blur();
        }
        if (shiftTabAfterFirstFocusable) {
            event.preventDefault();
            lastFocusable.focus();
        }
    }
    getFirstAndLastFocusable(parent) {
        const all = this.getAllFocusableChildren(parent);
        const firstFocusable = all.length > 0 ? all[0] : parent;
        const lastFocusable = all.length > 0 ? all[all.length - 1] : parent;
        return [firstFocusable, lastFocusable];
    }
    targetTile(focusedTile, items, offset) {
        return items.find(item => item.order === focusedTile.order + offset);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TileLayoutKeyboardNavigationService, deps: [{ token: i0.NgZone }, { token: i0.Renderer2 }, { token: i1.LocalizationService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TileLayoutKeyboardNavigationService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TileLayoutKeyboardNavigationService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: i0.NgZone }, { type: i0.Renderer2 }, { type: i1.LocalizationService }] });

/**
 * Contains the header content of the `TileLayoutItem` component.
 * You can drag this area to reorder items when reordering is enabled.
 *
 * @example
 * ```html
 * <kendo-tilelayout-item>
 *   <kendo-tilelayout-item-header>
 *     <h3>Custom Header</h3>
 *   </kendo-tilelayout-item-header>
 *   <p>Item content</p>
 * </kendo-tilelayout-item>
 * ```
 */
class TileLayoutItemHeaderComponent {
    hostClass = true;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TileLayoutItemHeaderComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: TileLayoutItemHeaderComponent, isStandalone: true, selector: "kendo-tilelayout-item-header", host: { properties: { "class.k-tilelayout-item-header": "this.hostClass", "class.k-card-header": "this.hostClass" } }, ngImport: i0, template: `
        <ng-content></ng-content>
    `, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TileLayoutItemHeaderComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-tilelayout-item-header',
                    template: `
        <ng-content></ng-content>
    `,
                    standalone: true
                }]
        }], propDecorators: { hostClass: [{
                type: HostBinding,
                args: ['class.k-tilelayout-item-header']
            }, {
                type: HostBinding,
                args: ['class.k-card-header']
            }] } });

/**
 * @hidden
 */
class TileLayoutResizeHandleDirective {
    el;
    renderer;
    resizeDirection;
    rtl;
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
    }
    ngOnInit() {
        this.sizeHandle();
    }
    setHorizontalPosition(element) {
        this.renderer.setStyle(element, this.rtl ? 'left' : 'right', -RESIZE_HANDLE_DIMENSIONS[this.resizeDirection].overlapX + 'px');
    }
    setBottom(element) {
        this.renderer.setStyle(element, 'bottom', -RESIZE_HANDLE_DIMENSIONS[this.resizeDirection].overlapY + 'px');
    }
    sizeHandle() {
        const element = this.el.nativeElement;
        const handleWidth = RESIZE_HANDLE_DIMENSIONS[this.resizeDirection].width ?
            `${RESIZE_HANDLE_DIMENSIONS[this.resizeDirection].width}px` : '100%';
        const handleHeight = RESIZE_HANDLE_DIMENSIONS[this.resizeDirection].height ?
            `${RESIZE_HANDLE_DIMENSIONS[this.resizeDirection].height}px` : '100%';
        this.renderer.setStyle(element, 'width', handleWidth);
        this.renderer.setStyle(element, 'height', handleHeight);
        if (this.resizeDirection === 'ew') {
            this.setHorizontalPosition(element);
        }
        else if (this.resizeDirection === 'ns') {
            this.setBottom(element);
        }
        else {
            this.setHorizontalPosition(element);
            this.setBottom(element);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TileLayoutResizeHandleDirective, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: TileLayoutResizeHandleDirective, isStandalone: true, selector: "[kendoTileLayoutResizeHandle]", inputs: { resizeDirection: "resizeDirection", rtl: "rtl" }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TileLayoutResizeHandleDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoTileLayoutResizeHandle]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.Renderer2 }], propDecorators: { resizeDirection: [{
                type: Input
            }], rtl: [{
                type: Input
            }] } });

/**
 * Represents a tile item within the TileLayoutComponent.
 *
 * @example
 * ```html
 * <kendo-tilelayout>
 *   <kendo-tilelayout-item [title]="'Item 1'" [colSpan]="2">
 *     <p>Item content goes here</p>
 *   </kendo-tilelayout-item>
 * </kendo-tilelayout>
 * ```
 * @remarks
 * Supported children components are: {@link TileLayoutItemBodyComponent}, {@link TileLayoutItemHeaderComponent}.
 */
class TileLayoutItemComponent {
    elem;
    zone;
    renderer;
    localization;
    draggingService;
    keyboardNavigationService;
    /**
     * Sets the title text that appears in the item header ([see example]({% slug tiles_tilelayout %}#toc-tiles-configuration)).
     */
    title;
    /**
     * Sets how many rows the tile item spans ([see example](slug:resizing_tilelayout#programmatic-resizing)).
     * @default 1
     */
    rowSpan = 1;
    /**
     *  Sets how many columns the tile item spans ([see example](slug:resizing_tilelayout#programmatic-resizing)).
     * @default 1
     */
    colSpan = 1;
    /**
     * Sets the order of the tile item within the TileLayout.
     * When not set, items receive increasing order values based on their DOM position.
     */
    set order(value) {
        this._order = value;
        this.renderer.setStyle(this.elem.nativeElement, 'order', `${this._order}`);
    }
    get order() {
        return this._order;
    }
    /**
     * Sets the starting column position of the item ([see example](slug:tiles_tilelayout#size-and-position)).
     */
    col;
    /**
     * Sets the starting row position of the item ([see example](slug:tiles_tilelayout#size-and-position)).
     */
    row;
    /**
     * Enables or disables individual item reordering.
     *
     * @default true
     */
    reorderable = true;
    /**
     * Enables or disables individual item resizing.
     * @default true
     */
    resizable = true;
    itemClass = true;
    hostRole = 'listitem';
    get hostDropEffect() {
        return this.isResizable || this.isReorderable ? 'execute' : undefined;
    }
    get hostTabindex() {
        return this.isNavigable ? '0' : undefined;
    }
    get ariaKeyShortcuts() {
        return this.isNavigable ? 'Enter' : undefined;
    }
    get hostGrabbed() {
        return this.isResizable || this.isReorderable;
    }
    get hostLabelledBy() {
        return this.title ? this.titleId : undefined;
    }
    get colEnd() {
        return `span ${this.colSpan}`;
    }
    get rowEnd() {
        return `span ${this.rowSpan}`;
    }
    get colStart() {
        return isPresent(this.col) ? this.col.toString() : undefined;
    }
    get rowStart() {
        return isPresent(this.row) ? this.row.toString() : undefined;
    }
    /**
     * @hidden
     */
    get isReorderable() {
        return this.reorderable && this.draggingService.reorderable.getValue();
    }
    /**
     * @hidden
     */
    get isNavigable() {
        return this.keyboardNavigationService.navigable.getValue();
    }
    /**
     * @hidden
     */
    get isResizable() {
        return this.resizable && this.draggingService.resizable.getValue();
    }
    /**
     * @hidden
     */
    resizeDirections;
    /**
     * @hidden
     */
    rtl;
    headers;
    /**
     * @hidden
     */
    titleId = '';
    subs = new Subscription();
    keyboardNavigationSubs;
    focusableItems;
    _order;
    constructor(elem, zone, renderer, localization, draggingService, keyboardNavigationService) {
        this.elem = elem;
        this.zone = zone;
        this.renderer = renderer;
        this.localization = localization;
        this.draggingService = draggingService;
        this.keyboardNavigationService = keyboardNavigationService;
        this.subs.add(this.localization.changes.subscribe(({ rtl }) => {
            this.rtl = rtl;
        }));
        this.subs.add(this.draggingService.resizable.subscribe(resizable => {
            this.resizeDirections = resizable && this.resizable ?
                this.rtl ? RTL_RESIZE_DIRECTIONS : RESIZE_DIRECTIONS : undefined;
        }));
        this.titleId = getId('k-tilelayout-title');
    }
    ngAfterViewInit() {
        const elem = this.elem.nativeElement;
        const keyboardNavigation = this.keyboardNavigationService;
        this.subs.add(this.draggingService.reorderable.subscribe(reorderable => {
            this.toggleCursorClass(reorderable && this.reorderable);
        }));
        this.subs.add(keyboardNavigation.navigable.subscribe(isNavigable => {
            if (isNavigable) {
                this.keyboardNavigationSubs = new Subscription();
                this.focusableItems = keyboardNavigation.getAllFocusableChildren(elem);
                this.zone.runOutsideAngular(() => {
                    keyboardNavigation.changeTabIndex('-1', elem, this.focusableItems);
                    this.keyboardNavigationSubs.add(this.renderer.listen(elem, 'keydown', event => keyboardNavigation.onKeyDown(event, elem, this.focusableItems, this.draggingService.tileLayoutSettings)));
                    this.keyboardNavigationSubs.add(this.renderer.listen(elem, 'mousedown', event => keyboardNavigation.onMousedown(event, elem, this.focusableItems, this)));
                    this.keyboardNavigationSubs.add(this.renderer.listen(elem, 'focusout', event => keyboardNavigation.onFocusOut(event, elem, this.focusableItems)));
                });
            }
            else if (this.focusableItems) {
                this.focusableItems.forEach((focusItem) => {
                    this.renderer.setAttribute(focusItem, 'tabindex', '0');
                });
                this.keyboardNavigationSubs.unsubscribe();
            }
        }));
    }
    ngOnChanges(changes) {
        if (changes['reorderable'] && !changes['reorderable'].firstChange) {
            this.toggleCursorClass(changes['reorderable'].currentValue && this.draggingService.reorderable.getValue());
        }
        if (changes['resizable']) {
            this.resizeDirections = this.resizable && this.draggingService.resizable.getValue() ?
                this.rtl ? RTL_RESIZE_DIRECTIONS : RESIZE_DIRECTIONS : undefined;
        }
    }
    ngOnDestroy() {
        this.subs.unsubscribe();
        if (this.keyboardNavigationSubs) {
            this.keyboardNavigationSubs.unsubscribe();
        }
    }
    /**
     * @hidden
     */
    focus() {
        this.elem.nativeElement.focus();
    }
    toggleCursorClass(isReorderable) {
        const headerEl = this.elem.nativeElement.querySelector('.k-tilelayout-item-header');
        if (!headerEl) {
            return;
        }
        if (isReorderable) {
            this.renderer.addClass(headerEl, 'k-cursor-move');
        }
        else {
            this.renderer.removeClass(headerEl, 'k-cursor-move');
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TileLayoutItemComponent, deps: [{ token: i0.ElementRef }, { token: i0.NgZone }, { token: i0.Renderer2 }, { token: i1.LocalizationService }, { token: TileLayoutDraggingService }, { token: TileLayoutKeyboardNavigationService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: TileLayoutItemComponent, isStandalone: true, selector: "kendo-tilelayout-item", inputs: { title: "title", rowSpan: "rowSpan", colSpan: "colSpan", order: "order", col: "col", row: "row", reorderable: "reorderable", resizable: "resizable" }, host: { properties: { "class.k-tilelayout-item": "this.itemClass", "class.k-card": "this.itemClass", "attr.role": "this.hostRole", "attr.aria-dropeffect": "this.hostDropEffect", "attr.tabindex": "this.hostTabindex", "attr.aria-keyshortcuts": "this.ariaKeyShortcuts", "attr.aria-grabbed": "this.hostGrabbed", "attr.aria-labelledby": "this.hostLabelledBy", "style.grid-column-end": "this.colEnd", "style.grid-row-end": "this.rowEnd", "style.grid-column-start": "this.colStart", "style.grid-row-start": "this.rowStart" } }, queries: [{ propertyName: "headers", predicate: TileLayoutItemHeaderComponent }], usesOnChanges: true, ngImport: i0, template: `
        @if (title) {
          <kendo-tilelayout-item-header>
            <h5 [id]="titleId" class="k-card-title">{{ title }}</h5>
          </kendo-tilelayout-item-header>
        }
        <ng-content></ng-content>
        @if (resizable) {
          @for (dir of resizeDirections; track dir) {
            <div
              class="k-resize-handle k-cursor-{{dir}}-resize"
              kendoTileLayoutResizeHandle
              [rtl]="rtl"
              [resizeDirection]="dir">
            </div>
          }
        }
        `, isInline: true, dependencies: [{ kind: "component", type: TileLayoutItemHeaderComponent, selector: "kendo-tilelayout-item-header" }, { kind: "directive", type: TileLayoutResizeHandleDirective, selector: "[kendoTileLayoutResizeHandle]", inputs: ["resizeDirection", "rtl"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TileLayoutItemComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-tilelayout-item',
                    template: `
        @if (title) {
          <kendo-tilelayout-item-header>
            <h5 [id]="titleId" class="k-card-title">{{ title }}</h5>
          </kendo-tilelayout-item-header>
        }
        <ng-content></ng-content>
        @if (resizable) {
          @for (dir of resizeDirections; track dir) {
            <div
              class="k-resize-handle k-cursor-{{dir}}-resize"
              kendoTileLayoutResizeHandle
              [rtl]="rtl"
              [resizeDirection]="dir">
            </div>
          }
        }
        `,
                    standalone: true,
                    imports: [TileLayoutItemHeaderComponent, TileLayoutResizeHandleDirective]
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.NgZone }, { type: i0.Renderer2 }, { type: i1.LocalizationService }, { type: TileLayoutDraggingService }, { type: TileLayoutKeyboardNavigationService }], propDecorators: { title: [{
                type: Input
            }], rowSpan: [{
                type: Input
            }], colSpan: [{
                type: Input
            }], order: [{
                type: Input
            }], col: [{
                type: Input
            }], row: [{
                type: Input
            }], reorderable: [{
                type: Input
            }], resizable: [{
                type: Input
            }], itemClass: [{
                type: HostBinding,
                args: ['class.k-tilelayout-item']
            }, {
                type: HostBinding,
                args: ['class.k-card']
            }], hostRole: [{
                type: HostBinding,
                args: ['attr.role']
            }], hostDropEffect: [{
                type: HostBinding,
                args: ['attr.aria-dropeffect']
            }], hostTabindex: [{
                type: HostBinding,
                args: ['attr.tabindex']
            }], ariaKeyShortcuts: [{
                type: HostBinding,
                args: ['attr.aria-keyshortcuts']
            }], hostGrabbed: [{
                type: HostBinding,
                args: ['attr.aria-grabbed']
            }], hostLabelledBy: [{
                type: HostBinding,
                args: ['attr.aria-labelledby']
            }], colEnd: [{
                type: HostBinding,
                args: ['style.grid-column-end']
            }], rowEnd: [{
                type: HostBinding,
                args: ['style.grid-row-end']
            }], colStart: [{
                type: HostBinding,
                args: ['style.grid-column-start']
            }], rowStart: [{
                type: HostBinding,
                args: ['style.grid-row-start']
            }], headers: [{
                type: ContentChildren,
                args: [TileLayoutItemHeaderComponent]
            }] } });

const autoFlowClasses = {
    column: 'k-grid-flow-col',
    row: 'k-grid-flow-row',
    'column-dense': 'k-grid-flow-col-dense',
    'row-dense': 'k-grid-flow-row-dense'
};
/**
 * Represents the [Kendo UI TileLayout component for Angular]({% slug overview_tilelayout %})
 *
 * @example
 * ```html
 * <kendo-tilelayout [columns]="3" [gap]="10">
 *   <kendo-tilelayout-item>Content 1</kendo-tilelayout-item>
 *   <kendo-tilelayout-item>Content 2</kendo-tilelayout-item>
 * </kendo-tilelayout>
 * ```
 * @remarks
 * Supported children components are: {@link TileLayoutItemComponent}.
 */
class TileLayoutComponent {
    zone;
    elem;
    renderer;
    localization;
    draggingService;
    navigationService;
    /**
     * Specifies the number of columns ([see example](slug:tiles_tilelayout#size-and-position)).
     * @default 1
     */
    columns = 1;
    /**
     * Sets the width of the columns.
     * Use numeric values for pixels or string values for other CSS units ([see example](slug:tiles_tilelayout#size-and-position)).
     * @default '1fr'
     */
    columnWidth = '1fr';
    /**
     * Sets the spacing between layout items in pixels.
     * Use an object with `rows` and `columns` properties to set different horizontal and vertical spacing.
     * Use a single number to apply the same spacing to both directions.
     *
     * @default { rows: 16, columns: 16 }
     */
    set gap(value) {
        this._gap = (typeof value === 'number') ? { rows: value, columns: value } : Object.assign(this._gap, value);
    }
    get gap() {
        return this._gap;
    }
    /**
     * Enables or disables item reordering ([see example]({% slug reordering_tilelayout %})).
     * @default false
     */
    reorderable = false;
    /**
     * Enables or disables item resizing ([see example]({% slug resizing_tilelayout %})).
     * @default false
     */
    resizable = false;
    /**
     * Sets the height of the rows.
     * Use numeric values for pixels or string values for other CSS units ([see example](slug:tiles_tilelayout#size-and-position)).
     * @default '1fr'
     */
    rowHeight = '1fr';
    /**
     *
     * Controls how the auto-placement algorithm works, specifying exactly how auto-placed items are flowed in the TileLayout ([see example]({% slug tiles_autoflow_tilelayout %})).
     *
     * For further reference, check the [grid-auto-flow CSS article](https://developer.mozilla.org/en-US/docs/Web/CSS/grid-auto-flow).
     * @default 'column'
     */
    autoFlow = 'column';
    /**
     * Enables or disables [keyboard navigation](slug:keyboard_navigation_tilelayout).
     * @default true
     */
    navigable = true;
    /**
     * Fires when item reordering is completed ([see example]({% slug reordering_tilelayout %})).
     * You can prevent this event to cancel the reorder operation.
     */
    reorder = new EventEmitter();
    /**
     * Fires when item resizing is completed ([see example]({% slug resizing_tilelayout %})).
     * You can prevent this event to cancel the resize operation.
     */
    resize = new EventEmitter();
    hostClass = true;
    hostRole = 'list';
    get gapStyle() {
        return `${this.gap.rows}px ${this.gap.columns}px`;
    }
    direction;
    get currentColStart() {
        return this.draggingService.colStart;
    }
    get currentRowStart() {
        return this.draggingService.rowStart;
    }
    get draggedItemWrapper() {
        return this.draggingService.itemWrapper;
    }
    get targetOrder() {
        return this.draggingService.order;
    }
    /**
     * Contains a query list of the `TileLayoutItemComponent` instances that are used in the TileLayout.
     * This allows you to access the items programmatically and manipulate their properties or listen to their events.
     */
    items;
    hint;
    /**
     * @hidden
     */
    showLicenseWatermark = false;
    /**
     * @hidden
     */
    licenseMessage;
    draggable;
    subs = new Subscription();
    _gap = {
        rows: 16,
        columns: 16
    };
    constructor(zone, elem, renderer, localization, draggingService, navigationService) {
        this.zone = zone;
        this.elem = elem;
        this.renderer = renderer;
        this.localization = localization;
        this.draggingService = draggingService;
        this.navigationService = navigationService;
        const isValid = validatePackage(packageMetadata);
        this.licenseMessage = getLicenseMessage(packageMetadata);
        this.showLicenseWatermark = shouldShowValidationUI(isValid);
    }
    ngOnInit() {
        this.applyColStyling();
        this.applyRowStyling();
        this.draggingService.reorderable.next(this.reorderable);
        this.draggingService.resizable.next(this.resizable);
        this.navigationService.owner = this;
        this.navigationService.navigable.next(this.navigable);
        if (hasObservers(this.reorder)) {
            this.subs.add(this.draggingService.reorder.subscribe(e => this.reorder.emit(e)));
        }
        if (hasObservers(this.resize)) {
            this.subs.add(this.draggingService.resize.subscribe(e => this.resize.emit(e)));
        }
        this.subs.add(this.draggingService.reorderable.subscribe(reorderable => {
            if (reorderable && !this.draggable) {
                this.initializeDraggable();
            }
        }));
        this.subs.add(this.draggingService.resizable.subscribe(resizable => {
            if (resizable && !this.draggable) {
                this.initializeDraggable();
            }
        }));
        this.subs.add(this.localization.changes.subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
        }));
    }
    ngAfterViewInit() {
        this.draggingService.tileLayoutSettings = this.draggingServiceConfig();
        this.applyAutoFlow(null, autoFlowClasses[this.autoFlow]);
        this.items.changes.subscribe(() => {
            this.setItemsOrder();
            this.draggingService.tileLayoutSettings.items = this.items.toArray();
        });
        this.zone.runOutsideAngular(() => {
            this.elem.nativeElement.addEventListener('focusin', this.onFocusIn);
        });
    }
    ngAfterContentInit() {
        this.setItemsOrder();
    }
    ngOnChanges(changes) {
        if (changes['columns'] || changes['columnWidth']) {
            this.applyColStyling();
        }
        if (changes['rowHeight']) {
            this.applyRowStyling();
        }
        if (isChanged('reorderable', changes)) {
            this.draggingService.reorderable.next(changes['reorderable'].currentValue);
        }
        if (isChanged('resizable', changes)) {
            this.draggingService.resizable.next(changes['resizable'].currentValue);
        }
        if (changes['gap'] || changes['autoFlow'] || changes['columns']) {
            this.draggingService.tileLayoutSettings = this.draggingServiceConfig();
            if (changes['autoFlow']) {
                this.applyAutoFlow(autoFlowClasses[changes['autoFlow'].previousValue] || '', autoFlowClasses[changes['autoFlow'].currentValue]);
            }
        }
        if (isChanged('navigable', changes)) {
            this.navigationService.navigable.next(changes['navigable'].currentValue);
        }
    }
    ngOnDestroy() {
        if (this.draggable) {
            this.draggable.destroy();
        }
        this.subs.unsubscribe();
        this.elem.nativeElement.removeEventListener('focusin', this.onFocusIn);
    }
    handlePress({ originalEvent }) {
        this.draggingService.handlePress(originalEvent);
    }
    handleDrag({ originalEvent }) {
        this.draggingService.handleDrag(originalEvent);
    }
    handleRelease({ originalEvent }) {
        this.draggingService.handleRelease(originalEvent);
    }
    applyColStyling() {
        const colWidth = typeof this.columnWidth === 'number' ? `${this.columnWidth}px` : this.columnWidth;
        const gridTemplateColumnsStyle = `repeat(${this.columns}, ${colWidth})`;
        this.renderer.setStyle(this.elem.nativeElement, 'grid-template-columns', gridTemplateColumnsStyle);
    }
    applyRowStyling() {
        const rowHeight = typeof this.rowHeight === 'number' ? `${this.rowHeight}px` : this.rowHeight;
        const gridAutoRowsStyle = `${rowHeight}`;
        this.renderer.setStyle(this.elem.nativeElement, 'grid-auto-rows', gridAutoRowsStyle);
    }
    draggingServiceConfig() {
        return {
            tileLayoutElement: this.elem ? this.elem.nativeElement : undefined,
            hintElement: this.hint ? this.hint.nativeElement : undefined,
            gap: this.gap,
            columns: this.columns,
            autoFlow: this.autoFlow,
            items: this.items ? this.items.toArray() : []
        };
    }
    initializeDraggable() {
        this.draggable = new Draggable({
            press: this.handlePress.bind(this),
            drag: this.handleDrag.bind(this),
            release: this.handleRelease.bind(this)
        });
        this.zone.runOutsideAngular(() => this.draggable.bindTo(this.elem.nativeElement));
    }
    applyAutoFlow(classToRemove, classToAdd) {
        const element = this.elem.nativeElement;
        if (classToRemove) {
            this.renderer.removeClass(element, classToRemove);
        }
        if (this.autoFlow !== 'none' && isPresent(classToAdd)) {
            this.renderer.addClass(element, classToAdd);
        }
    }
    setItemsOrder() {
        this.items.forEach((item, index) => {
            if (!isPresent(item.order)) {
                item.order = index;
            }
        });
    }
    onFocusIn = (e) => {
        if (!this.navigable || this.navigationService.mousedown || !e.relatedTarget) {
            this.navigationService.mousedown = false;
            return;
        }
        if (!(this.elem.nativeElement.compareDocumentPosition(e.relatedTarget) & Node.DOCUMENT_POSITION_CONTAINED_BY)) {
            this.navigationService.returnFocus();
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TileLayoutComponent, deps: [{ token: i0.NgZone }, { token: i0.ElementRef }, { token: i0.Renderer2 }, { token: i1.LocalizationService }, { token: TileLayoutDraggingService }, { token: TileLayoutKeyboardNavigationService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: TileLayoutComponent, isStandalone: true, selector: "kendo-tilelayout", inputs: { columns: "columns", columnWidth: "columnWidth", gap: "gap", reorderable: "reorderable", resizable: "resizable", rowHeight: "rowHeight", autoFlow: "autoFlow", navigable: "navigable" }, outputs: { reorder: "reorder", resize: "resize" }, host: { properties: { "class.k-tilelayout": "this.hostClass", "attr.role": "this.hostRole", "style.gap": "this.gapStyle", "style.padding": "this.gapStyle", "attr.dir": "this.direction" } }, providers: [
            LocalizationService,
            TileLayoutDraggingService,
            TileLayoutKeyboardNavigationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.tilelayout.component'
            }
        ], queries: [{ propertyName: "items", predicate: TileLayoutItemComponent }], viewQueries: [{ propertyName: "hint", first: true, predicate: ["hint"], descendants: true }], usesOnChanges: true, ngImport: i0, template: `
        <ng-content></ng-content>
        <div #hint class="k-layout-item-hint"
          [style.display]="'none'"
          [style.order]="targetOrder"
          [style.gridColumnEnd]="draggedItemWrapper?.style.gridColumnEnd"
          [style.gridRowEnd]="draggedItemWrapper?.style.gridRowEnd"
          [style.gridColumnStart]="currentColStart"
          [style.gridRowStart]="currentRowStart"
          [style.zIndex]="'1'">
        </div>
        @if (showLicenseWatermark) {
          <div kendoWatermarkOverlay [licenseMessage]="licenseMessage"></div>
        }
        `, isInline: true, dependencies: [{ kind: "component", type: WatermarkOverlayComponent, selector: "div[kendoWatermarkOverlay]", inputs: ["licenseMessage"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TileLayoutComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-tilelayout',
                    providers: [
                        LocalizationService,
                        TileLayoutDraggingService,
                        TileLayoutKeyboardNavigationService,
                        {
                            provide: L10N_PREFIX,
                            useValue: 'kendo.tilelayout.component'
                        }
                    ],
                    template: `
        <ng-content></ng-content>
        <div #hint class="k-layout-item-hint"
          [style.display]="'none'"
          [style.order]="targetOrder"
          [style.gridColumnEnd]="draggedItemWrapper?.style.gridColumnEnd"
          [style.gridRowEnd]="draggedItemWrapper?.style.gridRowEnd"
          [style.gridColumnStart]="currentColStart"
          [style.gridRowStart]="currentRowStart"
          [style.zIndex]="'1'">
        </div>
        @if (showLicenseWatermark) {
          <div kendoWatermarkOverlay [licenseMessage]="licenseMessage"></div>
        }
        `,
                    standalone: true,
                    imports: [WatermarkOverlayComponent]
                }]
        }], ctorParameters: () => [{ type: i0.NgZone }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i1.LocalizationService }, { type: TileLayoutDraggingService }, { type: TileLayoutKeyboardNavigationService }], propDecorators: { columns: [{
                type: Input
            }], columnWidth: [{
                type: Input
            }], gap: [{
                type: Input
            }], reorderable: [{
                type: Input
            }], resizable: [{
                type: Input
            }], rowHeight: [{
                type: Input
            }], autoFlow: [{
                type: Input
            }], navigable: [{
                type: Input
            }], reorder: [{
                type: Output
            }], resize: [{
                type: Output
            }], hostClass: [{
                type: HostBinding,
                args: ['class.k-tilelayout']
            }], hostRole: [{
                type: HostBinding,
                args: ['attr.role']
            }], gapStyle: [{
                type: HostBinding,
                args: ['style.gap']
            }, {
                type: HostBinding,
                args: ['style.padding']
            }], direction: [{
                type: HostBinding,
                args: ['attr.dir']
            }], items: [{
                type: ContentChildren,
                args: [TileLayoutItemComponent]
            }], hint: [{
                type: ViewChild,
                args: ['hint', { static: false }]
            }] } });

/**
 * Contains the main content of the `TileLayoutItem` component.
 *
 * @example
 * ```html
 * <kendo-tilelayout-item>
 *   <kendo-tilelayout-item-body>
 *     <p>Main content goes here</p>
 *   </kendo-tilelayout-item-body>
 * </kendo-tilelayout-item>
 * ```
 */
class TileLayoutItemBodyComponent {
    hostClass = true;
    minHeight = 0;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TileLayoutItemBodyComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: TileLayoutItemBodyComponent, isStandalone: true, selector: "kendo-tilelayout-item-body", host: { properties: { "class.k-tilelayout-item-body": "this.hostClass", "class.k-card-body": "this.hostClass", "style.min-height": "this.minHeight" } }, ngImport: i0, template: `
        <ng-content></ng-content>
    `, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TileLayoutItemBodyComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-tilelayout-item-body',
                    template: `
        <ng-content></ng-content>
    `,
                    standalone: true
                }]
        }], propDecorators: { hostClass: [{
                type: HostBinding,
                args: ['class.k-tilelayout-item-body']
            }, {
                type: HostBinding,
                args: ['class.k-card-body']
            }], minHeight: [{
                type: HostBinding,
                args: ['style.min-height']
            }] } });

/**
 * @hidden
 */
const VERTICAL_SUFFIX = {
    top: 'start',
    middle: 'center',
    bottom: 'end',
    stretch: 'stretch'
};
/**
 * @hidden
 */
const JUSTIFY_PREFIX = `k-justify-content`;
/**
 * @hidden
 */
const GRID_JUSTIFY_PREFIX = `k-justify-items`;
/**
 * @hidden
 */
const ALIGN_PREFIX = `k-align-items`;
/**
 * @hidden
 */
const normalizeGap = (gap) => {
    if (typeof gap === 'number' || typeof gap === 'string') {
        return { cols: gap, rows: gap };
    }
    else {
        const parsedGap = {};
        parsedGap.rows = gap.rows ? gap.rows : 0;
        parsedGap.cols = gap.cols ? gap.cols : 0;
        return parsedGap;
    }
};
/**
 * @hidden
 */
const generateGapStyle = (gap) => {
    if (gap.rows === gap.cols) {
        return typeof gap.rows === 'number' ? `${gap.rows}px` : gap.rows;
    }
    else {
        const rowStyle = `${typeof gap.rows === 'number' ? gap.rows + 'px' : gap.rows}`;
        const colStyle = `${typeof gap.cols === 'number' ? gap.cols + 'px' : gap.cols}`;
        return `${rowStyle} ${colStyle}`;
    }
};
/**
 * @hidden
 */
const generateGridStyle = (items, itemType) => {
    const styling = [];
    items.forEach((item) => {
        if (typeof item === 'number') {
            styling.push(`${item}px`);
        }
        else if (typeof item === 'string') {
            styling.push(item);
        }
        else {
            if (itemType === 'rows') {
                const rowHeight = item.height;
                if (rowHeight) {
                    styling.push(typeof rowHeight === 'number' ? `${rowHeight}px` : rowHeight);
                }
                else {
                    styling.push('0px');
                }
            }
            else {
                const colWidth = item.width;
                if (colWidth) {
                    styling.push(typeof colWidth === 'number' ? `${colWidth}px` : colWidth);
                }
                else {
                    styling.push('0px');
                }
            }
        }
    });
    return styling;
};
/**
 * @hidden
 */
const validateGridLayoutRowsCols = (arr) => {
    for (const el of arr) {
        const isNum = typeof el === 'number';
        const isStr = typeof el === 'string';
        const isObject = typeof el === 'object' && el !== null;
        if (!isNum && !isStr && !isObject) {
            return false;
        }
    }
    return true;
};

/**
 * Represents the Kendo UI GridLayout component for Angular.
 * Arranges child components in a two-dimensional grid layout with customizable rows, columns, and gaps ([see overview]({% slug overview_gridlayout %})).
 *
 * @example
 * ```html
 * <kendo-gridlayout [rows]="[100, 200]" [cols]="['1fr', '2fr']" [gap]="10">
 *   <kendo-gridlayout-item [row]="1" [col]="1">
 *     <p>Item 1</p>
 *   </kendo-gridlayout-item>
 *   <kendo-gridlayout-item [row]="1" [col]="2">
 *     <p>Item 2</p>
 *   </kendo-gridlayout-item>
 * </kendo-gridlayout>
 * ```
 *
 * @remarks
 * Supported children components are: {@link GridLayoutItemComponent}.
 */
class GridLayoutComponent {
    renderer;
    element;
    localization;
    hostClass = true;
    get dir() {
        return this.direction;
    }
    /**
     * Specifies the number of rows and their height
     * ([More details](slug:layout_gridlayout#toc-rows-and-columns)).
     *
     * You can define rows by passing an array where the number of elements determines the number of rows or each element defines the size of the corresponding row.
     * For example, you can use CSS units like `px`, `%`, `fr`, or `auto` to define the row sizes.
     */
    rows;
    /**
     * Specifies the number of columns and their widths
     * ([More details](slug:layout_gridlayout#toc-rows-and-columns)).
     *
     * You can define columns by passing an array where the number of elements determines the number of columns or each element defines the size of the corresponding column.
     * For example, you can use CSS units like `px`, `%`, `fr`, or `auto` to define the column sizes.
     */
    cols;
    /**
     * Specifies the gaps between the elements ([see example](slug:layout_gridlayout#toc-gap)).
     *
     * @default 0
     */
    gap = 0;
    /**
     * Specifies the horizontal and vertical alignment of the inner GridLayout elements
     * ([see example]({% slug layout_gridlayout %}#toc-alignment)).
     */
    set align(align) {
        this._align = Object.assign({}, this._align, align);
        this.handleAlignClasses();
    }
    get align() {
        return this._align;
    }
    _align = {
        horizontal: 'stretch',
        vertical: 'stretch'
    };
    justifyClass;
    alignClass;
    constructor(renderer, element, localization) {
        this.renderer = renderer;
        this.element = element;
        this.localization = localization;
        validatePackage(packageMetadata);
    }
    ngAfterViewInit() {
        this.handleAlignClasses();
        this.handleGridTemplateStyling('rows');
        this.handleGridTemplateStyling('cols');
        this.setGap();
    }
    ngOnChanges(changes) {
        if (isChanged('gap', changes)) {
            this.setGap();
        }
        if (isChanged('rows', changes)) {
            this.handleGridTemplateStyling('rows');
        }
        if (isChanged('cols', changes)) {
            this.handleGridTemplateStyling('cols');
        }
    }
    handleAlignClasses() {
        const elem = this.element.nativeElement;
        if (isPresent(this.justifyClass)) {
            this.renderer.removeClass(elem, this.justifyClass);
        }
        if (isPresent(this.alignClass)) {
            this.renderer.removeClass(elem, this.alignClass);
        }
        this.justifyClass = `${GRID_JUSTIFY_PREFIX}-${this.align.horizontal}`;
        this.alignClass = `${ALIGN_PREFIX}-${VERTICAL_SUFFIX[this.align.vertical]}`;
        this.renderer.addClass(elem, this.justifyClass);
        this.renderer.addClass(elem, this.alignClass);
    }
    setGap() {
        const parsedGap = normalizeGap(this.gap);
        const gapStyle = generateGapStyle(parsedGap);
        this.renderer.setStyle(this.element.nativeElement, 'gap', gapStyle);
    }
    handleGridTemplateStyling(type) {
        if (!isPresent(this[type])) {
            return;
        }
        const isValid = validateGridLayoutRowsCols(this[type]);
        if (!isValid && isDevMode()) {
            const valueType = type === 'rows' ? 'GridLayoutRowSize' : 'GridLayoutColSize';
            throw new Error(`The provided ${type} value contains invalid elements. The array supports values of type number, string or ${valueType}.`);
        }
        const gridTemplateStyle = type === 'rows' ? 'grid-template-rows' : 'grid-template-columns';
        const gridStyle = generateGridStyle(this[type], type);
        this.renderer.setStyle(this.element.nativeElement, gridTemplateStyle, gridStyle.join(' '));
    }
    get direction() {
        return this.localization.rtl ? 'rtl' : 'ltr';
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GridLayoutComponent, deps: [{ token: i0.Renderer2 }, { token: i0.ElementRef }, { token: i1.LocalizationService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: GridLayoutComponent, isStandalone: true, selector: "kendo-gridlayout", inputs: { rows: "rows", cols: "cols", gap: "gap", align: "align" }, host: { properties: { "class.k-grid-layout": "this.hostClass", "attr.dir": "this.dir" } }, providers: [
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.gridlayout'
            }
        ], exportAs: ["kendoGridLayout"], usesOnChanges: true, ngImport: i0, template: `
        <ng-content></ng-content>
    `, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GridLayoutComponent, decorators: [{
            type: Component,
            args: [{
                    exportAs: 'kendoGridLayout',
                    selector: 'kendo-gridlayout',
                    providers: [
                        LocalizationService,
                        {
                            provide: L10N_PREFIX,
                            useValue: 'kendo.gridlayout'
                        }
                    ],
                    template: `
        <ng-content></ng-content>
    `,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.Renderer2 }, { type: i0.ElementRef }, { type: i1.LocalizationService }], propDecorators: { hostClass: [{
                type: HostBinding,
                args: ['class.k-grid-layout']
            }], dir: [{
                type: HostBinding,
                args: ['attr.dir']
            }], rows: [{
                type: Input
            }], cols: [{
                type: Input
            }], gap: [{
                type: Input
            }], align: [{
                type: Input
            }] } });

/**
 * Represents the GridLayout item component. Defines the positioning and spanning of individual items within a GridLayout.
 *
 * @example
 * ```html
 * <kendo-gridlayout-item [row]="1" [col]="2" [rowSpan]="2" [colSpan]="1">
 *   <div>Grid item content</div>
 * </kendo-gridlayout-item>
 * ```
 */
class GridLayoutItemComponent {
    renderer;
    element;
    /**
     * Sets the row of the item in the GridLayout
     * ([see example]({% slug items_gridlayout %}#toc-size-and-position)).
     */
    row;
    /**
     * Sets the column of the item in the GridLayout
     * ([see example]({% slug items_gridlayout %}#toc-size-and-position)).
     */
    col;
    /**
     * Specifies how many rows the item spans ([see example]({% slug items_gridlayout %}#toc-size-and-position)).
     *
     * @default 1
     */
    rowSpan;
    /**
     * Specifies how many columns the item spans ([see example]({% slug items_gridlayout %}#toc-size-and-position)).
     *
     * @default 1
     */
    colSpan;
    constructor(renderer, element) {
        this.renderer = renderer;
        this.element = element;
    }
    ngOnInit() {
        this.setItemStyle();
    }
    ngOnChanges() {
        this.setItemStyle();
    }
    setItemStyle() {
        const row = this.row || 'auto';
        const col = this.col || 'auto';
        const rowSpan = this.rowSpan ? `span ${this.rowSpan}` : 'auto';
        const colSpan = this.colSpan ? `span ${this.colSpan}` : 'auto';
        const gridAreaStyle = `${row} / ${col} / ${rowSpan} / ${colSpan}`;
        this.renderer.setStyle(this.element.nativeElement, 'grid-area', gridAreaStyle);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GridLayoutItemComponent, deps: [{ token: i0.Renderer2 }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: GridLayoutItemComponent, isStandalone: true, selector: "kendo-gridlayout-item", inputs: { row: "row", col: "col", rowSpan: "rowSpan", colSpan: "colSpan" }, usesOnChanges: true, ngImport: i0, template: `
        <ng-content></ng-content>
    `, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GridLayoutItemComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-gridlayout-item',
                    template: `
        <ng-content></ng-content>
    `,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.Renderer2 }, { type: i0.ElementRef }], propDecorators: { row: [{
                type: Input
            }], col: [{
                type: Input
            }], rowSpan: [{
                type: Input
            }], colSpan: [{
                type: Input
            }] } });

/**
 * Represents the Kendo UI StackLayout component for Angular.
 * Arranges child components in a single row or column with customizable alignment and spacing ([see overview]({% slug overview_stacklayout %})).
 *
 * @example
 * ```html
 * <kendo-stacklayout orientation="horizontal" [gap]="16">
 *   <button class="k-button">Button 1</button>
 *   <button class="k-button">Button 2</button>
 *   <button class="k-button">Button 3</button>
 * </kendo-stacklayout>
 * ```
 */
class StackLayoutComponent {
    renderer;
    element;
    localization;
    hostClass = true;
    get horizontalClass() {
        return this.orientation === 'horizontal';
    }
    get verticalClass() {
        return this.orientation === 'vertical';
    }
    get dir() {
        return this.direction;
    }
    /**
     * Specifies the horizontal and vertical alignment of the inner StackLayout elements
     * ([see example]({% slug layout_stacklayout %}#toc-alignment)).
     */
    set align(align) {
        this._align = Object.assign({}, this._align, align);
        this.handleAlignClasses();
    }
    get align() {
        return this._align;
    }
    /**
     * Specifies the gap between the inner StackLayout elements ([see example](slug:layout_stacklayout#toc-gap)).
     *
     * @default 0
     */
    gap = 0;
    /**
     * Specifies the orientation of the StackLayout
     * ([see example]({% slug layout_stacklayout %}#toc-orientation)).
     *
     * @default 'horizontal'
     */
    orientation = 'horizontal';
    _align = {
        horizontal: 'stretch',
        vertical: 'stretch'
    };
    justifyClass;
    alignClass;
    constructor(renderer, element, localization) {
        this.renderer = renderer;
        this.element = element;
        this.localization = localization;
        validatePackage(packageMetadata);
    }
    ngAfterViewInit() {
        this.handleAlignClasses();
        this.setGap();
    }
    ngOnChanges(changes) {
        if (isChanged('gap', changes)) {
            this.setGap();
        }
        if (isChanged('orientation', changes)) {
            this.handleAlignClasses();
        }
    }
    handleAlignClasses() {
        const elem = this.element.nativeElement;
        if (isPresent(this.justifyClass)) {
            this.renderer.removeClass(elem, this.justifyClass);
        }
        if (isPresent(this.alignClass)) {
            this.renderer.removeClass(elem, this.alignClass);
        }
        if (this.orientation === 'horizontal') {
            this.justifyClass = `${JUSTIFY_PREFIX}-${this.align.horizontal}`;
            this.alignClass = `${ALIGN_PREFIX}-${VERTICAL_SUFFIX[this.align.vertical]}`;
        }
        else {
            this.justifyClass = `${JUSTIFY_PREFIX}-${VERTICAL_SUFFIX[this.align.vertical]}`;
            this.alignClass = `${ALIGN_PREFIX}-${this.align.horizontal}`;
        }
        this.renderer.addClass(elem, this.justifyClass);
        this.renderer.addClass(elem, this.alignClass);
    }
    setGap() {
        const parsedGap = isNumber(this.gap) ? `${this.gap}px` : this.gap;
        this.renderer.setStyle(this.element.nativeElement, 'gap', parsedGap);
    }
    get direction() {
        return this.localization.rtl ? 'rtl' : 'ltr';
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: StackLayoutComponent, deps: [{ token: i0.Renderer2 }, { token: i0.ElementRef }, { token: i1.LocalizationService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: StackLayoutComponent, isStandalone: true, selector: "kendo-stacklayout", inputs: { align: "align", gap: "gap", orientation: "orientation" }, host: { properties: { "class.k-stack-layout": "this.hostClass", "class.k-hstack": "this.horizontalClass", "class.k-vstack": "this.verticalClass", "attr.dir": "this.dir" } }, providers: [
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.stacklayout'
            }
        ], exportAs: ["kendoStackLayout"], usesOnChanges: true, ngImport: i0, template: `
        <ng-content></ng-content>
    `, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: StackLayoutComponent, decorators: [{
            type: Component,
            args: [{
                    exportAs: 'kendoStackLayout',
                    selector: 'kendo-stacklayout',
                    providers: [
                        LocalizationService,
                        {
                            provide: L10N_PREFIX,
                            useValue: 'kendo.stacklayout'
                        }
                    ],
                    template: `
        <ng-content></ng-content>
    `,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.Renderer2 }, { type: i0.ElementRef }, { type: i1.LocalizationService }], propDecorators: { hostClass: [{
                type: HostBinding,
                args: ['class.k-stack-layout']
            }], horizontalClass: [{
                type: HostBinding,
                args: ['class.k-hstack']
            }], verticalClass: [{
                type: HostBinding,
                args: ['class.k-vstack']
            }], dir: [{
                type: HostBinding,
                args: ['attr.dir']
            }], align: [{
                type: Input
            }], gap: [{
                type: Input
            }], orientation: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class TimelineMessages extends ComponentMessages {
    /**
     * The title of the previous button in horizontal orientation.
     */
    previous;
    /**
     * The title of the next button in horizontal orientation.
     */
    next;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TimelineMessages, deps: null, target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: TimelineMessages, isStandalone: true, selector: "kendo-timeline-messages-base", inputs: { previous: "previous", next: "next" }, usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TimelineMessages, decorators: [{
            type: Directive,
            args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: 'kendo-timeline-messages-base'
                }]
        }], propDecorators: { previous: [{
                type: Input
            }], next: [{
                type: Input
            }] } });

/**
 * Custom component messages override default component messages.
 */
class TimelineCustomMessagesComponent extends TimelineMessages {
    service;
    constructor(service) {
        super();
        this.service = service;
    }
    get override() {
        return true;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TimelineCustomMessagesComponent, deps: [{ token: i1.LocalizationService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: TimelineCustomMessagesComponent, isStandalone: true, selector: "kendo-timeline-messages", providers: [
            {
                provide: TimelineMessages,
                useExisting: forwardRef(() => TimelineCustomMessagesComponent),
            },
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TimelineCustomMessagesComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: TimelineMessages,
                            useExisting: forwardRef(() => TimelineCustomMessagesComponent),
                        },
                    ],
                    selector: 'kendo-timeline-messages',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1.LocalizationService }] });

/**
 * Specifies the actions of each timeline card. To define an actions template, nest an `<ng-template>` tag
 * with the `kendoTimelineCardActionsTemplate` directive inside the `<kendo-timeline>` tag.
 *
 * The following values are available as context variables:
 * - `let-event="event"` (`TimelineEvent`)&mdash;The current card's event. Also available as implicit context variable.
 * - `let-index="index"` (`number`)&mdash;The current event index.
 *
 * @example
 * ```html
 * <kendo-timeline [events]="events">
 *   <ng-template kendoTimelineCardActionsTemplate let-event let-index="index">
 *     Content for the actions of the card with index {{ index }} and event {{ event.title }}.
 *   </ng-template>
 * </kendo-timeline>
 * ```
 */
class TimelineCardActionsTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TimelineCardActionsTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: TimelineCardActionsTemplateDirective, isStandalone: true, selector: "[kendoTimelineCardActionsTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TimelineCardActionsTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoTimelineCardActionsTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }] });

/**
 * Specifies the body of each timeline card. To define a body template, nest an `<ng-template>` tag
 * with the `kendoTimelineCardBodyTemplate` directive inside the `<kendo-timeline>` tag.
 *
 * The following values are available as context variables:
 * - `let-event="event"` (`TimelineEvent`)&mdash;The current card's event. Also available as implicit context variable.
 * - `let-index="index"` (`number`)&mdash;The current event index.
 *
 * @example
 * ```html
 * <kendo-timeline [events]="events">
 *   <ng-template kendoTimelineCardBodyTemplate let-event let-index="index">
 *     Component for the body of the card with index {{ index }} and event {{ event.title }}.
 *   </ng-template>
 * </kendo-timeline>
 * ```
 */
class TimelineCardBodyTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TimelineCardBodyTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: TimelineCardBodyTemplateDirective, isStandalone: true, selector: "[kendoTimelineCardBodyTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TimelineCardBodyTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoTimelineCardBodyTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }] });

/**
 * Specifies the header of each timeline card. To define a header template, nest an `<ng-template>` tag
 * with the `kendoTimelineCardHeaderTemplate` directive inside the `<kendo-timeline>` tag.
 *
 * The following values are available as context variables:
 * - `let-event="event"` (`TimelineEvent`)&mdash;The current card's event. Also available as implicit context variable.
 * - `let-index="index"` (`number`)&mdash;The current event index.
 *
 * @example
 * ```html
 * <kendo-timeline [events]="events">
 *   <ng-template kendoTimelineCardHeaderTemplate let-event let-index="index">
 *     <span class="k-event-title">Title: {{ event.title }}</span>
 *     <div kendoCardSubtitle>Event number {{ index }}</div>
 *   </ng-template>
 * </kendo-timeline>
 * ```
 */
class TimelineCardHeaderTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TimelineCardHeaderTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: TimelineCardHeaderTemplateDirective, isStandalone: true, selector: "[kendoTimelineCardHeaderTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TimelineCardHeaderTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoTimelineCardHeaderTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }] });

/**
 * @hidden
 */
const defaultModelFields = {
    title: 'title',
    subtitle: 'subtitle',
    description: 'description',
    date: 'date',
    expanded: 'expanded',
    images: 'images',
    actions: 'actions',
};

/**
 * @hidden
 */
const processItems = (items, fields) => {
    return items.map((item) => parseItem(item, fields));
};
/**
 * @hidden
 */
const parseItem = (item, fields) => ({
    title: item[fields.title] || item.title,
    date: item[fields.date] || item.date,
    subtitle: item[fields.subtitle] || item.subtitle,
    description: item[fields.description] || item.description,
    expanded: item[fields.expanded] || item.expanded,
    images: item[fields.images] || item.images,
    actions: item[fields.actions] || item.actions,
});
/**
 * @hidden
 */
const MAX_VISIBLE_EVENTS = 3;

/**
 * @hidden
 */
class TimelineService {
    timeline;
    onToggle(event) {
        if (this.timeline) {
            this.timeline['onToggle']?.emit(event);
        }
    }
    onActionClick(event) {
        if (this.timeline) {
            this.timeline['onActionClick']?.emit(event);
        }
    }
    onNavigate(event) {
        if (this.timeline) {
            this.timeline['onNavigate']?.emit(event);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TimelineService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TimelineService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TimelineService, decorators: [{
            type: Injectable
        }] });

/**
 * @hidden
 */
class TimelineCardComponent {
    element;
    timelineService;
    renderer;
    event;
    expanded = false;
    collapsible = true;
    reversed = false;
    orientation;
    navigable;
    tabIndex;
    animationDuration;
    index;
    eventWidth;
    eventHeight;
    headerTemplate;
    bodyTemplate;
    actionsTemplate;
    set calloutStyle(value) {
        // applies only to horizontal orientation where the callout points upwards
        if (!this.calloutElementRef || !this.calloutElementRef.nativeElement.classList.contains('k-callout-n')) {
            return;
        }
        this.calloutElementRef.nativeElement.style.left = value?.left;
    }
    calloutElementRef;
    hostClass = true;
    get collapsedClass() {
        return !this.expanded && !this.animationInProgress && this.animationState === 'collapsed';
    }
    onComponentKeyDown(event) {
        if (!this.navigable) {
            return;
        }
        if (event.code === Keys.Space || event.code === Keys.Enter || event.code === Keys.NumpadEnter) {
            event.preventDefault();
            if (this.collapsible && this.orientation === 'vertical') {
                this.expanded = !this.expanded;
            }
        }
    }
    get role() {
        return this.orientation === 'vertical' ? 'button' : 'tabpanel';
    }
    get ariaLive() {
        return this.orientation === 'vertical' ? 'polite' : null;
    }
    get ariaExpanded() {
        return this.orientation === 'vertical' ? this.expanded : null;
    }
    calloutSvgIcon = chevronRightIcon;
    calloutFontIcon = 'arrow-chevron-right';
    animationState = this.expanded ? 'expanded' : 'collapsed';
    animationInProgress = false;
    constructor(element, timelineService, renderer) {
        this.element = element;
        this.timelineService = timelineService;
        this.renderer = renderer;
    }
    ngAfterViewInit() {
        this.makeOverflowVisible();
    }
    ngOnChanges(changes) {
        if (isChanged('collapsible', changes, false)) {
            if (!this.collapsible) {
                this.expanded = true;
            }
        }
    }
    toggle() {
        if (this.orientation === 'vertical') {
            this.expanded = this.collapsible ? !this.expanded : true;
            this.timelineService.onToggle(this.index);
        }
    }
    expand() {
        if (!this.expanded) {
            this.expanded = true;
            this.timelineService.onToggle(this.index);
        }
    }
    collapse() {
        if (!this.collapsible || !this.expanded) {
            return;
        }
        this.expanded = false;
        this.timelineService.onToggle(this.index);
    }
    onActionClick(event) {
        event.stopPropagation();
        this.timelineService.onActionClick(this.index);
    }
    animationStart() {
        this.animationInProgress = true;
    }
    animationDone(event) {
        this.animationInProgress = false;
        if (event.toState === 'expanded' && event.fromState !== 'expanded') {
            this.animationState = 'expanded';
            this.makeOverflowVisible();
        }
        else if (event.toState === 'collapsed' && event.fromState !== 'collapsed') {
            this.animationState = 'collapsed';
        }
    }
    makeOverflowVisible() {
        if (this.orientation === 'vertical') {
            return;
        }
        const cardBody = this.element?.nativeElement.querySelector('.k-card-body');
        if (cardBody) {
            this.renderer.setStyle(cardBody, 'overflow', 'auto');
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TimelineCardComponent, deps: [{ token: i0.ElementRef }, { token: TimelineService }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: TimelineCardComponent, isStandalone: true, selector: "kendo-timeline-card", inputs: { event: "event", expanded: "expanded", collapsible: "collapsible", reversed: "reversed", orientation: "orientation", navigable: "navigable", tabIndex: "tabIndex", animationDuration: "animationDuration", index: "index", eventWidth: "eventWidth", eventHeight: "eventHeight", headerTemplate: "headerTemplate", bodyTemplate: "bodyTemplate", actionsTemplate: "actionsTemplate", calloutStyle: "calloutStyle" }, host: { listeners: { "keydown": "onComponentKeyDown($event)" }, properties: { "class.k-timeline-card": "this.hostClass", "class.k-collapsed": "this.collapsedClass" } }, providers: [], viewQueries: [{ propertyName: "calloutElementRef", first: true, predicate: ["callout"], descendants: true }], exportAs: ["kendoTimelineCard"], usesOnChanges: true, ngImport: i0, template: `
        <kendo-card
          [ngStyle]="{ 'height': orientation === 'horizontal' ? eventHeight + 'px' : null }"
          [width]="orientation === 'horizontal' ? 'auto' : eventWidth + 'px'"
          class="k-card-with-callout k-card-vertical"
          (click)="toggle()"
          [attr.role]="role"
          [attr.aria-live]="ariaLive"
          [attr.aria-expanded]="ariaExpanded"
          [attr.tabindex]="tabIndex"
          >
          <span
            #callout
            class="k-timeline-card-callout k-card-callout"
                [ngClass]="{
                    'k-callout-n': orientation === 'horizontal',
                    'k-callout-w': orientation === 'vertical' && !this.reversed,
                    'k-callout-e': orientation === 'vertical' && this.reversed
                }"
            >
          </span>
          @if (event) {
            <div class="k-card-inner">
              <kendo-card-header>
                @if (headerTemplate) {
                  <ng-template
                    [ngTemplateOutlet]="headerTemplate?.templateRef"
                    [ngTemplateOutletContext]="{ $implicit: event, index: index}">
                    >
                  </ng-template>
                }
                @if (!headerTemplate) {
                  <div kendoCardTitle>
                    <span class="k-event-title">{{ event.title }}</span>
                    @if (collapsible && orientation === 'vertical') {
                      <button
                        kendoButton
                        [icon]="calloutFontIcon"
                        [svgIcon]="calloutSvgIcon"
                        class="k-event-collapse"
                        fillMode="flat"
                        [attr.aria-hidden]="true"
                        tabindex="-1"
                        type="button"
                      ></button>
                    }
                  </div>
                }
                @if (!headerTemplate) {
                  <div kendoCardSubtitle >{{ event.subtitle }}</div>
                }
              </kendo-card-header>
              @if (event.description || event.images) {
                <kendo-card-body
                  [@toggle]="{value: expanded ? 'expanded' : 'collapsed', params: {animationDuration: this.animationDuration || 0}}"
                  (@toggle.start)="animationStart()"
                  (@toggle.done)="animationDone($event)"
                  >
                  @if (bodyTemplate) {
                    <ng-template
                      [ngTemplateOutlet]="bodyTemplate?.templateRef"
                      [ngTemplateOutletContext]="{ $implicit: event, index: index}">
                      >
                    </ng-template>
                  }
                  @if (!bodyTemplate) {
                    <div class="k-card-description">
                      @if (event.description) {
                        <p>{{ event.description }}</p>
                      }
                      @for (image of event.images; track image) {
                        @if (image.alt) {
                          <img kendoCardMedia [src]="image.src" [alt]="image.alt" />
                        }
                        @if (!image.alt) {
                          <img kendoCardMedia [src]="image.src" />
                        }
                      }
                    </div>
                  }
                </kendo-card-body>
              }
              @if (event.actions) {
                <kendo-card-actions
                  [@toggle]="{value: expanded ? 'expanded' : 'collapsed', params: {animationDuration: this.animationDuration || 0}}"
                  >
                  @if (actionsTemplate) {
                    <ng-template
                      [ngTemplateOutlet]="actionsTemplate?.templateRef"
                      [ngTemplateOutletContext]="{ $implicit: event, index: index}">
                      >
                    </ng-template>
                  }
                  @if (!actionsTemplate) {
                    @for (action of event.actions; track action) {
                      <a
                        [href]="action.url"
                        [target]="action.target === 'blank' ? '_blank' : '_self'"
                        (click)="onActionClick($event)"
                        class="k-button k-button-md k-rounded-md k-button-flat k-button-flat-primary"
                        role="button"
                        >
                        {{ action.text }}
                      </a>
                    }
                  }
                </kendo-card-actions>
              }
            </div>
          }
        </kendo-card>
        `, isInline: true, dependencies: [{ kind: "component", type: CardComponent, selector: "kendo-card", inputs: ["orientation", "width"] }, { kind: "directive", type: NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "component", type: CardHeaderComponent, selector: "kendo-card-header" }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: CardTitleDirective, selector: "[kendoCardTitle]" }, { kind: "component", type: ButtonComponent, selector: "button[kendoButton]", inputs: ["arrowIcon", "toggleable", "togglable", "selected", "tabIndex", "imageUrl", "iconClass", "icon", "disabled", "size", "rounded", "fillMode", "themeColor", "svgIcon", "primary", "look"], outputs: ["selectedChange", "click"], exportAs: ["kendoButton"] }, { kind: "directive", type: CardSubtitleDirective, selector: "[kendoCardSubtitle]" }, { kind: "component", type: CardBodyComponent, selector: "kendo-card-body" }, { kind: "directive", type: CardMediaDirective, selector: "[kendoCardMedia]" }, { kind: "component", type: CardActionsComponent, selector: "kendo-card-actions", inputs: ["orientation", "layout", "actions"], outputs: ["action"] }], animations: [
            trigger('toggle', [
                state('collapsed', style({
                    height: '0',
                    'overflow-y': 'hidden',
                    display: 'none'
                })),
                state('expanded', style({
                    height: '*',
                    'overflow-y': 'hidden',
                    display: 'block'
                })),
                transition('collapsed <=> expanded', [
                    animate('{{animationDuration}}ms')
                ], { params: { animationDuration: '400' } }),
            ])
        ] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TimelineCardComponent, decorators: [{
            type: Component,
            args: [{
                    animations: [
                        trigger('toggle', [
                            state('collapsed', style({
                                height: '0',
                                'overflow-y': 'hidden',
                                display: 'none'
                            })),
                            state('expanded', style({
                                height: '*',
                                'overflow-y': 'hidden',
                                display: 'block'
                            })),
                            transition('collapsed <=> expanded', [
                                animate('{{animationDuration}}ms')
                            ], { params: { animationDuration: '400' } }),
                        ])
                    ],
                    providers: [],
                    exportAs: 'kendoTimelineCard',
                    selector: 'kendo-timeline-card',
                    template: `
        <kendo-card
          [ngStyle]="{ 'height': orientation === 'horizontal' ? eventHeight + 'px' : null }"
          [width]="orientation === 'horizontal' ? 'auto' : eventWidth + 'px'"
          class="k-card-with-callout k-card-vertical"
          (click)="toggle()"
          [attr.role]="role"
          [attr.aria-live]="ariaLive"
          [attr.aria-expanded]="ariaExpanded"
          [attr.tabindex]="tabIndex"
          >
          <span
            #callout
            class="k-timeline-card-callout k-card-callout"
                [ngClass]="{
                    'k-callout-n': orientation === 'horizontal',
                    'k-callout-w': orientation === 'vertical' && !this.reversed,
                    'k-callout-e': orientation === 'vertical' && this.reversed
                }"
            >
          </span>
          @if (event) {
            <div class="k-card-inner">
              <kendo-card-header>
                @if (headerTemplate) {
                  <ng-template
                    [ngTemplateOutlet]="headerTemplate?.templateRef"
                    [ngTemplateOutletContext]="{ $implicit: event, index: index}">
                    >
                  </ng-template>
                }
                @if (!headerTemplate) {
                  <div kendoCardTitle>
                    <span class="k-event-title">{{ event.title }}</span>
                    @if (collapsible && orientation === 'vertical') {
                      <button
                        kendoButton
                        [icon]="calloutFontIcon"
                        [svgIcon]="calloutSvgIcon"
                        class="k-event-collapse"
                        fillMode="flat"
                        [attr.aria-hidden]="true"
                        tabindex="-1"
                        type="button"
                      ></button>
                    }
                  </div>
                }
                @if (!headerTemplate) {
                  <div kendoCardSubtitle >{{ event.subtitle }}</div>
                }
              </kendo-card-header>
              @if (event.description || event.images) {
                <kendo-card-body
                  [@toggle]="{value: expanded ? 'expanded' : 'collapsed', params: {animationDuration: this.animationDuration || 0}}"
                  (@toggle.start)="animationStart()"
                  (@toggle.done)="animationDone($event)"
                  >
                  @if (bodyTemplate) {
                    <ng-template
                      [ngTemplateOutlet]="bodyTemplate?.templateRef"
                      [ngTemplateOutletContext]="{ $implicit: event, index: index}">
                      >
                    </ng-template>
                  }
                  @if (!bodyTemplate) {
                    <div class="k-card-description">
                      @if (event.description) {
                        <p>{{ event.description }}</p>
                      }
                      @for (image of event.images; track image) {
                        @if (image.alt) {
                          <img kendoCardMedia [src]="image.src" [alt]="image.alt" />
                        }
                        @if (!image.alt) {
                          <img kendoCardMedia [src]="image.src" />
                        }
                      }
                    </div>
                  }
                </kendo-card-body>
              }
              @if (event.actions) {
                <kendo-card-actions
                  [@toggle]="{value: expanded ? 'expanded' : 'collapsed', params: {animationDuration: this.animationDuration || 0}}"
                  >
                  @if (actionsTemplate) {
                    <ng-template
                      [ngTemplateOutlet]="actionsTemplate?.templateRef"
                      [ngTemplateOutletContext]="{ $implicit: event, index: index}">
                      >
                    </ng-template>
                  }
                  @if (!actionsTemplate) {
                    @for (action of event.actions; track action) {
                      <a
                        [href]="action.url"
                        [target]="action.target === 'blank' ? '_blank' : '_self'"
                        (click)="onActionClick($event)"
                        class="k-button k-button-md k-rounded-md k-button-flat k-button-flat-primary"
                        role="button"
                        >
                        {{ action.text }}
                      </a>
                    }
                  }
                </kendo-card-actions>
              }
            </div>
          }
        </kendo-card>
        `,
                    standalone: true,
                    imports: [CardComponent, NgStyle, NgClass, CardHeaderComponent, NgTemplateOutlet, CardTitleDirective, ButtonComponent, CardSubtitleDirective, CardBodyComponent, CardMediaDirective, CardActionsComponent]
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: TimelineService }, { type: i0.Renderer2 }], propDecorators: { event: [{
                type: Input
            }], expanded: [{
                type: Input
            }], collapsible: [{
                type: Input
            }], reversed: [{
                type: Input
            }], orientation: [{
                type: Input
            }], navigable: [{
                type: Input
            }], tabIndex: [{
                type: Input
            }], animationDuration: [{
                type: Input
            }], index: [{
                type: Input
            }], eventWidth: [{
                type: Input
            }], eventHeight: [{
                type: Input
            }], headerTemplate: [{
                type: Input
            }], bodyTemplate: [{
                type: Input
            }], actionsTemplate: [{
                type: Input
            }], calloutStyle: [{
                type: Input
            }], calloutElementRef: [{
                type: ViewChild,
                args: ['callout']
            }], hostClass: [{
                type: HostBinding,
                args: ['class.k-timeline-card']
            }], collapsedClass: [{
                type: HostBinding,
                args: ['class.k-collapsed']
            }], onComponentKeyDown: [{
                type: HostListener,
                args: ['keydown', ['$event']]
            }] } });

const DEFAULT_TAB_WIDTH = 200;
const SPACE_BETWEEN_TABS = 25;
const TRANSITION_EVENTS_COUNT = 3;
/**
 * @hidden
 */
class TimelineHorizontalComponent {
    cdr;
    _zone;
    renderer;
    timelineService;
    localization;
    events = [];
    alterMode;
    collapsibleEvents;
    navigable;
    showDateLabels;
    animationDuration;
    eventHeight;
    dateFormat;
    headerTemplate;
    bodyTemplate;
    actionsTemplate;
    cardElementRefs;
    circleElementRefs;
    flagElementRefs;
    trackElementRef;
    scrollableTrackElementRef;
    cardComponents;
    get selectedEvent() {
        return this._selectedEvent;
    }
    set selectedEvent(value) {
        if (this._selectedEvent === value) {
            return;
        }
        const newSelectedIndex = this.events.findIndex(event => event === value);
        if (newSelectedIndex === -1 && value !== null) {
            return;
        }
        this._selectedEvent = value;
        this.selectedEventIndex = newSelectedIndex;
        this.calloutStyle = this.calloutOffset;
    }
    trackWrapWidth;
    scrollableTrackWidth;
    cardWidth;
    svgLeftIcon = caretAltLeftIcon;
    svgRightIcon = caretAltRightIcon;
    calloutStyle;
    animationState = 'center';
    translateValue = 0;
    eventsInInterval = [0, 1, 2];
    selectedCardIndex = 0;
    selectedEventIndex;
    tabFlex;
    tabWidth = DEFAULT_TAB_WIDTH;
    visibleTabsCount;
    firstCircleInView = 0;
    visibleEvents = [];
    trackItems = [];
    previousTitle = 'previous';
    nextTitle = 'next';
    _selectedEvent;
    subscriptions = new Subscription();
    constructor(cdr, _zone, renderer, timelineService, localization) {
        this.cdr = cdr;
        this._zone = _zone;
        this.renderer = renderer;
        this.timelineService = timelineService;
        this.localization = localization;
    }
    ngOnInit() {
        this.l10nChange();
        this.subscriptions.add(this.localization.changes.subscribe(this.l10nChange.bind(this)));
        if (this.events.length > 0) {
            this.selectedEvent = this.events[0];
        }
        this.events.forEach(event => {
            if (event.flag) {
                this.trackItems.push({ isFlag: event.flag });
            }
            this.trackItems.push(event);
        });
    }
    ngAfterViewInit() {
        if (!isDocumentAvailable()) {
            return;
        }
        this.subscriptions.add(this.renderer.listen(this.trackElementRef.nativeElement, 'keydown', this.onKeyDown.bind(this)));
        this.trackWrapWidth = this.trackElementRef.nativeElement.getBoundingClientRect().width;
        this.scrollableTrackWidth = this.scrollableTrackElementRef.nativeElement.getBoundingClientRect().width;
        this._zone.runOutsideAngular(() => {
            this.onCirclesChange();
            this.subscriptions.add(this.circleElementRefs.changes.subscribe(this.onCirclesChange.bind(this)));
            this.subscriptions.add(this.cardElementRefs.changes.subscribe(this.onCardsChange.bind(this)));
        });
        if (this.events.length === 0) {
            return;
        }
        this.onCardsChange();
        if (this.cardComponents.get(this.selectedCardIndex)) {
            this.cardComponents.get(this.selectedCardIndex).calloutStyle = this.calloutOffset;
            this.focusTrackItem(0);
        }
    }
    ngOnChanges(changes) {
        if (isChanged('events', changes)) {
            if (!this.events || this.events.length === 0) {
                this.selectedEvent = null;
                this.trackItems = [];
                this.visibleEvents = [];
            }
            else {
                this.trackItems = [];
                this.events.forEach(event => {
                    if (event.flag) {
                        this.trackItems.push({ isFlag: event.flag });
                    }
                    this.trackItems.push(event);
                });
                this.navigateToFirstInterval();
            }
        }
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    onResize() {
        if (!isDocumentAvailable()) {
            return;
        }
        if (this.trackWrapWidth === this.trackElementRef.nativeElement.getBoundingClientRect().width) {
            return;
        }
        this.cardWidth = this.cardComponents.get(this.selectedCardIndex).element.nativeElement.offsetWidth;
        this.transformCards();
        this.trackWrapWidth = this.trackElementRef.nativeElement.getBoundingClientRect().width;
        this.scrollableTrackWidth = this.scrollableTrackElementRef.nativeElement.getBoundingClientRect().width;
        this.changeTabsCount();
        this._zone.run(() => {
            this.cardComponents.get(this.selectedCardIndex).calloutStyle = this.calloutOffset;
        });
    }
    onTransitionEnd() {
        this.cardElementRefs?.forEach(card => this.renderer.removeStyle(card.nativeElement, 'transition-duration'));
        this.cardComponents.get(this.selectedCardIndex).event = this.selectedEvent;
        this.calloutStyle = this.calloutOffset;
    }
    onTrackTransitionEnd() {
        this.calloutStyle = this.calloutOffset;
    }
    onSlideDone() {
        this.calloutStyle = this.calloutOffset;
    }
    previous() {
        if (this.firstCircleInView === 0) {
            return;
        }
        this.updateInterval(false);
    }
    previousClick() {
        this.previous();
        this.timelineService.onNavigate('previous');
    }
    next() {
        if (!this.visibleTabsCount || this.firstCircleInView + this.visibleTabsCount > this.trackItems.length) {
            return;
        }
        this.updateInterval(true);
    }
    nextClick() {
        this.next();
        this.timelineService.onNavigate('next');
    }
    open(index) {
        if (index < 0 || index >= this.events.length) {
            return;
        }
        if (this.visibleEvents.findIndex(event => event === this.events[index]) === -1) {
            // determine the start and end of the interval that the event belongs to, regardless of its position in the interval
            const trackItemIndex = this.trackItems.findIndex(event => event === this.events[index]);
            const start = Math.floor(trackItemIndex / this.visibleTabsCount) * this.visibleTabsCount;
            this.navigateToInterval(start, index);
        }
        this.selectedEvent = this.events[index];
        this.selectedCardIndex = this.getOtherSelectedCardIndex(index > this.selectedEventIndex);
        this.calloutStyle = this.calloutOffset;
        this.focusTrackItem(this.selectedEventIndex);
        this.animateCards();
    }
    navigateToEvent(index) {
        const eventIndex = this.events.findIndex(event => event === this.trackItems[index]);
        if (this.selectedEventIndex === eventIndex) {
            return;
        }
        this.selectedEvent = this.events[eventIndex];
        this.selectedCardIndex = this.getOtherSelectedCardIndex(index > eventIndex);
        this.calloutStyle = this.calloutOffset;
        this.animateCards();
    }
    getOtherSelectedCardIndex(forward) {
        // change the selected card which changes all cards' transform styles
        if (forward) {
            return this.selectedCardIndex === 0 ? TRANSITION_EVENTS_COUNT - 1 : this.selectedCardIndex - 1;
        }
        return this.selectedCardIndex === TRANSITION_EVENTS_COUNT - 1 ? 0 : this.selectedCardIndex + 1;
    }
    tabStyle() {
        if (!this.tabFlex) {
            return {};
        }
        return { 'flex': `1 0 ${this.tabFlex}%` };
    }
    getTransformation(width, position) {
        if (position === this.selectedCardIndex - 1 || position === this.selectedCardIndex + 2) {
            return `translate3d(${-width}px, 0, 0)`;
        }
        if (position === this.selectedCardIndex + 1 || position === this.selectedCardIndex - 2) {
            return `translate3d(${width}px, 0, 0)`;
        }
        return `translate3d(0, 0, 0)`;
    }
    getState(position) {
        if (position === this.selectedCardIndex) {
            return 'center';
        }
        if (position === this.selectedCardIndex - 1 || position === this.selectedCardIndex + 2) {
            return 'left';
        }
        return 'right';
    }
    get calloutOffset() {
        if (!isDocumentAvailable() || (!this.circleElementRefs?.first || !this.trackElementRef || !isPresent$1(this.selectedEventIndex))) {
            return {};
        }
        const circleCenter = this.circleElementRefs.get(this.selectedEventIndex).nativeElement.getBoundingClientRect().left +
            this.circleElementRefs.get(this.selectedEventIndex).nativeElement.offsetWidth / 2;
        const trackOffset = this.trackElementRef.nativeElement.getBoundingClientRect().left;
        return { left: `${circleCenter - trackOffset}px` };
    }
    get isFirstRange() {
        return this.firstCircleInView === 0;
    }
    get isLastRange() {
        if (!this.circleElementRefs?.first && !this.flagElementRefs?.first) {
            return false;
        }
        return this.trackItems.length === 0 ||
            this.firstCircleInView + this.visibleTabsCount >= this.trackItems.length;
    }
    onCardsChange() {
        if (this.cardElementRefs?.get(this.selectedCardIndex)) {
            this.cardWidth = this.cardElementRefs.get(this.selectedCardIndex).nativeElement.offsetWidth;
            this.transformCards();
        }
    }
    onCirclesChange() {
        if (!this.circleElementRefs?.first) {
            return;
        }
        this.circleElementRefs
            .map(element => element.nativeElement)
            .forEach((element, index) => {
            this.subscriptions.add(this.renderer.listen(element, 'click', () => {
                this.focusTrackItem(index);
            }));
        });
        const width = this.circleElementRefs.first.nativeElement.getBoundingClientRect().width;
        if (width > DEFAULT_TAB_WIDTH) {
            this.tabWidth = this.circleElementRefs.first.nativeElement.getBoundingClientRect().width + SPACE_BETWEEN_TABS;
        }
        this.changeTabsCount();
        this.visibleEvents = this.trackItems
            .slice(this.firstCircleInView, this.firstCircleInView + this.visibleTabsCount)
            .filter(event => !event.isFlag);
    }
    onKeyDown(event) {
        if (!this.navigable) {
            return;
        }
        const code = normalizeKeys(event);
        event.preventDefault();
        if (code === Keys.Home) {
            this.onHomeKey();
        }
        else if (code === Keys.End) {
            this.onEndKey();
        }
        else if (code === Keys.ArrowRight) {
            this.onArrowRightKey();
        }
        else if (code === Keys.ArrowLeft) {
            this.onArrowLeftKey();
        }
    }
    focusTrackItem(index) {
        if (!isDocumentAvailable()) {
            return;
        }
        if (!this.circleElementRefs || index < 0 || index >= this.circleElementRefs.length) {
            return;
        }
        const selectedTrackItem = this.circleElementRefs
            .find(element => element.nativeElement.hasAttribute('aria-selected'));
        if (selectedTrackItem) {
            this.removeTrackItemAttributes(selectedTrackItem);
            this.removeCardsAttributes();
        }
        const newTrackItem = this.circleElementRefs.get(index).nativeElement;
        this.setTrackItemAttributes(newTrackItem, index);
    }
    setTrackItemAttributes(element, index) {
        if (!isDocumentAvailable()) {
            return;
        }
        const innerCard = this.cardComponents.get(this.selectedCardIndex).element.nativeElement.querySelector('.k-card');
        const selectedCircle = this.circleElementRefs.get(index).nativeElement;
        this.renderer.addClass(element, 'k-focus');
        this.renderer.setAttribute(element, 'aria-selected', 'true');
        this.assignAriaLabel(innerCard, selectedCircle);
        this.assignAriaDescribedBy(innerCard, selectedCircle);
    }
    removeTrackItemAttributes(element) {
        this.renderer.removeClass(element.nativeElement, 'k-focus');
        this.renderer.removeAttribute(element.nativeElement, 'aria-selected');
        this.renderer.removeAttribute(element.nativeElement, 'id');
        this.renderer.removeAttribute(element.nativeElement, 'aria-describedby');
    }
    removeCardsAttributes() {
        this.cardElementRefs.forEach(card => {
            this.renderer.removeAttribute(card.nativeElement.querySelector('.k-card'), 'id');
            this.renderer.removeAttribute(card.nativeElement.querySelector('.k-card'), 'aria-label');
        });
    }
    assignAriaLabel(cardElement, dateElement) {
        const dateLabelId = `k-${guid()}`;
        this.renderer.setAttribute(dateElement, 'id', dateLabelId);
        this.renderer.setAttribute(cardElement, 'aria-label', dateLabelId);
    }
    assignAriaDescribedBy(cardElement, dateElement) {
        const cardId = `k-${guid()}`;
        this.renderer.setAttribute(cardElement, 'id', cardId);
        this.renderer.setAttribute(dateElement, 'aria-describedby', cardId);
    }
    updateInterval(forward) {
        let start = forward ? this.firstCircleInView + this.visibleTabsCount : this.firstCircleInView - this.visibleTabsCount;
        if (start < 0 || start >= this.trackItems.length) {
            start = 0;
        }
        this.navigateToInterval(start, 0, forward, !forward);
    }
    onHomeKey() {
        if (this.selectedEvent === this.events[0]) {
            return;
        }
        this.navigateToFirstInterval();
    }
    onEndKey() {
        if (this.selectedEvent === this.events[this.events.length - 1]) {
            return;
        }
        this.navigateToLastInterval();
    }
    onArrowRightKey() {
        this.navigateToOtherEvent(true);
    }
    onArrowLeftKey() {
        this.navigateToOtherEvent(false);
    }
    navigateToFirstInterval() {
        this.navigateToInterval(0);
    }
    navigateToLastInterval() {
        const start = Math.floor((this.trackItems.length - 1) / this.visibleTabsCount) * this.visibleTabsCount;
        this.navigateToInterval(start, this.events.length - 1);
    }
    navigateToOtherEvent(direction) {
        const offset = direction ? 1 : -1;
        const newIndex = this.selectedEventIndex + offset;
        if (newIndex < 0 || newIndex >= this.events.length) {
            return;
        }
        if (this.visibleEvents.findIndex(event => event === this.events[newIndex]) === -1) {
            this.updateInterval(direction);
        }
        else {
            this.selectedEvent = this.events[newIndex];
            this.selectedCardIndex = this.getOtherSelectedCardIndex(direction);
            this.focusTrackItem(this.selectedEventIndex);
            this.animateCards();
            this.cdr.markForCheck();
        }
    }
    navigateToInterval(start, selectedIndex = 0, selectFirst = false, selectLast = false) {
        const end = start + this.visibleTabsCount < this.trackItems.length ? start + this.visibleTabsCount : undefined;
        const forward = this.firstCircleInView < start;
        this.firstCircleInView = start;
        const interval = Math.floor(start / this.visibleTabsCount);
        this.translateValue = interval * -100;
        this.animationState = forward ? 'right' : 'left';
        this.visibleEvents = this.trackItems.slice(this.firstCircleInView, end).filter(event => !event.isFlag);
        if (selectFirst) {
            this.selectedEvent = this.visibleEvents[0];
        }
        else if (selectLast) {
            this.selectedEvent = this.visibleEvents[this.visibleEvents.length - 1];
        }
        else {
            this.selectedEvent = this.events[selectedIndex];
        }
        this.selectedCardIndex = this.getOtherSelectedCardIndex(forward);
        this.cdr.detectChanges();
        this.focusTrackItem(this.selectedEventIndex);
        this.animateCards();
        this.calloutStyle = this.calloutOffset;
        this.cdr.markForCheck();
    }
    animateCards() {
        if (this.animationDuration) {
            this.cardComponents.get(this.selectedCardIndex).event = null;
        }
        this.cardElementRefs.forEach((card, index) => {
            this.renderer.setStyle(card.nativeElement, 'transform', this.getTransformation(this.cardWidth, index));
            this.renderer.setStyle(card.nativeElement, 'transition-duration', `${this.animationDuration || 0}ms`);
        });
    }
    transformCards() {
        this.cardElementRefs.forEach((card, index) => this.renderer.setStyle(card.nativeElement, 'transform', this.getTransformation(this.cardWidth, index)));
    }
    changeTabsCount() {
        this.visibleTabsCount = Math.round(this.scrollableTrackWidth / this.tabWidth);
        if (this.tabFlex !== 100 / this.visibleTabsCount) {
            this.tabFlex = 100 / this.visibleTabsCount;
            this.circleElementRefs.forEach(item => this.renderer.setStyle(item.nativeElement, 'flex', `1 0 ${this.tabFlex}%`));
            this.flagElementRefs.forEach(item => this.renderer.setStyle(item.nativeElement, 'flex', `1 0 ${this.tabFlex}%`));
            this.cdr.detectChanges();
            this.visibleEvents = this.trackItems
                .slice(this.firstCircleInView, this.firstCircleInView + this.visibleTabsCount)
                .filter(event => !event.isFlag);
            if (!this.visibleEvents.find(event => event === this.selectedEvent)) {
                const trackItemIndex = this.trackItems.findIndex(event => event === this.selectedEvent);
                this.navigateToInterval(trackItemIndex, this.selectedEventIndex);
            }
        }
    }
    l10nChange() {
        if (this.localization.get('previous')) {
            this.previousTitle = this.localization.get('previous');
        }
        if (this.localization.get('next')) {
            this.nextTitle = this.localization.get('next');
        }
        this.cdr.markForCheck();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TimelineHorizontalComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.NgZone }, { token: i0.Renderer2 }, { token: TimelineService }, { token: i1.LocalizationService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: TimelineHorizontalComponent, isStandalone: true, selector: "kendo-timeline-horizontal", inputs: { events: "events", alterMode: "alterMode", collapsibleEvents: "collapsibleEvents", navigable: "navigable", showDateLabels: "showDateLabels", animationDuration: "animationDuration", eventHeight: "eventHeight", dateFormat: "dateFormat", headerTemplate: "headerTemplate", bodyTemplate: "bodyTemplate", actionsTemplate: "actionsTemplate" }, providers: [], viewQueries: [{ propertyName: "trackElementRef", first: true, predicate: ["track"], descendants: true }, { propertyName: "scrollableTrackElementRef", first: true, predicate: ["scrollableTrack"], descendants: true }, { propertyName: "cardElementRefs", predicate: ["card"], descendants: true, read: ElementRef }, { propertyName: "circleElementRefs", predicate: ["trackCircle"], descendants: true }, { propertyName: "flagElementRefs", predicate: ["trackFlag"], descendants: true }, { propertyName: "cardComponents", predicate: TimelineCardComponent, descendants: true }], exportAs: ["kendoTimelineHorizontal"], usesOnChanges: true, ngImport: i0, template: `
        <div class="k-timeline-track-wrap" #track>
          <button
            kendoButton
            [svgIcon]="svgLeftIcon"
            icon="caret-alt-left"
            class="k-timeline-arrow k-timeline-arrow-left"
            rounded="full"
            [title]="previousTitle"
            (click)="previousClick()"
            [disabled]="isFirstRange"
            tabindex="-1"
            type="button"
          ></button>
          <button
            kendoButton
            [svgIcon]="svgRightIcon"
            icon="caret-alt-right"
            class="k-timeline-arrow k-timeline-arrow-right"
            rounded="full"
            [title]="nextTitle"
            (click)="nextClick()"
            [disabled]="isLastRange"
            tabindex="-1"
            type="button"
          ></button>
          <div class="k-timeline-track">
            <ul class="k-timeline-scrollable-wrap"
              #scrollableTrack
              [attr.role]="'tablist'"
              [attr.tabindex]="'0'"
              [@trackSlide]="{value: animationState, params: {transformValue: this.translateValue}}"
              (@trackSlide.done)="onSlideDone()"
              (transitionend)="onTrackTransitionEnd()"
              >
              @for (event of trackItems; track event; let index = $index) {
                @if (event.isFlag) {
                  <li
                    #trackFlag
                    class="k-timeline-flag-wrap k-timeline-track-item"
                    [attr.role]="'none'"
                    [attr.aria-hidden]="true"
                    [ngStyle]="tabStyle()"
                    >
                    <span class="k-timeline-flag">{{ event.isFlag }}</span>
                  </li>
                }
                @if (!event.isFlag) {
                  <li
                    #trackCircle
                    class="k-timeline-track-item"
                    [attr.role]="'tab'"
                    (click)="navigateToEvent(index)"
                    [ngStyle]="tabStyle()"
                    >
                    <div class="k-timeline-date-wrap">
                      @if (showDateLabels) {
                        <span class="k-timeline-date">
                          {{ event.date | kendoDate: dateFormat }}
                        </span>
                      }
                    </div>
                    <span class="k-timeline-circle"></span>
                  </li>
                }
              }
            </ul>
          </div>
        </div>
        <div class="k-timeline-events-list">
          @if (selectedEvent) {
            <ul
              class="k-timeline-scrollable-wrap"
              [@eventsSlide]="{value: animationState, params: {animationDuration: this.animationDuration || 0}}"
              (@eventsSlide.done)="onSlideDone()"
              [ngStyle]="{'transform-origin': 'left top'}"
              >
              @for (event of eventsInInterval; track event; let index = $index) {
                <li
                  #card
                  class="k-timeline-event"
                  (transitionend)="onTransitionEnd()"
                  >
                  <kendo-timeline-card
                    [event]="selectedCardIndex === index ? selectedEvent : null"
                    [expanded]="true"
                    [collapsible]="collapsibleEvents"
                    [calloutStyle]="selectedCardIndex === index ? calloutStyle : {}"
                    [ngStyle]="{visibility: selectedCardIndex === index ? 'visible' : 'hidden' }"
                    [tabIndex]="selectedCardIndex === index ? '0' : '-1'"
                    [navigable]="navigable"
                    [index]="selectedEventIndex"
                    [headerTemplate]="headerTemplate"
                    [bodyTemplate]="bodyTemplate"
                    [actionsTemplate]="actionsTemplate"
                    [eventHeight]="eventHeight"
                    orientation="horizontal"
                    >
                  </kendo-timeline-card>
                </li>
              }
            </ul>
          }
          <kendo-resize-sensor (resize)="onResize()" [rateLimit]="10"></kendo-resize-sensor>
        </div>
        `, isInline: true, dependencies: [{ kind: "component", type: ButtonComponent, selector: "button[kendoButton]", inputs: ["arrowIcon", "toggleable", "togglable", "selected", "tabIndex", "imageUrl", "iconClass", "icon", "disabled", "size", "rounded", "fillMode", "themeColor", "svgIcon", "primary", "look"], outputs: ["selectedChange", "click"], exportAs: ["kendoButton"] }, { kind: "directive", type: NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "component", type: TimelineCardComponent, selector: "kendo-timeline-card", inputs: ["event", "expanded", "collapsible", "reversed", "orientation", "navigable", "tabIndex", "animationDuration", "index", "eventWidth", "eventHeight", "headerTemplate", "bodyTemplate", "actionsTemplate", "calloutStyle"], exportAs: ["kendoTimelineCard"] }, { kind: "pipe", type: DatePipe, name: "kendoDate" }, { kind: "component", type: ResizeSensorComponent, selector: "kendo-resize-sensor", inputs: ["rateLimit"], outputs: ["resize"] }], animations: [
            trigger('trackSlide', [
                state('left', style({
                    transform: `translateX({{transformValue}}%)`,
                }), { params: { transformValue: '0' } }),
                state('right', style({
                    transform: `translateX({{transformValue}}%)`,
                }), { params: { transformValue: '0' } }),
                state('center', style({
                    transform: `translateX(0)`,
                }))
            ]),
            trigger('eventsSlide', [
                transition('* => right', [
                    animate('{{animationDuration}}ms', style({ transform: `translateX(-100%)` }))
                ], { params: { animationDuration: '400' } }),
                transition('* => left', [
                    animate('{{animationDuration}}ms', style({ transform: `translateX(100%)` }))
                ], { params: { animationDuration: '400' } })
            ])
        ] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TimelineHorizontalComponent, decorators: [{
            type: Component,
            args: [{
                    animations: [
                        trigger('trackSlide', [
                            state('left', style({
                                transform: `translateX({{transformValue}}%)`,
                            }), { params: { transformValue: '0' } }),
                            state('right', style({
                                transform: `translateX({{transformValue}}%)`,
                            }), { params: { transformValue: '0' } }),
                            state('center', style({
                                transform: `translateX(0)`,
                            }))
                        ]),
                        trigger('eventsSlide', [
                            transition('* => right', [
                                animate('{{animationDuration}}ms', style({ transform: `translateX(-100%)` }))
                            ], { params: { animationDuration: '400' } }),
                            transition('* => left', [
                                animate('{{animationDuration}}ms', style({ transform: `translateX(100%)` }))
                            ], { params: { animationDuration: '400' } })
                        ])
                    ],
                    providers: [],
                    exportAs: 'kendoTimelineHorizontal',
                    selector: 'kendo-timeline-horizontal',
                    template: `
        <div class="k-timeline-track-wrap" #track>
          <button
            kendoButton
            [svgIcon]="svgLeftIcon"
            icon="caret-alt-left"
            class="k-timeline-arrow k-timeline-arrow-left"
            rounded="full"
            [title]="previousTitle"
            (click)="previousClick()"
            [disabled]="isFirstRange"
            tabindex="-1"
            type="button"
          ></button>
          <button
            kendoButton
            [svgIcon]="svgRightIcon"
            icon="caret-alt-right"
            class="k-timeline-arrow k-timeline-arrow-right"
            rounded="full"
            [title]="nextTitle"
            (click)="nextClick()"
            [disabled]="isLastRange"
            tabindex="-1"
            type="button"
          ></button>
          <div class="k-timeline-track">
            <ul class="k-timeline-scrollable-wrap"
              #scrollableTrack
              [attr.role]="'tablist'"
              [attr.tabindex]="'0'"
              [@trackSlide]="{value: animationState, params: {transformValue: this.translateValue}}"
              (@trackSlide.done)="onSlideDone()"
              (transitionend)="onTrackTransitionEnd()"
              >
              @for (event of trackItems; track event; let index = $index) {
                @if (event.isFlag) {
                  <li
                    #trackFlag
                    class="k-timeline-flag-wrap k-timeline-track-item"
                    [attr.role]="'none'"
                    [attr.aria-hidden]="true"
                    [ngStyle]="tabStyle()"
                    >
                    <span class="k-timeline-flag">{{ event.isFlag }}</span>
                  </li>
                }
                @if (!event.isFlag) {
                  <li
                    #trackCircle
                    class="k-timeline-track-item"
                    [attr.role]="'tab'"
                    (click)="navigateToEvent(index)"
                    [ngStyle]="tabStyle()"
                    >
                    <div class="k-timeline-date-wrap">
                      @if (showDateLabels) {
                        <span class="k-timeline-date">
                          {{ event.date | kendoDate: dateFormat }}
                        </span>
                      }
                    </div>
                    <span class="k-timeline-circle"></span>
                  </li>
                }
              }
            </ul>
          </div>
        </div>
        <div class="k-timeline-events-list">
          @if (selectedEvent) {
            <ul
              class="k-timeline-scrollable-wrap"
              [@eventsSlide]="{value: animationState, params: {animationDuration: this.animationDuration || 0}}"
              (@eventsSlide.done)="onSlideDone()"
              [ngStyle]="{'transform-origin': 'left top'}"
              >
              @for (event of eventsInInterval; track event; let index = $index) {
                <li
                  #card
                  class="k-timeline-event"
                  (transitionend)="onTransitionEnd()"
                  >
                  <kendo-timeline-card
                    [event]="selectedCardIndex === index ? selectedEvent : null"
                    [expanded]="true"
                    [collapsible]="collapsibleEvents"
                    [calloutStyle]="selectedCardIndex === index ? calloutStyle : {}"
                    [ngStyle]="{visibility: selectedCardIndex === index ? 'visible' : 'hidden' }"
                    [tabIndex]="selectedCardIndex === index ? '0' : '-1'"
                    [navigable]="navigable"
                    [index]="selectedEventIndex"
                    [headerTemplate]="headerTemplate"
                    [bodyTemplate]="bodyTemplate"
                    [actionsTemplate]="actionsTemplate"
                    [eventHeight]="eventHeight"
                    orientation="horizontal"
                    >
                  </kendo-timeline-card>
                </li>
              }
            </ul>
          }
          <kendo-resize-sensor (resize)="onResize()" [rateLimit]="10"></kendo-resize-sensor>
        </div>
        `,
                    standalone: true,
                    imports: [ButtonComponent, NgStyle, TimelineCardComponent, DatePipe, ResizeSensorComponent]
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.NgZone }, { type: i0.Renderer2 }, { type: TimelineService }, { type: i1.LocalizationService }], propDecorators: { events: [{
                type: Input
            }], alterMode: [{
                type: Input
            }], collapsibleEvents: [{
                type: Input
            }], navigable: [{
                type: Input
            }], showDateLabels: [{
                type: Input
            }], animationDuration: [{
                type: Input
            }], eventHeight: [{
                type: Input
            }], dateFormat: [{
                type: Input
            }], headerTemplate: [{
                type: Input
            }], bodyTemplate: [{
                type: Input
            }], actionsTemplate: [{
                type: Input
            }], cardElementRefs: [{
                type: ViewChildren,
                args: ['card', { read: ElementRef }]
            }], circleElementRefs: [{
                type: ViewChildren,
                args: ['trackCircle']
            }], flagElementRefs: [{
                type: ViewChildren,
                args: ['trackFlag']
            }], trackElementRef: [{
                type: ViewChild,
                args: ['track']
            }], scrollableTrackElementRef: [{
                type: ViewChild,
                args: ['scrollableTrack']
            }], cardComponents: [{
                type: ViewChildren,
                args: [TimelineCardComponent]
            }] } });

/**
 * @hidden
 */
class TimelineVerticalComponent {
    renderer;
    events = [];
    alterMode;
    collapsibleEvents;
    navigable;
    showDateLabels;
    animationDuration;
    eventWidth;
    dateFormat;
    headerTemplate;
    bodyTemplate;
    actionsTemplate;
    cards;
    dateElementRefs;
    innerDateElementRefs;
    subscriptions = new Subscription();
    constructor(renderer) {
        this.renderer = renderer;
    }
    ngAfterViewInit() {
        this.ariaDescribedByAllEvents();
        this.subscriptions.add(this.innerDateElementRefs.changes.subscribe(() => {
            if (this.innerDateElementRefs?.length > 0) {
                this.ariaDescribedByAllEvents();
            }
            else {
                this.removeAriaDescribedBy();
            }
        }));
    }
    expand(index) {
        if (index < 0 || index >= this.cards.length) {
            return;
        }
        this.cards.get(index).expand();
    }
    collapse(index) {
        if (index < 0 || index >= this.cards.length) {
            return;
        }
        this.cards.get(index).collapse();
    }
    ariaDescribedByAllEvents() {
        this.cards?.forEach((card, index) => {
            const innerCard = card.element.nativeElement.querySelector('.k-card');
            const innerDate = this.dateElementRefs.get(index).nativeElement.querySelector('.k-timeline-date');
            if (innerDate) {
                this.assignAriaDescribedBy(innerCard, innerDate);
            }
        });
    }
    removeAriaDescribedBy() {
        this.cards?.forEach(card => {
            const innerCard = card.element.nativeElement.querySelector('.k-card');
            this.renderer.removeAttribute(innerCard, 'aria-describedby');
        });
    }
    assignAriaDescribedBy(cardElement, dateElement) {
        const dateLabelId = `k-${guid()}`;
        this.renderer.setAttribute(dateElement, 'id', dateLabelId);
        this.renderer.setAttribute(cardElement, 'aria-describedby', dateLabelId);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TimelineVerticalComponent, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: TimelineVerticalComponent, isStandalone: true, selector: "kendo-timeline-vertical", inputs: { events: "events", alterMode: "alterMode", collapsibleEvents: "collapsibleEvents", navigable: "navigable", showDateLabels: "showDateLabels", animationDuration: "animationDuration", eventWidth: "eventWidth", dateFormat: "dateFormat", headerTemplate: "headerTemplate", bodyTemplate: "bodyTemplate", actionsTemplate: "actionsTemplate" }, providers: [], viewQueries: [{ propertyName: "cards", predicate: ["card"], descendants: true }, { propertyName: "dateElementRefs", predicate: ["dateWrap"], descendants: true }, { propertyName: "innerDateElementRefs", predicate: ["innerDate"], descendants: true }], exportAs: ["kendoTimelineVertical"], ngImport: i0, template: `
        @if (events && events.length > 0) {
          <ul>
            @for (event of events; track event; let i = $index) {
              @if (event.flag) {
                <li class="k-timeline-flag-wrap">
                  <span class="k-timeline-flag">{{ event.flag }}</span>
                </li>
              }
              <li class="k-timeline-event" [ngClass]="{ 'k-reverse': alterMode && i % 2 === 0 }">
                <div class="k-timeline-date-wrap" #dateWrap>
                  @if (showDateLabels) {
                    <span class="k-timeline-date" #innerDate>
                      {{ event.date | kendoDate: dateFormat }}
                    </span>
                  }
                </div>
                <span class="k-timeline-circle"></span>
                <kendo-timeline-card
                  #card
                  [event]="event"
                  [expanded]="event.expanded || !collapsibleEvents"
                  [collapsible]="collapsibleEvents"
                  [reversed]="alterMode && i % 2 === 0"
                  [tabIndex]="'0'"
                  [navigable]="navigable"
                  [animationDuration]="animationDuration"
                  [headerTemplate]="headerTemplate"
                  [bodyTemplate]="bodyTemplate"
                  [actionsTemplate]="actionsTemplate"
                  [index]="i"
                  [eventWidth]="eventWidth"
                  orientation="vertical"
                  >
                </kendo-timeline-card>
              </li>
            }
          </ul>
        }
        `, isInline: true, dependencies: [{ kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "component", type: TimelineCardComponent, selector: "kendo-timeline-card", inputs: ["event", "expanded", "collapsible", "reversed", "orientation", "navigable", "tabIndex", "animationDuration", "index", "eventWidth", "eventHeight", "headerTemplate", "bodyTemplate", "actionsTemplate", "calloutStyle"], exportAs: ["kendoTimelineCard"] }, { kind: "pipe", type: DatePipe, name: "kendoDate" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TimelineVerticalComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [],
                    exportAs: 'kendoTimelineVertical',
                    selector: 'kendo-timeline-vertical',
                    template: `
        @if (events && events.length > 0) {
          <ul>
            @for (event of events; track event; let i = $index) {
              @if (event.flag) {
                <li class="k-timeline-flag-wrap">
                  <span class="k-timeline-flag">{{ event.flag }}</span>
                </li>
              }
              <li class="k-timeline-event" [ngClass]="{ 'k-reverse': alterMode && i % 2 === 0 }">
                <div class="k-timeline-date-wrap" #dateWrap>
                  @if (showDateLabels) {
                    <span class="k-timeline-date" #innerDate>
                      {{ event.date | kendoDate: dateFormat }}
                    </span>
                  }
                </div>
                <span class="k-timeline-circle"></span>
                <kendo-timeline-card
                  #card
                  [event]="event"
                  [expanded]="event.expanded || !collapsibleEvents"
                  [collapsible]="collapsibleEvents"
                  [reversed]="alterMode && i % 2 === 0"
                  [tabIndex]="'0'"
                  [navigable]="navigable"
                  [animationDuration]="animationDuration"
                  [headerTemplate]="headerTemplate"
                  [bodyTemplate]="bodyTemplate"
                  [actionsTemplate]="actionsTemplate"
                  [index]="i"
                  [eventWidth]="eventWidth"
                  orientation="vertical"
                  >
                </kendo-timeline-card>
              </li>
            }
          </ul>
        }
        `,
                    standalone: true,
                    imports: [NgClass, TimelineCardComponent, DatePipe]
                }]
        }], ctorParameters: () => [{ type: i0.Renderer2 }], propDecorators: { events: [{
                type: Input
            }], alterMode: [{
                type: Input
            }], collapsibleEvents: [{
                type: Input
            }], navigable: [{
                type: Input
            }], showDateLabels: [{
                type: Input
            }], animationDuration: [{
                type: Input
            }], eventWidth: [{
                type: Input
            }], dateFormat: [{
                type: Input
            }], headerTemplate: [{
                type: Input
            }], bodyTemplate: [{
                type: Input
            }], actionsTemplate: [{
                type: Input
            }], cards: [{
                type: ViewChildren,
                args: ['card']
            }], dateElementRefs: [{
                type: ViewChildren,
                args: ['dateWrap']
            }], innerDateElementRefs: [{
                type: ViewChildren,
                args: ['innerDate']
            }] } });

/**
 * @hidden
 */
class LocalizedTimelineMessagesDirective extends TimelineMessages {
    service;
    constructor(service) {
        super();
        this.service = service;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: LocalizedTimelineMessagesDirective, deps: [{ token: i1.LocalizationService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: LocalizedTimelineMessagesDirective, isStandalone: true, selector: "[kendoTimelineLocalizedMessages]", providers: [
            {
                provide: TimelineMessages,
                useExisting: forwardRef(() => LocalizedTimelineMessagesDirective),
            },
        ], usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: LocalizedTimelineMessagesDirective, decorators: [{
            type: Directive,
            args: [{
                    providers: [
                        {
                            provide: TimelineMessages,
                            useExisting: forwardRef(() => LocalizedTimelineMessagesDirective),
                        },
                    ],
                    selector: `[kendoTimelineLocalizedMessages]`,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1.LocalizationService }] });

const DEFAULT_HORIZONTAL_ANIMATION_DURATION = 400;
const DEFAULT_VERTICAL_ANIMATION_DURATION = 300;
const DEFAULT_EVENT_WIDTH = 400;
const DEFAULT_EVENT_HEIGHT = 600;
const DEFAULT_DATE_FORMAT = 'MMMM dd, yyyy';
/**
 * Represents the [Kendo UI Timeline component for Angular]({% slug overview_timeline %}).
 *
 * @remarks
 * Supported children components are: {@link TimelineCustomMessagesComponent}.
 */
class TimelineComponent {
    timelineService;
    /**
     * An array of event instances which will be shown by the Timeline.
     */
    set events(events) {
        if (!isPresent$1(events)) {
            return;
        }
        this.originalData = events;
        this._events = processItems(this.originalData, this.modelFields);
        this.updateEvents();
    }
    get events() {
        return this._events;
    }
    /**
     * The names of the model fields from which the Timeline will read its data.
     */
    set modelFields(value) {
        this._modelFields = { ...defaultModelFields, ...value };
        if (this.originalData) {
            this.events = this.originalData;
        }
    }
    get modelFields() {
        return this._modelFields;
    }
    /**
     * Specifies the orientation of the axis.
     *
     * @default 'vertical'
     */
    orientation = 'vertical';
    /**
     * Specifies whether to render events alternatingly on both sides of the axis.
     * Applicable when `orientation` is set to `vertical`.
     *
     * @default false
     */
    alterMode = false;
    /**
     * Specifies whether the event cards can be collapsed.
     *
     * @default true
     */
    collapsibleEvents = true;
    /**
     * Specifies whether the user can use dedicated shortcuts to interact with the Timeline.
     *
     * @default true
     */
    navigable = true;
    /**
     * Specifies whether an event's date label will be visible.
     *
     * @default true
     */
    showDateLabels = true;
    /**
     * Specifies the time for sliding to the next event in `horizontal` mode and the time for collapsing the event in `vertical` mode.
     * The default animation duration values are `300ms` for `horizontal` mode and `400ms` for `vertical` mode.
     *
     * @default true
     */
    animation;
    /**
     * Specifies the order of the Timeline events.
     * `asc` - chronological order
     * `desc` - reverse-chronological order
     *
     * @default 'asc'
     */
    set eventsOrder(order) {
        if (order === this._eventsOrder) {
            return;
        }
        this._eventsOrder = order;
        this.updateEvents();
    }
    get eventsOrder() {
        return this._eventsOrder;
    }
    /**
     * Sets a specific width for the event.
     * This setting is supported only in `vertical` mode.
     *
     * @default 400
     */
    get eventWidth() {
        return this._eventWidth;
    }
    set eventWidth(value) {
        if (value) {
            this._eventWidth = value;
        }
        else {
            this._eventWidth = DEFAULT_EVENT_WIDTH;
        }
    }
    /**
     * Sets a specific height for the event.
     * This setting is supported only in `horizontal` mode.
     *
     * @default 600
     */
    get eventHeight() {
        return this._eventHeight;
    }
    set eventHeight(value) {
        if (value) {
            this._eventHeight = value;
        }
        else {
            this._eventHeight = DEFAULT_EVENT_HEIGHT;
        }
    }
    /**
     * @hidden
     */
    get animationDuration() {
        if (typeof this.animation === 'number') {
            return this.animation;
        }
        if ((typeof this.animation === 'boolean' && this.animation) || !isPresent$1(this.animation)) {
            return this.orientation === 'horizontal' ? DEFAULT_HORIZONTAL_ANIMATION_DURATION : DEFAULT_VERTICAL_ANIMATION_DURATION;
        }
        return 0;
    }
    /**
     * Specifies the date format for displaying the event date.
     *
     * @default 'MMMM dd, yyyy'
     */
    set dateFormat(value) {
        if (isPresent$1(value) && value !== '') {
            this._dateFormat = value;
        }
        else {
            this._dateFormat = DEFAULT_DATE_FORMAT;
        }
    }
    get dateFormat() {
        return this._dateFormat;
    }
    hostClass = true;
    get verticalClass() {
        return this.orientation === 'vertical';
    }
    get horizontalClass() {
        return this.orientation === 'horizontal';
    }
    get alternatingClass() {
        return this.alterMode === true && this.orientation === 'vertical';
    }
    get collapsibleClass() {
        return this.collapsibleEvents === true && this.orientation === 'vertical';
    }
    /**
     * @hidden
     */
    timelineHorizontal;
    /**
     * @hidden
     */
    timelineVertical;
    /**
     * @hidden
     */
    cardHeaderTemplate;
    /**
     * @hidden
     */
    cardBodyTemplate;
    /**
     * @hidden
     */
    cardActionsTemplate;
    /**
     * Fires when a card is toggled.
     * This event is supported only in `vertical` mode.
     */
    onToggle = new EventEmitter();
    /**
     * Fires when a card's action is clicked.
     */
    onActionClick = new EventEmitter();
    /**
     * Fires when the left or right arrow is clicked.
     * This event is supported only in `horizontal` mode.
     */
    onNavigate = new EventEmitter();
    /**
     * @hidden
     */
    headerTemplate;
    /**
     * @hidden
     */
    bodyTemplate;
    /**
     * @hidden
     */
    actionsTemplate;
    _events = [];
    _modelFields = defaultModelFields;
    _eventWidth = DEFAULT_EVENT_WIDTH;
    _eventHeight = DEFAULT_EVENT_HEIGHT;
    _dateFormat = DEFAULT_DATE_FORMAT;
    originalData = [];
    _eventsOrder = 'asc';
    subscriptions = new Subscription();
    constructor(timelineService) {
        this.timelineService = timelineService;
        this.timelineService.timeline = this;
    }
    ngAfterContentInit() {
        this.initTemplates();
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    /**
     * Switches to the previous portion of events.
     * This method is supported only in `horizontal` mode.
     */
    previous() {
        this.timelineHorizontal?.previous();
    }
    /**
     * Switches to the next portion of events.
     * This method is supported only in `horizontal` mode.
     */
    next() {
        this.timelineHorizontal?.next();
    }
    /**
     * Open event details.
     * This method is supported only in `horizontal` mode.
     */
    open(index) {
        this.timelineHorizontal?.open(index);
    }
    /**
     * Expands an event.
     * This method is supported only in `vertical` mode.
     */
    expand(index) {
        this.timelineVertical?.expand(index);
    }
    /**
     * Collapses an event.
     * This method is supported only in `vertical` mode.
     */
    collapse(index) {
        this.timelineVertical?.collapse(index);
    }
    updateEvents() {
        const sortOrder = this._eventsOrder === 'asc' ? 1 : -1;
        this._events = [...this._events].sort((a, b) => {
            return sortOrder * (a.date.getTime() - b.date.getTime());
        });
        if (this._events.length > 0) {
            let flag = this._events[0].date.getFullYear() - sortOrder;
            this._events.forEach((event) => {
                if (event.date.getFullYear() === flag) {
                    event.flag = null;
                }
                else {
                    flag = event.date.getFullYear();
                    event.flag = flag;
                }
            });
        }
    }
    initTemplates() {
        this.headerTemplate = this.cardHeaderTemplate?.first;
        this.bodyTemplate = this.cardBodyTemplate?.first;
        this.actionsTemplate = this.cardActionsTemplate?.first;
        this.subscriptions.add(this.cardHeaderTemplate?.changes.subscribe(() => {
            this.headerTemplate = this.cardHeaderTemplate?.first || null;
        }));
        this.subscriptions.add(this.cardBodyTemplate?.changes.subscribe(() => {
            this.bodyTemplate = this.cardBodyTemplate?.first || null;
        }));
        this.subscriptions.add(this.cardActionsTemplate?.changes.subscribe(() => {
            this.actionsTemplate = this.cardActionsTemplate?.first || null;
        }));
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TimelineComponent, deps: [{ token: TimelineService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: TimelineComponent, isStandalone: true, selector: "kendo-timeline", inputs: { events: "events", modelFields: "modelFields", orientation: "orientation", alterMode: "alterMode", collapsibleEvents: "collapsibleEvents", navigable: "navigable", showDateLabels: "showDateLabels", animation: "animation", eventsOrder: "eventsOrder", eventWidth: "eventWidth", eventHeight: "eventHeight", dateFormat: "dateFormat" }, outputs: { onToggle: "onToggle", onActionClick: "onActionClick", onNavigate: "onNavigate" }, host: { properties: { "class.k-timeline": "this.hostClass", "class.k-timeline-vertical": "this.verticalClass", "class.k-timeline-horizontal": "this.horizontalClass", "class.k-timeline-alternating": "this.alternatingClass", "class.k-timeline-collapsible": "this.collapsibleClass" } }, providers: [
            TimelineService,
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.timeline'
            }
        ], queries: [{ propertyName: "cardHeaderTemplate", predicate: TimelineCardHeaderTemplateDirective }, { propertyName: "cardBodyTemplate", predicate: TimelineCardBodyTemplateDirective }, { propertyName: "cardActionsTemplate", predicate: TimelineCardActionsTemplateDirective }], viewQueries: [{ propertyName: "timelineHorizontal", first: true, predicate: TimelineHorizontalComponent, descendants: true }, { propertyName: "timelineVertical", first: true, predicate: TimelineVerticalComponent, descendants: true }], exportAs: ["kendoTimeline"], ngImport: i0, template: `
        <ng-container kendoTimelineLocalizedMessages
          i18n-previous="kendo.timeline.previous|The title of the previous button in horizontal orientation."
          previous="previous"
          >
        </ng-container>
        <ng-container kendoTimelineLocalizedMessages
          i18n-next="kendo.timeline.next|The title of the next button in horizontal orientation."
          next="next"
          >
        </ng-container>
        @if (orientation === 'vertical') {
          <kendo-timeline-vertical
            [events]="events"
            [alterMode]="alterMode"
            [collapsibleEvents]="collapsibleEvents"
            [navigable]="navigable"
            [showDateLabels]="showDateLabels"
            [animationDuration]="animationDuration"
            [eventWidth]="eventWidth"
            [dateFormat]="dateFormat"
            [headerTemplate]="headerTemplate"
            [bodyTemplate]="bodyTemplate"
            [actionsTemplate]="actionsTemplate"
            >
          </kendo-timeline-vertical>
        }
        @if (orientation === 'horizontal') {
          <kendo-timeline-horizontal
            [events]="events"
            [collapsibleEvents]="false"
            [navigable]="navigable"
            [showDateLabels]="showDateLabels"
            [animationDuration]="animationDuration"
            [eventHeight]="eventHeight"
            [dateFormat]="dateFormat"
            [headerTemplate]="headerTemplate"
            [bodyTemplate]="bodyTemplate"
            [actionsTemplate]="actionsTemplate"
            >
          </kendo-timeline-horizontal>
        }
        `, isInline: true, dependencies: [{ kind: "directive", type: LocalizedTimelineMessagesDirective, selector: "[kendoTimelineLocalizedMessages]" }, { kind: "component", type: TimelineVerticalComponent, selector: "kendo-timeline-vertical", inputs: ["events", "alterMode", "collapsibleEvents", "navigable", "showDateLabels", "animationDuration", "eventWidth", "dateFormat", "headerTemplate", "bodyTemplate", "actionsTemplate"], exportAs: ["kendoTimelineVertical"] }, { kind: "component", type: TimelineHorizontalComponent, selector: "kendo-timeline-horizontal", inputs: ["events", "alterMode", "collapsibleEvents", "navigable", "showDateLabels", "animationDuration", "eventHeight", "dateFormat", "headerTemplate", "bodyTemplate", "actionsTemplate"], exportAs: ["kendoTimelineHorizontal"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TimelineComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        TimelineService,
                        LocalizationService,
                        {
                            provide: L10N_PREFIX,
                            useValue: 'kendo.timeline'
                        }
                    ],
                    exportAs: 'kendoTimeline',
                    selector: 'kendo-timeline',
                    template: `
        <ng-container kendoTimelineLocalizedMessages
          i18n-previous="kendo.timeline.previous|The title of the previous button in horizontal orientation."
          previous="previous"
          >
        </ng-container>
        <ng-container kendoTimelineLocalizedMessages
          i18n-next="kendo.timeline.next|The title of the next button in horizontal orientation."
          next="next"
          >
        </ng-container>
        @if (orientation === 'vertical') {
          <kendo-timeline-vertical
            [events]="events"
            [alterMode]="alterMode"
            [collapsibleEvents]="collapsibleEvents"
            [navigable]="navigable"
            [showDateLabels]="showDateLabels"
            [animationDuration]="animationDuration"
            [eventWidth]="eventWidth"
            [dateFormat]="dateFormat"
            [headerTemplate]="headerTemplate"
            [bodyTemplate]="bodyTemplate"
            [actionsTemplate]="actionsTemplate"
            >
          </kendo-timeline-vertical>
        }
        @if (orientation === 'horizontal') {
          <kendo-timeline-horizontal
            [events]="events"
            [collapsibleEvents]="false"
            [navigable]="navigable"
            [showDateLabels]="showDateLabels"
            [animationDuration]="animationDuration"
            [eventHeight]="eventHeight"
            [dateFormat]="dateFormat"
            [headerTemplate]="headerTemplate"
            [bodyTemplate]="bodyTemplate"
            [actionsTemplate]="actionsTemplate"
            >
          </kendo-timeline-horizontal>
        }
        `,
                    standalone: true,
                    imports: [LocalizedTimelineMessagesDirective, TimelineVerticalComponent, TimelineHorizontalComponent]
                }]
        }], ctorParameters: () => [{ type: TimelineService }], propDecorators: { events: [{
                type: Input
            }], modelFields: [{
                type: Input
            }], orientation: [{
                type: Input
            }], alterMode: [{
                type: Input
            }], collapsibleEvents: [{
                type: Input
            }], navigable: [{
                type: Input
            }], showDateLabels: [{
                type: Input
            }], animation: [{
                type: Input
            }], eventsOrder: [{
                type: Input
            }], eventWidth: [{
                type: Input
            }], eventHeight: [{
                type: Input
            }], dateFormat: [{
                type: Input
            }], hostClass: [{
                type: HostBinding,
                args: ['class.k-timeline']
            }], verticalClass: [{
                type: HostBinding,
                args: ['class.k-timeline-vertical']
            }], horizontalClass: [{
                type: HostBinding,
                args: ['class.k-timeline-horizontal']
            }], alternatingClass: [{
                type: HostBinding,
                args: ['class.k-timeline-alternating']
            }], collapsibleClass: [{
                type: HostBinding,
                args: ['class.k-timeline-collapsible']
            }], timelineHorizontal: [{
                type: ViewChild,
                args: [TimelineHorizontalComponent]
            }], timelineVertical: [{
                type: ViewChild,
                args: [TimelineVerticalComponent]
            }], cardHeaderTemplate: [{
                type: ContentChildren,
                args: [TimelineCardHeaderTemplateDirective, { descendants: false }]
            }], cardBodyTemplate: [{
                type: ContentChildren,
                args: [TimelineCardBodyTemplateDirective, { descendants: false }]
            }], cardActionsTemplate: [{
                type: ContentChildren,
                args: [TimelineCardActionsTemplateDirective, { descendants: false }]
            }], onToggle: [{
                type: Output
            }], onActionClick: [{
                type: Output
            }], onNavigate: [{
                type: Output
            }] } });

/**
 * Use the `KENDO_AVATAR` utility array to add all Avatar-related components and directives to a standalone Angular component.
 */
const KENDO_AVATAR = [
    AvatarComponent,
    AvatarCustomMessagesComponent
];
/**
 * Use the `KENDO_CARD` utility array to add all Card-related components and directives to a standalone Angular component.
 */
const KENDO_CARD = [
    CardComponent,
    CardActionsComponent,
    CardBodyComponent,
    CardFooterComponent,
    CardHeaderComponent,
    CardMediaDirective,
    CardSeparatorDirective,
    CardSubtitleDirective,
    CardTitleDirective
];
/**
 * Use the `KENDO_DRAWER` utility array to add all Drawer-related components and directives to a standalone Angular component.
 */
const KENDO_DRAWER = [
    DrawerComponent,
    DrawerContainerComponent,
    DrawerContentComponent,
    DrawerTemplateDirective,
    DrawerFooterTemplateDirective,
    DrawerHeaderTemplateDirective,
    DrawerItemTemplateDirective
];
/**
 * Use the `KENDO_EXPANSIONPANEL` utility array to add all ExpansionPanel-related components and directives to a standalone Angular component.
 */
const KENDO_EXPANSIONPANEL = [
    ExpansionPanelComponent,
    ExpansionPanelTitleDirective
];
/**
 * Use the `KENDO_GRIDLAYOUT` utility array to add all GridLayout-related components and directives to a standalone Angular component.
 */
const KENDO_GRIDLAYOUT = [
    GridLayoutComponent,
    GridLayoutItemComponent
];
/**
 * Use the `KENDO_PANELBAR` utility array to add all PanelBar-related components and directives to a standalone Angular component.
 */
const KENDO_PANELBAR = [
    PanelBarComponent,
    PanelBarItemComponent,
    PanelBarContentDirective,
    PanelBarItemTemplateDirective,
    PanelBarItemTitleDirective
];
/**
 * Use the `KENDO_SPLITTER` utility array to add all Splitter-related components and directives to a standalone Angular component.
 */
const KENDO_SPLITTER = [
    SplitterComponent,
    SplitterPaneComponent
];
/**
 * Use the `KENDO_STACKLAYOUT` utility array to add all StackLayout-related components and directives to a standalone Angular component.
 */
const KENDO_STACKLAYOUT = [
    StackLayoutComponent
];
/**
 * Use the `KENDO_STEPPER` utility array to add all Stepper-related components and directives to a standalone Angular component.
 */
const KENDO_STEPPER = [
    StepperComponent,
    StepperCustomMessagesComponent,
    StepperIndicatorTemplateDirective,
    StepperLabelTemplateDirective,
    StepperStepTemplateDirective
];
/**
 * Use the `KENDO_TABSTRIP` utility array to add all TabStrip-related components and directives to a standalone Angular component.
 */
const KENDO_TABSTRIP = [
    TabStripComponent,
    TabStripTabComponent,
    TabContentDirective,
    TabTitleDirective,
    TabStripCustomMessagesComponent
];
/**
 * Use the `KENDO_TILELAYOUT` utility array to add all TileLayout-related components and directives to a standalone Angular component.
 */
const KENDO_TILELAYOUT = [
    TileLayoutComponent,
    TileLayoutItemBodyComponent,
    TileLayoutItemComponent,
    TileLayoutItemHeaderComponent
];
/**
 * Use the `KENDO_TIMELINE` utility array to add all Timeline-related components and directives to a standalone Angular component.
 */
const KENDO_TIMELINE = [
    TimelineComponent,
    TimelineCustomMessagesComponent,
    TimelineCardActionsTemplateDirective,
    TimelineCardBodyTemplateDirective,
    TimelineCardHeaderTemplateDirective
];
/**
 * Use the `KENDO_LAYOUT` utility array to add all `@progress/kendo-angular-layout`-related components and directives to a standalone Angular component.
 */
const KENDO_LAYOUT = [
    ...KENDO_AVATAR,
    ...KENDO_CARD,
    ...KENDO_DRAWER,
    ...KENDO_EXPANSIONPANEL,
    ...KENDO_GRIDLAYOUT,
    ...KENDO_PANELBAR,
    ...KENDO_SPLITTER,
    ...KENDO_STACKLAYOUT,
    ...KENDO_STEPPER,
    ...KENDO_TABSTRIP,
    ...KENDO_TILELAYOUT,
    ...KENDO_TIMELINE
];

// IMPORTANT: NgModule export kept for backwards compatibility
/**
 * Defines the [`NgModule`](link:site.data.urls.angular['ngmoduleapi']) for the Avatar component.
 *
 * Use this module to add the Avatar component to your NgModule-based Angular application.
 *
 * @example
 * ```typescript
 * import { AvatarModule } from '@progress/kendo-angular-layout';
 * import { NgModule } from '@angular/core';
 *
 * @NgModule({
 *   imports: [AvatarModule]
 * })
 * export class AppModule { }
 * ```
 */
class AvatarModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AvatarModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.18", ngImport: i0, type: AvatarModule, imports: [AvatarComponent, AvatarCustomMessagesComponent], exports: [AvatarComponent, AvatarCustomMessagesComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AvatarModule, imports: [AvatarComponent] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: AvatarModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [...KENDO_AVATAR],
                    imports: [...KENDO_AVATAR]
                }]
        }] });

// IMPORTANT: NgModule export kept for backwards compatibility
/**
 * Defines the [`NgModule`](link:site.data.urls.angular['ngmoduleapi']) for the Card component.
 *
 * Use this module to add the Card component to your NgModule-based Angular application.
 *
 * @example
 * ```typescript
 * import { CardModule } from '@progress/kendo-angular-layout';
 * import { NgModule } from '@angular/core';
 *
 * @NgModule({
 *   imports: [CardModule]
 * })
 * export class AppModule { }
 * ```
 */
class CardModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CardModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.18", ngImport: i0, type: CardModule, imports: [CardComponent, CardActionsComponent, CardBodyComponent, CardFooterComponent, CardHeaderComponent, CardMediaDirective, CardSeparatorDirective, CardSubtitleDirective, CardTitleDirective], exports: [CardComponent, CardActionsComponent, CardBodyComponent, CardFooterComponent, CardHeaderComponent, CardMediaDirective, CardSeparatorDirective, CardSubtitleDirective, CardTitleDirective] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CardModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CardModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [...KENDO_CARD],
                    imports: [...KENDO_CARD]
                }]
        }] });

// IMPORTANT: NgModule export kept for backwards compatibility
/**
 * Defines the [`NgModule`](link:site.data.urls.angular['ngmoduleapi']) for the Drawer component.
 *
 * Use this module to add the Drawer component to your NgModule-based Angular application.
 *
 * @example
 * ```typescript
 * import { DrawerModule } from '@progress/kendo-angular-layout';
 * import { NgModule } from '@angular/core';
 *
 * @NgModule({
 *   imports: [DrawerModule]
 * })
 * export class AppModule { }
 * ```
 */
class DrawerModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DrawerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.18", ngImport: i0, type: DrawerModule, imports: [DrawerComponent, DrawerContainerComponent, DrawerContentComponent, DrawerTemplateDirective, DrawerFooterTemplateDirective, DrawerHeaderTemplateDirective, DrawerItemTemplateDirective], exports: [DrawerComponent, DrawerContainerComponent, DrawerContentComponent, DrawerTemplateDirective, DrawerFooterTemplateDirective, DrawerHeaderTemplateDirective, DrawerItemTemplateDirective] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DrawerModule, imports: [DrawerComponent] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DrawerModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [...KENDO_DRAWER],
                    imports: [...KENDO_DRAWER]
                }]
        }] });

// IMPORTANT: NgModule export kept for backwards compatibility
/**
 * Defines the [`NgModule`](link:site.data.urls.angular['ngmoduleapi']) for the Layout components.
 *
 * Use this module to add all Layout package components to your NgModule-based Angular application.
 *
 * @example
 * ```typescript
 * import { LayoutModule } from '@progress/kendo-angular-layout';
 * import { NgModule } from '@angular/core';
 * import { BrowserModule } from '@angular/platform-browser';
 * import { AppComponent } from './app.component';
 *
 * @NgModule({
 *   declarations: [AppComponent],
 *   imports: [BrowserModule, LayoutModule],
 *   bootstrap: [AppComponent]
 * })
 * export class AppModule { }
 * ```
 */
class LayoutModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: LayoutModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.18", ngImport: i0, type: LayoutModule, imports: [AvatarComponent, AvatarCustomMessagesComponent, CardComponent, CardActionsComponent, CardBodyComponent, CardFooterComponent, CardHeaderComponent, CardMediaDirective, CardSeparatorDirective, CardSubtitleDirective, CardTitleDirective, DrawerComponent, DrawerContainerComponent, DrawerContentComponent, DrawerTemplateDirective, DrawerFooterTemplateDirective, DrawerHeaderTemplateDirective, DrawerItemTemplateDirective, ExpansionPanelComponent, ExpansionPanelTitleDirective, GridLayoutComponent, GridLayoutItemComponent, PanelBarComponent, PanelBarItemComponent, PanelBarContentDirective, PanelBarItemTemplateDirective, PanelBarItemTitleDirective, SplitterComponent, SplitterPaneComponent, StackLayoutComponent, StepperComponent, StepperCustomMessagesComponent, StepperIndicatorTemplateDirective, StepperLabelTemplateDirective, StepperStepTemplateDirective, TabStripComponent, TabStripTabComponent, TabContentDirective, TabTitleDirective, TabStripCustomMessagesComponent, TileLayoutComponent, TileLayoutItemBodyComponent, TileLayoutItemComponent, TileLayoutItemHeaderComponent, TimelineComponent, TimelineCustomMessagesComponent, TimelineCardActionsTemplateDirective, TimelineCardBodyTemplateDirective, TimelineCardHeaderTemplateDirective], exports: [AvatarComponent, AvatarCustomMessagesComponent, CardComponent, CardActionsComponent, CardBodyComponent, CardFooterComponent, CardHeaderComponent, CardMediaDirective, CardSeparatorDirective, CardSubtitleDirective, CardTitleDirective, DrawerComponent, DrawerContainerComponent, DrawerContentComponent, DrawerTemplateDirective, DrawerFooterTemplateDirective, DrawerHeaderTemplateDirective, DrawerItemTemplateDirective, ExpansionPanelComponent, ExpansionPanelTitleDirective, GridLayoutComponent, GridLayoutItemComponent, PanelBarComponent, PanelBarItemComponent, PanelBarContentDirective, PanelBarItemTemplateDirective, PanelBarItemTitleDirective, SplitterComponent, SplitterPaneComponent, StackLayoutComponent, StepperComponent, StepperCustomMessagesComponent, StepperIndicatorTemplateDirective, StepperLabelTemplateDirective, StepperStepTemplateDirective, TabStripComponent, TabStripTabComponent, TabContentDirective, TabTitleDirective, TabStripCustomMessagesComponent, TileLayoutComponent, TileLayoutItemBodyComponent, TileLayoutItemComponent, TileLayoutItemHeaderComponent, TimelineComponent, TimelineCustomMessagesComponent, TimelineCardActionsTemplateDirective, TimelineCardBodyTemplateDirective, TimelineCardHeaderTemplateDirective] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: LayoutModule, imports: [AvatarComponent, DrawerComponent, ExpansionPanelComponent, PanelBarComponent, PanelBarItemComponent, SplitterComponent, StepperComponent, TabStripComponent, TileLayoutComponent, TimelineComponent] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: LayoutModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [...KENDO_LAYOUT],
                    imports: [...KENDO_LAYOUT]
                }]
        }] });

// IMPORTANT: NgModule export kept for backwards compatibility
/**
 * Defines the [`NgModule`](link:site.data.urls.angular['ngmoduleapi']) for the PanelBar component.
 *
 * Use this module to add the PanelBar component to your NgModule-based Angular application.
 *
 * @example
 * ```typescript
 * import { PanelBarModule } from '@progress/kendo-angular-layout';
 * import { NgModule } from '@angular/core';
 *
 * @NgModule({
 *   imports: [PanelBarModule]
 * })
 * export class AppModule { }
 * ```
 */
class PanelBarModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PanelBarModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.18", ngImport: i0, type: PanelBarModule, imports: [PanelBarComponent, PanelBarItemComponent, PanelBarContentDirective, PanelBarItemTemplateDirective, PanelBarItemTitleDirective], exports: [PanelBarComponent, PanelBarItemComponent, PanelBarContentDirective, PanelBarItemTemplateDirective, PanelBarItemTitleDirective] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PanelBarModule, imports: [PanelBarComponent, PanelBarItemComponent] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PanelBarModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [...KENDO_PANELBAR],
                    imports: [...KENDO_PANELBAR]
                }]
        }] });

// IMPORTANT: NgModule export kept for backwards compatibility
/**
 * Defines the [`NgModule`](link:site.data.urls.angular['ngmoduleapi']) for the Splitter component.
 *
 * Use this module to add the Splitter component to your NgModule-based Angular application.
 *
 * @example
 * ```typescript
 * import { SplitterModule } from '@progress/kendo-angular-layout';
 * import { NgModule } from '@angular/core';
 *
 * @NgModule({
 *   imports: [SplitterModule]
 * })
 * export class AppModule { }
 * ```
 */
class SplitterModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SplitterModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.18", ngImport: i0, type: SplitterModule, imports: [SplitterComponent, SplitterPaneComponent], exports: [SplitterComponent, SplitterPaneComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SplitterModule, imports: [SplitterComponent] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: SplitterModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [...KENDO_SPLITTER],
                    imports: [...KENDO_SPLITTER]
                }]
        }] });

// IMPORTANT: NgModule export kept for backwards compatibility
/**
 * Defines the [`NgModule`](link:site.data.urls.angular['ngmoduleapi']) for the Stepper component.
 *
 * Use this module to add the Stepper component to your NgModule-based Angular application.
 *
 * @example
 * ```typescript
 * import { StepperModule } from '@progress/kendo-angular-layout';
 * import { NgModule } from '@angular/core';
 *
 * @NgModule({
 *   imports: [StepperModule]
 * })
 * export class AppModule { }
 * ```
 */
class StepperModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: StepperModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.18", ngImport: i0, type: StepperModule, imports: [StepperComponent, StepperCustomMessagesComponent, StepperIndicatorTemplateDirective, StepperLabelTemplateDirective, StepperStepTemplateDirective], exports: [StepperComponent, StepperCustomMessagesComponent, StepperIndicatorTemplateDirective, StepperLabelTemplateDirective, StepperStepTemplateDirective] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: StepperModule, imports: [StepperComponent] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: StepperModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [...KENDO_STEPPER],
                    imports: [...KENDO_STEPPER]
                }]
        }] });

// IMPORTANT: NgModule export kept for backwards compatibility
/**
 * Defines the [`NgModule`](link:site.data.urls.angular['ngmoduleapi']) for the TabStrip component.
 *
 * Use this module to add the TabStrip component to your NgModule-based Angular application.
 *
 * @example
 * ```typescript
 * import { TabStripModule } from '@progress/kendo-angular-layout';
 * import { NgModule } from '@angular/core';
 *
 * @NgModule({
 *   imports: [TabStripModule]
 * })
 * export class AppModule { }
 * ```
 */
class TabStripModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TabStripModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.18", ngImport: i0, type: TabStripModule, imports: [TabStripComponent, TabStripTabComponent, TabContentDirective, TabTitleDirective, TabStripCustomMessagesComponent], exports: [TabStripComponent, TabStripTabComponent, TabContentDirective, TabTitleDirective, TabStripCustomMessagesComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TabStripModule, imports: [TabStripComponent] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TabStripModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [...KENDO_TABSTRIP],
                    imports: [...KENDO_TABSTRIP]
                }]
        }] });

// IMPORTANT: NgModule export kept for backwards compatibility
/**
 * Defines the [`NgModule`](link:site.data.urls.angular['ngmoduleapi']) for the ExpansionPanel component.
 *
 * Use this module to add the ExpansionPanel component to your NgModule-based Angular application.
 *
 * @example
 * ```typescript
 * import { ExpansionPanelModule } from '@progress/kendo-angular-layout';
 * import { NgModule } from '@angular/core';
 *
 * @NgModule({
 *   imports: [ExpansionPanelModule]
 * })
 * export class AppModule { }
 * ```
 */
class ExpansionPanelModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ExpansionPanelModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.18", ngImport: i0, type: ExpansionPanelModule, imports: [ExpansionPanelComponent, ExpansionPanelTitleDirective], exports: [ExpansionPanelComponent, ExpansionPanelTitleDirective] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ExpansionPanelModule, imports: [ExpansionPanelComponent] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ExpansionPanelModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [...KENDO_EXPANSIONPANEL],
                    imports: [...KENDO_EXPANSIONPANEL]
                }]
        }] });

// IMPORTANT: NgModule export kept for backwards compatibility
/**
 * Defines the [`NgModule`](link:site.data.urls.angular['ngmoduleapi']) for the TileLayout component.
 *
 * Use this module to add the TileLayout component to your NgModule-based Angular application.
 *
 * @example
 * ```typescript
 * import { TileLayoutModule } from '@progress/kendo-angular-layout';
 * import { NgModule } from '@angular/core';
 *
 * @NgModule({
 *   imports: [TileLayoutModule]
 * })
 * export class AppModule { }
 * ```
 */
class TileLayoutModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TileLayoutModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.18", ngImport: i0, type: TileLayoutModule, imports: [TileLayoutComponent, TileLayoutItemBodyComponent, TileLayoutItemComponent, TileLayoutItemHeaderComponent], exports: [TileLayoutComponent, TileLayoutItemBodyComponent, TileLayoutItemComponent, TileLayoutItemHeaderComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TileLayoutModule, imports: [TileLayoutComponent] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TileLayoutModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [...KENDO_TILELAYOUT],
                    imports: [...KENDO_TILELAYOUT]
                }]
        }] });

// IMPORTANT: NgModule export kept for backwards compatibility
/**
 * Defines the [`NgModule`](link:site.data.urls.angular['ngmoduleapi']) for the StackLayout component.
 *
 * Use this module to add the StackLayout component to your NgModule-based Angular application.
 *
 * @example
 * ```typescript
 * import { StackLayoutModule } from '@progress/kendo-angular-layout';
 * import { NgModule } from '@angular/core';
 *
 * @NgModule({
 *   imports: [StackLayoutModule]
 * })
 * export class AppModule { }
 * ```
 */
class StackLayoutModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: StackLayoutModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.18", ngImport: i0, type: StackLayoutModule, imports: [StackLayoutComponent], exports: [StackLayoutComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: StackLayoutModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: StackLayoutModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [...KENDO_STACKLAYOUT],
                    imports: [...KENDO_STACKLAYOUT]
                }]
        }] });

// IMPORTANT: NgModule export kept for backwards compatibility
/**
 * Defines the [`NgModule`](link:site.data.urls.angular['ngmoduleapi']) for the GridLayout component.
 *
 * Use this module to add the GridLayout component to your NgModule-based Angular application.
 *
 * @example
 * ```typescript
 * import { GridLayoutModule } from '@progress/kendo-angular-layout';
 * import { NgModule } from '@angular/core';
 *
 * @NgModule({
 *   imports: [GridLayoutModule]
 * })
 * export class AppModule { }
 * ```
 */
class GridLayoutModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GridLayoutModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.18", ngImport: i0, type: GridLayoutModule, imports: [GridLayoutComponent, GridLayoutItemComponent], exports: [GridLayoutComponent, GridLayoutItemComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GridLayoutModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: GridLayoutModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [...KENDO_GRIDLAYOUT],
                    imports: [...KENDO_GRIDLAYOUT]
                }]
        }] });

// IMPORTANT: NgModule export kept for backwards compatibility
/**
 * Defines the [`NgModule`](link:site.data.urls.angular['ngmoduleapi']) for the Timeline component.
 *
 * Use this module to add the Timeline component to your NgModule-based Angular application.
 *
 * @example
 * ```typescript
 * import { TimelineModule } from '@progress/kendo-angular-layout';
 * import { NgModule } from '@angular/core';
 *
 * @NgModule({
 *   imports: [TimelineModule]
 * })
 * export class AppModule { }
 * ```
 */
class TimelineModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TimelineModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.18", ngImport: i0, type: TimelineModule, imports: [TimelineComponent, TimelineCustomMessagesComponent, TimelineCardActionsTemplateDirective, TimelineCardBodyTemplateDirective, TimelineCardHeaderTemplateDirective], exports: [TimelineComponent, TimelineCustomMessagesComponent, TimelineCardActionsTemplateDirective, TimelineCardBodyTemplateDirective, TimelineCardHeaderTemplateDirective] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TimelineModule, imports: [TimelineComponent] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: TimelineModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [...KENDO_TIMELINE],
                    imports: [...KENDO_TIMELINE]
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { AvatarComponent, AvatarCustomMessagesComponent, AvatarModule, CardAction, CardActionsComponent, CardBodyComponent, CardComponent, CardFooterComponent, CardHeaderComponent, CardMediaDirective, CardModule, CardSeparatorDirective, CardSubtitleDirective, CardTitleDirective, DrawerComponent, DrawerContainerComponent, DrawerContentComponent, DrawerFooterTemplateDirective, DrawerHeaderTemplateDirective, DrawerItemTemplateDirective, DrawerModule, DrawerSelectEvent, DrawerTemplateDirective, ExpansionPanelActionEvent, ExpansionPanelComponent, ExpansionPanelModule, ExpansionPanelTitleDirective, GridLayoutComponent, GridLayoutItemComponent, GridLayoutModule, KENDO_AVATAR, KENDO_CARD, KENDO_DRAWER, KENDO_EXPANSIONPANEL, KENDO_GRIDLAYOUT, KENDO_LAYOUT, KENDO_PANELBAR, KENDO_SPLITTER, KENDO_STACKLAYOUT, KENDO_STEPPER, KENDO_TABSTRIP, KENDO_TILELAYOUT, KENDO_TIMELINE, LayoutModule, LocalizedAvatarMessagesDirective, LocalizedStepperMessagesDirective, LocalizedTabStripMessagesDirective, PanelBarCollapseEvent, PanelBarComponent, PanelBarContentDirective, PanelBarExpandEvent, PanelBarExpandMode, PanelBarItemClickEvent, PanelBarItemComponent, PanelBarItemTemplateDirective, PanelBarItemTitleDirective, PanelBarModule, PanelBarSelectEvent, PanelBarStateChangeEvent, SelectEvent, SplitterComponent, SplitterModule, SplitterPaneComponent, StackLayoutComponent, StackLayoutModule, StepperActivateEvent, StepperComponent, StepperCustomMessagesComponent, StepperIndicatorTemplateDirective, StepperLabelTemplateDirective, StepperModule, StepperStepTemplateDirective, TabCloseEvent, TabComponent, TabContentDirective, TabScrollEvent, TabStripComponent, TabStripCustomMessagesComponent, TabStripModule, TabStripTabComponent, TabTemplateDirective, TabTitleDirective, TileLayoutComponent, TileLayoutItemBodyComponent, TileLayoutItemComponent, TileLayoutItemHeaderComponent, TileLayoutModule, TileLayoutReorderEvent, TileLayoutResizeEvent, TileLayoutResizeHandleDirective, TimelineCardActionsTemplateDirective, TimelineCardBodyTemplateDirective, TimelineCardHeaderTemplateDirective, TimelineComponent, TimelineCustomMessagesComponent, TimelineModule };

