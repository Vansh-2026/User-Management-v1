/**-----------------------------------------------------------------------------------------
* Copyright © 2026 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import * as i0 from '@angular/core';
import { Input, Directive, forwardRef, Component, ChangeDetectionStrategy, HostBinding, ViewChild, Optional, ElementRef, EventEmitter, inject, HostListener, Output, ContentChildren, SkipSelf, NgModule } from '@angular/core';
import * as i1 from '@progress/kendo-angular-l10n';
import { ComponentMessages, LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';
import { Subject, Subscription } from 'rxjs';
import { caretAltLeftIcon, caretAltToLeftIcon, caretAltRightIcon, caretAltToRightIcon } from '@progress/kendo-svg-icons';
import { isVisible, isDocumentAvailable, isFocusable, Keys, EventsOutsideAngularDirective, anyChanged, isChanged, replaceMessagePlaceholder, normalizeKeys, ResizeSensorComponent, isPresent, ResizeBatchService } from '@progress/kendo-angular-common';
import { ButtonComponent } from '@progress/kendo-angular-buttons';
import { DropDownListComponent } from '@progress/kendo-angular-dropdowns';
import { NumericTextBoxComponent } from '@progress/kendo-angular-inputs';
import { validatePackage } from '@progress/kendo-licensing';
import { NgTemplateOutlet, NgStyle } from '@angular/common';
import { take } from 'rxjs/operators';
import { IconsService } from '@progress/kendo-angular-icons';
import { PopupService } from '@progress/kendo-angular-popup';

/**
 * @hidden
 */
class PreventableEvent {
    prevented = false;
    /**
     * Prevents the default action for a specified event.
     * In this way, the source component suppresses the built-in behavior that follows the event.
     */
    preventDefault() {
        this.prevented = true;
    }
    /**
     * If the event is prevented by any of its subscribers, returns `true`.
     *
     * @returns `true` if the default action was prevented. Otherwise, returns `false`.
     */
    isDefaultPrevented() {
        return this.prevented;
    }
}

/**
 * Represents the arguments for the `pageSizeChange` event. The `pageSizeChange` event fires when you change the page size
 * from the UI. If you cancel the event, the change does not occur.
 */
class PageSizeChangeEvent extends PreventableEvent {
    /**
     * Gets the newly selected page size.
     */
    newPageSize;
    /**
     * Constructs the event arguments for the `pageSizeChange` event.
     * @param newPageSize - The newly selected page size.
     * @hidden
     */
    constructor(newPageSize) {
        super();
        this.newPageSize = newPageSize;
    }
}

/**
 * @hidden
 */
class Messages extends ComponentMessages {
    /**
     * The label of the pager. Follows the pattern **Page navigation, page {currentPage} of {totalPages}** by default.
     * Тhe default label text when the current page is 1, and the total number of pages is 10 will be
     * **Page navigation, page 1 of 10**.
     *
     * The message consists of several parts - the current page number, the total number of pages, and a localizable string.
     * To allow for reordering its parts, the `ariaLabel` input accepts a string with placeholders for the current page
     * and total number of pages. The `{currentPage}` and `{totalPages}` placeholders will be replaced
     * internally with the respective actual values.
     */
    ariaLabel;
    /**
     * The label for the **First page** button.
     */
    firstPage;
    /**
     * The label for the **Last page** button.
     */
    lastPage;
    /**
     * The label for the **Previous page** button.
     */
    previousPage;
    /**
     * The label for the **Next page** button.
     */
    nextPage;
    /**
     * The label displayed before the pager input.
     */
    page;
    /**
     * The title attribute of the page number input element.
     */
    pageNumberInputTitle;
    /**
     * The label displayed after the page-size selector.
     */
    itemsPerPage;
    /**
     * The label before the total-page number.
     */
    of;
    /**
     * The label after the total-page number.
     */
    items;
    /**
     * The text of the title and aria-label attributes applied to the page chooser.
     */
    selectPage;
    /**
     * The text of the aria-label attribute applied to the input element for entering the page number."
     */
    inputLabel;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: Messages, deps: null, target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: Messages, isStandalone: true, selector: "kendoPagerMessages", inputs: { ariaLabel: "ariaLabel", firstPage: "firstPage", lastPage: "lastPage", previousPage: "previousPage", nextPage: "nextPage", page: "page", pageNumberInputTitle: "pageNumberInputTitle", itemsPerPage: "itemsPerPage", of: "of", items: "items", selectPage: "selectPage", inputLabel: "inputLabel" }, usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: Messages, decorators: [{
            type: Directive,
            args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: 'kendoPagerMessages'
                }]
        }], propDecorators: { ariaLabel: [{
                type: Input
            }], firstPage: [{
                type: Input
            }], lastPage: [{
                type: Input
            }], previousPage: [{
                type: Input
            }], nextPage: [{
                type: Input
            }], page: [{
                type: Input
            }], pageNumberInputTitle: [{
                type: Input
            }], itemsPerPage: [{
                type: Input
            }], of: [{
                type: Input
            }], items: [{
                type: Input
            }], selectPage: [{
                type: Input
            }], inputLabel: [{
                type: Input
            }] } });

/**
 * Represents the Kendo UI Pager custom messages component for Angular. Use this component to override default component messages
 * ([see example]({% slug pager_globalization %}#toc-messages)).
 *
 * @example
 * ```html
 * <kendo-pager [skip]="skip" [pageSize]="pageSize" [total]="total">
 *   <kendo-pager-messages
 *     previousNext="Previous/Next"
 *     page="Page"
 *     of="of">
 *   </kendo-pager-messages>
 * </kendo-pager>
 * ```
 */
class CustomMessagesComponent extends Messages {
    service;
    constructor(service) {
        super();
        this.service = service;
    }
    get override() {
        return true;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CustomMessagesComponent, deps: [{ token: i1.LocalizationService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: CustomMessagesComponent, isStandalone: true, selector: "kendo-datapager-messages, kendo-pager-messages", providers: [
            {
                provide: Messages,
                useExisting: forwardRef(() => CustomMessagesComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CustomMessagesComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: Messages,
                            useExisting: forwardRef(() => CustomMessagesComponent)
                        }
                    ],
                    selector: 'kendo-datapager-messages, kendo-pager-messages',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1.LocalizationService }] });

/**
 * @hidden
 */
class LocalizedMessagesDirective extends Messages {
    service;
    constructor(service) {
        super();
        this.service = service;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: LocalizedMessagesDirective, deps: [{ token: i1.LocalizationService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: LocalizedMessagesDirective, isStandalone: true, selector: "[kendoPagerLocalizedMessages]", providers: [
            {
                provide: Messages,
                useExisting: forwardRef(() => LocalizedMessagesDirective)
            }
        ], usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: LocalizedMessagesDirective, decorators: [{
            type: Directive,
            args: [{
                    providers: [
                        {
                            provide: Messages,
                            useExisting: forwardRef(() => LocalizedMessagesDirective)
                        }
                    ],
                    selector: '[kendoPagerLocalizedMessages]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1.LocalizationService }] });

/**
 * @hidden
 */
class PagerContextService {
    total;
    skip;
    pageSize;
    isAllSelected = false;
    localization;
    changes = new Subject();
    pageChange = new Subject();
    pageSizeChange = new Subject();
    get currentPage() {
        return this.skip / this.pageSize;
    }
    notifyChanges(changes) {
        this.total = changes.total;
        this.skip = changes.skip;
        this.pageSize = changes.pageSize;
        this.isAllSelected = changes.isAllSelected || false;
        this.changes.next(changes);
    }
    changePage(page) {
        this.pageChange.next({ skip: page * this.pageSize, take: this.pageSize });
    }
    changePageSize(event) {
        this.pageSizeChange.next(event);
    }
    nextPage() {
        const nextPage = this.currentPage + 1;
        if (nextPage * this.pageSize < this.total) {
            this.changePage(nextPage);
        }
    }
    prevPage() {
        const prevPage = this.currentPage - 1;
        if (prevPage * this.pageSize >= 0) {
            this.changePage(prevPage);
        }
    }
}

/**
 * @hidden
 */
class PagerElementComponent {
    localization;
    pagerContext;
    cd;
    total;
    skip;
    pageSize;
    caretAltLeftIcon = caretAltLeftIcon;
    caretAltToLeftIcon = caretAltToLeftIcon;
    caretAltRightIcon = caretAltRightIcon;
    caretAltToRightIcon = caretAltToRightIcon;
    /**
     * @hidden
     *
     * @readonly
     * @type {number}
     * @memberOf PagerElementComponent
     */
    get currentPage() {
        return Math.floor((this.skip || 0) / this.pageSize) + 1;
    }
    /**
     * @hidden
     *
     * @readonly
     * @type {number}
     * @memberOf PagerElementComponent
     */
    get totalPages() {
        return Math.ceil((this.total || 0) / this.pageSize);
    }
    subscriptions;
    constructor(localization, pagerContext, cd) {
        this.localization = localization;
        this.pagerContext = pagerContext;
        this.cd = cd;
        this.total = pagerContext.total;
        this.skip = pagerContext.skip;
        this.pageSize = pagerContext.pageSize;
    }
    /**
     * @hidden
     *
     * @param {string} key
     * @returns {string}
     *
     * @memberOf PagerElementComponent
     */
    textFor(key) {
        const isPagerLocalization = this.localization.prefix === 'kendo.pager';
        return this.localization.get(isPagerLocalization ? key : `pager${key[0].toLocaleUpperCase()}${key.slice(1)}`);
    }
    /**
     * @hidden
     *
     * @param {number} page
     *
     * @memberOf PagerElementComponent
     */
    changePage(page) {
        this.pagerContext.changePage(page);
        return false;
    }
    /**
     * @hidden
     *
     * @memberOf PagerElementComponent
     */
    ngOnInit() {
        this.subscriptions = this.pagerContext.changes.subscribe(this.onChanges.bind(this));
        this.subscriptions.add(this.localization.changes.subscribe(() => this.cd.markForCheck()));
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    }
    get prevArrowIcons() {
        return !this.localization.rtl ? ['caret-alt-to-left', 'caret-alt-left'] : ['caret-alt-to-right', 'caret-alt-right'];
    }
    get prevArrowSVGIcons() {
        return !this.localization.rtl ? [this.caretAltToLeftIcon, this.caretAltLeftIcon] : [this.caretAltToRightIcon, this.caretAltRightIcon];
    }
    get nextArrowIcons() {
        return !this.localization.rtl ? ['caret-alt-right', 'caret-alt-to-right'] : ['caret-alt-left', 'caret-alt-to-left'];
    }
    get nextArrowSVGIcons() {
        return !this.localization.rtl ? [this.caretAltRightIcon, this.caretAltToRightIcon] : [this.caretAltLeftIcon, this.caretAltToLeftIcon];
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PagerElementComponent, deps: [{ token: i1.LocalizationService }, { token: PagerContextService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: PagerElementComponent, isStandalone: true, selector: "kendo-pager-element", ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PagerElementComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-pager-element',
                    template: ``
                }]
        }], ctorParameters: () => [{ type: i1.LocalizationService }, { type: PagerContextService }, { type: i0.ChangeDetectorRef }] });

/**
 * @hidden
 */
const DEFAULT_PAGE_SIZE_VALUES = [5, 10, 20].map(n => ({
    text: String(n),
    value: n
}));
/**
 * @hidden
 */
const focusableDirectiveSelector = '[kendoPagerFocusable]';
/**
 * @hidden
 */
const getAllFocusableChildren = (parent) => {
    return Array.from(parent.querySelectorAll(focusableDirectiveSelector))?.filter(isVisible);
};
/**
 * @hidden
 */
const focusableSelector = [
    'a[href]:not([disabled]):not([aria-hidden="true"])',
    'area[href]:not([disabled]):not([aria-hidden="true"])',
    'input:not([disabled]):not([aria-hidden="true"])',
    'select:not([disabled]):not([aria-hidden="true"])',
    'textarea:not([disabled]):not([aria-hidden="true"])',
    'button:not([aria-hidden="true"])',
    'iframe:not([disabled])',
    'object:not([disabled])',
    'embed:not([disabled])',
    '*[tabindex]:not([disabled]):not([aria-hidden="true"])',
    '*[contenteditable]:not([disabled]):not([contenteditable="false"])'
].join(',');
/**
 * @hidden
 */
const DEFAULT_SIZE = 'medium';
const SIZES = {
    small: 'sm',
    medium: 'md',
    large: 'lg'
};
/**
 * @hidden
 *
 * Returns the styling classes to be added and removed
 */
const getStylingClasses = (componentType, stylingOption, previousValue, newValue) => {
    switch (stylingOption) {
        case 'size':
            return {
                toRemove: `k-${componentType}-${SIZES[previousValue]}`,
                toAdd: newValue !== 'none' ? `k-${componentType}-${SIZES[newValue]}` : ''
            };
        default:
            break;
    }
};
/**
 * @hidden
 */
const calculatePadding = (element) => {
    if (!element || !isDocumentAvailable()) {
        return { padding: 0, gapNumbersSizes: 0, gapSizesInfo: 0 };
    }
    const computedStyle = window.getComputedStyle(element);
    const paddingLeft = parseInt(computedStyle.paddingLeft, 10) || 0;
    const paddingRight = parseInt(computedStyle.paddingRight, 10) || 0;
    const padding = (paddingLeft + paddingRight) * 1.2; // account for rounding errors
    const style = getComputedStyle(document.documentElement);
    const gapNumbersSizes = 2 * (parseFloat(style.getPropertyValue('--kendo-spacing-3\\.5') || '0.875rem') * (parseFloat(getComputedStyle(document.documentElement).fontSize) || 16)); // convert rem to px
    const gapSizesInfo = gapNumbersSizes;
    return { padding, gapNumbersSizes, gapSizesInfo };
};
/**
 * @hidden
 */
const calculateGap = (element) => {
    if (!element || !isDocumentAvailable()) {
        return 0;
    }
    const computedStyle = window.getComputedStyle(element);
    return parseFloat(computedStyle.gap) || 0;
};
/**
 * @hidden
 */
const createMeasurementSpan = (renderer, container, className) => {
    const span = renderer.createElement('span');
    renderer.appendChild(container, span);
    renderer.addClass(span, className);
    return span;
};
/**
 * @hidden
 */
const copyComputedStyles = (renderer, source, destination) => {
    const computedStyle = getComputedStyle(source);
    const importantStyles = [
        'font-family', 'font-size', 'font-weight', 'font-style',
        'letter-spacing', 'text-transform', 'white-space', 'word-spacing',
        'padding-left', 'padding-right', 'margin-left', 'margin-right',
        'border-left-width', 'border-right-width', 'box-sizing'
    ];
    importantStyles.forEach(style => {
        renderer.setStyle(destination, style, computedStyle.getPropertyValue(style));
    });
};
/**
 *
 * @hidden
 */
const positionOffScreen = (renderer, element) => {
    renderer.setStyle(element, 'position', 'absolute');
    renderer.setStyle(element, 'visibility', 'hidden');
    renderer.setStyle(element, 'left', '-9999px');
    renderer.setStyle(element, 'top', '-9999px');
    renderer.setStyle(element, 'display', 'flex');
};

/**
 * @hidden
 */
class PagerNavigationService {
    isNavigable = true;
    innerNavigationChange = new Subject();
    toggleInnerNavigation(value) {
        this.innerNavigationChange.next(value);
    }
    keepFocusWithinComponent(wrapper, target, event) {
        const [firstFocusable, lastFocusable] = this.getFirstAndLastFocusable(wrapper);
        const tabAfterLastFocusable = !event.shiftKey && target === lastFocusable;
        const shiftTabAfterFirstFocusable = event.shiftKey && target === firstFocusable;
        if (tabAfterLastFocusable) {
            event.preventDefault();
            firstFocusable.focus();
        }
        if (shiftTabAfterFirstFocusable) {
            event.preventDefault();
            lastFocusable.focus();
        }
    }
    getFirstAndLastFocusable(wrapper) {
        const all = getAllFocusableChildren(wrapper);
        const firstFocusable = all.length > 0 ? all[0] : wrapper;
        const lastFocusable = all.length > 0 ? all[all.length - 1] : wrapper;
        return [
            isFocusable(firstFocusable) ? firstFocusable : firstFocusable.querySelector(focusableSelector),
            isFocusable(lastFocusable) ? lastFocusable : lastFocusable.querySelector(focusableSelector)
        ];
    }
}

/**
 * Represents the Kendo UI Pager focusable directive for Angular. Apply this directive to custom focusable elements in the [`kendoPagerTemplate`]({% slug api_pager_pagertemplatedirective %}) to include them in the built-in Pager keyboard navigation.
 *
 * @example
 * ```html
 * <kendo-pager [skip]="skip" [pageSize]="pageSize" [total]="total">
 *   <ng-template kendoPagerTemplate>
 *     <button kendoPagerFocusable type="button">Custom Button</button>
 *   </ng-template>
 * </kendo-pager>
 * ```
 */
class PagerFocusableDirective {
    navigationService;
    element;
    renderer;
    subscriptions = new Subscription();
    constructor(navigationService, element, renderer) {
        this.navigationService = navigationService;
        this.element = element;
        this.renderer = renderer;
    }
    ngOnInit() {
        if (!(this.nativeElement instanceof HTMLElement)) {
            return;
        }
        this.subscriptions.add(this.navigationService.innerNavigationChange.subscribe(this.innerNavigationChange.bind(this)));
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    get nativeElement() {
        return this.element.nativeElement;
    }
    innerNavigationChange(value) {
        if (!this.navigationService.isNavigable) {
            return;
        }
        const index = value ? '0' : '-1';
        if (this.nativeElement.matches(focusableSelector)) {
            this.renderer.setAttribute(this.nativeElement, 'tabindex', index);
        }
        const focusableElements = this.nativeElement.querySelectorAll(focusableSelector);
        focusableElements.forEach(el => {
            this.renderer.setAttribute(el, 'tabindex', index);
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PagerFocusableDirective, deps: [{ token: PagerNavigationService }, { token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: PagerFocusableDirective, isStandalone: true, selector: "[kendoPagerFocusable]", exportAs: ["kendoPagerFocusable"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PagerFocusableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoPagerFocusable]',
                    exportAs: 'kendoPagerFocusable',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: PagerNavigationService }, { type: i0.ElementRef }, { type: i0.Renderer2 }] });

// eslint-disable no-access-missing-member
/**
 * Represents the Kendo UI Pager Previous Buttons component for Angular. Displays buttons for navigating to the first and to the previous page ([see example]({% slug pager_settings %})).
 *
 * @example
 * ```html
 * <kendo-pager [skip]="skip" [pageSize]="pageSize" [total]="total">
 *   <ng-template kendoPagerTemplate>
 *     <kendo-pager-prev-buttons></kendo-pager-prev-buttons>
 *   </ng-template>
 * </kendo-pager>
 * ```
 */
class PagerPrevButtonsComponent extends PagerElementComponent {
    constructor(localization, pagerContext, cd) {
        super(localization, pagerContext, cd);
    }
    /**
     * Specifies the padding of the navigation buttons.
     *
     * @default 'medium'
     */
    size = DEFAULT_SIZE;
    /**
     * @hidden
     *
     * @readonly
     * @type {boolean}
     * @memberOf PagerPrevButtonsComponent
     */
    get disabled() {
        return this.currentPage === 1 || !this.total;
    }
    /**
     * @hidden
     */
    onClick(isFirst = false) {
        if (this.disabled) {
            return false;
        }
        const targetPage = isFirst ? 0 : this.currentPage - 2;
        return this.currentPage !== 1 ? this.changePage(targetPage) : false;
    }
    onChanges({ total, skip, pageSize }) {
        this.total = total;
        this.skip = skip;
        this.pageSize = pageSize;
        this.cd.markForCheck();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PagerPrevButtonsComponent, deps: [{ token: i1.LocalizationService }, { token: PagerContextService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: PagerPrevButtonsComponent, isStandalone: true, selector: "kendo-datapager-prev-buttons, kendo-pager-prev-buttons", inputs: { size: "size" }, usesInheritance: true, ngImport: i0, template: `
        <button
            type="button" kendoButton
            kendoPagerFocusable
            class="k-pager-nav k-pager-first"
            [attr.aria-disabled]="disabled"
            [class.k-disabled]="disabled"
            [icon]="prevArrowIcons[0]"
            [svgIcon]="prevArrowSVGIcons[0]"
            fillMode="flat"
            rounded="none"
            [size]="size"
            [title]="textFor('firstPage')"
            [attr.aria-label]="textFor('firstPage')"
            (click)="onClick(true)">
        </button>
        <button
            type="button" kendoButton
            kendoPagerFocusable
            class="k-pager-nav"
            [attr.aria-disabled]="disabled"
            [class.k-disabled]="disabled"
            [icon]="prevArrowIcons[1]"
            [svgIcon]="prevArrowSVGIcons[1]"
            fillMode="flat"
            rounded="none"
            [size]="size"
            [title]="textFor('previousPage')"
            [attr.aria-label]="textFor('previousPage')"
            (click)="onClick()">
        </button>
    `, isInline: true, dependencies: [{ kind: "component", type: ButtonComponent, selector: "button[kendoButton]", inputs: ["arrowIcon", "toggleable", "togglable", "selected", "tabIndex", "imageUrl", "iconClass", "icon", "disabled", "size", "rounded", "fillMode", "themeColor", "svgIcon", "primary", "look"], outputs: ["selectedChange", "click"], exportAs: ["kendoButton"] }, { kind: "directive", type: PagerFocusableDirective, selector: "[kendoPagerFocusable]", exportAs: ["kendoPagerFocusable"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PagerPrevButtonsComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-datapager-prev-buttons, kendo-pager-prev-buttons',
                    template: `
        <button
            type="button" kendoButton
            kendoPagerFocusable
            class="k-pager-nav k-pager-first"
            [attr.aria-disabled]="disabled"
            [class.k-disabled]="disabled"
            [icon]="prevArrowIcons[0]"
            [svgIcon]="prevArrowSVGIcons[0]"
            fillMode="flat"
            rounded="none"
            [size]="size"
            [title]="textFor('firstPage')"
            [attr.aria-label]="textFor('firstPage')"
            (click)="onClick(true)">
        </button>
        <button
            type="button" kendoButton
            kendoPagerFocusable
            class="k-pager-nav"
            [attr.aria-disabled]="disabled"
            [class.k-disabled]="disabled"
            [icon]="prevArrowIcons[1]"
            [svgIcon]="prevArrowSVGIcons[1]"
            fillMode="flat"
            rounded="none"
            [size]="size"
            [title]="textFor('previousPage')"
            [attr.aria-label]="textFor('previousPage')"
            (click)="onClick()">
        </button>
    `,
                    standalone: true,
                    imports: [ButtonComponent, PagerFocusableDirective]
                }]
        }], ctorParameters: () => [{ type: i1.LocalizationService }, { type: PagerContextService }, { type: i0.ChangeDetectorRef }], propDecorators: { size: [{
                type: Input
            }] } });

/**
 * Represents the Kendo UI Pager Page Sizes component for Angular. Displays a drop-down list for the page size selection ([see example]({% slug pager_settings %})).
 *
 * @example
 * ```html
 * <kendo-pager [skip]="skip" [pageSize]="pageSize" [total]="total">
 *   <ng-template kendoPagerTemplate>
 *     <kendo-pager-page-sizes [pageSizes]="[10, 20, 50]"></kendo-pager-page-sizes>
 *   </ng-template>
 * </kendo-pager>
 * ```
 */
class PagerPageSizesComponent extends PagerElementComponent {
    pagerContext;
    element;
    ngZone;
    dropDownList;
    _showItemsText = true;
    /**
     * Controls the visibility of the page text label.
     * @hidden
     */
    get showItemsText() {
        return this._showItemsText;
    }
    set showItemsText(value) {
        this._showItemsText = value;
        this.cd.markForCheck();
    }
    /**
     * Specifies the page sizes collection. You can include numbers and [`PageSizeItem`]({% slug api_pager_pagesizeitem %}) objects.
     *
     * @example
     * ```html
     * <kendo-pager [skip]="0" [pageSize]="10" [total]="100">
     *   <ng-template kendoPagerTemplate>
     *     <kendo-pager-page-sizes [pageSizes]="[5, 10, 20, { text: 'All', value: 'all' }]"></kendo-pager-page-sizes>
     *   </ng-template>
     * </kendo-pager>
     * ```
     */
    set pageSizes(pageSizes) {
        let normalizedItems = [];
        if (Array.isArray(pageSizes)) {
            pageSizes.forEach(item => {
                if (typeof item === 'number') {
                    normalizedItems.push({
                        text: item.toString(),
                        value: item
                    });
                }
                else {
                    normalizedItems.push(item);
                }
            });
        }
        else {
            normalizedItems = DEFAULT_PAGE_SIZE_VALUES;
        }
        if (this.pageSize && !normalizedItems.some(item => item.value === this.pageSize)) {
            normalizedItems = [{ text: this.pageSize.toString(), value: this.pageSize }, ...normalizedItems];
        }
        this._pageSizes = normalizedItems;
    }
    /**
     * Specifies the padding of the DropDownList component.
     *
     * @default 'medium'
     */
    size = DEFAULT_SIZE;
    /**
     * Specifies the adaptive mode of the internal `DropDownList` component.
     *
     * @default 'auto'
     */
    adaptiveMode = 'auto';
    /**
     * @hidden
     *
     * @readonly
     */
    get classes() {
        return true;
    }
    _pageSizes = [];
    constructor(localization, cd, pagerContext, element, ngZone) {
        super(localization, pagerContext, cd);
        this.pagerContext = pagerContext;
        this.element = element;
        this.ngZone = ngZone;
    }
    ngAfterViewInit() {
        this.ngZone.runOutsideAngular(() => {
            this.element.nativeElement.addEventListener('keydown', this.keyDownHandler.bind(this), true);
        });
    }
    ngOnDestroy() {
        this.element.nativeElement.removeEventListener('keydown', this.keyDownHandler);
    }
    /**
     * @hidden
     */
    pageSizeChange(value, dropdownlist) {
        const event = new PageSizeChangeEvent(value);
        this.pagerContext.changePageSize(event);
        if (event.isDefaultPrevented()) {
            dropdownlist.writeValue(this.pageSize);
        }
    }
    onChanges({ total, skip, pageSize, isAllSelected }) {
        this.total = total;
        this.skip = skip;
        const normalizedPageSize = typeof pageSize === 'number' ? pageSize : this.total;
        this.pageSize = isAllSelected ? 'all' : normalizedPageSize;
        this.cd.markForCheck();
    }
    keyDownHandler(ev) {
        if (ev.code === Keys.Escape && this.dropDownList.isOpen) {
            ev.stopPropagation();
            this.dropDownList.toggle(false);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PagerPageSizesComponent, deps: [{ token: i1.LocalizationService }, { token: i0.ChangeDetectorRef }, { token: PagerContextService }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: PagerPageSizesComponent, isStandalone: true, selector: "kendo-datapager-page-sizes, kendo-pager-page-sizes", inputs: { showItemsText: "showItemsText", pageSizes: "pageSizes", size: "size", adaptiveMode: "adaptiveMode" }, host: { properties: { "class.k-pager-sizes": "this.classes" } }, viewQueries: [{ propertyName: "dropDownList", first: true, predicate: ["dropdownlist"], descendants: true, static: true }], usesInheritance: true, ngImport: i0, template: `
        <kendo-dropdownlist kendoPagerFocusable
          #dropdownlist
          [size]="size"
          [data]="_pageSizes"
          textField="text"
          valueField="value"
          [valuePrimitive]="true"
          [value]="pageSize"
          (valueChange)="pageSizeChange($event, dropdownlist)"
          [adaptiveMode]="adaptiveMode"
          [attr.aria-label]="textFor('itemsPerPage')">
        </kendo-dropdownlist>
        @if (showItemsText) {
          {{ textFor('itemsPerPage') }}
        }
        `, isInline: true, dependencies: [{ kind: "component", type: DropDownListComponent, selector: "kendo-dropdownlist", inputs: ["customIconClass", "showStickyHeader", "icon", "svgIcon", "loading", "data", "value", "textField", "valueField", "adaptiveMode", "adaptiveTitle", "adaptiveSubtitle", "popupSettings", "listHeight", "defaultItem", "disabled", "itemDisabled", "readonly", "filterable", "virtual", "ignoreCase", "delay", "valuePrimitive", "tabindex", "tabIndex", "size", "rounded", "fillMode", "leftRightArrowsNavigation", "id"], outputs: ["valueChange", "filterChange", "selectionChange", "open", "opened", "close", "closed", "focus", "blur"], exportAs: ["kendoDropDownList"] }, { kind: "directive", type: PagerFocusableDirective, selector: "[kendoPagerFocusable]", exportAs: ["kendoPagerFocusable"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PagerPageSizesComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-datapager-page-sizes, kendo-pager-page-sizes',
                    template: `
        <kendo-dropdownlist kendoPagerFocusable
          #dropdownlist
          [size]="size"
          [data]="_pageSizes"
          textField="text"
          valueField="value"
          [valuePrimitive]="true"
          [value]="pageSize"
          (valueChange)="pageSizeChange($event, dropdownlist)"
          [adaptiveMode]="adaptiveMode"
          [attr.aria-label]="textFor('itemsPerPage')">
        </kendo-dropdownlist>
        @if (showItemsText) {
          {{ textFor('itemsPerPage') }}
        }
        `,
                    standalone: true,
                    imports: [DropDownListComponent, PagerFocusableDirective]
                }]
        }], ctorParameters: () => [{ type: i1.LocalizationService }, { type: i0.ChangeDetectorRef }, { type: PagerContextService }, { type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { dropDownList: [{
                type: ViewChild,
                args: ['dropdownlist', { static: true }]
            }], showItemsText: [{
                type: Input
            }], pageSizes: [{
                type: Input
            }], size: [{
                type: Input
            }], adaptiveMode: [{
                type: Input
            }], classes: [{
                type: HostBinding,
                args: ["class.k-pager-sizes"]
            }] } });

/**
 * Represents the Kendo UI Pager template directive for Angular.
 * Use this directive to customize the Pager appearance. To define a Pager template, nest an `<ng-template>` tag with the `kendoPagerTemplate` directive inside `<kendo-pager>`.
 *
 * The template context provides the following fields:
 *
 * * `currentPage`&mdash;The index of the displayed page.
 * * `pageSize`&mdash;The value of the current `pageSize`.
 * * `skip`&mdash;The current skip value.
 * * `total`&mdash;The total number of records.
 * * `totalPages`&mdash;The total number of available pages.
 *
 * @example
 * ```html
 * <kendo-pager [skip]="0" [pageSize]="10" [total]="100">
 *   <ng-template kendoPagerTemplate let-currentPage="currentPage" let-pageSize="pageSize" let-skip="skip" let-total="total" let-totalPages="totalPages">
 *     <span>Page {{currentPage}} of {{totalPages}}</span>
 *     <span>Items per page: {{pageSize}}</span>
 *   </ng-template>
 * </kendo-pager>
 * ```
 */
class PagerTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PagerTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: PagerTemplateDirective, isStandalone: true, selector: "[kendoDataPagerTemplate], [kendoPagerTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PagerTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoDataPagerTemplate], [kendoPagerTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }] });

/**
 * Represents the Kendo UI Pager Numeric Buttons component for Angular. Displays numeric buttons to enable navigation between the pages.
 *
 * @example
 * ```html
 * <kendo-pager [skip]="skip" [pageSize]="pageSize" [total]="total">
 *   <ng-template kendoPagerTemplate>
 *     <kendo-pager-numeric-buttons [buttonCount]="5"></kendo-pager-numeric-buttons>
 *   </ng-template>
 * </kendo-pager>
 * ```
 */
class PagerNumericButtonsComponent extends PagerElementComponent {
    pagerContext;
    renderer;
    selectElement;
    numbersElement;
    /**
     * Specifies the count of the displayed buttons.
     *
     * @type {number}
     * @memberOf PagerNumericButtonsComponent
     */
    buttonCount;
    /**
     * Specifies the padding of the numeric buttons.
     *
     * @default 'medium'
     */
    set size(size) {
        const newSize = size ? size : DEFAULT_SIZE;
        this.handleClasses(newSize, 'size');
        this._size = newSize;
    }
    get size() {
        return this._size;
    }
    /**
     * @hidden
     *
     * @readonly
     * @type {number[]}
     * @memberOf PagerNumericButtonsComponent
     */
    get buttons() {
        const result = [];
        for (let idx = this.start; idx <= this.end; idx++) {
            result.push(idx);
        }
        return result;
    }
    /**
     * @hidden
     */
    get end() {
        return Math.min((this.start + this.buttonCount) - 1, this.totalPages);
    }
    /**
     * @hidden
     */
    get start() {
        const page = this.currentPage;
        const buttonCount = this.buttonCount;
        if (page > buttonCount) {
            const reminder = (page % buttonCount);
            return (reminder === 0) ? (page - buttonCount) + 1 : (page - reminder) + 1;
        }
        return 1;
    }
    constructor(localization, cd, pagerContext, renderer) {
        super(localization, pagerContext, cd);
        this.pagerContext = pagerContext;
        this.renderer = renderer;
    }
    _size = DEFAULT_SIZE;
    ngAfterViewInit() {
        this.handleClasses(this.size, 'size');
    }
    /**
     * @hidden
     */
    pageLabel(num) {
        const pageText = this.textFor('page');
        if (pageText) {
            return pageText + ' ' + num;
        }
        return num.toString();
    }
    /**
     * @hidden
     */
    onSelectChange(e) {
        const target = e.target;
        const valueAsNumber = Number(target.value);
        if (!Number.isNaN(valueAsNumber)) {
            this.changePage(valueAsNumber - 1);
        }
        else {
            if (target.value === 'previousButtons') {
                this.changePage(this.start - 2);
            }
            else {
                this.changePage(this.end);
            }
        }
    }
    onChanges({ total, skip, pageSize }) {
        this.total = total;
        this.skip = skip;
        this.pageSize = pageSize;
        this.cd.markForCheck();
    }
    get pageChooserLabel() {
        return this.textFor('selectPage');
    }
    handleClasses(value, input) {
        const elem = this.selectElement?.nativeElement;
        const classes = getStylingClasses('picker', input, this[input], value);
        if (!elem) {
            return;
        }
        if (classes.toRemove) {
            this.renderer.removeClass(elem, classes.toRemove);
        }
        if (classes.toAdd) {
            this.renderer.addClass(elem, classes.toAdd);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PagerNumericButtonsComponent, deps: [{ token: i1.LocalizationService }, { token: i0.ChangeDetectorRef }, { token: PagerContextService }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: PagerNumericButtonsComponent, isStandalone: true, selector: "kendo-datapager-numeric-buttons, kendo-pager-numeric-buttons", inputs: { buttonCount: "buttonCount", size: "size" }, viewQueries: [{ propertyName: "selectElement", first: true, predicate: ["select"], descendants: true, read: ElementRef }, { propertyName: "numbersElement", first: true, predicate: ["numbers"], descendants: true, read: ElementRef }], usesInheritance: true, ngImport: i0, template: `
        <div class="k-pager-numbers" #numbers>
          @if (start > 1) {
            <button
              type="button"
              kendoPagerFocusable
              kendoButton
              [size]="size"
              fillMode="flat"
              themeColor="primary"
              rounded="none"
              [attr.aria-label]="pageLabel(start - 1)"
              [attr.title]="pageLabel(start - 1)"
            (click)="changePage(start - 2)">...</button>
          }
          @for (num of buttons; track num) {
            <button
              type="button"
              kendoPagerFocusable
              kendoButton
              [size]="size"
              fillMode="flat"
              themeColor="primary"
              rounded="none"
              [attr.aria-label]="pageLabel(num)"
              [attr.title]="pageLabel(num)"
              [attr.aria-current]="currentPage === num ? 'page' : undefined"
              [selected]="currentPage === num"
              (click)="currentPage === num ? false : changePage(num - 1)">
              {{num}}
            </button>
          }
          @if (end < totalPages) {
            <button
              type="button"
              kendoPagerFocusable
              kendoButton
              [size]="size"
              fillMode="flat"
              themeColor="primary"
              rounded="none"
              [attr.aria-label]="pageLabel(end + 1)"
              [attr.title]="pageLabel(end + 1)"
            (click)="changePage(end)">...</button>
          }
        </div>
        `, isInline: true, dependencies: [{ kind: "directive", type: PagerFocusableDirective, selector: "[kendoPagerFocusable]", exportAs: ["kendoPagerFocusable"] }, { kind: "component", type: ButtonComponent, selector: "button[kendoButton]", inputs: ["arrowIcon", "toggleable", "togglable", "selected", "tabIndex", "imageUrl", "iconClass", "icon", "disabled", "size", "rounded", "fillMode", "themeColor", "svgIcon", "primary", "look"], outputs: ["selectedChange", "click"], exportAs: ["kendoButton"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PagerNumericButtonsComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-datapager-numeric-buttons, kendo-pager-numeric-buttons',
                    template: `
        <div class="k-pager-numbers" #numbers>
          @if (start > 1) {
            <button
              type="button"
              kendoPagerFocusable
              kendoButton
              [size]="size"
              fillMode="flat"
              themeColor="primary"
              rounded="none"
              [attr.aria-label]="pageLabel(start - 1)"
              [attr.title]="pageLabel(start - 1)"
            (click)="changePage(start - 2)">...</button>
          }
          @for (num of buttons; track num) {
            <button
              type="button"
              kendoPagerFocusable
              kendoButton
              [size]="size"
              fillMode="flat"
              themeColor="primary"
              rounded="none"
              [attr.aria-label]="pageLabel(num)"
              [attr.title]="pageLabel(num)"
              [attr.aria-current]="currentPage === num ? 'page' : undefined"
              [selected]="currentPage === num"
              (click)="currentPage === num ? false : changePage(num - 1)">
              {{num}}
            </button>
          }
          @if (end < totalPages) {
            <button
              type="button"
              kendoPagerFocusable
              kendoButton
              [size]="size"
              fillMode="flat"
              themeColor="primary"
              rounded="none"
              [attr.aria-label]="pageLabel(end + 1)"
              [attr.title]="pageLabel(end + 1)"
            (click)="changePage(end)">...</button>
          }
        </div>
        `,
                    standalone: true,
                    imports: [PagerFocusableDirective, ButtonComponent]
                }]
        }], ctorParameters: () => [{ type: i1.LocalizationService }, { type: i0.ChangeDetectorRef }, { type: PagerContextService }, { type: i0.Renderer2 }], propDecorators: { selectElement: [{
                type: ViewChild,
                args: ['select', { read: ElementRef }]
            }], numbersElement: [{
                type: ViewChild,
                args: ['numbers', { read: ElementRef }]
            }], buttonCount: [{
                type: Input
            }], size: [{
                type: Input
            }] } });

// eslint-disable  no-access-missing-member
/**
 * Represents the Kendo UI Pager Next Buttons component for Angular. Displays buttons for navigating to the next and to the last page ([see example]({% slug pager_settings %})).
 *
 * @example
 * ```html
 * <kendo-pager [skip]="skip" [pageSize]="pageSize" [total]="total">
 *   <ng-template kendoPagerTemplate>
 *     <kendo-pager-next-buttons></kendo-pager-next-buttons>
 *   </ng-template>
 * </kendo-pager>
 * ```
 */
class PagerNextButtonsComponent extends PagerElementComponent {
    /**
     * @hidden
     *
     * @readonly
     * @type {boolean}
     * @memberOf PagerNextButtonsComponent
     */
    get disabled() {
        return this.currentPage === this.totalPages || !this.total;
    }
    /**
     * Specifies the padding of the navigation buttons.
     *
     * @default 'medium'
     */
    size = DEFAULT_SIZE;
    constructor(localization, pagerContext, cd) {
        super(localization, pagerContext, cd);
    }
    /**
     * @hidden
     */
    onClick(isLast = false) {
        if (this.disabled) {
            return false;
        }
        const targetPage = isLast ? this.totalPages - 1 : this.currentPage;
        return this.currentPage !== this.totalPages ? this.changePage(targetPage) : false;
    }
    onChanges({ total, skip, pageSize }) {
        this.total = total;
        this.skip = skip;
        this.pageSize = pageSize;
        this.cd.markForCheck();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PagerNextButtonsComponent, deps: [{ token: i1.LocalizationService }, { token: PagerContextService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: PagerNextButtonsComponent, isStandalone: true, selector: "kendo-datapager-next-buttons, kendo-pager-next-buttons", inputs: { size: "size" }, usesInheritance: true, ngImport: i0, template: `
        <button kendoButton kendoPagerFocusable
            type="button"
            [size]="size"
            [icon]="nextArrowIcons[0]"
            [svgIcon]="nextArrowSVGIcons[0]"
            fillMode="flat"
            rounded="none"
            class="k-pager-nav"
            [attr.aria-disabled]="disabled"
            [class.k-disabled]="disabled"
            [title]="textFor('nextPage')"
            [attr.aria-label]="textFor('nextPage')"
            (click)="onClick()">
        </button>
        <button kendoButton kendoPagerFocusable
            type="button"
            [size]="size"
            [icon]="nextArrowIcons[1]"
            [svgIcon]="nextArrowSVGIcons[1]"
            fillMode="flat"
            rounded="none"
            class="k-pager-nav k-pager-last"
            [attr.aria-disabled]="disabled"
            [class.k-disabled]="disabled"
            [title]="textFor('lastPage')"
            [attr.aria-label]="textFor('lastPage')"
            (click)="onClick(true)">
        </button>
    `, isInline: true, dependencies: [{ kind: "component", type: ButtonComponent, selector: "button[kendoButton]", inputs: ["arrowIcon", "toggleable", "togglable", "selected", "tabIndex", "imageUrl", "iconClass", "icon", "disabled", "size", "rounded", "fillMode", "themeColor", "svgIcon", "primary", "look"], outputs: ["selectedChange", "click"], exportAs: ["kendoButton"] }, { kind: "directive", type: PagerFocusableDirective, selector: "[kendoPagerFocusable]", exportAs: ["kendoPagerFocusable"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PagerNextButtonsComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-datapager-next-buttons, kendo-pager-next-buttons',
                    template: `
        <button kendoButton kendoPagerFocusable
            type="button"
            [size]="size"
            [icon]="nextArrowIcons[0]"
            [svgIcon]="nextArrowSVGIcons[0]"
            fillMode="flat"
            rounded="none"
            class="k-pager-nav"
            [attr.aria-disabled]="disabled"
            [class.k-disabled]="disabled"
            [title]="textFor('nextPage')"
            [attr.aria-label]="textFor('nextPage')"
            (click)="onClick()">
        </button>
        <button kendoButton kendoPagerFocusable
            type="button"
            [size]="size"
            [icon]="nextArrowIcons[1]"
            [svgIcon]="nextArrowSVGIcons[1]"
            fillMode="flat"
            rounded="none"
            class="k-pager-nav k-pager-last"
            [attr.aria-disabled]="disabled"
            [class.k-disabled]="disabled"
            [title]="textFor('lastPage')"
            [attr.aria-label]="textFor('lastPage')"
            (click)="onClick(true)">
        </button>
    `,
                    standalone: true,
                    imports: [ButtonComponent, PagerFocusableDirective]
                }]
        }], ctorParameters: () => [{ type: i1.LocalizationService }, { type: PagerContextService }, { type: i0.ChangeDetectorRef }], propDecorators: { size: [{
                type: Input
            }] } });

/**
 * Represents the Kendo UI Pager Input component for Angular. Displays an input element which allows you to type and render page numbers.
 *
 * @example
 * ```html
 * <kendo-pager [skip]="skip" [pageSize]="pageSize" [total]="total">
 *   <ng-template kendoPagerTemplate>
 *     <kendo-pager-input></kendo-pager-input>
 *   </ng-template>
 * </kendo-pager>
 * ```
 */
class PagerInputComponent extends PagerElementComponent {
    pagerContext;
    zone;
    renderer;
    numericInput;
    /**
     * Controls the visibility of the page text label.
     * @hidden
     */
    showPageText = true;
    /**
     * Specifies the padding of the internal `NumericTextBox` component.
     *
     * @default 'medium'
     */
    size = DEFAULT_SIZE;
    constructor(localization, pagerContext, zone, cd, renderer) {
        super(localization, pagerContext, cd);
        this.pagerContext = pagerContext;
        this.zone = zone;
        this.renderer = renderer;
    }
    onChanges({ total, skip, pageSize }) {
        this.total = total;
        this.skip = skip;
        this.pageSize = pageSize;
        this.cd.markForCheck();
    }
    /**
     * @hidden
     *
     * @param {string} value
     *
     * @memberOf PagerInputComponent
     */
    handleKeyDown = (event) => {
        const incomingValue = this.numericInput.value || this.current;
        // eslint-disable import/no-deprecated
        if (event.code === Keys.Enter || event.code === Keys.NumpadEnter) {
            event.preventDefault();
            if (incomingValue !== this.current) {
                this.zone.run(() => {
                    this.changePage(incomingValue - 1);
                });
            }
        }
    };
    /**
     * @hidden
     *
     * @param {string} value
     *
     * @memberOf PagerInputComponent
     */
    handleBlur = () => {
        const inputValue = this.numericInput.value;
        if (!inputValue) {
            this.numericInput.writeValue(this.current);
            return;
        }
        if (inputValue !== this.current) {
            this.zone.run(() => {
                this.changePage(inputValue - 1);
            });
        }
    };
    /**
     * @hidden
     */
    get current() {
        return this.hasPages ? this.currentPage : 0;
    }
    /**
     * @hidden
     */
    get hasPages() {
        return this.totalPages !== 0;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PagerInputComponent, deps: [{ token: i1.LocalizationService }, { token: PagerContextService }, { token: i0.NgZone }, { token: i0.ChangeDetectorRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: PagerInputComponent, isStandalone: true, selector: "kendo-datapager-input, kendo-pager-input", inputs: { showPageText: "showPageText", size: "size" }, viewQueries: [{ propertyName: "numericInput", first: true, predicate: NumericTextBoxComponent, descendants: true, static: true }], usesInheritance: true, ngImport: i0, template: `
     <span class="k-pager-input">
       @if (showPageText) {
         {{textFor('page')}}
       }
       <kendo-numerictextbox kendoPagerFocusable
         [spinners]="false"
         [decimals]="0"
         format="n0"
         [size]="size"
         [disabled]="!hasPages"
         [value]="current"
         [min]="hasPages ? 1 : 0"
         [max]="totalPages"
         [autoCorrect]="true"
            [inputAttributes]="{
                'aria-label': textFor('inputLabel')
            }"
         [title]="textFor('pageNumberInputTitle')"
            [kendoEventsOutsideAngular]="{
                keydown: handleKeyDown,
                focusout: handleBlur
            }">
       </kendo-numerictextbox>
       {{textFor('of')}} {{totalPages}}
     </span>
     `, isInline: true, dependencies: [{ kind: "component", type: NumericTextBoxComponent, selector: "kendo-numerictextbox", inputs: ["focusableId", "disabled", "readonly", "title", "autoCorrect", "format", "max", "min", "decimals", "placeholder", "step", "spinners", "rangeValidation", "tabindex", "tabIndex", "changeValueOnScroll", "selectOnFocus", "value", "maxlength", "size", "rounded", "fillMode", "inputAttributes"], outputs: ["valueChange", "focus", "blur", "inputFocus", "inputBlur"], exportAs: ["kendoNumericTextBox"] }, { kind: "directive", type: PagerFocusableDirective, selector: "[kendoPagerFocusable]", exportAs: ["kendoPagerFocusable"] }, { kind: "directive", type: EventsOutsideAngularDirective, selector: "[kendoEventsOutsideAngular]", inputs: ["kendoEventsOutsideAngular", "scope"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PagerInputComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-datapager-input, kendo-pager-input',
                    template: `
     <span class="k-pager-input">
       @if (showPageText) {
         {{textFor('page')}}
       }
       <kendo-numerictextbox kendoPagerFocusable
         [spinners]="false"
         [decimals]="0"
         format="n0"
         [size]="size"
         [disabled]="!hasPages"
         [value]="current"
         [min]="hasPages ? 1 : 0"
         [max]="totalPages"
         [autoCorrect]="true"
            [inputAttributes]="{
                'aria-label': textFor('inputLabel')
            }"
         [title]="textFor('pageNumberInputTitle')"
            [kendoEventsOutsideAngular]="{
                keydown: handleKeyDown,
                focusout: handleBlur
            }">
       </kendo-numerictextbox>
       {{textFor('of')}} {{totalPages}}
     </span>
     `,
                    standalone: true,
                    imports: [NumericTextBoxComponent, PagerFocusableDirective, EventsOutsideAngularDirective]
                }]
        }], ctorParameters: () => [{ type: i1.LocalizationService }, { type: PagerContextService }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }, { type: i0.Renderer2 }], propDecorators: { numericInput: [{
                type: ViewChild,
                args: [NumericTextBoxComponent, { static: true }]
            }], showPageText: [{
                type: Input
            }], size: [{
                type: Input
            }] } });

// eslint-disable no-access-missing-member
/**
 * Represents the Kendo UI Pager Info component for Angular. Displays information about the current page and the total number of records ([see example]({% slug pager_settings %})).
 *
 * @example
 * ```html
 * <kendo-pager [skip]="skip" [pageSize]="pageSize" [total]="total">
 *   <ng-template kendoPagerTemplate>
 *     <kendo-pager-info></kendo-pager-info>
 *   </ng-template>
 * </kendo-pager>
 * ```
 */
class PagerInfoComponent extends PagerElementComponent {
    /**
     * @hidden
     *
     * @readonly
     * @type {number}
     * @memberOf PagerInfoComponent
     */
    get maxItems() {
        return Math.min(this.currentPage * this.pageSize, this.total);
    }
    /**
     * @hidden
     *
     * @readonly
     * @type {number}
     * @memberOf PagerInfoComponent
     */
    get currentPageText() {
        return this.total ?
            (this.currentPage - 1) * this.pageSize + 1 :
            0;
    }
    /**
     * @hidden
     *
     * @readonly
     * @type {boolean}
     * @memberOf PagerInfoComponent
     */
    hostClass = true;
    constructor(localization, cd, pagerContext) {
        super(localization, pagerContext, cd);
    }
    onChanges({ total, skip, pageSize }) {
        this.total = total;
        this.skip = skip;
        this.pageSize = pageSize;
        this.cd.markForCheck();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PagerInfoComponent, deps: [{ token: i1.LocalizationService }, { token: i0.ChangeDetectorRef }, { token: PagerContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: PagerInfoComponent, isStandalone: true, selector: "kendo-datapager-info, kendo-pager-info", host: { properties: { "class.k-pager-info": "this.hostClass" } }, usesInheritance: true, ngImport: i0, template: `{{currentPageText}} - {{maxItems}} {{textFor('of')}} {{total}} {{textFor('items')}}`, isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PagerInfoComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-datapager-info, kendo-pager-info',
                    template: `{{currentPageText}} - {{maxItems}} {{textFor('of')}} {{total}} {{textFor('items')}}`,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1.LocalizationService }, { type: i0.ChangeDetectorRef }, { type: PagerContextService }], propDecorators: { hostClass: [{
                type: HostBinding,
                args: ['class.k-pager-info']
            }] } });

/**
 * @hidden
 */
const packageMetadata = {
    name: '@progress/kendo-angular-pager',
    productName: 'Kendo UI for Angular',
    productCode: 'KENDOUIANGULAR',
    productCodes: ['KENDOUIANGULAR'],
    publishDate: 0,
    version: '22.0.1',
    licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/'
};

/**
 * Represents the Kendo UI Pager component for Angular.
 * Enables you to split a set of data into pages, providing a flexible and intuitive UI.
 *
 * @example
 * ```ts
 * @Component({
 *   selector: 'my-app',
 *   template: `
 *     <kendo-pager
 *       [total]="total"
 *       [skip]="skip"
 *       [pageSize]="pageSize"
 *       (pageChange)="onPageChange($event)">
 *     </kendo-pager>
 *   `
 * })
 * export class AppComponent {
 *   public total = 200;
 *   public skip = 0;
 *   public pageSize = 10;
 *
 *   public onPageChange(event: PageChangeEvent) {
 *     this.skip = event.skip;
 *   }
 * }
 * ```
 *
 * @remarks
 * Supported children components are:
 * {@link PagerNumericButtonsComponent},
 * {@link PagerInputComponent},
 * {@link PagerPageSizesComponent},
 * {@link PagerSpacerComponent},
 * {@link PagerPrevButtonsComponent},
 * {@link PagerNextButtonsComponent},
 * {@link PagerInfoComponent},
 * {@link CustomMessagesComponent}
 */
class PagerComponent {
    pagerContext;
    element;
    localization;
    renderer;
    ngZone;
    cdr;
    navigationService;
    /**
     * Represents the collection of pager template directives.
     */
    template;
    set numericButtons(buttons) {
        const newWidth = buttons ? buttons.nativeElement?.offsetWidth : 0;
        if (buttons && newWidth !== this.pagerDimensions.numericButtonsWidth) {
            this.pagerDimensions.numericButtonsWidth = newWidth;
        }
    }
    set pagerInput(input) {
        const newWidth = input ? input.nativeElement?.offsetWidth : 0;
        if (input && newWidth !== this.pagerDimensions.inputWidth) {
            this.pagerDimensions.inputWidth = newWidth;
        }
        if (input?.nativeElement && !this.pagerDimensions.gapPageText) {
            const innerStyledElement = input.nativeElement.querySelector('.k-pager-input');
            this.pagerDimensions.gapPageText = calculateGap(innerStyledElement);
        }
    }
    pagerInputComponent;
    set pageSizes(sizes) {
        const newWidth = sizes ? sizes.nativeElement?.offsetWidth : 0;
        if (sizes && newWidth !== this.pagerDimensions.pageSizesWidth) {
            this.pagerDimensions.pageSizesWidth = newWidth;
        }
    }
    pageSizesComponent;
    /**
     * @hidden
     */
    externalTemplate;
    /**
     * Specifies the total number of data items in the collection.
     *
     * @default 0
     */
    total = 0;
    /**
     * Specifies the number of data items to skip.
     *
     * @default 0
     */
    skip = 0;
    /**
     * Specifies the number of data items per page.
     */
    pageSize;
    /**
     * Specifies the maximum number of numeric buttons before the buttons are collapsed.
     *
     * @default 10
     */
    buttonCount = 10;
    /**
     * Determines whether to display information about the current page and the total number of records.
     *
     * @default true
     */
    info = true;
    /**
     * Specifies the type of the Pager.
     *
     * @default 'numeric'
     */
    type = 'numeric';
    /**
     * Displays a dropdown for selecting the page size.
     * When set to `true`, the dropdown contains the default list of options - 5, 10, 20.
     * To customize the list of options, set `pageSizeValues` to an array of the desired values.
     * The array can contain numbers and [PageSizeItem]({% slug api_pager_pagesizeitem %}) objects.
     */
    set pageSizeValues(value) {
        if (typeof value === 'boolean') {
            this._pageSizeValues = value ? DEFAULT_PAGE_SIZE_VALUES : [];
        }
        else {
            this._pageSizeValues = value;
        }
    }
    get pageSizeValues() {
        return this._pageSizeValues;
    }
    /**
     * Determines whether to display the **Previous** and **Next** buttons.
     *
     * @default true
     */
    previousNext = true;
    /**
     * Determines whether users can use dedicated shortcuts to interact with the Pager ([see example]({% slug keyboard_navigation_pager %})).
     * By default, navigation is enabled. To disable it and make the Pager content accessible in the normal tab sequence, set the property to `false`.
     * @default true
     */
    set navigable(value) {
        this._navigable = value;
        this.navigationService.isNavigable = value;
    }
    get navigable() {
        return this._navigable;
    }
    /**
     * Specifies the padding of all Pager elements.
     *
     * @default 'medium'
     */
    set size(size) {
        const newSize = size ? size : DEFAULT_SIZE;
        this.handleClasses(newSize, 'size');
        this._size = newSize;
    }
    get size() {
        return this._size;
    }
    /**
     * Determines whether the Pager responsive functionality is enabled ([see example](slug:responsive_pager)).
     *
     * @default true
     */
    responsive = true;
    /**
     * Determines whether the Pager adaptiveness functionality is enabled ([see example](slug:adaptive_mode_pager)).
     *
     * @default 'none'
     */
    adaptiveMode = 'none';
    /**
     * Fires when the current page of the Pager changes ([see example](slug:overview_pager)).
     * You have to handle the event and page the data.
     */
    pageChange = new EventEmitter();
    /**
     * Fires when the page size of the Pager changes.
     * You have to handle the event and page the data.
     * If the event is prevented, the page size remains unchanged ([see example]({% slug pager_events %})).
     */
    pageSizeChange = new EventEmitter();
    /**
     * @hidden
     */
    pagerInputVisibilityChange = new EventEmitter();
    /**
     * @hidden
     */
    pageTextVisibilityChange = new EventEmitter();
    /**
     * @hidden
     */
    itemsTextVisibilityChange = new EventEmitter();
    pagerClass = true;
    get responsiveClass() {
        return this.responsive;
    }
    widgetRole = 'application';
    roleDescription = 'pager';
    keyShortcuts = 'Enter ArrowRight ArrowLeft';
    get hostTabindex() {
        return this.navigable ? '0' : '-1';
    }
    get dir() {
        return this.direction;
    }
    /**
     * @hidden
     */
    focusHandler(ev) {
        const isInnerNavigationEnabled = ev.target !== this.element.nativeElement;
        this.navigationService.toggleInnerNavigation(isInnerNavigationEnabled);
    }
    get totalPages() {
        return Math.ceil((this.total || 0) / this.pageSize);
    }
    get currentPage() {
        return Math.floor((this.skip || 0) / this.pageSize) + 1;
    }
    get templateContext() {
        const context = this._templateContext;
        context.totalPages = this.totalPages;
        context.total = this.total;
        context.skip = this.skip;
        context.pageSize = this.pageSize;
        context.currentPage = this.currentPage;
        return context;
    }
    /**
     * @hidden
     */
    get showPageText() {
        return this._showPageText;
    }
    set showPageText(value) {
        this._showPageText = value;
        if (this.pagerInputComponent) {
            this.pagerInputComponent.showPageText = value;
        }
        this.pageTextVisibilityChange.emit(value);
    }
    /**
     * @hidden
     */
    get showItemsText() {
        return this._showItemsText;
    }
    set showItemsText(value) {
        this._showItemsText = value;
        if (this.pageSizesComponent) {
            this.pageSizesComponent.showItemsText = value;
        }
        this.itemsTextVisibilityChange.emit(value);
    }
    /**
     * @hidden
     */
    get showInput() {
        return this._showInput;
    }
    set showInput(value) {
        this._showInput = value;
        this.pagerInputVisibilityChange.emit(value);
    }
    /**
     * @hidden
     */
    initialized = false;
    subscriptions = new Subscription();
    _templateContext = {};
    _pageSizeValues = DEFAULT_PAGE_SIZE_VALUES;
    direction;
    isInnerNavigationEnabled = false;
    _navigable = true;
    _size = DEFAULT_SIZE;
    _showInput = true;
    _showPageText = true;
    _showItemsText = true;
    _isAllSelected = false;
    /**
     * Stores the measurements of various Pager elements.
     * These dimensions are used for responsive layout calculations.
     * @hidden
     */
    pagerDimensions = {
        padding: 0,
        numericButtonsWidth: 0,
        inputWidth: 0,
        pageSizesWidth: 0,
        sizesTextWidth: 0,
        pageTextWidth: 0,
        infoTextWidth: 0,
        gapNumbersSizes: 0,
        gapSizesInfo: 0,
        gapPageText: 0,
        width: 0
    };
    constructor(pagerContext, element, localization, renderer, ngZone, cdr, navigationService) {
        this.pagerContext = pagerContext;
        this.element = element;
        this.localization = localization;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.cdr = cdr;
        this.navigationService = navigationService;
        validatePackage(packageMetadata);
        this.direction = localization.rtl ? 'rtl' : 'ltr';
        if (!navigationService) {
            this.navigationService = inject(PagerNavigationService);
        }
        if (!pagerContext) {
            this.pagerContext = inject(PagerContextService);
        }
        this.pagerContext.localization = localization;
    }
    ngOnInit() {
        this.subscriptions.add(this.pagerContext.pageChange.subscribe(this.changePage.bind(this)));
        this.subscriptions.add(this.pagerContext.pageSizeChange.subscribe(this.changePageSize.bind(this)));
        this.subscriptions.add(this.localization.changes.subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
            this.measureAllTextWidths();
            if (this.responsive) {
                this.resizeHandler();
            }
        }));
        this.subscriptions.add(this.navigationService.innerNavigationChange.subscribe(this.innerNavigationChange.bind(this)));
        if (this.navigable) {
            const wrapper = this.element.nativeElement;
            this.ngZone.runOutsideAngular(() => {
                this.subscriptions.add(this.renderer.listen(wrapper, 'keydown', this.keyDownHandler.bind(this)));
            });
        }
    }
    /**
     * Gets the maximum number of items displayed on the current page.
     */
    get maxItems() {
        return Math.min(this.currentPage * this.pageSize, this.total);
    }
    ngAfterViewInit() {
        this.renderer.setAttribute(this.element.nativeElement, 'aria-label', this.ariaLabel);
        this.subscriptions.add(this.template.changes.subscribe(() => {
            this.measureAllTextWidths();
            if (this.responsive) {
                this.resizeHandler(false);
            }
        }));
        this.handleClasses(this.size, 'size');
        this.setPagerDimensions();
        this.ngZone.onStable.pipe(take(1)).subscribe(() => {
            if (this.type !== 'input') {
                this.showInput = false;
            }
            this.responsive && this.resizeHandler();
        });
        if (!isDocumentAvailable()) {
            this.initialized = true;
            return;
        }
        this.ngZone.runOutsideAngular(() => {
            setTimeout(() => {
                this.initialized = true;
                this.cdr.markForCheck();
            }, 0);
        });
    }
    ngOnChanges(changes) {
        if (anyChanged(["pageSize", "skip", "total"], changes, false)) {
            const previousTotal = changes['total']?.previousValue;
            const currentTotal = this.total;
            let pageSizeAdjusted = false;
            if (this._isAllSelected && previousTotal && currentTotal !== previousTotal && this.pageSize === previousTotal) {
                this.pageSize = currentTotal;
                pageSizeAdjusted = true;
            }
            const previousButtonCount = Math.min(this.buttonCount, (changes['total']?.previousValue || this.total) / (changes['pageSize']?.previousValue || this.pageSize));
            this.pagerContext.notifyChanges({
                pageSize: this.pageSize,
                skip: this.skip,
                total: this.total,
                isAllSelected: this._isAllSelected
            });
            this.pagerDimensions.numericButtonsWidth = (this.pagerDimensions.numericButtonsWidth * Math.min(this.buttonCount, this.total / this.pageSize)) / previousButtonCount;
            this.renderer.setAttribute(this.element.nativeElement, 'aria-label', this.ariaLabel);
            if (this.responsive) {
                this.resizeHandler(false);
            }
            if (pageSizeAdjusted) {
                Promise.resolve().then(() => {
                    this.pageChange.emit({ skip: this.skip, take: currentTotal });
                    this.cdr.detectChanges();
                });
            }
        }
        if (anyChanged(["pageSizeValues", "previousNext", "buttonCount"], changes, true)) {
            if (this.responsive) {
                this.resizeHandler(false);
            }
        }
        if (isChanged('responsive', changes, true)) {
            if (changes['responsive'].currentValue && !changes['responsive'].previousValue) {
                this.measureAllTextWidths();
                this.resizeHandler(false);
            }
            if (!this.responsive) {
                this.showInput = this.type === 'input';
                this.showElements(this.element.nativeElement.offsetWidth, this.pagerDimensions.width);
            }
        }
        if (isChanged('type', changes, true)) {
            this.showNumericButtonsResponsive();
            if (this.responsive) {
                this.resizeHandler(false);
            }
        }
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    /**
     * @hidden
     */
    changePage(event) {
        this.pageChange.emit(event);
    }
    /**
     * @hidden
     */
    changePageSize(event) {
        this.pageSizeChange.emit(event);
        if (!event.isDefaultPrevented()) {
            if (event.newPageSize === 'all') {
                this._isAllSelected = true;
                this.pageChange.emit({ skip: 0, take: this.total });
            }
            else {
                this._isAllSelected = false;
                this.pageChange.emit({ skip: 0, take: event.newPageSize });
            }
        }
    }
    /**
     * @hidden
     */
    onPageSizeChange(event) {
        this.pageSizeChange.emit(event);
        if (!event.isDefaultPrevented()) {
            this.pageChange.emit({ skip: this.skip, take: event.newPageSize });
        }
    }
    /**
     * @hidden
     */
    resizeHandler = (compareWidth = true) => {
        if (this.template?.first && !this.responsive) {
            return;
        }
        if (!isDocumentAvailable() || !this.element?.nativeElement) {
            this.initialized = true;
            return;
        }
        let pagerWidth = this.element.nativeElement.offsetWidth;
        if (pagerWidth <= 0) {
            return;
        }
        if (compareWidth && pagerWidth === this.pagerDimensions.width) {
            return;
        }
        else {
            this.pagerDimensions.width = pagerWidth;
        }
        this.ngZone.runOutsideAngular(() => {
            setTimeout(() => {
                if (this.template?.first && !this.responsive) {
                    return;
                }
                const numericButtonsWrapperElement = this.element.nativeElement.querySelector('.k-pager-numbers-wrap');
                const pagerInfoElement = this.pagerInfoElement();
                const pagerPageSizes = this.sizesDropDownElement();
                let elementsWidths = numericButtonsWrapperElement?.offsetWidth + (pagerPageSizes?.offsetWidth || 0) + (pagerInfoElement?.offsetWidth > 0 ? Math.min(this.pagerDimensions.infoTextWidth) : 0);
                if (this.isElementVisible(pagerInfoElement)) {
                    elementsWidths += this.pagerDimensions.gapSizesInfo;
                }
                pagerWidth -= this.pagerDimensions.padding;
                if (this.isElementVisible(pagerPageSizes)) {
                    pagerWidth -= this.pagerDimensions.gapNumbersSizes;
                }
                if (pagerWidth < 0) {
                    return;
                }
                this.showElements(pagerWidth, elementsWidths);
                if (!this.initialized) {
                    this.ngZone.onStable.pipe(take(1)).subscribe(() => this.initialized = true);
                }
            });
        });
    };
    // use selectors to get the element even when used in a template
    sizesDropDownElement = () => this.element.nativeElement.querySelector('.k-pager-sizes');
    pagerInputElement = () => this.element.nativeElement.querySelector('.k-pager-input');
    pagerInfoElement = () => this.element.nativeElement.querySelector('.k-pager-info');
    numericButtonsElement = () => this.element.nativeElement.querySelector('kendo-datapager-numeric-buttons, kendo-pager-numeric-buttons');
    responsiveDropDownElement = {
        name: 'sizeDropDown',
        isEnabled: () => this.showPageSizes,
        isVisible: () => this.isElementVisible(this.sizesDropDownElement()),
        width: () => this.pagerDimensions.pageSizesWidth + this.pagerDimensions.gapNumbersSizes - this.pagerDimensions.sizesTextWidth,
        show: () => {
            this.ngZone.run(() => this.showItemsText = false);
            this.showElement(this.sizesDropDownElement());
        },
        hide: () => {
            this.hideElement(this.sizesDropDownElement());
        }
    };
    responsiveDropDownTextElement = {
        name: 'itemsDropDownText',
        isEnabled: () => this.showPageSizes,
        isVisible: () => this.isElementVisible(this.sizesDropDownElement()) && this.showItemsText,
        width: () => this.pagerDimensions.sizesTextWidth + this.pagerDimensions.gapPageText,
        show: () => this.ngZone.run(() => this.showItemsText = true),
        hide: () => this.ngZone.run(() => this.showItemsText = false)
    };
    responsivePageTextElement = {
        name: 'pageText',
        isEnabled: () => this.isElementVisible(this.pagerInputElement()),
        isVisible: () => this.showPageText,
        width: () => this.pagerDimensions.pageTextWidth + this.pagerDimensions.gapPageText,
        show: () => this.ngZone.run(() => this.showPageText = true),
        hide: () => this.ngZone.run(() => this.showPageText = false)
    };
    responsiveInfoTextElement = {
        name: 'infoText',
        isEnabled: () => this.info,
        isVisible: () => this.isElementVisible(this.pagerInfoElement()),
        width: () => this.pagerDimensions.infoTextWidth + this.pagerDimensions.gapSizesInfo,
        show: () => {
            this.ngZone.run(() => {
                this.showElement(this.pagerInfoElement());
            });
        },
        hide: () => {
            this.ngZone.run(() => {
                this.hideElement(this.pagerInfoElement());
            });
        }
    };
    responsiveNumericButtonsElement = {
        name: 'numericButtons',
        isEnabled: () => this.type === 'numeric',
        isVisible: () => this.isElementVisible(this.numericButtonsElement()),
        width: () => this.pagerDimensions.numericButtonsWidth - this.pagerDimensions.inputWidth,
        show: () => {
            this.showElement(this.numericButtonsElement());
            this.ngZone.run(() => {
                this.showInput = false;
                this.cdr.markForCheck();
            });
        },
        hide: () => {
            this.hideElement(this.numericButtonsElement());
            this.ngZone.run(() => {
                this.showInput = true;
                this.showPageText = true;
                this.cdr.markForCheck();
            });
        }
    };
    /**
     * Contains all elements that are subject to responsive toggling.
     * These elements will be shown or hidden based on the available space.
     * The order of elements in the array defines the priority of visibility.
     * This array allows us to work with the elements without performing element-specific logic in other methods.
     */
    responsiveElements = [
        this.responsiveDropDownElement,
        this.responsiveDropDownTextElement,
        this.responsivePageTextElement,
        this.responsiveInfoTextElement,
        this.responsiveNumericButtonsElement
    ];
    get ariaLabel() {
        const localizationMsg = this.localization.get('ariaLabel') || '';
        return replaceMessagePlaceholder(replaceMessagePlaceholder(localizationMsg, 'currentPage', this.currentPage.toString()), 'totalPages', this.totalPages.toString());
    }
    keyDownHandler(e) {
        const target = e.target;
        const wrapper = this.element.nativeElement;
        // on some keyboards arrow keys, PageUp/Down, and Home/End are mapped to Numpad keys
        const code = normalizeKeys(e);
        const isArrowLeftOrPageUp = code === Keys.ArrowLeft || code === Keys.PageUp;
        const isArrowRightOrPageDown = code === Keys.ArrowRight || code === Keys.PageDown;
        const isEnter = code === Keys.Enter || code === Keys.NumpadEnter;
        const isHome = code === Keys.Home;
        const isEnd = code === Keys.End;
        const isEsc = code === Keys.Escape;
        const isTab = code === Keys.Tab;
        const isFirstPage = this.currentPage === 1;
        const isLastPage = this.currentPage === this.totalPages;
        this.ngZone.run(() => {
            if (isHome) {
                if (e.target !== wrapper) {
                    return;
                }
                e.preventDefault();
                if (!isFirstPage) {
                    this.pagerContext.changePage(0);
                }
            }
            else if (isEnd) {
                e.preventDefault();
                if (e.target !== wrapper) {
                    return;
                }
                if (!isLastPage) {
                    this.pagerContext.changePage(this.totalPages - 1);
                }
            }
            else if (this.isInnerNavigationEnabled) {
                if (isEsc) {
                    this.navigationService.toggleInnerNavigation(false);
                    wrapper.focus();
                }
                else if (isTab) {
                    this.navigationService.keepFocusWithinComponent(wrapper, target, e);
                }
            }
            else {
                if (e.target !== wrapper) {
                    return;
                }
                if (isArrowLeftOrPageUp) {
                    e.preventDefault();
                    if (!isFirstPage) {
                        this.pagerContext.prevPage();
                    }
                }
                else if (isArrowRightOrPageDown) {
                    e.preventDefault();
                    if (!isLastPage) {
                        this.pagerContext.nextPage();
                    }
                }
                else if (isEnter) {
                    e.preventDefault();
                    let [firstFocusable] = this.navigationService.getFirstAndLastFocusable(wrapper);
                    if (firstFocusable.getAttribute('aria-disabled') === 'true') {
                        firstFocusable = Array.from(getAllFocusableChildren(wrapper)).find((el) => !el.getAttribute('aria-disabled'));
                        const input = firstFocusable.querySelector('input');
                        if (input) {
                            firstFocusable = input;
                        }
                    }
                    this.navigationService.toggleInnerNavigation(true);
                    firstFocusable?.focus();
                }
            }
        });
    }
    innerNavigationChange(value) {
        this.isInnerNavigationEnabled = value;
    }
    handleClasses(value, input) {
        const elem = this.element.nativeElement;
        const classes = getStylingClasses('pager', input, this[input], value);
        if (classes.toRemove) {
            this.renderer.removeClass(elem, classes.toRemove);
        }
        if (classes.toAdd) {
            this.renderer.addClass(elem, classes.toAdd);
        }
    }
    showElements(availableWidth, currentWidth) {
        let index = 0;
        while (index < this.responsiveElements.length) {
            const element = this.responsiveElements[index];
            if (!element.isEnabled() || element.isVisible()) {
                index++;
                continue;
            }
            const elementWidth = element.width();
            // If not responsive, show all elements regardless of available width. If responsive, check if the current element fits
            if (this.responsive && (currentWidth + elementWidth) > availableWidth) {
                index++;
                break;
            }
            element.show();
            currentWidth += elementWidth;
            index++;
        }
        // Do not hide elements if not responsive. If all elements fit, do not hide any.
        if (!this.responsive || currentWidth <= availableWidth) {
            return;
        }
        let hideIndex = Math.min(index - 1, this.responsiveElements.length - 1);
        while (hideIndex >= 0 && currentWidth > availableWidth) {
            const element = this.responsiveElements[hideIndex];
            if (!element.isEnabled() || !element.isVisible()) {
                hideIndex--;
                continue;
            }
            const elementWidth = element.width();
            element.hide();
            currentWidth -= elementWidth;
            hideIndex--;
        }
    }
    isElementVisible(element) {
        return element && !element?.classList.contains('k-hidden');
    }
    hideElement(element) {
        if (element) {
            this.renderer.addClass(element, 'k-hidden');
        }
    }
    showElement(element) {
        if (element) {
            this.renderer.removeClass(element, 'k-hidden');
        }
    }
    measureAllTextWidths() {
        if (!isDocumentAvailable()) {
            return;
        }
        const existingInfo = this.pagerInfoElement();
        const existingInput = this.pagerInputElement();
        const existingSizes = this.sizesDropDownElement();
        // create a single measurement container
        const measureContainer = this.renderer.createElement('div');
        positionOffScreen(this.renderer, measureContainer);
        this.renderer.appendChild(this.element.nativeElement, measureContainer);
        const infoSpan = createMeasurementSpan(this.renderer, measureContainer, 'k-pager-info');
        const pageSpan = createMeasurementSpan(this.renderer, measureContainer, 'k-pager-input');
        const sizesSpan = createMeasurementSpan(this.renderer, measureContainer, 'k-pager-sizes');
        const infoText = `${this.currentPage} - ${this.maxItems} ${this.localization.get('of')} ${this.total} ${this.localization.get('items')}`;
        this.renderer.setProperty(infoSpan, 'textContent', infoText);
        this.renderer.setProperty(pageSpan, 'textContent', this.localization.get('page'));
        this.renderer.setProperty(sizesSpan, 'textContent', this.localization.get('itemsPerPage'));
        // copy computed styles if available
        if (existingInfo)
            copyComputedStyles(this.renderer, existingInfo, infoSpan);
        if (existingInput)
            copyComputedStyles(this.renderer, existingInput, pageSpan);
        if (existingSizes)
            copyComputedStyles(this.renderer, existingSizes, sizesSpan);
        // force a reflow to ensure measurements are accurate
        measureContainer.getBoundingClientRect();
        this.pagerDimensions.infoTextWidth = infoSpan?.offsetWidth;
        if (this.pagerDimensions.inputWidth && this.pagerDimensions.pageTextWidth) {
            this.pagerDimensions.inputWidth = this.pagerDimensions.inputWidth - this.pagerDimensions.pageTextWidth + pageSpan.offsetWidth;
        }
        this.pagerDimensions.pageTextWidth = pageSpan?.offsetWidth;
        if (this.pagerDimensions.pageSizesWidth && this.pagerDimensions.sizesTextWidth) {
            this.pagerDimensions.pageSizesWidth = this.pagerDimensions.pageSizesWidth - this.pagerDimensions.sizesTextWidth + sizesSpan.offsetWidth;
        }
        this.pagerDimensions.sizesTextWidth = sizesSpan?.offsetWidth;
        this.renderer.removeChild(this.element.nativeElement, measureContainer);
    }
    showNumericButtonsResponsive() {
        if (!isDocumentAvailable() || !this.element?.nativeElement) {
            return;
        }
        const numericButtonsElement = this.numericButtonsElement();
        const hasNumericButtons = this.numericButtons || numericButtonsElement;
        const hasInput = this.pagerInput || this.pagerInputElement();
        if (!this.responsive || (!hasNumericButtons && !hasInput)) {
            this.showInput = this.type === 'input';
            return;
        }
        const pagerInfoElement = this.pagerInfoElement();
        if (this.type === 'input' || !this.isElementVisible(pagerInfoElement)) {
            this.showInput = true;
            return;
        }
        if (this.isElementVisible(numericButtonsElement)) {
            this.showInput = false;
            return;
        }
        const pagerWidth = this.element.nativeElement?.offsetWidth;
        const numericButtonsWrapperElement = this.element.nativeElement.querySelector('.k-pager-numbers-wrap');
        const elementsWidths = numericButtonsWrapperElement?.offsetWidth + this.pagerDimensions.pageSizesWidth + this.pagerDimensions.infoTextWidth + this.pagerDimensions.gapSizesInfo;
        const hasAvailableWidth = pagerWidth > elementsWidths - this.pagerDimensions.inputWidth + this.pagerDimensions.numericButtonsWidth;
        this.showInput = !hasAvailableWidth;
    }
    get showPageSizes() {
        if (typeof this.pageSizeValues === 'boolean') {
            return this.pageSizeValues;
        }
        return this.pageSizeValues?.length > 0;
    }
    setPagerDimensions() {
        this.measureAllTextWidths();
        !this.numericButtons && (this.pagerDimensions.numericButtonsWidth = this.element.nativeElement.querySelector('.k-pager-numbers')?.offsetWidth ?? 0);
        !this.pagerInput && (this.pagerDimensions.inputWidth = this.element.nativeElement.querySelector('kendo-pager-input')?.offsetWidth ?? 0);
        !this.pageSizes && (this.pagerDimensions.pageSizesWidth = this.sizesDropDownElement()?.offsetWidth ?? 0);
        const padding = calculatePadding(this.element.nativeElement);
        this.pagerDimensions.padding = padding.padding;
        this.pagerDimensions.gapNumbersSizes = padding.gapNumbersSizes;
        this.pagerDimensions.gapSizesInfo = padding.gapSizesInfo;
        const innerStyledElement = this.pagerInputElement();
        !this.pagerDimensions.gapPageText && (this.pagerDimensions.gapPageText = calculateGap(innerStyledElement));
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PagerComponent, deps: [{ token: PagerContextService, optional: true, skipSelf: true }, { token: i0.ElementRef }, { token: i1.LocalizationService }, { token: i0.Renderer2 }, { token: i0.NgZone }, { token: i0.ChangeDetectorRef }, { token: PagerNavigationService, optional: true, skipSelf: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: PagerComponent, isStandalone: true, selector: "kendo-datapager, kendo-pager", inputs: { externalTemplate: "externalTemplate", total: "total", skip: "skip", pageSize: "pageSize", buttonCount: "buttonCount", info: "info", type: "type", pageSizeValues: "pageSizeValues", previousNext: "previousNext", navigable: "navigable", size: "size", responsive: "responsive", adaptiveMode: "adaptiveMode" }, outputs: { pageChange: "pageChange", pageSizeChange: "pageSizeChange", pagerInputVisibilityChange: "pagerInputVisibilityChange", pageTextVisibilityChange: "pageTextVisibilityChange", itemsTextVisibilityChange: "itemsTextVisibilityChange" }, host: { listeners: { "focusin": "focusHandler($event)" }, properties: { "class.k-pager": "this.pagerClass", "class.k-pager-responsive": "this.responsiveClass", "attr.role": "this.widgetRole", "attr.aria-roledescription": "this.roleDescription", "attr.aria-keyshortcuts": "this.keyShortcuts", "attr.tabindex": "this.hostTabindex", "attr.dir": "this.dir" } }, providers: [
            LocalizationService,
            PagerContextService,
            PagerNavigationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.pager'
            }
        ], queries: [{ propertyName: "template", predicate: PagerTemplateDirective }], viewQueries: [{ propertyName: "numericButtons", first: true, predicate: PagerNumericButtonsComponent, descendants: true, read: ElementRef }, { propertyName: "pagerInput", first: true, predicate: PagerInputComponent, descendants: true, read: ElementRef }, { propertyName: "pagerInputComponent", first: true, predicate: PagerInputComponent, descendants: true }, { propertyName: "pageSizes", first: true, predicate: PagerPageSizesComponent, descendants: true, read: ElementRef }, { propertyName: "pageSizesComponent", first: true, predicate: PagerPageSizesComponent, descendants: true }], exportAs: ["kendoDataPager", "kendoPager"], usesOnChanges: true, ngImport: i0, template: `
        <ng-container kendoPagerLocalizedMessages
          i18n-ariaLabel="kendo.pager.ariaLabel|The value of the aria-label attribute of the Pager"
          ariaLabel="{{ 'Page navigation, page {currentPage} of {totalPages}' }}"
        
          i18n-firstPage="kendo.pager.firstPage|The label for the first page button in the Pager"
          firstPage="Go to the first page"
        
          i18n-previousPage="kendo.pager.previousPage|The label for the previous page button in the Pager"
          previousPage="Go to the previous page"
        
          i18n-nextPage="kendo.pager.nextPage|The label for the next page button in the Pager"
          nextPage="Go to the next page"
        
          i18n-lastPage="kendo.pager.lastPage|The label for the last page button in the Pager"
          lastPage="Go to the last page"
        
          i18n-page="kendo.pager.page|The label before the current page number in the Pager"
          page="Page"
        
          i18n-of="kendo.pager.of|The label before the total pages number in the Pager"
          of="of"
        
          i18n-pageNumberInputTitle="kendo.pager.pageNumberInputTitle|The label for the pager input in the Pager"
          pageNumberInputTitle="Page Number"
        
          i18n-items="kendo.pager.items|The label after the total pages number in the Pager"
          items="items"
        
          i18n-itemsPerPage="kendo.pager.itemsPerPage|The label for the page size chooser in the Pager"
          itemsPerPage="items per page"
        
          i18n-selectPage="kendo.pager.selectPage|The text of the title and aria-label attributes applied to the page chooser in the Pager"
          selectPage="Select page"
        
          i18n-inputLabel="kendo.pager.inputLabel|The text of the aria-label attribute applied to the input element for entering the page number."
          inputLabel="Type a page number"
          >
        </ng-container>
        @if (template.first?.templateRef) {
          <ng-container
            [ngTemplateOutlet]="template.first?.templateRef"
            [ngTemplateOutletContext]="templateContext">
          </ng-container>
        } @else {
          <div class="k-pager-numbers-wrap" [ngStyle]="{opacity: initialized ? null : '0'}">
            @if (previousNext) {
              <kendo-pager-prev-buttons [size]="size"></kendo-pager-prev-buttons>
            }
            @if (type === 'numeric' && buttonCount > 0) {
              <kendo-pager-numeric-buttons
                [size]="size"
                [buttonCount]="buttonCount">
              </kendo-pager-numeric-buttons>
            }
            @if (showInput) {
              <kendo-pager-input [size]="size"></kendo-pager-input>
            }
            @if (previousNext) {
              <kendo-pager-next-buttons [size]="size"></kendo-pager-next-buttons>
            }
          </div>
          @if (_pageSizeValues.length) {
            <kendo-pager-page-sizes
              [ngStyle]="{opacity: initialized ? null : '0'}"
              [size]="size"
              [pageSizes]="_pageSizeValues"
              [adaptiveMode]="adaptiveMode">
            </kendo-pager-page-sizes>
          }
          @if (info) {
            <kendo-pager-info [ngStyle]="{opacity: initialized ? null : '0'}">
            </kendo-pager-info>
          }
        }
        @if (responsive) {
          <kendo-resize-sensor (resize)="resizeHandler()"></kendo-resize-sensor>
        }
        `, isInline: true, dependencies: [{ kind: "directive", type: LocalizedMessagesDirective, selector: "[kendoPagerLocalizedMessages]" }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: PagerPrevButtonsComponent, selector: "kendo-datapager-prev-buttons, kendo-pager-prev-buttons", inputs: ["size"] }, { kind: "component", type: PagerNumericButtonsComponent, selector: "kendo-datapager-numeric-buttons, kendo-pager-numeric-buttons", inputs: ["buttonCount", "size"] }, { kind: "component", type: PagerInputComponent, selector: "kendo-datapager-input, kendo-pager-input", inputs: ["showPageText", "size"] }, { kind: "component", type: PagerNextButtonsComponent, selector: "kendo-datapager-next-buttons, kendo-pager-next-buttons", inputs: ["size"] }, { kind: "component", type: PagerPageSizesComponent, selector: "kendo-datapager-page-sizes, kendo-pager-page-sizes", inputs: ["showItemsText", "pageSizes", "size", "adaptiveMode"] }, { kind: "component", type: PagerInfoComponent, selector: "kendo-datapager-info, kendo-pager-info" }, { kind: "component", type: ResizeSensorComponent, selector: "kendo-resize-sensor", inputs: ["rateLimit"], outputs: ["resize"] }, { kind: "directive", type: NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PagerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-datapager, kendo-pager',
                    exportAs: 'kendoDataPager, kendoPager',
                    providers: [
                        LocalizationService,
                        PagerContextService,
                        PagerNavigationService,
                        {
                            provide: L10N_PREFIX,
                            useValue: 'kendo.pager'
                        }
                    ],
                    template: `
        <ng-container kendoPagerLocalizedMessages
          i18n-ariaLabel="kendo.pager.ariaLabel|The value of the aria-label attribute of the Pager"
          ariaLabel="{{ 'Page navigation, page {currentPage} of {totalPages}' }}"
        
          i18n-firstPage="kendo.pager.firstPage|The label for the first page button in the Pager"
          firstPage="Go to the first page"
        
          i18n-previousPage="kendo.pager.previousPage|The label for the previous page button in the Pager"
          previousPage="Go to the previous page"
        
          i18n-nextPage="kendo.pager.nextPage|The label for the next page button in the Pager"
          nextPage="Go to the next page"
        
          i18n-lastPage="kendo.pager.lastPage|The label for the last page button in the Pager"
          lastPage="Go to the last page"
        
          i18n-page="kendo.pager.page|The label before the current page number in the Pager"
          page="Page"
        
          i18n-of="kendo.pager.of|The label before the total pages number in the Pager"
          of="of"
        
          i18n-pageNumberInputTitle="kendo.pager.pageNumberInputTitle|The label for the pager input in the Pager"
          pageNumberInputTitle="Page Number"
        
          i18n-items="kendo.pager.items|The label after the total pages number in the Pager"
          items="items"
        
          i18n-itemsPerPage="kendo.pager.itemsPerPage|The label for the page size chooser in the Pager"
          itemsPerPage="items per page"
        
          i18n-selectPage="kendo.pager.selectPage|The text of the title and aria-label attributes applied to the page chooser in the Pager"
          selectPage="Select page"
        
          i18n-inputLabel="kendo.pager.inputLabel|The text of the aria-label attribute applied to the input element for entering the page number."
          inputLabel="Type a page number"
          >
        </ng-container>
        @if (template.first?.templateRef) {
          <ng-container
            [ngTemplateOutlet]="template.first?.templateRef"
            [ngTemplateOutletContext]="templateContext">
          </ng-container>
        } @else {
          <div class="k-pager-numbers-wrap" [ngStyle]="{opacity: initialized ? null : '0'}">
            @if (previousNext) {
              <kendo-pager-prev-buttons [size]="size"></kendo-pager-prev-buttons>
            }
            @if (type === 'numeric' && buttonCount > 0) {
              <kendo-pager-numeric-buttons
                [size]="size"
                [buttonCount]="buttonCount">
              </kendo-pager-numeric-buttons>
            }
            @if (showInput) {
              <kendo-pager-input [size]="size"></kendo-pager-input>
            }
            @if (previousNext) {
              <kendo-pager-next-buttons [size]="size"></kendo-pager-next-buttons>
            }
          </div>
          @if (_pageSizeValues.length) {
            <kendo-pager-page-sizes
              [ngStyle]="{opacity: initialized ? null : '0'}"
              [size]="size"
              [pageSizes]="_pageSizeValues"
              [adaptiveMode]="adaptiveMode">
            </kendo-pager-page-sizes>
          }
          @if (info) {
            <kendo-pager-info [ngStyle]="{opacity: initialized ? null : '0'}">
            </kendo-pager-info>
          }
        }
        @if (responsive) {
          <kendo-resize-sensor (resize)="resizeHandler()"></kendo-resize-sensor>
        }
        `,
                    standalone: true,
                    imports: [LocalizedMessagesDirective, NgTemplateOutlet, PagerPrevButtonsComponent, PagerNumericButtonsComponent, PagerInputComponent, PagerNextButtonsComponent, PagerPageSizesComponent, PagerInfoComponent, ResizeSensorComponent, NgStyle]
                }]
        }], ctorParameters: () => [{ type: PagerContextService, decorators: [{
                    type: Optional
                }, {
                    type: SkipSelf
                }] }, { type: i0.ElementRef }, { type: i1.LocalizationService }, { type: i0.Renderer2 }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }, { type: PagerNavigationService, decorators: [{
                    type: Optional
                }, {
                    type: SkipSelf
                }] }], propDecorators: { template: [{
                type: ContentChildren,
                args: [PagerTemplateDirective]
            }], numericButtons: [{
                type: ViewChild,
                args: [PagerNumericButtonsComponent, { read: ElementRef }]
            }], pagerInput: [{
                type: ViewChild,
                args: [PagerInputComponent, { read: ElementRef }]
            }], pagerInputComponent: [{
                type: ViewChild,
                args: [PagerInputComponent]
            }], pageSizes: [{
                type: ViewChild,
                args: [PagerPageSizesComponent, { read: ElementRef }]
            }], pageSizesComponent: [{
                type: ViewChild,
                args: [PagerPageSizesComponent]
            }], externalTemplate: [{
                type: Input
            }], total: [{
                type: Input
            }], skip: [{
                type: Input
            }], pageSize: [{
                type: Input
            }], buttonCount: [{
                type: Input
            }], info: [{
                type: Input
            }], type: [{
                type: Input
            }], pageSizeValues: [{
                type: Input
            }], previousNext: [{
                type: Input
            }], navigable: [{
                type: Input
            }], size: [{
                type: Input
            }], responsive: [{
                type: Input
            }], adaptiveMode: [{
                type: Input
            }], pageChange: [{
                type: Output
            }], pageSizeChange: [{
                type: Output
            }], pagerInputVisibilityChange: [{
                type: Output
            }], pageTextVisibilityChange: [{
                type: Output
            }], itemsTextVisibilityChange: [{
                type: Output
            }], pagerClass: [{
                type: HostBinding,
                args: ['class.k-pager']
            }], responsiveClass: [{
                type: HostBinding,
                args: ['class.k-pager-responsive']
            }], widgetRole: [{
                type: HostBinding,
                args: ['attr.role']
            }], roleDescription: [{
                type: HostBinding,
                args: ['attr.aria-roledescription']
            }], keyShortcuts: [{
                type: HostBinding,
                args: ['attr.aria-keyshortcuts']
            }], hostTabindex: [{
                type: HostBinding,
                args: ['attr.tabindex']
            }], dir: [{
                type: HostBinding,
                args: ['attr.dir']
            }], focusHandler: [{
                type: HostListener,
                args: ['focusin', ['$event']]
            }] } });

/**
 * Represents the Kendo UI Pager Spacer component for Angular.
 * Gives you additional white space between the Pager inner elements,
 * and provides a way for customizing the spacer width.
 *
 * @example
 * ```html
 * <kendo-pager [skip]="skip" [pageSize]="pageSize" [total]="total">
 *   <ng-template kendoPagerTemplate>
 *     <kendo-pager-prev-buttons></kendo-pager-prev-buttons>
 *     <kendo-pager-info></kendo-pager-info>
 *     <kendo-pager-spacer></kendo-pager-spacer>
 *     <kendo-pager-next-buttons></kendo-pager-next-buttons>
 *   </ng-template>
 * </kendo-pager>
 * ```
 */
class PagerSpacerComponent {
    /**
     * Gets the CSS class for the spacer.
     */
    hostClass = true;
    /**
     * Gets the CSS class for sized spacers.
     */
    get sizedClass() {
        return isPresent(this.width);
    }
    /**
     * Gets the flex-basis style for the spacer width.
     */
    get flexBasisStyle() {
        return this.width;
    }
    /**
     * Specifies the width of the `PagerSpacer` component.
     * Accepts the [string values of the CSS `flex-basis` property](https://developer.mozilla.org/en-US/docs/Web/CSS/flex-basis).
     *
     * If you do not set this property, the `PagerSpacer` takes all the available space.
     */
    width;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PagerSpacerComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: PagerSpacerComponent, isStandalone: true, selector: "kendo-pager-spacer", inputs: { width: "width" }, host: { properties: { "class.k-spacer": "this.hostClass", "class.k-spacer-sized": "this.sizedClass", "style.flexBasis": "this.flexBasisStyle" } }, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PagerSpacerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-pager-spacer',
                    template: ``,
                    standalone: true
                }]
        }], propDecorators: { hostClass: [{
                type: HostBinding,
                args: ['class.k-spacer']
            }], sizedClass: [{
                type: HostBinding,
                args: ['class.k-spacer-sized']
            }], flexBasisStyle: [{
                type: HostBinding,
                args: ['style.flexBasis']
            }], width: [{
                type: Input
            }] } });

/**
 * Use this utility array to access all `@progress/kendo-angular-pager`-related components and directives in a standalone Angular component.
 *
 * @example
 * ```typescript
 * import { Component } from '@angular/core';
 * import { KENDO_PAGER } from '@progress/kendo-angular-pager';
 *
 * @Component({
 *   selector: 'my-app',
 *   standalone: true,
 *   imports: [KENDO_PAGER],
 *   template: `<kendo-pager></kendo-pager>`
 * })
 * export class AppComponent {}
 * ```
 */
const KENDO_PAGER = [
    CustomMessagesComponent,
    PagerFocusableDirective,
    PagerInfoComponent,
    PagerInputComponent,
    PagerNextButtonsComponent,
    PagerNumericButtonsComponent,
    PagerPageSizesComponent,
    PagerPrevButtonsComponent,
    PagerTemplateDirective,
    PagerComponent,
    PagerSpacerComponent
];

//IMPORTANT: NgModule export kept for backwards compatibility
/**
 * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi'])
 * definition for the Pager component. Imports `PagerModule` into the
 * [root module](link:site.data.urls.angular['ngmodules']#angular-modularity)
 * of your application or into any other sub-module that will use the Pager component.
 *
 * @example
 * ```ts-no-run
 * import { NgModule } from '@angular/core';
 * import { BrowserModule } from '@angular/platform-browser';
 * import { PagerModule } from '@progress/kendo-angular-pager';
 * import { AppComponent } from './app.component';
 *
 * _@NgModule({
 *     bootstrap:    [AppComponent],
 *     declarations: [AppComponent],
 *     imports:      [BrowserModule, PagerModule]
 * })
 * export class AppModule {
 * }
 * ```
 */
class PagerModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PagerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.18", ngImport: i0, type: PagerModule, imports: [CustomMessagesComponent, PagerFocusableDirective, PagerInfoComponent, PagerInputComponent, PagerNextButtonsComponent, PagerNumericButtonsComponent, PagerPageSizesComponent, PagerPrevButtonsComponent, PagerTemplateDirective, PagerComponent, PagerSpacerComponent], exports: [CustomMessagesComponent, PagerFocusableDirective, PagerInfoComponent, PagerInputComponent, PagerNextButtonsComponent, PagerNumericButtonsComponent, PagerPageSizesComponent, PagerPrevButtonsComponent, PagerTemplateDirective, PagerComponent, PagerSpacerComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PagerModule, providers: [
            IconsService,
            PopupService,
            ResizeBatchService
        ], imports: [PagerInputComponent, PagerNextButtonsComponent, PagerNumericButtonsComponent, PagerPageSizesComponent, PagerPrevButtonsComponent, PagerComponent] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: PagerModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [...KENDO_PAGER],
                    imports: [...KENDO_PAGER],
                    providers: [
                        IconsService,
                        PopupService,
                        ResizeBatchService
                    ]
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { CustomMessagesComponent, KENDO_PAGER, LocalizedMessagesDirective, PageSizeChangeEvent, PagerComponent, PagerContextService, PagerFocusableDirective, PagerInfoComponent, PagerInputComponent, PagerModule, PagerNavigationService, PagerNextButtonsComponent, PagerNumericButtonsComponent, PagerPageSizesComponent, PagerPrevButtonsComponent, PagerSpacerComponent, PagerTemplateDirective };

