/**-----------------------------------------------------------------------------------------
* Copyright © 2026 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import * as i0 from '@angular/core';
import { EventEmitter, Injectable, inject, ElementRef, Input, ViewChild, Directive, Output, forwardRef, HostBinding, Component, ViewContainerRef, HostListener, ContentChildren, isDevMode, ViewChildren, NgModule } from '@angular/core';
import * as i2 from '@progress/kendo-angular-popup';
import { PopupService } from '@progress/kendo-angular-popup';
import { normalizeKeys, Keys, isPresent as isPresent$1, isDocumentAvailable, guid, parseCSSClassNames, ResizeSensorComponent, ResizeBatchService } from '@progress/kendo-angular-common';
import * as i1 from '@progress/kendo-angular-l10n';
import { ComponentMessages, LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';
import { validatePackage } from '@progress/kendo-licensing';
import { take, filter, takeUntil } from 'rxjs/operators';
import { Subject, Subscription, merge, fromEvent } from 'rxjs';
import { caretAltLeftIcon, caretAltRightIcon, moreHorizontalIcon, moreVerticalIcon, caretAltDownIcon } from '@progress/kendo-svg-icons';
import { ButtonComponent, ButtonGroupComponent, DropDownButtonComponent, SplitButtonComponent } from '@progress/kendo-angular-buttons';
import { NgTemplateOutlet, NgClass, NgStyle } from '@angular/common';
import { IconWrapperComponent, IconsService } from '@progress/kendo-angular-icons';
import { BadgeComponent, BadgeContainerComponent } from '@progress/kendo-angular-indicators';

/**
 * @hidden
 */
const packageMetadata = {
    name: '@progress/kendo-angular-toolbar',
    productName: 'Kendo UI for Angular',
    productCode: 'KENDOUIANGULAR',
    productCodes: ['KENDOUIANGULAR'],
    publishDate: 0,
    version: '22.0.1',
    licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/'
};

/**
 * @hidden
 */
class RefreshService {
    onRefresh = new EventEmitter();
    refresh(tool) {
        this.onRefresh.emit(tool);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: RefreshService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: RefreshService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: RefreshService, decorators: [{
            type: Injectable
        }] });

/**
 * @hidden
 */
const focusableRegex = /^(?:a|input|select|textarea|button|object)$/i;
/**
 * @hidden
 */
function outerWidth(element) {
    let width = element.offsetWidth;
    const style = getComputedStyle(element);
    width += parseFloat(style.marginLeft) || 0 + parseFloat(style.marginRight) || 0;
    return width;
}
/**
 * @hidden
 */
function innerWidth(element) {
    let width = element.offsetWidth;
    const style = getComputedStyle(element);
    width -= parseFloat(style.paddingLeft) || 0 + parseFloat(style.borderLeftWidth) || 0;
    width -= parseFloat(style.paddingRight) || 0 + parseFloat(style.borderRightWidth) || 0;
    return width;
}
/**
 * @hidden
 */
function outerHeight(element) {
    let width = element.offsetHeight;
    const style = getComputedStyle(element);
    width += parseFloat(style.marginTop) || 0 + parseFloat(style.marginBottom) || 0;
    return width;
}
/**
 * @hidden
 */
const closest = (node, predicate) => {
    while (node && !predicate(node)) {
        node = node.parentNode;
    }
    return node;
};
/**
 * @hidden
 */
const isVisible = (element) => {
    const rect = element.getBoundingClientRect();
    const hasSize = rect.width > 0 && rect.height > 0;
    const hasPosition = rect.x !== 0 && rect.y !== 0;
    // Elements can have zero size due to styling, but they should still count as visible.
    // For example, the selection checkbox has no size, but is made visible through styling.
    return (hasSize || hasPosition) && window.getComputedStyle(element).visibility !== 'hidden';
};
/**
 * @hidden
 */
const findElement = (node, predicate, matchSelf = true) => {
    if (!node) {
        return;
    }
    if (matchSelf && predicate(node)) {
        return node;
    }
    node = node.firstChild;
    while (node) {
        if (node.nodeType === 1) {
            const element = findElement(node, predicate);
            if (element) {
                return element;
            }
        }
        node = node.nextSibling;
    }
};
/**
 * @hidden
 */
const isFocusable = (element, checkVisibility = true) => {
    if (element.tagName) {
        const tagName = element.tagName.toLowerCase();
        const tabIndex = element.getAttribute('tabIndex');
        let focusable = tabIndex !== null;
        if (focusableRegex.test(tagName)) {
            focusable = !element.disabled;
        }
        return focusable && (!checkVisibility || isVisible(element));
    }
    return false;
};
/**
 * @hidden
 */
const findFocusable = (element, checkVisibility = true) => {
    return findElement(element, node => isFocusable(node, checkVisibility));
};
/**
 * @hidden
 */
const findFocusableChild = (element, checkVisibility = true) => {
    return findElement(element, node => isFocusable(node, checkVisibility), false);
};
/**
 * @hidden
 */
const findFocusableSibling = (element, checkVisibility = true, reverse) => {
    let node = reverse ? element.prevSibling : element.nextSibling;
    while (node) {
        if (node.nodeType === 1) {
            const result = findElement(node, el => isFocusable(el, checkVisibility));
            if (result) {
                return result;
            }
        }
        node = reverse ? node.prevSibling : node.nextSibling;
    }
};
/**
 * @hidden
 */
const isPresent = (value) => value !== null && value !== undefined;
/**
 * @hidden
 */
const makePeeker = (collection) => (index) => isPresent(collection[index]);
/**
 * @hidden
 */
const getIndexOfFocused = (prevKeyCode, nextKeyCode, collection) => (ev) => {
    const code = normalizeKeys(ev);
    switch (ev.type) {
        case 'keydown':
            if (code === prevKeyCode) {
                return collection.length - 1;
            }
            if (code === nextKeyCode) {
                return 0;
            }
            break;
        case 'click':
            return collection.findIndex(be => be === ev.target || be.contains(ev.target));
        case 'focus':
            return 0;
        default:
            return 0;
    }
};
/**
 * @hidden
 */
const seekFocusedIndex = (prevKeyCode, nextKeyCode, seeker) => (startIndex, ev) => {
    const code = normalizeKeys(ev);
    switch (code) {
        case prevKeyCode:
            return seeker(startIndex - 1) ? startIndex - 1 : startIndex;
        case nextKeyCode:
            return seeker(startIndex + 1) ? startIndex + 1 : startIndex;
        default:
            return startIndex;
    }
};
/**
 * @hidden
 */
const areEqual = (first) => (second) => first === second;
/**
 * @hidden
 */
const getNextKey = (rtl = false) => (overflows = true) => overflows ? Keys.ArrowDown : rtl ? Keys.ArrowLeft : Keys.ArrowRight;
/**
 * @hidden
 */
const getPrevKey = (rtl = false) => (overflows = true) => overflows ? Keys.ArrowUp : rtl ? Keys.ArrowRight : Keys.ArrowLeft;
/**
 * @hidden
 */
const getValueForLocation = (property, displayMode, overflows) => {
    switch (displayMode) {
        case 'toolbar':
            return overflows ? undefined : property;
        case 'menu':
            return overflows ? property : undefined;
        case 'never':
            return;
        default:
            return property;
    }
};
/**
 * @hidden
 */
const SIZES = {
    small: 'sm',
    medium: 'md',
    large: 'lg'
};
/**
 * @hidden
 *
 * Returns the styling classes to be added and removed
 */
const getStylingClasses = (componentType, stylingOption, previousValue, newValue) => {
    switch (stylingOption) {
        case 'size':
            return {
                toRemove: `k-${componentType}-${SIZES[previousValue]}`,
                toAdd: newValue !== 'none' ? `k-${componentType}-${SIZES[newValue]}` : ''
            };
        case 'fillMode':
            return {
                toRemove: `k-${componentType}-${previousValue}`,
                toAdd: newValue !== 'none' ? `k-${componentType}-${newValue}` : ''
            };
        default:
            break;
    }
};
/**
 * @hidden
 *
 * Checks whether a Node is Text or Element node.
 * nodeType 1 is Element, nodeType 3 is Text
 */
const isElementOrTextNode = n => n.nodeType === 1 || n.nodeType === 3;
/**
 * @hidden
 */
const normalizeOverflowSettings = (overflow) => {
    const defaultOverflowSettings = { mode: 'none', scrollButtons: 'auto', scrollButtonsPosition: 'split' };
    let normalizedSettings = {};
    if (typeof overflow === 'object') {
        normalizedSettings = Object.assign(defaultOverflowSettings, overflow);
    }
    else if (typeof overflow === 'boolean') {
        normalizedSettings = overflow ? Object.assign(defaultOverflowSettings, { mode: 'menu' }) : defaultOverflowSettings;
    }
    else {
        normalizedSettings = Object.assign(defaultOverflowSettings, { mode: overflow });
    }
    return normalizedSettings;
};

/**
 * @hidden
 */
class NavigationService {
    zone;
    overflowButton;
    focused = { renderedTool: null, index: -1 };
    renderedTools = [];
    isPopupFocused = false;
    isOverflowButtonFocused = false;
    constructor(zone) {
        this.zone = zone;
    }
    setRenderedTools(rts) {
        this.renderedTools = rts;
    }
    click({ context, event: ev }) {
        if (this.focused.renderedTool !== context && ev) {
            this.focus(context, ev);
        }
    }
    moveFocusToToolBar() {
        this.isPopupFocused = false;
        this.focusOverflowButton();
    }
    moveFocusToPopup() {
        this.isPopupFocused = true;
        this.resetNavigation();
        this.focus();
    }
    focusNext(ev) {
        if (this.isOverflowButtonFocused) {
            const firstFocusableRT = this.getFocusableTools()[0];
            this.focus(firstFocusableRT, ev);
        }
        else if (!this.isOverflowButtonFocused && this.focused.renderedTool && !this.focused.renderedTool.tool.handleKey(ev)) {
            const nextRT = this.getFocusableTools().slice(this.focused.index + 1)[0];
            if (nextRT) {
                this.focus(nextRT, ev);
            }
            else {
                if (this.isOverflowButtonVisible() && !this.isPopupFocused) {
                    this.focusOverflowButton();
                }
                else {
                    const firstRT = this.getFocusableTools()[0];
                    this.focus(firstRT, ev);
                }
            }
        }
    }
    focusPrev(ev) {
        if (this.isOverflowButtonFocused) {
            const lastFocusableRT = this.getFocusableTools().reverse()[0];
            this.focus(lastFocusableRT, ev);
        }
        else if (!this.isOverflowButtonFocused && this.focused.renderedTool && !this.focused.renderedTool.tool.handleKey(ev)) {
            const prevRT = this.getFocusableTools()
                .slice(0, this.focused.index)
                .reverse()[0];
            if (prevRT) {
                this.focus(prevRT, ev);
            }
            else {
                if (this.isOverflowButtonVisible() && !this.isPopupFocused) {
                    this.focusOverflowButton();
                }
                else {
                    const lastRT = this.getFocusableTools().reverse()[0];
                    this.focus(lastRT, ev);
                }
            }
        }
    }
    resetNavigation() {
        this.blurOverflowButton();
        this.focused.renderedTool = null;
        this.focused.index = -1;
    }
    focusFirst(ev) {
        const firstTool = this.getFocusableTools()[0];
        const overFlowButton = this.overflowButton;
        if (firstTool) {
            this.focused.renderedTool = firstTool;
            this.focused.index = this.getFocusableTools().findIndex(rt => rt === firstTool);
            this.focus(firstTool, ev);
        }
        else if (overFlowButton) {
            overFlowButton.nativeElement.focus();
        }
    }
    focusLast(ev) {
        const lastTool = this.getFocusableTools().reverse()[0];
        const overFlowButton = this.overflowButton;
        if (lastTool) {
            this.focused.renderedTool = lastTool;
            this.focused.index = this.getFocusableTools().findIndex(rt => rt === lastTool);
            this.focus(lastTool, ev);
        }
        else if (overFlowButton) {
            overFlowButton.nativeElement.focus();
        }
    }
    getFocusableTools() {
        return this.renderedTools.filter(rt => (rt.tool.overflows === this.isPopupFocused) && rt.tool.canFocus());
    }
    focus(renderedTool, ev) {
        // running the code below in onStable fixes issue #2939
        this.zone.onStable.pipe(take(1)).subscribe(() => {
            if (!renderedTool) {
                const focusableRTs = this.getFocusableTools();
                const lastFocusedRT = focusableRTs.find(rt => rt === this.focused.renderedTool) || focusableRTs[0];
                // guard against only disabled tools
                if (lastFocusedRT) {
                    this.focused.renderedTool = lastFocusedRT;
                    this.focused.index = this.getFocusableTools().findIndex(rt => rt === lastFocusedRT);
                    // if event is undefined, then this means that the tool is the first one in the overflow popup
                    lastFocusedRT.tool.focus(ev);
                }
            }
            else if (renderedTool.tool.canFocus && renderedTool.tool.canFocus()) {
                this.focused.renderedTool = renderedTool;
                this.focused.index = this.getFocusableTools().findIndex(rt => rt === renderedTool);
                renderedTool.tool.focus(ev);
                this.blurOverflowButton();
            }
        });
    }
    blurOverflowButton() {
        if (this.overflowButton) {
            this.isOverflowButtonFocused = false;
            this.overflowButton.nativeElement.tabIndex = -1;
        }
    }
    focusOverflowButton() {
        if (this.overflowButton) {
            this.isOverflowButtonFocused = true;
            this.overflowButton.nativeElement.tabIndex = 0;
            this.overflowButton.nativeElement.focus();
        }
    }
    isOverflowButtonVisible() {
        return (isPresent(this.overflowButton) &&
            window.getComputedStyle(this.overflowButton.nativeElement).getPropertyValue('visibility') === 'visible');
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: NavigationService, deps: [{ token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: NavigationService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: NavigationService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: i0.NgZone }] });

/**
 * Represents the base ToolBar Tool component for Angular.
 *
 * Extend this class to create a custom tool for the ToolBar.
 *
 * @example
 * ```typescript
 * import { Component } from '@angular/core';
 * import { ToolBarToolComponent } from '@progress/kendo-angular-toolbar';
 *
 * @Component({
 *    providers: [{ provide: ToolBarToolComponent, useExisting: forwardRef(() => CustomToolComponent) }],
 *    selector: 'custom-tool',
 * })
 *
 * export class CustomToolComponent extends ToolBarToolComponent {
 *
 *  constructor() {
 *        super();
 *    }
 * }
 * ```
 */
class ToolBarToolComponent {
    toolbarTemplate;
    sectionTemplate;
    popupTemplate;
    tabIndex = -1; //Focus movement inside the toolbar is managed using roving tabindex.
    overflows = true;
    visibility;
    element;
    isBuiltInTool = false;
    /**
     * @hidden
     */
    isHidden = false;
    /**
     * @hidden
     */
    location;
    constructor() {
        this.element = inject(ElementRef);
    }
    // this should be replaced with showTool: DisplayMode = 'both';
    /**
     * @hidden
     */
    responsive = true;
    get toolbarDisplay() {
        return this.overflows ? 'none' : 'inline-flex';
    }
    get overflowDisplay() {
        return this.overflows ? 'block' : 'none';
    }
    /**
     * Determines if the tool can receive focus.
     * Returns `true` if the tool participates in keyboard navigation.
     * @returns `true` if the tool is focusable.
     */
    canFocus() {
        return false;
    }
    /**
     * Called when the tool receives focus.
     * Accepts the original browser event, which can be a `KeyboardEvent`, `MouseEvent`, or `FocusEvent`.
     * @param {Event} _ev - The event that triggers focus for the tool.
     */
    focus(_ev) {
        /* noop */
    }
    /**
     * Called when the tool is focused and an arrow key is pressed.
     * Returns a boolean value that determines if the `ToolBarComponent` moves focus to the next or previous tool
     * ([see example]({% slug customcontroltypes_toolbar %}#toc-adding-keyboard-navigation)).
     * @param {KeyboardEvent} _ev - The last pressed arrow key.
     * @returns `true` if focus moves to another tool.
     */
    handleKey(_ev) {
        return false;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ToolBarToolComponent, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: ToolBarToolComponent, isStandalone: true, inputs: { responsive: "responsive" }, viewQueries: [{ propertyName: "toolbarTemplate", first: true, predicate: ["toolbarTemplate"], descendants: true, static: true }, { propertyName: "sectionTemplate", first: true, predicate: ["sectionTemplate"], descendants: true, static: true }, { propertyName: "popupTemplate", first: true, predicate: ["popupTemplate"], descendants: true, static: true }], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ToolBarToolComponent, decorators: [{
            type: Directive,
            args: [{
                    standalone: true
                }]
        }], ctorParameters: () => [], propDecorators: { toolbarTemplate: [{
                type: ViewChild,
                args: ['toolbarTemplate', { static: true }]
            }], sectionTemplate: [{
                type: ViewChild,
                args: ['sectionTemplate', { static: true }]
            }], popupTemplate: [{
                type: ViewChild,
                args: ['popupTemplate', { static: true }]
            }], responsive: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class PreventableEvent {
    prevented = false;
    /**
     * Prevents the default action for a specified event.
     * In this way, the source component suppresses the built-in behavior that follows the event.
     */
    preventDefault() {
        this.prevented = true;
    }
    /**
     * If the event is prevented by any of its subscribers, returns `true`.
     *
     * @returns `true` if the default action was prevented. Otherwise, returns `false`.
     */
    isDefaultPrevented() {
        return this.prevented;
    }
}

/**
 * @hidden
 */
class RendererService {
    element;
    renderer;
    getElement() {
        return this.element.nativeElement;
    }
    querySelector(selector) {
        return this.element.nativeElement.querySelector(selector);
    }
    querySelectorAll(selector) {
        return this.element.nativeElement.querySelectorAll(selector);
    }
    findFocusable() {
        return findFocusable(this.element.nativeElement, false);
    }
    findFocusableChild(element) {
        if (!element) {
            element = this.findFocusable();
        }
        return findFocusableChild(element, false);
    }
    findNextFocusableSibling(element) {
        if (!element) {
            element = this.findFocusable();
        }
        return findFocusableSibling(element, false);
    }
    findPrevFocusableSibling(element) {
        if (!element) {
            element = this.findFocusable();
        }
        return findFocusableSibling(element, false, true);
    }
    setAttribute(element, attr, value) {
        this.renderer.setAttribute(element, attr, value);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: RendererService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: RendererService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: RendererService, decorators: [{
            type: Injectable
        }] });

/**
 * @hidden
 */
class ToolbarToolsService {
    renderedToolsChange = new Subject();
    overflowToolsChange = new Subject();
    renderedTools = [];
    overflowTools = [];
    allTools = [];
    reset() {
        this.renderedTools = this.overflowTools = this.allTools = [];
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ToolbarToolsService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ToolbarToolsService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ToolbarToolsService, decorators: [{
            type: Injectable
        }] });

const MIN_SPACER_WIDTH = 18;
/**
 * @hidden
 */
class ToolBarRendererComponent {
    renderer;
    rendererService;
    refreshService;
    toolsService;
    viewContainer;
    tool;
    location;
    resizable;
    rendererClick = new EventEmitter();
    template;
    element;
    get isSpacer() {
        return this.tool && this.tool.__isSpacer;
    }
    refreshSubscription;
    internalComponentRef;
    constructor(renderer, rendererService, refreshService, toolsService, viewContainer) {
        this.renderer = renderer;
        this.rendererService = rendererService;
        this.refreshService = refreshService;
        this.toolsService = toolsService;
        this.viewContainer = viewContainer;
    }
    ngOnInit() {
        this.tool.location = this.location;
        this.element = this.tool.element;
        this.rendererService.element = this.element;
        this.rendererService.renderer = this;
        this.refreshSubscription = this.refreshService.onRefresh.subscribe((tool) => {
            if (this.tool === tool) {
                this.refresh();
            }
        });
    }
    ngOnDestroy() {
        this.refreshSubscription?.unsubscribe();
        this.internalComponentRef?.removeEventListener('click', this.onClick);
    }
    ngAfterViewInit() {
        const viewContainerRootNodes = this.viewContainer.get(0)?.rootNodes?.filter(isElementOrTextNode);
        if (!viewContainerRootNodes || viewContainerRootNodes.length === 0) {
            return;
        }
        this.internalComponentRef = viewContainerRootNodes[0];
        this.internalComponentRef.addEventListener('click', this.onClick);
        if (this.resizable) {
            if (this.location === 'toolbar') {
                this.template = this.tool.toolbarTemplate;
                this.hideTool();
            }
            else if (this.location === 'section') {
                this.template = this.tool.toolbarTemplate;
                if (this.tool.isHidden) {
                    this.hideTool();
                }
                else {
                    this.renderer.setStyle(this.internalComponentRef, 'visibility', 'visible');
                    this.renderer.setStyle(this.internalComponentRef, 'display', 'inline-flex');
                }
            }
            else {
                this.template = this.tool.popupTemplate;
                if (this.tool.isHidden) {
                    this.hideTool();
                }
                else {
                    this.renderer.setStyle(this.internalComponentRef, 'display', 'none');
                }
            }
        }
        else {
            this.tool.overflows = false;
            this.template = this.tool.toolbarTemplate;
            if (this.tool.isHidden) {
                this.hideTool();
            }
            else {
                this.renderer.setStyle(this.internalComponentRef, 'visibility', 'visible');
                this.renderer.setStyle(this.internalComponentRef, 'display', 'inline-flex');
            }
        }
        if (this.resizable) {
            this.refresh();
        }
        this.updateTools();
    }
    /**
     * @hidden
     */
    get width() {
        if (this.isSpacer) {
            return MIN_SPACER_WIDTH;
        }
        if (!this.internalComponentRef) {
            return;
        }
        return this.tool.overflows ? 0 : outerWidth(this.internalComponentRef);
    }
    isDisplayed() {
        return this.internalComponentRef?.style?.display !== 'none';
    }
    refresh() {
        this.tool.location = this.location;
        if (!isPresent$1(this.internalComponentRef)) {
            return;
        }
        if (this.tool.isHidden) {
            this.hideTool();
        }
        else if (this.resizable) {
            if (this.location === 'toolbar') {
                this.renderer.setStyle(this.internalComponentRef, 'visibility', this.tool.visibility);
                this.renderer.setStyle(this.internalComponentRef, 'display', this.tool.toolbarDisplay);
            }
            else {
                this.renderer.setStyle(this.internalComponentRef, 'display', this.tool.overflowDisplay);
            }
        }
        else {
            this.renderer.setStyle(this.internalComponentRef, 'visibility', 'visible');
            this.renderer.setStyle(this.internalComponentRef, 'display', 'inline-flex');
        }
        this.updateTools();
    }
    setAttribute(element, attr, value) {
        this.renderer.setAttribute(element, attr, value);
    }
    onClick = (ev) => {
        this.rendererClick.emit({ context: this, event: ev });
    };
    updateTools() {
        this.tool.location = this.location;
        const isInToolbar = this.toolsService.renderedTools.some(t => t.tool === this.tool);
        const isInPopup = this.toolsService.overflowTools.some(t => t.tool === this.tool);
        if (this.location === 'toolbar') {
            isInPopup && (this.toolsService.overflowTools = this.toolsService.overflowTools.filter(t => t.tool !== this.tool));
            !isInToolbar && this.toolsService.renderedTools.push(this);
        }
        else {
            if (!isInPopup) {
                this.toolsService.overflowTools.push(this);
                this.toolsService.overflowTools.sort((t1, t2) => {
                    // ensures correct navigation order in Popup
                    return this.toolsService.allTools.indexOf(t1.tool) - this.toolsService.allTools.indexOf(t2.tool);
                });
            }
        }
    }
    hideTool() {
        this.renderer.setStyle(this.internalComponentRef, 'visibility', 'hidden');
        this.renderer.setStyle(this.internalComponentRef, 'display', 'none');
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ToolBarRendererComponent, deps: [{ token: i0.Renderer2 }, { token: RendererService }, { token: RefreshService }, { token: ToolbarToolsService }, { token: i0.ViewContainerRef }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: ToolBarRendererComponent, isStandalone: true, selector: "[kendoToolbarRenderer]", inputs: { tool: "tool", location: "location", resizable: "resizable" }, outputs: { rendererClick: "rendererClick" }, providers: [RendererService], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ToolBarRendererComponent, decorators: [{
            type: Directive,
            args: [{
                    providers: [RendererService],
                    standalone: true,
                    selector: '[kendoToolbarRenderer]'
                }]
        }], ctorParameters: () => [{ type: i0.Renderer2 }, { type: RendererService }, { type: RefreshService }, { type: ToolbarToolsService }, { type: i0.ViewContainerRef }], propDecorators: { tool: [{
                type: Input
            }], location: [{
                type: Input
            }], resizable: [{
                type: Input
            }], rendererClick: [{
                type: Output
            }] } });

/**
 * @hidden
 */
class ToolbarMessages extends ComponentMessages {
    /**
     * Sets the title of the **More Tools** button in a responsive ToolBar.
     */
    moreToolsTitle;
    /**
     * Sets the title for the **Previous Tool** button when the ToolBar is scrollable.
     */
    previousToolButton;
    /**
     * Sets the title for the **Next Tool** button when the ToolBar is scrollable.
     */
    nextToolButton;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ToolbarMessages, deps: null, target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: ToolbarMessages, isStandalone: true, selector: "kendo-toolbar-messages-base", inputs: { moreToolsTitle: "moreToolsTitle", previousToolButton: "previousToolButton", nextToolButton: "nextToolButton" }, usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ToolbarMessages, decorators: [{
            type: Directive,
            args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: 'kendo-toolbar-messages-base'
                }]
        }], propDecorators: { moreToolsTitle: [{
                type: Input
            }], previousToolButton: [{
                type: Input
            }], nextToolButton: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class LocalizedToolbarMessagesDirective extends ToolbarMessages {
    service;
    constructor(service) {
        super();
        this.service = service;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: LocalizedToolbarMessagesDirective, deps: [{ token: i1.LocalizationService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: LocalizedToolbarMessagesDirective, isStandalone: true, selector: "[kendoToolbarLocalizedMessages]", providers: [
            {
                provide: ToolbarMessages,
                useExisting: forwardRef(() => LocalizedToolbarMessagesDirective)
            }
        ], usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: LocalizedToolbarMessagesDirective, decorators: [{
            type: Directive,
            args: [{
                    providers: [
                        {
                            provide: ToolbarMessages,
                            useExisting: forwardRef(() => LocalizedToolbarMessagesDirective)
                        }
                    ],
                    selector: '[kendoToolbarLocalizedMessages]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1.LocalizationService }] });

const DEFAULT_SCROLL_BEHAVIOR = 'smooth';
const DEFAULT_SCROLL_SPEED = 100;
/**
 * @hidden
 */
class ScrollService {
    ngZone;
    localization;
    owner;
    position = 0;
    scrollButtonActiveStateChange = new Subject();
    get scrollElement() {
        return this.owner.scrollContainer?.nativeElement;
    }
    get scrollContainerOverflowSize() {
        if (!isDocumentAvailable()) {
            return 0;
        }
        if (!this.scrollElement) {
            return 0;
        }
        const overflowSize = Math.floor(this.scrollElement.scrollWidth - this.scrollElement.getBoundingClientRect().width);
        return overflowSize < 0 ? 0 : overflowSize;
    }
    get toolsOverflow() {
        return this.scrollContainerOverflowSize > 0;
    }
    constructor(ngZone, localization) {
        this.ngZone = ngZone;
        this.localization = localization;
    }
    toggleScrollButtonsState() {
        const toolbar = this.owner;
        if (!toolbar.hasScrollButtons) {
            return;
        }
        const currentPrevButtonActive = !this.isDisabled('prev');
        const currentNextButtonActive = !this.isDisabled('next');
        const defaultOffset = 1;
        const rtlDelta = this.localization.rtl ? -1 : 1;
        const calculatedPrevButtonActive = (this.position * rtlDelta) > 0 && this.scrollContainerOverflowSize > 0;
        const calculatedNextButtonActive = (this.position * rtlDelta) < this.scrollContainerOverflowSize - defaultOffset && this.scrollContainerOverflowSize > 0;
        if (calculatedPrevButtonActive !== currentPrevButtonActive) {
            this.ngZone.run(() => this.toggleButtonActiveState('prev', calculatedPrevButtonActive));
        }
        if (calculatedNextButtonActive !== currentNextButtonActive) {
            this.ngZone.run(() => this.toggleButtonActiveState('next', calculatedNextButtonActive));
        }
    }
    onScroll(e) {
        this.position = e.target.scrollLeft;
        this.toggleScrollButtonsState();
    }
    scrollTools(direction) {
        this.calculateListPosition(direction, DEFAULT_SCROLL_SPEED);
        if (this.scrollElement) {
            this.scrollElement.scrollTo({ left: this.position, behavior: DEFAULT_SCROLL_BEHAVIOR });
        }
        this.toggleScrollButtonsState();
    }
    updateScrollPosition(element) {
        this.position = element.scrollLeft;
    }
    calculateListPosition(direction, scrollSpeed) {
        if (direction === 'prev') {
            if (!this.localization.rtl) {
                this.position = this.position - scrollSpeed <= 0 ? 0 : this.position - scrollSpeed;
            }
            else {
                this.position = this.position + scrollSpeed >= 0 ? 0 : this.position + scrollSpeed;
            }
        }
        else if (direction === 'next' && this.position < this.scrollContainerOverflowSize) {
            if (this.position + scrollSpeed > this.scrollContainerOverflowSize) {
                if (this.localization.rtl) {
                    this.position = -this.scrollContainerOverflowSize;
                }
                else {
                    this.position = this.scrollContainerOverflowSize;
                }
                return;
            }
            if (this.localization.rtl) {
                this.position -= scrollSpeed;
            }
            else {
                this.position += scrollSpeed;
            }
        }
    }
    toggleButtonActiveState(buttonType, active) {
        this.scrollButtonActiveStateChange.next({ buttonType, active });
    }
    isDisabled = (buttonType) => this.owner[`${buttonType}ScrollButton`]?.nativeElement.classList.contains('k-disabled');
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ScrollService, deps: [{ token: i0.NgZone }, { token: i1.LocalizationService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ScrollService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ScrollService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: i0.NgZone }, { type: i1.LocalizationService }] });

const DIRECTION_CLASSES = {
    left: 'caret-alt-left',
    right: 'caret-alt-right'
};
/**
 * @hidden
 */
class ToolbarScrollableButtonComponent {
    host;
    renderer;
    ngZone;
    localization;
    get prevClass() {
        return this.prev;
    }
    get nextClass() {
        return !this.prev;
    }
    role = 'button';
    prev = false;
    overflow;
    onClick = new EventEmitter();
    get iconClass() {
        return this.scrollButtonIconClass;
    }
    get customIconClass() {
        return this.customScrollButtonIconClass;
    }
    get svgIcon() {
        return this.scrollButtonSVGIcon;
    }
    caretAltLeftIcon = caretAltLeftIcon;
    caretAltRightIcon = caretAltRightIcon;
    subs = new Subscription();
    constructor(host, renderer, ngZone, localization) {
        this.host = host;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.localization = localization;
    }
    ngAfterViewInit() {
        this.ngZone.runOutsideAngular(() => {
            this.subs.add(this.renderer.listen(this.host.nativeElement, 'click', this.clickHandler));
        });
    }
    ngOnDestroy() {
        this.subs.unsubscribe();
    }
    clickHandler = () => {
        const buttonType = this.prev ? 'prev' : 'next';
        this.onClick.emit(buttonType);
    };
    get scrollButtonIconClass() {
        const defaultPrevIcon = !this.localization.rtl ?
            DIRECTION_CLASSES.left :
            DIRECTION_CLASSES.right;
        const defaultNextIcon = !this.localization.rtl ?
            DIRECTION_CLASSES.right :
            DIRECTION_CLASSES.left;
        if (typeof this.overflow === 'object') {
            const prevIcon = typeof this.overflow.prevButtonIcon === 'undefined' ? defaultPrevIcon : '';
            const nextIcon = typeof this.overflow.nextButtonIcon === 'undefined' ? defaultNextIcon : '';
            if (prevIcon && this.prev) {
                return prevIcon;
            }
            else if (nextIcon && !this.prev) {
                return nextIcon;
            }
        }
    }
    get customScrollButtonIconClass() {
        if (typeof this.overflow === 'object') {
            const prevIcon = this.overflow.prevButtonIcon;
            const nextIcon = this.overflow.nextButtonIcon;
            if (prevIcon && this.prev) {
                return `k-icon ${prevIcon}`;
            }
            if (nextIcon && !this.prev) {
                return `k-icon ${nextIcon}`;
            }
        }
    }
    get scrollButtonSVGIcon() {
        const defaultPrevSVGIcon = !this.localization.rtl ?
            this.caretAltLeftIcon :
            this.caretAltRightIcon;
        const defaultNextSVGIcon = !this.localization.rtl ?
            this.caretAltRightIcon :
            this.caretAltLeftIcon;
        if (typeof this.overflow === 'object') {
            const prevIcon = this.overflow.prevSVGButtonIcon !== undefined ? this.overflow.prevSVGButtonIcon : defaultPrevSVGIcon;
            const nextIcon = this.overflow.nextSVGButtonIcon !== undefined ? this.overflow.nextSVGButtonIcon : defaultNextSVGIcon;
            if (prevIcon || nextIcon) {
                return this.prev ? prevIcon : nextIcon;
            }
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ToolbarScrollableButtonComponent, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }, { token: i0.NgZone }, { token: i1.LocalizationService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: ToolbarScrollableButtonComponent, isStandalone: true, selector: "[kendoToolbarScrollableButton]", inputs: { prev: "prev", overflow: "overflow" }, outputs: { onClick: "onClick" }, host: { properties: { "class.k-toolbar-prev": "this.prevClass", "class.k-toolbar-next": "this.nextClass", "attr.role": "this.role" } }, ngImport: i0, template: `
        <kendo-icon-wrapper
            [name]="iconClass"
            [customFontClass]="customIconClass"
            [svgIcon]="svgIcon"
            innerCssClass="k-button-icon"
        >
        </kendo-icon-wrapper>
    `, isInline: true, dependencies: [{ kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ToolbarScrollableButtonComponent, decorators: [{
            type: Component,
            args: [{
                    template: `
        <kendo-icon-wrapper
            [name]="iconClass"
            [customFontClass]="customIconClass"
            [svgIcon]="svgIcon"
            innerCssClass="k-button-icon"
        >
        </kendo-icon-wrapper>
    `,
                    // eslint-disable-next-line @angular-eslint/component-selector
                    selector: '[kendoToolbarScrollableButton]',
                    standalone: true,
                    imports: [IconWrapperComponent]
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i0.NgZone }, { type: i1.LocalizationService }], propDecorators: { prevClass: [{
                type: HostBinding,
                args: ['class.k-toolbar-prev']
            }], nextClass: [{
                type: HostBinding,
                args: ['class.k-toolbar-next']
            }], role: [{
                type: HostBinding,
                args: ['attr.role']
            }], prev: [{
                type: Input
            }], overflow: [{
                type: Input
            }], onClick: [{
                type: Output
            }] } });

/* eslint-disable no-case-declarations */
const DEFAULT_SIZE = 'medium';
const DEFAULT_FILL_MODE = 'solid';
const immediateResizeThreshold = 300;
const getInitialPopupSettings = (isRtl) => ({
    animate: true,
    anchorAlign: { horizontal: isRtl ? 'left' : 'right', vertical: 'bottom' },
    popupAlign: { horizontal: isRtl ? 'left' : 'right', vertical: 'top' }
});
/**
 * Represents the [Kendo UI ToolBar component for Angular]({% slug overview_toolbar %}).
 *
 * @example
 * ```html
 * <kendo-toolbar>
 *      <kendo-toolbar-button text="Button"></kendo-toolbar-button>
 * </kendo-toolbar>
 * ```
 *
 * @remarks
 * Supported children components are:
 * {@link ToolBarButtonComponent},
 * {@link ToolBarButtonGroupComponent},
 * {@link ToolBarDropDownButtonComponent},
 * {@link ToolBarSplitButtonComponent},
 * {@link ToolBarSeparatorComponent},
 * {@link ToolBarSpacerComponent},
 * {@link ToolbarCustomMessagesComponent},
 * {@link ToolBarToolComponent},
 * {@link EditorColorPickerComponent},
 * {@link EditorFontFamilyComponent},
 * {@link EditorFontSizeComponent},
 * {@link EditorFormatComponent},
 * {@link EditorInsertTableButtonComponent},
 * {@link SelectAllToolbarToolComponent}.
 */
class ToolBarComponent {
    localization;
    popupService;
    refreshService;
    navigationService;
    element;
    zone;
    renderer;
    _cdr;
    toolsService;
    scrollService;
    get overflowClass() {
        return `k-button-${SIZES[this.size]}`;
    }
    /**
     * Sets the overflow mode for the ToolBar.
     * Use this property to control how tools render when their total size is greater than the ToolBar container.
     * @default false
     */
    set overflow(overflow) {
        if (this.isScrollMode) {
            this.removeSubscriptions(['scrollButtonStateChangeSub', 'scrollContainerScrollSub']);
        }
        this._overflow = overflow;
        if (this.isScrollMode) {
            this.handleScrollModeUpdates();
        }
        this.setScrollableOverlayClasses();
        this.zone.onStable.pipe(take(1)).subscribe(() => this.onResize());
    }
    get overflow() {
        return this._overflow;
    }
    get showScrollButtons() {
        const buttonsVisibility = this.normalizedOverflow.scrollButtons;
        const showAuto = buttonsVisibility === 'auto' && this.showAutoButtons;
        const showAlways = buttonsVisibility === 'visible';
        return this.isScrollMode && (showAuto || showAlways);
    }
    /**
     * @hidden
     */
    set resizable(value) {
        this.overflow = value;
    }
    get resizable() {
        return this.showMenu;
    }
    /**
     * @hidden
     */
    get hasScrollButtons() {
        const visible = this.normalizedOverflow.mode === 'scroll' && this.normalizedOverflow.scrollButtons !== 'hidden';
        const position = this.normalizedOverflow.scrollButtonsPosition;
        return {
            visible,
            position
        };
    }
    /**
     * @hidden
     */
    get isScrollMode() {
        return this.normalizedOverflow.mode === 'scroll';
    }
    /**
     * @hidden
     */
    get showMenu() {
        return this.normalizedOverflow.mode === 'menu' || this.normalizedOverflow.mode === 'section';
    }
    /**
     * @hidden
     */
    get overflowEnabled() {
        return this.normalizedOverflow.mode !== 'none';
    }
    /**
     * Configures the popup for the ToolBar overflow button.
     * Use this property to customize the overflow popup appearance and behavior
     * ([see example](slug:responsive_toolbar#customizing-the-popup)).
     */
    set popupSettings(settings) {
        this._popupSettings = Object.assign({}, getInitialPopupSettings(this.localization.rtl), settings);
    }
    get popupSettings() {
        return this._popupSettings || getInitialPopupSettings(this.localization.rtl);
    }
    /**
     * Sets the fill mode for the ToolBar.
     * This property controls the background and border styles of the ToolBar
     * ([see example](slug:appearance_toolbar#toc-fill-mode)).
     * @default 'solid'
     */
    set fillMode(fillMode) {
        const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE;
        this.handleClasses(newFillMode, 'fillMode');
        this._fillMode = newFillMode;
    }
    get fillMode() {
        return this._fillMode;
    }
    /**
     * Sets the `tabindex` attribute of the ToolBar.
     * Use this property to control the tab order of the ToolBar component.
     * @default 0
     */
    tabindex = 0;
    /**
     * Sets the size for all ToolBar elements.
     * Use this property to control the padding of the ToolBar elements.
     * @default 'medium'
     */
    set size(size) {
        const newSize = size ? size : DEFAULT_SIZE;
        this.handleClasses(newSize, 'size');
        this._size = newSize;
    }
    get size() {
        return this._size;
    }
    /**
     * @hidden
     */
    set tabIndex(tabIndex) {
        this.tabindex = tabIndex;
    }
    get tabIndex() {
        return this.tabindex;
    }
    /**
     * Sets the icon visibility for all tools in the ToolBar.
     * You can override this property for each tool using the `showIcon` property of the tool.
     * @default 'always'
     */
    set showIcon(value) {
        if (this._showIcon === value) {
            return;
        }
        const normalizedValue = this.normalizeDisplayValue(value);
        this._showIcon = value;
        this.propertyChange.emit({
            property: 'showIcon',
            value: normalizedValue
        });
    }
    /**
     * Sets the text visibility for all tools in the ToolBar.
     * You can override this property for each tool using the `showText` property of the tool.
     * @default 'always'
     */
    set showText(value) {
        if (this._showText === value) {
            return;
        }
        const normalizedValue = this.normalizeDisplayValue(value);
        this._showText = value;
        this.propertyChange.emit({
            property: 'showText',
            value: normalizedValue
        });
    }
    /**
     * Emits when the overflow popup of the ToolBar opens.
     */
    open = new EventEmitter();
    /**
     * Emits when the overflow popup of the ToolBar closes.
     */
    close = new EventEmitter();
    allTools;
    overflowButton;
    popupTemplate;
    popupSectionTemplate;
    scrollContainer;
    resizeSensor;
    container;
    prevScrollButton;
    nextScrollButton;
    startButtonGroup;
    endButtonGroup;
    scrollSeparator;
    popupRef;
    direction;
    get appendTo() {
        const { appendTo } = this.popupSettings;
        if (!appendTo || appendTo === 'root') {
            return undefined;
        }
        return appendTo === 'component' ? this.container : appendTo;
    }
    set popupOpen(open) {
        if (this.popupOpen === open) {
            return;
        }
        const eventArgs = new PreventableEvent();
        if (open) {
            this.open.emit(eventArgs);
        }
        else {
            this.close.emit(eventArgs);
        }
        if (eventArgs.isDefaultPrevented()) {
            return;
        }
        this.toggle(open);
    }
    get popupOpen() {
        return this._open;
    }
    /**
     * @hidden
     */
    prevButtonIcon = caretAltLeftIcon;
    /**
     * @hidden
     */
    nextButtonIcon = caretAltRightIcon;
    /**
     * @hidden
     */
    propertyChange = new EventEmitter();
    hostClass = true;
    get scrollableClass() {
        return this.isScrollMode;
    }
    get sectionClass() {
        return this.normalizedOverflow.mode === 'section';
    }
    _overflow = false;
    _popupSettings;
    cachedOverflowAnchorWidth;
    _open;
    toolbarKeydownListener;
    overflowKeydownListener;
    sectionKeydownListener;
    cancelRenderedToolsSubscription$ = new Subject();
    cachedGap;
    _size = DEFAULT_SIZE;
    _fillMode = DEFAULT_FILL_MODE;
    _showText = 'always';
    _showIcon = 'always';
    overflowButtonClickedTime = null;
    showAutoButtons = false;
    scrollButtonStateChangeSub;
    scrollContainerScrollSub;
    /**
     * @hidden
     */
    get normalizedOverflow() {
        return normalizeOverflowSettings(this.overflow);
    }
    subscriptions = new Subscription();
    popupSubs = new Subscription();
    focusedByPointer = false;
    /**
     * @hidden
     */
    onFocus(ev) {
        if (this.focusedByPointer) {
            this.focusedByPointer = false;
            return;
        }
        this.navigationService.resetNavigation();
        this.navigationService.focusFirst(ev);
        // prevents ExpressionChangedAfterItHasBeenCheckedError when tools with popup are opened/closed asynchronously
        this.element.nativeElement.setAttribute('tabindex', '-1');
    }
    /**
     * @hidden
     */
    onFocusOut(event) {
        // prevents ExpressionChangedAfterItHasBeenCheckedError when tools with popup are opened/closed asynchronously
        if (closest(event.relatedTarget, (el) => el === this.element.nativeElement)) {
            this.element.nativeElement.setAttribute('tabindex', '-1');
            return;
        }
        this.element.nativeElement.setAttribute('tabindex', this.tabindex.toString());
    }
    role = 'toolbar';
    get getDir() {
        return this.direction;
    }
    get resizableClass() {
        return this.resizable;
    }
    constructor(localization, popupService, refreshService, navigationService, 
    // Needs to be public as it is being accessed in the Editor component
    element, zone, renderer, _cdr, toolsService, scrollService) {
        this.localization = localization;
        this.popupService = popupService;
        this.refreshService = refreshService;
        this.navigationService = navigationService;
        this.element = element;
        this.zone = zone;
        this.renderer = renderer;
        this._cdr = _cdr;
        this.toolsService = toolsService;
        this.scrollService = scrollService;
        validatePackage(packageMetadata);
        this.direction = localization.rtl ? 'rtl' : 'ltr';
        this.scrollService.owner = this;
    }
    ngAfterContentInit() {
        this.toolsService.allTools = this.allTools.toArray();
        this.subscriptions.add(this.allTools.changes.subscribe(() => {
            this.toolsService.reset();
            this.toolsService.allTools = this.allTools.toArray();
            this.allTools.forEach((tool) => {
                this.refreshService.refresh(tool);
            });
            this.zone.onStable.pipe(take(1)).subscribe(() => this.onResize());
        }));
    }
    ngAfterViewInit() {
        this.toolsService.renderedToolsChange.next(this.toolsService.renderedTools);
        this.toolsService.overflowToolsChange.next(this.toolsService.overflowTools);
        const element = this.element.nativeElement;
        if (!element.getAttribute('tabindex')) {
            this.element.nativeElement.setAttribute('tabindex', '0');
        }
        this.zone.runOutsideAngular(() => {
            this.toolbarKeydownListener = this.renderer.listen(this.element.nativeElement, 'keydown', (ev) => {
                // on some keyboards arrow keys, PageUp/Down, and Home/End are mapped to Numpad keys
                const code = normalizeKeys(ev);
                switch (code) {
                    case Keys.ArrowLeft:
                        this.zone.run(() => {
                            ev.preventDefault();
                            if (this.direction === 'ltr') {
                                this.navigationService.focusPrev(ev);
                            }
                            else {
                                this.navigationService.focusNext(ev);
                            }
                            // prevents ExpressionChangedAfterItHasBeenCheckedError when tools with popup are opened/closed asynchronously
                            this.element.nativeElement.setAttribute('tabindex', '-1');
                        });
                        break;
                    case Keys.ArrowRight:
                        this.zone.run(() => {
                            ev.preventDefault();
                            if (this.direction === 'ltr') {
                                this.navigationService.focusNext(ev);
                            }
                            else {
                                this.navigationService.focusPrev(ev);
                            }
                            // prevents ExpressionChangedAfterItHasBeenCheckedError when tools with popup are opened/closed asynchronously
                            this.element.nativeElement.setAttribute('tabindex', '-1');
                        });
                        break;
                    case Keys.Tab:
                        this.zone.run(() => this.navigationService.resetNavigation());
                        break;
                    case Keys.Escape:
                        this.zone.run(() => this.toggle(false));
                        break;
                    case Keys.Home:
                        this.zone.run(() => this.navigationService.focusFirst(ev));
                        break;
                    case Keys.End:
                        this.zone.run(() => this.navigationService.focusLast(ev));
                        break;
                    default:
                        break;
                }
            });
        });
        if (this.overflowEnabled) {
            this.subscriptions.add(merge(this.resizeSensor.resize, this.toolsService.renderedToolsChange).subscribe(() => this.onResize()));
            if (this.showMenu) {
                this.navigationService.overflowButton = this.overflowButton;
            }
            // because of https://github.com/telerik/kendo-angular-buttons/pull/276
            // button icons are not rendered until onResize() is called
            this.zone.runOutsideAngular(() => {
                setTimeout(() => {
                    this.zone.run(() => {
                        this.onResize();
                    });
                });
            });
        }
        if (this.isScrollMode) {
            this.handleScrollModeUpdates();
        }
        this.subscriptions.add(this.renderer.listen(this.element.nativeElement, 'pointerdown', (ev) => {
            if (!ev.target.closest('.k-toolbar-items')) {
                this.focusedByPointer = true;
            }
        }));
        this.navigationService.setRenderedTools(this.toolsService.renderedTools);
        const stylingOptions = ['size', 'fillMode'];
        stylingOptions.forEach(option => {
            this.handleClasses(this[option], option);
        });
    }
    ngOnInit() {
        this.subscriptions.add(this.localization.changes.subscribe(({ rtl }) => (this.direction = rtl ? 'rtl' : 'ltr')));
        this.zone.onStable.pipe(take(1)).subscribe(() => this.onResize());
        if (isDocumentAvailable()) {
            this.zone.runOutsideAngular(() => this.subscriptions.add(fromEvent(document, 'click')
                .pipe(filter(() => !!this.popupRef), filter((ev) => !this.popupRef.popup.instance.container.nativeElement.contains(ev.target)), filter((ev) => !this.overflowButton.nativeElement.contains(ev.target)))
                .subscribe(() => {
                this.zone.run(() => {
                    this.popupOpen = false;
                });
            })));
        }
    }
    ngOnChanges(changes) {
        if (changes['tabindex']) {
            // prevents ExpressionChangedAfterItHasBeenCheckedError when tools with popup are opened/closed asynchronously
            this.element.nativeElement.setAttribute('tabindex', changes['tabindex'].currentValue.toString());
        }
    }
    ngOnDestroy() {
        this.destroyPopup();
        if (this.toolbarKeydownListener) {
            this.toolbarKeydownListener();
        }
        this.cancelRenderedToolsSubscription$.next(undefined);
        this.subscriptions.unsubscribe();
    }
    /**
     * @hidden
     */
    showOverflowSeparator = false;
    /**
     * @hidden
     */
    get moreToolsTitle() {
        return this.localization.get('moreToolsTitle');
    }
    /**
     * @hidden
     */
    get cdr() {
        return this._cdr;
    }
    /**
     * @hidden
     */
    get sectionSizeClass() {
        return this.size === 'none' ? '' : `k-toolbar-items-list-${SIZES[this.size]}`;
    }
    /**
     * @hidden
     */
    getScrollButtonTitle(buttonType) {
        let currentButton;
        if (this.localization.rtl) {
            currentButton = buttonType === 'prev' ? 'nextToolButton' : 'previousToolButton';
        }
        else {
            currentButton = buttonType === 'prev' ? 'previousToolButton' : 'nextToolButton';
        }
        return this.localization.get(currentButton);
    }
    /**
     * @hidden
     */
    scrollTools(dir) {
        this.scrollService.scrollTools(dir);
    }
    /**
     * @hidden
     */
    onRendererClick(data) {
        this.navigationService.click(data);
        this.element.nativeElement.setAttribute('tabindex', '-1');
    }
    /**
     * @hidden
     */
    overflowButtonIcon(iconType) {
        if (iconType === 'svg') {
            return this.normalizedOverflow.mode === 'section' ? moreHorizontalIcon : moreVerticalIcon;
        }
        else {
            return this.normalizedOverflow.mode === 'section' ? 'more-horizontal' : 'more-vertical';
        }
    }
    /**
     * @hidden
     */
    showPopup() {
        this.popupOpen = !this.popupOpen;
        this.navigationService.click({ context: undefined, event: undefined });
        this.overflowButtonClickedTime = Date.now();
    }
    /**
     * Toggles the visibility of the overflow popup.
     */
    toggle(popupOpen) {
        this._open = popupOpen !== undefined ? popupOpen : !this.popupOpen;
        if (this.popupRef) {
            this.popupRef.close();
            this.popupRef = null;
        }
        if (this.popupOpen) {
            let settings;
            const isSection = this.normalizedOverflow.mode === 'section';
            if (isSection) {
                settings = {
                    anchor: this.element.nativeElement,
                    content: this.popupSectionTemplate,
                    popupClass: this.normalizePopupClasses(),
                    positionMode: 'absolute'
                };
            }
            else {
                settings = {
                    anchor: this.overflowButton,
                    anchorAlign: this.popupSettings.anchorAlign,
                    popupAlign: this.popupSettings.popupAlign,
                    content: this.popupTemplate,
                    appendTo: this.appendTo,
                    animate: this.popupSettings.animate,
                    popupClass: this.normalizePopupClasses(this.popupSettings.popupClass),
                    positionMode: 'absolute'
                };
            }
            this.popupRef = this.popupService.open(settings);
            this.setPopupContentDimensions(isSection);
            this.popupSubs.add(this.popupRef.popupOpen.subscribe(this.onPopupOpen.bind(this)));
            this.popupSubs.add(this.popupRef.popupClose.subscribe(this.onPopupClose.bind(this)));
        }
    }
    /**
     * @hidden
     */
    onResize() {
        if (isDocumentAvailable()) {
            if (this.showMenu) {
                const containerWidth = innerWidth(this.element.nativeElement) - this.overflowAnchorWidth;
                this.shrink(containerWidth, this.childrenWidth);
                this.stretch(containerWidth, this.childrenWidth);
                this.displayAnchor();
                const isImmediateResize = (Date.now() - this.overflowButtonClickedTime) < immediateResizeThreshold;
                if (this.popupOpen && !isImmediateResize) {
                    const eventArgs = new PreventableEvent();
                    this.close.emit(eventArgs);
                    if (eventArgs.isDefaultPrevented()) {
                        return;
                    }
                    this.toggle();
                }
            }
            else if (this.isScrollMode) {
                if (this.normalizedOverflow.scrollButtons === 'auto') {
                    const containerWidth = innerWidth(this.element.nativeElement);
                    let scrollButtonsWidth = 0;
                    if (this.showAutoButtons) {
                        const separatorWidth = this.scrollSeparator.nativeElement.getBoundingClientRect().width + 2 * this.gap;
                        if (this.hasScrollButtons.position === 'split') {
                            scrollButtonsWidth = innerWidth(this.prevScrollButton.nativeElement) + innerWidth(this.nextScrollButton.nativeElement) + 2 * separatorWidth;
                        }
                        else if (this.hasScrollButtons.position === 'end') {
                            scrollButtonsWidth = innerWidth(this.endButtonGroup.nativeElement) + separatorWidth;
                        }
                        else {
                            scrollButtonsWidth = innerWidth(this.startButtonGroup.nativeElement) + separatorWidth;
                        }
                    }
                    const shouldShowButtons = (this.childrenWidth + scrollButtonsWidth) > containerWidth;
                    if (shouldShowButtons !== this.showAutoButtons) {
                        this.showAutoButtons = shouldShowButtons;
                        this.cdr.detectChanges();
                    }
                    this.scrollService.toggleScrollButtonsState();
                }
                else if (!this.hasScrollButtons.visible) {
                    this.setScrollableOverlayClasses();
                }
                else if (!this.scrollService.toolsOverflow) {
                    this.renderer.addClass(this.nextScrollButton.nativeElement, 'k-disabled');
                    this.renderer.addClass(this.prevScrollButton.nativeElement, 'k-disabled');
                }
                else {
                    this.scrollService.toggleScrollButtonsState();
                }
            }
            this.resizeSensor?.acceptSize();
        }
    }
    /**
     * @hidden
     */
    onPopupOpen() {
        this.zone.runOutsideAngular(() => {
            if (this.normalizedOverflow.mode === 'section') {
                this.sectionKeydownListener = this.renderer.listen(this.popupRef.popupElement, 'keydown', (ev) => {
                    const code = normalizeKeys(ev);
                    switch (code) {
                        case Keys.ArrowLeft:
                            this.zone.run(() => {
                                ev.preventDefault();
                                if (this.direction === 'ltr') {
                                    this.navigationService.focusPrev(ev);
                                }
                                else {
                                    this.navigationService.focusNext(ev);
                                }
                                // prevents ExpressionChangedAfterItHasBeenCheckedError when tools with popup are opened/closed asynchronously
                                this.element.nativeElement.setAttribute('tabindex', '-1');
                            });
                            break;
                        case Keys.ArrowRight:
                            this.zone.run(() => {
                                ev.preventDefault();
                                if (this.direction === 'ltr') {
                                    this.navigationService.focusNext(ev);
                                }
                                else {
                                    this.navigationService.focusPrev(ev);
                                }
                                // prevents ExpressionChangedAfterItHasBeenCheckedError when tools with popup are opened/closed asynchronously
                                this.element.nativeElement.setAttribute('tabindex', '-1');
                            });
                            break;
                        case Keys.Escape: {
                            this.zone.run(() => this.toggle(false));
                            const eventArgs = new PreventableEvent();
                            this.close.emit(eventArgs);
                            break;
                        }
                        case Keys.Tab:
                            this.zone.run(() => {
                                this.toggle(false);
                                this.navigationService.resetNavigation();
                            });
                            break;
                        default:
                            break;
                    }
                });
            }
            else {
                this.overflowKeydownListener = this.renderer.listen(this.popupRef.popupElement, 'keydown', (ev) => {
                    const code = normalizeKeys(ev);
                    switch (code) {
                        case Keys.ArrowUp:
                            this.zone.run(() => {
                                ev.preventDefault();
                                this.navigationService.focusPrev(ev);
                            });
                            break;
                        case Keys.ArrowDown:
                            this.zone.run(() => {
                                ev.preventDefault();
                                this.navigationService.focusNext(ev);
                            });
                            break;
                        case Keys.Escape: {
                            this.zone.run(() => this.toggle(false));
                            const eventArgs = new PreventableEvent();
                            this.close.emit(eventArgs);
                            break;
                        }
                        case Keys.Tab:
                            this.zone.run(() => {
                                this.toggle(false);
                                this.navigationService.resetNavigation();
                            });
                            break;
                        case Keys.NumpadEnter:
                        case Keys.Enter:
                        case Keys.Space:
                            this.zone.run(() => {
                                if (ev.target.closest('.k-menu-item')) {
                                    ev.preventDefault();
                                    ev.target.click();
                                    ev.target.focus();
                                }
                            });
                            break;
                        default:
                            break;
                    }
                });
            }
        });
        this.cancelRenderedToolsSubscription$.next(undefined);
        this.navigationService.setRenderedTools(this.toolsService.overflowTools);
        this.navigationService.moveFocusToPopup();
        this.toolsService.overflowToolsChange
            .pipe(takeUntil(this.cancelRenderedToolsSubscription$))
            .subscribe((rts) => this.navigationService.setRenderedTools(rts));
        this.renderer.setAttribute(this.overflowButton.nativeElement, 'aria-controls', this.popupId);
    }
    /**
     * @hidden
     */
    onPopupClose() {
        this.cancelRenderedToolsSubscription$.next(undefined);
        this.navigationService.setRenderedTools(this.toolsService.renderedTools);
        this.toolsService.renderedToolsChange
            .pipe(takeUntil(this.cancelRenderedToolsSubscription$))
            .subscribe((rts) => this.navigationService.setRenderedTools(rts));
        this.navigationService.moveFocusToToolBar();
        if (this.overflowKeydownListener) {
            this.overflowKeydownListener();
        }
        if (this.sectionKeydownListener) {
            this.sectionKeydownListener();
        }
        this.renderer.removeAttribute(this.overflowButton.nativeElement, 'aria-controls');
    }
    /**
     * @hidden
     */
    overflowBtnId = guid();
    /**
     * @hidden
     */
    popupId = guid();
    displayAnchor() {
        const visibility = this.allTools.filter(t => t.overflows && t.responsive).length > 0 ? 'visible' : 'hidden';
        this.overflowButton && this.renderer.setStyle(this.overflowButton.nativeElement, 'visibility', visibility);
        const isVisible = visibility === 'visible';
        if (isVisible !== this.showOverflowSeparator) {
            this.showOverflowSeparator = isVisible;
            this.cdr.detectChanges();
        }
        if (!isVisible) {
            this.destroyPopup();
        }
    }
    get popupWidth() {
        if (!this.popupSettings || !this.popupSettings.width) {
            return 'auto';
        }
        return isNaN(this.popupSettings.width) ? this.popupSettings.width : `${this.popupSettings.width}px`;
    }
    get popupHeight() {
        if (!this.popupSettings || !this.popupSettings.height) {
            return;
        }
        return isNaN(this.popupSettings.height) ? this.popupSettings.height : `${this.popupSettings.height}px`;
    }
    get overflowAnchorWidth() {
        if (!this.showMenu) {
            return 0;
        }
        if (!this.cachedOverflowAnchorWidth) {
            this.cachedOverflowAnchorWidth = this.overflowButton.nativeElement.offsetWidth;
        }
        return this.cachedOverflowAnchorWidth;
    }
    get gap() {
        if (isPresent(this.cachedGap)) {
            return this.cachedGap;
        }
        const computedGap = getComputedStyle(this.element.nativeElement).gap;
        this.cachedGap = isPresent(computedGap) ? parseInt(computedGap, 10) : 0;
        return this.cachedGap;
    }
    get childrenWidth() {
        const width = this.toolsService.renderedTools.reduce((totalWidth, tool) => tool.width + totalWidth + (tool.isDisplayed() ? this.gap : 0), 0);
        return Math.ceil(width);
    }
    get visibleTools() {
        return this.allTools.filter((tool) => {
            return tool.overflows === false;
        });
    }
    get overflowTools() {
        return this.allTools.filter((tool) => {
            return tool.overflows === true;
        });
    }
    shrink(containerWidth, childrenWidth) {
        let width;
        if (containerWidth < childrenWidth) {
            for (let i = this.visibleTools.length - 1; i >= 0; i--) {
                if (containerWidth > childrenWidth) {
                    break;
                }
                else {
                    width = this.hideLastVisibleTool();
                    childrenWidth -= width;
                }
            }
        }
    }
    stretch(containerWidth, childrenWidth) {
        let width;
        if (containerWidth > childrenWidth) {
            for (let i = this.overflowTools.length - 1; i >= 0; i--) {
                width = this.showFirstHiddenTool(containerWidth, childrenWidth);
                if (width > 0) {
                    childrenWidth += width + this.gap;
                }
                else if (width === 0) {
                    break;
                }
            }
        }
    }
    hideLastVisibleTool() {
        const tool = this.visibleTools[this.visibleTools.length - 1];
        if (!tool) {
            return null;
        }
        const renderedElement = this.toolsService.renderedTools.find((r) => {
            return r.tool === tool;
        });
        const width = renderedElement.width;
        tool.overflows = this.showMenu;
        this.refreshService.refresh(tool);
        return width;
    }
    showFirstHiddenTool(containerWidth, childrenWidth) {
        const tool = this.overflowTools[0];
        if (!tool) {
            return null;
        }
        const renderedElement = this.toolsService.renderedTools.find((r) => r.tool === tool);
        tool.overflows = false;
        tool.visibility = 'hidden';
        this.refreshService.refresh(tool);
        if (containerWidth > childrenWidth + renderedElement.width) {
            tool.visibility = 'visible';
        }
        else {
            tool.overflows = true;
        }
        this.refreshService.refresh(tool);
        return tool.isHidden ? -1 : renderedElement.width; // returns 0 if `overflows` is true and -1 if the tool is hidden
    }
    setPopupContentDimensions(isSection) {
        const popupContentContainer = this.popupRef.popup.instance.contentContainer.nativeElement;
        if (isSection) {
            const toolbarWidth = this.element.nativeElement.getBoundingClientRect().width;
            popupContentContainer.style.width = `${toolbarWidth}px`;
        }
        else {
            popupContentContainer.style.width = this.popupWidth;
            popupContentContainer.style.height = this.popupHeight;
            popupContentContainer.style.overflow = 'auto';
        }
    }
    destroyPopup() {
        if (this.popupRef) {
            this.popupSubs.unsubscribe();
            this.popupRef.close();
            this.popupRef = null;
            this._open = false;
        }
    }
    handleClasses(value, input) {
        const elem = this.element.nativeElement;
        const classes = getStylingClasses('toolbar', input, this[input], value);
        if (classes.toRemove) {
            this.renderer.removeClass(elem, classes.toRemove);
        }
        if (classes.toAdd) {
            this.renderer.addClass(elem, classes.toAdd);
        }
    }
    normalizePopupClasses(classList) {
        const classes = ['k-toolbar-popup'];
        if (this.normalizedOverflow.mode === 'menu') {
            classes.push('k-menu-popup');
        }
        if (!classList) {
            return classes;
        }
        const parsedClassList = parseCSSClassNames(classList);
        if (parsedClassList.length) {
            classes.push(...parsedClassList);
        }
        return classes;
    }
    setScrollableOverlayClasses() {
        const wrapper = this.element.nativeElement;
        const container = this.scrollContainer?.nativeElement;
        if (!container) {
            return;
        }
        const scrollOffset = container.scrollLeft;
        const defaultOffset = 1;
        if (this.scrollService.toolsOverflow && !this.hasScrollButtons.visible) {
            this.renderer.addClass(wrapper, 'k-toolbar-scrollable-overlay');
            if (scrollOffset === 0) {
                this.renderer.removeClass(wrapper, 'k-toolbar-scrollable-end');
                this.renderer.addClass(wrapper, 'k-toolbar-scrollable-start');
            }
            else if ((scrollOffset > 0 && scrollOffset < this.scrollService.scrollContainerOverflowSize - defaultOffset) || (scrollOffset < 0 && Math.abs(scrollOffset) < this.scrollService.scrollContainerOverflowSize - defaultOffset)) {
                this.renderer.removeClass(wrapper, 'k-toolbar-scrollable-end');
                this.renderer.removeClass(wrapper, 'k-toolbar-scrollable-start');
            }
            else {
                this.renderer.removeClass(wrapper, 'k-toolbar-scrollable-start');
                this.renderer.addClass(wrapper, 'k-toolbar-scrollable-end');
            }
        }
        else {
            this.renderer.removeClass(wrapper, 'k-toolbar-scrollable-overlay');
            this.renderer.removeClass(wrapper, 'k-toolbar-scrollable-end');
            this.renderer.removeClass(wrapper, 'k-toolbar-scrollable-start');
        }
    }
    handleScrollModeUpdates() {
        if (isPresent(this.scrollContainer)) {
            this.scrollService.updateScrollPosition(this.scrollContainer.nativeElement);
            this.zone.runOutsideAngular(() => {
                this.scrollContainerScrollSub = this.renderer.listen(this.scrollContainer.nativeElement, 'scroll', (e) => {
                    if (!this.hasScrollButtons.visible) {
                        this.setScrollableOverlayClasses();
                    }
                    else {
                        this.scrollService.onScroll(e);
                    }
                });
                this.subscriptions.add(this.scrollContainerScrollSub);
            });
        }
        if (this.showScrollButtons && this.nextScrollButton && this.prevScrollButton) {
            if (this.normalizedOverflow.scrollButtons === 'visible' && !this.scrollService.toolsOverflow) {
                this.renderer.addClass(this.nextScrollButton.nativeElement, 'k-disabled');
                this.renderer.addClass(this.prevScrollButton.nativeElement, 'k-disabled');
            }
            else {
                const buttonToDisable = this.direction === 'rtl' ? this.nextScrollButton : this.prevScrollButton;
                this.renderer.addClass(buttonToDisable.nativeElement, 'k-disabled');
            }
        }
        if (this.hasScrollButtons.visible) {
            this.scrollButtonStateChangeSub = this.scrollService.scrollButtonActiveStateChange.subscribe((activeButtonSettings) => {
                if (this.showScrollButtons) {
                    const action = activeButtonSettings.active ? 'remove' : 'add';
                    const scrollButton = this[`${activeButtonSettings.buttonType}ScrollButton`]?.nativeElement;
                    scrollButton && this.renderer[`${action}Class`](scrollButton, 'k-disabled');
                }
            });
            this.subscriptions.add(this.scrollButtonStateChangeSub);
            this.scrollService.toggleScrollButtonsState();
        }
    }
    removeSubscriptions(subsToRemove) {
        subsToRemove.forEach((sub) => {
            if (this[sub]) {
                this.subscriptions.remove(this[sub]);
                this[sub] = null;
            }
        });
    }
    normalizeDisplayValue(value) {
        if (typeof value === 'boolean') {
            return value ? 'always' : 'never';
        }
        return value;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ToolBarComponent, deps: [{ token: i1.LocalizationService }, { token: i2.PopupService }, { token: RefreshService }, { token: NavigationService }, { token: i0.ElementRef }, { token: i0.NgZone }, { token: i0.Renderer2 }, { token: i0.ChangeDetectorRef }, { token: ToolbarToolsService }, { token: ScrollService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: ToolBarComponent, isStandalone: true, selector: "kendo-toolbar", inputs: { overflow: "overflow", resizable: "resizable", popupSettings: "popupSettings", fillMode: "fillMode", tabindex: "tabindex", size: "size", tabIndex: "tabIndex", showIcon: "showIcon", showText: "showText" }, outputs: { open: "open", close: "close" }, host: { listeners: { "focus": "onFocus($event)", "focusout": "onFocusOut($event)" }, properties: { "class.k-toolbar": "this.hostClass", "class.k-toolbar-scrollable": "this.scrollableClass", "class.k-toolbar-section": "this.sectionClass", "attr.role": "this.role", "attr.dir": "this.getDir", "class.k-toolbar-resizable": "this.resizableClass" } }, providers: [
            RefreshService,
            NavigationService,
            LocalizationService,
            ToolbarToolsService,
            ScrollService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.toolbar'
            }
        ], queries: [{ propertyName: "allTools", predicate: ToolBarToolComponent }], viewQueries: [{ propertyName: "overflowButton", first: true, predicate: ["overflowButton"], descendants: true, read: ElementRef }, { propertyName: "popupTemplate", first: true, predicate: ["popupTemplate"], descendants: true, static: true }, { propertyName: "popupSectionTemplate", first: true, predicate: ["popupSectionTemplate"], descendants: true, static: true }, { propertyName: "scrollContainer", first: true, predicate: ["scrollContainer"], descendants: true, read: ElementRef }, { propertyName: "resizeSensor", first: true, predicate: ["resizeSensor"], descendants: true }, { propertyName: "container", first: true, predicate: ["container"], descendants: true, read: ViewContainerRef, static: true }, { propertyName: "prevScrollButton", first: true, predicate: ["prevScrollButton"], descendants: true, read: ElementRef }, { propertyName: "nextScrollButton", first: true, predicate: ["nextScrollButton"], descendants: true, read: ElementRef }, { propertyName: "startButtonGroup", first: true, predicate: ["startButtonGroup"], descendants: true, read: ElementRef }, { propertyName: "endButtonGroup", first: true, predicate: ["endButtonGroup"], descendants: true, read: ElementRef }, { propertyName: "scrollSeparator", first: true, predicate: ["scrollSeparator"], descendants: true, read: ElementRef }], exportAs: ["kendoToolBar"], usesOnChanges: true, ngImport: i0, template: `
        <ng-container kendoToolbarLocalizedMessages
            i18n-moreToolsTitle="kendo.toolbar.moreToolsTitle|The title of the **more tools** button in a responsive ToolBar"
            moreToolsTitle="More tools"

            i18n-previousToolButton="kendo.toolbar.previousToolButton|The title for the **Previous Tool** button when the Toolbar is scrollable."
            previousToolButton="Scroll left"

            i18n-nextToolButton="kendo.toolbar.nextToolButton|The title for the **Next Tool** button when the Toolbar is scrollable."
            nextToolButton="Scroll right"
        >
        </ng-container>
        @if (showScrollButtons && (hasScrollButtons.position === 'split' || hasScrollButtons.position === 'start')) {
            @if (hasScrollButtons.position === 'split') {
                <span #prevScrollButton
                    kendoToolbarScrollableButton
                    [prev]="true"
                    [overflow]="normalizedOverflow"
                    [title]="getScrollButtonTitle('prev')"
                    class="k-toolbar-prev k-icon-button k-button k-button-solid k-button-solid-base k-rounded-md"
                    [ngClass]="{
                        'k-button-sm': size === 'small',
                        'k-button-md': size === 'medium' || !size,
                        'k-button-lg': size === 'large'
                    }"
                    (onClick)="scrollTools($event)">
                </span>
            }
            @if (hasScrollButtons.position === 'start') {
                <div class="k-button-group k-button-group-solid" #startButtonGroup>
                <span #prevScrollButton
                    kendoToolbarScrollableButton
                    [prev]="true"
                    [overflow]="normalizedOverflow"
                    [title]="getScrollButtonTitle('prev')"
                    class="k-toolbar-prev k-icon-button k-button k-button-solid k-button-solid-base k-rounded-md"
                    [ngClass]="{
                        'k-button-sm': size === 'small',
                        'k-button-md': size === 'medium' || !size,
                        'k-button-lg': size === 'large'
                    }"
                    (onClick)="scrollTools($event)">
                </span>
                <span #nextScrollButton
                    kendoToolbarScrollableButton
                    [prev]="false"
                    [overflow]="normalizedOverflow"
                    [title]="getScrollButtonTitle('next')"
                    class="k-toolbar-next k-icon-button k-button k-button-solid k-button-solid-base k-rounded-md"
                    [ngClass]="{
                        'k-button-sm': size === 'small',
                        'k-button-md': size === 'medium' || !size,
                        'k-button-lg': size === 'large'
                    }"
                    (onClick)="scrollTools($event)">
                </span>
            </div>
            }
            <div class="k-toolbar-separator k-toolbar-button-separator k-separator" #scrollSeparator></div>
        }
        @if (isScrollMode) {
            <div class="k-toolbar-items k-toolbar-items-scroll" tabindex="-1" #scrollContainer>
                @for (tool of allTools; track tool; let index = $index) {
                    <ng-container
                kendoToolbarRenderer
                [tool]="tool"
                location="toolbar"
                [resizable]="resizable"
                (rendererClick)="onRendererClick($event)"
                [ngTemplateOutlet]="tool.isBuiltInTool ? tool.toolbarTemplate : wrapper">
                <ng-template #wrapper>
                    <div class="k-toolbar-item">
                        <ng-container [ngTemplateOutlet]="tool.toolbarTemplate"></ng-container>
                    </div>
                </ng-template>
            </ng-container>
            }
        </div>
        } @else {
            @for (tool of allTools; track tool; let index = $index) {
                <ng-container
                kendoToolbarRenderer
                [tool]="tool"
                location="toolbar"
                [resizable]="resizable"
                (rendererClick)="onRendererClick($event)"
                [ngTemplateOutlet]="tool.isBuiltInTool ? tool.toolbarTemplate : wrapper">
                <ng-template #wrapper>
                    <div class="k-toolbar-item">
                        <ng-container [ngTemplateOutlet]="tool.toolbarTemplate"></ng-container>
                    </div>
                </ng-template>
            </ng-container>
            }
        }
        @if (showOverflowSeparator) {
            <div class="k-toolbar-separator k-toolbar-button-separator k-separator"></div>
        }
        @if (showMenu) {
            <button
            kendoButton
            fillMode="flat"
            #overflowButton
            type="button"
            [icon]="overflowButtonIcon('font')"
            [svgIcon]="overflowButtonIcon('svg')"
            tabindex="-1"
            [title]="moreToolsTitle"
            [attr.aria-label]="moreToolsTitle"
            [attr.aria-expanded]="popupOpen"
            [id]="overflowBtnId"
            [attr.aria-haspopup]="normalizedOverflow.mode === 'section' ? null : 'menu'"
            [style.visibility]="'hidden'"
            [style.position]="'relative'"
            class="k-toolbar-overflow-button"
            [ngClass]="overflowClass"
            (click)="showPopup()"
        >
        </button>
        }
        @if (showScrollButtons && (hasScrollButtons.position === 'split' || hasScrollButtons.position === 'end')) {
            <div class="k-toolbar-separator k-toolbar-button-separator k-separator" #scrollSeparator></div>
            @if (hasScrollButtons.position === 'split') {
                <span #nextScrollButton
                kendoToolbarScrollableButton
                [prev]="false"
                [overflow]="normalizedOverflow"
                [title]="getScrollButtonTitle('next')"
                class="k-toolbar-next k-icon-button k-button k-button-solid k-button-solid-base k-rounded-md"
                [ngClass]="{
                    'k-button-sm': size === 'small',
                    'k-button-md': size === 'medium' || !size,
                    'k-button-lg': size === 'large'
                }"
                (onClick)="scrollTools($event)">
            </span>
            }
            @if (hasScrollButtons.position === 'end') {
                <div class="k-button-group k-button-group-solid" #endButtonGroup>
                <span #prevScrollButton
                    kendoToolbarScrollableButton
                    [prev]="true"
                    [overflow]="normalizedOverflow"
                    [title]="getScrollButtonTitle('prev')"
                    class="k-toolbar-prev k-icon-button k-button k-button-solid k-button-solid-base k-rounded-md"
                    [ngClass]="{
                        'k-button-sm': size === 'small',
                        'k-button-md': size === 'medium' || !size,
                        'k-button-lg': size === 'large'
                    }"
                    (onClick)="scrollTools($event)">
                </span>
                <span #nextScrollButton
                    kendoToolbarScrollableButton
                    [prev]="false"
                    [overflow]="normalizedOverflow"
                    [title]="getScrollButtonTitle('next')"
                    class="k-toolbar-next k-icon-button k-button k-button-solid k-button-solid-base k-rounded-md"
                    [ngClass]="{
                        'k-button-sm': size === 'small',
                        'k-button-md': size === 'medium' || !size,
                        'k-button-lg': size === 'large'
                    }"
                    (onClick)="scrollTools($event)">
                </span>
            </div>
            }
        }
        <ng-template #popupTemplate>
            <div
                class="k-menu-group k-menu-group-md"
                role="menu"
                [id]="popupId"
                [attr.dir]="direction === 'rtl' ? 'rtl' : null"
                [attr.aria-labelledby]="overflowBtnId">
                @for (tool of overflowTools; track tool; let index = $index) {
                    @if (tool.popupTemplate) {
                        <ng-template
                            kendoToolbarRenderer
                            [tool]="tool"
                            location="overflow"
                            [resizable]="resizable"
                            (rendererClick)="onRendererClick($event)"
                            [ngTemplateOutlet]="tool.isBuiltInTool ? tool.popupTemplate : popupWrapper"></ng-template>
                    }
                    <ng-template #popupWrapper>
                        <div role="menuitem" tabindex="-1" class="k-item k-menu-item">
                            <ng-container [ngTemplateOutlet]="tool.popupTemplate"></ng-container>
                        </div>
                    </ng-template>
                }
            </div>
        </ng-template>
        <ng-template #popupSectionTemplate>
            <span class="k-toolbar-items-list k-toolbar-items-list-solid"
                [ngClass]="sectionSizeClass"
                role="toolbar"
                [id]="popupId"
                [attr.dir]="direction === 'rtl' ? 'rtl' : null"
                [attr.aria-labelledby]="overflowBtnId">
                @for (tool of overflowTools; track tool; let index = $index) {
                    <ng-container
                        kendoToolbarRenderer
                        [tool]="tool"
                        location="section"
                        [resizable]="resizable"
                        (rendererClick)="onRendererClick($event)"
                        [ngTemplateOutlet]="tool.isBuiltInTool ? tool.sectionTemplate : wrapper">
                        <ng-template #wrapper>
                            <ng-container [ngTemplateOutlet]="tool.sectionTemplate"></ng-container>
                        </ng-template>
                    </ng-container>
                }
            </span>
        </ng-template>
        <ng-container #container></ng-container>
        @if (overflowEnabled) {
            <kendo-resize-sensor #resizeSensor></kendo-resize-sensor>
        }
    `, isInline: true, dependencies: [{ kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: LocalizedToolbarMessagesDirective, selector: "[kendoToolbarLocalizedMessages]" }, { kind: "directive", type: ToolBarRendererComponent, selector: "[kendoToolbarRenderer]", inputs: ["tool", "location", "resizable"], outputs: ["rendererClick"] }, { kind: "component", type: ButtonComponent, selector: "button[kendoButton]", inputs: ["arrowIcon", "toggleable", "togglable", "selected", "tabIndex", "imageUrl", "iconClass", "icon", "disabled", "size", "rounded", "fillMode", "themeColor", "svgIcon", "primary", "look"], outputs: ["selectedChange", "click"], exportAs: ["kendoButton"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "component", type: ResizeSensorComponent, selector: "kendo-resize-sensor", inputs: ["rateLimit"], outputs: ["resize"] }, { kind: "component", type: ToolbarScrollableButtonComponent, selector: "[kendoToolbarScrollableButton]", inputs: ["prev", "overflow"], outputs: ["onClick"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ToolBarComponent, decorators: [{
            type: Component,
            args: [{
                    exportAs: 'kendoToolBar',
                    providers: [
                        RefreshService,
                        NavigationService,
                        LocalizationService,
                        ToolbarToolsService,
                        ScrollService,
                        {
                            provide: L10N_PREFIX,
                            useValue: 'kendo.toolbar'
                        }
                    ],
                    selector: 'kendo-toolbar',
                    template: `
        <ng-container kendoToolbarLocalizedMessages
            i18n-moreToolsTitle="kendo.toolbar.moreToolsTitle|The title of the **more tools** button in a responsive ToolBar"
            moreToolsTitle="More tools"

            i18n-previousToolButton="kendo.toolbar.previousToolButton|The title for the **Previous Tool** button when the Toolbar is scrollable."
            previousToolButton="Scroll left"

            i18n-nextToolButton="kendo.toolbar.nextToolButton|The title for the **Next Tool** button when the Toolbar is scrollable."
            nextToolButton="Scroll right"
        >
        </ng-container>
        @if (showScrollButtons && (hasScrollButtons.position === 'split' || hasScrollButtons.position === 'start')) {
            @if (hasScrollButtons.position === 'split') {
                <span #prevScrollButton
                    kendoToolbarScrollableButton
                    [prev]="true"
                    [overflow]="normalizedOverflow"
                    [title]="getScrollButtonTitle('prev')"
                    class="k-toolbar-prev k-icon-button k-button k-button-solid k-button-solid-base k-rounded-md"
                    [ngClass]="{
                        'k-button-sm': size === 'small',
                        'k-button-md': size === 'medium' || !size,
                        'k-button-lg': size === 'large'
                    }"
                    (onClick)="scrollTools($event)">
                </span>
            }
            @if (hasScrollButtons.position === 'start') {
                <div class="k-button-group k-button-group-solid" #startButtonGroup>
                <span #prevScrollButton
                    kendoToolbarScrollableButton
                    [prev]="true"
                    [overflow]="normalizedOverflow"
                    [title]="getScrollButtonTitle('prev')"
                    class="k-toolbar-prev k-icon-button k-button k-button-solid k-button-solid-base k-rounded-md"
                    [ngClass]="{
                        'k-button-sm': size === 'small',
                        'k-button-md': size === 'medium' || !size,
                        'k-button-lg': size === 'large'
                    }"
                    (onClick)="scrollTools($event)">
                </span>
                <span #nextScrollButton
                    kendoToolbarScrollableButton
                    [prev]="false"
                    [overflow]="normalizedOverflow"
                    [title]="getScrollButtonTitle('next')"
                    class="k-toolbar-next k-icon-button k-button k-button-solid k-button-solid-base k-rounded-md"
                    [ngClass]="{
                        'k-button-sm': size === 'small',
                        'k-button-md': size === 'medium' || !size,
                        'k-button-lg': size === 'large'
                    }"
                    (onClick)="scrollTools($event)">
                </span>
            </div>
            }
            <div class="k-toolbar-separator k-toolbar-button-separator k-separator" #scrollSeparator></div>
        }
        @if (isScrollMode) {
            <div class="k-toolbar-items k-toolbar-items-scroll" tabindex="-1" #scrollContainer>
                @for (tool of allTools; track tool; let index = $index) {
                    <ng-container
                kendoToolbarRenderer
                [tool]="tool"
                location="toolbar"
                [resizable]="resizable"
                (rendererClick)="onRendererClick($event)"
                [ngTemplateOutlet]="tool.isBuiltInTool ? tool.toolbarTemplate : wrapper">
                <ng-template #wrapper>
                    <div class="k-toolbar-item">
                        <ng-container [ngTemplateOutlet]="tool.toolbarTemplate"></ng-container>
                    </div>
                </ng-template>
            </ng-container>
            }
        </div>
        } @else {
            @for (tool of allTools; track tool; let index = $index) {
                <ng-container
                kendoToolbarRenderer
                [tool]="tool"
                location="toolbar"
                [resizable]="resizable"
                (rendererClick)="onRendererClick($event)"
                [ngTemplateOutlet]="tool.isBuiltInTool ? tool.toolbarTemplate : wrapper">
                <ng-template #wrapper>
                    <div class="k-toolbar-item">
                        <ng-container [ngTemplateOutlet]="tool.toolbarTemplate"></ng-container>
                    </div>
                </ng-template>
            </ng-container>
            }
        }
        @if (showOverflowSeparator) {
            <div class="k-toolbar-separator k-toolbar-button-separator k-separator"></div>
        }
        @if (showMenu) {
            <button
            kendoButton
            fillMode="flat"
            #overflowButton
            type="button"
            [icon]="overflowButtonIcon('font')"
            [svgIcon]="overflowButtonIcon('svg')"
            tabindex="-1"
            [title]="moreToolsTitle"
            [attr.aria-label]="moreToolsTitle"
            [attr.aria-expanded]="popupOpen"
            [id]="overflowBtnId"
            [attr.aria-haspopup]="normalizedOverflow.mode === 'section' ? null : 'menu'"
            [style.visibility]="'hidden'"
            [style.position]="'relative'"
            class="k-toolbar-overflow-button"
            [ngClass]="overflowClass"
            (click)="showPopup()"
        >
        </button>
        }
        @if (showScrollButtons && (hasScrollButtons.position === 'split' || hasScrollButtons.position === 'end')) {
            <div class="k-toolbar-separator k-toolbar-button-separator k-separator" #scrollSeparator></div>
            @if (hasScrollButtons.position === 'split') {
                <span #nextScrollButton
                kendoToolbarScrollableButton
                [prev]="false"
                [overflow]="normalizedOverflow"
                [title]="getScrollButtonTitle('next')"
                class="k-toolbar-next k-icon-button k-button k-button-solid k-button-solid-base k-rounded-md"
                [ngClass]="{
                    'k-button-sm': size === 'small',
                    'k-button-md': size === 'medium' || !size,
                    'k-button-lg': size === 'large'
                }"
                (onClick)="scrollTools($event)">
            </span>
            }
            @if (hasScrollButtons.position === 'end') {
                <div class="k-button-group k-button-group-solid" #endButtonGroup>
                <span #prevScrollButton
                    kendoToolbarScrollableButton
                    [prev]="true"
                    [overflow]="normalizedOverflow"
                    [title]="getScrollButtonTitle('prev')"
                    class="k-toolbar-prev k-icon-button k-button k-button-solid k-button-solid-base k-rounded-md"
                    [ngClass]="{
                        'k-button-sm': size === 'small',
                        'k-button-md': size === 'medium' || !size,
                        'k-button-lg': size === 'large'
                    }"
                    (onClick)="scrollTools($event)">
                </span>
                <span #nextScrollButton
                    kendoToolbarScrollableButton
                    [prev]="false"
                    [overflow]="normalizedOverflow"
                    [title]="getScrollButtonTitle('next')"
                    class="k-toolbar-next k-icon-button k-button k-button-solid k-button-solid-base k-rounded-md"
                    [ngClass]="{
                        'k-button-sm': size === 'small',
                        'k-button-md': size === 'medium' || !size,
                        'k-button-lg': size === 'large'
                    }"
                    (onClick)="scrollTools($event)">
                </span>
            </div>
            }
        }
        <ng-template #popupTemplate>
            <div
                class="k-menu-group k-menu-group-md"
                role="menu"
                [id]="popupId"
                [attr.dir]="direction === 'rtl' ? 'rtl' : null"
                [attr.aria-labelledby]="overflowBtnId">
                @for (tool of overflowTools; track tool; let index = $index) {
                    @if (tool.popupTemplate) {
                        <ng-template
                            kendoToolbarRenderer
                            [tool]="tool"
                            location="overflow"
                            [resizable]="resizable"
                            (rendererClick)="onRendererClick($event)"
                            [ngTemplateOutlet]="tool.isBuiltInTool ? tool.popupTemplate : popupWrapper"></ng-template>
                    }
                    <ng-template #popupWrapper>
                        <div role="menuitem" tabindex="-1" class="k-item k-menu-item">
                            <ng-container [ngTemplateOutlet]="tool.popupTemplate"></ng-container>
                        </div>
                    </ng-template>
                }
            </div>
        </ng-template>
        <ng-template #popupSectionTemplate>
            <span class="k-toolbar-items-list k-toolbar-items-list-solid"
                [ngClass]="sectionSizeClass"
                role="toolbar"
                [id]="popupId"
                [attr.dir]="direction === 'rtl' ? 'rtl' : null"
                [attr.aria-labelledby]="overflowBtnId">
                @for (tool of overflowTools; track tool; let index = $index) {
                    <ng-container
                        kendoToolbarRenderer
                        [tool]="tool"
                        location="section"
                        [resizable]="resizable"
                        (rendererClick)="onRendererClick($event)"
                        [ngTemplateOutlet]="tool.isBuiltInTool ? tool.sectionTemplate : wrapper">
                        <ng-template #wrapper>
                            <ng-container [ngTemplateOutlet]="tool.sectionTemplate"></ng-container>
                        </ng-template>
                    </ng-container>
                }
            </span>
        </ng-template>
        <ng-container #container></ng-container>
        @if (overflowEnabled) {
            <kendo-resize-sensor #resizeSensor></kendo-resize-sensor>
        }
    `,
                    standalone: true,
                    imports: [NgTemplateOutlet, LocalizedToolbarMessagesDirective, ToolBarRendererComponent, ButtonComponent, NgClass, ResizeSensorComponent, ToolbarScrollableButtonComponent]
                }]
        }], ctorParameters: () => [{ type: i1.LocalizationService }, { type: i2.PopupService }, { type: RefreshService }, { type: NavigationService }, { type: i0.ElementRef }, { type: i0.NgZone }, { type: i0.Renderer2 }, { type: i0.ChangeDetectorRef }, { type: ToolbarToolsService }, { type: ScrollService }], propDecorators: { overflow: [{
                type: Input
            }], resizable: [{
                type: Input
            }], popupSettings: [{
                type: Input
            }], fillMode: [{
                type: Input
            }], tabindex: [{
                type: Input
            }], size: [{
                type: Input
            }], tabIndex: [{
                type: Input,
                args: ['tabIndex']
            }], showIcon: [{
                type: Input
            }], showText: [{
                type: Input
            }], open: [{
                type: Output
            }], close: [{
                type: Output
            }], allTools: [{
                type: ContentChildren,
                args: [ToolBarToolComponent]
            }], overflowButton: [{
                type: ViewChild,
                args: ['overflowButton', { static: false, read: ElementRef }]
            }], popupTemplate: [{
                type: ViewChild,
                args: ['popupTemplate', { static: true }]
            }], popupSectionTemplate: [{
                type: ViewChild,
                args: ['popupSectionTemplate', { static: true }]
            }], scrollContainer: [{
                type: ViewChild,
                args: ['scrollContainer', { read: ElementRef, static: false }]
            }], resizeSensor: [{
                type: ViewChild,
                args: ['resizeSensor', { static: false }]
            }], container: [{
                type: ViewChild,
                args: ['container', { read: ViewContainerRef, static: true }]
            }], prevScrollButton: [{
                type: ViewChild,
                args: ['prevScrollButton', { read: ElementRef }]
            }], nextScrollButton: [{
                type: ViewChild,
                args: ['nextScrollButton', { read: ElementRef }]
            }], startButtonGroup: [{
                type: ViewChild,
                args: ['startButtonGroup', { read: ElementRef }]
            }], endButtonGroup: [{
                type: ViewChild,
                args: ['endButtonGroup', { read: ElementRef }]
            }], scrollSeparator: [{
                type: ViewChild,
                args: ['scrollSeparator', { read: ElementRef }]
            }], hostClass: [{
                type: HostBinding,
                args: ['class.k-toolbar']
            }], scrollableClass: [{
                type: HostBinding,
                args: ['class.k-toolbar-scrollable']
            }], sectionClass: [{
                type: HostBinding,
                args: ['class.k-toolbar-section']
            }], onFocus: [{
                type: HostListener,
                args: ['focus', ['$event']]
            }], onFocusOut: [{
                type: HostListener,
                args: ['focusout', ['$event']]
            }], role: [{
                type: HostBinding,
                args: ['attr.role']
            }], getDir: [{
                type: HostBinding,
                args: ['attr.dir']
            }], resizableClass: [{
                type: HostBinding,
                args: ['class.k-toolbar-resizable']
            }] } });

/**
 * Represents the [Kendo UI ToolBar Button tool for Angular]({% slug controltypes_toolbar %}#toc-buttons).
 *
 * Use this component to render a button inside the ToolBar.
 *
 *  @example
 * ```html
 * <kendo-toolbar>
 *      <kendo-toolbar-button text="Button"></kendo-toolbar-button>
 * </kendo-toolbar>
 * ```
 *
 */
class ToolBarButtonComponent extends ToolBarToolComponent {
    element;
    zone;
    host;
    // showText and showIcon showIcon should be declared first
    /**
     * Specifies the button text visibility.
     * Accepts a `DisplayMode` value.
     * @default 'always'
     */
    set showText(value) {
        this._showText = value;
        this.setTextDisplayMode();
    }
    get showText() {
        return this._showText;
    }
    /**
     * Specifies the button icon visibility.
     * Accepts a `DisplayMode` value.
     * @default 'always'
     */
    set showIcon(value) {
        this._showIcon = value;
        this.setTextDisplayMode();
    }
    get showIcon() {
        return this._showIcon;
    }
    /**
     * Specifies the text of the Button
     * ([see example]({% slug controltypes_toolbar %}#toc-buttons)).
     */
    set text(text) {
        this._text = text;
        this.setTextDisplayMode();
    }
    get text() {
        return this._text;
    }
    /**
     * @hidden
     */
    get size() {
        return this.host.size;
    }
    /**
     * Specifies custom inline CSS styles for the Button.
     */
    style;
    /**
     * Specifies custom CSS class names to be added to the Button.
     */
    className;
    /**
     * Specifies the `title` attribute of the Button.
     */
    title;
    /**
     * Disables the Button when set to `true`
     * ([see example]({% slug controltypes_toolbar %}#toc-buttons)).
     */
    disabled;
    /**
     * Provides visual styling to indicate if the Button is active
     * ([see example]({% slug controltypes_toolbar %}#toc-toggle-buttons)).
     * For toggleable buttons, set this to `true`.
     * @default false
     */
    toggleable = false;
    /**
     * @hidden
     */
    set look(look) {
        if (look) {
            this.fillMode = look === 'default' ? 'solid' : look;
        }
    }
    /**
     * @hidden
     */
    get togglable() {
        return this.toggleable;
    }
    set togglable(value) {
        this.toggleable = value;
    }
    /**
     * Sets the selected state of the Button.
     * Use with the `toggleable` property.
     * @default false
     */
    selected = false;
    /**
     * Specifies the background and border styles of the Button.
     * Accepts a `ButtonFillMode` value.
     * @default 'solid'
     */
    fillMode = 'solid';
    /**
     * Specifies the border radius of the Button.
     * Accepts a `ButtonRounded` value.
     *
     * @default 'medium'
     */
    rounded = 'medium';
    /**
     * Specifies the predefined theme color of the Button.
     * Accepts a `ButtonThemeColor` value.
     * @default 'base'
     */
    themeColor = 'base';
    /**
     * Defines the name for an existing icon in a Kendo UI theme
     * ([see example]({% slug controltypes_toolbar %}#toc-buttons)).
     * The icon is rendered inside the Button by a `span.k-icon` element.
     */
    set icon(icon) {
        this.toolbarOptions.icon = getValueForLocation(icon, this.showIcon, false);
        this.overflowOptions.icon = getValueForLocation(icon, this.showIcon, true);
    }
    /**
     * Defines a CSS class or multiple classes to be applied to a `span` element inside the Button.
     * Allows the usage of custom icons.
     */
    set iconClass(iconClass) {
        this.toolbarOptions.iconClass = getValueForLocation(iconClass, this.showIcon, false);
        this.overflowOptions.iconClass = getValueForLocation(iconClass, this.showIcon, true);
    }
    /**
     * Defines an SVGIcon to be rendered within the button.
     * Accepts either an [existing Kendo SVG icon](slug:svgicon_list) or a custom one.
     */
    set svgIcon(icon) {
        const isIconSet = this.toolbarOptions.icon || this.overflowOptions.icon;
        const isIconClassSet = this.toolbarOptions.iconClass || this.overflowOptions.iconClass;
        if (isDevMode() &&
            icon &&
            isIconSet &&
            isIconClassSet) {
            throw new Error('Setting both icon/svgIcon and iconClass options at the same time is not supported.');
        }
        this.toolbarOptions.svgIcon = getValueForLocation(icon, this.showIcon, false);
        this.overflowOptions.svgIcon = getValueForLocation(icon, this.showIcon, true);
    }
    /**
     * Defines a URL for an image to be rendered inside the Button.
     * The URL can be relative or absolute.
     */
    set imageUrl(imageUrl) {
        this.toolbarOptions.imageUrl = getValueForLocation(imageUrl, this.showIcon, false);
        this.overflowOptions.imageUrl = getValueForLocation(imageUrl, this.showIcon, true);
    }
    /**
     * Fires each time the Button is clicked.
     */
    click = new EventEmitter();
    /**
     * Fires when the Button's `pointerdown` event is triggered.
     */
    pointerdown = new EventEmitter();
    /**
     * Fires each time the selected state of a toggleable Button is changed.
     * The event argument is the new selected state (Boolean).
     */
    selectedChange = new EventEmitter();
    toolbarOptions = {
        text: '',
        icon: '',
        iconClass: '',
        svgIcon: null,
        imageUrl: ''
    };
    overflowOptions = {
        text: '',
        icon: '',
        iconClass: '',
        svgIcon: null,
        imageUrl: ''
    };
    /**
     * @hidden
     */
    hasBadgeContainer = false;
    /**
     * @hidden
     */
    showBadge = false;
    toolbarButtonElement;
    sectionButtonElement;
    overflowButtonElement;
    _showText;
    _showIcon;
    _text;
    propertyChangeSub;
    constructor(element, zone, host) {
        super();
        this.element = element;
        this.zone = zone;
        this.host = host;
        this.isBuiltInTool = true;
        this.propertyChangeSub = this.host.propertyChange.subscribe(change => {
            if (change.property === 'showText' || change.property === 'showIcon') {
                this[change.property] = change.value;
            }
        });
    }
    ngOnInit() {
        this.setTextDisplayMode();
    }
    ngOnDestroy() {
        this.propertyChangeSub.unsubscribe();
        this.propertyChangeSub = null;
    }
    ngOnChanges(changes) {
        if (changes['rounded']) {
            this.rounded = changes['rounded'].currentValue;
        }
        if (changes['themeColor']) {
            this.themeColor = changes['themeColor'].currentValue;
        }
        if (changes['showText']) {
            this.showText = changes['showText'].currentValue;
        }
    }
    /**
     * @hidden
     */
    onBlur() {
        this.getButton().tabIndex = -1;
    }
    /**
     * @hidden
     */
    canFocus() {
        return !this.disabled;
    }
    /**
     * @hidden
     */
    focus(ev) {
        //guard against focusing twice on mousedown.
        if (!ev || ev.type === 'focus' || ev.type === 'keydown') {
            this.getButton().focus({ preventScroll: true });
        }
        this.getButton().tabIndex = 0;
    }
    /**
     * @hidden
     */
    handleKey() {
        this.getButton().tabIndex = -1;
        return false;
    }
    /**
     * @hidden
     */
    handleClick(ev) {
        this.click.emit(ev);
        if (this.toggleable) {
            this.selected = !this.selected;
            this.selectedChange.emit(this.selected);
        }
    }
    /**
     * @hidden
     */
    selectedChangeHandler(state) {
        this.selected = state;
        this.selectedChange.emit(state);
    }
    /**
     * @hidden
     */
    getButton() {
        return this[`${this.location}ButtonElement`]?.nativeElement;
    }
    setTextDisplayMode() {
        this.toolbarOptions.text = this.showText === 'menu' || this.showText === 'never' ? undefined : this.text;
        this.zone.onStable.pipe(take(1)).subscribe(() => {
            this.overflowOptions.text = this.showText === 'toolbar' || this.showText === 'never' ? undefined : this.text;
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ToolBarButtonComponent, deps: [{ token: i0.ElementRef }, { token: i0.NgZone }, { token: ToolBarComponent }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: ToolBarButtonComponent, isStandalone: true, selector: "kendo-toolbar-button", inputs: { showText: "showText", showIcon: "showIcon", text: "text", style: "style", className: "className", title: "title", disabled: "disabled", toggleable: "toggleable", look: "look", togglable: "togglable", selected: "selected", fillMode: "fillMode", rounded: "rounded", themeColor: "themeColor", icon: "icon", iconClass: "iconClass", svgIcon: "svgIcon", imageUrl: "imageUrl" }, outputs: { click: "click", pointerdown: "pointerdown", selectedChange: "selectedChange" }, providers: [{ provide: ToolBarToolComponent, useExisting: forwardRef(() => ToolBarButtonComponent) }], viewQueries: [{ propertyName: "toolbarButtonElement", first: true, predicate: ["toolbarButton"], descendants: true, read: ElementRef }, { propertyName: "sectionButtonElement", first: true, predicate: ["sectionButton"], descendants: true, read: ElementRef }, { propertyName: "overflowButtonElement", first: true, predicate: ["overflowButton"], descendants: true, read: ElementRef }], exportAs: ["kendoToolBarButton"], usesInheritance: true, usesOnChanges: true, ngImport: i0, template: `
        <ng-template #toolbarTemplate>
          @if (hasBadgeContainer) {
            <kendo-badge-container>
              <button
                #toolbarButton
                [class.k-toolbar-button]="!toggleable"
                [class.k-toolbar-toggle-button]="toggleable"
                [tabindex]="tabIndex"
                type="button"
                kendoButton
                [size]="size"
                [ngStyle]="style"
                [ngClass]="className"
                [attr.title]="title"
                [disabled]="disabled"
                [toggleable]="toggleable"
                [fillMode]="fillMode"
                [themeColor]="fillMode ? themeColor : null"
                [rounded]="rounded"
                [selected]="selected"
                [icon]="toolbarOptions.icon"
                [iconClass]="toolbarOptions.iconClass"
                [svgIcon]="toolbarOptions.svgIcon"
                [imageUrl]="toolbarOptions.imageUrl"
                (click)="click.emit($event)"
                (pointerdown)="pointerdown.emit($event)"
                (selectedChange)="selectedChangeHandler($event)"
                (blur)="onBlur()"
                >
                {{ toolbarOptions.text }}
              </button>
              @if (showBadge) {
                <kendo-badge [cutoutBorder]="true" rounded="full"></kendo-badge>
              }
            </kendo-badge-container>
          }

          @if (!hasBadgeContainer) {
            <button
              #toolbarButton
              [class.k-toolbar-button]="!toggleable"
              [class.k-toolbar-toggle-button]="toggleable"
              [tabindex]="tabIndex"
              type="button"
              kendoButton
              [size]="size"
              [ngStyle]="style"
              [ngClass]="className"
              [attr.title]="title"
              [disabled]="disabled"
              [toggleable]="toggleable"
              [fillMode]="fillMode"
              [themeColor]="fillMode ? themeColor : null"
              [rounded]="rounded"
              [selected]="selected"
              [icon]="toolbarOptions.icon"
              [iconClass]="toolbarOptions.iconClass"
              [svgIcon]="toolbarOptions.svgIcon"
              [imageUrl]="toolbarOptions.imageUrl"
              (click)="click.emit($event)"
              (pointerdown)="pointerdown.emit($event)"
              (selectedChange)="selectedChangeHandler($event)"
              (blur)="onBlur()"
              >
              {{ toolbarOptions.text }}
            </button>
          }
        </ng-template>
        <ng-template #popupTemplate>
          <div
            #overflowButton
            tabindex="-1"
            role="menuitem"
            class="k-item k-menu-item"
            [class.k-disabled]="disabled"
            [ngClass]="className"
            [ngStyle]="style"
            (click)="handleClick($event)">
            <span
              class="k-link k-menu-link"
              [class.k-selected]="selected"
              >
              @if (overflowOptions.icon || overflowOptions.iconClass || overflowOptions.svgIcon) {
                <kendo-icon-wrapper
                  [name]="overflowOptions.icon"
                  [customFontClass]="overflowOptions.iconClass"
                  [svgIcon]="overflowOptions.svgIcon"
                ></kendo-icon-wrapper>
              }
              @if (overflowOptions.imageUrl) {
                <span class="k-icon k-button-icon">
                  <img [src]="overflowOptions.imageUrl" role="presentation" class="k-image" />
                </span>
              }
              @if (overflowOptions.text) {
                <span class="k-menu-link-text">{{overflowOptions.text}}</span>
              }
            </span>
          </div>
        </ng-template>
        <ng-template #sectionTemplate>
          @if (hasBadgeContainer) {
            <kendo-badge-container>
              <button
                #sectionButton
                [class.k-toolbar-button]="!toggleable"
                [class.k-toolbar-toggle-button]="toggleable"
                [tabindex]="tabIndex"
                type="button"
                kendoButton
                [size]="size"
                [ngStyle]="style"
                [ngClass]="className"
                [attr.title]="title"
                [disabled]="disabled"
                [toggleable]="toggleable"
                [fillMode]="fillMode"
                [themeColor]="fillMode ? themeColor : null"
                [rounded]="rounded"
                [selected]="selected"
                [icon]="toolbarOptions.icon"
                [iconClass]="toolbarOptions.iconClass"
                [svgIcon]="toolbarOptions.svgIcon"
                [imageUrl]="toolbarOptions.imageUrl"
                (click)="click.emit($event)"
                (pointerdown)="pointerdown.emit($event)"
                (selectedChange)="selectedChangeHandler($event)"
                (blur)="onBlur()"
                >
                {{ toolbarOptions.text }}
              </button>
              @if (showBadge) {
                <kendo-badge [cutoutBorder]="true" rounded="full"></kendo-badge>
              }
            </kendo-badge-container>
          }
          @if (!hasBadgeContainer) {
            <button
              #sectionButton
              [class.k-toolbar-button]="!toggleable"
              [class.k-toolbar-toggle-button]="toggleable"
              [tabindex]="tabIndex"
              type="button"
              kendoButton
              [size]="size"
              [ngStyle]="style"
              [ngClass]="className"
              [attr.title]="title"
              [disabled]="disabled"
              [toggleable]="toggleable"
              [fillMode]="fillMode"
              [themeColor]="fillMode ? themeColor : null"
              [rounded]="rounded"
              [selected]="selected"
              [icon]="toolbarOptions.icon"
              [iconClass]="toolbarOptions.iconClass"
              [svgIcon]="toolbarOptions.svgIcon"
              [imageUrl]="toolbarOptions.imageUrl"
              (click)="click.emit($event)"
              (pointerdown)="pointerdown.emit($event)"
              (selectedChange)="selectedChangeHandler($event)"
              (blur)="onBlur()"
              >
              {{ toolbarOptions.text }}
            </button>
          }
        </ng-template>
        `, isInline: true, dependencies: [{ kind: "component", type: ButtonComponent, selector: "button[kendoButton]", inputs: ["arrowIcon", "toggleable", "togglable", "selected", "tabIndex", "imageUrl", "iconClass", "icon", "disabled", "size", "rounded", "fillMode", "themeColor", "svgIcon", "primary", "look"], outputs: ["selectedChange", "click"], exportAs: ["kendoButton"] }, { kind: "directive", type: NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "component", type: BadgeComponent, selector: "kendo-badge", inputs: ["align", "size", "fill", "themeColor", "rounded", "position", "cutoutBorder"] }, { kind: "component", type: BadgeContainerComponent, selector: "kendo-badge-container" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ToolBarButtonComponent, decorators: [{
            type: Component,
            args: [{
                    exportAs: 'kendoToolBarButton',
                    providers: [{ provide: ToolBarToolComponent, useExisting: forwardRef(() => ToolBarButtonComponent) }],
                    selector: 'kendo-toolbar-button',
                    template: `
        <ng-template #toolbarTemplate>
          @if (hasBadgeContainer) {
            <kendo-badge-container>
              <button
                #toolbarButton
                [class.k-toolbar-button]="!toggleable"
                [class.k-toolbar-toggle-button]="toggleable"
                [tabindex]="tabIndex"
                type="button"
                kendoButton
                [size]="size"
                [ngStyle]="style"
                [ngClass]="className"
                [attr.title]="title"
                [disabled]="disabled"
                [toggleable]="toggleable"
                [fillMode]="fillMode"
                [themeColor]="fillMode ? themeColor : null"
                [rounded]="rounded"
                [selected]="selected"
                [icon]="toolbarOptions.icon"
                [iconClass]="toolbarOptions.iconClass"
                [svgIcon]="toolbarOptions.svgIcon"
                [imageUrl]="toolbarOptions.imageUrl"
                (click)="click.emit($event)"
                (pointerdown)="pointerdown.emit($event)"
                (selectedChange)="selectedChangeHandler($event)"
                (blur)="onBlur()"
                >
                {{ toolbarOptions.text }}
              </button>
              @if (showBadge) {
                <kendo-badge [cutoutBorder]="true" rounded="full"></kendo-badge>
              }
            </kendo-badge-container>
          }

          @if (!hasBadgeContainer) {
            <button
              #toolbarButton
              [class.k-toolbar-button]="!toggleable"
              [class.k-toolbar-toggle-button]="toggleable"
              [tabindex]="tabIndex"
              type="button"
              kendoButton
              [size]="size"
              [ngStyle]="style"
              [ngClass]="className"
              [attr.title]="title"
              [disabled]="disabled"
              [toggleable]="toggleable"
              [fillMode]="fillMode"
              [themeColor]="fillMode ? themeColor : null"
              [rounded]="rounded"
              [selected]="selected"
              [icon]="toolbarOptions.icon"
              [iconClass]="toolbarOptions.iconClass"
              [svgIcon]="toolbarOptions.svgIcon"
              [imageUrl]="toolbarOptions.imageUrl"
              (click)="click.emit($event)"
              (pointerdown)="pointerdown.emit($event)"
              (selectedChange)="selectedChangeHandler($event)"
              (blur)="onBlur()"
              >
              {{ toolbarOptions.text }}
            </button>
          }
        </ng-template>
        <ng-template #popupTemplate>
          <div
            #overflowButton
            tabindex="-1"
            role="menuitem"
            class="k-item k-menu-item"
            [class.k-disabled]="disabled"
            [ngClass]="className"
            [ngStyle]="style"
            (click)="handleClick($event)">
            <span
              class="k-link k-menu-link"
              [class.k-selected]="selected"
              >
              @if (overflowOptions.icon || overflowOptions.iconClass || overflowOptions.svgIcon) {
                <kendo-icon-wrapper
                  [name]="overflowOptions.icon"
                  [customFontClass]="overflowOptions.iconClass"
                  [svgIcon]="overflowOptions.svgIcon"
                ></kendo-icon-wrapper>
              }
              @if (overflowOptions.imageUrl) {
                <span class="k-icon k-button-icon">
                  <img [src]="overflowOptions.imageUrl" role="presentation" class="k-image" />
                </span>
              }
              @if (overflowOptions.text) {
                <span class="k-menu-link-text">{{overflowOptions.text}}</span>
              }
            </span>
          </div>
        </ng-template>
        <ng-template #sectionTemplate>
          @if (hasBadgeContainer) {
            <kendo-badge-container>
              <button
                #sectionButton
                [class.k-toolbar-button]="!toggleable"
                [class.k-toolbar-toggle-button]="toggleable"
                [tabindex]="tabIndex"
                type="button"
                kendoButton
                [size]="size"
                [ngStyle]="style"
                [ngClass]="className"
                [attr.title]="title"
                [disabled]="disabled"
                [toggleable]="toggleable"
                [fillMode]="fillMode"
                [themeColor]="fillMode ? themeColor : null"
                [rounded]="rounded"
                [selected]="selected"
                [icon]="toolbarOptions.icon"
                [iconClass]="toolbarOptions.iconClass"
                [svgIcon]="toolbarOptions.svgIcon"
                [imageUrl]="toolbarOptions.imageUrl"
                (click)="click.emit($event)"
                (pointerdown)="pointerdown.emit($event)"
                (selectedChange)="selectedChangeHandler($event)"
                (blur)="onBlur()"
                >
                {{ toolbarOptions.text }}
              </button>
              @if (showBadge) {
                <kendo-badge [cutoutBorder]="true" rounded="full"></kendo-badge>
              }
            </kendo-badge-container>
          }
          @if (!hasBadgeContainer) {
            <button
              #sectionButton
              [class.k-toolbar-button]="!toggleable"
              [class.k-toolbar-toggle-button]="toggleable"
              [tabindex]="tabIndex"
              type="button"
              kendoButton
              [size]="size"
              [ngStyle]="style"
              [ngClass]="className"
              [attr.title]="title"
              [disabled]="disabled"
              [toggleable]="toggleable"
              [fillMode]="fillMode"
              [themeColor]="fillMode ? themeColor : null"
              [rounded]="rounded"
              [selected]="selected"
              [icon]="toolbarOptions.icon"
              [iconClass]="toolbarOptions.iconClass"
              [svgIcon]="toolbarOptions.svgIcon"
              [imageUrl]="toolbarOptions.imageUrl"
              (click)="click.emit($event)"
              (pointerdown)="pointerdown.emit($event)"
              (selectedChange)="selectedChangeHandler($event)"
              (blur)="onBlur()"
              >
              {{ toolbarOptions.text }}
            </button>
          }
        </ng-template>
        `,
                    standalone: true,
                    imports: [ButtonComponent, NgStyle, NgClass, IconWrapperComponent, BadgeComponent, BadgeContainerComponent],
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.NgZone }, { type: ToolBarComponent }], propDecorators: { showText: [{
                type: Input
            }], showIcon: [{
                type: Input
            }], text: [{
                type: Input
            }], style: [{
                type: Input
            }], className: [{
                type: Input
            }], title: [{
                type: Input
            }], disabled: [{
                type: Input
            }], toggleable: [{
                type: Input
            }], look: [{
                type: Input
            }], togglable: [{
                type: Input
            }], selected: [{
                type: Input
            }], fillMode: [{
                type: Input
            }], rounded: [{
                type: Input
            }], themeColor: [{
                type: Input
            }], icon: [{
                type: Input
            }], iconClass: [{
                type: Input
            }], svgIcon: [{
                type: Input
            }], imageUrl: [{
                type: Input
            }], click: [{
                type: Output
            }], pointerdown: [{
                type: Output
            }], selectedChange: [{
                type: Output
            }], toolbarButtonElement: [{
                type: ViewChild,
                args: ['toolbarButton', { read: ElementRef }]
            }], sectionButtonElement: [{
                type: ViewChild,
                args: ['sectionButton', { read: ElementRef }]
            }], overflowButtonElement: [{
                type: ViewChild,
                args: ['overflowButton', { read: ElementRef }]
            }] } });

/**
 * Represents the [Kendo UI Toolbar ButtonGroup for Angular](slug:controltypes_toolbar#button-groups).
 *
 * Use this component to group buttons in a ButtonGroup inside the ToolBar.
 *
 * @example
 * ```html
 * <kendo-toolbar>
 *      <kendo-toolbar-buttongroup>
 *          <kendo-toolbar-button text="Bold"></kendo-toolbar-button>
 *          <kendo-toolbar-button text="Underline"></kendo-toolbar-button>
 *          <kendo-toolbar-button text="Italic"></kendo-toolbar-button>
 *      </kendo-toolbar-buttongroup>
 * </kendo-toolbar>
 * ```
 *
 * @remarks
 * Supported children components are: {@link ToolBarButtonComponent}
 */
class ToolBarButtonGroupComponent extends ToolBarToolComponent {
    localization;
    host;
    /**
     * When `true`, disables the whole group of buttons.
     * If you set the `disabled` property of the group, it overrides the `disabled` property of individual buttons.
     */
    disabled;
    /**
     * @hidden
     *
     * Used to set different fillmode in Spreadsheet and Toolbar to comply with referent rendering.
     * @default 'solid'
     */
    fillMode = 'solid';
    /**
     * Sets the selection mode of the ButtonGroup.
     * @default 'multiple'
     */
    selection = 'multiple';
    /**
     * Sets the width of the ButtonGroup.
     * When you set the width of the ButtonGroup, the buttons have the same width and resize to fill the group wrapper.
     */
    width;
    /**
     * @hidden
     */
    set look(look) {
        if (look) {
            this.buttonComponents.forEach(b => b.fillMode = look === 'default' ? 'solid' : look);
        }
    }
    toolbarButtonGroup;
    sectionButtonGroup;
    overflowListItems;
    buttonComponents;
    get buttonElements() {
        if (this.overflows && this.location === 'overflow') {
            return [...this.overflowListItems.toArray().filter(el => !el.nativeElement.classList.contains('k-disabled'))].map(el => el.nativeElement);
        }
        else if (this.overflows && this.location === 'section') {
            return this.sectionButtonGroup
                .buttons.filter(b => !b.isDisabled)
                .map(b => b.element);
        }
        else {
            return this.toolbarButtonGroup
                .buttons.filter(b => !b.isDisabled)
                .map(b => b.element);
        }
    }
    focusedIndex = -1;
    getNextKey;
    getPrevKey;
    constructor(localization, host) {
        super();
        this.localization = localization;
        this.host = host;
        this.getNextKey = getNextKey(this.localization.rtl);
        this.getPrevKey = getPrevKey(this.localization.rtl);
        this.isBuiltInTool = true;
    }
    /**
     * @hidden
     */
    onFocus() {
        // triggered on tabin
        this.focusedIndex = 0;
    }
    /**
     * @hidden
     */
    onNavigate(ev) {
        ev.preventDefault();
    }
    /**
     * @hidden
     */
    selectedChangeHandler(state, button) {
        button.selected = state;
        button.selectedChange.emit(state);
    }
    /**
     * @hidden
     */
    overflowSelectedChangeHandler(button) {
        if (this.selection === 'multiple') {
            button.selected = !button.selected;
        }
        else {
            const filteredButtons = this.buttonComponents.filter(b => b !== button);
            filteredButtons.forEach(b => b.selected = false);
            button.selected = !button.selected;
        }
        button.selectedChange.emit(button.selected);
    }
    /**
     * @hidden
     */
    onButtonClick(ev) {
        this.focusedIndex = this.buttonElements.findIndex(be => be === ev.target || be.contains(ev.target));
        this.focusButton(this.focusedIndex, ev);
    }
    /**
     * @hidden
     */
    canFocus() {
        return !(this.disabled || this.buttonElements.length === 0);
    }
    /**
     * @hidden
     */
    focus(ev = {}) {
        const nextKey = this.getNextKey((this.overflows && this.location === 'overflow'));
        const prevKey = this.getPrevKey((this.overflows && this.location === 'overflow'));
        this.focusedIndex = getIndexOfFocused(prevKey, nextKey, this.buttonElements)(ev);
        this.focusButton(this.focusedIndex, ev);
    }
    /**
     * @hidden
     */
    handleKey(ev) {
        const nextKey = this.getNextKey((this.overflows && this.location === 'overflow'));
        const prevKey = this.getPrevKey((this.overflows && this.location === 'overflow'));
        const peekAtIndex = makePeeker(this.buttonElements);
        const isUnmodified = areEqual(this.focusedIndex);
        this.focusedIndex = seekFocusedIndex(prevKey, nextKey, peekAtIndex)(this.focusedIndex, ev);
        this.focusButton(this.focusedIndex, ev);
        return !isUnmodified(this.focusedIndex);
    }
    /**
     * @hidden
     */
    handleClick(ev, button) {
        button.click.emit(ev);
        this.onButtonClick(ev);
        this.overflowSelectedChangeHandler(button);
    }
    /**
     * @hidden
     */
    getIconClasses(button) {
        if (button.overflowOptions.icon) {
            return `${button.overflowOptions.icon}`;
        }
        if (button.overflowOptions.iconClass) {
            return button.overflowOptions.iconClass;
        }
        if (button.overflowOptions.svgIcon) {
            return button.overflowOptions.svgIcon;
        }
    }
    /**
     * @hidden
     */
    get size() {
        return this.host.size;
    }
    focusButton(index, ev) {
        // Guard against focusing twice on mousedown.
        if (!ev.type || ev.type === 'focus' || ev.type === 'keydown') {
            this.buttonElements[index]?.focus();
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ToolBarButtonGroupComponent, deps: [{ token: i1.LocalizationService }, { token: ToolBarComponent }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: ToolBarButtonGroupComponent, isStandalone: true, selector: "kendo-toolbar-buttongroup", inputs: { disabled: "disabled", fillMode: "fillMode", selection: "selection", width: "width", look: "look" }, providers: [LocalizationService, { provide: ToolBarToolComponent, useExisting: forwardRef(() => ToolBarButtonGroupComponent) }], queries: [{ propertyName: "buttonComponents", predicate: i0.forwardRef(() => ToolBarButtonComponent) }], viewQueries: [{ propertyName: "toolbarButtonGroup", first: true, predicate: ["toolbarButtonGroup"], descendants: true }, { propertyName: "sectionButtonGroup", first: true, predicate: ["sectionButtonGroup"], descendants: true }, { propertyName: "overflowListItems", predicate: ["listItem"], descendants: true }], exportAs: ["kendoToolBarButtonGroup"], usesInheritance: true, ngImport: i0, template: `
        <ng-template #toolbarTemplate>
          <kendo-buttongroup
            class="k-toolbar-button-group k-button-group-{{fillMode}}"
            #toolbarButtonGroup
            [tabIndex]="-1"
            [selection]="selection"
            [disabled]="disabled"
            [width]="width"
            (navigate)="onNavigate($event)"
            (focus)="onFocus()"
            >
            @for (button of buttonComponents; track button) {
              <button
                kendoButton
                type="button"
                [ngStyle]="button.style"
                [ngClass]="button.className"
                [attr.title]="button.title"
                [disabled]="button.disabled"
                [size]="size"
                [togglable]="button.togglable"
                [selected]="button.selected"
                [attr.aria-pressed]="button.selected ? true : false"
                [fillMode]="button.fillMode"
                [themeColor]="button.fillMode ? button.themeColor : null"
                [icon]="button.toolbarOptions.icon"
                [iconClass]="button.toolbarOptions.iconClass"
                [svgIcon]="button.toolbarOptions.svgIcon"
                [imageUrl]="button.toolbarOptions.imageUrl"
                (click)="button.click.emit($event); onButtonClick($event)"
                (pointerdown)="button.pointerdown.emit($event)"
                (selectedChange)="selectedChangeHandler($event, button)"
                >
                {{ button.toolbarOptions.text }}
              </button>
            }
          </kendo-buttongroup>
        </ng-template>
        <ng-template #popupTemplate>
          @for (button of buttonComponents; track button) {
            <div
              #listItem
              tabindex="-1"
              role="menuitem"
              class="k-item k-menu-item"
              [class.k-disabled]="disabled || button.disabled"
              [ngStyle]="button.style"
              [ngClass]="button.className"
              (click)="handleClick($event, button)">
              <span
                class="k-link k-menu-link"
                [class.k-selected]="button.selected"
                >
                @if (button.overflowOptions.icon || button.overflowOptions.iconClass || button.overflowOptions.svgIcon) {
                  <kendo-icon-wrapper
                    [name]="button.overflowOptions.icon"
                    [customFontClass]="button.overflowOptions.iconClass"
                    [svgIcon]="button.overflowOptions.svgIcon"
                  ></kendo-icon-wrapper>
                }
                @if (button.overflowOptions.text) {
                  <span class="k-menu-link-text">{{button.overflowOptions.text}}</span>
                }
              </span>
            </div>
          }
        </ng-template>
        <ng-template #sectionTemplate>
          <kendo-buttongroup
            class="k-toolbar-button-group k-button-group-{{fillMode}}"
            #sectionButtonGroup
            [tabIndex]="-1"
            [selection]="selection"
            [disabled]="disabled"
            [width]="width"
            (navigate)="onNavigate($event)"
            (focus)="onFocus()"
            >
            @for (button of buttonComponents; track button) {
              <button
                kendoButton
                type="button"
                [ngStyle]="button.style"
                [ngClass]="button.className"
                [attr.title]="button.title"
                [disabled]="button.disabled"
                [size]="size"
                [togglable]="button.togglable"
                [selected]="button.selected"
                [attr.aria-pressed]="button.selected ? true : false"
                [fillMode]="button.fillMode"
                [themeColor]="button.fillMode ? button.themeColor : null"
                [icon]="button.toolbarOptions.icon"
                [iconClass]="button.toolbarOptions.iconClass"
                [svgIcon]="button.toolbarOptions.svgIcon"
                [imageUrl]="button.toolbarOptions.imageUrl"
                (click)="button.click.emit($event); onButtonClick($event)"
                (pointerdown)="button.pointerdown.emit($event)"
                (selectedChange)="selectedChangeHandler($event, button)"
                >
                {{ button.toolbarOptions.text }}
              </button>
            }
          </kendo-buttongroup>
        </ng-template>
        `, isInline: true, dependencies: [{ kind: "component", type: ButtonGroupComponent, selector: "kendo-buttongroup", inputs: ["disabled", "selection", "width", "tabIndex", "navigable"], outputs: ["navigate"], exportAs: ["kendoButtonGroup"] }, { kind: "component", type: ButtonComponent, selector: "button[kendoButton]", inputs: ["arrowIcon", "toggleable", "togglable", "selected", "tabIndex", "imageUrl", "iconClass", "icon", "disabled", "size", "rounded", "fillMode", "themeColor", "svgIcon", "primary", "look"], outputs: ["selectedChange", "click"], exportAs: ["kendoButton"] }, { kind: "directive", type: NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ToolBarButtonGroupComponent, decorators: [{
            type: Component,
            args: [{
                    exportAs: 'kendoToolBarButtonGroup',
                    providers: [LocalizationService, { provide: ToolBarToolComponent, useExisting: forwardRef(() => ToolBarButtonGroupComponent) }],
                    selector: 'kendo-toolbar-buttongroup',
                    template: `
        <ng-template #toolbarTemplate>
          <kendo-buttongroup
            class="k-toolbar-button-group k-button-group-{{fillMode}}"
            #toolbarButtonGroup
            [tabIndex]="-1"
            [selection]="selection"
            [disabled]="disabled"
            [width]="width"
            (navigate)="onNavigate($event)"
            (focus)="onFocus()"
            >
            @for (button of buttonComponents; track button) {
              <button
                kendoButton
                type="button"
                [ngStyle]="button.style"
                [ngClass]="button.className"
                [attr.title]="button.title"
                [disabled]="button.disabled"
                [size]="size"
                [togglable]="button.togglable"
                [selected]="button.selected"
                [attr.aria-pressed]="button.selected ? true : false"
                [fillMode]="button.fillMode"
                [themeColor]="button.fillMode ? button.themeColor : null"
                [icon]="button.toolbarOptions.icon"
                [iconClass]="button.toolbarOptions.iconClass"
                [svgIcon]="button.toolbarOptions.svgIcon"
                [imageUrl]="button.toolbarOptions.imageUrl"
                (click)="button.click.emit($event); onButtonClick($event)"
                (pointerdown)="button.pointerdown.emit($event)"
                (selectedChange)="selectedChangeHandler($event, button)"
                >
                {{ button.toolbarOptions.text }}
              </button>
            }
          </kendo-buttongroup>
        </ng-template>
        <ng-template #popupTemplate>
          @for (button of buttonComponents; track button) {
            <div
              #listItem
              tabindex="-1"
              role="menuitem"
              class="k-item k-menu-item"
              [class.k-disabled]="disabled || button.disabled"
              [ngStyle]="button.style"
              [ngClass]="button.className"
              (click)="handleClick($event, button)">
              <span
                class="k-link k-menu-link"
                [class.k-selected]="button.selected"
                >
                @if (button.overflowOptions.icon || button.overflowOptions.iconClass || button.overflowOptions.svgIcon) {
                  <kendo-icon-wrapper
                    [name]="button.overflowOptions.icon"
                    [customFontClass]="button.overflowOptions.iconClass"
                    [svgIcon]="button.overflowOptions.svgIcon"
                  ></kendo-icon-wrapper>
                }
                @if (button.overflowOptions.text) {
                  <span class="k-menu-link-text">{{button.overflowOptions.text}}</span>
                }
              </span>
            </div>
          }
        </ng-template>
        <ng-template #sectionTemplate>
          <kendo-buttongroup
            class="k-toolbar-button-group k-button-group-{{fillMode}}"
            #sectionButtonGroup
            [tabIndex]="-1"
            [selection]="selection"
            [disabled]="disabled"
            [width]="width"
            (navigate)="onNavigate($event)"
            (focus)="onFocus()"
            >
            @for (button of buttonComponents; track button) {
              <button
                kendoButton
                type="button"
                [ngStyle]="button.style"
                [ngClass]="button.className"
                [attr.title]="button.title"
                [disabled]="button.disabled"
                [size]="size"
                [togglable]="button.togglable"
                [selected]="button.selected"
                [attr.aria-pressed]="button.selected ? true : false"
                [fillMode]="button.fillMode"
                [themeColor]="button.fillMode ? button.themeColor : null"
                [icon]="button.toolbarOptions.icon"
                [iconClass]="button.toolbarOptions.iconClass"
                [svgIcon]="button.toolbarOptions.svgIcon"
                [imageUrl]="button.toolbarOptions.imageUrl"
                (click)="button.click.emit($event); onButtonClick($event)"
                (pointerdown)="button.pointerdown.emit($event)"
                (selectedChange)="selectedChangeHandler($event, button)"
                >
                {{ button.toolbarOptions.text }}
              </button>
            }
          </kendo-buttongroup>
        </ng-template>
        `,
                    standalone: true,
                    imports: [ButtonGroupComponent, ButtonComponent, NgStyle, NgClass, IconWrapperComponent]
                }]
        }], ctorParameters: () => [{ type: i1.LocalizationService }, { type: ToolBarComponent }], propDecorators: { disabled: [{
                type: Input
            }], fillMode: [{
                type: Input
            }], selection: [{
                type: Input
            }], width: [{
                type: Input
            }], look: [{
                type: Input
            }], toolbarButtonGroup: [{
                type: ViewChild,
                args: ['toolbarButtonGroup', { static: false }]
            }], sectionButtonGroup: [{
                type: ViewChild,
                args: ['sectionButtonGroup', { static: false }]
            }], overflowListItems: [{
                type: ViewChildren,
                args: ['listItem']
            }], buttonComponents: [{
                type: ContentChildren,
                args: [forwardRef(() => ToolBarButtonComponent)]
            }] } });

/**
 * Represents the [Kendo UI ToolBar DropDownButton for Angular](slug:controltypes_toolbar#drop-down-buttons).
 *
 * Use this component to add a button that opens a popup with a list of items in the ToolBar.
 *
 * @example
 * ```html
 * <kendo-toolbar>
 *      <kendo-toolbar-dropdownbutton text="Paste Variations" [data]="data">
 *      </kendo-toolbar-dropdownbutton>
 * </kendo-toolbar>
 * ```
 *
 */
class ToolBarDropDownButtonComponent extends ToolBarToolComponent {
    zone;
    renderer;
    host;
    /**
     * Shows the default arrow icon or lets you provide a custom one.
     * @default false
     */
    arrowIcon = false;
    /**
     * Sets the `title` attribute of the underlying button element.
     * @default ''
     */
    title = '';
    // showText and showIcon showIcon should be declared first
    /**
     * Controls the button text visibility.
     * @default 'always'
     */
    set showText(value) {
        this._showText = value;
        this.setTextDisplayMode();
    }
    get showText() {
        return this._showText;
    }
    /**
     * Controls the button icon visibility.
     * @default 'always'
     */
    set showIcon(value) {
        this._showIcon = value;
    }
    get showIcon() {
        return this._showIcon;
    }
    /**
     * Sets the text of the DropDownButton
     * ([see example](slug:controltypes_toolbar#toc-drop-down-buttons)).
     */
    set text(text) {
        this._text = text;
        this.setTextDisplayMode();
    }
    get text() {
        return this._text;
    }
    /**
     * Sets the icon rendered next to the button text.
     */
    set icon(icon) {
        this.toolbarOptions.icon = getValueForLocation(icon, this.showIcon, false);
        this.overflowOptions.icon = getValueForLocation(icon, this.showIcon, true);
    }
    /**
     * Sets the `SVGIcon` rendered in the button.
     * Accepts an [existing Kendo SVG icon](slug:svgicon_list) or a custom one.
     */
    set svgIcon(icon) {
        const isIconSet = this.toolbarOptions.icon || this.overflowOptions.icon;
        const isIconClassSet = this.toolbarOptions.iconClass || this.overflowOptions.iconClass;
        if (isDevMode() &&
            icon &&
            isIconSet &&
            isIconClassSet) {
            throw new Error('Setting both icon/svgIcon and iconClass options at the same time is not supported.');
        }
        this.toolbarOptions.svgIcon = getValueForLocation(icon, this.showIcon, false);
        this.overflowOptions.svgIcon = getValueForLocation(icon, this.showIcon, true);
    }
    /**
     * Sets a custom CSS class icon rendered next to the button text.
     */
    set iconClass(iconClass) {
        this.toolbarOptions.iconClass = getValueForLocation(iconClass, this.showIcon, false);
        this.overflowOptions.iconClass = getValueForLocation(iconClass, this.showIcon, true);
    }
    /**
     * Sets a URL for the image displayed next to the button text.
     */
    set imageUrl(imageUrl) {
        this.toolbarOptions.imageUrl = getValueForLocation(imageUrl, this.showIcon, false);
        this.overflowOptions.imageUrl = getValueForLocation(imageUrl, this.showIcon, true);
    }
    /**
     * Configures the popup of the DropDownButton.
     * Accepts a `PopupSettings` object that allows you to customize the popup behavior and appearance.
     */
    set popupSettings(settings) {
        this._popupSettings = Object.assign({ animate: true, popupClass: '' }, settings);
    }
    get popupSettings() {
        return this._popupSettings;
    }
    /**
     * @hidden
     */
    set look(look) {
        if (look) {
            this.fillMode = look === 'default' ? 'solid' : look;
        }
    }
    /**
     * @hidden
     */
    set primary(primary) {
        this.themeColor = primary ? 'primary' : 'base';
    }
    /**
     * Sets the fill mode for the button.
     * The fill mode represents the background and border styles.
     * @default 'solid'
     */
    fillMode = 'solid';
    /**
     * Sets the predefined theme color for the button.
     * The theme color applies to the background, border, and text
     * ([see example]({% slug api_buttons_dropdownbuttoncomponent %}#toc-themeColor)).
     * @default 'base'
     */
    themeColor = 'base';
    /**
     * Sets the CSS classes for the main button.
     * Accepts values supported by [`ngClass`](link:site.data.urls.angular['ngclassapi']).
     */
    buttonClass;
    /**
     * Sets the data item field that repesents the item text.
     * If the data contains only primitive values, do not set this property.
     */
    textField;
    /**
     * When `true`, disables the DropDownButton.
     */
    disabled;
    /**
     * Sets the data of the DropDownButton
     * ([see example](slug:controltypes_toolbar#drop-down-buttons)).
     *
     * > Provide the data as an array-like list.
     */
    set data(data) {
        this._data = data || [];
    }
    get data() {
        if (!this._data) {
            this.data = [];
        }
        return this._data;
    }
    /**
     * Fires each time the user clicks a DropDownButton item.
     * The event data contains the clicked item's data.
     */
    itemClick = new EventEmitter();
    /**
     * Fires when the popup is about to open.
     * This event is preventable. If you cancel the event, the popup stays closed.
     */
    open = new EventEmitter();
    /**
     * Fires when the popup is about to close.
     * This event is preventable. If you cancel the event, the popup stays open.
     */
    close = new EventEmitter();
    dropdownButton;
    toolbarDropDownButton;
    sectionDropDownButton;
    overflowListItems;
    toolbarOptions = {
        text: '',
        icon: '',
        iconClass: '',
        svgIcon: null,
        imageUrl: ''
    };
    overflowOptions = {
        text: '',
        icon: '',
        iconClass: '',
        svgIcon: null,
        imageUrl: ''
    };
    get overflowButtons() {
        return [...this.overflowListItems.toArray().filter(el => !el.nativeElement.classList.contains('k-disabled'))];
    }
    _data;
    _popupSettings = { animate: true, popupClass: '' };
    focusedIndex = -1;
    _showText;
    _showIcon;
    _text;
    propertyChangeSub;
    getNextKey;
    getPrevKey;
    constructor(zone, renderer, host) {
        super();
        this.zone = zone;
        this.renderer = renderer;
        this.host = host;
        this.getNextKey = getNextKey();
        this.getPrevKey = getPrevKey();
        this.isBuiltInTool = true;
        this.propertyChangeSub = this.host.propertyChange.subscribe(change => {
            if (change.property === 'showText' || change.property === 'showIcon') {
                this[change.property] = change.value;
            }
        });
    }
    ngOnInit() {
        this.setTextDisplayMode();
    }
    ngOnDestroy() {
        if (this.propertyChangeSub) {
            this.propertyChangeSub.unsubscribe();
            this.propertyChangeSub = null;
        }
    }
    ngAfterViewInit() {
        this.zone.onStable.pipe(take(1)).subscribe(() => {
            const dropdownButton = this[`${this.location}DropDownButton`];
            if (dropdownButton?.button) {
                this.renderer.addClass(dropdownButton.button.nativeElement, 'k-toolbar-menu-button');
            }
        });
    }
    /**
     * @hidden
     */
    onButtonListClick(ev) {
        this.focusedIndex = this.overflowListItems
            .toArray()
            .findIndex(b => b.nativeElement.contains(ev.target));
    }
    /**
     * @hidden
     */
    get size() {
        return this.host.size;
    }
    /**
     * @hidden
     */
    canFocus() {
        return !this.disabled;
    }
    /**
     * @hidden
     */
    focus(ev = {}) {
        if (!this.overflows || this.location === 'section') {
            if (!ev.type || ev.type === 'focus' || ev.type === 'keydown') {
                this[`${this.location}DropDownButton`]?.focus();
            }
        }
        else if (this.overflowButtons.length > 0) {
            this.focusedIndex = getIndexOfFocused(this.getPrevKey(), this.getNextKey(), this.overflowButtons.map(ob => ob.nativeElement))(ev);
            this.focusButton(this.focusedIndex, ev);
        }
    }
    /**
     * @hidden
     */
    handleKey(ev) {
        const code = normalizeKeys(ev);
        if (!this.overflows && (code === this.getPrevKey(this.overflows) || code === this.getNextKey(this.overflows))) {
            return false;
        }
        if (this.overflows && this.location !== 'section') {
            const peekAtIndex = makePeeker(this.overflowButtons);
            const isUnmodified = areEqual(this.focusedIndex);
            this.focusedIndex = seekFocusedIndex(this.getPrevKey(), this.getNextKey(), peekAtIndex)(this.focusedIndex, ev);
            this.focusButton(this.focusedIndex, ev);
            return !isUnmodified(this.focusedIndex);
        }
    }
    /**
     * @hidden
     */
    getText(dataItem) {
        if (dataItem) {
            return this.textField ? dataItem[this.textField] : dataItem.text || dataItem;
        }
    }
    /**
     * @hidden
     */
    handleClick(ev, item, index) {
        this.onButtonListClick(ev);
        const dataItem = this.data[index];
        if (item.click) {
            item.click(dataItem);
        }
        this.itemClick.emit(dataItem);
    }
    focusButton(index, ev) {
        if (!ev.type || ev.type === 'focus' || ev.type === 'keydown') {
            this.overflowButtons[index].nativeElement.focus();
        }
    }
    setTextDisplayMode() {
        this.toolbarOptions.text = this.showText === 'menu' || this.showText === 'never' ? undefined : this.text;
        this.overflowOptions.text = this.showText === 'toolbar' || this.showText === 'never' ? undefined : this.text;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ToolBarDropDownButtonComponent, deps: [{ token: i0.NgZone }, { token: i0.Renderer2 }, { token: ToolBarComponent }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: ToolBarDropDownButtonComponent, isStandalone: true, selector: "kendo-toolbar-dropdownbutton", inputs: { arrowIcon: "arrowIcon", title: "title", showText: "showText", showIcon: "showIcon", text: "text", icon: "icon", svgIcon: "svgIcon", iconClass: "iconClass", imageUrl: "imageUrl", popupSettings: "popupSettings", look: "look", primary: "primary", fillMode: "fillMode", themeColor: "themeColor", buttonClass: "buttonClass", textField: "textField", disabled: "disabled", data: "data" }, outputs: { itemClick: "itemClick", open: "open", close: "close" }, providers: [{ provide: ToolBarToolComponent, useExisting: forwardRef(() => ToolBarDropDownButtonComponent) }], viewQueries: [{ propertyName: "dropdownButton", first: true, predicate: ["dropdownButton"], descendants: true, read: ElementRef, static: true }, { propertyName: "toolbarDropDownButton", first: true, predicate: ["toolbarDropDownButton"], descendants: true }, { propertyName: "sectionDropDownButton", first: true, predicate: ["sectionDropDownButton"], descendants: true }, { propertyName: "overflowListItems", predicate: ["listItem"], descendants: true }], exportAs: ["kendoToolBarDropDownButton"], usesInheritance: true, ngImport: i0, template: `
        <ng-template #toolbarTemplate>
          <kendo-dropdownbutton #toolbarDropDownButton
            [icon]="toolbarOptions.icon"
            [iconClass]="toolbarOptions.iconClass"
            [svgIcon]="toolbarOptions.svgIcon"
            [imageUrl]="toolbarOptions.imageUrl"
            [arrowIcon]="arrowIcon"
            [buttonClass]="buttonClass"
            [disabled]="disabled"
            [size]="size"
            [tabIndex]="-1"
            [data]="data"
            [buttonAttributes]="{'title': title}"
            [textField]="textField"
            [popupSettings]="popupSettings"
            [fillMode]="fillMode"
            [themeColor]="fillMode ? themeColor : null"
            (open)="open.emit($event)"
            (close)="close.emit($event)"
            (itemClick)="itemClick.emit($event)"
            >
            {{ toolbarOptions.text }}
          </kendo-dropdownbutton>
        </ng-template>
        
        <ng-template #popupTemplate>
          <div
            tabindex="-1"
            role="menuitem"
            class="k-item k-menu-item k-disabled"
            [ngClass]="buttonClass">
            <span
              [ngClass]="{'k-link': true, 'k-menu-link': true}"
              >
              @if (overflowOptions.icon || overflowOptions.iconClass || overflowOptions.svgIcon) {
                <kendo-icon-wrapper
                  [name]="overflowOptions.icon"
                  [customFontClass]="overflowOptions.iconClass"
                  [svgIcon]="overflowOptions.svgIcon"
                ></kendo-icon-wrapper>
              }
              @if (overflowOptions.text) {
                <span class="k-menu-link-text">{{overflowOptions.text}}</span>
              }
            </span>
          </div>
          @for (item of data; track item; let i = $index) {
            <div #listItem
              tabindex="-1"
              role="menuitem"
              class="k-item k-menu-item"
              [class.k-disabled]="disabled || item.disabled"
              (click)="handleClick($event, item, i)">
              <span
                class="k-link k-menu-link"
                [ngClass]="item.cssClass"
                >
                @if (item.icon || item.iconClass || item.svgIcon) {
                  <kendo-icon-wrapper
                    [name]="item.icon"
                    [customFontClass]="item.iconClass"
                    [svgIcon]="item.svgIcon"
                  ></kendo-icon-wrapper>
                }
                @if (getText(item)) {
                  <span class="k-menu-link-text">{{ getText(item) }}</span>
                }
              </span>
            </div>
          }
        </ng-template>
        
        <ng-template #sectionTemplate>
          <kendo-dropdownbutton #sectionDropDownButton
            [icon]="toolbarOptions.icon"
            [iconClass]="toolbarOptions.iconClass"
            [svgIcon]="toolbarOptions.svgIcon"
            [imageUrl]="toolbarOptions.imageUrl"
            [arrowIcon]="arrowIcon"
            [buttonClass]="buttonClass"
            [disabled]="disabled"
            [size]="size"
            [tabIndex]="-1"
            [data]="data"
            [buttonAttributes]="{'title': title}"
            [textField]="textField"
            [popupSettings]="popupSettings"
            [fillMode]="fillMode"
            [themeColor]="fillMode ? themeColor : null"
            (open)="open.emit($event)"
            (close)="close.emit($event)"
            (itemClick)="itemClick.emit($event)"
            >
            {{ toolbarOptions.text }}
          </kendo-dropdownbutton>
        </ng-template>
        `, isInline: true, dependencies: [{ kind: "component", type: DropDownButtonComponent, selector: "kendo-dropdownbutton", inputs: ["arrowIcon", "icon", "svgIcon", "iconClass", "imageUrl", "textField", "data", "size", "rounded", "fillMode", "themeColor", "buttonAttributes"], outputs: ["itemClick", "focus", "blur"], exportAs: ["kendoDropDownButton"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ToolBarDropDownButtonComponent, decorators: [{
            type: Component,
            args: [{
                    exportAs: 'kendoToolBarDropDownButton',
                    providers: [{ provide: ToolBarToolComponent, useExisting: forwardRef(() => ToolBarDropDownButtonComponent) }],
                    selector: 'kendo-toolbar-dropdownbutton',
                    template: `
        <ng-template #toolbarTemplate>
          <kendo-dropdownbutton #toolbarDropDownButton
            [icon]="toolbarOptions.icon"
            [iconClass]="toolbarOptions.iconClass"
            [svgIcon]="toolbarOptions.svgIcon"
            [imageUrl]="toolbarOptions.imageUrl"
            [arrowIcon]="arrowIcon"
            [buttonClass]="buttonClass"
            [disabled]="disabled"
            [size]="size"
            [tabIndex]="-1"
            [data]="data"
            [buttonAttributes]="{'title': title}"
            [textField]="textField"
            [popupSettings]="popupSettings"
            [fillMode]="fillMode"
            [themeColor]="fillMode ? themeColor : null"
            (open)="open.emit($event)"
            (close)="close.emit($event)"
            (itemClick)="itemClick.emit($event)"
            >
            {{ toolbarOptions.text }}
          </kendo-dropdownbutton>
        </ng-template>
        
        <ng-template #popupTemplate>
          <div
            tabindex="-1"
            role="menuitem"
            class="k-item k-menu-item k-disabled"
            [ngClass]="buttonClass">
            <span
              [ngClass]="{'k-link': true, 'k-menu-link': true}"
              >
              @if (overflowOptions.icon || overflowOptions.iconClass || overflowOptions.svgIcon) {
                <kendo-icon-wrapper
                  [name]="overflowOptions.icon"
                  [customFontClass]="overflowOptions.iconClass"
                  [svgIcon]="overflowOptions.svgIcon"
                ></kendo-icon-wrapper>
              }
              @if (overflowOptions.text) {
                <span class="k-menu-link-text">{{overflowOptions.text}}</span>
              }
            </span>
          </div>
          @for (item of data; track item; let i = $index) {
            <div #listItem
              tabindex="-1"
              role="menuitem"
              class="k-item k-menu-item"
              [class.k-disabled]="disabled || item.disabled"
              (click)="handleClick($event, item, i)">
              <span
                class="k-link k-menu-link"
                [ngClass]="item.cssClass"
                >
                @if (item.icon || item.iconClass || item.svgIcon) {
                  <kendo-icon-wrapper
                    [name]="item.icon"
                    [customFontClass]="item.iconClass"
                    [svgIcon]="item.svgIcon"
                  ></kendo-icon-wrapper>
                }
                @if (getText(item)) {
                  <span class="k-menu-link-text">{{ getText(item) }}</span>
                }
              </span>
            </div>
          }
        </ng-template>
        
        <ng-template #sectionTemplate>
          <kendo-dropdownbutton #sectionDropDownButton
            [icon]="toolbarOptions.icon"
            [iconClass]="toolbarOptions.iconClass"
            [svgIcon]="toolbarOptions.svgIcon"
            [imageUrl]="toolbarOptions.imageUrl"
            [arrowIcon]="arrowIcon"
            [buttonClass]="buttonClass"
            [disabled]="disabled"
            [size]="size"
            [tabIndex]="-1"
            [data]="data"
            [buttonAttributes]="{'title': title}"
            [textField]="textField"
            [popupSettings]="popupSettings"
            [fillMode]="fillMode"
            [themeColor]="fillMode ? themeColor : null"
            (open)="open.emit($event)"
            (close)="close.emit($event)"
            (itemClick)="itemClick.emit($event)"
            >
            {{ toolbarOptions.text }}
          </kendo-dropdownbutton>
        </ng-template>
        `,
                    standalone: true,
                    imports: [DropDownButtonComponent, NgClass, IconWrapperComponent]
                }]
        }], ctorParameters: () => [{ type: i0.NgZone }, { type: i0.Renderer2 }, { type: ToolBarComponent }], propDecorators: { arrowIcon: [{
                type: Input
            }], title: [{
                type: Input
            }], showText: [{
                type: Input
            }], showIcon: [{
                type: Input
            }], text: [{
                type: Input
            }], icon: [{
                type: Input
            }], svgIcon: [{
                type: Input
            }], iconClass: [{
                type: Input
            }], imageUrl: [{
                type: Input
            }], popupSettings: [{
                type: Input
            }], look: [{
                type: Input
            }], primary: [{
                type: Input
            }], fillMode: [{
                type: Input
            }], themeColor: [{
                type: Input
            }], buttonClass: [{
                type: Input
            }], textField: [{
                type: Input
            }], disabled: [{
                type: Input
            }], data: [{
                type: Input
            }], itemClick: [{
                type: Output
            }], open: [{
                type: Output
            }], close: [{
                type: Output
            }], dropdownButton: [{
                type: ViewChild,
                args: ['dropdownButton', { read: ElementRef, static: true }]
            }], toolbarDropDownButton: [{
                type: ViewChild,
                args: ['toolbarDropDownButton', { static: false }]
            }], sectionDropDownButton: [{
                type: ViewChild,
                args: ['sectionDropDownButton', { static: false }]
            }], overflowListItems: [{
                type: ViewChildren,
                args: ['listItem']
            }] } });

/**
 * Represents the [Kendo UI ToolBar SplitButton for Angular](slug:controltypes_toolbar#split-buttons).
 *
 * Use the ToolBar SplitButton to create a split button with a main button and a drop-down list of actions in the ToolBar.
 *
 * @example
 * ```html
 * <kendo-toolbar>
 *      <kendo-toolbar-splitbutton text="Paste" [data]="data">
 *      </kendo-toolbar-splitbutton>
 * </kendo-toolbar>
 * ```
 */
class ToolBarSplitButtonComponent extends ToolBarToolComponent {
    host;
    // showText and showIcon showIcon should be declared first
    /**
     * Controls the button text visibility.
     * @default 'always'
     */
    set showText(value) {
        this._showText = value;
        this.setTextDisplayMode();
    }
    get showText() {
        return this._showText;
    }
    /**
     * Controls the button icon visibility.
     * @default 'always'
     */
    set showIcon(value) {
        this._showIcon = value;
        this.setTextDisplayMode();
    }
    get showIcon() {
        return this._showIcon;
    }
    /**
     * Sets the text of the SplitButton ([see example](slug:controltypes_toolbar#toc-split-buttons)).
     */
    set text(text) {
        this._text = text;
        this.setTextDisplayMode();
    }
    get text() {
        return this._text;
    }
    /**
     * Sets the icon rendered next to the button text
     * ([see example](slug:controltypes_toolbar#toc-split-buttons)).
     */
    set icon(icon) {
        this.toolbarOptions.icon = getValueForLocation(icon, this.showIcon, false);
        this.overflowOptions.icon = getValueForLocation(icon, this.showIcon, true);
    }
    /**
     * Sets the `SVGIcon` rendered in the main button.
     * Accepts an [existing Kendo SVG icon](slug:svgicon_list) or a custom one.
     */
    set svgIcon(icon) {
        const isIconSet = this.toolbarOptions.icon || this.overflowOptions.icon;
        const isIconClassSet = this.toolbarOptions.iconClass || this.overflowOptions.iconClass;
        if (isDevMode() &&
            icon &&
            isIconSet &&
            isIconClassSet) {
            throw new Error('Setting both icon/svgIcon and iconClass options at the same time is not supported.');
        }
        this.toolbarOptions.svgIcon = getValueForLocation(icon, this.showIcon, false);
        this.overflowOptions.svgIcon = getValueForLocation(icon, this.showIcon, true);
    }
    /**
     * Sets a custom CSS class icon rendered next to the button text.
     */
    set iconClass(iconClass) {
        this.toolbarOptions.iconClass = getValueForLocation(iconClass, this.showIcon, false);
        this.overflowOptions.iconClass = getValueForLocation(iconClass, this.showIcon, true);
    }
    /**
     * Sets a URL for the image displayed next to the button text.
     */
    set imageUrl(imageUrl) {
        this.toolbarOptions.imageUrl = getValueForLocation(imageUrl, this.showIcon, false);
        this.overflowOptions.imageUrl = getValueForLocation(imageUrl, this.showIcon, true);
    }
    /**
     * When `true`, disables a SplitButton item.
     */
    disabled;
    /**
     * Configures the popup of the SplitButton.
     * Accepts a `PopupSettings` object that allows you to customize the popup behavior and appearance.

     */
    set popupSettings(value) {
        this._popupSettings = value;
    }
    get popupSettings() {
        if (!this._popupSettings) {
            this._popupSettings = { animate: true, popupClass: '' };
        }
        return this._popupSettings;
    }
    /**
     * Sets the fill mode for the button.
     * The fill mode represents the background and border styles.
     * @default 'solid'
     */
    fillMode = 'solid';
    /**
     * Sets the predefined theme color for the button.
     * The theme color applies to the background, border, and text.
     * @default 'base'
     */
    themeColor = 'base';
    /**
     * @hidden
     */
    set look(look) {
        if (look) {
            this.fillMode = look === 'default' ? 'solid' : look;
        }
    }
    /**
     * Sets the CSS classes for the main button.
     * Accepts values supported by [`ngClass`](link:site.data.urls.angular['ngclassapi']).
     */
    buttonClass;
    /**
     * Sets the CSS classes for the arrow button that opens the popup.
     * Accepts values supported by [`ngClass`](link:site.data.urls.angular['ngclassapi']).
     */
    arrowButtonClass;
    /**
     * Sets the name of the [font icon](slug:icons#icons-list) for the arrow button.
     */
    arrowButtonIcon = 'caret-alt-down';
    /**
     * Sets the [`SVGIcon`](slug:api_icons_svgicon) for the arrow button.
     */
    arrowButtonSvgIcon = caretAltDownIcon;
    /**
     * Sets the text field for the button-list popup.
     * @default 'text'
     */
    textField = 'text';
    /**
     * Sets the data of the SplitButton ([see example](slug:controltypes_toolbar#toc-split-buttons)).
     *
     * > Provide the data as an array-like list.
     */
    set data(data) {
        this._data = data || [];
    }
    get data() {
        if (!this._data) {
            this.data = [];
        }
        return this._data;
    }
    /**
     * Fires when the user clicks the main button.
     */
    buttonClick = new EventEmitter();
    /**
     * Fires when the user clicks a drop-down list item.
     * The event data contains the clicked item's data.
     */
    itemClick = new EventEmitter();
    /**
     * Fires when the popup is about to open.
     * This event is preventable. If you cancel the event, the popup stays closed.
     */
    open = new EventEmitter();
    /**
     * Fires when the popup is about to close.
     * This event is preventable. If you cancel the event, the popup stays open.
     */
    close = new EventEmitter();
    toolbarOptions = {
        text: '',
        icon: '',
        iconClass: '',
        svgIcon: null,
        imageUrl: ''
    };
    overflowOptions = {
        text: '',
        icon: '',
        iconClass: '',
        svgIcon: null,
        imageUrl: ''
    };
    ngOnInit() {
        this.setTextDisplayMode();
    }
    ngOnDestroy() {
        if (this.propertyChangeSub) {
            this.propertyChangeSub.unsubscribe();
            this.propertyChangeSub = null;
        }
    }
    get overflowButtons() {
        return [this.overflowMainButton, ...this.overflowListItems.toArray().filter(el => !el.nativeElement.classList.contains('k-disabled'))];
    }
    _data;
    _popupSettings = { animate: true, popupClass: '' };
    focusedIndex = -1;
    _showText;
    _showIcon;
    _text;
    propertyChangeSub;
    getNextKey;
    getPrevKey;
    toolbarSplitButton;
    sectionSplitButton;
    overflowMainButton;
    overflowListItems;
    constructor(host) {
        super();
        this.host = host;
        this.getNextKey = getNextKey();
        this.getPrevKey = getPrevKey();
        this.isBuiltInTool = true;
        this.propertyChangeSub = this.host.propertyChange.subscribe(change => {
            if (change.property === 'showText' || change.property === 'showIcon') {
                this[change.property] = change.value;
            }
        });
    }
    /**
     * @hidden
     */
    onButtonListClick(ev) {
        this.focusedIndex = this.overflowButtons.findIndex(b => b.nativeElement.contains(ev.target));
    }
    /**
     * @hidden
     */
    onMainButtonClick(ev) {
        this.buttonClick.emit(ev);
        this.focusedIndex = 0;
    }
    /**
     * @hidden
     */
    canFocus() {
        return !this.disabled;
    }
    /**
     * @hidden
     */
    get size() {
        return this.host.size;
    }
    /**
     * @hidden
     */
    focus(ev = {}) {
        if (!this.overflows || this.location === 'section') {
            if (!ev.type || ev.type === 'focus' || ev.type === 'keydown') {
                this[`${this.location}SplitButton`].focus();
            }
        }
        else if (this.overflowButtons.length > 0) {
            this.focusedIndex = getIndexOfFocused(this.getPrevKey(), this.getNextKey(), this.overflowButtons.map(ob => ob.nativeElement))(ev);
            this.focusButton(this.focusedIndex, ev);
        }
    }
    /**
     * @hidden
     */
    handleKey(ev) {
        const code = normalizeKeys(ev);
        if (!this.overflows && (code === this.getPrevKey(this.overflows) || code === this.getNextKey(this.overflows))) {
            return false;
        }
        if (this.overflows) {
            const peekAtIndex = makePeeker(this.overflowButtons);
            const isUnmodified = areEqual(this.focusedIndex);
            this.focusedIndex = seekFocusedIndex(this.getPrevKey(), this.getNextKey(), peekAtIndex)(this.focusedIndex, ev);
            this.focusButton(this.focusedIndex, ev);
            return !isUnmodified(this.focusedIndex);
        }
    }
    /**
     * @hidden
     */
    getText(dataItem) {
        if (dataItem) {
            return this.textField ? dataItem[this.textField] : dataItem.text || dataItem;
        }
    }
    /**
     * @hidden
     */
    handleClick(ev, item, index) {
        this.onButtonListClick(ev);
        const dataItem = this.data[index];
        if (item.click) {
            item.click(dataItem);
        }
        this.itemClick.emit(dataItem);
    }
    focusButton(index, ev) {
        if ((!ev.type || ev.type === 'focus' || ev.type === 'keydown' || ev.type === 'click') && this.location !== 'section') {
            this.overflowButtons[index].nativeElement.focus();
        }
    }
    setTextDisplayMode() {
        this.toolbarOptions.text = this.showText === 'menu' || this.showText === 'never' ? undefined : this.text;
        this.overflowOptions.text = this.showText === 'toolbar' || this.showText === 'never' ? undefined : this.text;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ToolBarSplitButtonComponent, deps: [{ token: ToolBarComponent }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: ToolBarSplitButtonComponent, isStandalone: true, selector: "kendo-toolbar-splitbutton", inputs: { showText: "showText", showIcon: "showIcon", text: "text", icon: "icon", svgIcon: "svgIcon", iconClass: "iconClass", imageUrl: "imageUrl", disabled: "disabled", popupSettings: "popupSettings", fillMode: "fillMode", themeColor: "themeColor", look: "look", buttonClass: "buttonClass", arrowButtonClass: "arrowButtonClass", arrowButtonIcon: "arrowButtonIcon", arrowButtonSvgIcon: "arrowButtonSvgIcon", textField: "textField", data: "data" }, outputs: { buttonClick: "buttonClick", itemClick: "itemClick", open: "open", close: "close" }, providers: [{ provide: ToolBarToolComponent, useExisting: forwardRef(() => ToolBarSplitButtonComponent) }], viewQueries: [{ propertyName: "toolbarSplitButton", first: true, predicate: ["toolbarSplitButton"], descendants: true }, { propertyName: "sectionSplitButton", first: true, predicate: ["sectionSplitButton"], descendants: true }, { propertyName: "overflowMainButton", first: true, predicate: ["overflowMainButton"], descendants: true, read: ElementRef }, { propertyName: "overflowListItems", predicate: ["listItem"], descendants: true }], exportAs: ["kendoToolBarSplitButton"], usesInheritance: true, ngImport: i0, template: `
        <ng-template #toolbarTemplate>
          <kendo-splitbutton
            #toolbarSplitButton
            class="k-toolbar-split-button"
            [data]="data"
            [text]="toolbarOptions.text"
            [icon]="toolbarOptions.icon"
            [iconClass]="toolbarOptions.iconClass"
            [svgIcon]="toolbarOptions.svgIcon"
            [imageUrl]="toolbarOptions.imageUrl"
            [buttonClass]="buttonClass"
            [arrowButtonClass]="arrowButtonClass"
            [arrowButtonIcon]="arrowButtonIcon"
            [arrowButtonSvgIcon]="arrowButtonSvgIcon"
            [disabled]="disabled"
            [size]="size"
            [tabIndex]="-1"
            [textField]="textField"
            [popupSettings]="popupSettings"
            [fillMode]="fillMode"
            [themeColor]="fillMode ? themeColor : null"
            (buttonClick)="buttonClick.emit($event)"
            (open)="open.emit($event)"
            (close)="close.emit($event)"
            (itemClick)="itemClick.emit($event)"
          ></kendo-splitbutton>
        </ng-template>
        <ng-template #popupTemplate>
          <div #overflowMainButton
            tabindex="-1"
            role="menuitem"
            class="k-item k-menu-item"
            [class.k-disabled]="disabled"
            [ngClass]="buttonClass"
            (click)="onMainButtonClick($event)">
            <span
              [ngClass]="{'k-link': true, 'k-menu-link': true}"
              >
              @if (overflowOptions.icon || overflowOptions.iconClass || overflowOptions.svgIcon) {
                <kendo-icon-wrapper
                  [name]="overflowOptions.icon"
                  [customFontClass]="overflowOptions.iconClass"
                  [svgIcon]="overflowOptions.svgIcon"
                  >
                </kendo-icon-wrapper>
              }
              @if (overflowOptions.text) {
                <span class="k-menu-link-text">{{overflowOptions.text}}</span>
              }
            </span>
          </div>
          @for (item of data; track item; let i = $index) {
            <div #listItem
              tabindex="-1"
              role="menuitem"
              class="k-item k-menu-item"
              [class.k-disabled]="disabled || item.disabled"
              (click)="handleClick($event, item, i)">
              <span
                class="k-link k-menu-link"
                >
                @if (item.icon || item.iconClass || item.svgIcon) {
                  <kendo-icon-wrapper
                    [name]="item.icon"
                    [customFontClass]="item.iconClass"
                    [svgIcon]="item.svgIcon"
                    >
                  </kendo-icon-wrapper>
                }
                @if (getText(item)) {
                  <span class="k-menu-link-text">{{ getText(item) }}</span>
                }
              </span>
            </div>
          }
        </ng-template>
        <ng-template #sectionTemplate>
          <kendo-splitbutton
            #sectionSplitButton
            class="k-toolbar-split-button"
            [data]="data"
            [text]="toolbarOptions.text"
            [icon]="toolbarOptions.icon"
            [iconClass]="toolbarOptions.iconClass"
            [svgIcon]="toolbarOptions.svgIcon"
            [imageUrl]="toolbarOptions.imageUrl"
            [buttonClass]="buttonClass"
            [arrowButtonClass]="arrowButtonClass"
            [arrowButtonIcon]="arrowButtonIcon"
            [arrowButtonSvgIcon]="arrowButtonSvgIcon"
            [disabled]="disabled"
            [size]="size"
            [tabIndex]="-1"
            [textField]="textField"
            [popupSettings]="popupSettings"
            [fillMode]="fillMode"
            [themeColor]="fillMode ? themeColor : null"
            (buttonClick)="buttonClick.emit($event)"
            (open)="open.emit($event)"
            (close)="close.emit($event)"
            (itemClick)="itemClick.emit($event)"
          ></kendo-splitbutton>
        </ng-template>
        `, isInline: true, dependencies: [{ kind: "component", type: SplitButtonComponent, selector: "kendo-splitbutton", inputs: ["text", "icon", "svgIcon", "iconClass", "type", "imageUrl", "size", "rounded", "fillMode", "themeColor", "disabled", "popupSettings", "tabIndex", "textField", "data", "arrowButtonClass", "arrowButtonIcon", "arrowButtonSvgIcon", "buttonAttributes"], outputs: ["buttonClick", "itemClick", "focus", "blur", "open", "close"], exportAs: ["kendoSplitButton"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ToolBarSplitButtonComponent, decorators: [{
            type: Component,
            args: [{
                    exportAs: 'kendoToolBarSplitButton',
                    providers: [{ provide: ToolBarToolComponent, useExisting: forwardRef(() => ToolBarSplitButtonComponent) }],
                    selector: 'kendo-toolbar-splitbutton',
                    template: `
        <ng-template #toolbarTemplate>
          <kendo-splitbutton
            #toolbarSplitButton
            class="k-toolbar-split-button"
            [data]="data"
            [text]="toolbarOptions.text"
            [icon]="toolbarOptions.icon"
            [iconClass]="toolbarOptions.iconClass"
            [svgIcon]="toolbarOptions.svgIcon"
            [imageUrl]="toolbarOptions.imageUrl"
            [buttonClass]="buttonClass"
            [arrowButtonClass]="arrowButtonClass"
            [arrowButtonIcon]="arrowButtonIcon"
            [arrowButtonSvgIcon]="arrowButtonSvgIcon"
            [disabled]="disabled"
            [size]="size"
            [tabIndex]="-1"
            [textField]="textField"
            [popupSettings]="popupSettings"
            [fillMode]="fillMode"
            [themeColor]="fillMode ? themeColor : null"
            (buttonClick)="buttonClick.emit($event)"
            (open)="open.emit($event)"
            (close)="close.emit($event)"
            (itemClick)="itemClick.emit($event)"
          ></kendo-splitbutton>
        </ng-template>
        <ng-template #popupTemplate>
          <div #overflowMainButton
            tabindex="-1"
            role="menuitem"
            class="k-item k-menu-item"
            [class.k-disabled]="disabled"
            [ngClass]="buttonClass"
            (click)="onMainButtonClick($event)">
            <span
              [ngClass]="{'k-link': true, 'k-menu-link': true}"
              >
              @if (overflowOptions.icon || overflowOptions.iconClass || overflowOptions.svgIcon) {
                <kendo-icon-wrapper
                  [name]="overflowOptions.icon"
                  [customFontClass]="overflowOptions.iconClass"
                  [svgIcon]="overflowOptions.svgIcon"
                  >
                </kendo-icon-wrapper>
              }
              @if (overflowOptions.text) {
                <span class="k-menu-link-text">{{overflowOptions.text}}</span>
              }
            </span>
          </div>
          @for (item of data; track item; let i = $index) {
            <div #listItem
              tabindex="-1"
              role="menuitem"
              class="k-item k-menu-item"
              [class.k-disabled]="disabled || item.disabled"
              (click)="handleClick($event, item, i)">
              <span
                class="k-link k-menu-link"
                >
                @if (item.icon || item.iconClass || item.svgIcon) {
                  <kendo-icon-wrapper
                    [name]="item.icon"
                    [customFontClass]="item.iconClass"
                    [svgIcon]="item.svgIcon"
                    >
                  </kendo-icon-wrapper>
                }
                @if (getText(item)) {
                  <span class="k-menu-link-text">{{ getText(item) }}</span>
                }
              </span>
            </div>
          }
        </ng-template>
        <ng-template #sectionTemplate>
          <kendo-splitbutton
            #sectionSplitButton
            class="k-toolbar-split-button"
            [data]="data"
            [text]="toolbarOptions.text"
            [icon]="toolbarOptions.icon"
            [iconClass]="toolbarOptions.iconClass"
            [svgIcon]="toolbarOptions.svgIcon"
            [imageUrl]="toolbarOptions.imageUrl"
            [buttonClass]="buttonClass"
            [arrowButtonClass]="arrowButtonClass"
            [arrowButtonIcon]="arrowButtonIcon"
            [arrowButtonSvgIcon]="arrowButtonSvgIcon"
            [disabled]="disabled"
            [size]="size"
            [tabIndex]="-1"
            [textField]="textField"
            [popupSettings]="popupSettings"
            [fillMode]="fillMode"
            [themeColor]="fillMode ? themeColor : null"
            (buttonClick)="buttonClick.emit($event)"
            (open)="open.emit($event)"
            (close)="close.emit($event)"
            (itemClick)="itemClick.emit($event)"
          ></kendo-splitbutton>
        </ng-template>
        `,
                    standalone: true,
                    imports: [SplitButtonComponent, NgClass, IconWrapperComponent]
                }]
        }], ctorParameters: () => [{ type: ToolBarComponent }], propDecorators: { showText: [{
                type: Input
            }], showIcon: [{
                type: Input
            }], text: [{
                type: Input
            }], icon: [{
                type: Input
            }], svgIcon: [{
                type: Input
            }], iconClass: [{
                type: Input
            }], imageUrl: [{
                type: Input
            }], disabled: [{
                type: Input
            }], popupSettings: [{
                type: Input
            }], fillMode: [{
                type: Input
            }], themeColor: [{
                type: Input
            }], look: [{
                type: Input
            }], buttonClass: [{
                type: Input
            }], arrowButtonClass: [{
                type: Input
            }], arrowButtonIcon: [{
                type: Input
            }], arrowButtonSvgIcon: [{
                type: Input
            }], textField: [{
                type: Input
            }], data: [{
                type: Input
            }], buttonClick: [{
                type: Output
            }], itemClick: [{
                type: Output
            }], open: [{
                type: Output
            }], close: [{
                type: Output
            }], toolbarSplitButton: [{
                type: ViewChild,
                args: ['toolbarSplitButton', { static: false }]
            }], sectionSplitButton: [{
                type: ViewChild,
                args: ['sectionSplitButton', { static: false }]
            }], overflowMainButton: [{
                type: ViewChild,
                args: ['overflowMainButton', { read: ElementRef }]
            }], overflowListItems: [{
                type: ViewChildren,
                args: ['listItem']
            }] } });

/**
 * Represents the [Kendo UI ToolBar Separator for Angular]({% slug controltypes_toolbar %}#toc-separators).
 *
 * Use this component to add a visual separator between ToolBar tools.
 *
 * @example
 * ```html
 * <kendo-toolbar>
 *      <kendo-toolbar-button text="Button 1"></kendo-toolbar-button>
 *      <kendo-toolbar-separator></kendo-toolbar-separator>
 *      <kendo-toolbar-button text="Button 2"></kendo-toolbar-button>
 * </kendo-toolbar>
 * ```
 */
class ToolBarSeparatorComponent extends ToolBarToolComponent {
    separator;
    constructor() {
        super();
        this.isBuiltInTool = true;
    }
    /**
     * @hidden
     */
    canFocus() {
        return false;
    }
    // If this is not here, the docs display info from its parent(ToolBarToolComponent).
    /**
     * @hidden
     */
    focus() {
        /* noop */
    }
    // If this is not here, the docs display info from its parent(ToolBarToolComponent).
    /**
     * @hidden
     */
    handleKey() {
        return false;
    }
    ngAfterViewInit() {
        if (!this.popupTemplate) {
            this.popupTemplate = this.toolbarTemplate;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ToolBarSeparatorComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: ToolBarSeparatorComponent, isStandalone: true, selector: "kendo-toolbar-separator", providers: [{ provide: ToolBarToolComponent, useExisting: forwardRef(() => ToolBarSeparatorComponent) }], viewQueries: [{ propertyName: "separator", first: true, predicate: ["separator"], descendants: true }], exportAs: ["kendoToolBarSeparator"], usesInheritance: true, ngImport: i0, template: `
        <ng-template #toolbarTemplate>
            <div class="k-separator k-toolbar-separator"></div>
        </ng-template>

        <ng-template #sectionTemplate>
            <div class="k-separator k-toolbar-separator"></div>
        </ng-template>

        <ng-template #popupTemplate>
            <div class="k-item k-menu-item">
                <div class="k-separator k-separator-horizontal"></div>
            </div>
        </ng-template>
    `, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ToolBarSeparatorComponent, decorators: [{
            type: Component,
            args: [{
                    exportAs: 'kendoToolBarSeparator',
                    providers: [{ provide: ToolBarToolComponent, useExisting: forwardRef(() => ToolBarSeparatorComponent) }],
                    selector: 'kendo-toolbar-separator',
                    template: `
        <ng-template #toolbarTemplate>
            <div class="k-separator k-toolbar-separator"></div>
        </ng-template>

        <ng-template #sectionTemplate>
            <div class="k-separator k-toolbar-separator"></div>
        </ng-template>

        <ng-template #popupTemplate>
            <div class="k-item k-menu-item">
                <div class="k-separator k-separator-horizontal"></div>
            </div>
        </ng-template>
    `,
                    standalone: true
                }]
        }], ctorParameters: () => [], propDecorators: { separator: [{
                type: ViewChild,
                args: ['separator', { static: false }]
            }] } });

/**
 * Represents the [Kendo UI ToolBar Spacer for Angular]({% slug controltypes_toolbar %}#toc-separators).
 *
 * Use the ToolBar Spacer to add flexible space between ToolBar tools.
 *
 * @example
 * ```html
 * <kendo-toolbar>
 *      <kendo-toolbar-button text="Button 1"></kendo-toolbar-button>
 *      <kendo-toolbar-spacer></kendo-toolbar-spacer>
 *      <kendo-toolbar-button text="Button 2"></kendo-toolbar-button>
 * </kendo-toolbar>
 * ```
 */
class ToolBarSpacerComponent extends ToolBarToolComponent {
    /**
     * @hidden
     */
    __isSpacer = true;
    constructor() {
        super();
        this.isBuiltInTool = true;
    }
    /**
     * @hidden
     */
    canFocus() {
        return false;
    }
    // If this is not here, the docs display info from its parent(ToolBarToolComponent).
    /**
     * @hidden
     */
    focus() {
        /* noop */
    }
    // If this is not here, the docs display info from its parent(ToolBarToolComponent).
    /**
     * @hidden
     */
    handleKey() {
        return false;
    }
    ngAfterViewInit() {
        if (!this.popupTemplate) {
            this.popupTemplate = this.toolbarTemplate;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ToolBarSpacerComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: ToolBarSpacerComponent, isStandalone: true, selector: "kendo-toolbar-spacer", providers: [{ provide: ToolBarToolComponent, useExisting: forwardRef(() => ToolBarSpacerComponent) }], exportAs: ["kendoToolBarSpacer"], usesInheritance: true, ngImport: i0, template: `
        <ng-template #toolbarTemplate>
            <div class="k-spacer"></div>
        </ng-template>
    `, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ToolBarSpacerComponent, decorators: [{
            type: Component,
            args: [{
                    exportAs: 'kendoToolBarSpacer',
                    providers: [{ provide: ToolBarToolComponent, useExisting: forwardRef(() => ToolBarSpacerComponent) }],
                    selector: 'kendo-toolbar-spacer',
                    template: `
        <ng-template #toolbarTemplate>
            <div class="k-spacer"></div>
        </ng-template>
    `,
                    standalone: true
                }]
        }], ctorParameters: () => [] });

/**
 * Represents the custom messages component of the ToolBar.
 *
 * Use this component to override default messages for the ToolBar.
 *
 * @example
 * ```html
 * <kendo-toolbar>
 *      <kendo-toolbar-messages
 *          moreToolsTitle="More options"
 *          previousToolButton="Previous"
 *          nextToolButton="Next">
 *      </kendo-toolbar-messages>
 * </kendo-toolbar>
 * ```
 */
class ToolbarCustomMessagesComponent extends ToolbarMessages {
    service;
    constructor(service) {
        super();
        this.service = service;
    }
    get override() {
        return true;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ToolbarCustomMessagesComponent, deps: [{ token: i1.LocalizationService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: ToolbarCustomMessagesComponent, isStandalone: true, selector: "kendo-toolbar-messages", providers: [
            {
                provide: ToolbarMessages,
                useExisting: forwardRef(() => ToolbarCustomMessagesComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ToolbarCustomMessagesComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: ToolbarMessages,
                            useExisting: forwardRef(() => ToolbarCustomMessagesComponent)
                        }
                    ],
                    selector: 'kendo-toolbar-messages',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1.LocalizationService }] });

/**
* Use this utility array to access all `@progress/kendo-angular-toolbar`-related components and directives in a standalone Angular component.
*
* @example
* ```typescript
* import { Component } from '@angular/core';
* import { KENDO_TOOLBAR } from '@progress/kendo-angular-toolbar';
*
* @Component({
*   selector: 'my-app',
*   standalone: true,
*   imports: [KENDO_TOOLBAR],
*   template: `
*      <kendo-toolbar>
*         <kendo-toolbar-button text="Button"></kendo-toolbar-button>
*      </kendo-toolbar>
*   `
* })
* export class AppComponent {}
* ```
*/
const KENDO_TOOLBAR = [
    ToolBarComponent,
    ToolbarCustomMessagesComponent,
    ToolBarButtonComponent,
    ToolBarButtonGroupComponent,
    ToolBarDropDownButtonComponent,
    ToolBarSeparatorComponent,
    ToolBarSpacerComponent,
    ToolBarSplitButtonComponent,
    ToolBarToolComponent
];

// IMPORTANT: NgModule export kept for backwards compatibility
/**
 * Represents the [`NgModule`](link:site.data.urls.angular['ngmoduleapi']) definition for the ToolBar component.
 *
 * @example
 * ```typescript
 * import { ToolBarModule } from '@progress/kendo-angular-toolbar';
 *
 * @NgModule({
 *   imports: [ToolBarModule]
 * })
 * export class AppModule {}
 * ```
 */
class ToolBarModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ToolBarModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.18", ngImport: i0, type: ToolBarModule, imports: [ToolBarComponent, ToolbarCustomMessagesComponent, ToolBarButtonComponent, ToolBarButtonGroupComponent, ToolBarDropDownButtonComponent, ToolBarSeparatorComponent, ToolBarSpacerComponent, ToolBarSplitButtonComponent, ToolBarToolComponent], exports: [ToolBarComponent, ToolbarCustomMessagesComponent, ToolBarButtonComponent, ToolBarButtonGroupComponent, ToolBarDropDownButtonComponent, ToolBarSeparatorComponent, ToolBarSpacerComponent, ToolBarSplitButtonComponent, ToolBarToolComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ToolBarModule, providers: [IconsService, PopupService, ResizeBatchService], imports: [ToolBarComponent, ToolBarButtonComponent, ToolBarButtonGroupComponent, ToolBarDropDownButtonComponent, ToolBarSplitButtonComponent] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: ToolBarModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [...KENDO_TOOLBAR],
                    imports: [...KENDO_TOOLBAR],
                    providers: [IconsService, PopupService, ResizeBatchService]
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { KENDO_TOOLBAR, LocalizedToolbarMessagesDirective, RefreshService, ToolBarButtonComponent, ToolBarButtonGroupComponent, ToolBarComponent, ToolBarDropDownButtonComponent, ToolBarModule, ToolBarSeparatorComponent, ToolBarSpacerComponent, ToolBarSplitButtonComponent, ToolBarToolComponent, ToolbarCustomMessagesComponent };

