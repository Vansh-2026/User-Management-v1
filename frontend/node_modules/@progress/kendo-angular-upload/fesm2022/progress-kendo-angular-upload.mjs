/**-----------------------------------------------------------------------------------------
* Copyright © 2026 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import * as i1 from '@angular/common/http';
import { HttpHeaders, HttpRequest, HttpEventType, HttpResponse } from '@angular/common/http';
import * as i0 from '@angular/core';
import { EventEmitter, Injectable, Directive, ElementRef, Output, HostBinding, Input, ViewChild, ContentChild, Component, HostListener, ViewChildren, Inject, forwardRef, isDevMode, NgModule } from '@angular/core';
import { guid, isDocumentAvailable, normalizeKeys, Keys, isControlRequired, isChanged, KendoInput, ResizeBatchService } from '@progress/kendo-angular-common';
import { fileDiscImageIcon, fileZipIcon, fileConfigIcon, filePdfIcon, fileProgrammingIcon, fileDataIcon, filePresentationIcon, fileTxtIcon, fileImageIcon, fileVideoIcon, fileAudioIcon, fileIcon, arrowRotateCwSmallIcon, playSmIcon, pauseSmIcon, cancelIcon, xIcon, copyIcon, checkIcon, exclamationCircleIcon, uploadIcon } from '@progress/kendo-svg-icons';
import { NgControl, NG_VALUE_ACCESSOR } from '@angular/forms';
import * as i1$1 from '@progress/kendo-angular-l10n';
import { ComponentMessages, LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';
import { fromEvent, merge } from 'rxjs';
import { filter } from 'rxjs/operators';
import { validatePackage } from '@progress/kendo-licensing';
import { trigger, state, transition, style, animate } from '@angular/animations';
import { ButtonComponent } from '@progress/kendo-angular-buttons';
import { NgClass, NgTemplateOutlet } from '@angular/common';
import { IconWrapperComponent, IconsService } from '@progress/kendo-angular-icons';
import { ProgressBarComponent } from '@progress/kendo-angular-progressbar';
import { PopupService } from '@progress/kendo-angular-popup';

/**
 * Lists the possible states of a file.
 */
var FileState;
(function (FileState) {
    /**
     * The file upload process failed.
     */
    FileState[FileState["Failed"] = 0] = "Failed";
    /**
     * An initially selected file without a set state.
     */
    FileState[FileState["Initial"] = 1] = "Initial";
    /**
     * The file is selected.
     */
    FileState[FileState["Selected"] = 2] = "Selected";
    /**
     * The file uploaded successfully.
     */
    FileState[FileState["Uploaded"] = 3] = "Uploaded";
    /**
     * The file is uploading.
     */
    FileState[FileState["Uploading"] = 4] = "Uploading";
    /**
     * The file upload process is paused.
     */
    FileState[FileState["Paused"] = 5] = "Paused";
})(FileState || (FileState = {}));

/**
 * @hidden
 */
class FileMap {
    _files;
    constructor() {
        this._files = {};
    }
    add(file) {
        const uid = file.uid;
        if (this.has(uid)) {
            if (file.validationErrors && file.validationErrors.length > 0) {
                this._files[uid].unshift(file);
            }
            else {
                this._files[uid].push(file);
            }
        }
        else {
            this._files[uid] = [file];
        }
    }
    remove(uid) {
        if (this.has(uid)) {
            this._files[uid] = null;
            delete this._files[uid];
        }
    }
    clear() {
        const allFiles = this._files;
        for (const uid in allFiles) {
            if (allFiles.hasOwnProperty(uid)) {
                for (const file of allFiles[uid]) {
                    if (file.httpSubscription) {
                        file.httpSubscription.unsubscribe();
                    }
                }
                allFiles[uid] = null;
                delete allFiles[uid];
            }
        }
    }
    has(uid) {
        return uid in this._files;
    }
    get(uid) {
        return this._files[uid];
    }
    setFilesState(files, state) {
        for (const file of files) {
            this.setFilesStateByUid(file.uid, state);
        }
    }
    setFilesStateByUid(uid, state) {
        this.get(uid).forEach((f) => {
            f.state = state;
        });
    }
    get count() {
        return Object.getOwnPropertyNames(this._files).length;
    }
    get files() {
        const initial = this._files;
        const transformed = [];
        for (const uid in initial) {
            if (initial.hasOwnProperty(uid)) {
                transformed.push(initial[uid]);
            }
        }
        return transformed;
    }
    get filesFlat() {
        const initial = this._files;
        const transformed = [];
        for (const uid in initial) {
            if (initial.hasOwnProperty(uid)) {
                const current = initial[uid];
                current.forEach((file) => {
                    transformed.push(file);
                });
            }
        }
        return transformed;
    }
    get filesToUpload() {
        const files = this._files;
        const notUploaded = [];
        for (const uid in files) {
            if (files.hasOwnProperty(uid)) {
                const currentFiles = files[uid];
                let currentFilesValid = true;
                for (const file of currentFiles) {
                    if (file.state !== FileState.Selected || (file.validationErrors && file.validationErrors.length > 0)) {
                        currentFilesValid = false;
                    }
                }
                if (currentFilesValid) {
                    notUploaded.push(currentFiles);
                }
            }
        }
        return notUploaded;
    }
    get firstFileToUpload() {
        const files = this._files;
        for (const uid in files) {
            if (files.hasOwnProperty(uid)) {
                const currentFiles = files[uid];
                let currentFilesValid = true;
                for (const file of currentFiles) {
                    if (file.state !== FileState.Selected || (file.validationErrors && file.validationErrors.length > 0)) {
                        currentFilesValid = false;
                    }
                }
                if (currentFilesValid) {
                    return currentFiles;
                }
            }
        }
        return null;
    }
    getFilesWithState(state) {
        return this.filesFlat.filter(file => file.state === state);
    }
    hasFileWithState(fileStates) {
        const files = this._files;
        for (const uid in files) {
            if (files.hasOwnProperty(uid)) {
                const currentFiles = files[uid];
                for (const file of currentFiles) {
                    if (fileStates.indexOf(file.state) >= 0) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
}

/**
 * Arguments for the `cancel` event. The `cancel` event fires when
 * you cancel the upload of a file or batch of files.
 *
 * ```typescript
 * @Component({
 *    template: `
 *    <kendo-upload (cancel)="cancelEventHandler($event)"></kendo-upload>
 *    `
 *  })
 *  export class UploadComponent {
 *    public cancelEventHandler(e: CancelEvent) {
 *      console.log('Canceling file upload', e.files);
 *    }
 * }
 * ```
 */
class CancelEvent {
    /**
     * The files that you canceled during the upload process.
     */
    files;
    /**
     * @hidden
     * Constructs the event arguments for the `cancel` event.
     * @param files - The list of the files that were going to be uploaded.
     */
    constructor(files) {
        this.files = files;
    }
}

/**
 * @hidden
 */
class PreventableEvent {
    prevented = false;
    /**
     * Prevents the default action for a specified event.
     * In this way, the source component suppresses the built-in behavior that follows the event.
     */
    preventDefault() {
        this.prevented = true;
    }
    /**
     * If the event is prevented by any of its subscribers, returns `true`.
     *
     * @returns `true` if the default action was prevented. Otherwise, returns `false`.
     */
    isDefaultPrevented() {
        return this.prevented;
    }
}

/**
 * Arguments for the `clear` event. The `clear` event fires when
 * the **Clear** button is clicked and selected files are about to be cleared.
 *
 * ```typescript
 * @Component({
 *    template: `
 *    <kendo-upload (clear)="clearEventHandler($event)"></kendo-upload>
 *    `
 *  })
 *  export class UploadComponent {
 *    public clearEventHandler(e: ClearEvent) {
 *      console.log('Clearing the file upload');
 *    }
 * }
 * ```
 */
class ClearEvent extends PreventableEvent {
    /**
     * @hidden
     * Constructs the event arguments for the `clear` event.
     */
    constructor() { super(); }
}

/**
 * Arguments for the `error` event. The `error` event fires when
 * an `upload` or `remove` operation fails.
 *
 * ```typescript
 * @Component({
 *    template: `
 *    <kendo-upload (error)="errorEventHandler($event)"></kendo-upload>
 *    `
 *  })
 *  export class UploadComponent {
 *   public errorEventHandler(e: ErrorEvent) {
 *      console.log('An error occurred');
 *    }
 * }
 * ```
 */
class ErrorEvent {
    /**
     * The array of files that failed to be uploaded or removed.
     */
    files;
    /**
     * The operation type that failed (`upload` or `remove`).
     */
    operation;
    /**
     * The HTTP response returned by the server containing error details.
     */
    response;
    /**
     * @hidden
     * Constructs the event arguments for the `error` event.
     *
     * @param files - The list of the files that failed to be uploaded or removed.
     * @param operation - The operation type (`upload` or `remove`).
     * @param response - The response object returned by the server.
     */
    constructor(files, operation, response) {
        this.files = files;
        this.operation = operation;
        this.response = response;
    }
}

/**
 * Arguments for the `pause` event. The `pause` event fires when
 * you pause a file that is currently uploading.
 *
 * ```typescript
 *  @Component({
 *    template: `
 *    <kendo-upload
 *      [chunkable]="true"
 *      (pause)="pauseEventHandler($event)">
 *    </kendo-upload>
 *    `
 *  })
 *  export class UploadComponent {
 *    public pauseEventHandler(ev: PauseEvent) {
 *      console.log('File paused');
 *    }
 *  }
 * ```
 */
class PauseEvent {
    /**
     * The file that you paused during the upload process.
     */
    file;
    /**
     * @hidden
     * Constructs the event arguments for the `pause` event.
     * @param file - The file that is going to be paused.
     */
    constructor(file) {
        this.file = file;
    }
}

/**
 * Arguments for the `remove` event. The `remove` event fires when you are about to remove an uploaded
 * or selected file. You can cancel this event to prevent removal.
 *
 * ```typescript
 *  @Component({
 *    template: `
 *    <kendo-upload (remove)="removeEventHandler($event)"></kendo-upload>
 *    `
 *  })
 *  export class UploadComponent {
 *    public removeEventHandler(e: RemoveEvent) {
 *      console.log('Removing a file');
 *    }
 *  }
 * ```
 */
class RemoveEvent extends PreventableEvent {
    /**
     * An optional object that you send to the `remove` handler as key/value pairs.
     *
     */
    data;
    /**
     * The files that you will remove from the server.
     */
    files;
    /**
     * The headers of the request.
     * You can use this to add custom headers to the remove request.
     */
    headers;
    /**
     * @hidden
     * Constructs the event arguments for the `remove` event.
     * @param files - The list of the files that will be removed.
     * @param headers - The headers of the request.
     */
    constructor(files, headers) {
        super();
        this.files = files;
        this.headers = headers;
    }
}

/**
 * Arguments for the `resume` event. The `resume` event fires when
 * you resume a previously paused file upload.
 *
 * ```typescript
 *  @Component({
 *    template: `
 *    <kendo-upload
 *      [chunkable]="true"
 *      (resume)="resumeEventHandler($event)">
 *    </kendo-upload>
 *    `
 *  })
 *  export class UploadComponent {
 *    public resumeEventHandler(ev: ResumeEvent) {
 *      console.log('File resumed');
 *    }
 *  }
 * ```
 */
class ResumeEvent {
    /**
     * The file that you resumed during the upload process.
     */
    file;
    /**
     * @hidden
     * Constructs the event arguments for the `resume` event.
     * @param file - The file that is going to be resumed.
     */
    constructor(file) {
        this.file = file;
    }
}

/**
 * Arguments for the `select` event. The `select` event fires when
 * a file or multiple files are selected for upload. The event can be canceled to prevent selection.
 *
 * ```typescript
 *  @Component({
 *    template: `
 *    <kendo-upload (select)="selectEventHandler($event)"></kendo-upload>
 *    `
 *  })
 *  export class UploadComponent {
 *    public selectEventHandler(e: SelectEvent) {
 *      console.log('File selected');
 *    }
 *  }
 * ```
 */
class SelectEvent extends PreventableEvent {
    /**
     * The files that are selected for upload.
     */
    files;
    /**
     * @hidden
     * Constructs the event arguments for the `select` event.
     * @param files - The list of the selected files.
     */
    constructor(files) {
        super();
        this.files = files;
    }
}

/**
 * Arguments for the `success` event. The `success` event fires when
 * you successfully upload or remove the selected files.
 *
 * ```typescript
 *  @Component({
 *    template: `
 *    <kendo-upload (success)="successEventHandler($event)"></kendo-upload>
 *    `
 *  })
 *  export class UploadComponent {
 *    public successEventHandler(e: SuccessEvent) {
 *      console.log('The ' + e.operation + ' was successful!');
 *    }
 *  }
 * ```
 */
class SuccessEvent extends PreventableEvent {
    /**
     * The files that you successfully uploaded or removed.
     */
    files;
    /**
     * The operation type that succeeded (`upload` or `remove`).
     */
    operation;
    /**
     * The HTTP response that the server returns to confirm success.
     */
    response;
    /**
     * @hidden
     * Constructs the event arguments for the `success` event.
     * @param files - The list of the files that were uploaded or removed.
     * @param operation - The operation type (`upload` or `remove`).
     * @param response - The response object returned by the server.
     */
    constructor(files, operation, response) {
        super();
        this.files = files;
        this.operation = operation;
        this.response = response;
    }
}

/**
 * Arguments for the `upload` event. The `upload` event fires when you are about
 * to upload one or more files. You can cancel this event to prevent upload and add headers to the request.
 *
 * ```typescript
 *  @Component({
 *    template: `
 *    <kendo-upload (upload)="uploadEventHandler($event)"></kendo-upload>
 *    `
 *  })
 *  export class UploadComponent {
 *    public uploadEventHandler(e: UploadEvent) {
 *      e.headers = e.headers.append('X-Foo', 'Bar');
 *    }
 *  }
 * ```
 */
class UploadEvent extends PreventableEvent {
    /**
     * The optional object that you send to the `upload` handler as key/value pairs.
     *
     */
    data;
    /**
     * The files that you will upload to the server.
     */
    files;
    /**
     * The headers of the request.
     * You can use this to add custom headers to the upload request.
     */
    headers;
    /**
     * @hidden
     * Constructs the event arguments for the `upload` event.
     * @param files - The list of the files that will be uploaded.
     * @param headers - The headers of the request.
     */
    constructor(files, headers) {
        super();
        this.files = files;
        this.headers = headers;
    }
}

/**
 * Arguments for the `uploadprogress` event. The `uploadprogress` event
 * fires when you upload files.
 *
 * ```typescript
 *  @Component({
 *    template: `
 *    <kendo-upload (uploadProgress)="uploadProgressEventHandler($event)"></kendo-upload>
 *    `
 *  })
 *  export class UploadComponent {
 *    public uploadProgressEventHandler(e: UploadProgressEvent) {
 *      console.log(e.files[0].name + ' is ' + e.percentComplete + ' uploaded');
 *    }
 *  }
 * ```
 */
class UploadProgressEvent {
    /**
     * The files that you are currently uploading.
     */
    files;
    /**
     * The upload progress as a percentage from 0 to 100.
     */
    percentComplete;
    /**
     * @hidden
     * Constructs the event arguments for the `uploadprogress` event.
     * @param files - The list of files that are being uploaded.
     * @param percentComplete - The portion that has been uploaded.
     */
    constructor(files, percentComplete) {
        this.files = files;
        this.percentComplete = percentComplete;
    }
}

/**
 * @hidden
 */
const fileGroupMap = {
    audio: [
        ".aif", ".iff", ".m3u", ".m4a", ".mid", ".mp3", ".mpa", ".wav", ".wma", ".ogg", ".wav", ".wma", ".wpl"
    ],
    video: [
        ".3g2", ".3gp", ".avi", ".asf", ".flv", ".m4u", ".rm", ".h264", ".m4v", ".mkv", ".mov", ".mp4", ".mpg", ".rm", ".swf", ".vob", ".wmv"
    ],
    image: [
        ".ai", ".dds", ".heic", ".jpe", "jfif", ".jif", ".jp2", ".jps", ".eps", ".bmp", ".gif", ".jpeg", ".jpg", ".png", ".ps", ".psd", ".svg", ".svgz", ".tif", ".tiff"
    ],
    txt: [
        ".doc", ".docx", ".log", ".pages", ".tex", ".wpd", ".wps", ".odt", ".rtf", ".text", ".txt", ".wks"
    ],
    presentation: [
        ".key", ".odp", ".pps", ".ppt", ".pptx"
    ],
    data: [
        ".xlr", ".xls", ".xlsx"
    ],
    programming: [
        ".tmp", ".bak", ".msi", ".cab", ".cpl", ".cur", ".dll", ".dmp", ".drv", ".icns", ".ico", ".link", ".sys", ".cfg",
        ".ini", ".asp", ".aspx", ".cer", ".csr", ".css", ".dcr", ".htm", ".html", ".js", ".php", ".rss", ".xhtml"
    ],
    pdf: [
        ".pdf"
    ],
    config: [
        ".apk", ".app", ".bat", ".cgi", ".com", ".exe", ".gadget", ".jar", ".wsf"
    ],
    zip: [
        ".7z", ".cbr", ".gz", ".sitx", ".arj", ".deb", ".pkg", ".rar", ".rpm", ".tar.gz", ".z", ".zip", ".zipx"
    ],
    discImage: [
        ".dmg", ".iso", ".toast", ".vcd", ".bin", ".cue", ".mdf"
    ]
};
/**
 * @hidden
 */
const fileSVGGroupMap = {
    audio: fileAudioIcon,
    video: fileVideoIcon,
    image: fileImageIcon,
    txt: fileTxtIcon,
    presentation: filePresentationIcon,
    data: fileDataIcon,
    programming: fileProgrammingIcon,
    pdf: filePdfIcon,
    config: fileConfigIcon,
    zip: fileZipIcon,
    discImage: fileDiscImageIcon
};

/* eslint-disable  no-bitwise */
/**
 * Calculates the total size of the files in KB or MB.
 */
const getTotalFilesSizeMessage = (files) => {
    let totalSize = 0;
    let i;
    if (typeof files[0].size === "number") {
        for (i = 0; i < files.length; i++) {
            if (files[i].size) {
                totalSize += files[i].size;
            }
        }
    }
    else {
        return "";
    }
    totalSize /= 1024;
    if (totalSize < 1024) {
        return totalSize.toFixed(2) + " KB";
    }
    else {
        return (totalSize / 1024).toFixed(2) + " MB";
    }
};
const stripPath = (name) => {
    const slashIndex = name.lastIndexOf("\\");
    return (slashIndex !== -1) ? name.substr(slashIndex + 1) : name;
};
const getFileExtension = (fileName) => {
    const rFileExtension = /\.([^\.]+)$/;
    const matches = fileName.match(rFileExtension);
    return matches ? matches[0] : "";
};
/**
 * @hidden
 */
const validateInitialFileInfo = (file) => {
    if (file instanceof Object && file.hasOwnProperty("name")) {
        return true;
    }
    return false;
};
/**
 * @hidden
 */
const validateInitialFileSelectFile = (file) => {
    if (file instanceof File || validateInitialFileInfo(file)) {
        return true;
    }
    return false;
};
/**
 * @hidden
 */
const getInitialFileInfo = (fakeFile) => {
    fakeFile.extension = fakeFile.extension || getFileExtension(fakeFile.name);
    fakeFile.name = fakeFile.name; // eslint-disable-line no-self-assign
    fakeFile.size = fakeFile.size || 0;
    if (!fakeFile.hasOwnProperty("state")) {
        fakeFile.state = FileState.Initial;
    }
    if (!fakeFile.hasOwnProperty("uid")) {
        fakeFile.uid = guid();
    }
    return fakeFile;
};
/**
 * @hidden
 */
const convertFileToFileInfo = (file) => {
    const fileInfo = getFileInfo(file);
    fileInfo.uid = guid();
    // Used to differentiate initial FileInfo objects and actual Files
    fileInfo.state = FileState.Selected;
    return fileInfo;
};
const getFileInfo = (rawFile) => {
    const fileName = rawFile.name;
    const fileSize = rawFile.size;
    return {
        extension: getFileExtension(fileName),
        name: fileName,
        rawFile: rawFile,
        size: fileSize,
        state: FileState.Selected
    };
};
/**
 * @hidden
 */
const getAllFileInfo = (rawFiles) => {
    const allFileInfo = new Array();
    let i;
    for (i = 0; i < rawFiles.length; i++) {
        allFileInfo.push(getFileInfo(rawFiles[i]));
    }
    return allFileInfo;
};
/**
 * @hidden
 */
const fileHasValidationErrors = (file) => {
    if (file.validationErrors && file.validationErrors.length > 0) {
        return true;
    }
    return false;
};
/**
 * @hidden
 */
const filesHaveValidationErrors = (files) => {
    for (const file of files) {
        if (fileHasValidationErrors(file)) {
            return true;
        }
    }
    return false;
};
/**
 * @hidden
 */
const inputFiles = (input) => {
    if (input.files) {
        return getAllFileInfo(input.files);
    }
    else {
        //Required for testing
        const fileNames = input.value.split("|").map((file, index) => {
            const fileName = file.trim();
            return {
                extension: getFileExtension(fileName),
                name: stripPath(fileName),
                rawFile: null,
                size: (index + 1) * 1000,
                state: FileState.Selected
            };
        });
        return fileNames;
    }
};
/**
 * @hidden
 */
const assignGuidToFiles = (files, isUnique) => {
    const uid = guid();
    return files.map((file) => {
        file.uid = isUnique ? guid() : uid;
        return file;
    });
};
/**
 * @hidden
 */
const supportsFormData = () => {
    return typeof (FormData) !== "undefined";
};
/**
 * @hidden
 */
const userAgent = () => {
    return navigator.userAgent;
};
const focusableRegex = /^(?:a|input|select|textarea|button|object)$/i;
/**
 * @hidden
 */
const IGNORE_TARGET_CLASSES = 'k-icon k-select k-input k-multiselect-wrap';
/**
 * @hidden
 */
const UPLOAD_CLASSES = 'k-upload-button k-clear-selected k-upload-selected k-upload-action k-file';
const isVisible = (element) => {
    if (!isDocumentAvailable()) {
        return false;
    }
    const rect = element.getBoundingClientRect();
    return !!(rect.width && rect.height) && window.getComputedStyle(element).visibility !== 'hidden';
};
const toClassList = (classNames) => String(classNames).trim().split(' ');
/**
 * @hidden
 */
const hasClasses = (element, classNames) => {
    const namesList = toClassList(classNames);
    return Boolean(toClassList(element.className).find((className) => namesList.indexOf(className) >= 0));
};
/**
 * @hidden
 */
const isFocusable = (element, checkVisibility = true) => {
    if (element.tagName) {
        const tagName = element.tagName.toLowerCase();
        const tabIndex = element.getAttribute('tabIndex');
        const validTabIndex = tabIndex !== null && !isNaN(tabIndex) && tabIndex > -1;
        let focusable = false;
        if (focusableRegex.test(tagName)) {
            focusable = !element.disabled;
        }
        else {
            focusable = validTabIndex;
        }
        return focusable && (!checkVisibility || isVisible(element));
    }
    return false;
};
/**
 * @hidden
 */
const getFileGroupCssClass = (fileExtension) => {
    const initial = 'file';
    for (const group in fileGroupMap) {
        if (fileGroupMap[group].indexOf(fileExtension) >= 0) {
            if (group === 'discImage') {
                return `${initial}-disc-image`;
            }
            return `${initial}-${group}`;
        }
    }
    return initial;
};
/**
 * @hidden
 */
const isPresent = (value) => value !== null && value !== undefined;
/**
 * Matches the file extension with the corresponding SVG icon.
 * @returns The SVG icon that corresponds to the file extension.
 */
const fileSVGGroupIcon = (extension) => {
    const initial = fileIcon;
    if (extension) {
        for (const group in fileGroupMap) {
            if (fileGroupMap[group].indexOf(extension.toLowerCase()) >= 0) {
                return fileSVGGroupMap[group];
            }
        }
    }
    return initial;
};
/**
 * Matches the file extension with the corresponding CSS class.
 * @returns The CSS class name that corresponds to the file extension.
 */
const fileGroupClass = (extension) => getFileGroupCssClass(extension || '');

/**
 * @hidden
 */
class ChunkMap {
    _files;
    constructor() {
        this._files = {};
    }
    add(uid, totalChunks) {
        const initialChunkInfo = {
            index: 0,
            position: 0,
            retries: 0,
            totalChunks: totalChunks
        };
        this._files[uid] = initialChunkInfo;
        return initialChunkInfo;
    }
    remove(uid) {
        if (this.has(uid)) {
            this._files[uid] = null;
            delete this._files[uid];
        }
    }
    has(uid) {
        return uid in this._files;
    }
    get(uid) {
        return this._files[uid];
    }
}

/**
 * @hidden
 */
class UploadService {
    http;
    cancelEvent = new EventEmitter();
    clearEvent = new EventEmitter();
    completeEvent = new EventEmitter();
    errorEvent = new EventEmitter();
    pauseEvent = new EventEmitter();
    removeEvent = new EventEmitter();
    resumeEvent = new EventEmitter();
    selectEvent = new EventEmitter();
    successEvent = new EventEmitter();
    uploadEvent = new EventEmitter();
    uploadProgressEvent = new EventEmitter();
    /**
     * Required for the `ControlValueAccessor` integration
     */
    changeEvent = new EventEmitter();
    /**
     * Default async settings
     */
    async = {
        autoUpload: true,
        batch: false,
        chunk: false,
        concurrent: true,
        removeField: "fileNames",
        removeHeaders: new HttpHeaders(),
        removeMethod: "POST",
        removeUrl: "",
        responseType: "json",
        saveField: "files",
        saveHeaders: new HttpHeaders(),
        saveMethod: "POST",
        saveUrl: "",
        withCredentials: true
    };
    /**
     * Default chunk settings
     */
    chunk = {
        autoRetryAfter: 100,
        size: 1024 * 1024,
        maxAutoRetries: 1,
        resumable: true
    };
    component = 'Upload';
    chunkMap = new ChunkMap();
    fileList = new FileMap();
    constructor(http) {
        this.http = http;
    }
    get files() {
        return this.fileList;
    }
    setChunkSettings(settings) {
        if (settings !== false) {
            this.async.chunk = true;
            if (typeof settings === "object") {
                this.chunk = Object.assign({}, this.chunk, settings);
            }
        }
    }
    onChange() {
        const files = this.fileList.filesFlat.filter((file) => {
            return file.state === FileState.Initial ||
                file.state === FileState.Uploaded;
        });
        this.changeEvent.emit(files.length > 0 ? files : null);
    }
    addFiles(files) {
        const selectEventArgs = new SelectEvent(files);
        this.selectEvent.emit(selectEventArgs);
        if (!selectEventArgs.isDefaultPrevented()) {
            for (const file of files) {
                this.fileList.add(file);
            }
            if (this.async.autoUpload) {
                this.uploadFiles();
            }
        }
        if (this.component === 'FileSelect') {
            const flatFiles = this.fileList.filesFlat;
            this.changeEvent.emit(flatFiles.length > 0 ? flatFiles : null);
        }
    }
    addInitialFiles(initialFiles) {
        this.fileList.clear();
        initialFiles.forEach((file) => {
            const fakeFile = getInitialFileInfo(file);
            this.fileList.add(fakeFile);
        });
    }
    addInitialFileSelectFiles(initialFiles) {
        this.fileList.clear();
        initialFiles.forEach((file) => {
            if (file instanceof File) {
                this.fileList.add(convertFileToFileInfo(file));
            }
            else {
                this.fileList.add(getInitialFileInfo(file));
            }
        });
    }
    resumeFile(uid) {
        const fileToResume = this.fileList.get(uid);
        this.resumeEvent.emit(new ResumeEvent(fileToResume[0]));
        this.fileList.setFilesStateByUid(uid, FileState.Uploading);
        this._uploadFiles([fileToResume]);
    }
    pauseFile(uid) {
        const pausedFile = this.fileList.get(uid)[0];
        this.pauseEvent.emit(new PauseEvent(pausedFile));
        this.fileList.setFilesStateByUid(uid, FileState.Paused);
    }
    removeFiles(uid) {
        const removedFiles = this.fileList.get(uid);
        // Clone the Headers so that the default ones are not overridden
        const removeEventArgs = new RemoveEvent(removedFiles, this.cloneRequestHeaders(this.async.removeHeaders));
        this.removeEvent.emit(removeEventArgs);
        if (!removeEventArgs.isDefaultPrevented()) {
            if (this.component === 'Upload' &&
                (removedFiles[0].state === FileState.Uploaded ||
                    removedFiles[0].state === FileState.Initial)) {
                this.performRemove(removedFiles, removeEventArgs);
            }
            else {
                this.fileList.remove(uid);
                if (this.component === 'FileSelect') {
                    const flatFiles = this.fileList.filesFlat;
                    this.changeEvent.emit(flatFiles.length > 0 ? flatFiles : null);
                }
            }
        }
    }
    cancelFiles(uid) {
        const canceledFiles = this.fileList.get(uid);
        const cancelEventArgs = new CancelEvent(canceledFiles);
        this.cancelEvent.emit(cancelEventArgs);
        for (const file of canceledFiles) {
            if (file.httpSubscription) {
                file.httpSubscription.unsubscribe();
            }
        }
        this.fileList.remove(uid);
        this.checkAllComplete();
    }
    clearFiles() {
        const clearEventArgs = new ClearEvent();
        this.clearEvent.emit(clearEventArgs);
        if (!clearEventArgs.isDefaultPrevented()) {
            const triggerChange = this.fileList.hasFileWithState([
                FileState.Initial,
                FileState.Uploaded
            ]);
            this.fileList.clear();
            if (triggerChange) {
                this.onChange();
            }
        }
    }
    uploadFiles() {
        let filesToUpload = [];
        if (this.async.concurrent) {
            filesToUpload = this.fileList.filesToUpload;
        }
        if (!this.async.concurrent && !this.fileList.hasFileWithState([FileState.Uploading])) {
            filesToUpload = this.fileList.firstFileToUpload ? [this.fileList.firstFileToUpload] : [];
        }
        if (filesToUpload && filesToUpload.length > 0) {
            this._uploadFiles(filesToUpload);
        }
    }
    retryFiles(uid) {
        const filesToRetry = [this.fileList.get(uid)];
        if (filesToRetry) {
            this._uploadFiles(filesToRetry);
        }
    }
    _uploadFiles(allFiles) {
        for (const filesToUpload of allFiles) {
            if (filesToUpload[0].state === FileState.Paused) {
                return;
            }
            // Clone the Headers so that the default ones are not overridden
            const uploadEventArgs = new UploadEvent(filesToUpload, this.cloneRequestHeaders(this.async.saveHeaders));
            this.uploadEvent.emit(uploadEventArgs);
            if (!uploadEventArgs.isDefaultPrevented()) {
                this.fileList.setFilesState(filesToUpload, FileState.Uploading);
                const httpSubcription = this.performUpload(filesToUpload, uploadEventArgs);
                filesToUpload.forEach((file) => {
                    file.httpSubscription = httpSubcription;
                });
            }
            else {
                this.fileList.remove(filesToUpload[0].uid);
                this.checkAllComplete();
            }
        }
    }
    performRemove(files, removeEventArgs) {
        const async = this.async;
        const fileNames = files.map((file) => {
            return file.name;
        });
        const formData = this.populateRemoveFormData(fileNames, removeEventArgs.data);
        const options = this.populateRequestOptions(removeEventArgs.headers, false);
        const removeRequest = new HttpRequest(async.removeMethod, async.removeUrl, formData, options);
        this.http.request(removeRequest)
            .subscribe(success => {
            this.onSuccess(success, files, "remove");
        }, error => {
            this.onError(error, files, "remove");
        });
    }
    performUpload(files, uploadEventArgs) {
        const async = this.async;
        const formData = this.populateUploadFormData(files, uploadEventArgs.data);
        const options = this.populateRequestOptions(uploadEventArgs.headers);
        const uploadRequest = new HttpRequest(async.saveMethod, async.saveUrl, formData, options);
        const httpSubscription = this.http.request(uploadRequest)
            .subscribe(event => {
            if (event.type === HttpEventType.UploadProgress && !this.async.chunk) {
                this.onProgress(event, files);
            }
            else if (event instanceof HttpResponse) {
                this.onSuccess(event, files, "upload");
                this.checkAllComplete();
            }
        }, error => {
            this.onError(error, files, "upload");
            this.checkAllComplete();
        });
        return httpSubscription;
    }
    onSuccess(successResponse, files, operation) {
        if (operation === "upload" && this.async.chunk) {
            this.onChunkProgress(files);
            if (this.isChunkUploadComplete(files[0].uid)) {
                this.removeChunkInfo(files[0].uid);
            }
            else {
                this.updateChunkInfo(files[0].uid);
                this._uploadFiles([files]);
                return;
            }
        }
        const successArgs = new SuccessEvent(files, operation, successResponse);
        this.successEvent.emit(successArgs);
        if (operation === "upload") {
            this.fileList.setFilesState(files, successArgs.isDefaultPrevented() ? FileState.Failed : FileState.Uploaded);
        }
        else {
            if (!successArgs.isDefaultPrevented()) {
                this.fileList.remove(files[0].uid);
            }
        }
        if (!successArgs.isDefaultPrevented()) {
            this.onChange();
        }
    }
    onError(errorResponse, files, operation) {
        if (operation === "upload" && this.async.chunk) {
            const maxRetries = this.chunk.maxAutoRetries;
            const chunkInfo = this.chunkMap.get(files[0].uid);
            if (chunkInfo.retries < maxRetries) {
                chunkInfo.retries += 1;
                setTimeout(() => {
                    this.retryFiles(files[0].uid);
                }, this.chunk.autoRetryAfter);
                return;
            }
        }
        const errorArgs = new ErrorEvent(files, operation, errorResponse);
        this.errorEvent.emit(errorArgs);
        if (operation === "upload") {
            this.fileList.setFilesState(files, FileState.Failed);
        }
    }
    onProgress(event, files) {
        const percentComplete = Math.round(100 * event.loaded / event.total);
        const progressArgs = new UploadProgressEvent(files, percentComplete < 100 ? percentComplete : 100);
        this.uploadProgressEvent.emit(progressArgs);
    }
    onChunkProgress(files) {
        const chunkInfo = this.chunkMap.get(files[0].uid);
        let percentComplete = 0;
        if (chunkInfo) {
            if (chunkInfo.index === chunkInfo.totalChunks - 1) {
                percentComplete = 100;
            }
            else {
                percentComplete = Math.round(((chunkInfo.index + 1) / chunkInfo.totalChunks) * 100);
            }
        }
        const progressArgs = new UploadProgressEvent(files, percentComplete < 100 ? percentComplete : 100);
        this.uploadProgressEvent.emit(progressArgs);
    }
    checkAllComplete() {
        if (!this.fileList.hasFileWithState([
            FileState.Uploading,
            FileState.Paused
        ]) && this.areAllSelectedFilesHandled()) {
            this.completeEvent.emit();
        }
        else if (this.shouldUploadNextFile()) {
            this.uploadFiles();
        }
    }
    shouldUploadNextFile() {
        return !this.async.concurrent &&
            this.fileList.hasFileWithState([FileState.Selected]) &&
            !this.fileList.hasFileWithState([FileState.Uploading]);
    }
    areAllSelectedFilesHandled() {
        const validSelectedFiles = this.fileList.getFilesWithState(FileState.Selected).filter(file => !file.validationErrors);
        return validSelectedFiles.length === 0;
    }
    cloneRequestHeaders(headers) {
        const cloned = {};
        if (headers) {
            headers.keys().forEach((key) => {
                if (key !== 'constructor' && key !== '__proto__' && key !== 'prototype')
                    cloned[key] = headers.get(key);
            });
        }
        return new HttpHeaders(cloned);
    }
    populateRequestOptions(headers, reportProgress = true) {
        return {
            headers: headers,
            reportProgress: reportProgress,
            responseType: this.async.responseType,
            withCredentials: this.async.withCredentials
        };
    }
    populateUploadFormData(files, clientData) {
        const saveField = this.async.saveField;
        const data = new FormData();
        this.populateClientFormData(data, clientData);
        if (this.async.chunk) {
            data.append(saveField, this.getNextChunk(files[0]));
            data.append("metadata", this.getChunkMetadata(files[0]));
        }
        else {
            for (const file of files) {
                data.append(saveField, file.rawFile);
            }
        }
        return data;
    }
    populateRemoveFormData(fileNames, clientData) {
        const data = new FormData();
        this.populateClientFormData(data, clientData);
        for (const fileName of fileNames) {
            data.append(this.async.removeField, fileName);
        }
        return data;
    }
    populateClientFormData(data, clientData) {
        for (const key in clientData) {
            if (clientData.hasOwnProperty(key)) {
                data.append(key, clientData[key]);
            }
        }
    }
    /* Chunking Helper Methods Section */
    getNextChunk(file) {
        const info = this.getChunkInfo(file);
        const newPosition = info.position + this.chunk.size;
        return file.rawFile.slice(info.position, newPosition);
    }
    getChunkInfo(file) {
        let chunkInfo = this.chunkMap.get(file.uid);
        if (!chunkInfo) {
            const totalChunks = file.size > 0 ? Math.ceil(file.size / this.chunk.size) : 1;
            chunkInfo = this.chunkMap.add(file.uid, totalChunks);
        }
        return chunkInfo;
    }
    updateChunkInfo(uid) {
        const chunkInfo = this.chunkMap.get(uid);
        if (chunkInfo.index < chunkInfo.totalChunks - 1) {
            chunkInfo.index += 1;
            chunkInfo.position += this.chunk.size;
            chunkInfo.retries = 0;
        }
    }
    removeChunkInfo(uid) {
        this.chunkMap.remove(uid);
    }
    getChunkMetadata(file) {
        const chunkInfo = this.chunkMap.get(file.uid);
        const chunkMetadata = {
            chunkIndex: chunkInfo.index,
            contentType: file.rawFile.type,
            fileName: file.name,
            fileSize: file.size,
            fileUid: file.uid,
            totalChunks: chunkInfo.totalChunks
        };
        return JSON.stringify(chunkMetadata);
    }
    isChunkUploadComplete(uid) {
        const chunkInfo = this.chunkMap.get(uid);
        if (chunkInfo) {
            return chunkInfo.index + 1 === chunkInfo.totalChunks;
        }
        return false;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: UploadService, deps: [{ token: i1.HttpClient }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: UploadService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: UploadService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: i1.HttpClient }] });

/**
 * @hidden
 */
class NavigationService {
    uploadService;
    zone;
    onActionButtonFocus = new EventEmitter();
    onFileAction = new EventEmitter();
    onFileFocus = new EventEmitter();
    onTabOut = new EventEmitter();
    onWrapperFocus = new EventEmitter();
    onSelectButtonFocus = new EventEmitter();
    actionButtonsVisible = false;
    fileListVisible = false;
    focused = false;
    keyBindings;
    focusedFileIndex = 0;
    _focusedIndex = -1;
    constructor(uploadService, zone) {
        this.uploadService = uploadService;
        this.zone = zone;
    }
    action(event) {
        const key = normalizeKeys(event);
        return this.keyBindings[key];
    }
    process(event, component) {
        const handler = this.action(event);
        if (handler) {
            handler(event, component);
        }
    }
    computeKeys() {
        this.keyBindings = {
            [Keys.Space]: () => this.handleSpace(),
            [Keys.Enter]: () => this.handleEnter(),
            [Keys.NumpadEnter]: () => this.handleEnter(),
            [Keys.Escape]: () => this.handleEscape(),
            [Keys.Delete]: () => this.handleDelete(),
            [Keys.Tab]: (event, component) => this.handleTab(event, component),
            [Keys.ArrowUp]: (event) => this.handleUpDown(event, -1),
            [Keys.ArrowDown]: (event) => this.handleUpDown(event, 1)
        };
    }
    focusSelectButton() {
        this.focused = true;
        this._focusedIndex = -1;
        this.onSelectButtonFocus.emit();
    }
    handleEnter() {
        if (this.lastIndex >= 0 && this.focusedIndex >= 0 && this.focusedIndex <= this.lastFileIndex) {
            this.zone.run(() => this.onFileAction.emit(Keys.Enter));
        }
    }
    handleSpace() {
        if (this.lastIndex >= 0 && this.focusedIndex >= 0 && this.focusedIndex <= this.lastFileIndex) {
            this.zone.run(() => this.onFileAction.emit(Keys.Space));
        }
    }
    handleDelete() {
        if (this.focusedIndex >= 0 && this.focusedIndex <= this.lastFileIndex) {
            this.zone.run(() => this.onFileAction.emit(Keys.Delete));
        }
    }
    handleEscape() {
        if (this.focusedIndex >= 0 && this.focusedIndex <= this.lastFileIndex) {
            this.zone.run(() => this.onFileAction.emit(Keys.Escape));
        }
    }
    handleTab(event, component) {
        const shifted = event.shiftKey;
        /* Select Files button is focused */
        if (this.focusedIndex === -1 && this.fileListVisible && !shifted) {
            this.focusedIndex = this.focusedFileIndex;
            event.preventDefault();
            this.onFileFocus.emit(this.focusedFileIndex);
            return;
        }
        /* File in the list is focused */
        if (this.focusedIndex > -1 && this.focusedIndex <= this.lastFileIndex) {
            if (shifted) {
                this.focusedIndex = -1;
            }
            else if (component !== 'fileselect' && this.actionButtonsVisible) {
                this.focusedIndex = this.lastFileIndex + 1;
                return;
            }
        }
        /* Clear button is focused */
        if (this.focusedIndex === this.lastFileIndex + 1) {
            this.focusedIndex = shifted ? this.focusedFileIndex : this.lastIndex;
            if (shifted) {
                event.preventDefault();
                this.onFileFocus.emit(this.focusedFileIndex);
            }
            return;
        }
        /* Upload button is focused */
        if (this.focusedIndex === this.lastIndex && this.actionButtonsVisible && shifted) {
            this.focusedIndex -= 1;
            return;
        }
        this.onTabOut.emit();
    }
    handleUpDown(event, direction) {
        const focusOnFileList = this.focusedIndex > -1 && this.uploadService.files.count >= 0;
        const nextFocusableIndexInBoundaries = direction > 0 ? this.focusedFileIndex < this.lastFileIndex : this.focusedFileIndex > 0;
        const focusNextFile = focusOnFileList && nextFocusableIndexInBoundaries;
        if (focusNextFile) {
            event.preventDefault();
            this.zone.run(() => {
                this.focusedIndex += direction;
                this.focusedFileIndex += direction;
            });
        }
    }
    get focusedIndex() {
        return this._focusedIndex;
    }
    set focusedIndex(index) {
        if (!this.focused) {
            this.onWrapperFocus.emit();
        }
        this._focusedIndex = index;
        this.focused = true;
        if (this._focusedIndex >= 0 && this._focusedIndex <= this.lastFileIndex) {
            this.onFileFocus.emit(index);
        }
    }
    get lastFileIndex() {
        return this.actionButtonsVisible ? this.lastIndex - 2 : this.lastIndex;
    }
    get lastIndex() {
        const fileCount = this.uploadService.files.count;
        return this.actionButtonsVisible ? fileCount + 1 : fileCount - 1;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: NavigationService, deps: [{ token: UploadService }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: NavigationService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: NavigationService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: UploadService }, { type: i0.NgZone }] });

const components = {};
/**
 * @hidden
 */
class DropZoneService {
    addComponent(component, zoneId) {
        if (this.has(zoneId)) {
            components[zoneId].push(component);
        }
        else {
            components[zoneId] = [component];
        }
    }
    clearComponent(component, zoneId) {
        if (this.has(zoneId)) {
            const componentIdx = components[zoneId].indexOf(component);
            components[zoneId].splice(componentIdx, 1);
        }
    }
    getComponents(zoneId) {
        return components[zoneId];
    }
    has(id) {
        return id in components;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DropZoneService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DropZoneService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DropZoneService, decorators: [{
            type: Injectable
        }] });

/**
 * @hidden
 */
const INVALIDMAXFILESIZE = "invalidMaxFileSize";
/**
 * @hidden
 */
const INVALIDMINFILESIZE = "invalidMinFileSize";
/**
 * @hidden
 */
const INVALIDFILEEXTENSION = "invalidFileExtension";
const validateFileExtension = (file, allowedExtensions) => {
    if (allowedExtensions.length > 0) {
        if (allowedExtensions.indexOf(file.extension.toLowerCase()) < 0) {
            file.validationErrors = file.validationErrors || [];
            if (file.validationErrors.indexOf(INVALIDFILEEXTENSION) < 0) {
                file.validationErrors.push(INVALIDFILEEXTENSION);
            }
        }
    }
};
const validateFileSize = (file, minFileSize, maxFileSize) => {
    if (minFileSize !== 0 && file.size < minFileSize) {
        file.validationErrors = file.validationErrors || [];
        if (file.validationErrors.indexOf(INVALIDMINFILESIZE) < 0) {
            file.validationErrors.push(INVALIDMINFILESIZE);
        }
    }
    if (maxFileSize !== 0 && file.size > maxFileSize) {
        file.validationErrors = file.validationErrors || [];
        if (file.validationErrors.indexOf(INVALIDMAXFILESIZE) < 0) {
            file.validationErrors.push(INVALIDMAXFILESIZE);
        }
    }
};
const parseAllowedExtensions = (extensions) => {
    const allowedExtensions = extensions.map((ext) => {
        const parsedExt = (ext.substring(0, 1) === ".") ? ext : ("." + ext);
        return parsedExt.toLowerCase();
    });
    return allowedExtensions;
};
/**
 * @hidden
 */
const validateFiles = (files, restrictionInfo) => {
    const allowedExtensions = parseAllowedExtensions(restrictionInfo.allowedExtensions);
    const maxFileSize = restrictionInfo.maxFileSize;
    const minFileSize = restrictionInfo.minFileSize;
    let i;
    for (i = 0; i < files.length; i++) {
        validateFileExtension(files[i], allowedExtensions);
        validateFileSize(files[i], minFileSize, maxFileSize);
    }
};

/**
 * @hidden
 */
const packageMetadata = {
    name: '@progress/kendo-angular-upload',
    productName: 'Kendo UI for Angular',
    productCode: 'KENDOUIANGULAR',
    productCodes: ['KENDOUIANGULAR'],
    publishDate: 0,
    version: '22.0.1',
    licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/'
};

/**
 * Customizes the rendering of files in the list. ([See example.](slug:templates_upload#toc-file-template))
 *
 * The following context variables are available in the template:
 *
 * * `let-files`&mdash;A reference to the files associated with the current item.
 * * `let-state`&mdash;A reference to the current state of each file. If the [`batch`](slug:api_upload_uploadcomponent#toc-batch) option of the Upload is set to `true`, the field reflects the state of the whole batch.
 * * `#myUpload="kendoUpload"` or `#myFileSelect="kendoFileSelect"`&mdash;A reference to the instance of the Upload/FileSelect component. It is exported as `kendoUpload`/`kendoFileSelect` by using the [`exportAs`](https://angular.io/api/core/Component) metadata property.
 *
 * @example
 * ```html
 * <kendo-upload #myUpload="kendoUpload">
 *     <ng-template kendoUploadFileTemplate let-files let-state>
 *         <div>Name: {{ files[0].name }} Size: {{ files[0].size }} bytes</div>
 *     </ng-template>
 * </kendo-upload>
 * ```
 */
class FileTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FileTemplateDirective, deps: [{ token: i0.TemplateRef }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: FileTemplateDirective, isStandalone: true, selector: "[kendoUploadFileTemplate], [kendoFileSelectFileTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FileTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoUploadFileTemplate], [kendoFileSelectFileTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef }] });

/**
 * Customizes the rendering of the file info section in the list. All other elements of the default template, such as file icon, action buttons, and upload progress, are preserved in place. ([See example](slug:templates_upload#toc-file-info-template)).
 *
 * The following context variables are available in the template:
 *
 * * `let-files`&mdash;A reference to the files associated with the current item.
 * * `let-state`&mdash;A reference to the current state of each file. If the [`batch`](slug:api_upload_uploadcomponent#toc-batch) option of the Upload is set to `true`, the field reflects the state of the whole batch.
 * * `#myUpload="kendoUpload"` or `#myFileSelect="kendoFileSelect"`&mdash;A reference to the instance of the Upload/FileSelect component. It is exported as `kendoUpload`/`kendoFileSelect` by using the [`exportAs`](https://angular.io/api/core/Component) metadata property.
 *
 * @example
 * ```html
 * <kendo-upload #myUpload="kendoUpload">
 *     <ng-template kendoUploadFileInfoTemplate let-files let-state>
 *         <div>Name: {{ files[0].name }}</div>
 *     </ng-template>
 * </kendo-upload>
 * ```
 */
class FileInfoTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FileInfoTemplateDirective, deps: [{ token: i0.TemplateRef }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: FileInfoTemplateDirective, isStandalone: true, selector: "[kendoUploadFileInfoTemplate], [kendoFileSelectFileInfoTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FileInfoTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoUploadFileInfoTemplate], [kendoFileSelectFileInfoTemplate]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef }] });

/**
 * @hidden
 */
class UploadFileSelectBase {
    uploadService;
    navigation;
    cdr;
    injector;
    zone;
    /**
     * @hidden
     */
    fileTemplate;
    /**
     * @hidden
     */
    fileInfoTemplate;
    /**
     * @hidden
     */
    fileSelectButton;
    /**
     * Sets the `accept` attribute of the internal `input` element of the component.
     */
    accept;
    /**
     * Disables the component.
     *
     * @default false
     */
    disabled = false;
    /**
     * Allows you to select multiple files.
     * When you set this to `false`, you can select only one file at a time.
     *
     * @default true
     */
    multiple = true;
    /**
     * Controls the visibility of the file list.
     *
     * @default true
     */
    showFileList = true;
    /**
     * Sets the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
     *
     * @default 0
     */
    tabindex = 0;
    /**
     * Sets the restrictions for selected files.
     */
    set restrictions(restrictions) {
        const parsedRestrictions = Object.assign({}, this.restrictions, restrictions);
        this._restrictions = parsedRestrictions;
    }
    get restrictions() {
        return this._restrictions;
    }
    /**
     * Sets the `id` of the external drop zone that you want to associate with the component.
     *
     */
    zoneId;
    /**
     * @hidden
     */
    focusableId = `k-${guid()}`;
    /**
     * @hidden
     */
    hostDefaultClasses = true;
    /**
     * @hidden
     */
    get hostDisabledClass() {
        return this.disabled;
    }
    /**
     * Fires when you navigate outside the component.
     */
    onBlur = new EventEmitter();
    /**
     * Fires when you focus the component.
     */
    onFocus = new EventEmitter();
    /**
     * Fires when you select files. If you prevent this event, the component will not add the selected files to the list.
     */
    select = new EventEmitter();
    /**
     * Fires when you are about to remove a file. If you prevent this event, the file will remain in the list.
     */
    remove = new EventEmitter();
    /**
     * @hidden
     */
    _restrictions = {
        allowedExtensions: [],
        maxFileSize: 0,
        minFileSize: 0
    };
    /**
     * @hidden
     */
    fileList;
    constructor(uploadService, navigation, cdr, injector, zone) {
        this.uploadService = uploadService;
        this.navigation = navigation;
        this.cdr = cdr;
        this.injector = injector;
        this.zone = zone;
        this.fileList = this.uploadService.files;
    }
    /**
     * @hidden
     */
    get formControl() {
        const ngControl = this.injector.get(NgControl, null);
        return ngControl?.control || null;
    }
    /**
     * @hidden
     */
    get isControlRequired() {
        return isControlRequired(this.formControl);
    }
    /**
     * @hidden
     */
    get hasFileList() {
        const hasFileList = this.showFileList && this.fileList.count > 0;
        this.navigation.fileListVisible = hasFileList;
        return hasFileList;
    }
    /**
     * @hidden
     */
    writeValue(newValue, validation, callback) {
        let isValid = true;
        if (newValue instanceof Array) {
            newValue.forEach((file) => {
                if (!validation(file)) {
                    isValid = false;
                }
            });
            if (isValid) {
                this.uploadService[callback](newValue);
            }
        }
        if (newValue === null) {
            this.fileList.clear();
        }
        this.cdr.markForCheck();
    }
    onTouchedCallback = (_) => { };
    onChangeCallback = (_) => { };
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    /**
     * @hidden
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * @hidden
     */
    onFileSelectButtonFocus() {
        if (!this.navigation.focused) {
            this.navigation.focusedIndex = -1;
        }
    }
    /**
     * Focuses the component's **Select files** button.
     */
    focus() {
        this.zone.runOutsideAngular(() => {
            setTimeout(() => {
                this.fileSelectButton.nativeElement.focus();
                this.navigation.focused = true;
            });
        });
    }
    /**
     * @hidden
     * @deprecated
     */
    focusComponent() {
        this.focus();
    }
    /**
     * Blurs the component if you previously focused it.
     */
    blur() {
        if (this.navigation.focused) {
            this.navigation.focused = false;
            document.activeElement.blur();
        }
    }
    /**
     * @hidden
     * @deprecated
     */
    blurComponent() {
        this.blur();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: UploadFileSelectBase, deps: [{ token: UploadService }, { token: NavigationService }, { token: i0.ChangeDetectorRef }, { token: i0.Injector }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: UploadFileSelectBase, isStandalone: true, inputs: { accept: "accept", disabled: "disabled", multiple: "multiple", showFileList: "showFileList", tabindex: "tabindex", restrictions: "restrictions", zoneId: "zoneId", focusableId: "focusableId" }, outputs: { onBlur: "blur", onFocus: "focus", select: "select", remove: "remove" }, host: { properties: { "class.k-upload": "this.hostDefaultClasses", "class.k-disabled": "this.hostDisabledClass" } }, queries: [{ propertyName: "fileTemplate", first: true, predicate: FileTemplateDirective, descendants: true }, { propertyName: "fileInfoTemplate", first: true, predicate: FileInfoTemplateDirective, descendants: true }], viewQueries: [{ propertyName: "fileSelectButton", first: true, predicate: ["fileSelectButton"], descendants: true, read: ElementRef, static: true }], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: UploadFileSelectBase, decorators: [{
            type: Directive,
            args: [{}]
        }], ctorParameters: () => [{ type: UploadService }, { type: NavigationService }, { type: i0.ChangeDetectorRef }, { type: i0.Injector }, { type: i0.NgZone }], propDecorators: { fileTemplate: [{
                type: ContentChild,
                args: [FileTemplateDirective]
            }], fileInfoTemplate: [{
                type: ContentChild,
                args: [FileInfoTemplateDirective]
            }], fileSelectButton: [{
                type: ViewChild,
                args: ['fileSelectButton', { static: true, read: ElementRef }]
            }], accept: [{
                type: Input
            }], disabled: [{
                type: Input
            }], multiple: [{
                type: Input
            }], showFileList: [{
                type: Input
            }], tabindex: [{
                type: Input
            }], restrictions: [{
                type: Input
            }], zoneId: [{
                type: Input
            }], focusableId: [{
                type: Input
            }], hostDefaultClasses: [{
                type: HostBinding,
                args: ['class.k-upload']
            }], hostDisabledClass: [{
                type: HostBinding,
                args: ['class.k-disabled']
            }], onBlur: [{
                type: Output,
                args: ['blur']
            }], onFocus: [{
                type: Output,
                args: ['focus']
            }], select: [{
                type: Output
            }], remove: [{
                type: Output
            }] } });

/* eslint-disable no-debugger */
/**
 * @hidden
 */
class UploadActionButtonsComponent {
    uploadService;
    localization;
    navigation;
    disabled;
    actionsLayout;
    clearButton;
    uploadButton;
    hostDefaultClass = true;
    get actionButtonsEndClassName() {
        return this.actionsLayout === 'end';
    }
    get actionButtonsStretchedClassName() {
        return this.actionsLayout === 'stretched';
    }
    get actionButtonsStartClassName() {
        return this.actionsLayout === 'start';
    }
    get actionButtonsCenterClassName() {
        return this.actionsLayout === 'center';
    }
    constructor(uploadService, localization, navigation) {
        this.uploadService = uploadService;
        this.localization = localization;
        this.navigation = navigation;
    }
    onUploadButtonFocus() {
        if (!this.navigation.focused) {
            this.navigation.focusedIndex = this.navigation.lastIndex;
        }
    }
    onUploadButtonClick(event) {
        event.stopImmediatePropagation();
        this.performUpload();
    }
    performUpload() {
        if (!this.disabled) {
            this.uploadService.uploadFiles();
            this.navigation.focusSelectButton();
        }
    }
    onClearButtonClick(event) {
        event.stopImmediatePropagation();
        this.clearFiles();
    }
    clearFiles() {
        if (!this.disabled) {
            this.uploadService.clearFiles();
            this.navigation.focusSelectButton();
        }
    }
    textFor(key) {
        return this.localization.get(key);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: UploadActionButtonsComponent, deps: [{ token: UploadService }, { token: i1$1.LocalizationService }, { token: NavigationService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: UploadActionButtonsComponent, isStandalone: true, selector: "kendo-upload-action-buttons", inputs: { disabled: "disabled", actionsLayout: "actionsLayout" }, host: { properties: { "class.k-actions": "this.hostDefaultClass", "class.k-actions-end": "this.actionButtonsEndClassName", "class.k-actions-stretched": "this.actionButtonsStretchedClassName", "class.k-actions-start": "this.actionButtonsStartClassName", "class.k-actions-center": "this.actionButtonsCenterClassName" } }, viewQueries: [{ propertyName: "clearButton", first: true, predicate: ["clearButton"], descendants: true, static: true }, { propertyName: "uploadButton", first: true, predicate: ["uploadButton"], descendants: true, static: true }], ngImport: i0, template: `
        <button #clearButton role="button" class="k-button k-button-md k-rounded-md k-button-solid k-button-solid-base k-clear-selected"
            (click)="onClearButtonClick($event)">
                {{textFor('clearSelectedFiles')}}
        </button>
        <button #uploadButton role="button" class="k-button k-button-md k-rounded-md k-button-solid k-button-solid-primary k-upload-selected"
            (focus)="onUploadButtonFocus()"
            (click)="onUploadButtonClick($event)">
                {{textFor('uploadSelectedFiles')}}
        </button>
    `, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: UploadActionButtonsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-upload-action-buttons',
                    template: `
        <button #clearButton role="button" class="k-button k-button-md k-rounded-md k-button-solid k-button-solid-base k-clear-selected"
            (click)="onClearButtonClick($event)">
                {{textFor('clearSelectedFiles')}}
        </button>
        <button #uploadButton role="button" class="k-button k-button-md k-rounded-md k-button-solid k-button-solid-primary k-upload-selected"
            (focus)="onUploadButtonFocus()"
            (click)="onUploadButtonClick($event)">
                {{textFor('uploadSelectedFiles')}}
        </button>
    `,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: UploadService }, { type: i1$1.LocalizationService }, { type: NavigationService }], propDecorators: { disabled: [{
                type: Input
            }], actionsLayout: [{
                type: Input
            }], clearButton: [{
                type: ViewChild,
                args: ['clearButton', { static: true }]
            }], uploadButton: [{
                type: ViewChild,
                args: ['uploadButton', { static: true }]
            }], hostDefaultClass: [{
                type: HostBinding,
                args: ['class.k-actions']
            }], actionButtonsEndClassName: [{
                type: HostBinding,
                args: ['class.k-actions-end']
            }], actionButtonsStretchedClassName: [{
                type: HostBinding,
                args: ['class.k-actions-stretched']
            }], actionButtonsStartClassName: [{
                type: HostBinding,
                args: ['class.k-actions-start']
            }], actionButtonsCenterClassName: [{
                type: HostBinding,
                args: ['class.k-actions-center']
            }] } });

/**
 * @hidden
 */
class FileListItemDirective {
    navigationService;
    uploadService;
    files;
    index;
    fileClass = true;
    focused = false;
    element;
    constructor(el, navigationService, uploadService) {
        this.navigationService = navigationService;
        this.uploadService = uploadService;
        this.element = el;
    }
    focus() {
        this.element.nativeElement.focus();
    }
    get uidAttribute() {
        return this.files[0].uid;
    }
    get tabIndex() {
        return this.navigationService.focusedFileIndex === this.index ? '0' : '-1';
    }
    get kFileError() {
        return this.files[0].state === FileState.Failed;
    }
    get kFileInvalid() {
        return filesHaveValidationErrors(this.files);
    }
    get kFileProgress() {
        return this.files[0].state === FileState.Uploading ||
            this.files[0].state === FileState.Paused;
    }
    get kFileSuccess() {
        if (this.uploadService.component === 'Upload') {
            return this.files[0].state === FileState.Uploaded ||
                this.files[0].state === FileState.Initial;
        }
        return false;
    }
    get kStateFocused() {
        return this.focused;
    }
    onFocus() {
        this.focused = true;
    }
    onBlur() {
        this.focused = false;
    }
    onClick(event) {
        if ((!isFocusable(event.target) && !hasClasses(event.target, IGNORE_TARGET_CLASSES)) || !!event.target.closest('.k-upload-action')) {
            this.navigationService.focusedIndex = this.navigationService.focusedFileIndex = this.index;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FileListItemDirective, deps: [{ token: i0.ElementRef }, { token: NavigationService }, { token: UploadService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: FileListItemDirective, isStandalone: true, selector: "[kendoUploadFileListItem]", inputs: { files: "files", index: "index" }, host: { listeners: { "focus": "onFocus()", "blur": "onBlur()", "click": "onClick($event)" }, properties: { "class.k-file": "this.fileClass", "attr.data-uid": "this.uidAttribute", "attr.tabIndex": "this.tabIndex", "class.k-file-error": "this.kFileError", "class.k-file-invalid": "this.kFileInvalid", "class.k-file-progress": "this.kFileProgress", "class.k-file-success": "this.kFileSuccess", "class.k-focus": "this.kStateFocused" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FileListItemDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoUploadFileListItem]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: NavigationService }, { type: UploadService }], propDecorators: { files: [{
                type: Input
            }], index: [{
                type: Input
            }], fileClass: [{
                type: HostBinding,
                args: ['class.k-file']
            }], uidAttribute: [{
                type: HostBinding,
                args: ['attr.data-uid']
            }], tabIndex: [{
                type: HostBinding,
                args: ['attr.tabIndex']
            }], kFileError: [{
                type: HostBinding,
                args: ['class.k-file-error']
            }], kFileInvalid: [{
                type: HostBinding,
                args: ['class.k-file-invalid']
            }], kFileProgress: [{
                type: HostBinding,
                args: ['class.k-file-progress']
            }], kFileSuccess: [{
                type: HostBinding,
                args: ['class.k-file-success']
            }], kStateFocused: [{
                type: HostBinding,
                args: ['class.k-focus']
            }], onFocus: [{
                type: HostListener,
                args: ['focus']
            }], onBlur: [{
                type: HostListener,
                args: ['blur']
            }], onClick: [{
                type: HostListener,
                args: ['click', ['$event']]
            }] } });

/**
 * @hidden
 */
class FileListItemBase {
    uploadService;
    progressComplete = 0;
    localization;
    uploadProgressSubscription;
    constructor(uploadService) {
        this.uploadService = uploadService;
    }
    subscribeUploadProgress(uploadProgressHandler) {
        this.uploadProgressSubscription = this.uploadService.uploadProgressEvent.subscribe(uploadProgressHandler);
    }
    fileHasValidationErrors(file) {
        return fileHasValidationErrors(file);
    }
    filesHaveValidationErrors(files) {
        return filesHaveValidationErrors(files);
    }
    ngOnDestroy() {
        this.uploadProgressSubscription.unsubscribe();
    }
    getFileValidationMessage(file) {
        let validationMessage;
        if (file.validationErrors && file.validationErrors.length > 0) {
            validationMessage = this.localization.get(file.validationErrors[0]);
        }
        return validationMessage;
    }
    getTotalFilesSizeMessage(files) {
        return getTotalFilesSizeMessage(files);
    }
    textFor(key) {
        return this.localization.get(key);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FileListItemBase, deps: [{ token: UploadService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: FileListItemBase, isStandalone: true, selector: "ng-component", ngImport: i0, template: '', isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FileListItemBase, decorators: [{
            type: Component,
            args: [{ template: '' }]
        }], ctorParameters: () => [{ type: UploadService }] });

/**
 * @hidden
 */
class FileListItemActionButtonComponent {
    uploadService;
    localization;
    navigation;
    file;
    disabled;
    progress;
    retrySVGIcon = arrowRotateCwSmallIcon;
    playSVGIcon = playSmIcon;
    pauseSVGIcon = pauseSmIcon;
    cancelSVGIcon = cancelIcon;
    deleteSVGIcon = xIcon;
    constructor(uploadService, localization, navigation) {
        this.uploadService = uploadService;
        this.localization = localization;
        this.navigation = navigation;
    }
    onRetryClick() {
        if (this.disabled) {
            return;
        }
        this.uploadService.retryFiles(this.file.uid);
    }
    onRemoveCancelClick(event) {
        if (this.disabled) {
            return;
        }
        event.stopImmediatePropagation();
        const uid = this.file.uid;
        if (this.file.state === FileState.Uploading) {
            this.uploadService.cancelFiles(uid);
        }
        else {
            this.uploadService.removeFiles(uid);
        }
        this.navigation.focusSelectButton();
    }
    onPauseResumeClick() {
        if (this.disabled) {
            return;
        }
        const uid = this.file.uid;
        if (this.file.state === FileState.Paused) {
            this.uploadService.resumeFile(uid);
        }
        else {
            this.uploadService.pauseFile(uid);
        }
    }
    get actionButtonTitle() {
        if (this.file.state === FileState.Uploading) {
            return this.localization.get('cancel');
        }
        return this.localization.get('remove');
    }
    get retryButtonTitle() {
        return this.localization.get('retry');
    }
    get pauseResumeButtonTitle() {
        if (this.file.state === FileState.Uploading) {
            return this.localization.get('pause');
        }
        return this.localization.get('resume');
    }
    get isUploading() {
        return this.file.state === FileState.Uploading;
    }
    get isFailed() {
        return this.file.state === FileState.Failed;
    }
    get isPaused() {
        return this.file.state === FileState.Paused;
    }
    get isResumable() {
        const service = this.uploadService;
        const isResumable = service.async.chunk && service.chunk.resumable;
        const isUploading = (this.file.state === FileState.Paused) || (this.file.state === FileState.Uploading);
        return isResumable && isUploading;
    }
    get isActionButtonVisible() {
        if ((this.file.state === FileState.Uploaded || this.file.state === FileState.Initial) &&
            !this.uploadService.async.removeUrl && this.uploadService.component === 'Upload') {
            return false;
        }
        return true;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FileListItemActionButtonComponent, deps: [{ token: UploadService }, { token: i1$1.LocalizationService }, { token: NavigationService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: FileListItemActionButtonComponent, isStandalone: true, selector: "kendo-upload-file-list-item-action-button", inputs: { file: "file", disabled: "disabled", progress: "progress" }, ngImport: i0, template: `
    <span class="k-upload-actions">
      @if (isUploading || isPaused) {
        <span class="k-upload-pct">{{progress}}%</span>
      }
    
      @if (isFailed) {
        <button
          kendoButton
          type="button"
          class="k-upload-action k-retry"
          fillMode="flat"
          [attr.tabIndex]="-1"
          [attr.aria-hidden]="true"
          [attr.title]="retryButtonTitle"
          [svgIcon]="retrySVGIcon"
          icon="refresh-sm"
          (pointerdown)="$event.preventDefault()"
          (click)="onRetryClick()"
        ></button>
      }
    
      @if (isResumable) {
        <button
          kendoButton
          type="button"
          class="k-upload-action"
          fillMode="flat"
          [attr.tabIndex]="-1"
          [attr.aria-hidden]="true"
          [attr.title]="pauseResumeButtonTitle"
          [svgIcon]="isPaused ? playSVGIcon : pauseSVGIcon"
          [icon]="isPaused ? 'play-sm' : 'pause-sm'"
          (pointerdown)="$event.preventDefault()"
          (click)="onPauseResumeClick()"
        ></button>
      }
    
      @if (isActionButtonVisible) {
        <button
          kendoButton
          class="k-upload-action"
          [class.k-delete]="!isUploading"
          fillMode="flat"
          type="button"
          [attr.tabIndex]="-1"
          [attr.aria-hidden]="true"
          [attr.title]="actionButtonTitle"
          [svgIcon]="isUploading ? cancelSVGIcon : deleteSVGIcon"
          [icon]="isUploading ? 'cancel' : 'x'"
          (click)="onRemoveCancelClick($event)"
        ></button>
      }
    </span>
    `, isInline: true, dependencies: [{ kind: "component", type: ButtonComponent, selector: "button[kendoButton]", inputs: ["arrowIcon", "toggleable", "togglable", "selected", "tabIndex", "imageUrl", "iconClass", "icon", "disabled", "size", "rounded", "fillMode", "themeColor", "svgIcon", "primary", "look"], outputs: ["selectedChange", "click"], exportAs: ["kendoButton"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FileListItemActionButtonComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-upload-file-list-item-action-button',
                    template: `
    <span class="k-upload-actions">
      @if (isUploading || isPaused) {
        <span class="k-upload-pct">{{progress}}%</span>
      }
    
      @if (isFailed) {
        <button
          kendoButton
          type="button"
          class="k-upload-action k-retry"
          fillMode="flat"
          [attr.tabIndex]="-1"
          [attr.aria-hidden]="true"
          [attr.title]="retryButtonTitle"
          [svgIcon]="retrySVGIcon"
          icon="refresh-sm"
          (pointerdown)="$event.preventDefault()"
          (click)="onRetryClick()"
        ></button>
      }
    
      @if (isResumable) {
        <button
          kendoButton
          type="button"
          class="k-upload-action"
          fillMode="flat"
          [attr.tabIndex]="-1"
          [attr.aria-hidden]="true"
          [attr.title]="pauseResumeButtonTitle"
          [svgIcon]="isPaused ? playSVGIcon : pauseSVGIcon"
          [icon]="isPaused ? 'play-sm' : 'pause-sm'"
          (pointerdown)="$event.preventDefault()"
          (click)="onPauseResumeClick()"
        ></button>
      }
    
      @if (isActionButtonVisible) {
        <button
          kendoButton
          class="k-upload-action"
          [class.k-delete]="!isUploading"
          fillMode="flat"
          type="button"
          [attr.tabIndex]="-1"
          [attr.aria-hidden]="true"
          [attr.title]="actionButtonTitle"
          [svgIcon]="isUploading ? cancelSVGIcon : deleteSVGIcon"
          [icon]="isUploading ? 'cancel' : 'x'"
          (click)="onRemoveCancelClick($event)"
        ></button>
      }
    </span>
    `,
                    standalone: true,
                    imports: [ButtonComponent]
                }]
        }], ctorParameters: () => [{ type: UploadService }, { type: i1$1.LocalizationService }, { type: NavigationService }], propDecorators: { file: [{
                type: Input
            }], disabled: [{
                type: Input
            }], progress: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class FileListMultipleItemsComponent extends FileListItemBase {
    localization;
    disabled;
    files;
    fileInfoTemplate;
    filesHaveErrors;
    copySVGIcon = copyIcon;
    constructor(localization, uploadService) {
        super(uploadService);
        this.localization = localization;
        this.subscribeUploadProgress((args) => {
            if (args.files[0].uid === this.files[0].uid) {
                this.progressComplete = args.percentComplete;
            }
        });
    }
    get showProgress() {
        const showProgress = this.files[0].state === FileState.Uploading || this.files[0].state === FileState.Paused;
        return showProgress ? 'active' : 'inactive';
    }
    ngOnInit() {
        this.filesHaveErrors = super.filesHaveValidationErrors(this.files);
    }
    fileStatusText(file) {
        const errors = file.validationErrors;
        if (!isPresent(errors)) {
            return this.getTotalFilesSizeMessage([file]);
        }
        return this.getFileValidationMessage(file);
    }
    get batchStatusText() {
        const state = this.files[0].state;
        const fileCount = this.files.length;
        if (state === FileState.Uploaded) {
            return `${fileCount} ${this.textFor('filesBatchStatusUploaded')}`;
        }
        if (state === FileState.Failed) {
            return `${fileCount} ${this.textFor('filesBatchStatusFailed')}`;
        }
        return `${fileCount} ${this.textFor('filesBatchStatus')}`;
    }
    get isUploadSuccessful() {
        return this.files[0].state === FileState.Uploaded;
    }
    get isUploadFailed() {
        return this.files[0].state === FileState.Failed;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FileListMultipleItemsComponent, deps: [{ token: i1$1.LocalizationService }, { token: UploadService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: FileListMultipleItemsComponent, isStandalone: true, selector: "kendo-upload-file-list-multiple-items", inputs: { disabled: "disabled", files: "files", fileInfoTemplate: "fileInfoTemplate" }, usesInheritance: true, ngImport: i0, template: `
        <kendo-progressbar
          [@progressState]="showProgress"
          [value]="progressComplete"
          [label]="{ visible: false }"
          >
        </kendo-progressbar>
        <span class="k-file-icon-wrapper">
          <kendo-icon-wrapper
            name="copy"
            size="xxlarge"
            [svgIcon]="copySVGIcon"
            innerCssClass="k-file-icon"
            >
          </kendo-icon-wrapper>
        </span>
        <span class="k-multiple-files-wrapper">
          @if (!fileInfoTemplate) {
            @for (file of files; track file) {
              <span class="k-file-info">
                <span [title]="file.name" class="k-file-name">
                  {{file.name}}
                </span>
                    <span [attr.aria-live]="'polite'" [ngClass]="{
                        'k-file-validation-message': file.validationErrors,
                        'k-file-size': !file.validationErrors
                        }"
                >{{fileStatusText(file)}}</span>
              </span>
            }
            <span class="k-file-summary"
            >{{batchStatusText}}</span>
          }
          @if (fileInfoTemplate) {
            <ng-container
              [ngTemplateOutlet]="fileInfoTemplate.templateRef"
                [ngTemplateOutletContext]="{
                    templateRef: fileInfoTemplate.templateRef,
                    state: files[0].state,
                    $implicit: files
                }"></ng-container>
          }
        </span>
        <kendo-upload-file-list-item-action-button
          [file]='files[0]'
          [disabled]='disabled'
          [progress]='progressComplete'>
        </kendo-upload-file-list-item-action-button>
        `, isInline: true, dependencies: [{ kind: "component", type: ProgressBarComponent, selector: "kendo-progressbar", inputs: ["label", "progressCssStyle", "progressCssClass", "emptyCssStyle", "emptyCssClass", "animation"], outputs: ["animationEnd"], exportAs: ["kendoProgressBar"] }, { kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: FileListItemActionButtonComponent, selector: "kendo-upload-file-list-item-action-button", inputs: ["file", "disabled", "progress"] }], animations: [
            trigger('progressState', [
                state('active', style({ opacity: 1 })),
                state('inactive', style({ opacity: 0 })),
                transition('void => active', style({ opacity: 0 })),
                transition('inactive => active', style({ opacity: 1 })),
                transition('active => inactive', animate('1s 2s ease-out'))
            ])
        ] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FileListMultipleItemsComponent, decorators: [{
            type: Component,
            args: [{
                    animations: [
                        trigger('progressState', [
                            state('active', style({ opacity: 1 })),
                            state('inactive', style({ opacity: 0 })),
                            transition('void => active', style({ opacity: 0 })),
                            transition('inactive => active', style({ opacity: 1 })),
                            transition('active => inactive', animate('1s 2s ease-out'))
                        ])
                    ],
                    selector: 'kendo-upload-file-list-multiple-items',
                    template: `
        <kendo-progressbar
          [@progressState]="showProgress"
          [value]="progressComplete"
          [label]="{ visible: false }"
          >
        </kendo-progressbar>
        <span class="k-file-icon-wrapper">
          <kendo-icon-wrapper
            name="copy"
            size="xxlarge"
            [svgIcon]="copySVGIcon"
            innerCssClass="k-file-icon"
            >
          </kendo-icon-wrapper>
        </span>
        <span class="k-multiple-files-wrapper">
          @if (!fileInfoTemplate) {
            @for (file of files; track file) {
              <span class="k-file-info">
                <span [title]="file.name" class="k-file-name">
                  {{file.name}}
                </span>
                    <span [attr.aria-live]="'polite'" [ngClass]="{
                        'k-file-validation-message': file.validationErrors,
                        'k-file-size': !file.validationErrors
                        }"
                >{{fileStatusText(file)}}</span>
              </span>
            }
            <span class="k-file-summary"
            >{{batchStatusText}}</span>
          }
          @if (fileInfoTemplate) {
            <ng-container
              [ngTemplateOutlet]="fileInfoTemplate.templateRef"
                [ngTemplateOutletContext]="{
                    templateRef: fileInfoTemplate.templateRef,
                    state: files[0].state,
                    $implicit: files
                }"></ng-container>
          }
        </span>
        <kendo-upload-file-list-item-action-button
          [file]='files[0]'
          [disabled]='disabled'
          [progress]='progressComplete'>
        </kendo-upload-file-list-item-action-button>
        `,
                    standalone: true,
                    imports: [ProgressBarComponent, IconWrapperComponent, NgClass, NgTemplateOutlet, FileListItemActionButtonComponent]
                }]
        }], ctorParameters: () => [{ type: i1$1.LocalizationService }, { type: UploadService }], propDecorators: { disabled: [{
                type: Input
            }], files: [{
                type: Input
            }], fileInfoTemplate: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class FileListSingleItemComponent extends FileListItemBase {
    localization;
    disabled;
    file;
    fileInfoTemplate;
    constructor(localization, uploadService) {
        super(uploadService);
        this.localization = localization;
        this.subscribeUploadProgress((args) => {
            if (args.files[0].uid === this.file.uid) {
                this.progressComplete = args.percentComplete;
            }
        });
    }
    get fileStatusText() {
        const errors = this.file.validationErrors;
        if (this.file.state === FileState.Uploaded) {
            return `${this.textFor('fileStatusUploaded')}`;
        }
        if (this.file.state === FileState.Failed) {
            return `${this.textFor('fileStatusFailed')}`;
        }
        if (!isPresent(errors)) {
            return this.getTotalFilesSizeMessage([this.file]);
        }
        return this.getFileValidationMessage(this.file);
    }
    get showProgress() {
        const showProgress = this.file.state === FileState.Uploading || this.file.state === FileState.Paused;
        return showProgress ? 'active' : 'inactive';
    }
    get fileGroupClass() {
        return fileGroupClass(this.file.extension);
    }
    get fileSVGGroupIcon() {
        return fileSVGGroupIcon(this.file.extension);
    }
    get isUploadSuccessful() {
        return this.file.state === FileState.Uploaded;
    }
    get isUploadFailed() {
        return this.file.state === FileState.Failed;
    }
    get isNotYetUploaded() {
        return !this.isUploadFailed && !this.isUploadSuccessful;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FileListSingleItemComponent, deps: [{ token: i1$1.LocalizationService }, { token: UploadService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: FileListSingleItemComponent, isStandalone: true, selector: "kendo-upload-file-list-single-item", inputs: { disabled: "disabled", file: "file", fileInfoTemplate: "fileInfoTemplate" }, usesInheritance: true, ngImport: i0, template: `
        <kendo-progressbar
          [@progressState]="showProgress"
          [value]="progressComplete"
          [label]="{ visible: false }"
          >
        </kendo-progressbar>
        <span class="k-file-icon-wrapper">
          <kendo-icon-wrapper
            size="xxlarge"
            [name]="fileGroupClass"
            [svgIcon]="fileSVGGroupIcon"
            innerCssClass="k-file-icon"
            >
          </kendo-icon-wrapper>
        </span>
        <span class="k-file-info">
          @if (!fileInfoTemplate) {
            <span class="k-file-name" [title]="file.name">{{ file.name }}</span>
                <span [attr.aria-live]="'polite'" [ngClass]="{
                    'k-file-validation-message': file.validationErrors,
                    'k-file-size': !file.validationErrors && isNotYetUploaded,
                    'k-file-summary': isUploadSuccessful || isUploadFailed
                    }"
            >{{fileStatusText}}</span>
          }
          @if (fileInfoTemplate) {
<ng-container [ngTemplateOutlet]="fileInfoTemplate.templateRef" [ngTemplateOutletContext]="{
                    templateRef: fileInfoTemplate.templateRef,
                    state: file.state,
                    $implicit: [file]
                }"></ng-container>
          }
        </span>
        <kendo-upload-file-list-item-action-button
          [file]='file'
          [disabled]='disabled'
          [progress]='progressComplete'>
        </kendo-upload-file-list-item-action-button>
        `, isInline: true, dependencies: [{ kind: "component", type: ProgressBarComponent, selector: "kendo-progressbar", inputs: ["label", "progressCssStyle", "progressCssClass", "emptyCssStyle", "emptyCssClass", "animation"], outputs: ["animationEnd"], exportAs: ["kendoProgressBar"] }, { kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: FileListItemActionButtonComponent, selector: "kendo-upload-file-list-item-action-button", inputs: ["file", "disabled", "progress"] }], animations: [
            trigger('progressState', [
                state('active', style({ opacity: 1 })),
                state('inactive', style({ opacity: 0 })),
                transition('void => active', style({ opacity: 0 })),
                transition('inactive => active', style({ opacity: 1 })),
                transition('active => inactive', animate('1s 2s ease-out'))
            ])
        ] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FileListSingleItemComponent, decorators: [{
            type: Component,
            args: [{
                    animations: [
                        trigger('progressState', [
                            state('active', style({ opacity: 1 })),
                            state('inactive', style({ opacity: 0 })),
                            transition('void => active', style({ opacity: 0 })),
                            transition('inactive => active', style({ opacity: 1 })),
                            transition('active => inactive', animate('1s 2s ease-out'))
                        ])
                    ],
                    selector: 'kendo-upload-file-list-single-item',
                    template: `
        <kendo-progressbar
          [@progressState]="showProgress"
          [value]="progressComplete"
          [label]="{ visible: false }"
          >
        </kendo-progressbar>
        <span class="k-file-icon-wrapper">
          <kendo-icon-wrapper
            size="xxlarge"
            [name]="fileGroupClass"
            [svgIcon]="fileSVGGroupIcon"
            innerCssClass="k-file-icon"
            >
          </kendo-icon-wrapper>
        </span>
        <span class="k-file-info">
          @if (!fileInfoTemplate) {
            <span class="k-file-name" [title]="file.name">{{ file.name }}</span>
                <span [attr.aria-live]="'polite'" [ngClass]="{
                    'k-file-validation-message': file.validationErrors,
                    'k-file-size': !file.validationErrors && isNotYetUploaded,
                    'k-file-summary': isUploadSuccessful || isUploadFailed
                    }"
            >{{fileStatusText}}</span>
          }
          @if (fileInfoTemplate) {
<ng-container [ngTemplateOutlet]="fileInfoTemplate.templateRef" [ngTemplateOutletContext]="{
                    templateRef: fileInfoTemplate.templateRef,
                    state: file.state,
                    $implicit: [file]
                }"></ng-container>
          }
        </span>
        <kendo-upload-file-list-item-action-button
          [file]='file'
          [disabled]='disabled'
          [progress]='progressComplete'>
        </kendo-upload-file-list-item-action-button>
        `,
                    standalone: true,
                    imports: [ProgressBarComponent, IconWrapperComponent, NgClass, NgTemplateOutlet, FileListItemActionButtonComponent]
                }]
        }], ctorParameters: () => [{ type: i1$1.LocalizationService }, { type: UploadService }], propDecorators: { disabled: [{
                type: Input
            }], file: [{
                type: Input
            }], fileInfoTemplate: [{
                type: Input
            }] } });

/* eslint-disable @angular-eslint/component-selector */
/**
 * @hidden
 */
class FileListComponent {
    uploadService;
    navigation;
    disabled;
    fileList;
    fileTemplate;
    fileInfoTemplate;
    fileListItems;
    fileListRole = 'list';
    focusSubscription;
    actionSubscription;
    constructor(uploadService, navigation) {
        this.uploadService = uploadService;
        this.navigation = navigation;
        this.onItemFocus();
        this.onItemAction();
    }
    onItemFocus() {
        this.focusSubscription = this.navigation.onFileFocus.subscribe((index) => {
            this.fileListItems.toArray()[index].focus();
        });
    }
    onItemAction() {
        this.actionSubscription = this.navigation.onFileAction.subscribe((key) => {
            this.itemActionHandler(key);
        });
    }
    itemActionHandler(key) {
        const index = this.navigation.focusedIndex;
        const filesArray = this.fileListItems.toArray();
        const numberOfFiles = filesArray.length;
        const item = filesArray[index];
        const uid = item.uidAttribute;
        const files = this.uploadService.files.get(uid);
        if (key === Keys.Escape && files[0].state === FileState.Uploading) {
            this.uploadService.cancelFiles(uid);
            this.navigation.focusSelectButton();
            return;
        }
        if ((key === Keys.Enter || key === Keys.NumpadEnter) && files[0].state === FileState.Failed) {
            this.uploadService.retryFiles(uid);
            return;
        }
        if (key === Keys.Delete) {
            if (files[0].state === FileState.Uploading) {
                this.uploadService.cancelFiles(uid);
            }
            else if (this.hasDelete(item)) {
                this.uploadService.removeFiles(uid);
            }
            if (index < numberOfFiles - 1) {
                filesArray[index + 1].focus();
            }
            else if (numberOfFiles === 1) {
                this.navigation.focusSelectButton();
            }
            else if (index === numberOfFiles - 1) {
                this.navigation.focusedIndex = this.navigation.focusedFileIndex = index - 1;
                filesArray[index - 1].focus();
            }
        }
        const isUploadChunk = this.uploadService.async.chunk;
        const canTogglePauseResume = key === Keys.Space && files[0].state !== FileState.Uploaded;
        if (canTogglePauseResume && isUploadChunk) {
            if (files[0].state === FileState.Paused) {
                this.uploadService.resumeFile(uid);
            }
            else {
                this.uploadService.pauseFile(uid);
            }
        }
    }
    hasDelete(item) {
        return item.element.nativeElement.getElementsByClassName('k-svg-i-x').length > 0;
    }
    /**
     * Tracks files array by the UID of the first file in the batch.
     * Each batch of files shares the same UID, which remains stable
     * throughout the file lifecycle until the batch is removed.
     */
    trackByUid(index, files) {
        return files[0]?.uid || index.toString();
    }
    ngOnDestroy() {
        this.focusSubscription.unsubscribe();
        this.actionSubscription.unsubscribe();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FileListComponent, deps: [{ token: UploadService }, { token: NavigationService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: FileListComponent, isStandalone: true, selector: "[kendo-upload-file-list]", inputs: { disabled: "disabled", fileList: "fileList", fileTemplate: "fileTemplate", fileInfoTemplate: "fileInfoTemplate" }, host: { properties: { "attr.role": "this.fileListRole" } }, viewQueries: [{ propertyName: "fileListItems", predicate: FileListItemDirective, descendants: true }], ngImport: i0, template: `
        @for (files of fileList; track trackByUid($index, files); let index = $index) {
          <li kendoUploadFileListItem [files]='files' [index]='index' role="listitem">
            @if (files.length === 1 && !fileTemplate) {
              <kendo-upload-file-list-single-item
                class='k-file-single'
                [disabled]='disabled'
                [file]='files[0]'
              [fileInfoTemplate]="fileInfoTemplate"></kendo-upload-file-list-single-item>
            }
            @if (files.length > 1 && !fileTemplate) {
              <kendo-upload-file-list-multiple-items
                class='k-file-multiple'
                [disabled]='disabled'
                [files]='files'
              [fileInfoTemplate]="fileInfoTemplate"></kendo-upload-file-list-multiple-items>
            }
            @if (fileTemplate) {
              <ng-container
                    [ngTemplateOutlet]="fileTemplate.templateRef" [ngTemplateOutletContext]="{
                            templateRef: fileTemplate.templateRef,
                            state: files[0].state,
                            $implicit: files
                        }"></ng-container>
            }
          </li>
        }
        `, isInline: true, dependencies: [{ kind: "directive", type: FileListItemDirective, selector: "[kendoUploadFileListItem]", inputs: ["files", "index"] }, { kind: "component", type: FileListSingleItemComponent, selector: "kendo-upload-file-list-single-item", inputs: ["disabled", "file", "fileInfoTemplate"] }, { kind: "component", type: FileListMultipleItemsComponent, selector: "kendo-upload-file-list-multiple-items", inputs: ["disabled", "files", "fileInfoTemplate"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FileListComponent, decorators: [{
            type: Component,
            args: [{
                    selector: '[kendo-upload-file-list]',
                    template: `
        @for (files of fileList; track trackByUid($index, files); let index = $index) {
          <li kendoUploadFileListItem [files]='files' [index]='index' role="listitem">
            @if (files.length === 1 && !fileTemplate) {
              <kendo-upload-file-list-single-item
                class='k-file-single'
                [disabled]='disabled'
                [file]='files[0]'
              [fileInfoTemplate]="fileInfoTemplate"></kendo-upload-file-list-single-item>
            }
            @if (files.length > 1 && !fileTemplate) {
              <kendo-upload-file-list-multiple-items
                class='k-file-multiple'
                [disabled]='disabled'
                [files]='files'
              [fileInfoTemplate]="fileInfoTemplate"></kendo-upload-file-list-multiple-items>
            }
            @if (fileTemplate) {
              <ng-container
                    [ngTemplateOutlet]="fileTemplate.templateRef" [ngTemplateOutletContext]="{
                            templateRef: fileTemplate.templateRef,
                            state: files[0].state,
                            $implicit: files
                        }"></ng-container>
            }
          </li>
        }
        `,
                    standalone: true,
                    imports: [FileListItemDirective, FileListSingleItemComponent, FileListMultipleItemsComponent, NgTemplateOutlet]
                }]
        }], ctorParameters: () => [{ type: UploadService }, { type: NavigationService }], propDecorators: { disabled: [{
                type: Input
            }], fileList: [{
                type: Input
            }], fileTemplate: [{
                type: Input
            }], fileInfoTemplate: [{
                type: Input
            }], fileListItems: [{
                type: ViewChildren,
                args: [FileListItemDirective]
            }], fileListRole: [{
                type: HostBinding,
                args: ['attr.role']
            }] } });

/**
 * @hidden
 */
class UploadStatusTotalComponent {
    localization;
    fileList;
    isFailed;
    isPaused;
    isUploading;
    statusText;
    checkmarkIcon = checkIcon;
    exceptionSVGIcon = exclamationCircleIcon;
    uploadSVGIcon = uploadIcon;
    pauseSVGIcon = pauseSmIcon;
    constructor(localization) {
        this.localization = localization;
    }
    get iconClass() {
        if (!this.isUploading && !this.isFailed) {
            return 'checkmark';
        }
        if (!this.isUploading && this.isFailed) {
            return 'exception';
        }
        if (this.isUploading) {
            return 'upload';
        }
        if (this.isPaused) {
            return 'pause-sm';
        }
    }
    get SVGIconClass() {
        if (!this.isUploading && !this.isFailed) {
            return this.checkmarkIcon;
        }
        if (!this.isUploading && this.isFailed) {
            return this.exceptionSVGIcon;
        }
        if (this.isUploading) {
            return this.uploadSVGIcon;
        }
        if (this.isPaused) {
            return this.pauseSVGIcon;
        }
    }
    ngDoCheck() {
        this.isPaused = this.fileList.hasFileWithState([FileState.Paused]);
        this.isFailed = this.fileList.hasFileWithState([FileState.Failed]);
        this.isUploading = this.fileList.hasFileWithState([FileState.Uploading]);
        if (this.isPaused && !this.isUploading) {
            this.statusText = this.localization.get('headerStatusPaused');
        }
        else {
            this.statusText = this.isUploading ? this.localization.get('headerStatusUploading')
                : this.localization.get('headerStatusUploaded');
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: UploadStatusTotalComponent, deps: [{ token: i1$1.LocalizationService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: UploadStatusTotalComponent, isStandalone: true, selector: "kendo-upload-status-total", inputs: { fileList: "fileList" }, ngImport: i0, template: `
        <kendo-icon-wrapper
            [name]="iconClass"
            [svgIcon]="SVGIconClass"
        >
        </kendo-icon-wrapper>
        {{statusText}}
    `, isInline: true, dependencies: [{ kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: UploadStatusTotalComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-upload-status-total',
                    template: `
        <kendo-icon-wrapper
            [name]="iconClass"
            [svgIcon]="SVGIconClass"
        >
        </kendo-icon-wrapper>
        {{statusText}}
    `,
                    standalone: true,
                    imports: [IconWrapperComponent]
                }]
        }], ctorParameters: () => [{ type: i1$1.LocalizationService }], propDecorators: { fileList: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class FileSelectDirective {
    uploadService;
    navigation;
    dir;
    disabled;
    multiple;
    restrictions;
    accept;
    required;
    type = "file";
    autocomplete = "off";
    tabIndex = -1;
    ariaHidden = true;
    element;
    constructor(uploadService, navigation, el) {
        this.uploadService = uploadService;
        this.navigation = navigation;
        this.element = el;
    }
    classNames = true;
    get nameAttribute() {
        return this.uploadService.async.saveField;
    }
    get multipleAttribute() {
        return this.multiple ? "multiple" : null;
    }
    get dirAttribute() {
        return this.dir;
    }
    get disabledAttribute() {
        return this.disabled ? "true" : null;
    }
    get acceptAttribute() {
        return this.accept ? this.accept : null;
    }
    get requiredAttribute() {
        return this.required ? "" : null;
    }
    onInputChange(event) {
        const ua = navigator.userAgent;
        const webkit = /(webkit)[ \/]([\w.]+)/i;
        const msBrowsers = /(windows)[ \/]([\w.]+)/i;
        let selectedFiles = inputFiles(event.target);
        selectedFiles = assignGuidToFiles(selectedFiles, !this.uploadService.async.batch);
        validateFiles(selectedFiles, this.restrictions);
        if (!this.multiple) {
            this.uploadService.clearFiles();
        }
        this.uploadService.addFiles(selectedFiles);
        /*
        Chrome, IE, Edge and Safari do not trigger a `change` event
        when a file with the same name is selected a number of consecutive times.
        As a workaround, clear the input value after handling the file.
        */
        const native = this.element.nativeElement;
        if (ua.match(webkit) || ua.match(msBrowsers)) {
            native.type = "";
            native.type = "file";
        }
        setTimeout(() => {
            this.navigation.focusedIndex = -1;
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FileSelectDirective, deps: [{ token: UploadService }, { token: NavigationService }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: FileSelectDirective, isStandalone: true, selector: "[kendoFileSelect]", inputs: { dir: "dir", disabled: "disabled", multiple: "multiple", restrictions: "restrictions", accept: "accept", required: "required" }, host: { listeners: { "change": "onInputChange($event)" }, properties: { "attr.type": "this.type", "attr.autocomplete": "this.autocomplete", "attr.tabindex": "this.tabIndex", "attr.aria-hidden": "this.ariaHidden", "class.k-hidden": "this.classNames", "attr.name": "this.nameAttribute", "attr.multiple": "this.multipleAttribute", "attr.dir": "this.dirAttribute", "attr.disabled": "this.disabledAttribute", "attr.accept": "this.acceptAttribute", "attr.required": "this.requiredAttribute" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FileSelectDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoFileSelect]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: UploadService }, { type: NavigationService }, { type: i0.ElementRef }], propDecorators: { dir: [{
                type: Input
            }], disabled: [{
                type: Input
            }], multiple: [{
                type: Input
            }], restrictions: [{
                type: Input
            }], accept: [{
                type: Input
            }], required: [{
                type: Input
            }], type: [{
                type: HostBinding,
                args: ["attr.type"]
            }], autocomplete: [{
                type: HostBinding,
                args: ["attr.autocomplete"]
            }], tabIndex: [{
                type: HostBinding,
                args: ["attr.tabindex"]
            }], ariaHidden: [{
                type: HostBinding,
                args: ["attr.aria-hidden"]
            }], classNames: [{
                type: HostBinding,
                args: ["class.k-hidden"]
            }], nameAttribute: [{
                type: HostBinding,
                args: ["attr.name"]
            }], multipleAttribute: [{
                type: HostBinding,
                args: ["attr.multiple"]
            }], dirAttribute: [{
                type: HostBinding,
                args: ["attr.dir"]
            }], disabledAttribute: [{
                type: HostBinding,
                args: ["attr.disabled"]
            }], acceptAttribute: [{
                type: HostBinding,
                args: ["attr.accept"]
            }], requiredAttribute: [{
                type: HostBinding,
                args: ["attr.required"]
            }], onInputChange: [{
                type: HostListener,
                args: ["change", ["$event"]]
            }] } });

/**
 * @hidden
 */
class DropZoneBase {
    element;
    renderer;
    hoverClass;
    lastDragElement;
    hideIntervalElement = null;
    /**
     * @hidden
     */
    onElementDragEnterListener() {
        this.addClass(this.hoverClass);
        this.lastDragElement = new Date();
        if (!this.hideIntervalElement) {
            this.hideIntervalElement = setInterval(() => {
                if (this.calculateTimeDiff(this.lastDragElement) < 100) {
                    return;
                }
                this.removeClass(this.hoverClass);
                clearInterval(this.hideIntervalElement);
                this.hideIntervalElement = null;
            }, 100);
        }
        return false;
    }
    /**
     * @hidden
     */
    onElementDragOverListener() {
        this.lastDragElement = new Date();
        return false;
    }
    constructor(element, renderer, cssClass) {
        this.element = element;
        this.renderer = renderer;
        this.hoverClass = cssClass;
    }
    calculateTimeDiff(prevEvent) {
        return new Date().getTime() - prevEvent.getTime();
    }
    addClass(className) {
        this.renderer.addClass(this.element.nativeElement, className);
    }
    removeClass(className) {
        this.renderer.removeClass(this.element.nativeElement, className);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DropZoneBase, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }, { token: 'hoverClass' }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: DropZoneBase, isStandalone: true, host: { listeners: { "dragenter": "onElementDragEnterListener()", "dragover": "onElementDragOverListener()" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DropZoneBase, decorators: [{
            type: Directive
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: undefined, decorators: [{
                    type: Inject,
                    args: ['hoverClass']
                }] }], propDecorators: { onElementDragEnterListener: [{
                type: HostListener,
                args: ['dragenter']
            }], onElementDragOverListener: [{
                type: HostListener,
                args: ['dragover']
            }] } });

/**
 * @hidden
 */
class DropZoneInternalDirective extends DropZoneBase {
    ngZone;
    uploadService;
    disabled;
    multiple;
    restrictions;
    initialClassName = true;
    unsubscribeDocumentDragEnter;
    unsubscribeDocumentDragOver;
    lastDragDocument;
    hideIntervalDocument = null;
    activeClass = 'k-dropzone-active';
    constructor(element, renderer, ngZone, uploadService) {
        super(element, renderer, 'k-hover');
        this.ngZone = ngZone;
        this.uploadService = uploadService;
        this.ngZone.runOutsideAngular(() => {
            this.unsubscribeDocumentDragEnter = this.renderer.listen('document', 'dragenter', () => this.onDocumentDragEnter());
            this.unsubscribeDocumentDragOver = this.renderer.listen('document', 'dragover', () => this.onDocumentDragOver());
        });
    }
    ngOnDestroy() {
        this.ngZone.runOutsideAngular(() => {
            if (this.unsubscribeDocumentDragEnter) {
                this.unsubscribeDocumentDragEnter();
            }
            if (this.unsubscribeDocumentDragOver) {
                this.unsubscribeDocumentDragOver();
            }
        });
    }
    onDocumentDragEnter() {
        this.addClass(this.activeClass);
        this.lastDragDocument = new Date();
        if (!this.hideIntervalDocument) {
            this.hideIntervalDocument = setInterval(() => {
                if (this.calculateTimeDiff(this.lastDragDocument) < 100) {
                    return;
                }
                this.removeClass(this.activeClass);
                clearInterval(this.hideIntervalDocument);
                this.hideIntervalDocument = null;
            }, 100);
        }
        return false;
    }
    /**
     * @hidden
     */
    onDocumentDragOver() {
        this.lastDragDocument = new Date();
        return false;
    }
    onDropListener(event) {
        const droppedFiles = event.dataTransfer.files;
        if (droppedFiles.length > 0 && !this.disabled) {
            let files = getAllFileInfo(droppedFiles);
            files = assignGuidToFiles(files, !this.uploadService.async.batch);
            if (!this.multiple) {
                files.splice(1, files.length - 1);
                this.uploadService.clearFiles();
            }
            validateFiles(files, this.restrictions);
            this.uploadService.addFiles(files);
        }
        return false;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DropZoneInternalDirective, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }, { token: i0.NgZone }, { token: UploadService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: DropZoneInternalDirective, isStandalone: true, selector: "\n      [kendoUploadInternalDropZone],\n      [kendoFileSelectInternalDropZone]\n    ", inputs: { disabled: "disabled", multiple: "multiple", restrictions: "restrictions" }, host: { listeners: { "drop": "onDropListener($event)" }, properties: { "class.k-dropzone": "this.initialClassName", "class.k-upload-dropzone": "this.initialClassName" } }, usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: DropZoneInternalDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: `
      [kendoUploadInternalDropZone],
      [kendoFileSelectInternalDropZone]
    `,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i0.NgZone }, { type: UploadService }], propDecorators: { disabled: [{
                type: Input
            }], multiple: [{
                type: Input
            }], restrictions: [{
                type: Input
            }], initialClassName: [{
                type: HostBinding,
                args: ['class.k-dropzone']
            }, {
                type: HostBinding,
                args: ['class.k-upload-dropzone']
            }], onDropListener: [{
                type: HostListener,
                args: ['drop', ['$event']]
            }] } });

/**
 * @hidden
 */
class Messages extends ComponentMessages {
    /**
     * Sets the text for the **Cancel** button.
     *
     * @default 'Cancel'
     */
    cancel;
    /**
     * Sets the text for the **Clear** button.
     *
     * @default 'Clear'
     */
    clearSelectedFiles;
    /**
     * Sets the drop-zone hint.
     *
     * @default 'Drop files here to upload'
     */
    dropFilesHere;
    /**
     * Sets the external drop-zone hint.
     *
     * @default 'Drag and drop files here to upload'
     */
    externalDropFilesHere;
    /**
     * Sets the status message for a batch of files.
     *
     * @default 'files'
     */
    filesBatchStatus;
    /**
     * Sets the status message for a batch of files after failed upload.
     *
     * @default 'files failed to upload.'
     */
    filesBatchStatusFailed;
    /**
     * Sets the status message for a batch of files after successful upload.
     *
     * @default 'files successfully uploaded.'
     */
    filesBatchStatusUploaded;
    /**
     * Sets the file status message after failed upload.
     *
     * @default 'File failed to upload.'
     */
    fileStatusFailed;
    /**
     * Sets the file status message after successful upload.
     *
     * @default 'File successfully uploaded.'
     */
    fileStatusUploaded;
    /**
     * Sets the header status message when the file upload is paused.
     *
     * @default 'Paused'
     */
    headerStatusPaused;
    /**
     * Sets the header status message after the file upload completes.
     *
     * @default 'Done'
     */
    headerStatusUploaded;
    /**
     * Sets the header status message during the upload of the file.
     *
     * @default 'Uploading...'
     */
    headerStatusUploading;
    /**
     * Sets the text for the invalid `allowedExtensions` restriction message.
     *
     * @default 'File type not allowed.'
     */
    invalidFileExtension;
    /**
     * Sets the text for the invalid `maxFileSize` restriction message.
     *
     * @default 'File size too large.'
     */
    invalidMaxFileSize;
    /**
     * Sets the text for the invalid `minFileSize` restriction message.
     *
     * @default 'File size too small.'
     */
    invalidMinFileSize;
    /**
     * Sets the text for the **Pause** button.
     *
     * @default 'Pause'
     */
    pause;
    /**
     * Sets the text for the **Remove** button.
     *
     * @default 'Remove'
     */
    remove;
    /**
     * Sets the text for the **Resume** button.
     *
     * @default 'Resume'
     */
    resume;
    /**
     * Sets the text for the **Retry** button.
     *
     * @default 'Retry'
     */
    retry;
    /**
     * Sets the text for the **Select** button.
     *
     * @default 'Select files...'
     */
    select;
    /**
     * Sets the text for the **Upload files** button.
     *
     * @default 'Upload'
     */
    uploadSelectedFiles;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: Messages, deps: null, target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: Messages, isStandalone: true, inputs: { cancel: "cancel", clearSelectedFiles: "clearSelectedFiles", dropFilesHere: "dropFilesHere", externalDropFilesHere: "externalDropFilesHere", filesBatchStatus: "filesBatchStatus", filesBatchStatusFailed: "filesBatchStatusFailed", filesBatchStatusUploaded: "filesBatchStatusUploaded", fileStatusFailed: "fileStatusFailed", fileStatusUploaded: "fileStatusUploaded", headerStatusPaused: "headerStatusPaused", headerStatusUploaded: "headerStatusUploaded", headerStatusUploading: "headerStatusUploading", invalidFileExtension: "invalidFileExtension", invalidMaxFileSize: "invalidMaxFileSize", invalidMinFileSize: "invalidMinFileSize", pause: "pause", remove: "remove", resume: "resume", retry: "retry", select: "select", uploadSelectedFiles: "uploadSelectedFiles" }, usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: Messages, decorators: [{
            type: Directive
        }], propDecorators: { cancel: [{
                type: Input
            }], clearSelectedFiles: [{
                type: Input
            }], dropFilesHere: [{
                type: Input
            }], externalDropFilesHere: [{
                type: Input
            }], filesBatchStatus: [{
                type: Input
            }], filesBatchStatusFailed: [{
                type: Input
            }], filesBatchStatusUploaded: [{
                type: Input
            }], fileStatusFailed: [{
                type: Input
            }], fileStatusUploaded: [{
                type: Input
            }], headerStatusPaused: [{
                type: Input
            }], headerStatusUploaded: [{
                type: Input
            }], headerStatusUploading: [{
                type: Input
            }], invalidFileExtension: [{
                type: Input
            }], invalidMaxFileSize: [{
                type: Input
            }], invalidMinFileSize: [{
                type: Input
            }], pause: [{
                type: Input
            }], remove: [{
                type: Input
            }], resume: [{
                type: Input
            }], retry: [{
                type: Input
            }], select: [{
                type: Input
            }], uploadSelectedFiles: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class LocalizedMessagesDirective extends Messages {
    service;
    constructor(service) {
        super();
        this.service = service;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: LocalizedMessagesDirective, deps: [{ token: i1$1.LocalizationService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: LocalizedMessagesDirective, isStandalone: true, selector: "\n    [kendoUploadLocalizedMessages],\n    [kendoFileSelectLocalizedMessages],\n    [kendoUploadDropZoneLocalizedMessages]\n  ", providers: [
            {
                provide: Messages,
                useExisting: forwardRef(() => LocalizedMessagesDirective)
            }
        ], usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: LocalizedMessagesDirective, decorators: [{
            type: Directive,
            args: [{
                    providers: [
                        {
                            provide: Messages,
                            useExisting: forwardRef(() => LocalizedMessagesDirective)
                        }
                    ],
                    selector: `
    [kendoUploadLocalizedMessages],
    [kendoFileSelectLocalizedMessages],
    [kendoUploadDropZoneLocalizedMessages]
  `,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1$1.LocalizationService }] });

/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * @hidden
 */
const UPLOAD_VALUE_ACCESSOR = {
    multi: true,
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => UploadComponent)
};
let idx$1 = 0;
/**
 * Represents the [Kendo UI Upload component for Angular]({% slug overview_upload %}).
 *
 * @example
 * ```html
 * <kendo-upload
 *    [saveUrl]="uploadSaveUrl"
 *    [removeUrl]="uploadRemoveUrl">
 * </kendo-upload>
 * ```
 *
 * @remarks
 * Supported children components are: {@link CustomMessagesComponent}
 */
class UploadComponent extends UploadFileSelectBase {
    uploadService;
    localization;
    navigation;
    dropZoneService;
    zone;
    renderer;
    cdr;
    injector;
    /**
     * Specifies whether selected files upload automatically
     * ([see example]({% slug fileprocessing_upload %}#toc-automatic-upload-of-files)).
     * Set `autoUpload` to `false` to change this behavior.
     *
     * @default true
     */
    set autoUpload(autoUpload) {
        this.uploadService.async.autoUpload = autoUpload;
    }
    get autoUpload() {
        return this.uploadService.async.autoUpload;
    }
    /**
     * Specifies whether all files in the selection upload in a single request
     * ([see example]({% slug fileprocessing_upload %}#toc-upload-of-batches-of-files)).
     * Files selected one after the other upload in separate requests.
     *
     * @default false
     */
    set batch(batch) {
        this.uploadService.async.batch = batch;
    }
    get batch() {
        return this.uploadService.async.batch;
    }
    /**
     * Specifies whether credentials (cookies, headers) are sent for cross-site requests
     * ([see example]({% slug credentials_upload %}#toc-attaching-credentials-to-requests)).
     * Set `withCredentials` has no effect on same-site requests.
     * Use the `saveHeaders` or `removeHeaders` property to add credentials to the request.
     * You can also use the [`upload`]({% slug api_upload_uploadevent %}) event.
     *
     * @default true
     */
    set withCredentials(withCredentials) {
        this.uploadService.async.withCredentials = withCredentials;
    }
    get withCredentials() {
        return this.uploadService.async.withCredentials;
    }
    /**
     * Specifies the [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) key which contains the files submitted to `saveUrl`.
     *
     */
    set saveField(saveField) {
        this.uploadService.async.saveField = saveField;
    }
    get saveField() {
        return this.uploadService.async.saveField;
    }
    /**
     * Specifies the [`HttpHeaders`](https://angular.io/api/common/http/HttpHeaders) attached to each upload request.
     */
    set saveHeaders(saveHeaders) {
        this.uploadService.async.saveHeaders = saveHeaders;
    }
    get saveHeaders() {
        return this.uploadService.async.saveHeaders;
    }
    /**
     * Specifies the [`RequestMethod`](https://angular.io/api/http/RequestMethod) of the upload request.
     *
     */
    set saveMethod(saveMethod) {
        this.uploadService.async.saveMethod = saveMethod;
    }
    get saveMethod() {
        return this.uploadService.async.saveMethod;
    }
    /**
     * Specifies the URL of the endpoint for the upload request.
     * The request [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) key uses the name from the `saveField` property.
     * This key contains the list of files to be uploaded.
     */
    set saveUrl(saveUrl) {
        this.uploadService.async.saveUrl = saveUrl;
    }
    get saveUrl() {
        return this.uploadService.async.saveUrl;
    }
    /**
     * Specifies the expected [`response type`](https://angular.io/api/common/http/HttpRequest#responseType) of the server.
     * The response type determines how the response is parsed.
     *
     * @default 'json'
     */
    set responseType(responseType) {
        this.uploadService.async.responseType = responseType;
    }
    get responseType() {
        return this.uploadService.async.responseType;
    }
    /**
     * Specifies the [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) key which contains the list of file names submitted to `removeUrl`.
     *
     */
    set removeField(removeField) { this.uploadService.async.removeField = removeField; }
    get removeField() { return this.uploadService.async.removeField; }
    /**
     * Specifies the [`HttpHeaders`](https://angular.io/api/common/http/HttpHeaders) attached to each `remove` request.
     */
    set removeHeaders(removeHeaders) {
        this.uploadService.async.removeHeaders = removeHeaders;
    }
    get removeHeaders() {
        return this.uploadService.async.removeHeaders;
    }
    /**
     * Specifies the [`RequestMethod`](https://angular.io/api/http/RequestMethod) of the `remove` request.
     *
     */
    set removeMethod(removeMethod) {
        this.uploadService.async.removeMethod = removeMethod;
    }
    get removeMethod() {
        return this.uploadService.async.removeMethod;
    }
    /**
     * Specifies the URL of the endpoint for the `remove` request.
     * The [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) request key uses the name from the `removeField` property.
     * This key contains the list of file names to be removed.
     */
    set removeUrl(removeUrl) {
        this.uploadService.async.removeUrl = removeUrl;
    }
    get removeUrl() {
        return this.uploadService.async.removeUrl;
    }
    /**
     * Specifies whether the chunk functionality of the Upload is enabled.
     *
     * @default false
     */
    chunkable = false;
    /**
     * Specifies whether selected files upload simultaneously or one by one.
     *
     * @default true
     */
    set concurrent(concurrent) {
        this.uploadService.async.concurrent = concurrent;
    }
    get concurrent() {
        return this.uploadService.async.concurrent;
    }
    /**
     * Specifies whether the file list is visible.
     *
     * @default true
     */
    showFileList = true;
    /**
     * @hidden
     */
    set tabIndex(tabIndex) {
        this.tabindex = tabIndex;
    }
    get tabIndex() {
        return this.tabindex;
    }
    /**
     * Specifies the layout of the action buttons.
     *
     * @default 'end'
     */
    actionsLayout = 'end';
    fileSelectInput;
    /**
     * Fires when the upload is canceled while in progress.
     */
    cancel = new EventEmitter();
    /**
     * Fires when the file list is about to be cleared.
     * Prevent this event to keep the files in the list.
     */
    clear = new EventEmitter();
    /**
     * Fires when all active uploads complete successfully or with errors.
     */
    complete = new EventEmitter();
    /**
     * Fires when an `upload` or `remove` operation fails.
     */
    error = new EventEmitter();
    /**
     * Fires when the upload of a file is paused.
     */
    pause = new EventEmitter();
    /**
     * Fires when the upload of a file is resumed.
     */
    resume = new EventEmitter();
    /**
     * Fires when an `upload` or `remove` operation completes successfully.
     */
    success = new EventEmitter();
    /**
     * Fires when one or more files are about to be uploaded.
     * Prevent this event to stop the files from uploading and being added to the file list.
     */
    upload = new EventEmitter();
    /**
     * Fires when one or more files are uploading.
     */
    uploadProgress = new EventEmitter();
    /**
     * Fires when the component value changes after a successful `upload`, `remove`, or `clear` operation.
     */
    valueChange = new EventEmitter();
    get dir() {
        return this.direction;
    }
    direction;
    wrapper;
    fileListId;
    documentClick;
    blurSubscription;
    wrapperFocusSubscription;
    selectButtonFocusSubscription;
    localizationChangeSubscription;
    subs;
    constructor(uploadService, localization, navigation, dropZoneService, zone, renderer, cdr, wrapper, injector) {
        super(uploadService, navigation, cdr, injector, zone);
        this.uploadService = uploadService;
        this.localization = localization;
        this.navigation = navigation;
        this.dropZoneService = dropZoneService;
        this.zone = zone;
        this.renderer = renderer;
        this.cdr = cdr;
        this.injector = injector;
        validatePackage(packageMetadata);
        this.fileList = this.uploadService.files;
        this.localizationChangeSubscription = localization.changes.subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
        });
        this.direction = localization.rtl ? 'rtl' : 'ltr';
        this.navigation.computeKeys();
        this.wrapper = wrapper.nativeElement;
        this.subscribeBlur();
        this.subscribeFocus();
        this.attachEventHandlers();
    }
    ngOnInit() {
        this.verifySettings();
        const { buttonId, fileListId } = this.getIds();
        this.focusableId = buttonId;
        this.fileListId = fileListId;
        this.uploadService.setChunkSettings(this.chunkable);
        if (this.zoneId) {
            this.dropZoneService.addComponent(this, this.zoneId);
        }
        this.zone.runOutsideAngular(() => {
            this.subs.add(this.renderer.listen(this.wrapper, 'keydown', event => this.handleKeydown(event)));
        });
    }
    ngOnChanges(changes) {
        if (isChanged("chunkable", changes)) {
            const newChunkable = changes.chunkable.currentValue;
            if (typeof newChunkable === 'boolean') {
                this.uploadService.async.chunk = newChunkable;
            }
            if (typeof newChunkable === "object" && newChunkable !== null) {
                this.uploadService.async.chunk = true;
                this.uploadService.chunk = Object.assign({}, this.uploadService.chunk, newChunkable);
            }
        }
    }
    ngOnDestroy() {
        this.fileList.clear();
        if (this.zoneId) {
            this.dropZoneService.clearComponent(this, this.zoneId);
        }
        if (this.blurSubscription) {
            this.blurSubscription.unsubscribe();
        }
        if (this.wrapperFocusSubscription) {
            this.wrapperFocusSubscription.unsubscribe();
        }
        if (this.selectButtonFocusSubscription) {
            this.selectButtonFocusSubscription.unsubscribe();
        }
        if (this.localizationChangeSubscription) {
            this.localizationChangeSubscription.unsubscribe();
        }
        if (this.subs) {
            this.subs.unsubscribe();
        }
    }
    /**
     * @hidden
     */
    writeValue(newValue) {
        super.writeValue(newValue, validateInitialFileInfo, 'addInitialFiles');
    }
    /**
     * @hidden
     */
    get showActionButtons() {
        let areVisible = false;
        if (!this.autoUpload) {
            const hasFilesToUpload = this.fileList.filesToUpload.length > 0;
            const uploadingFiles = this.fileList.hasFileWithState([FileState.Uploading]);
            if (this.concurrent && hasFilesToUpload) {
                areVisible = true;
            }
            if (!this.concurrent && hasFilesToUpload && !uploadingFiles) {
                areVisible = true;
            }
        }
        this.navigation.actionButtonsVisible = areVisible;
        return areVisible;
    }
    /**
     * @hidden
     */
    get showTotalStatus() {
        const states = [
            FileState.Uploaded,
            FileState.Uploading,
            FileState.Failed,
            FileState.Paused
        ];
        if (this.fileList.hasFileWithState(states)) {
            return true;
        }
        return false;
    }
    /**
     * @hidden
     */
    textFor(key) {
        return this.localization.get(key);
    }
    /**
     * @hidden
     */
    getIds() {
        const id = ++idx$1;
        const buttonId = `k-upload-button-${id}`;
        const fileListId = `k-upload-file-list-${id}`;
        return { buttonId, fileListId };
    }
    /**
     * Pauses the upload process of a file that is currently uploading.
     * This method requires the `chunkable` option of the Upload to be enabled.
     *
     * @param uid The `uid` of the file that will be paused.
     */
    pauseFileByUid(uid) {
        this.uploadService.pauseFile(uid);
    }
    /**
     * Resumes the upload process for a file that was previously paused.
     * This method requires the `chunkable` option of the Upload to be enabled.
     *
     * @param uid The `uid` of the file that will be resumed.
     */
    resumeFileByUid(uid) {
        this.uploadService.resumeFile(uid);
    }
    /**
     * Removes a file or a batch of files.
     *
     * @param uid The `uid` of the file or a batch of files that will be removed.
     */
    removeFilesByUid(uid) {
        this.uploadService.removeFiles(uid);
    }
    /**
     * Retries the upload of a file or batch of files that failed to upload.
     *
     * @param uid The `uid` of the file or a batch of files to be retried.
     */
    retryUploadByUid(uid) {
        this.uploadService.retryFiles(uid);
    }
    /**
     * Cancels the upload of a file or a batch of files.
     *
     * @param uid The `uid` of the file or a batch of files that will be canceled.
     */
    cancelUploadByUid(uid) {
        this.uploadService.cancelFiles(uid);
    }
    /**
     * Uploads the currently selected files that pass the set restrictions.
     */
    uploadFiles() {
        if (this.fileList.filesToUpload.length) {
            this.uploadService.uploadFiles();
        }
    }
    /**
     * Clears all files from the UI without sending requests to the remove handler.
     */
    clearFiles() {
        this.uploadService.clearFiles();
    }
    /**
     * @hidden
     * Used by the external dropzone to add files to the Upload
     */
    addFiles(files) {
        this.uploadService.addFiles(files);
    }
    /**
     * @hidden
     * Used to determine if the component is empty.
     */
    isEmpty() {
        return false;
    }
    verifySettings() {
        if (isDevMode()) {
            if (this.batch && this.chunkable !== false) {
                throw new Error('The file chunking functionality requires the batch setting to be disabled.');
            }
        }
    }
    subscribeBlur() {
        if (!isDocumentAvailable()) {
            return;
        }
        this.zone.runOutsideAngular(() => {
            this.documentClick = fromEvent(document, 'click').pipe(filter((event) => {
                return !(this.wrapper !== event.target && this.wrapper.contains(event.target));
            }));
            this.blurSubscription = merge(this.documentClick, this.navigation.onTabOut).subscribe(() => {
                if (this.navigation.focused) {
                    this.zone.run(() => {
                        this.navigation.focused = false;
                        this.onTouchedCallback();
                        this.onBlur.emit();
                    });
                }
            });
        });
    }
    handleKeydown(event) {
        if (this.disabled) {
            return;
        }
        if (event.target === this.fileSelectButton.nativeElement && (event.code === Keys.Enter || event.code === Keys.Space)) {
            event.preventDefault();
            this.fileSelectInput.nativeElement.click();
            return;
        }
        if (hasClasses(event.target, UPLOAD_CLASSES) ||
            (!isFocusable(event.target) && !hasClasses(event.target, IGNORE_TARGET_CLASSES))) {
            this.navigation.process(event);
        }
    }
    subscribeFocus() {
        this.wrapperFocusSubscription = this.navigation.onWrapperFocus.subscribe(() => {
            this.onFocus.emit();
        });
        this.selectButtonFocusSubscription = this.navigation.onSelectButtonFocus.subscribe(() => {
            this.fileSelectButton.nativeElement.focus();
        });
    }
    attachEventHandlers() {
        this.subs = this.uploadService.cancelEvent.subscribe((args) => {
            this.cancel.emit(args);
        });
        this.subs.add(this.uploadService.changeEvent.subscribe((files) => {
            this.onChangeCallback(files);
            this.valueChange.emit(files);
        }));
        this.subs.add(this.uploadService.clearEvent.subscribe((args) => {
            this.clear.emit(args);
        }));
        this.subs.add(this.uploadService.completeEvent.subscribe(() => {
            this.complete.emit();
        }));
        this.subs.add(this.uploadService.errorEvent.subscribe((args) => {
            this.error.emit(args);
        }));
        this.subs.add(this.uploadService.pauseEvent.subscribe((args) => {
            this.pause.emit(args);
        }));
        this.subs.add(this.uploadService.removeEvent.subscribe((args) => {
            this.remove.emit(args);
        }));
        this.subs.add(this.uploadService.resumeEvent.subscribe((args) => {
            this.resume.emit(args);
        }));
        this.subs.add(this.uploadService.selectEvent.subscribe((args) => {
            this.select.emit(args);
        }));
        this.subs.add(this.uploadService.successEvent.subscribe((args) => {
            this.success.emit(args);
        }));
        this.subs.add(this.uploadService.uploadEvent.subscribe((args) => {
            this.upload.emit(args);
        }));
        this.subs.add(this.uploadService.uploadProgressEvent.subscribe((args) => {
            this.uploadProgress.emit(args);
        }));
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: UploadComponent, deps: [{ token: UploadService }, { token: i1$1.LocalizationService }, { token: NavigationService }, { token: DropZoneService }, { token: i0.NgZone }, { token: i0.Renderer2 }, { token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: UploadComponent, isStandalone: true, selector: "kendo-upload", inputs: { autoUpload: "autoUpload", batch: "batch", withCredentials: "withCredentials", saveField: "saveField", saveHeaders: "saveHeaders", saveMethod: "saveMethod", saveUrl: "saveUrl", responseType: "responseType", removeField: "removeField", removeHeaders: "removeHeaders", removeMethod: "removeMethod", removeUrl: "removeUrl", chunkable: "chunkable", concurrent: "concurrent", showFileList: "showFileList", tabIndex: "tabIndex", actionsLayout: "actionsLayout" }, outputs: { cancel: "cancel", clear: "clear", complete: "complete", error: "error", pause: "pause", resume: "resume", success: "success", upload: "upload", uploadProgress: "uploadProgress", valueChange: "valueChange" }, host: { properties: { "attr.dir": "this.dir" } }, providers: [
            LocalizationService,
            NavigationService,
            UploadService,
            DropZoneService,
            UPLOAD_VALUE_ACCESSOR,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.upload'
            },
            {
                provide: KendoInput,
                useExisting: forwardRef(() => UploadComponent)
            }
        ], viewQueries: [{ propertyName: "fileSelectInput", first: true, predicate: ["fileSelectInput"], descendants: true, static: true }], exportAs: ["kendoUpload"], usesInheritance: true, usesOnChanges: true, ngImport: i0, template: `
    <ng-container kendoUploadLocalizedMessages
      i18n-cancel="kendo.upload.cancel|The text for the Cancel button"
      cancel="Cancel"
    
      i18n-clearSelectedFiles="kendo.upload.clearSelectedFiles|The text for the Clear button"
      clearSelectedFiles="Clear"
    
      i18n-dropFilesHere="kendo.upload.dropFilesHere|The drop zone hint"
      dropFilesHere="Drop files here to upload"
    
      i18n-filesBatchStatus="kendo.upload.filesBatchStatus|The status message for a batch of files"
      filesBatchStatus="files"
    
      i18n-filesBatchStatusFailed="kendo.upload.filesBatchStatusFailed|The status message for a batch of files after failed upload"
      filesBatchStatusFailed="files failed to upload."
    
      i18n-filesBatchStatusUploaded="kendo.upload.filesBatchStatusUploaded|The status message for a batch of files after successful upload"
      filesBatchStatusUploaded="files successfully uploaded."
    
      i18n-fileStatusFailed="kendo.upload.fileStatusFailed|The file status message after failed upload"
      fileStatusFailed="File failed to upload."
    
      i18n-fileStatusUploaded="kendo.upload.fileStatusUploaded|The file status message after successful upload"
      fileStatusUploaded="File successfully uploaded."
    
      i18n-headerStatusPaused="kendo.upload.headerStatusPaused|The header status message when the file upload is paused"
      headerStatusPaused="Paused"
    
      i18n-headerStatusUploaded="kendo.upload.headerStatusUploaded|The header status message after file upload completion"
      headerStatusUploaded="Done"
    
      i18n-headerStatusUploading="kendo.upload.headerStatusUploading|The header status message during file upload"
      headerStatusUploading="Uploading..."
    
      i18n-invalidFileExtension="kendo.upload.invalidFileExtension|The text for the invalid allowed extensions restriction message"
      invalidFileExtension="File type not allowed."
    
      i18n-invalidMaxFileSize="kendo.upload.invalidMaxFileSize|The text for the invalid max file size restriction message"
      invalidMaxFileSize="File size too large."
    
      i18n-invalidMinFileSize="kendo.upload.invalidMinFileSize|The text for the invalid min file size restriction message"
      invalidMinFileSize="File size too small."
    
      i18n-pause="kendo.upload.pause|The text for the Pause button"
      pause="Pause"
    
      i18n-remove="kendo.upload.remove|The text for the Remove button"
      remove="Remove"
    
      i18n-resume="kendo.upload.resume|The text for the Resume button"
      resume="Resume"
    
      i18n-retry="kendo.upload.retry|The text for the Retry button"
      retry="Retry"
    
      i18n-select="kendo.upload.select|The text for the Select button"
      select="Select files..."
    
      i18n-uploadSelectedFiles="kendo.upload.uploadSelectedFiles|The text for the Upload files button"
      uploadSelectedFiles="Upload"
      >
    </ng-container>
    <div kendoUploadInternalDropZone
      [restrictions]="restrictions"
      [multiple]="multiple"
      [disabled]="disabled"
      >
      <div class="k-upload-button-wrap">
        <button
          kendoButton
          #fileSelectButton
          class="k-upload-button"
          type="button"
          (click)="fileSelectInput.click()"
          (focus)="onFileSelectButtonFocus()"
          [id]="focusableId"
          [attr.aria-label]="textFor('select')"
          [attr.tabindex]="tabindex"
          [attr.aria-expanded]="hasFileList"
          [attr.aria-controls]="hasFileList ? fileListId : undefined"
          >
          {{textFor('select')}}
        </button>
        <input kendoFileSelect #fileSelectInput
          [dir]="direction"
          [accept]="accept"
          [restrictions]="restrictions"
          [multiple]="multiple"
          [disabled]="disabled"
          [required]="isControlRequired" />
      </div>
      @if (showTotalStatus) {
        <kendo-upload-status-total
          class="k-upload-status"
          [fileList]="fileList">
        </kendo-upload-status-total>
      }
      <div class="k-dropzone-hint">{{textFor('dropFilesHere')}}</div>
    </div>
    @if (hasFileList) {
      <ul kendo-upload-file-list
        class="k-upload-files k-reset"
        [disabled]="disabled"
        [fileList]="fileList.files"
        [fileTemplate]="fileTemplate"
        [fileInfoTemplate]="fileInfoTemplate"
        [id]="fileListId">
      </ul>
    }
    @if (showActionButtons) {
      <kendo-upload-action-buttons
        [disabled]="disabled"
        [actionsLayout]="actionsLayout">
      </kendo-upload-action-buttons>
    }
    `, isInline: true, dependencies: [{ kind: "directive", type: LocalizedMessagesDirective, selector: "\n    [kendoUploadLocalizedMessages],\n    [kendoFileSelectLocalizedMessages],\n    [kendoUploadDropZoneLocalizedMessages]\n  " }, { kind: "directive", type: DropZoneInternalDirective, selector: "\n      [kendoUploadInternalDropZone],\n      [kendoFileSelectInternalDropZone]\n    ", inputs: ["disabled", "multiple", "restrictions"] }, { kind: "component", type: ButtonComponent, selector: "button[kendoButton]", inputs: ["arrowIcon", "toggleable", "togglable", "selected", "tabIndex", "imageUrl", "iconClass", "icon", "disabled", "size", "rounded", "fillMode", "themeColor", "svgIcon", "primary", "look"], outputs: ["selectedChange", "click"], exportAs: ["kendoButton"] }, { kind: "directive", type: FileSelectDirective, selector: "[kendoFileSelect]", inputs: ["dir", "disabled", "multiple", "restrictions", "accept", "required"] }, { kind: "component", type: UploadStatusTotalComponent, selector: "kendo-upload-status-total", inputs: ["fileList"] }, { kind: "component", type: FileListComponent, selector: "[kendo-upload-file-list]", inputs: ["disabled", "fileList", "fileTemplate", "fileInfoTemplate"] }, { kind: "component", type: UploadActionButtonsComponent, selector: "kendo-upload-action-buttons", inputs: ["disabled", "actionsLayout"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: UploadComponent, decorators: [{
            type: Component,
            args: [{
                    exportAs: 'kendoUpload',
                    providers: [
                        LocalizationService,
                        NavigationService,
                        UploadService,
                        DropZoneService,
                        UPLOAD_VALUE_ACCESSOR,
                        {
                            provide: L10N_PREFIX,
                            useValue: 'kendo.upload'
                        },
                        {
                            provide: KendoInput,
                            useExisting: forwardRef(() => UploadComponent)
                        }
                    ],
                    selector: 'kendo-upload',
                    template: `
    <ng-container kendoUploadLocalizedMessages
      i18n-cancel="kendo.upload.cancel|The text for the Cancel button"
      cancel="Cancel"
    
      i18n-clearSelectedFiles="kendo.upload.clearSelectedFiles|The text for the Clear button"
      clearSelectedFiles="Clear"
    
      i18n-dropFilesHere="kendo.upload.dropFilesHere|The drop zone hint"
      dropFilesHere="Drop files here to upload"
    
      i18n-filesBatchStatus="kendo.upload.filesBatchStatus|The status message for a batch of files"
      filesBatchStatus="files"
    
      i18n-filesBatchStatusFailed="kendo.upload.filesBatchStatusFailed|The status message for a batch of files after failed upload"
      filesBatchStatusFailed="files failed to upload."
    
      i18n-filesBatchStatusUploaded="kendo.upload.filesBatchStatusUploaded|The status message for a batch of files after successful upload"
      filesBatchStatusUploaded="files successfully uploaded."
    
      i18n-fileStatusFailed="kendo.upload.fileStatusFailed|The file status message after failed upload"
      fileStatusFailed="File failed to upload."
    
      i18n-fileStatusUploaded="kendo.upload.fileStatusUploaded|The file status message after successful upload"
      fileStatusUploaded="File successfully uploaded."
    
      i18n-headerStatusPaused="kendo.upload.headerStatusPaused|The header status message when the file upload is paused"
      headerStatusPaused="Paused"
    
      i18n-headerStatusUploaded="kendo.upload.headerStatusUploaded|The header status message after file upload completion"
      headerStatusUploaded="Done"
    
      i18n-headerStatusUploading="kendo.upload.headerStatusUploading|The header status message during file upload"
      headerStatusUploading="Uploading..."
    
      i18n-invalidFileExtension="kendo.upload.invalidFileExtension|The text for the invalid allowed extensions restriction message"
      invalidFileExtension="File type not allowed."
    
      i18n-invalidMaxFileSize="kendo.upload.invalidMaxFileSize|The text for the invalid max file size restriction message"
      invalidMaxFileSize="File size too large."
    
      i18n-invalidMinFileSize="kendo.upload.invalidMinFileSize|The text for the invalid min file size restriction message"
      invalidMinFileSize="File size too small."
    
      i18n-pause="kendo.upload.pause|The text for the Pause button"
      pause="Pause"
    
      i18n-remove="kendo.upload.remove|The text for the Remove button"
      remove="Remove"
    
      i18n-resume="kendo.upload.resume|The text for the Resume button"
      resume="Resume"
    
      i18n-retry="kendo.upload.retry|The text for the Retry button"
      retry="Retry"
    
      i18n-select="kendo.upload.select|The text for the Select button"
      select="Select files..."
    
      i18n-uploadSelectedFiles="kendo.upload.uploadSelectedFiles|The text for the Upload files button"
      uploadSelectedFiles="Upload"
      >
    </ng-container>
    <div kendoUploadInternalDropZone
      [restrictions]="restrictions"
      [multiple]="multiple"
      [disabled]="disabled"
      >
      <div class="k-upload-button-wrap">
        <button
          kendoButton
          #fileSelectButton
          class="k-upload-button"
          type="button"
          (click)="fileSelectInput.click()"
          (focus)="onFileSelectButtonFocus()"
          [id]="focusableId"
          [attr.aria-label]="textFor('select')"
          [attr.tabindex]="tabindex"
          [attr.aria-expanded]="hasFileList"
          [attr.aria-controls]="hasFileList ? fileListId : undefined"
          >
          {{textFor('select')}}
        </button>
        <input kendoFileSelect #fileSelectInput
          [dir]="direction"
          [accept]="accept"
          [restrictions]="restrictions"
          [multiple]="multiple"
          [disabled]="disabled"
          [required]="isControlRequired" />
      </div>
      @if (showTotalStatus) {
        <kendo-upload-status-total
          class="k-upload-status"
          [fileList]="fileList">
        </kendo-upload-status-total>
      }
      <div class="k-dropzone-hint">{{textFor('dropFilesHere')}}</div>
    </div>
    @if (hasFileList) {
      <ul kendo-upload-file-list
        class="k-upload-files k-reset"
        [disabled]="disabled"
        [fileList]="fileList.files"
        [fileTemplate]="fileTemplate"
        [fileInfoTemplate]="fileInfoTemplate"
        [id]="fileListId">
      </ul>
    }
    @if (showActionButtons) {
      <kendo-upload-action-buttons
        [disabled]="disabled"
        [actionsLayout]="actionsLayout">
      </kendo-upload-action-buttons>
    }
    `,
                    standalone: true,
                    imports: [LocalizedMessagesDirective, DropZoneInternalDirective, ButtonComponent, FileSelectDirective, UploadStatusTotalComponent, FileListComponent, UploadActionButtonsComponent]
                }]
        }], ctorParameters: () => [{ type: UploadService }, { type: i1$1.LocalizationService }, { type: NavigationService }, { type: DropZoneService }, { type: i0.NgZone }, { type: i0.Renderer2 }, { type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.Injector }], propDecorators: { autoUpload: [{
                type: Input
            }], batch: [{
                type: Input
            }], withCredentials: [{
                type: Input
            }], saveField: [{
                type: Input
            }], saveHeaders: [{
                type: Input
            }], saveMethod: [{
                type: Input
            }], saveUrl: [{
                type: Input
            }], responseType: [{
                type: Input
            }], removeField: [{
                type: Input
            }], removeHeaders: [{
                type: Input
            }], removeMethod: [{
                type: Input
            }], removeUrl: [{
                type: Input
            }], chunkable: [{
                type: Input
            }], concurrent: [{
                type: Input
            }], showFileList: [{
                type: Input
            }], tabIndex: [{
                type: Input,
                args: ['tabIndex']
            }], actionsLayout: [{
                type: Input
            }], fileSelectInput: [{
                type: ViewChild,
                args: ['fileSelectInput', { static: true }]
            }], cancel: [{
                type: Output
            }], clear: [{
                type: Output
            }], complete: [{
                type: Output
            }], error: [{
                type: Output
            }], pause: [{
                type: Output
            }], resume: [{
                type: Output
            }], success: [{
                type: Output
            }], upload: [{
                type: Output
            }], uploadProgress: [{
                type: Output
            }], valueChange: [{
                type: Output
            }], dir: [{
                type: HostBinding,
                args: ['attr.dir']
            }] } });

/**
 * Represents the [Kendo UI UploadDropZone directive for Angular]({% slug overview_upload %}).
 * Use this directive to create external drop zones for Upload and FileSelect components.
 *
 * @example
 * ```html
 * <div kendoUploadDropZone="upload1">Drop files here</div>
 * <kendo-upload [saveUrl]="uploadSaveUrl" zoneId="upload1"></kendo-upload>
 * ```
 */
class UploadDropZoneDirective {
    dropZoneService;
    /**
     * The id of the drop zone to associate with an existing Upload component.
     */
    zoneId;
    /**
     * The id of the drop zone to associate with an existing FileSelect component.
     */
    fileSelectZoneId;
    constructor(dropZoneService) {
        this.dropZoneService = dropZoneService;
    }
    /**
     * @hidden
     */
    onElementDragEnter() {
        return false;
    }
    /**
     * @hidden
     */
    onElementDragOver() {
        return false;
    }
    /**
     * @hidden
     */
    onDropListener(event) {
        const components = this.componentInstance;
        if (!isPresent(components)) {
            return;
        }
        components.forEach((component) => {
            const droppedFiles = event.dataTransfer.files;
            if (droppedFiles.length > 0 && !component.disabled) {
                let files = getAllFileInfo(droppedFiles);
                if (component instanceof UploadComponent) {
                    files = assignGuidToFiles(files, !component.batch);
                }
                else {
                    files = assignGuidToFiles(files, true);
                }
                if (!component.multiple) {
                    files.splice(1, files.length - 1);
                    component.clearFiles();
                }
                validateFiles(files, component.restrictions);
                component.addFiles(files);
            }
        });
        return false;
    }
    /**
     * @hidden
     */
    get componentInstance() {
        const id = this.zoneId || this.fileSelectZoneId;
        return this.dropZoneService.getComponents(id);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: UploadDropZoneDirective, deps: [{ token: DropZoneService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.18", type: UploadDropZoneDirective, isStandalone: true, selector: "[kendoUploadDropZone], [kendoFileSelectDropZone]", inputs: { zoneId: ["kendoUploadDropZone", "zoneId"], fileSelectZoneId: ["kendoFileSelectDropZone", "fileSelectZoneId"] }, host: { listeners: { "dragenter": "onElementDragEnter()", "dragover": "onElementDragOver()", "drop": "onDropListener($event)" } }, providers: [
            DropZoneService
        ], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: UploadDropZoneDirective, decorators: [{
            type: Directive,
            args: [{
                    providers: [
                        DropZoneService
                    ],
                    selector: '[kendoUploadDropZone], [kendoFileSelectDropZone]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: DropZoneService }], propDecorators: { zoneId: [{
                type: Input,
                args: ['kendoUploadDropZone']
            }], fileSelectZoneId: [{
                type: Input,
                args: ['kendoFileSelectDropZone']
            }], onElementDragEnter: [{
                type: HostListener,
                args: ['dragenter']
            }], onElementDragOver: [{
                type: HostListener,
                args: ['dragover']
            }], onDropListener: [{
                type: HostListener,
                args: ['drop', ['$event']]
            }] } });

/**
 * Represents the [Kendo UI UploadDropZone component for Angular]({% slug overview_upload %}).
 *
 * @example
 * ```html
 * <kendo-uploaddropzone zoneId="upload1">
 *   Drop files here to upload
 * </kendo-uploaddropzone>
 * <kendo-upload [saveUrl]="uploadSaveUrl" zoneId="upload1"></kendo-upload>
 * ```
 *
 * @remarks
 * Supported children components are: {@link CustomMessagesComponent}
 */
class UploadDropZoneComponent extends DropZoneBase {
    localization;
    hostClass = true;
    get dirAttribute() {
        return this.direction;
    }
    /**
     * Specifies the id of the component.
     * Use this id to associate the DropZone with an existing Upload or FileSelect component.
     */
    zoneId;
    /**
     * Specifies the name for an existing icon in a Kendo UI theme.
     * The icon renders inside the DropZone.
     */
    icon;
    /**
     * Specifies a CSS class or multiple classes separated by spaces which apply to a span element.
     * Use this property to apply custom icons.
     */
    iconClass;
    /**
     * Specifies an SVGIcon to render inside the DropZone.
     * The input accepts either an [existing Kendo SVG icon](slug:svgicon_list) or a custom one.
     */
    set svgIcon(icon) {
        if (isDevMode() && icon && this.icon && this.iconClass) {
            throw new Error('Setting both icon/svgIcon and iconClass options at the same time is not supported.');
        }
        this._svgIcon = icon;
    }
    get svgIcon() {
        return this._svgIcon;
    }
    direction;
    localizationChangeSubscription;
    _svgIcon = uploadIcon;
    constructor(element, renderer, localization) {
        super(element, renderer, 'k-external-dropzone-hover');
        this.localization = localization;
        this.localizationChangeSubscription = this.localization.changes.subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
        });
    }
    /**
     * @hidden
     */
    textFor(key) {
        return this.localization.get(key);
    }
    /**
     * @hidden
     */
    get iconClasses() {
        if (this.icon) {
            return `${this.icon}`;
        }
        if (!this.icon && !this.iconClass) {
            return 'upload';
        }
    }
    ngOnDestroy() {
        if (this.localizationChangeSubscription) {
            this.localizationChangeSubscription.unsubscribe();
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: UploadDropZoneComponent, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }, { token: i1$1.LocalizationService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: UploadDropZoneComponent, isStandalone: true, selector: "kendo-uploaddropzone", inputs: { zoneId: "zoneId", icon: "icon", iconClass: "iconClass", svgIcon: "svgIcon" }, host: { properties: { "class.k-external-dropzone": "this.hostClass", "attr.dir": "this.dirAttribute" } }, providers: [
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.uploaddropzone'
            }
        ], exportAs: ["kendoUploadDropZone"], usesInheritance: true, ngImport: i0, template: `
        <ng-container kendoUploadDropZoneLocalizedMessages
            i18n-externalDropFilesHere='kendo.uploaddropzone.externalDropFilesHere|Sets the external drop-zone hint'
            externalDropFilesHere='Drag and drop files here to upload'>
        </ng-container>
        <div class='k-dropzone-inner' [kendoUploadDropZone]="zoneId">
            <kendo-icon-wrapper
                size="xxxlarge"
                innerCssClass="k-dropzone-icon"
                [name]="iconClasses"
                [customFontClass]="iconClass"
                [svgIcon]="svgIcon"
            ></kendo-icon-wrapper>
            <span class="k-dropzone-hint">{{ textFor('externalDropFilesHere') }}</span>
            <span class="k-dropzone-note">
                <ng-content></ng-content>
            </span>
        </div>
    `, isInline: true, dependencies: [{ kind: "directive", type: LocalizedMessagesDirective, selector: "\n    [kendoUploadLocalizedMessages],\n    [kendoFileSelectLocalizedMessages],\n    [kendoUploadDropZoneLocalizedMessages]\n  " }, { kind: "directive", type: UploadDropZoneDirective, selector: "[kendoUploadDropZone], [kendoFileSelectDropZone]", inputs: ["kendoUploadDropZone", "kendoFileSelectDropZone"] }, { kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: UploadDropZoneComponent, decorators: [{
            type: Component,
            args: [{
                    exportAs: 'kendoUploadDropZone',
                    providers: [
                        LocalizationService,
                        {
                            provide: L10N_PREFIX,
                            useValue: 'kendo.uploaddropzone'
                        }
                    ],
                    selector: 'kendo-uploaddropzone',
                    template: `
        <ng-container kendoUploadDropZoneLocalizedMessages
            i18n-externalDropFilesHere='kendo.uploaddropzone.externalDropFilesHere|Sets the external drop-zone hint'
            externalDropFilesHere='Drag and drop files here to upload'>
        </ng-container>
        <div class='k-dropzone-inner' [kendoUploadDropZone]="zoneId">
            <kendo-icon-wrapper
                size="xxxlarge"
                innerCssClass="k-dropzone-icon"
                [name]="iconClasses"
                [customFontClass]="iconClass"
                [svgIcon]="svgIcon"
            ></kendo-icon-wrapper>
            <span class="k-dropzone-hint">{{ textFor('externalDropFilesHere') }}</span>
            <span class="k-dropzone-note">
                <ng-content></ng-content>
            </span>
        </div>
    `,
                    standalone: true,
                    imports: [LocalizedMessagesDirective, UploadDropZoneDirective, IconWrapperComponent]
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i1$1.LocalizationService }], propDecorators: { hostClass: [{
                type: HostBinding,
                args: ['class.k-external-dropzone']
            }], dirAttribute: [{
                type: HostBinding,
                args: ['attr.dir']
            }], zoneId: [{
                type: Input
            }], icon: [{
                type: Input
            }], iconClass: [{
                type: Input
            }], svgIcon: [{
                type: Input
            }] } });

/**
 * @hidden
 */
const FILESELECT_VALUE_ACCESSOR = {
    multi: true,
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => FileSelectComponent)
};
let idx = 0;
/**
 * Represents the [Kendo UI FileSelect component for Angular](slug:overview_fileselect_uploads).
 *
 * @example
 * ```html
 * <kendo-fileselect> </kendo-fileselect>
 * ```
 *
 * @remarks
 * Supported children components are: {@link CustomMessagesComponent}
 */
class FileSelectComponent extends UploadFileSelectBase {
    uploadService;
    localization;
    navigation;
    dropZoneService;
    ngZone;
    renderer;
    cdr;
    injector;
    fileSelectInput;
    get dir() {
        return this.direction;
    }
    /**
     * Specifies the `name` attribute of the `input` element of the FileSelect.
     */
    set name(name) {
        this.uploadService.async.saveField = name;
    }
    get name() {
        return this.uploadService.async.saveField;
    }
    /**
     * Fires when the component value changes after a successful `select` or `remove` operation.
     */
    valueChange = new EventEmitter();
    /**
     * @hidden
     */
    _restrictions = {
        allowedExtensions: [],
        maxFileSize: 0,
        minFileSize: 0
    };
    direction;
    wrapper;
    fileListId;
    documentClick;
    blurSubscription;
    wrapperFocusSubscription;
    selectButtonFocusSubscription;
    localizationChangeSubscription;
    subs;
    constructor(uploadService, localization, navigation, dropZoneService, ngZone, renderer, cdr, wrapper, injector) {
        super(uploadService, navigation, cdr, injector, ngZone);
        this.uploadService = uploadService;
        this.localization = localization;
        this.navigation = navigation;
        this.dropZoneService = dropZoneService;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.cdr = cdr;
        this.injector = injector;
        validatePackage(packageMetadata);
        this.wrapper = wrapper.nativeElement;
        this.direction = localization.rtl ? 'rtl' : 'ltr';
        this.navigation.computeKeys();
        this.localizationChangeSubscription = localization.changes.subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
        });
        this.subscribeBlur();
        this.subscribeFocus();
        this.attachEventHandlers();
        this.setDefaultSettings();
    }
    ngOnInit() {
        const { buttonId, fileListId } = this.getIds();
        this.focusableId = buttonId;
        this.fileListId = fileListId;
        if (this.zoneId) {
            this.dropZoneService.addComponent(this, this.zoneId);
        }
        this.subs.add(this.renderer.listen(this.fileSelectInput.nativeElement, 'mouseenter', () => {
            this.renderer.addClass(this.fileSelectButton.nativeElement, 'k-hover');
        }));
        this.subs.add(this.renderer.listen(this.fileSelectInput.nativeElement, 'mouseleave', () => {
            this.renderer.removeClass(this.fileSelectButton.nativeElement, 'k-hover');
        }));
        this.ngZone.runOutsideAngular(() => {
            this.subs.add(this.renderer.listen(this.wrapper, 'keydown', event => this.handleKeydown(event)));
        });
    }
    /**
     * @hidden
     */
    textFor(key) {
        return this.localization.get(key);
    }
    ngOnDestroy() {
        this.fileList.clear();
        if (this.blurSubscription) {
            this.blurSubscription.unsubscribe();
        }
        if (this.wrapperFocusSubscription) {
            this.wrapperFocusSubscription.unsubscribe();
        }
        if (this.selectButtonFocusSubscription) {
            this.selectButtonFocusSubscription.unsubscribe();
        }
        if (this.localizationChangeSubscription) {
            this.localizationChangeSubscription.unsubscribe();
        }
        if (this.subs) {
            this.subs.unsubscribe();
        }
    }
    /**
     * Removes a specific file from the file list.
     *
     * @param uid The `uid` of the file to be removed.
     */
    removeFileByUid(uid) {
        this.uploadService.removeFiles(uid);
    }
    /**
     * Clears all files from the UI.
     */
    clearFiles() {
        this.uploadService.clearFiles();
    }
    /**
     * @hidden
     * Used to determine if the component is empty.
     */
    isEmpty() {
        return false;
    }
    /**
     * @hidden
     * Used by the external dropzone to add files to the FileSelect
     */
    addFiles(files) {
        this.uploadService.addFiles(files);
    }
    /**
     * @hidden
     */
    get selectButtonTabIndex() {
        return this.disabled ? undefined : this.tabindex;
    }
    /**
     * @hidden
     */
    getIds() {
        const id = ++idx;
        const buttonId = `k-fileselect-button-${id}`;
        const fileListId = `k-fileselect-file-list-${id}`;
        return { buttonId, fileListId };
    }
    /**
     * @hidden
     */
    writeValue(newValue) {
        super.writeValue(newValue, validateInitialFileSelectFile, 'addInitialFileSelectFiles');
    }
    subscribeBlur() {
        if (!isDocumentAvailable()) {
            return;
        }
        this.ngZone.runOutsideAngular(() => {
            this.documentClick = fromEvent(document, 'click').pipe(filter((event) => {
                return !(this.wrapper !== event.target && this.wrapper.contains(event.target));
            }));
            this.blurSubscription = merge(this.documentClick, this.navigation.onTabOut).subscribe(() => {
                if (this.navigation.focused) {
                    this.ngZone.run(() => {
                        this.navigation.focused = false;
                        this.onTouchedCallback();
                        this.onBlur.emit();
                    });
                }
            });
        });
    }
    subscribeFocus() {
        this.wrapperFocusSubscription = this.navigation.onWrapperFocus.subscribe(() => {
            this.onFocus.emit();
        });
        this.selectButtonFocusSubscription = this.navigation.onSelectButtonFocus.subscribe(() => {
            this.fileSelectButton.nativeElement.focus();
        });
    }
    handleKeydown(event) {
        if (this.disabled) {
            return;
        }
        if (event.target === this.fileSelectButton.nativeElement && (event.code === Keys.Enter || event.code === Keys.NumpadEnter || event.code === Keys.Space)) {
            event.preventDefault();
            this.fileSelectInput.nativeElement.click();
            return;
        }
        if (hasClasses(event.target, UPLOAD_CLASSES) ||
            (!isFocusable(event.target) && !hasClasses(event.target, IGNORE_TARGET_CLASSES))) {
            this.navigation.process(event, 'fileselect');
        }
    }
    attachEventHandlers() {
        this.subs = this.uploadService.changeEvent.subscribe((files) => {
            let model = [];
            if (files !== null) {
                files.forEach((file) => {
                    if (file.state === FileState.Initial) {
                        model.push(file);
                    }
                    if (file.state === FileState.Selected && file.rawFile && !file.validationErrors) {
                        model.push(file.rawFile);
                    }
                });
            }
            if (model.length === 0) {
                model = null;
            }
            this.onChangeCallback(model);
            this.valueChange.emit(model);
        });
        this.subs.add(this.uploadService.removeEvent.subscribe((args) => {
            this.remove.emit(args);
        }));
        this.subs.add(this.uploadService.selectEvent.subscribe((args) => {
            this.select.emit(args);
        }));
    }
    setDefaultSettings() {
        this.uploadService.async.autoUpload = false;
        this.uploadService.component = 'FileSelect';
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FileSelectComponent, deps: [{ token: UploadService }, { token: i1$1.LocalizationService }, { token: NavigationService }, { token: DropZoneService }, { token: i0.NgZone }, { token: i0.Renderer2 }, { token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.18", type: FileSelectComponent, isStandalone: true, selector: "kendo-fileselect", inputs: { name: "name" }, outputs: { valueChange: "valueChange" }, host: { properties: { "attr.dir": "this.dir" } }, providers: [
            LocalizationService,
            NavigationService,
            UploadService,
            DropZoneService,
            FILESELECT_VALUE_ACCESSOR,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.fileselect'
            },
            {
                provide: KendoInput,
                useExisting: forwardRef(() => FileSelectComponent)
            }
        ], viewQueries: [{ propertyName: "fileSelectInput", first: true, predicate: ["fileSelectInput"], descendants: true, static: true }], exportAs: ["kendoFileSelect"], usesInheritance: true, ngImport: i0, template: `
        <ng-container kendoFileSelectLocalizedMessages
          i18n-dropFilesHere="kendo.fileselect.dropFilesHere|The drop zone hint"
          dropFilesHere="Drop files here to select"
        
          i18n-invalidFileExtension="kendo.fileselect.invalidFileExtension|The text for the invalid allowed extensions restriction message"
          invalidFileExtension="File type not allowed."
        
          i18n-invalidMaxFileSize="kendo.fileselect.invalidMaxFileSize|The text for the invalid max file size restriction message"
          invalidMaxFileSize="File size too large."
        
          i18n-invalidMinFileSize="kendo.fileselect.invalidMinFileSize|The text for the invalid min file size restriction message"
          invalidMinFileSize="File size too small."
        
          i18n-remove="kendo.fileselect.remove|The text for the Remove button"
          remove="Remove"
        
          i18n-select="kendo.fileselect.select|The text for the Select button"
          select="Select files..."
          >
        </ng-container>
        <div kendoFileSelectInternalDropZone
          [restrictions]="restrictions"
          [multiple]="multiple"
          [disabled]="disabled">
          <div class="k-upload-button-wrap">
            <button
              kendoButton
              #fileSelectButton
              class="k-upload-button"
              type="button"
              role="button"
              (click)="fileSelectInput.click()"
              (focus)="onFileSelectButtonFocus()"
              [id]="focusableId"
              [attr.aria-label]="textFor('select')"
              [attr.tabindex]="tabindex"
              [attr.aria-expanded]="hasFileList"
              [attr.aria-controls]="hasFileList ? fileListId : undefined"
              >
              {{textFor('select')}}
            </button>
            <input kendoFileSelect #fileSelectInput
              [dir]="direction"
              [accept]="accept"
              [restrictions]="restrictions"
              [multiple]="multiple"
              [disabled]="disabled"
              [required]="isControlRequired"
              />
          </div>
          <div class="k-dropzone-hint">{{textFor('dropFilesHere')}}</div>
        </div>
        @if (hasFileList) {
          <ul kendo-upload-file-list
            class="k-upload-files k-reset"
            [disabled]="disabled"
            [fileList]="fileList.files"
            [fileTemplate]="fileTemplate"
            [fileInfoTemplate]="fileInfoTemplate"
            [id]="fileListId">
          </ul>
        }
        `, isInline: true, dependencies: [{ kind: "directive", type: LocalizedMessagesDirective, selector: "\n    [kendoUploadLocalizedMessages],\n    [kendoFileSelectLocalizedMessages],\n    [kendoUploadDropZoneLocalizedMessages]\n  " }, { kind: "directive", type: DropZoneInternalDirective, selector: "\n      [kendoUploadInternalDropZone],\n      [kendoFileSelectInternalDropZone]\n    ", inputs: ["disabled", "multiple", "restrictions"] }, { kind: "component", type: ButtonComponent, selector: "button[kendoButton]", inputs: ["arrowIcon", "toggleable", "togglable", "selected", "tabIndex", "imageUrl", "iconClass", "icon", "disabled", "size", "rounded", "fillMode", "themeColor", "svgIcon", "primary", "look"], outputs: ["selectedChange", "click"], exportAs: ["kendoButton"] }, { kind: "directive", type: FileSelectDirective, selector: "[kendoFileSelect]", inputs: ["dir", "disabled", "multiple", "restrictions", "accept", "required"] }, { kind: "component", type: FileListComponent, selector: "[kendo-upload-file-list]", inputs: ["disabled", "fileList", "fileTemplate", "fileInfoTemplate"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FileSelectComponent, decorators: [{
            type: Component,
            args: [{
                    exportAs: 'kendoFileSelect',
                    providers: [
                        LocalizationService,
                        NavigationService,
                        UploadService,
                        DropZoneService,
                        FILESELECT_VALUE_ACCESSOR,
                        {
                            provide: L10N_PREFIX,
                            useValue: 'kendo.fileselect'
                        },
                        {
                            provide: KendoInput,
                            useExisting: forwardRef(() => FileSelectComponent)
                        }
                    ],
                    selector: 'kendo-fileselect',
                    template: `
        <ng-container kendoFileSelectLocalizedMessages
          i18n-dropFilesHere="kendo.fileselect.dropFilesHere|The drop zone hint"
          dropFilesHere="Drop files here to select"
        
          i18n-invalidFileExtension="kendo.fileselect.invalidFileExtension|The text for the invalid allowed extensions restriction message"
          invalidFileExtension="File type not allowed."
        
          i18n-invalidMaxFileSize="kendo.fileselect.invalidMaxFileSize|The text for the invalid max file size restriction message"
          invalidMaxFileSize="File size too large."
        
          i18n-invalidMinFileSize="kendo.fileselect.invalidMinFileSize|The text for the invalid min file size restriction message"
          invalidMinFileSize="File size too small."
        
          i18n-remove="kendo.fileselect.remove|The text for the Remove button"
          remove="Remove"
        
          i18n-select="kendo.fileselect.select|The text for the Select button"
          select="Select files..."
          >
        </ng-container>
        <div kendoFileSelectInternalDropZone
          [restrictions]="restrictions"
          [multiple]="multiple"
          [disabled]="disabled">
          <div class="k-upload-button-wrap">
            <button
              kendoButton
              #fileSelectButton
              class="k-upload-button"
              type="button"
              role="button"
              (click)="fileSelectInput.click()"
              (focus)="onFileSelectButtonFocus()"
              [id]="focusableId"
              [attr.aria-label]="textFor('select')"
              [attr.tabindex]="tabindex"
              [attr.aria-expanded]="hasFileList"
              [attr.aria-controls]="hasFileList ? fileListId : undefined"
              >
              {{textFor('select')}}
            </button>
            <input kendoFileSelect #fileSelectInput
              [dir]="direction"
              [accept]="accept"
              [restrictions]="restrictions"
              [multiple]="multiple"
              [disabled]="disabled"
              [required]="isControlRequired"
              />
          </div>
          <div class="k-dropzone-hint">{{textFor('dropFilesHere')}}</div>
        </div>
        @if (hasFileList) {
          <ul kendo-upload-file-list
            class="k-upload-files k-reset"
            [disabled]="disabled"
            [fileList]="fileList.files"
            [fileTemplate]="fileTemplate"
            [fileInfoTemplate]="fileInfoTemplate"
            [id]="fileListId">
          </ul>
        }
        `,
                    standalone: true,
                    imports: [LocalizedMessagesDirective, DropZoneInternalDirective, ButtonComponent, FileSelectDirective, FileListComponent]
                }]
        }], ctorParameters: () => [{ type: UploadService }, { type: i1$1.LocalizationService }, { type: NavigationService }, { type: DropZoneService }, { type: i0.NgZone }, { type: i0.Renderer2 }, { type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.Injector }], propDecorators: { fileSelectInput: [{
                type: ViewChild,
                args: ['fileSelectInput', { static: true }]
            }], dir: [{
                type: HostBinding,
                args: ['attr.dir']
            }], name: [{
                type: Input
            }], valueChange: [{
                type: Output
            }] } });

/**
 * Custom component messages override default component messages ([more information and example]({% slug globalization_upload %})).
 *
 * @example
 * ```html
 * <!-- Custom messages for FileSelect -->
 * <kendo-fileselect>
 *     <kendo-fileselect-messages
 *         dropFilesHere="Drop your file here"
 *         select="Upload file">
 *     </kendo-fileselect-messages>
 * </kendo-fileselect>
 *
 * <!-- Custom messages for Upload -->
 * <kendo-upload>
 *     <kendo-upload-messages
 *         dropFilesHere="Drop your file here"
 *         fileStatusFailed="File upload failed"
 *         fileStatusSuccessful="File upload successful">
 *     </kendo-upload-messages>
 * </kendo-upload>
 *
 * <!-- Custom messages for UploadDropZone -->
 * <kendo-uploaddropzone>
 *     <kendo-uploaddropzone-messages
 *         externalDropFilesHere="Drag and your file here">
 *     </kendo-uploaddropzone-messages>
 * </kendo-uploaddropzone>
 * ```
 */
class CustomMessagesComponent extends Messages {
    service;
    get override() {
        return true;
    }
    constructor(service) {
        super();
        this.service = service;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CustomMessagesComponent, deps: [{ token: i1$1.LocalizationService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.18", type: CustomMessagesComponent, isStandalone: true, selector: "kendo-upload-messages, kendo-fileselect-messages, kendo-uploaddropzone-messages", providers: [
            {
                provide: Messages,
                useExisting: forwardRef(() => CustomMessagesComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: CustomMessagesComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: Messages,
                            useExisting: forwardRef(() => CustomMessagesComponent)
                        }
                    ],
                    selector: 'kendo-upload-messages, kendo-fileselect-messages, kendo-uploaddropzone-messages',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1$1.LocalizationService }] });

/**
 * Use the `KENDO_FILESELECT` utility array to add all FileSelect-related components and directives to a standalone Angular component.
 *
 * @example
 * ```typescript
 * import { Component } from '@angular/core';
 * import { KENDO_FILESELECT } from '@progress/kendo-angular-upload';
 *
 * @Component({
 *   selector: 'my-app',
 *   standalone: true,
 *   imports: [KENDO_FILESELECT],
 *   template: `<kendo-fileselect></kendo-fileselect>`
 * })
 * export class AppComponent {}
 * ```
 */
const KENDO_FILESELECT = [
    FileSelectComponent,
    FileTemplateDirective,
    FileInfoTemplateDirective,
    CustomMessagesComponent,
    UploadDropZoneDirective,
    UploadDropZoneComponent
];
/**
 * Use the `KENDO_UPLOAD` utility array to add all Upload-related components and directives to a standalone Angular component.
 *
 * @example
 * ```typescript
 * import { Component } from '@angular/core';
 * import { KENDO_UPLOAD } from '@progress/kendo-angular-upload';
 *
 * @Component({
 *   selector: 'my-app',
 *   standalone: true,
 *   imports: [KENDO_UPLOAD],
 *   template: `<kendo-upload></kendo-upload>`
 * })
 * export class AppComponent {}
 * ```
 */
const KENDO_UPLOAD = [
    UploadComponent,
    UploadActionButtonsComponent,
    UploadStatusTotalComponent,
    FileTemplateDirective,
    FileInfoTemplateDirective,
    CustomMessagesComponent,
    UploadDropZoneDirective,
    UploadDropZoneComponent
];
/**
 * Use the `KENDO_UPLOADS` utility array to add all `@progress/kendo-angular-upload`-related components and directives to a standalone Angular component.
 *
 * @example
 * ```typescript
 * import { Component } from '@angular/core';
 * import { KENDO_UPLOADS } from '@progress/kendo-angular-upload';
 *
 * @Component({
 *   selector: 'my-app',
 *   standalone: true,
 *   imports: [KENDO_UPLOADS],
 *   template: `
 *      <kendo-upload></kendo-upload>
 *      <kendo-fileselect></kendo-fileselect>
 *   `
 * })
 * export class AppComponent {}
 * ```
 */
const KENDO_UPLOADS = [
    ...KENDO_FILESELECT,
    ...KENDO_UPLOAD
];

// IMPORTANT: NgModule export kept for backwards compatibility
/**
 * Represents the [NgModule](https://angular.io/api/core/NgModule) definition for the FileSelect component.
 */
class FileSelectModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FileSelectModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.18", ngImport: i0, type: FileSelectModule, imports: [FileSelectComponent, FileTemplateDirective, FileInfoTemplateDirective, CustomMessagesComponent, UploadDropZoneDirective, UploadDropZoneComponent], exports: [FileSelectComponent, FileTemplateDirective, FileInfoTemplateDirective, CustomMessagesComponent, UploadDropZoneDirective, UploadDropZoneComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FileSelectModule, providers: [
            IconsService,
            PopupService,
            ResizeBatchService
        ], imports: [FileSelectComponent, UploadDropZoneComponent] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: FileSelectModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [...KENDO_FILESELECT],
                    imports: [...KENDO_FILESELECT],
                    providers: [
                        IconsService,
                        PopupService,
                        ResizeBatchService
                    ]
                }]
        }] });

// IMPORTANT: NgModule export kept for backwards compatibility
/**
 * Represents the [NgModule](https://angular.io/api/core/NgModule) definition for the Upload component.
 */
class UploadModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: UploadModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.18", ngImport: i0, type: UploadModule, imports: [UploadComponent, UploadActionButtonsComponent, UploadStatusTotalComponent, FileTemplateDirective, FileInfoTemplateDirective, CustomMessagesComponent, UploadDropZoneDirective, UploadDropZoneComponent], exports: [UploadComponent, UploadActionButtonsComponent, UploadStatusTotalComponent, FileTemplateDirective, FileInfoTemplateDirective, CustomMessagesComponent, UploadDropZoneDirective, UploadDropZoneComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: UploadModule, providers: [
            IconsService,
            PopupService,
            ResizeBatchService
        ], imports: [UploadComponent, UploadStatusTotalComponent, UploadDropZoneComponent] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: UploadModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [...KENDO_UPLOAD],
                    imports: [...KENDO_UPLOAD],
                    providers: [
                        IconsService,
                        PopupService,
                        ResizeBatchService
                    ]
                }]
        }] });

// IMPORTANT: NgModule export kept for backwards compatibility
/**
 * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi'])
 * definition for the Uploads components.
 *
 * @example
 *
 * ```ts-no-run
 * import { UploadsModule } from '@progress/kendo-angular-upload';
 *
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 * import { NgModule } from '@angular/core';
 *
 * import { AppComponent } from './app.component';
 *
 * _@NgModule({
 *     declarations: [AppComponent],
 *     imports:      [BrowserModule, UploadsModule],
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
class UploadsModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: UploadsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.18", ngImport: i0, type: UploadsModule, imports: [FileSelectComponent, FileTemplateDirective, FileInfoTemplateDirective, CustomMessagesComponent, UploadDropZoneDirective, UploadDropZoneComponent, UploadComponent, UploadActionButtonsComponent, UploadStatusTotalComponent, FileTemplateDirective, FileInfoTemplateDirective, CustomMessagesComponent, UploadDropZoneDirective, UploadDropZoneComponent], exports: [FileSelectComponent, FileTemplateDirective, FileInfoTemplateDirective, CustomMessagesComponent, UploadDropZoneDirective, UploadDropZoneComponent, UploadComponent, UploadActionButtonsComponent, UploadStatusTotalComponent, FileTemplateDirective, FileInfoTemplateDirective, CustomMessagesComponent, UploadDropZoneDirective, UploadDropZoneComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: UploadsModule, providers: [
            IconsService,
            PopupService,
            ResizeBatchService
        ], imports: [FileSelectComponent, UploadDropZoneComponent, UploadComponent, UploadStatusTotalComponent, UploadDropZoneComponent] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.18", ngImport: i0, type: UploadsModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [...KENDO_UPLOADS],
                    imports: [...KENDO_UPLOADS],
                    providers: [
                        IconsService,
                        PopupService,
                        ResizeBatchService
                    ]
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { CancelEvent, ClearEvent, CustomMessagesComponent, DropZoneService, ErrorEvent, FileInfoTemplateDirective, FileListComponent, FileListItemActionButtonComponent, FileListItemBase, FileListMultipleItemsComponent, FileListSingleItemComponent, FileMap, FileSelectComponent, FileSelectDirective, FileSelectModule, FileState, FileTemplateDirective, KENDO_FILESELECT, KENDO_UPLOAD, KENDO_UPLOADS, NavigationService, PauseEvent, RemoveEvent, ResumeEvent, SelectEvent, SuccessEvent, UPLOAD_VALUE_ACCESSOR, UploadActionButtonsComponent, UploadComponent, UploadDropZoneComponent, UploadDropZoneDirective, UploadEvent, UploadModule, UploadProgressEvent, UploadService, UploadStatusTotalComponent, UploadsModule, fileGroupClass, fileSVGGroupIcon, getTotalFilesSizeMessage, validateFiles };

