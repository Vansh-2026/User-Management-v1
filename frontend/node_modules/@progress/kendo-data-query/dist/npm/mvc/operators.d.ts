import { State } from '../state';
import { AggregateDescriptor } from '../grouping/aggregate.operators';
/**
 * Represents the state required by the [`toDataSourceRequest`]({% slug api_kendo-data-query_todatasourcerequest %})
 * and [`toDataSourceRequestString`]({% slug api_kendo-data-query_todatasourcerequeststring %}) methods.
 *
 * The `DataSourceRequestState` is an extension of the [`State`]({% slug api_kendo-data-query_state %}) type
 * with an additional `aggregates` field&mdash;an array of [`AggregateDescriptor`]({% slug api_kendo-data-query_aggregatedescriptor %}).
 *
 * The aggregates field is required for serialization of aggregate descriptors in the request and does not replace the `aggregate` field
 * of the [`GroupDescriptor`]({% slug api_kendo-data-query_groupdescriptor %}) used by the `group` field.
 *
 * ```ts
 * import { DataSourceRequestState } from '@progress/kendo-data-query';
 *
 * const state: DataSourceRequestState = {
 *     skip: 0,
 *     take: 10,
 *     sort: [{ field: 'ProductName', dir: 'asc' }],
 *     group: [
 *         {
 *             field: 'Category',
 *             aggregates: [{ field: 'UnitPrice', aggregate: 'sum' }] // GroupDescriptor aggregates
 *         }
 *     ],
 *     aggregates: [{ field: 'UnitPrice', aggregate: 'sum' }] // DataSourceRequestState aggregates
 * };
 * ```
 */
export type DataSourceRequestState = State & {
    /**
     * The descriptors used for aggregation.
     * @type {Array<AggregateDescriptor>}
     */
    aggregates?: Array<AggregateDescriptor>;
};
/**
 * Converts a [`DataSourceRequestState`]({% slug api_kendo-data-query_datasourcerequeststate %}) into a string
 * that is comparable with the `DataSourceRequest` format in UI for ASP.NET MVC.
 *
 * @param {DataSourceRequestState} state The state that will be serialized.
 * @returns {string} The serialized state.
 *
 * The following code snippet demonstrates how to use the `toDataSourceRequestString` method.
 *
 * {% platform_content angular %}
 * ```ts
 * import { HttpClient } from '@angular/common/http';
 * import { Observable } from 'rxjs';
 * import { map } from 'rxjs/operators';
 * import {
 *     DataSourceRequestState,
 *     toDataSourceRequestString,
 *     translateDataSourceResultGroups,
 *     translateAggregateResults
 * } from '@progress/kendo-data-query';
 *
 * export class ProductService {
 *     private BASE_URL = 'https://api.example.com/products';
 *
 *     constructor(private http: HttpClient) { }
 *
 *     public fetch(state: DataSourceRequestState): Observable<GridDataResult> {
 *
 *         // DataSourceRequestState includes:
 *         // - State properties: skip, take, sort, filter, group
 *         // - Additional property: aggregates
 *         const queryString = toDataSourceRequestString(state);
 *
 *         const hasGroups = state.group && state.group.length;
 *
 *         return this.http
 *             .get<ServerResponse>(`${this.BASE_URL}?${queryString}`)
 *             .pipe(
 *                 map(({ Data, Total, AggregateResults }) => ({
 *                     data: hasGroups ? translateDataSourceResultGroups(Data) : Data,
 *                     total: Total,
 *                     aggregateResult: translateAggregateResults(AggregateResults)
 *                 }))
 *             );
 *     }
 * }
 * ```
 * {% endplatform_content %}
 *
 * {% platform_content react %}
 * ```jsx
 * import React from 'react';
 * import { toDataSourceRequestString, translateDataSourceResultGroups } from '@progress/kendo-data-query';
 *
 * export function withState(WrappedGrid) {
 *     return class StatefullGrid extends React.Component {
 *         constructor(props) {
 *             super(props);
 *             // DataSourceRequestState includes:
 *             // - State properties: skip, take, sort, filter, group
 *             // - Additional property: aggregates
 *             this.state = { dataState: { skip: 0, take: 20 } };
 *         }
 *
 *         render() {
 *             return (
 *                 <WrappedGrid
 *                     filterable={true}
 *                     sortable={true}
 *                     pageable={{ pageSizes: true }}
 *                     {...this.props}
 *                     total={this.state.total}
 *                     data={this.state.data}
 *                     skip={this.state.dataState.skip}
 *                     pageSize={this.state.dataState.take}
 *                     filter={this.state.dataState.filter}
 *                     sort={this.state.dataState.sort}
 *                     dataStateChange={this.dataStateChange}
 *                 />
 *             );
 *         }
 *
 *         componentDidMount() {
 *             this.fetchData(this.state.dataState);
 *         }
 *
 *         dataStateChange = (changeEvent) => {
 *             this.setState({ dataState: changeEvent.data });
 *             this.fetchData(changeEvent.data);
 *         }
 *
 *         fetchData(dataState) {
 *             // DataSourceRequestState includes:
 *             // - State properties: skip, take, sort, filter, group
 *             // - Additional property: aggregates
 *             const queryStr = `${toDataSourceRequestString(dataState)}`; // Serialize the state
 *             const hasGroups = dataState.group && dataState.group.length;
 *
 *             const base_url = 'api/Products';
 *             const init = { method: 'GET', accept: 'application/json', headers: {} };
 *
 *             fetch(`${base_url}?${queryStr}`, init)
 *                 .then(response => response.json())
 *                 .then(({ data, total }) => {
 *                     this.setState({
 *                         data: hasGroups ? translateDataSourceResultGroups(data) : data,
 *                         total,
 *                         dataState
 *                     });
 *                 });
 *         }
 *     }
 * }
 * ```
 * {% endplatform_content %}
 */
export declare const toDataSourceRequestString: (state: DataSourceRequestState) => string;
/**
 * Converts a [`DataSourceRequestState`]({% slug api_kendo-data-query_datasourcerequeststate %}) into an object
 * that is compatible with the `DataSourceRequest` format in UI for ASP.NET MVC.
 *
 * @param {DataSourceRequestState} state The state that will be serialized.
 * @returns {any} The serialized state.
 *
 * The following code snippet demonstrates how to use the `toDataSourceRequest` method.
 *
 * {% platform_content angular %}
 * ```ts
 * import { HttpClient } from '@angular/common/http';
 * import { Observable } from 'rxjs';
 * import { map } from 'rxjs/operators';
 * import {
 *     DataSourceRequestState,
 *     toDataSourceRequest,
 *     translateDataSourceResultGroups,
 *     translateAggregateResults
 * } from '@progress/kendo-data-query';
 *
 * export class ProductService {
 *     private BASE_URL = 'https://api.example.com/products';
 *
 *     constructor(private http: HttpClient) { }
 *
 *     public fetch(state: DataSourceRequestState): Observable<GridDataResult> {
 *
 *         // DataSourceRequestState includes:
 *         // - State properties: skip, take, sort, filter, group
 *         // - Additional property: aggregates
 *         const dataSourceRequest = toDataSourceRequest(state);
 *
 *         const hasGroups = state.group && state.group.length;
 *
 *         return this.http
 *             .post<ServerResponse>(this.BASE_URL, dataSourceRequest)
 *             .pipe(
 *                 map(({ Data, Total, AggregateResults }) => ({
 *                     data: hasGroups ? translateDataSourceResultGroups(Data) : Data,
 *                     total: Total,
 *                     aggregateResult: translateAggregateResults(AggregateResults)
 *                 }))
 *             );
 *     }
 * }
 * ```
 * {% endplatform_content %}
 */
export declare const toDataSourceRequest: (state: DataSourceRequestState) => any;
